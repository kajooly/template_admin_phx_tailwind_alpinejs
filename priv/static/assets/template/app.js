(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __defProps = Object.defineProperties;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getOwnPropSymbols = Object.getOwnPropertySymbols;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __propIsEnum = Object.prototype.propertyIsEnumerable;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues = (a, b) => {
    for (var prop in b || (b = {}))
      if (__hasOwnProp.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(b)) {
        if (__propIsEnum.call(b, prop))
          __defNormalProp(a, prop, b[prop]);
      }
    return a;
  };
  var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
  var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __reExport = (target, module, desc) => {
    if (module && typeof module === "object" || typeof module === "function") {
      for (let key of __getOwnPropNames(module))
        if (!__hasOwnProp.call(target, key) && key !== "default")
          __defProp(target, key, { get: () => module[key], enumerable: !(desc = __getOwnPropDesc(module, key)) || desc.enumerable });
    }
    return target;
  };
  var __toModule = (module) => {
    return __reExport(__markAsModule(__defProp(module != null ? __create(__getProtoOf(module)) : {}, "default", module && module.__esModule && "default" in module ? { get: () => module.default, enumerable: true } : { value: module, enumerable: true })), module);
  };

  // vendor/topbar.js
  var require_topbar = __commonJS({
    "vendor/topbar.js"(exports, module) {
      (function(window2, document2) {
        "use strict";
        (function() {
          var lastTime = 0;
          var vendors = ["ms", "moz", "webkit", "o"];
          for (var x = 0; x < vendors.length && !window2.requestAnimationFrame; ++x) {
            window2.requestAnimationFrame = window2[vendors[x] + "RequestAnimationFrame"];
            window2.cancelAnimationFrame = window2[vendors[x] + "CancelAnimationFrame"] || window2[vendors[x] + "CancelRequestAnimationFrame"];
          }
          if (!window2.requestAnimationFrame)
            window2.requestAnimationFrame = function(callback, element) {
              var currTime = new Date().getTime();
              var timeToCall = Math.max(0, 16 - (currTime - lastTime));
              var id = window2.setTimeout(function() {
                callback(currTime + timeToCall);
              }, timeToCall);
              lastTime = currTime + timeToCall;
              return id;
            };
          if (!window2.cancelAnimationFrame)
            window2.cancelAnimationFrame = function(id) {
              clearTimeout(id);
            };
        })();
        var canvas, progressTimerId, fadeTimerId, currentProgress, showing, addEvent = function(elem, type, handler3) {
          if (elem.addEventListener)
            elem.addEventListener(type, handler3, false);
          else if (elem.attachEvent)
            elem.attachEvent("on" + type, handler3);
          else
            elem["on" + type] = handler3;
        }, options = {
          autoRun: true,
          barThickness: 3,
          barColors: {
            0: "rgba(26,  188, 156, .9)",
            ".25": "rgba(52,  152, 219, .9)",
            ".50": "rgba(241, 196, 15,  .9)",
            ".75": "rgba(230, 126, 34,  .9)",
            "1.0": "rgba(211, 84,  0,   .9)"
          },
          shadowBlur: 10,
          shadowColor: "rgba(0,   0,   0,   .6)",
          className: null
        }, repaint = function() {
          canvas.width = window2.innerWidth;
          canvas.height = options.barThickness * 5;
          var ctx = canvas.getContext("2d");
          ctx.shadowBlur = options.shadowBlur;
          ctx.shadowColor = options.shadowColor;
          var lineGradient = ctx.createLinearGradient(0, 0, canvas.width, 0);
          for (var stop2 in options.barColors)
            lineGradient.addColorStop(stop2, options.barColors[stop2]);
          ctx.lineWidth = options.barThickness;
          ctx.beginPath();
          ctx.moveTo(0, options.barThickness / 2);
          ctx.lineTo(Math.ceil(currentProgress * canvas.width), options.barThickness / 2);
          ctx.strokeStyle = lineGradient;
          ctx.stroke();
        }, createCanvas = function() {
          canvas = document2.createElement("canvas");
          var style = canvas.style;
          style.position = "fixed";
          style.top = style.left = style.right = style.margin = style.padding = 0;
          style.zIndex = 100001;
          style.display = "none";
          if (options.className)
            canvas.classList.add(options.className);
          document2.body.appendChild(canvas);
          addEvent(window2, "resize", repaint);
        }, topbar2 = {
          config: function(opts) {
            for (var key in opts)
              if (options.hasOwnProperty(key))
                options[key] = opts[key];
          },
          show: function() {
            if (showing)
              return;
            showing = true;
            if (fadeTimerId !== null)
              window2.cancelAnimationFrame(fadeTimerId);
            if (!canvas)
              createCanvas();
            canvas.style.opacity = 1;
            canvas.style.display = "block";
            topbar2.progress(0);
            if (options.autoRun) {
              (function loop2() {
                progressTimerId = window2.requestAnimationFrame(loop2);
                topbar2.progress("+" + 0.05 * Math.pow(1 - Math.sqrt(currentProgress), 2));
              })();
            }
          },
          progress: function(to) {
            if (typeof to === "undefined")
              return currentProgress;
            if (typeof to === "string") {
              to = (to.indexOf("+") >= 0 || to.indexOf("-") >= 0 ? currentProgress : 0) + parseFloat(to);
            }
            currentProgress = to > 1 ? 1 : to;
            repaint();
            return currentProgress;
          },
          hide: function() {
            if (!showing)
              return;
            showing = false;
            if (progressTimerId != null) {
              window2.cancelAnimationFrame(progressTimerId);
              progressTimerId = null;
            }
            (function loop2() {
              if (topbar2.progress("+.1") >= 1) {
                canvas.style.opacity -= 0.05;
                if (canvas.style.opacity <= 0.05) {
                  canvas.style.display = "none";
                  fadeTimerId = null;
                  return;
                }
              }
              fadeTimerId = window2.requestAnimationFrame(loop2);
            })();
          }
        };
        if (typeof module === "object" && typeof module.exports === "object") {
          module.exports = topbar2;
        } else if (typeof define === "function" && define.amd) {
          define(function() {
            return topbar2;
          });
        } else {
          this.topbar = topbar2;
        }
      }).call(exports, window, document);
    }
  });

  // node_modules/html5-qrcode/third_party/zxing-js.umd.js
  var require_zxing_js_umd = __commonJS({
    "node_modules/html5-qrcode/third_party/zxing-js.umd.js"(exports, module) {
      (function(global3, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global3 = typeof globalThis !== "undefined" ? globalThis : global3 || self, factory(global3.ZXing = {}));
      })(exports, function(exports2) {
        "use strict";
        function isNullOrUndefined2(obj) {
          return obj === null || obj === void 0;
        }
        var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
          d.__proto__ = b;
        } || function(d, b) {
          for (var p in b)
            if (b.hasOwnProperty(p))
              d[p] = b[p];
        };
        function __extends3(d, b) {
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        }
        function fixProto(target, prototype) {
          var setPrototypeOf = Object.setPrototypeOf;
          setPrototypeOf ? setPrototypeOf(target, prototype) : target.__proto__ = prototype;
        }
        function fixStack(target, fn) {
          if (fn === void 0) {
            fn = target.constructor;
          }
          var captureStackTrace = Error.captureStackTrace;
          captureStackTrace && captureStackTrace(target, fn);
        }
        var CustomError = function(_super) {
          __extends3(CustomError2, _super);
          function CustomError2(message) {
            var _newTarget = this.constructor;
            var _this = _super.call(this, message) || this;
            Object.defineProperty(_this, "name", {
              value: _newTarget.name,
              enumerable: false
            });
            fixProto(_this, _newTarget.prototype);
            fixStack(_this);
            return _this;
          }
          return CustomError2;
        }(Error);
        class Exception extends CustomError {
          constructor(message = void 0) {
            super(message);
            this.message = message;
          }
          getKind() {
            const ex = this.constructor;
            return ex.kind;
          }
        }
        Exception.kind = "Exception";
        class ArgumentException extends Exception {
        }
        ArgumentException.kind = "ArgumentException";
        class IllegalArgumentException extends Exception {
        }
        IllegalArgumentException.kind = "IllegalArgumentException";
        class BinaryBitmap {
          constructor(binarizer) {
            this.binarizer = binarizer;
            if (binarizer === null) {
              throw new IllegalArgumentException("Binarizer must be non-null.");
            }
          }
          getWidth() {
            return this.binarizer.getWidth();
          }
          getHeight() {
            return this.binarizer.getHeight();
          }
          getBlackRow(y, row) {
            return this.binarizer.getBlackRow(y, row);
          }
          getBlackMatrix() {
            if (this.matrix === null || this.matrix === void 0) {
              this.matrix = this.binarizer.getBlackMatrix();
            }
            return this.matrix;
          }
          isCropSupported() {
            return this.binarizer.getLuminanceSource().isCropSupported();
          }
          crop(left, top, width, height) {
            const newSource = this.binarizer.getLuminanceSource().crop(left, top, width, height);
            return new BinaryBitmap(this.binarizer.createBinarizer(newSource));
          }
          isRotateSupported() {
            return this.binarizer.getLuminanceSource().isRotateSupported();
          }
          rotateCounterClockwise() {
            const newSource = this.binarizer.getLuminanceSource().rotateCounterClockwise();
            return new BinaryBitmap(this.binarizer.createBinarizer(newSource));
          }
          rotateCounterClockwise45() {
            const newSource = this.binarizer.getLuminanceSource().rotateCounterClockwise45();
            return new BinaryBitmap(this.binarizer.createBinarizer(newSource));
          }
          toString() {
            try {
              return this.getBlackMatrix().toString();
            } catch (e) {
              return "";
            }
          }
        }
        class ChecksumException extends Exception {
          static getChecksumInstance() {
            return new ChecksumException();
          }
        }
        ChecksumException.kind = "ChecksumException";
        class Binarizer {
          constructor(source) {
            this.source = source;
          }
          getLuminanceSource() {
            return this.source;
          }
          getWidth() {
            return this.source.getWidth();
          }
          getHeight() {
            return this.source.getHeight();
          }
        }
        class System {
          static arraycopy(src, srcPos, dest, destPos, length) {
            while (length--) {
              dest[destPos++] = src[srcPos++];
            }
          }
          static currentTimeMillis() {
            return Date.now();
          }
        }
        class IndexOutOfBoundsException extends Exception {
        }
        IndexOutOfBoundsException.kind = "IndexOutOfBoundsException";
        class ArrayIndexOutOfBoundsException extends IndexOutOfBoundsException {
          constructor(index = void 0, message = void 0) {
            super(message);
            this.index = index;
            this.message = message;
          }
        }
        ArrayIndexOutOfBoundsException.kind = "ArrayIndexOutOfBoundsException";
        class Arrays {
          static fill(a, val) {
            for (let i = 0, len = a.length; i < len; i++)
              a[i] = val;
          }
          static fillWithin(a, fromIndex, toIndex, val) {
            Arrays.rangeCheck(a.length, fromIndex, toIndex);
            for (let i = fromIndex; i < toIndex; i++)
              a[i] = val;
          }
          static rangeCheck(arrayLength, fromIndex, toIndex) {
            if (fromIndex > toIndex) {
              throw new IllegalArgumentException("fromIndex(" + fromIndex + ") > toIndex(" + toIndex + ")");
            }
            if (fromIndex < 0) {
              throw new ArrayIndexOutOfBoundsException(fromIndex);
            }
            if (toIndex > arrayLength) {
              throw new ArrayIndexOutOfBoundsException(toIndex);
            }
          }
          static asList(...args) {
            return args;
          }
          static create(rows, cols, value) {
            let arr = Array.from({ length: rows });
            return arr.map((x) => Array.from({ length: cols }).fill(value));
          }
          static createInt32Array(rows, cols, value) {
            let arr = Array.from({ length: rows });
            return arr.map((x) => Int32Array.from({ length: cols }).fill(value));
          }
          static equals(first, second) {
            if (!first) {
              return false;
            }
            if (!second) {
              return false;
            }
            if (!first.length) {
              return false;
            }
            if (!second.length) {
              return false;
            }
            if (first.length !== second.length) {
              return false;
            }
            for (let i = 0, length = first.length; i < length; i++) {
              if (first[i] !== second[i]) {
                return false;
              }
            }
            return true;
          }
          static hashCode(a) {
            if (a === null) {
              return 0;
            }
            let result = 1;
            for (const element of a) {
              result = 31 * result + element;
            }
            return result;
          }
          static fillUint8Array(a, value) {
            for (let i = 0; i !== a.length; i++) {
              a[i] = value;
            }
          }
          static copyOf(original, newLength) {
            return original.slice(0, newLength);
          }
          static copyOfUint8Array(original, newLength) {
            if (original.length <= newLength) {
              const newArray = new Uint8Array(newLength);
              newArray.set(original);
              return newArray;
            }
            return original.slice(0, newLength);
          }
          static copyOfRange(original, from, to) {
            const newLength = to - from;
            const copy = new Int32Array(newLength);
            System.arraycopy(original, from, copy, 0, newLength);
            return copy;
          }
          static binarySearch(ar, el, comparator) {
            if (comparator === void 0) {
              comparator = Arrays.numberComparator;
            }
            let m = 0;
            let n = ar.length - 1;
            while (m <= n) {
              const k = n + m >> 1;
              const cmp = comparator(el, ar[k]);
              if (cmp > 0) {
                m = k + 1;
              } else if (cmp < 0) {
                n = k - 1;
              } else {
                return k;
              }
            }
            return -m - 1;
          }
          static numberComparator(a, b) {
            return a - b;
          }
        }
        class Integer {
          static numberOfTrailingZeros(i) {
            let y;
            if (i === 0)
              return 32;
            let n = 31;
            y = i << 16;
            if (y !== 0) {
              n -= 16;
              i = y;
            }
            y = i << 8;
            if (y !== 0) {
              n -= 8;
              i = y;
            }
            y = i << 4;
            if (y !== 0) {
              n -= 4;
              i = y;
            }
            y = i << 2;
            if (y !== 0) {
              n -= 2;
              i = y;
            }
            return n - (i << 1 >>> 31);
          }
          static numberOfLeadingZeros(i) {
            if (i === 0) {
              return 32;
            }
            let n = 1;
            if (i >>> 16 === 0) {
              n += 16;
              i <<= 16;
            }
            if (i >>> 24 === 0) {
              n += 8;
              i <<= 8;
            }
            if (i >>> 28 === 0) {
              n += 4;
              i <<= 4;
            }
            if (i >>> 30 === 0) {
              n += 2;
              i <<= 2;
            }
            n -= i >>> 31;
            return n;
          }
          static toHexString(i) {
            return i.toString(16);
          }
          static toBinaryString(intNumber) {
            return String(parseInt(String(intNumber), 2));
          }
          static bitCount(i) {
            i = i - (i >>> 1 & 1431655765);
            i = (i & 858993459) + (i >>> 2 & 858993459);
            i = i + (i >>> 4) & 252645135;
            i = i + (i >>> 8);
            i = i + (i >>> 16);
            return i & 63;
          }
          static truncDivision(dividend, divisor) {
            return Math.trunc(dividend / divisor);
          }
          static parseInt(num, radix = void 0) {
            return parseInt(num, radix);
          }
        }
        Integer.MIN_VALUE_32_BITS = -2147483648;
        Integer.MAX_VALUE = Number.MAX_SAFE_INTEGER;
        class BitArray {
          constructor(size2, bits) {
            if (size2 === void 0) {
              this.size = 0;
              this.bits = new Int32Array(1);
            } else {
              this.size = size2;
              if (bits === void 0 || bits === null) {
                this.bits = BitArray.makeArray(size2);
              } else {
                this.bits = bits;
              }
            }
          }
          getSize() {
            return this.size;
          }
          getSizeInBytes() {
            return Math.floor((this.size + 7) / 8);
          }
          ensureCapacity(size2) {
            if (size2 > this.bits.length * 32) {
              const newBits = BitArray.makeArray(size2);
              System.arraycopy(this.bits, 0, newBits, 0, this.bits.length);
              this.bits = newBits;
            }
          }
          get(i) {
            return (this.bits[Math.floor(i / 32)] & 1 << (i & 31)) !== 0;
          }
          set(i) {
            this.bits[Math.floor(i / 32)] |= 1 << (i & 31);
          }
          flip(i) {
            this.bits[Math.floor(i / 32)] ^= 1 << (i & 31);
          }
          getNextSet(from) {
            const size2 = this.size;
            if (from >= size2) {
              return size2;
            }
            const bits = this.bits;
            let bitsOffset = Math.floor(from / 32);
            let currentBits = bits[bitsOffset];
            currentBits &= ~((1 << (from & 31)) - 1);
            const length = bits.length;
            while (currentBits === 0) {
              if (++bitsOffset === length) {
                return size2;
              }
              currentBits = bits[bitsOffset];
            }
            const result = bitsOffset * 32 + Integer.numberOfTrailingZeros(currentBits);
            return result > size2 ? size2 : result;
          }
          getNextUnset(from) {
            const size2 = this.size;
            if (from >= size2) {
              return size2;
            }
            const bits = this.bits;
            let bitsOffset = Math.floor(from / 32);
            let currentBits = ~bits[bitsOffset];
            currentBits &= ~((1 << (from & 31)) - 1);
            const length = bits.length;
            while (currentBits === 0) {
              if (++bitsOffset === length) {
                return size2;
              }
              currentBits = ~bits[bitsOffset];
            }
            const result = bitsOffset * 32 + Integer.numberOfTrailingZeros(currentBits);
            return result > size2 ? size2 : result;
          }
          setBulk(i, newBits) {
            this.bits[Math.floor(i / 32)] = newBits;
          }
          setRange(start2, end) {
            if (end < start2 || start2 < 0 || end > this.size) {
              throw new IllegalArgumentException();
            }
            if (end === start2) {
              return;
            }
            end--;
            const firstInt = Math.floor(start2 / 32);
            const lastInt = Math.floor(end / 32);
            const bits = this.bits;
            for (let i = firstInt; i <= lastInt; i++) {
              const firstBit = i > firstInt ? 0 : start2 & 31;
              const lastBit = i < lastInt ? 31 : end & 31;
              const mask = (2 << lastBit) - (1 << firstBit);
              bits[i] |= mask;
            }
          }
          clear() {
            const max = this.bits.length;
            const bits = this.bits;
            for (let i = 0; i < max; i++) {
              bits[i] = 0;
            }
          }
          isRange(start2, end, value) {
            if (end < start2 || start2 < 0 || end > this.size) {
              throw new IllegalArgumentException();
            }
            if (end === start2) {
              return true;
            }
            end--;
            const firstInt = Math.floor(start2 / 32);
            const lastInt = Math.floor(end / 32);
            const bits = this.bits;
            for (let i = firstInt; i <= lastInt; i++) {
              const firstBit = i > firstInt ? 0 : start2 & 31;
              const lastBit = i < lastInt ? 31 : end & 31;
              const mask = (2 << lastBit) - (1 << firstBit) & 4294967295;
              if ((bits[i] & mask) !== (value ? mask : 0)) {
                return false;
              }
            }
            return true;
          }
          appendBit(bit) {
            this.ensureCapacity(this.size + 1);
            if (bit) {
              this.bits[Math.floor(this.size / 32)] |= 1 << (this.size & 31);
            }
            this.size++;
          }
          appendBits(value, numBits) {
            if (numBits < 0 || numBits > 32) {
              throw new IllegalArgumentException("Num bits must be between 0 and 32");
            }
            this.ensureCapacity(this.size + numBits);
            for (let numBitsLeft = numBits; numBitsLeft > 0; numBitsLeft--) {
              this.appendBit((value >> numBitsLeft - 1 & 1) === 1);
            }
          }
          appendBitArray(other) {
            const otherSize = other.size;
            this.ensureCapacity(this.size + otherSize);
            for (let i = 0; i < otherSize; i++) {
              this.appendBit(other.get(i));
            }
          }
          xor(other) {
            if (this.size !== other.size) {
              throw new IllegalArgumentException("Sizes don't match");
            }
            const bits = this.bits;
            for (let i = 0, length = bits.length; i < length; i++) {
              bits[i] ^= other.bits[i];
            }
          }
          toBytes(bitOffset, array, offset, numBytes) {
            for (let i = 0; i < numBytes; i++) {
              let theByte = 0;
              for (let j = 0; j < 8; j++) {
                if (this.get(bitOffset)) {
                  theByte |= 1 << 7 - j;
                }
                bitOffset++;
              }
              array[offset + i] = theByte;
            }
          }
          getBitArray() {
            return this.bits;
          }
          reverse() {
            const newBits = new Int32Array(this.bits.length);
            const len = Math.floor((this.size - 1) / 32);
            const oldBitsLen = len + 1;
            const bits = this.bits;
            for (let i = 0; i < oldBitsLen; i++) {
              let x = bits[i];
              x = x >> 1 & 1431655765 | (x & 1431655765) << 1;
              x = x >> 2 & 858993459 | (x & 858993459) << 2;
              x = x >> 4 & 252645135 | (x & 252645135) << 4;
              x = x >> 8 & 16711935 | (x & 16711935) << 8;
              x = x >> 16 & 65535 | (x & 65535) << 16;
              newBits[len - i] = x;
            }
            if (this.size !== oldBitsLen * 32) {
              const leftOffset = oldBitsLen * 32 - this.size;
              let currentInt = newBits[0] >>> leftOffset;
              for (let i = 1; i < oldBitsLen; i++) {
                const nextInt = newBits[i];
                currentInt |= nextInt << 32 - leftOffset;
                newBits[i - 1] = currentInt;
                currentInt = nextInt >>> leftOffset;
              }
              newBits[oldBitsLen - 1] = currentInt;
            }
            this.bits = newBits;
          }
          static makeArray(size2) {
            return new Int32Array(Math.floor((size2 + 31) / 32));
          }
          equals(o) {
            if (!(o instanceof BitArray)) {
              return false;
            }
            const other = o;
            return this.size === other.size && Arrays.equals(this.bits, other.bits);
          }
          hashCode() {
            return 31 * this.size + Arrays.hashCode(this.bits);
          }
          toString() {
            let result = "";
            for (let i = 0, size2 = this.size; i < size2; i++) {
              if ((i & 7) === 0) {
                result += " ";
              }
              result += this.get(i) ? "X" : ".";
            }
            return result;
          }
          clone() {
            return new BitArray(this.size, this.bits.slice());
          }
        }
        var DecodeHintType;
        (function(DecodeHintType2) {
          DecodeHintType2[DecodeHintType2["OTHER"] = 0] = "OTHER";
          DecodeHintType2[DecodeHintType2["PURE_BARCODE"] = 1] = "PURE_BARCODE";
          DecodeHintType2[DecodeHintType2["POSSIBLE_FORMATS"] = 2] = "POSSIBLE_FORMATS";
          DecodeHintType2[DecodeHintType2["TRY_HARDER"] = 3] = "TRY_HARDER";
          DecodeHintType2[DecodeHintType2["CHARACTER_SET"] = 4] = "CHARACTER_SET";
          DecodeHintType2[DecodeHintType2["ALLOWED_LENGTHS"] = 5] = "ALLOWED_LENGTHS";
          DecodeHintType2[DecodeHintType2["ASSUME_CODE_39_CHECK_DIGIT"] = 6] = "ASSUME_CODE_39_CHECK_DIGIT";
          DecodeHintType2[DecodeHintType2["ASSUME_GS1"] = 7] = "ASSUME_GS1";
          DecodeHintType2[DecodeHintType2["RETURN_CODABAR_START_END"] = 8] = "RETURN_CODABAR_START_END";
          DecodeHintType2[DecodeHintType2["NEED_RESULT_POINT_CALLBACK"] = 9] = "NEED_RESULT_POINT_CALLBACK";
          DecodeHintType2[DecodeHintType2["ALLOWED_EAN_EXTENSIONS"] = 10] = "ALLOWED_EAN_EXTENSIONS";
        })(DecodeHintType || (DecodeHintType = {}));
        var DecodeHintType$1 = DecodeHintType;
        class FormatException extends Exception {
          static getFormatInstance() {
            return new FormatException();
          }
        }
        FormatException.kind = "FormatException";
        var CharacterSetValueIdentifiers;
        (function(CharacterSetValueIdentifiers2) {
          CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["Cp437"] = 0] = "Cp437";
          CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["ISO8859_1"] = 1] = "ISO8859_1";
          CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["ISO8859_2"] = 2] = "ISO8859_2";
          CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["ISO8859_3"] = 3] = "ISO8859_3";
          CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["ISO8859_4"] = 4] = "ISO8859_4";
          CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["ISO8859_5"] = 5] = "ISO8859_5";
          CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["ISO8859_6"] = 6] = "ISO8859_6";
          CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["ISO8859_7"] = 7] = "ISO8859_7";
          CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["ISO8859_8"] = 8] = "ISO8859_8";
          CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["ISO8859_9"] = 9] = "ISO8859_9";
          CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["ISO8859_10"] = 10] = "ISO8859_10";
          CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["ISO8859_11"] = 11] = "ISO8859_11";
          CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["ISO8859_13"] = 12] = "ISO8859_13";
          CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["ISO8859_14"] = 13] = "ISO8859_14";
          CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["ISO8859_15"] = 14] = "ISO8859_15";
          CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["ISO8859_16"] = 15] = "ISO8859_16";
          CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["SJIS"] = 16] = "SJIS";
          CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["Cp1250"] = 17] = "Cp1250";
          CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["Cp1251"] = 18] = "Cp1251";
          CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["Cp1252"] = 19] = "Cp1252";
          CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["Cp1256"] = 20] = "Cp1256";
          CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["UnicodeBigUnmarked"] = 21] = "UnicodeBigUnmarked";
          CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["UTF8"] = 22] = "UTF8";
          CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["ASCII"] = 23] = "ASCII";
          CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["Big5"] = 24] = "Big5";
          CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["GB18030"] = 25] = "GB18030";
          CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["EUC_KR"] = 26] = "EUC_KR";
        })(CharacterSetValueIdentifiers || (CharacterSetValueIdentifiers = {}));
        class CharacterSetECI {
          constructor(valueIdentifier, valuesParam, name, ...otherEncodingNames) {
            this.valueIdentifier = valueIdentifier;
            this.name = name;
            if (typeof valuesParam === "number") {
              this.values = Int32Array.from([valuesParam]);
            } else {
              this.values = valuesParam;
            }
            this.otherEncodingNames = otherEncodingNames;
            CharacterSetECI.VALUE_IDENTIFIER_TO_ECI.set(valueIdentifier, this);
            CharacterSetECI.NAME_TO_ECI.set(name, this);
            const values = this.values;
            for (let i = 0, length = values.length; i !== length; i++) {
              const v = values[i];
              CharacterSetECI.VALUES_TO_ECI.set(v, this);
            }
            for (const otherName of otherEncodingNames) {
              CharacterSetECI.NAME_TO_ECI.set(otherName, this);
            }
          }
          getValueIdentifier() {
            return this.valueIdentifier;
          }
          getName() {
            return this.name;
          }
          getValue() {
            return this.values[0];
          }
          static getCharacterSetECIByValue(value) {
            if (value < 0 || value >= 900) {
              throw new FormatException("incorect value");
            }
            const characterSet = CharacterSetECI.VALUES_TO_ECI.get(value);
            if (characterSet === void 0) {
              throw new FormatException("incorect value");
            }
            return characterSet;
          }
          static getCharacterSetECIByName(name) {
            const characterSet = CharacterSetECI.NAME_TO_ECI.get(name);
            if (characterSet === void 0) {
              throw new FormatException("incorect value");
            }
            return characterSet;
          }
          equals(o) {
            if (!(o instanceof CharacterSetECI)) {
              return false;
            }
            const other = o;
            return this.getName() === other.getName();
          }
        }
        CharacterSetECI.VALUE_IDENTIFIER_TO_ECI = /* @__PURE__ */ new Map();
        CharacterSetECI.VALUES_TO_ECI = /* @__PURE__ */ new Map();
        CharacterSetECI.NAME_TO_ECI = /* @__PURE__ */ new Map();
        CharacterSetECI.Cp437 = new CharacterSetECI(CharacterSetValueIdentifiers.Cp437, Int32Array.from([0, 2]), "Cp437");
        CharacterSetECI.ISO8859_1 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_1, Int32Array.from([1, 3]), "ISO-8859-1", "ISO88591", "ISO8859_1");
        CharacterSetECI.ISO8859_2 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_2, 4, "ISO-8859-2", "ISO88592", "ISO8859_2");
        CharacterSetECI.ISO8859_3 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_3, 5, "ISO-8859-3", "ISO88593", "ISO8859_3");
        CharacterSetECI.ISO8859_4 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_4, 6, "ISO-8859-4", "ISO88594", "ISO8859_4");
        CharacterSetECI.ISO8859_5 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_5, 7, "ISO-8859-5", "ISO88595", "ISO8859_5");
        CharacterSetECI.ISO8859_6 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_6, 8, "ISO-8859-6", "ISO88596", "ISO8859_6");
        CharacterSetECI.ISO8859_7 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_7, 9, "ISO-8859-7", "ISO88597", "ISO8859_7");
        CharacterSetECI.ISO8859_8 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_8, 10, "ISO-8859-8", "ISO88598", "ISO8859_8");
        CharacterSetECI.ISO8859_9 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_9, 11, "ISO-8859-9", "ISO88599", "ISO8859_9");
        CharacterSetECI.ISO8859_10 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_10, 12, "ISO-8859-10", "ISO885910", "ISO8859_10");
        CharacterSetECI.ISO8859_11 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_11, 13, "ISO-8859-11", "ISO885911", "ISO8859_11");
        CharacterSetECI.ISO8859_13 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_13, 15, "ISO-8859-13", "ISO885913", "ISO8859_13");
        CharacterSetECI.ISO8859_14 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_14, 16, "ISO-8859-14", "ISO885914", "ISO8859_14");
        CharacterSetECI.ISO8859_15 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_15, 17, "ISO-8859-15", "ISO885915", "ISO8859_15");
        CharacterSetECI.ISO8859_16 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_16, 18, "ISO-8859-16", "ISO885916", "ISO8859_16");
        CharacterSetECI.SJIS = new CharacterSetECI(CharacterSetValueIdentifiers.SJIS, 20, "SJIS", "Shift_JIS");
        CharacterSetECI.Cp1250 = new CharacterSetECI(CharacterSetValueIdentifiers.Cp1250, 21, "Cp1250", "windows-1250");
        CharacterSetECI.Cp1251 = new CharacterSetECI(CharacterSetValueIdentifiers.Cp1251, 22, "Cp1251", "windows-1251");
        CharacterSetECI.Cp1252 = new CharacterSetECI(CharacterSetValueIdentifiers.Cp1252, 23, "Cp1252", "windows-1252");
        CharacterSetECI.Cp1256 = new CharacterSetECI(CharacterSetValueIdentifiers.Cp1256, 24, "Cp1256", "windows-1256");
        CharacterSetECI.UnicodeBigUnmarked = new CharacterSetECI(CharacterSetValueIdentifiers.UnicodeBigUnmarked, 25, "UnicodeBigUnmarked", "UTF-16BE", "UnicodeBig");
        CharacterSetECI.UTF8 = new CharacterSetECI(CharacterSetValueIdentifiers.UTF8, 26, "UTF8", "UTF-8");
        CharacterSetECI.ASCII = new CharacterSetECI(CharacterSetValueIdentifiers.ASCII, Int32Array.from([27, 170]), "ASCII", "US-ASCII");
        CharacterSetECI.Big5 = new CharacterSetECI(CharacterSetValueIdentifiers.Big5, 28, "Big5");
        CharacterSetECI.GB18030 = new CharacterSetECI(CharacterSetValueIdentifiers.GB18030, 29, "GB18030", "GB2312", "EUC_CN", "GBK");
        CharacterSetECI.EUC_KR = new CharacterSetECI(CharacterSetValueIdentifiers.EUC_KR, 30, "EUC_KR", "EUC-KR");
        class UnsupportedOperationException extends Exception {
        }
        UnsupportedOperationException.kind = "UnsupportedOperationException";
        class StringEncoding {
          static decode(bytes, encoding) {
            const encodingName = this.encodingName(encoding);
            if (this.customDecoder) {
              return this.customDecoder(bytes, encodingName);
            }
            if (typeof TextDecoder === "undefined" || this.shouldDecodeOnFallback(encodingName)) {
              return this.decodeFallback(bytes, encodingName);
            }
            return new TextDecoder(encodingName).decode(bytes);
          }
          static shouldDecodeOnFallback(encodingName) {
            return !StringEncoding.isBrowser() && encodingName === "ISO-8859-1";
          }
          static encode(s, encoding) {
            const encodingName = this.encodingName(encoding);
            if (this.customEncoder) {
              return this.customEncoder(s, encodingName);
            }
            if (typeof TextEncoder === "undefined") {
              return this.encodeFallback(s);
            }
            return new TextEncoder().encode(s);
          }
          static isBrowser() {
            return typeof window !== "undefined" && {}.toString.call(window) === "[object Window]";
          }
          static encodingName(encoding) {
            return typeof encoding === "string" ? encoding : encoding.getName();
          }
          static encodingCharacterSet(encoding) {
            if (encoding instanceof CharacterSetECI) {
              return encoding;
            }
            return CharacterSetECI.getCharacterSetECIByName(encoding);
          }
          static decodeFallback(bytes, encoding) {
            const characterSet = this.encodingCharacterSet(encoding);
            if (StringEncoding.isDecodeFallbackSupported(characterSet)) {
              let s = "";
              for (let i = 0, length = bytes.length; i < length; i++) {
                let h = bytes[i].toString(16);
                if (h.length < 2) {
                  h = "0" + h;
                }
                s += "%" + h;
              }
              return decodeURIComponent(s);
            }
            if (characterSet.equals(CharacterSetECI.UnicodeBigUnmarked)) {
              return String.fromCharCode.apply(null, new Uint16Array(bytes.buffer));
            }
            throw new UnsupportedOperationException(`Encoding ${this.encodingName(encoding)} not supported by fallback.`);
          }
          static isDecodeFallbackSupported(characterSet) {
            return characterSet.equals(CharacterSetECI.UTF8) || characterSet.equals(CharacterSetECI.ISO8859_1) || characterSet.equals(CharacterSetECI.ASCII);
          }
          static encodeFallback(s) {
            const encodedURIstring = btoa(unescape(encodeURIComponent(s)));
            const charList = encodedURIstring.split("");
            const uintArray = [];
            for (let i = 0; i < charList.length; i++) {
              uintArray.push(charList[i].charCodeAt(0));
            }
            return new Uint8Array(uintArray);
          }
        }
        class StringUtils {
          static castAsNonUtf8Char(code, encoding = null) {
            const e = encoding ? encoding.getName() : this.ISO88591;
            return StringEncoding.decode(new Uint8Array([code]), e);
          }
          static guessEncoding(bytes, hints) {
            if (hints !== null && hints !== void 0 && hints.get(DecodeHintType$1.CHARACTER_SET) !== void 0) {
              return hints.get(DecodeHintType$1.CHARACTER_SET).toString();
            }
            const length = bytes.length;
            let canBeISO88591 = true;
            let canBeShiftJIS = true;
            let canBeUTF8 = true;
            let utf8BytesLeft = 0;
            let utf2BytesChars = 0;
            let utf3BytesChars = 0;
            let utf4BytesChars = 0;
            let sjisBytesLeft = 0;
            let sjisKatakanaChars = 0;
            let sjisCurKatakanaWordLength = 0;
            let sjisCurDoubleBytesWordLength = 0;
            let sjisMaxKatakanaWordLength = 0;
            let sjisMaxDoubleBytesWordLength = 0;
            let isoHighOther = 0;
            const utf8bom = bytes.length > 3 && bytes[0] === 239 && bytes[1] === 187 && bytes[2] === 191;
            for (let i = 0; i < length && (canBeISO88591 || canBeShiftJIS || canBeUTF8); i++) {
              const value = bytes[i] & 255;
              if (canBeUTF8) {
                if (utf8BytesLeft > 0) {
                  if ((value & 128) === 0) {
                    canBeUTF8 = false;
                  } else {
                    utf8BytesLeft--;
                  }
                } else if ((value & 128) !== 0) {
                  if ((value & 64) === 0) {
                    canBeUTF8 = false;
                  } else {
                    utf8BytesLeft++;
                    if ((value & 32) === 0) {
                      utf2BytesChars++;
                    } else {
                      utf8BytesLeft++;
                      if ((value & 16) === 0) {
                        utf3BytesChars++;
                      } else {
                        utf8BytesLeft++;
                        if ((value & 8) === 0) {
                          utf4BytesChars++;
                        } else {
                          canBeUTF8 = false;
                        }
                      }
                    }
                  }
                }
              }
              if (canBeISO88591) {
                if (value > 127 && value < 160) {
                  canBeISO88591 = false;
                } else if (value > 159) {
                  if (value < 192 || value === 215 || value === 247) {
                    isoHighOther++;
                  }
                }
              }
              if (canBeShiftJIS) {
                if (sjisBytesLeft > 0) {
                  if (value < 64 || value === 127 || value > 252) {
                    canBeShiftJIS = false;
                  } else {
                    sjisBytesLeft--;
                  }
                } else if (value === 128 || value === 160 || value > 239) {
                  canBeShiftJIS = false;
                } else if (value > 160 && value < 224) {
                  sjisKatakanaChars++;
                  sjisCurDoubleBytesWordLength = 0;
                  sjisCurKatakanaWordLength++;
                  if (sjisCurKatakanaWordLength > sjisMaxKatakanaWordLength) {
                    sjisMaxKatakanaWordLength = sjisCurKatakanaWordLength;
                  }
                } else if (value > 127) {
                  sjisBytesLeft++;
                  sjisCurKatakanaWordLength = 0;
                  sjisCurDoubleBytesWordLength++;
                  if (sjisCurDoubleBytesWordLength > sjisMaxDoubleBytesWordLength) {
                    sjisMaxDoubleBytesWordLength = sjisCurDoubleBytesWordLength;
                  }
                } else {
                  sjisCurKatakanaWordLength = 0;
                  sjisCurDoubleBytesWordLength = 0;
                }
              }
            }
            if (canBeUTF8 && utf8BytesLeft > 0) {
              canBeUTF8 = false;
            }
            if (canBeShiftJIS && sjisBytesLeft > 0) {
              canBeShiftJIS = false;
            }
            if (canBeUTF8 && (utf8bom || utf2BytesChars + utf3BytesChars + utf4BytesChars > 0)) {
              return StringUtils.UTF8;
            }
            if (canBeShiftJIS && (StringUtils.ASSUME_SHIFT_JIS || sjisMaxKatakanaWordLength >= 3 || sjisMaxDoubleBytesWordLength >= 3)) {
              return StringUtils.SHIFT_JIS;
            }
            if (canBeISO88591 && canBeShiftJIS) {
              return sjisMaxKatakanaWordLength === 2 && sjisKatakanaChars === 2 || isoHighOther * 10 >= length ? StringUtils.SHIFT_JIS : StringUtils.ISO88591;
            }
            if (canBeISO88591) {
              return StringUtils.ISO88591;
            }
            if (canBeShiftJIS) {
              return StringUtils.SHIFT_JIS;
            }
            if (canBeUTF8) {
              return StringUtils.UTF8;
            }
            return StringUtils.PLATFORM_DEFAULT_ENCODING;
          }
          static format(append, ...args) {
            let i = -1;
            function callback(exp, p0, p1, p2, p3, p4) {
              if (exp === "%%")
                return "%";
              if (args[++i] === void 0)
                return void 0;
              exp = p2 ? parseInt(p2.substr(1)) : void 0;
              let base = p3 ? parseInt(p3.substr(1)) : void 0;
              let val;
              switch (p4) {
                case "s":
                  val = args[i];
                  break;
                case "c":
                  val = args[i][0];
                  break;
                case "f":
                  val = parseFloat(args[i]).toFixed(exp);
                  break;
                case "p":
                  val = parseFloat(args[i]).toPrecision(exp);
                  break;
                case "e":
                  val = parseFloat(args[i]).toExponential(exp);
                  break;
                case "x":
                  val = parseInt(args[i]).toString(base ? base : 16);
                  break;
                case "d":
                  val = parseFloat(parseInt(args[i], base ? base : 10).toPrecision(exp)).toFixed(0);
                  break;
              }
              val = typeof val === "object" ? JSON.stringify(val) : (+val).toString(base);
              let size2 = parseInt(p1);
              let ch = p1 && p1[0] + "" === "0" ? "0" : " ";
              while (val.length < size2)
                val = p0 !== void 0 ? val + ch : ch + val;
              return val;
            }
            let regex = /%(-)?(0?[0-9]+)?([.][0-9]+)?([#][0-9]+)?([scfpexd%])/g;
            return append.replace(regex, callback);
          }
          static getBytes(str, encoding) {
            return StringEncoding.encode(str, encoding);
          }
          static getCharCode(str, index = 0) {
            return str.charCodeAt(index);
          }
          static getCharAt(charCode) {
            return String.fromCharCode(charCode);
          }
        }
        StringUtils.SHIFT_JIS = CharacterSetECI.SJIS.getName();
        StringUtils.GB2312 = "GB2312";
        StringUtils.ISO88591 = CharacterSetECI.ISO8859_1.getName();
        StringUtils.EUC_JP = "EUC_JP";
        StringUtils.UTF8 = CharacterSetECI.UTF8.getName();
        StringUtils.PLATFORM_DEFAULT_ENCODING = StringUtils.UTF8;
        StringUtils.ASSUME_SHIFT_JIS = false;
        class StringBuilder {
          constructor(value = "") {
            this.value = value;
          }
          enableDecoding(encoding) {
            this.encoding = encoding;
            return this;
          }
          append(s) {
            if (typeof s === "string") {
              this.value += s.toString();
            } else if (this.encoding) {
              this.value += StringUtils.castAsNonUtf8Char(s, this.encoding);
            } else {
              this.value += String.fromCharCode(s);
            }
            return this;
          }
          appendChars(str, offset, len) {
            for (let i = offset; offset < offset + len; i++) {
              this.append(str[i]);
            }
            return this;
          }
          length() {
            return this.value.length;
          }
          charAt(n) {
            return this.value.charAt(n);
          }
          deleteCharAt(n) {
            this.value = this.value.substr(0, n) + this.value.substring(n + 1);
          }
          setCharAt(n, c) {
            this.value = this.value.substr(0, n) + c + this.value.substr(n + 1);
          }
          substring(start2, end) {
            return this.value.substring(start2, end);
          }
          setLengthToZero() {
            this.value = "";
          }
          toString() {
            return this.value;
          }
          insert(n, c) {
            this.value = this.value.substr(0, n) + c + this.value.substr(n + c.length);
          }
        }
        class BitMatrix {
          constructor(width, height, rowSize, bits) {
            this.width = width;
            this.height = height;
            this.rowSize = rowSize;
            this.bits = bits;
            if (height === void 0 || height === null) {
              height = width;
            }
            this.height = height;
            if (width < 1 || height < 1) {
              throw new IllegalArgumentException("Both dimensions must be greater than 0");
            }
            if (rowSize === void 0 || rowSize === null) {
              rowSize = Math.floor((width + 31) / 32);
            }
            this.rowSize = rowSize;
            if (bits === void 0 || bits === null) {
              this.bits = new Int32Array(this.rowSize * this.height);
            }
          }
          static parseFromBooleanArray(image) {
            const height = image.length;
            const width = image[0].length;
            const bits = new BitMatrix(width, height);
            for (let i = 0; i < height; i++) {
              const imageI = image[i];
              for (let j = 0; j < width; j++) {
                if (imageI[j]) {
                  bits.set(j, i);
                }
              }
            }
            return bits;
          }
          static parseFromString(stringRepresentation, setString, unsetString) {
            if (stringRepresentation === null) {
              throw new IllegalArgumentException("stringRepresentation cannot be null");
            }
            const bits = new Array(stringRepresentation.length);
            let bitsPos = 0;
            let rowStartPos = 0;
            let rowLength = -1;
            let nRows = 0;
            let pos = 0;
            while (pos < stringRepresentation.length) {
              if (stringRepresentation.charAt(pos) === "\n" || stringRepresentation.charAt(pos) === "\r") {
                if (bitsPos > rowStartPos) {
                  if (rowLength === -1) {
                    rowLength = bitsPos - rowStartPos;
                  } else if (bitsPos - rowStartPos !== rowLength) {
                    throw new IllegalArgumentException("row lengths do not match");
                  }
                  rowStartPos = bitsPos;
                  nRows++;
                }
                pos++;
              } else if (stringRepresentation.substring(pos, pos + setString.length) === setString) {
                pos += setString.length;
                bits[bitsPos] = true;
                bitsPos++;
              } else if (stringRepresentation.substring(pos, pos + unsetString.length) === unsetString) {
                pos += unsetString.length;
                bits[bitsPos] = false;
                bitsPos++;
              } else {
                throw new IllegalArgumentException("illegal character encountered: " + stringRepresentation.substring(pos));
              }
            }
            if (bitsPos > rowStartPos) {
              if (rowLength === -1) {
                rowLength = bitsPos - rowStartPos;
              } else if (bitsPos - rowStartPos !== rowLength) {
                throw new IllegalArgumentException("row lengths do not match");
              }
              nRows++;
            }
            const matrix = new BitMatrix(rowLength, nRows);
            for (let i = 0; i < bitsPos; i++) {
              if (bits[i]) {
                matrix.set(Math.floor(i % rowLength), Math.floor(i / rowLength));
              }
            }
            return matrix;
          }
          get(x, y) {
            const offset = y * this.rowSize + Math.floor(x / 32);
            return (this.bits[offset] >>> (x & 31) & 1) !== 0;
          }
          set(x, y) {
            const offset = y * this.rowSize + Math.floor(x / 32);
            this.bits[offset] |= 1 << (x & 31) & 4294967295;
          }
          unset(x, y) {
            const offset = y * this.rowSize + Math.floor(x / 32);
            this.bits[offset] &= ~(1 << (x & 31) & 4294967295);
          }
          flip(x, y) {
            const offset = y * this.rowSize + Math.floor(x / 32);
            this.bits[offset] ^= 1 << (x & 31) & 4294967295;
          }
          xor(mask) {
            if (this.width !== mask.getWidth() || this.height !== mask.getHeight() || this.rowSize !== mask.getRowSize()) {
              throw new IllegalArgumentException("input matrix dimensions do not match");
            }
            const rowArray = new BitArray(Math.floor(this.width / 32) + 1);
            const rowSize = this.rowSize;
            const bits = this.bits;
            for (let y = 0, height = this.height; y < height; y++) {
              const offset = y * rowSize;
              const row = mask.getRow(y, rowArray).getBitArray();
              for (let x = 0; x < rowSize; x++) {
                bits[offset + x] ^= row[x];
              }
            }
          }
          clear() {
            const bits = this.bits;
            const max = bits.length;
            for (let i = 0; i < max; i++) {
              bits[i] = 0;
            }
          }
          setRegion(left, top, width, height) {
            if (top < 0 || left < 0) {
              throw new IllegalArgumentException("Left and top must be nonnegative");
            }
            if (height < 1 || width < 1) {
              throw new IllegalArgumentException("Height and width must be at least 1");
            }
            const right = left + width;
            const bottom = top + height;
            if (bottom > this.height || right > this.width) {
              throw new IllegalArgumentException("The region must fit inside the matrix");
            }
            const rowSize = this.rowSize;
            const bits = this.bits;
            for (let y = top; y < bottom; y++) {
              const offset = y * rowSize;
              for (let x = left; x < right; x++) {
                bits[offset + Math.floor(x / 32)] |= 1 << (x & 31) & 4294967295;
              }
            }
          }
          getRow(y, row) {
            if (row === null || row === void 0 || row.getSize() < this.width) {
              row = new BitArray(this.width);
            } else {
              row.clear();
            }
            const rowSize = this.rowSize;
            const bits = this.bits;
            const offset = y * rowSize;
            for (let x = 0; x < rowSize; x++) {
              row.setBulk(x * 32, bits[offset + x]);
            }
            return row;
          }
          setRow(y, row) {
            System.arraycopy(row.getBitArray(), 0, this.bits, y * this.rowSize, this.rowSize);
          }
          rotate180() {
            const width = this.getWidth();
            const height = this.getHeight();
            let topRow = new BitArray(width);
            let bottomRow = new BitArray(width);
            for (let i = 0, length = Math.floor((height + 1) / 2); i < length; i++) {
              topRow = this.getRow(i, topRow);
              bottomRow = this.getRow(height - 1 - i, bottomRow);
              topRow.reverse();
              bottomRow.reverse();
              this.setRow(i, bottomRow);
              this.setRow(height - 1 - i, topRow);
            }
          }
          getEnclosingRectangle() {
            const width = this.width;
            const height = this.height;
            const rowSize = this.rowSize;
            const bits = this.bits;
            let left = width;
            let top = height;
            let right = -1;
            let bottom = -1;
            for (let y = 0; y < height; y++) {
              for (let x32 = 0; x32 < rowSize; x32++) {
                const theBits = bits[y * rowSize + x32];
                if (theBits !== 0) {
                  if (y < top) {
                    top = y;
                  }
                  if (y > bottom) {
                    bottom = y;
                  }
                  if (x32 * 32 < left) {
                    let bit = 0;
                    while ((theBits << 31 - bit & 4294967295) === 0) {
                      bit++;
                    }
                    if (x32 * 32 + bit < left) {
                      left = x32 * 32 + bit;
                    }
                  }
                  if (x32 * 32 + 31 > right) {
                    let bit = 31;
                    while (theBits >>> bit === 0) {
                      bit--;
                    }
                    if (x32 * 32 + bit > right) {
                      right = x32 * 32 + bit;
                    }
                  }
                }
              }
            }
            if (right < left || bottom < top) {
              return null;
            }
            return Int32Array.from([left, top, right - left + 1, bottom - top + 1]);
          }
          getTopLeftOnBit() {
            const rowSize = this.rowSize;
            const bits = this.bits;
            let bitsOffset = 0;
            while (bitsOffset < bits.length && bits[bitsOffset] === 0) {
              bitsOffset++;
            }
            if (bitsOffset === bits.length) {
              return null;
            }
            const y = bitsOffset / rowSize;
            let x = bitsOffset % rowSize * 32;
            const theBits = bits[bitsOffset];
            let bit = 0;
            while ((theBits << 31 - bit & 4294967295) === 0) {
              bit++;
            }
            x += bit;
            return Int32Array.from([x, y]);
          }
          getBottomRightOnBit() {
            const rowSize = this.rowSize;
            const bits = this.bits;
            let bitsOffset = bits.length - 1;
            while (bitsOffset >= 0 && bits[bitsOffset] === 0) {
              bitsOffset--;
            }
            if (bitsOffset < 0) {
              return null;
            }
            const y = Math.floor(bitsOffset / rowSize);
            let x = Math.floor(bitsOffset % rowSize) * 32;
            const theBits = bits[bitsOffset];
            let bit = 31;
            while (theBits >>> bit === 0) {
              bit--;
            }
            x += bit;
            return Int32Array.from([x, y]);
          }
          getWidth() {
            return this.width;
          }
          getHeight() {
            return this.height;
          }
          getRowSize() {
            return this.rowSize;
          }
          equals(o) {
            if (!(o instanceof BitMatrix)) {
              return false;
            }
            const other = o;
            return this.width === other.width && this.height === other.height && this.rowSize === other.rowSize && Arrays.equals(this.bits, other.bits);
          }
          hashCode() {
            let hash = this.width;
            hash = 31 * hash + this.width;
            hash = 31 * hash + this.height;
            hash = 31 * hash + this.rowSize;
            hash = 31 * hash + Arrays.hashCode(this.bits);
            return hash;
          }
          toString(setString = "X ", unsetString = "  ", lineSeparator = "\n") {
            return this.buildToString(setString, unsetString, lineSeparator);
          }
          buildToString(setString, unsetString, lineSeparator) {
            let result = new StringBuilder();
            for (let y = 0, height = this.height; y < height; y++) {
              for (let x = 0, width = this.width; x < width; x++) {
                result.append(this.get(x, y) ? setString : unsetString);
              }
              result.append(lineSeparator);
            }
            return result.toString();
          }
          clone() {
            return new BitMatrix(this.width, this.height, this.rowSize, this.bits.slice());
          }
        }
        class NotFoundException extends Exception {
          static getNotFoundInstance() {
            return new NotFoundException();
          }
        }
        NotFoundException.kind = "NotFoundException";
        class GlobalHistogramBinarizer extends Binarizer {
          constructor(source) {
            super(source);
            this.luminances = GlobalHistogramBinarizer.EMPTY;
            this.buckets = new Int32Array(GlobalHistogramBinarizer.LUMINANCE_BUCKETS);
          }
          getBlackRow(y, row) {
            const source = this.getLuminanceSource();
            const width = source.getWidth();
            if (row === void 0 || row === null || row.getSize() < width) {
              row = new BitArray(width);
            } else {
              row.clear();
            }
            this.initArrays(width);
            const localLuminances = source.getRow(y, this.luminances);
            const localBuckets = this.buckets;
            for (let x = 0; x < width; x++) {
              localBuckets[(localLuminances[x] & 255) >> GlobalHistogramBinarizer.LUMINANCE_SHIFT]++;
            }
            const blackPoint = GlobalHistogramBinarizer.estimateBlackPoint(localBuckets);
            if (width < 3) {
              for (let x = 0; x < width; x++) {
                if ((localLuminances[x] & 255) < blackPoint) {
                  row.set(x);
                }
              }
            } else {
              let left = localLuminances[0] & 255;
              let center = localLuminances[1] & 255;
              for (let x = 1; x < width - 1; x++) {
                const right = localLuminances[x + 1] & 255;
                if ((center * 4 - left - right) / 2 < blackPoint) {
                  row.set(x);
                }
                left = center;
                center = right;
              }
            }
            return row;
          }
          getBlackMatrix() {
            const source = this.getLuminanceSource();
            const width = source.getWidth();
            const height = source.getHeight();
            const matrix = new BitMatrix(width, height);
            this.initArrays(width);
            const localBuckets = this.buckets;
            for (let y = 1; y < 5; y++) {
              const row = Math.floor(height * y / 5);
              const localLuminances2 = source.getRow(row, this.luminances);
              const right = Math.floor(width * 4 / 5);
              for (let x = Math.floor(width / 5); x < right; x++) {
                const pixel = localLuminances2[x] & 255;
                localBuckets[pixel >> GlobalHistogramBinarizer.LUMINANCE_SHIFT]++;
              }
            }
            const blackPoint = GlobalHistogramBinarizer.estimateBlackPoint(localBuckets);
            const localLuminances = source.getMatrix();
            for (let y = 0; y < height; y++) {
              const offset = y * width;
              for (let x = 0; x < width; x++) {
                const pixel = localLuminances[offset + x] & 255;
                if (pixel < blackPoint) {
                  matrix.set(x, y);
                }
              }
            }
            return matrix;
          }
          createBinarizer(source) {
            return new GlobalHistogramBinarizer(source);
          }
          initArrays(luminanceSize) {
            if (this.luminances.length < luminanceSize) {
              this.luminances = new Uint8ClampedArray(luminanceSize);
            }
            const buckets = this.buckets;
            for (let x = 0; x < GlobalHistogramBinarizer.LUMINANCE_BUCKETS; x++) {
              buckets[x] = 0;
            }
          }
          static estimateBlackPoint(buckets) {
            const numBuckets = buckets.length;
            let maxBucketCount = 0;
            let firstPeak = 0;
            let firstPeakSize = 0;
            for (let x = 0; x < numBuckets; x++) {
              if (buckets[x] > firstPeakSize) {
                firstPeak = x;
                firstPeakSize = buckets[x];
              }
              if (buckets[x] > maxBucketCount) {
                maxBucketCount = buckets[x];
              }
            }
            let secondPeak = 0;
            let secondPeakScore = 0;
            for (let x = 0; x < numBuckets; x++) {
              const distanceToBiggest = x - firstPeak;
              const score = buckets[x] * distanceToBiggest * distanceToBiggest;
              if (score > secondPeakScore) {
                secondPeak = x;
                secondPeakScore = score;
              }
            }
            if (firstPeak > secondPeak) {
              const temp = firstPeak;
              firstPeak = secondPeak;
              secondPeak = temp;
            }
            if (secondPeak - firstPeak <= numBuckets / 16) {
              throw new NotFoundException();
            }
            let bestValley = secondPeak - 1;
            let bestValleyScore = -1;
            for (let x = secondPeak - 1; x > firstPeak; x--) {
              const fromFirst = x - firstPeak;
              const score = fromFirst * fromFirst * (secondPeak - x) * (maxBucketCount - buckets[x]);
              if (score > bestValleyScore) {
                bestValley = x;
                bestValleyScore = score;
              }
            }
            return bestValley << GlobalHistogramBinarizer.LUMINANCE_SHIFT;
          }
        }
        GlobalHistogramBinarizer.LUMINANCE_BITS = 5;
        GlobalHistogramBinarizer.LUMINANCE_SHIFT = 8 - GlobalHistogramBinarizer.LUMINANCE_BITS;
        GlobalHistogramBinarizer.LUMINANCE_BUCKETS = 1 << GlobalHistogramBinarizer.LUMINANCE_BITS;
        GlobalHistogramBinarizer.EMPTY = Uint8ClampedArray.from([0]);
        class HybridBinarizer extends GlobalHistogramBinarizer {
          constructor(source) {
            super(source);
            this.matrix = null;
          }
          getBlackMatrix() {
            if (this.matrix !== null) {
              return this.matrix;
            }
            const source = this.getLuminanceSource();
            const width = source.getWidth();
            const height = source.getHeight();
            if (width >= HybridBinarizer.MINIMUM_DIMENSION && height >= HybridBinarizer.MINIMUM_DIMENSION) {
              const luminances = source.getMatrix();
              let subWidth = width >> HybridBinarizer.BLOCK_SIZE_POWER;
              if ((width & HybridBinarizer.BLOCK_SIZE_MASK) !== 0) {
                subWidth++;
              }
              let subHeight = height >> HybridBinarizer.BLOCK_SIZE_POWER;
              if ((height & HybridBinarizer.BLOCK_SIZE_MASK) !== 0) {
                subHeight++;
              }
              const blackPoints = HybridBinarizer.calculateBlackPoints(luminances, subWidth, subHeight, width, height);
              const newMatrix = new BitMatrix(width, height);
              HybridBinarizer.calculateThresholdForBlock(luminances, subWidth, subHeight, width, height, blackPoints, newMatrix);
              this.matrix = newMatrix;
            } else {
              this.matrix = super.getBlackMatrix();
            }
            return this.matrix;
          }
          createBinarizer(source) {
            return new HybridBinarizer(source);
          }
          static calculateThresholdForBlock(luminances, subWidth, subHeight, width, height, blackPoints, matrix) {
            const maxYOffset = height - HybridBinarizer.BLOCK_SIZE;
            const maxXOffset = width - HybridBinarizer.BLOCK_SIZE;
            for (let y = 0; y < subHeight; y++) {
              let yoffset = y << HybridBinarizer.BLOCK_SIZE_POWER;
              if (yoffset > maxYOffset) {
                yoffset = maxYOffset;
              }
              const top = HybridBinarizer.cap(y, 2, subHeight - 3);
              for (let x = 0; x < subWidth; x++) {
                let xoffset = x << HybridBinarizer.BLOCK_SIZE_POWER;
                if (xoffset > maxXOffset) {
                  xoffset = maxXOffset;
                }
                const left = HybridBinarizer.cap(x, 2, subWidth - 3);
                let sum = 0;
                for (let z = -2; z <= 2; z++) {
                  const blackRow = blackPoints[top + z];
                  sum += blackRow[left - 2] + blackRow[left - 1] + blackRow[left] + blackRow[left + 1] + blackRow[left + 2];
                }
                const average = sum / 25;
                HybridBinarizer.thresholdBlock(luminances, xoffset, yoffset, average, width, matrix);
              }
            }
          }
          static cap(value, min, max) {
            return value < min ? min : value > max ? max : value;
          }
          static thresholdBlock(luminances, xoffset, yoffset, threshold, stride, matrix) {
            for (let y = 0, offset = yoffset * stride + xoffset; y < HybridBinarizer.BLOCK_SIZE; y++, offset += stride) {
              for (let x = 0; x < HybridBinarizer.BLOCK_SIZE; x++) {
                if ((luminances[offset + x] & 255) <= threshold) {
                  matrix.set(xoffset + x, yoffset + y);
                }
              }
            }
          }
          static calculateBlackPoints(luminances, subWidth, subHeight, width, height) {
            const maxYOffset = height - HybridBinarizer.BLOCK_SIZE;
            const maxXOffset = width - HybridBinarizer.BLOCK_SIZE;
            const blackPoints = new Array(subHeight);
            for (let y = 0; y < subHeight; y++) {
              blackPoints[y] = new Int32Array(subWidth);
              let yoffset = y << HybridBinarizer.BLOCK_SIZE_POWER;
              if (yoffset > maxYOffset) {
                yoffset = maxYOffset;
              }
              for (let x = 0; x < subWidth; x++) {
                let xoffset = x << HybridBinarizer.BLOCK_SIZE_POWER;
                if (xoffset > maxXOffset) {
                  xoffset = maxXOffset;
                }
                let sum = 0;
                let min = 255;
                let max = 0;
                for (let yy = 0, offset = yoffset * width + xoffset; yy < HybridBinarizer.BLOCK_SIZE; yy++, offset += width) {
                  for (let xx = 0; xx < HybridBinarizer.BLOCK_SIZE; xx++) {
                    const pixel = luminances[offset + xx] & 255;
                    sum += pixel;
                    if (pixel < min) {
                      min = pixel;
                    }
                    if (pixel > max) {
                      max = pixel;
                    }
                  }
                  if (max - min > HybridBinarizer.MIN_DYNAMIC_RANGE) {
                    for (yy++, offset += width; yy < HybridBinarizer.BLOCK_SIZE; yy++, offset += width) {
                      for (let xx = 0; xx < HybridBinarizer.BLOCK_SIZE; xx++) {
                        sum += luminances[offset + xx] & 255;
                      }
                    }
                  }
                }
                let average = sum >> HybridBinarizer.BLOCK_SIZE_POWER * 2;
                if (max - min <= HybridBinarizer.MIN_DYNAMIC_RANGE) {
                  average = min / 2;
                  if (y > 0 && x > 0) {
                    const averageNeighborBlackPoint = (blackPoints[y - 1][x] + 2 * blackPoints[y][x - 1] + blackPoints[y - 1][x - 1]) / 4;
                    if (min < averageNeighborBlackPoint) {
                      average = averageNeighborBlackPoint;
                    }
                  }
                }
                blackPoints[y][x] = average;
              }
            }
            return blackPoints;
          }
        }
        HybridBinarizer.BLOCK_SIZE_POWER = 3;
        HybridBinarizer.BLOCK_SIZE = 1 << HybridBinarizer.BLOCK_SIZE_POWER;
        HybridBinarizer.BLOCK_SIZE_MASK = HybridBinarizer.BLOCK_SIZE - 1;
        HybridBinarizer.MINIMUM_DIMENSION = HybridBinarizer.BLOCK_SIZE * 5;
        HybridBinarizer.MIN_DYNAMIC_RANGE = 24;
        class LuminanceSource {
          constructor(width, height) {
            this.width = width;
            this.height = height;
          }
          getWidth() {
            return this.width;
          }
          getHeight() {
            return this.height;
          }
          isCropSupported() {
            return false;
          }
          crop(left, top, width, height) {
            throw new UnsupportedOperationException("This luminance source does not support cropping.");
          }
          isRotateSupported() {
            return false;
          }
          rotateCounterClockwise() {
            throw new UnsupportedOperationException("This luminance source does not support rotation by 90 degrees.");
          }
          rotateCounterClockwise45() {
            throw new UnsupportedOperationException("This luminance source does not support rotation by 45 degrees.");
          }
          toString() {
            const row = new Uint8ClampedArray(this.width);
            let result = new StringBuilder();
            for (let y = 0; y < this.height; y++) {
              const sourceRow = this.getRow(y, row);
              for (let x = 0; x < this.width; x++) {
                const luminance = sourceRow[x] & 255;
                let c;
                if (luminance < 64) {
                  c = "#";
                } else if (luminance < 128) {
                  c = "+";
                } else if (luminance < 192) {
                  c = ".";
                } else {
                  c = " ";
                }
                result.append(c);
              }
              result.append("\n");
            }
            return result.toString();
          }
        }
        class InvertedLuminanceSource extends LuminanceSource {
          constructor(delegate) {
            super(delegate.getWidth(), delegate.getHeight());
            this.delegate = delegate;
          }
          getRow(y, row) {
            const sourceRow = this.delegate.getRow(y, row);
            const width = this.getWidth();
            for (let i = 0; i < width; i++) {
              sourceRow[i] = 255 - (sourceRow[i] & 255);
            }
            return sourceRow;
          }
          getMatrix() {
            const matrix = this.delegate.getMatrix();
            const length = this.getWidth() * this.getHeight();
            const invertedMatrix = new Uint8ClampedArray(length);
            for (let i = 0; i < length; i++) {
              invertedMatrix[i] = 255 - (matrix[i] & 255);
            }
            return invertedMatrix;
          }
          isCropSupported() {
            return this.delegate.isCropSupported();
          }
          crop(left, top, width, height) {
            return new InvertedLuminanceSource(this.delegate.crop(left, top, width, height));
          }
          isRotateSupported() {
            return this.delegate.isRotateSupported();
          }
          invert() {
            return this.delegate;
          }
          rotateCounterClockwise() {
            return new InvertedLuminanceSource(this.delegate.rotateCounterClockwise());
          }
          rotateCounterClockwise45() {
            return new InvertedLuminanceSource(this.delegate.rotateCounterClockwise45());
          }
        }
        class HTMLCanvasElementLuminanceSource extends LuminanceSource {
          constructor(canvas) {
            super(canvas.width, canvas.height);
            this.canvas = canvas;
            this.tempCanvasElement = null;
            this.buffer = HTMLCanvasElementLuminanceSource.makeBufferFromCanvasImageData(canvas);
          }
          static makeBufferFromCanvasImageData(canvas) {
            const imageData = canvas.getContext("2d").getImageData(0, 0, canvas.width, canvas.height);
            return HTMLCanvasElementLuminanceSource.toGrayscaleBuffer(imageData.data, canvas.width, canvas.height);
          }
          static toGrayscaleBuffer(imageBuffer, width, height) {
            const grayscaleBuffer = new Uint8ClampedArray(width * height);
            for (let i = 0, j = 0, length = imageBuffer.length; i < length; i += 4, j++) {
              let gray;
              const alpha = imageBuffer[i + 3];
              if (alpha === 0) {
                gray = 255;
              } else {
                const pixelR = imageBuffer[i];
                const pixelG = imageBuffer[i + 1];
                const pixelB = imageBuffer[i + 2];
                gray = 306 * pixelR + 601 * pixelG + 117 * pixelB + 512 >> 10;
              }
              grayscaleBuffer[j] = gray;
            }
            return grayscaleBuffer;
          }
          getRow(y, row) {
            if (y < 0 || y >= this.getHeight()) {
              throw new IllegalArgumentException("Requested row is outside the image: " + y);
            }
            const width = this.getWidth();
            const start2 = y * width;
            if (row === null) {
              row = this.buffer.slice(start2, start2 + width);
            } else {
              if (row.length < width) {
                row = new Uint8ClampedArray(width);
              }
              row.set(this.buffer.slice(start2, start2 + width));
            }
            return row;
          }
          getMatrix() {
            return this.buffer;
          }
          isCropSupported() {
            return true;
          }
          crop(left, top, width, height) {
            super.crop(left, top, width, height);
            return this;
          }
          isRotateSupported() {
            return true;
          }
          rotateCounterClockwise() {
            this.rotate(-90);
            return this;
          }
          rotateCounterClockwise45() {
            this.rotate(-45);
            return this;
          }
          getTempCanvasElement() {
            if (this.tempCanvasElement === null) {
              const tempCanvasElement = this.canvas.ownerDocument.createElement("canvas");
              tempCanvasElement.width = this.canvas.width;
              tempCanvasElement.height = this.canvas.height;
              this.tempCanvasElement = tempCanvasElement;
            }
            return this.tempCanvasElement;
          }
          rotate(angle) {
            const tempCanvasElement = this.getTempCanvasElement();
            const tempContext = tempCanvasElement.getContext("2d");
            const angleRadians = angle * HTMLCanvasElementLuminanceSource.DEGREE_TO_RADIANS;
            const width = this.canvas.width;
            const height = this.canvas.height;
            const newWidth = Math.ceil(Math.abs(Math.cos(angleRadians)) * width + Math.abs(Math.sin(angleRadians)) * height);
            const newHeight = Math.ceil(Math.abs(Math.sin(angleRadians)) * width + Math.abs(Math.cos(angleRadians)) * height);
            tempCanvasElement.width = newWidth;
            tempCanvasElement.height = newHeight;
            tempContext.translate(newWidth / 2, newHeight / 2);
            tempContext.rotate(angleRadians);
            tempContext.drawImage(this.canvas, width / -2, height / -2);
            this.buffer = HTMLCanvasElementLuminanceSource.makeBufferFromCanvasImageData(tempCanvasElement);
            return this;
          }
          invert() {
            return new InvertedLuminanceSource(this);
          }
        }
        HTMLCanvasElementLuminanceSource.DEGREE_TO_RADIANS = Math.PI / 180;
        class VideoInputDevice {
          constructor(deviceId, label, groupId) {
            this.deviceId = deviceId;
            this.label = label;
            this.kind = "videoinput";
            this.groupId = groupId || void 0;
          }
          toJSON() {
            return {
              kind: this.kind,
              groupId: this.groupId,
              deviceId: this.deviceId,
              label: this.label
            };
          }
        }
        var __awaiter8 = (globalThis || global || self || window || void 0) && (globalThis || global || self || window || void 0).__awaiter || function(thisArg, _arguments, P, generator) {
          function adopt(value) {
            return value instanceof P ? value : new P(function(resolve) {
              resolve(value);
            });
          }
          return new (P || (P = Promise))(function(resolve, reject) {
            function fulfilled(value) {
              try {
                step(generator.next(value));
              } catch (e) {
                reject(e);
              }
            }
            function rejected(value) {
              try {
                step(generator["throw"](value));
              } catch (e) {
                reject(e);
              }
            }
            function step(result) {
              result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
          });
        };
        class BrowserCodeReader {
          constructor(reader, timeBetweenScansMillis = 500, _hints) {
            this.reader = reader;
            this.timeBetweenScansMillis = timeBetweenScansMillis;
            this._hints = _hints;
            this._stopContinuousDecode = false;
            this._stopAsyncDecode = false;
            this._timeBetweenDecodingAttempts = 0;
          }
          get hasNavigator() {
            return typeof navigator !== "undefined";
          }
          get isMediaDevicesSuported() {
            return this.hasNavigator && !!navigator.mediaDevices;
          }
          get canEnumerateDevices() {
            return !!(this.isMediaDevicesSuported && navigator.mediaDevices.enumerateDevices);
          }
          get timeBetweenDecodingAttempts() {
            return this._timeBetweenDecodingAttempts;
          }
          set timeBetweenDecodingAttempts(millis) {
            this._timeBetweenDecodingAttempts = millis < 0 ? 0 : millis;
          }
          set hints(hints) {
            this._hints = hints || null;
          }
          get hints() {
            return this._hints;
          }
          listVideoInputDevices() {
            return __awaiter8(this, void 0, void 0, function* () {
              if (!this.hasNavigator) {
                throw new Error("Can't enumerate devices, navigator is not present.");
              }
              if (!this.canEnumerateDevices) {
                throw new Error("Can't enumerate devices, method not supported.");
              }
              const devices = yield navigator.mediaDevices.enumerateDevices();
              const videoDevices = [];
              for (const device of devices) {
                const kind = device.kind === "video" ? "videoinput" : device.kind;
                if (kind !== "videoinput") {
                  continue;
                }
                const deviceId = device.deviceId || device.id;
                const label = device.label || `Video device ${videoDevices.length + 1}`;
                const groupId = device.groupId;
                const videoDevice = { deviceId, label, kind, groupId };
                videoDevices.push(videoDevice);
              }
              return videoDevices;
            });
          }
          getVideoInputDevices() {
            return __awaiter8(this, void 0, void 0, function* () {
              const devices = yield this.listVideoInputDevices();
              return devices.map((d) => new VideoInputDevice(d.deviceId, d.label));
            });
          }
          findDeviceById(deviceId) {
            return __awaiter8(this, void 0, void 0, function* () {
              const devices = yield this.listVideoInputDevices();
              if (!devices) {
                return null;
              }
              return devices.find((x) => x.deviceId === deviceId);
            });
          }
          decodeFromInputVideoDevice(deviceId, videoSource) {
            return __awaiter8(this, void 0, void 0, function* () {
              return yield this.decodeOnceFromVideoDevice(deviceId, videoSource);
            });
          }
          decodeOnceFromVideoDevice(deviceId, videoSource) {
            return __awaiter8(this, void 0, void 0, function* () {
              this.reset();
              let videoConstraints;
              if (!deviceId) {
                videoConstraints = { facingMode: "environment" };
              } else {
                videoConstraints = { deviceId: { exact: deviceId } };
              }
              const constraints = { video: videoConstraints };
              return yield this.decodeOnceFromConstraints(constraints, videoSource);
            });
          }
          decodeOnceFromConstraints(constraints, videoSource) {
            return __awaiter8(this, void 0, void 0, function* () {
              const stream = yield navigator.mediaDevices.getUserMedia(constraints);
              return yield this.decodeOnceFromStream(stream, videoSource);
            });
          }
          decodeOnceFromStream(stream, videoSource) {
            return __awaiter8(this, void 0, void 0, function* () {
              this.reset();
              const video = yield this.attachStreamToVideo(stream, videoSource);
              const result = yield this.decodeOnce(video);
              return result;
            });
          }
          decodeFromInputVideoDeviceContinuously(deviceId, videoSource, callbackFn) {
            return __awaiter8(this, void 0, void 0, function* () {
              return yield this.decodeFromVideoDevice(deviceId, videoSource, callbackFn);
            });
          }
          decodeFromVideoDevice(deviceId, videoSource, callbackFn) {
            return __awaiter8(this, void 0, void 0, function* () {
              let videoConstraints;
              if (!deviceId) {
                videoConstraints = { facingMode: "environment" };
              } else {
                videoConstraints = { deviceId: { exact: deviceId } };
              }
              const constraints = { video: videoConstraints };
              return yield this.decodeFromConstraints(constraints, videoSource, callbackFn);
            });
          }
          decodeFromConstraints(constraints, videoSource, callbackFn) {
            return __awaiter8(this, void 0, void 0, function* () {
              const stream = yield navigator.mediaDevices.getUserMedia(constraints);
              return yield this.decodeFromStream(stream, videoSource, callbackFn);
            });
          }
          decodeFromStream(stream, videoSource, callbackFn) {
            return __awaiter8(this, void 0, void 0, function* () {
              this.reset();
              const video = yield this.attachStreamToVideo(stream, videoSource);
              return yield this.decodeContinuously(video, callbackFn);
            });
          }
          stopAsyncDecode() {
            this._stopAsyncDecode = true;
          }
          stopContinuousDecode() {
            this._stopContinuousDecode = true;
          }
          attachStreamToVideo(stream, videoSource) {
            return __awaiter8(this, void 0, void 0, function* () {
              const videoElement = this.prepareVideoElement(videoSource);
              this.addVideoSource(videoElement, stream);
              this.videoElement = videoElement;
              this.stream = stream;
              yield this.playVideoOnLoadAsync(videoElement);
              return videoElement;
            });
          }
          playVideoOnLoadAsync(videoElement) {
            return new Promise((resolve, reject) => this.playVideoOnLoad(videoElement, () => resolve()));
          }
          playVideoOnLoad(element, callbackFn) {
            this.videoEndedListener = () => this.stopStreams();
            this.videoCanPlayListener = () => this.tryPlayVideo(element);
            element.addEventListener("ended", this.videoEndedListener);
            element.addEventListener("canplay", this.videoCanPlayListener);
            element.addEventListener("playing", callbackFn);
            this.tryPlayVideo(element);
          }
          isVideoPlaying(video) {
            return video.currentTime > 0 && !video.paused && !video.ended && video.readyState > 2;
          }
          tryPlayVideo(videoElement) {
            return __awaiter8(this, void 0, void 0, function* () {
              if (this.isVideoPlaying(videoElement)) {
                console.warn("Trying to play video that is already playing.");
                return;
              }
              try {
                yield videoElement.play();
              } catch (_a) {
                console.warn("It was not possible to play the video.");
              }
            });
          }
          getMediaElement(mediaElementId, type) {
            const mediaElement = document.getElementById(mediaElementId);
            if (!mediaElement) {
              throw new ArgumentException(`element with id '${mediaElementId}' not found`);
            }
            if (mediaElement.nodeName.toLowerCase() !== type.toLowerCase()) {
              throw new ArgumentException(`element with id '${mediaElementId}' must be an ${type} element`);
            }
            return mediaElement;
          }
          decodeFromImage(source, url) {
            if (!source && !url) {
              throw new ArgumentException("either imageElement with a src set or an url must be provided");
            }
            if (url && !source) {
              return this.decodeFromImageUrl(url);
            }
            return this.decodeFromImageElement(source);
          }
          decodeFromVideo(source, url) {
            if (!source && !url) {
              throw new ArgumentException("Either an element with a src set or an URL must be provided");
            }
            if (url && !source) {
              return this.decodeFromVideoUrl(url);
            }
            return this.decodeFromVideoElement(source);
          }
          decodeFromVideoContinuously(source, url, callbackFn) {
            if (source === void 0 && url === void 0) {
              throw new ArgumentException("Either an element with a src set or an URL must be provided");
            }
            if (url && !source) {
              return this.decodeFromVideoUrlContinuously(url, callbackFn);
            }
            return this.decodeFromVideoElementContinuously(source, callbackFn);
          }
          decodeFromImageElement(source) {
            if (!source) {
              throw new ArgumentException("An image element must be provided.");
            }
            this.reset();
            const element = this.prepareImageElement(source);
            this.imageElement = element;
            let task;
            if (this.isImageLoaded(element)) {
              task = this.decodeOnce(element, false, true);
            } else {
              task = this._decodeOnLoadImage(element);
            }
            return task;
          }
          decodeFromVideoElement(source) {
            const element = this._decodeFromVideoElementSetup(source);
            return this._decodeOnLoadVideo(element);
          }
          decodeFromVideoElementContinuously(source, callbackFn) {
            const element = this._decodeFromVideoElementSetup(source);
            return this._decodeOnLoadVideoContinuously(element, callbackFn);
          }
          _decodeFromVideoElementSetup(source) {
            if (!source) {
              throw new ArgumentException("A video element must be provided.");
            }
            this.reset();
            const element = this.prepareVideoElement(source);
            this.videoElement = element;
            return element;
          }
          decodeFromImageUrl(url) {
            if (!url) {
              throw new ArgumentException("An URL must be provided.");
            }
            this.reset();
            const element = this.prepareImageElement();
            this.imageElement = element;
            const decodeTask = this._decodeOnLoadImage(element);
            element.src = url;
            return decodeTask;
          }
          decodeFromVideoUrl(url) {
            if (!url) {
              throw new ArgumentException("An URL must be provided.");
            }
            this.reset();
            const element = this.prepareVideoElement();
            const decodeTask = this.decodeFromVideoElement(element);
            element.src = url;
            return decodeTask;
          }
          decodeFromVideoUrlContinuously(url, callbackFn) {
            if (!url) {
              throw new ArgumentException("An URL must be provided.");
            }
            this.reset();
            const element = this.prepareVideoElement();
            const decodeTask = this.decodeFromVideoElementContinuously(element, callbackFn);
            element.src = url;
            return decodeTask;
          }
          _decodeOnLoadImage(element) {
            return new Promise((resolve, reject) => {
              this.imageLoadedListener = () => this.decodeOnce(element, false, true).then(resolve, reject);
              element.addEventListener("load", this.imageLoadedListener);
            });
          }
          _decodeOnLoadVideo(videoElement) {
            return __awaiter8(this, void 0, void 0, function* () {
              yield this.playVideoOnLoadAsync(videoElement);
              return yield this.decodeOnce(videoElement);
            });
          }
          _decodeOnLoadVideoContinuously(videoElement, callbackFn) {
            return __awaiter8(this, void 0, void 0, function* () {
              yield this.playVideoOnLoadAsync(videoElement);
              this.decodeContinuously(videoElement, callbackFn);
            });
          }
          isImageLoaded(img) {
            if (!img.complete) {
              return false;
            }
            if (img.naturalWidth === 0) {
              return false;
            }
            return true;
          }
          prepareImageElement(imageSource) {
            let imageElement;
            if (typeof imageSource === "undefined") {
              imageElement = document.createElement("img");
              imageElement.width = 200;
              imageElement.height = 200;
            }
            if (typeof imageSource === "string") {
              imageElement = this.getMediaElement(imageSource, "img");
            }
            if (imageSource instanceof HTMLImageElement) {
              imageElement = imageSource;
            }
            return imageElement;
          }
          prepareVideoElement(videoSource) {
            let videoElement;
            if (!videoSource && typeof document !== "undefined") {
              videoElement = document.createElement("video");
              videoElement.width = 200;
              videoElement.height = 200;
            }
            if (typeof videoSource === "string") {
              videoElement = this.getMediaElement(videoSource, "video");
            }
            if (videoSource instanceof HTMLVideoElement) {
              videoElement = videoSource;
            }
            videoElement.setAttribute("autoplay", "true");
            videoElement.setAttribute("muted", "true");
            videoElement.setAttribute("playsinline", "true");
            return videoElement;
          }
          decodeOnce(element, retryIfNotFound = true, retryIfChecksumOrFormatError = true) {
            this._stopAsyncDecode = false;
            const loop2 = (resolve, reject) => {
              if (this._stopAsyncDecode) {
                reject(new NotFoundException("Video stream has ended before any code could be detected."));
                this._stopAsyncDecode = void 0;
                return;
              }
              try {
                const result = this.decode(element);
                resolve(result);
              } catch (e) {
                const ifNotFound = retryIfNotFound && e instanceof NotFoundException;
                const isChecksumOrFormatError = e instanceof ChecksumException || e instanceof FormatException;
                const ifChecksumOrFormat = isChecksumOrFormatError && retryIfChecksumOrFormatError;
                if (ifNotFound || ifChecksumOrFormat) {
                  return setTimeout(loop2, this._timeBetweenDecodingAttempts, resolve, reject);
                }
                reject(e);
              }
            };
            return new Promise((resolve, reject) => loop2(resolve, reject));
          }
          decodeContinuously(element, callbackFn) {
            this._stopContinuousDecode = false;
            const loop2 = () => {
              if (this._stopContinuousDecode) {
                this._stopContinuousDecode = void 0;
                return;
              }
              try {
                const result = this.decode(element);
                callbackFn(result, null);
                setTimeout(loop2, this.timeBetweenScansMillis);
              } catch (e) {
                callbackFn(null, e);
                const isChecksumOrFormatError = e instanceof ChecksumException || e instanceof FormatException;
                const isNotFound = e instanceof NotFoundException;
                if (isChecksumOrFormatError || isNotFound) {
                  setTimeout(loop2, this._timeBetweenDecodingAttempts);
                }
              }
            };
            loop2();
          }
          decode(element) {
            const binaryBitmap = this.createBinaryBitmap(element);
            return this.decodeBitmap(binaryBitmap);
          }
          _isHTMLVideoElement(mediaElement) {
            const potentialVideo = mediaElement;
            return potentialVideo.videoWidth !== 0;
          }
          drawFrameOnCanvas(srcElement, dimensions, canvasElementContext) {
            if (!dimensions) {
              dimensions = {
                sx: 0,
                sy: 0,
                sWidth: srcElement.videoWidth,
                sHeight: srcElement.videoHeight,
                dx: 0,
                dy: 0,
                dWidth: srcElement.videoWidth,
                dHeight: srcElement.videoHeight
              };
            }
            if (!canvasElementContext) {
              canvasElementContext = this.captureCanvasContext;
            }
            canvasElementContext.drawImage(srcElement, dimensions.sx, dimensions.sy, dimensions.sWidth, dimensions.sHeight, dimensions.dx, dimensions.dy, dimensions.dWidth, dimensions.dHeight);
          }
          drawImageOnCanvas(srcElement, dimensions, canvasElementContext = this.captureCanvasContext) {
            if (!dimensions) {
              dimensions = {
                sx: 0,
                sy: 0,
                sWidth: srcElement.naturalWidth,
                sHeight: srcElement.naturalHeight,
                dx: 0,
                dy: 0,
                dWidth: srcElement.naturalWidth,
                dHeight: srcElement.naturalHeight
              };
            }
            if (!canvasElementContext) {
              canvasElementContext = this.captureCanvasContext;
            }
            canvasElementContext.drawImage(srcElement, dimensions.sx, dimensions.sy, dimensions.sWidth, dimensions.sHeight, dimensions.dx, dimensions.dy, dimensions.dWidth, dimensions.dHeight);
          }
          createBinaryBitmap(mediaElement) {
            const ctx = this.getCaptureCanvasContext(mediaElement);
            if (this._isHTMLVideoElement(mediaElement)) {
              this.drawFrameOnCanvas(mediaElement);
            } else {
              this.drawImageOnCanvas(mediaElement);
            }
            const canvas = this.getCaptureCanvas(mediaElement);
            const luminanceSource = new HTMLCanvasElementLuminanceSource(canvas);
            const hybridBinarizer = new HybridBinarizer(luminanceSource);
            return new BinaryBitmap(hybridBinarizer);
          }
          getCaptureCanvasContext(mediaElement) {
            if (!this.captureCanvasContext) {
              const elem = this.getCaptureCanvas(mediaElement);
              const ctx = elem.getContext("2d");
              this.captureCanvasContext = ctx;
            }
            return this.captureCanvasContext;
          }
          getCaptureCanvas(mediaElement) {
            if (!this.captureCanvas) {
              const elem = this.createCaptureCanvas(mediaElement);
              this.captureCanvas = elem;
            }
            return this.captureCanvas;
          }
          decodeBitmap(binaryBitmap) {
            return this.reader.decode(binaryBitmap, this._hints);
          }
          createCaptureCanvas(mediaElement) {
            if (typeof document === "undefined") {
              this._destroyCaptureCanvas();
              return null;
            }
            const canvasElement = document.createElement("canvas");
            let width;
            let height;
            if (typeof mediaElement !== "undefined") {
              if (mediaElement instanceof HTMLVideoElement) {
                width = mediaElement.videoWidth;
                height = mediaElement.videoHeight;
              } else if (mediaElement instanceof HTMLImageElement) {
                width = mediaElement.naturalWidth || mediaElement.width;
                height = mediaElement.naturalHeight || mediaElement.height;
              }
            }
            canvasElement.style.width = width + "px";
            canvasElement.style.height = height + "px";
            canvasElement.width = width;
            canvasElement.height = height;
            return canvasElement;
          }
          stopStreams() {
            if (this.stream) {
              this.stream.getVideoTracks().forEach((t) => t.stop());
              this.stream = void 0;
            }
            if (this._stopAsyncDecode === false) {
              this.stopAsyncDecode();
            }
            if (this._stopContinuousDecode === false) {
              this.stopContinuousDecode();
            }
          }
          reset() {
            this.stopStreams();
            this._destroyVideoElement();
            this._destroyImageElement();
            this._destroyCaptureCanvas();
          }
          _destroyVideoElement() {
            if (!this.videoElement) {
              return;
            }
            if (typeof this.videoEndedListener !== "undefined") {
              this.videoElement.removeEventListener("ended", this.videoEndedListener);
            }
            if (typeof this.videoPlayingEventListener !== "undefined") {
              this.videoElement.removeEventListener("playing", this.videoPlayingEventListener);
            }
            if (typeof this.videoCanPlayListener !== "undefined") {
              this.videoElement.removeEventListener("loadedmetadata", this.videoCanPlayListener);
            }
            this.cleanVideoSource(this.videoElement);
            this.videoElement = void 0;
          }
          _destroyImageElement() {
            if (!this.imageElement) {
              return;
            }
            if (this.imageLoadedListener !== void 0) {
              this.imageElement.removeEventListener("load", this.imageLoadedListener);
            }
            this.imageElement.src = void 0;
            this.imageElement.removeAttribute("src");
            this.imageElement = void 0;
          }
          _destroyCaptureCanvas() {
            this.captureCanvasContext = void 0;
            this.captureCanvas = void 0;
          }
          addVideoSource(videoElement, stream) {
            try {
              videoElement.srcObject = stream;
            } catch (err) {
              videoElement.src = URL.createObjectURL(stream);
            }
          }
          cleanVideoSource(videoElement) {
            try {
              videoElement.srcObject = null;
            } catch (err) {
              videoElement.src = "";
            }
            this.videoElement.removeAttribute("src");
          }
        }
        class Result {
          constructor(text, rawBytes, numBits = rawBytes == null ? 0 : 8 * rawBytes.length, resultPoints, format, timestamp = System.currentTimeMillis()) {
            this.text = text;
            this.rawBytes = rawBytes;
            this.numBits = numBits;
            this.resultPoints = resultPoints;
            this.format = format;
            this.timestamp = timestamp;
            this.text = text;
            this.rawBytes = rawBytes;
            if (numBits === void 0 || numBits === null) {
              this.numBits = rawBytes === null || rawBytes === void 0 ? 0 : 8 * rawBytes.length;
            } else {
              this.numBits = numBits;
            }
            this.resultPoints = resultPoints;
            this.format = format;
            this.resultMetadata = null;
            if (timestamp === void 0 || timestamp === null) {
              this.timestamp = System.currentTimeMillis();
            } else {
              this.timestamp = timestamp;
            }
          }
          getText() {
            return this.text;
          }
          getRawBytes() {
            return this.rawBytes;
          }
          getNumBits() {
            return this.numBits;
          }
          getResultPoints() {
            return this.resultPoints;
          }
          getBarcodeFormat() {
            return this.format;
          }
          getResultMetadata() {
            return this.resultMetadata;
          }
          putMetadata(type, value) {
            if (this.resultMetadata === null) {
              this.resultMetadata = /* @__PURE__ */ new Map();
            }
            this.resultMetadata.set(type, value);
          }
          putAllMetadata(metadata) {
            if (metadata !== null) {
              if (this.resultMetadata === null) {
                this.resultMetadata = metadata;
              } else {
                this.resultMetadata = new Map(metadata);
              }
            }
          }
          addResultPoints(newPoints) {
            const oldPoints = this.resultPoints;
            if (oldPoints === null) {
              this.resultPoints = newPoints;
            } else if (newPoints !== null && newPoints.length > 0) {
              const allPoints = new Array(oldPoints.length + newPoints.length);
              System.arraycopy(oldPoints, 0, allPoints, 0, oldPoints.length);
              System.arraycopy(newPoints, 0, allPoints, oldPoints.length, newPoints.length);
              this.resultPoints = allPoints;
            }
          }
          getTimestamp() {
            return this.timestamp;
          }
          toString() {
            return this.text;
          }
        }
        var BarcodeFormat;
        (function(BarcodeFormat2) {
          BarcodeFormat2[BarcodeFormat2["AZTEC"] = 0] = "AZTEC";
          BarcodeFormat2[BarcodeFormat2["CODABAR"] = 1] = "CODABAR";
          BarcodeFormat2[BarcodeFormat2["CODE_39"] = 2] = "CODE_39";
          BarcodeFormat2[BarcodeFormat2["CODE_93"] = 3] = "CODE_93";
          BarcodeFormat2[BarcodeFormat2["CODE_128"] = 4] = "CODE_128";
          BarcodeFormat2[BarcodeFormat2["DATA_MATRIX"] = 5] = "DATA_MATRIX";
          BarcodeFormat2[BarcodeFormat2["EAN_8"] = 6] = "EAN_8";
          BarcodeFormat2[BarcodeFormat2["EAN_13"] = 7] = "EAN_13";
          BarcodeFormat2[BarcodeFormat2["ITF"] = 8] = "ITF";
          BarcodeFormat2[BarcodeFormat2["MAXICODE"] = 9] = "MAXICODE";
          BarcodeFormat2[BarcodeFormat2["PDF_417"] = 10] = "PDF_417";
          BarcodeFormat2[BarcodeFormat2["QR_CODE"] = 11] = "QR_CODE";
          BarcodeFormat2[BarcodeFormat2["RSS_14"] = 12] = "RSS_14";
          BarcodeFormat2[BarcodeFormat2["RSS_EXPANDED"] = 13] = "RSS_EXPANDED";
          BarcodeFormat2[BarcodeFormat2["UPC_A"] = 14] = "UPC_A";
          BarcodeFormat2[BarcodeFormat2["UPC_E"] = 15] = "UPC_E";
          BarcodeFormat2[BarcodeFormat2["UPC_EAN_EXTENSION"] = 16] = "UPC_EAN_EXTENSION";
        })(BarcodeFormat || (BarcodeFormat = {}));
        var BarcodeFormat$1 = BarcodeFormat;
        var ResultMetadataType;
        (function(ResultMetadataType2) {
          ResultMetadataType2[ResultMetadataType2["OTHER"] = 0] = "OTHER";
          ResultMetadataType2[ResultMetadataType2["ORIENTATION"] = 1] = "ORIENTATION";
          ResultMetadataType2[ResultMetadataType2["BYTE_SEGMENTS"] = 2] = "BYTE_SEGMENTS";
          ResultMetadataType2[ResultMetadataType2["ERROR_CORRECTION_LEVEL"] = 3] = "ERROR_CORRECTION_LEVEL";
          ResultMetadataType2[ResultMetadataType2["ISSUE_NUMBER"] = 4] = "ISSUE_NUMBER";
          ResultMetadataType2[ResultMetadataType2["SUGGESTED_PRICE"] = 5] = "SUGGESTED_PRICE";
          ResultMetadataType2[ResultMetadataType2["POSSIBLE_COUNTRY"] = 6] = "POSSIBLE_COUNTRY";
          ResultMetadataType2[ResultMetadataType2["UPC_EAN_EXTENSION"] = 7] = "UPC_EAN_EXTENSION";
          ResultMetadataType2[ResultMetadataType2["PDF417_EXTRA_METADATA"] = 8] = "PDF417_EXTRA_METADATA";
          ResultMetadataType2[ResultMetadataType2["STRUCTURED_APPEND_SEQUENCE"] = 9] = "STRUCTURED_APPEND_SEQUENCE";
          ResultMetadataType2[ResultMetadataType2["STRUCTURED_APPEND_PARITY"] = 10] = "STRUCTURED_APPEND_PARITY";
        })(ResultMetadataType || (ResultMetadataType = {}));
        var ResultMetadataType$1 = ResultMetadataType;
        class DecoderResult {
          constructor(rawBytes, text, byteSegments, ecLevel, structuredAppendSequenceNumber = -1, structuredAppendParity = -1) {
            this.rawBytes = rawBytes;
            this.text = text;
            this.byteSegments = byteSegments;
            this.ecLevel = ecLevel;
            this.structuredAppendSequenceNumber = structuredAppendSequenceNumber;
            this.structuredAppendParity = structuredAppendParity;
            this.numBits = rawBytes === void 0 || rawBytes === null ? 0 : 8 * rawBytes.length;
          }
          getRawBytes() {
            return this.rawBytes;
          }
          getNumBits() {
            return this.numBits;
          }
          setNumBits(numBits) {
            this.numBits = numBits;
          }
          getText() {
            return this.text;
          }
          getByteSegments() {
            return this.byteSegments;
          }
          getECLevel() {
            return this.ecLevel;
          }
          getErrorsCorrected() {
            return this.errorsCorrected;
          }
          setErrorsCorrected(errorsCorrected) {
            this.errorsCorrected = errorsCorrected;
          }
          getErasures() {
            return this.erasures;
          }
          setErasures(erasures) {
            this.erasures = erasures;
          }
          getOther() {
            return this.other;
          }
          setOther(other) {
            this.other = other;
          }
          hasStructuredAppend() {
            return this.structuredAppendParity >= 0 && this.structuredAppendSequenceNumber >= 0;
          }
          getStructuredAppendParity() {
            return this.structuredAppendParity;
          }
          getStructuredAppendSequenceNumber() {
            return this.structuredAppendSequenceNumber;
          }
        }
        class AbstractGenericGF {
          exp(a) {
            return this.expTable[a];
          }
          log(a) {
            if (a === 0) {
              throw new IllegalArgumentException();
            }
            return this.logTable[a];
          }
          static addOrSubtract(a, b) {
            return a ^ b;
          }
        }
        class GenericGFPoly {
          constructor(field, coefficients) {
            if (coefficients.length === 0) {
              throw new IllegalArgumentException();
            }
            this.field = field;
            const coefficientsLength = coefficients.length;
            if (coefficientsLength > 1 && coefficients[0] === 0) {
              let firstNonZero = 1;
              while (firstNonZero < coefficientsLength && coefficients[firstNonZero] === 0) {
                firstNonZero++;
              }
              if (firstNonZero === coefficientsLength) {
                this.coefficients = Int32Array.from([0]);
              } else {
                this.coefficients = new Int32Array(coefficientsLength - firstNonZero);
                System.arraycopy(coefficients, firstNonZero, this.coefficients, 0, this.coefficients.length);
              }
            } else {
              this.coefficients = coefficients;
            }
          }
          getCoefficients() {
            return this.coefficients;
          }
          getDegree() {
            return this.coefficients.length - 1;
          }
          isZero() {
            return this.coefficients[0] === 0;
          }
          getCoefficient(degree) {
            return this.coefficients[this.coefficients.length - 1 - degree];
          }
          evaluateAt(a) {
            if (a === 0) {
              return this.getCoefficient(0);
            }
            const coefficients = this.coefficients;
            let result;
            if (a === 1) {
              result = 0;
              for (let i = 0, length = coefficients.length; i !== length; i++) {
                const coefficient = coefficients[i];
                result = AbstractGenericGF.addOrSubtract(result, coefficient);
              }
              return result;
            }
            result = coefficients[0];
            const size2 = coefficients.length;
            const field = this.field;
            for (let i = 1; i < size2; i++) {
              result = AbstractGenericGF.addOrSubtract(field.multiply(a, result), coefficients[i]);
            }
            return result;
          }
          addOrSubtract(other) {
            if (!this.field.equals(other.field)) {
              throw new IllegalArgumentException("GenericGFPolys do not have same GenericGF field");
            }
            if (this.isZero()) {
              return other;
            }
            if (other.isZero()) {
              return this;
            }
            let smallerCoefficients = this.coefficients;
            let largerCoefficients = other.coefficients;
            if (smallerCoefficients.length > largerCoefficients.length) {
              const temp = smallerCoefficients;
              smallerCoefficients = largerCoefficients;
              largerCoefficients = temp;
            }
            let sumDiff = new Int32Array(largerCoefficients.length);
            const lengthDiff = largerCoefficients.length - smallerCoefficients.length;
            System.arraycopy(largerCoefficients, 0, sumDiff, 0, lengthDiff);
            for (let i = lengthDiff; i < largerCoefficients.length; i++) {
              sumDiff[i] = AbstractGenericGF.addOrSubtract(smallerCoefficients[i - lengthDiff], largerCoefficients[i]);
            }
            return new GenericGFPoly(this.field, sumDiff);
          }
          multiply(other) {
            if (!this.field.equals(other.field)) {
              throw new IllegalArgumentException("GenericGFPolys do not have same GenericGF field");
            }
            if (this.isZero() || other.isZero()) {
              return this.field.getZero();
            }
            const aCoefficients = this.coefficients;
            const aLength = aCoefficients.length;
            const bCoefficients = other.coefficients;
            const bLength = bCoefficients.length;
            const product = new Int32Array(aLength + bLength - 1);
            const field = this.field;
            for (let i = 0; i < aLength; i++) {
              const aCoeff = aCoefficients[i];
              for (let j = 0; j < bLength; j++) {
                product[i + j] = AbstractGenericGF.addOrSubtract(product[i + j], field.multiply(aCoeff, bCoefficients[j]));
              }
            }
            return new GenericGFPoly(field, product);
          }
          multiplyScalar(scalar) {
            if (scalar === 0) {
              return this.field.getZero();
            }
            if (scalar === 1) {
              return this;
            }
            const size2 = this.coefficients.length;
            const field = this.field;
            const product = new Int32Array(size2);
            const coefficients = this.coefficients;
            for (let i = 0; i < size2; i++) {
              product[i] = field.multiply(coefficients[i], scalar);
            }
            return new GenericGFPoly(field, product);
          }
          multiplyByMonomial(degree, coefficient) {
            if (degree < 0) {
              throw new IllegalArgumentException();
            }
            if (coefficient === 0) {
              return this.field.getZero();
            }
            const coefficients = this.coefficients;
            const size2 = coefficients.length;
            const product = new Int32Array(size2 + degree);
            const field = this.field;
            for (let i = 0; i < size2; i++) {
              product[i] = field.multiply(coefficients[i], coefficient);
            }
            return new GenericGFPoly(field, product);
          }
          divide(other) {
            if (!this.field.equals(other.field)) {
              throw new IllegalArgumentException("GenericGFPolys do not have same GenericGF field");
            }
            if (other.isZero()) {
              throw new IllegalArgumentException("Divide by 0");
            }
            const field = this.field;
            let quotient = field.getZero();
            let remainder = this;
            const denominatorLeadingTerm = other.getCoefficient(other.getDegree());
            const inverseDenominatorLeadingTerm = field.inverse(denominatorLeadingTerm);
            while (remainder.getDegree() >= other.getDegree() && !remainder.isZero()) {
              const degreeDifference = remainder.getDegree() - other.getDegree();
              const scale = field.multiply(remainder.getCoefficient(remainder.getDegree()), inverseDenominatorLeadingTerm);
              const term = other.multiplyByMonomial(degreeDifference, scale);
              const iterationQuotient = field.buildMonomial(degreeDifference, scale);
              quotient = quotient.addOrSubtract(iterationQuotient);
              remainder = remainder.addOrSubtract(term);
            }
            return [quotient, remainder];
          }
          toString() {
            let result = "";
            for (let degree = this.getDegree(); degree >= 0; degree--) {
              let coefficient = this.getCoefficient(degree);
              if (coefficient !== 0) {
                if (coefficient < 0) {
                  result += " - ";
                  coefficient = -coefficient;
                } else {
                  if (result.length > 0) {
                    result += " + ";
                  }
                }
                if (degree === 0 || coefficient !== 1) {
                  const alphaPower = this.field.log(coefficient);
                  if (alphaPower === 0) {
                    result += "1";
                  } else if (alphaPower === 1) {
                    result += "a";
                  } else {
                    result += "a^";
                    result += alphaPower;
                  }
                }
                if (degree !== 0) {
                  if (degree === 1) {
                    result += "x";
                  } else {
                    result += "x^";
                    result += degree;
                  }
                }
              }
            }
            return result;
          }
        }
        class ArithmeticException extends Exception {
        }
        ArithmeticException.kind = "ArithmeticException";
        class GenericGF extends AbstractGenericGF {
          constructor(primitive, size2, generatorBase) {
            super();
            this.primitive = primitive;
            this.size = size2;
            this.generatorBase = generatorBase;
            const expTable = new Int32Array(size2);
            let x = 1;
            for (let i = 0; i < size2; i++) {
              expTable[i] = x;
              x *= 2;
              if (x >= size2) {
                x ^= primitive;
                x &= size2 - 1;
              }
            }
            this.expTable = expTable;
            const logTable = new Int32Array(size2);
            for (let i = 0; i < size2 - 1; i++) {
              logTable[expTable[i]] = i;
            }
            this.logTable = logTable;
            this.zero = new GenericGFPoly(this, Int32Array.from([0]));
            this.one = new GenericGFPoly(this, Int32Array.from([1]));
          }
          getZero() {
            return this.zero;
          }
          getOne() {
            return this.one;
          }
          buildMonomial(degree, coefficient) {
            if (degree < 0) {
              throw new IllegalArgumentException();
            }
            if (coefficient === 0) {
              return this.zero;
            }
            const coefficients = new Int32Array(degree + 1);
            coefficients[0] = coefficient;
            return new GenericGFPoly(this, coefficients);
          }
          inverse(a) {
            if (a === 0) {
              throw new ArithmeticException();
            }
            return this.expTable[this.size - this.logTable[a] - 1];
          }
          multiply(a, b) {
            if (a === 0 || b === 0) {
              return 0;
            }
            return this.expTable[(this.logTable[a] + this.logTable[b]) % (this.size - 1)];
          }
          getSize() {
            return this.size;
          }
          getGeneratorBase() {
            return this.generatorBase;
          }
          toString() {
            return "GF(0x" + Integer.toHexString(this.primitive) + "," + this.size + ")";
          }
          equals(o) {
            return o === this;
          }
        }
        GenericGF.AZTEC_DATA_12 = new GenericGF(4201, 4096, 1);
        GenericGF.AZTEC_DATA_10 = new GenericGF(1033, 1024, 1);
        GenericGF.AZTEC_DATA_6 = new GenericGF(67, 64, 1);
        GenericGF.AZTEC_PARAM = new GenericGF(19, 16, 1);
        GenericGF.QR_CODE_FIELD_256 = new GenericGF(285, 256, 0);
        GenericGF.DATA_MATRIX_FIELD_256 = new GenericGF(301, 256, 1);
        GenericGF.AZTEC_DATA_8 = GenericGF.DATA_MATRIX_FIELD_256;
        GenericGF.MAXICODE_FIELD_64 = GenericGF.AZTEC_DATA_6;
        class ReedSolomonException extends Exception {
        }
        ReedSolomonException.kind = "ReedSolomonException";
        class IllegalStateException extends Exception {
        }
        IllegalStateException.kind = "IllegalStateException";
        class ReedSolomonDecoder {
          constructor(field) {
            this.field = field;
          }
          decode(received, twoS) {
            const field = this.field;
            const poly = new GenericGFPoly(field, received);
            const syndromeCoefficients = new Int32Array(twoS);
            let noError = true;
            for (let i = 0; i < twoS; i++) {
              const evalResult = poly.evaluateAt(field.exp(i + field.getGeneratorBase()));
              syndromeCoefficients[syndromeCoefficients.length - 1 - i] = evalResult;
              if (evalResult !== 0) {
                noError = false;
              }
            }
            if (noError) {
              return;
            }
            const syndrome = new GenericGFPoly(field, syndromeCoefficients);
            const sigmaOmega = this.runEuclideanAlgorithm(field.buildMonomial(twoS, 1), syndrome, twoS);
            const sigma = sigmaOmega[0];
            const omega = sigmaOmega[1];
            const errorLocations = this.findErrorLocations(sigma);
            const errorMagnitudes = this.findErrorMagnitudes(omega, errorLocations);
            for (let i = 0; i < errorLocations.length; i++) {
              const position = received.length - 1 - field.log(errorLocations[i]);
              if (position < 0) {
                throw new ReedSolomonException("Bad error location");
              }
              received[position] = GenericGF.addOrSubtract(received[position], errorMagnitudes[i]);
            }
          }
          runEuclideanAlgorithm(a, b, R) {
            if (a.getDegree() < b.getDegree()) {
              const temp = a;
              a = b;
              b = temp;
            }
            const field = this.field;
            let rLast = a;
            let r = b;
            let tLast = field.getZero();
            let t = field.getOne();
            while (r.getDegree() >= (R / 2 | 0)) {
              let rLastLast = rLast;
              let tLastLast = tLast;
              rLast = r;
              tLast = t;
              if (rLast.isZero()) {
                throw new ReedSolomonException("r_{i-1} was zero");
              }
              r = rLastLast;
              let q = field.getZero();
              const denominatorLeadingTerm = rLast.getCoefficient(rLast.getDegree());
              const dltInverse = field.inverse(denominatorLeadingTerm);
              while (r.getDegree() >= rLast.getDegree() && !r.isZero()) {
                const degreeDiff = r.getDegree() - rLast.getDegree();
                const scale = field.multiply(r.getCoefficient(r.getDegree()), dltInverse);
                q = q.addOrSubtract(field.buildMonomial(degreeDiff, scale));
                r = r.addOrSubtract(rLast.multiplyByMonomial(degreeDiff, scale));
              }
              t = q.multiply(tLast).addOrSubtract(tLastLast);
              if (r.getDegree() >= rLast.getDegree()) {
                throw new IllegalStateException("Division algorithm failed to reduce polynomial?");
              }
            }
            const sigmaTildeAtZero = t.getCoefficient(0);
            if (sigmaTildeAtZero === 0) {
              throw new ReedSolomonException("sigmaTilde(0) was zero");
            }
            const inverse = field.inverse(sigmaTildeAtZero);
            const sigma = t.multiplyScalar(inverse);
            const omega = r.multiplyScalar(inverse);
            return [sigma, omega];
          }
          findErrorLocations(errorLocator) {
            const numErrors = errorLocator.getDegree();
            if (numErrors === 1) {
              return Int32Array.from([errorLocator.getCoefficient(1)]);
            }
            const result = new Int32Array(numErrors);
            let e = 0;
            const field = this.field;
            for (let i = 1; i < field.getSize() && e < numErrors; i++) {
              if (errorLocator.evaluateAt(i) === 0) {
                result[e] = field.inverse(i);
                e++;
              }
            }
            if (e !== numErrors) {
              throw new ReedSolomonException("Error locator degree does not match number of roots");
            }
            return result;
          }
          findErrorMagnitudes(errorEvaluator, errorLocations) {
            const s = errorLocations.length;
            const result = new Int32Array(s);
            const field = this.field;
            for (let i = 0; i < s; i++) {
              const xiInverse = field.inverse(errorLocations[i]);
              let denominator = 1;
              for (let j = 0; j < s; j++) {
                if (i !== j) {
                  const term = field.multiply(errorLocations[j], xiInverse);
                  const termPlus1 = (term & 1) === 0 ? term | 1 : term & ~1;
                  denominator = field.multiply(denominator, termPlus1);
                }
              }
              result[i] = field.multiply(errorEvaluator.evaluateAt(xiInverse), field.inverse(denominator));
              if (field.getGeneratorBase() !== 0) {
                result[i] = field.multiply(result[i], xiInverse);
              }
            }
            return result;
          }
        }
        var Table;
        (function(Table2) {
          Table2[Table2["UPPER"] = 0] = "UPPER";
          Table2[Table2["LOWER"] = 1] = "LOWER";
          Table2[Table2["MIXED"] = 2] = "MIXED";
          Table2[Table2["DIGIT"] = 3] = "DIGIT";
          Table2[Table2["PUNCT"] = 4] = "PUNCT";
          Table2[Table2["BINARY"] = 5] = "BINARY";
        })(Table || (Table = {}));
        class Decoder {
          decode(detectorResult) {
            this.ddata = detectorResult;
            let matrix = detectorResult.getBits();
            let rawbits = this.extractBits(matrix);
            let correctedBits = this.correctBits(rawbits);
            let rawBytes = Decoder.convertBoolArrayToByteArray(correctedBits);
            let result = Decoder.getEncodedData(correctedBits);
            let decoderResult = new DecoderResult(rawBytes, result, null, null);
            decoderResult.setNumBits(correctedBits.length);
            return decoderResult;
          }
          static highLevelDecode(correctedBits) {
            return this.getEncodedData(correctedBits);
          }
          static getEncodedData(correctedBits) {
            let endIndex = correctedBits.length;
            let latchTable = Table.UPPER;
            let shiftTable = Table.UPPER;
            let result = "";
            let index = 0;
            while (index < endIndex) {
              if (shiftTable === Table.BINARY) {
                if (endIndex - index < 5) {
                  break;
                }
                let length = Decoder.readCode(correctedBits, index, 5);
                index += 5;
                if (length === 0) {
                  if (endIndex - index < 11) {
                    break;
                  }
                  length = Decoder.readCode(correctedBits, index, 11) + 31;
                  index += 11;
                }
                for (let charCount = 0; charCount < length; charCount++) {
                  if (endIndex - index < 8) {
                    index = endIndex;
                    break;
                  }
                  const code = Decoder.readCode(correctedBits, index, 8);
                  result += StringUtils.castAsNonUtf8Char(code);
                  index += 8;
                }
                shiftTable = latchTable;
              } else {
                let size2 = shiftTable === Table.DIGIT ? 4 : 5;
                if (endIndex - index < size2) {
                  break;
                }
                let code = Decoder.readCode(correctedBits, index, size2);
                index += size2;
                let str = Decoder.getCharacter(shiftTable, code);
                if (str.startsWith("CTRL_")) {
                  latchTable = shiftTable;
                  shiftTable = Decoder.getTable(str.charAt(5));
                  if (str.charAt(6) === "L") {
                    latchTable = shiftTable;
                  }
                } else {
                  result += str;
                  shiftTable = latchTable;
                }
              }
            }
            return result;
          }
          static getTable(t) {
            switch (t) {
              case "L":
                return Table.LOWER;
              case "P":
                return Table.PUNCT;
              case "M":
                return Table.MIXED;
              case "D":
                return Table.DIGIT;
              case "B":
                return Table.BINARY;
              case "U":
              default:
                return Table.UPPER;
            }
          }
          static getCharacter(table, code) {
            switch (table) {
              case Table.UPPER:
                return Decoder.UPPER_TABLE[code];
              case Table.LOWER:
                return Decoder.LOWER_TABLE[code];
              case Table.MIXED:
                return Decoder.MIXED_TABLE[code];
              case Table.PUNCT:
                return Decoder.PUNCT_TABLE[code];
              case Table.DIGIT:
                return Decoder.DIGIT_TABLE[code];
              default:
                throw new IllegalStateException("Bad table");
            }
          }
          correctBits(rawbits) {
            let gf;
            let codewordSize;
            if (this.ddata.getNbLayers() <= 2) {
              codewordSize = 6;
              gf = GenericGF.AZTEC_DATA_6;
            } else if (this.ddata.getNbLayers() <= 8) {
              codewordSize = 8;
              gf = GenericGF.AZTEC_DATA_8;
            } else if (this.ddata.getNbLayers() <= 22) {
              codewordSize = 10;
              gf = GenericGF.AZTEC_DATA_10;
            } else {
              codewordSize = 12;
              gf = GenericGF.AZTEC_DATA_12;
            }
            let numDataCodewords = this.ddata.getNbDatablocks();
            let numCodewords = rawbits.length / codewordSize;
            if (numCodewords < numDataCodewords) {
              throw new FormatException();
            }
            let offset = rawbits.length % codewordSize;
            let dataWords = new Int32Array(numCodewords);
            for (let i = 0; i < numCodewords; i++, offset += codewordSize) {
              dataWords[i] = Decoder.readCode(rawbits, offset, codewordSize);
            }
            try {
              let rsDecoder = new ReedSolomonDecoder(gf);
              rsDecoder.decode(dataWords, numCodewords - numDataCodewords);
            } catch (ex) {
              throw new FormatException(ex);
            }
            let mask = (1 << codewordSize) - 1;
            let stuffedBits = 0;
            for (let i = 0; i < numDataCodewords; i++) {
              let dataWord = dataWords[i];
              if (dataWord === 0 || dataWord === mask) {
                throw new FormatException();
              } else if (dataWord === 1 || dataWord === mask - 1) {
                stuffedBits++;
              }
            }
            let correctedBits = new Array(numDataCodewords * codewordSize - stuffedBits);
            let index = 0;
            for (let i = 0; i < numDataCodewords; i++) {
              let dataWord = dataWords[i];
              if (dataWord === 1 || dataWord === mask - 1) {
                correctedBits.fill(dataWord > 1, index, index + codewordSize - 1);
                index += codewordSize - 1;
              } else {
                for (let bit = codewordSize - 1; bit >= 0; --bit) {
                  correctedBits[index++] = (dataWord & 1 << bit) !== 0;
                }
              }
            }
            return correctedBits;
          }
          extractBits(matrix) {
            let compact = this.ddata.isCompact();
            let layers = this.ddata.getNbLayers();
            let baseMatrixSize = (compact ? 11 : 14) + layers * 4;
            let alignmentMap = new Int32Array(baseMatrixSize);
            let rawbits = new Array(this.totalBitsInLayer(layers, compact));
            if (compact) {
              for (let i = 0; i < alignmentMap.length; i++) {
                alignmentMap[i] = i;
              }
            } else {
              let matrixSize = baseMatrixSize + 1 + 2 * Integer.truncDivision(Integer.truncDivision(baseMatrixSize, 2) - 1, 15);
              let origCenter = baseMatrixSize / 2;
              let center = Integer.truncDivision(matrixSize, 2);
              for (let i = 0; i < origCenter; i++) {
                let newOffset = i + Integer.truncDivision(i, 15);
                alignmentMap[origCenter - i - 1] = center - newOffset - 1;
                alignmentMap[origCenter + i] = center + newOffset + 1;
              }
            }
            for (let i = 0, rowOffset = 0; i < layers; i++) {
              let rowSize = (layers - i) * 4 + (compact ? 9 : 12);
              let low = i * 2;
              let high = baseMatrixSize - 1 - low;
              for (let j = 0; j < rowSize; j++) {
                let columnOffset = j * 2;
                for (let k = 0; k < 2; k++) {
                  rawbits[rowOffset + columnOffset + k] = matrix.get(alignmentMap[low + k], alignmentMap[low + j]);
                  rawbits[rowOffset + 2 * rowSize + columnOffset + k] = matrix.get(alignmentMap[low + j], alignmentMap[high - k]);
                  rawbits[rowOffset + 4 * rowSize + columnOffset + k] = matrix.get(alignmentMap[high - k], alignmentMap[high - j]);
                  rawbits[rowOffset + 6 * rowSize + columnOffset + k] = matrix.get(alignmentMap[high - j], alignmentMap[low + k]);
                }
              }
              rowOffset += rowSize * 8;
            }
            return rawbits;
          }
          static readCode(rawbits, startIndex, length) {
            let res = 0;
            for (let i = startIndex; i < startIndex + length; i++) {
              res <<= 1;
              if (rawbits[i]) {
                res |= 1;
              }
            }
            return res;
          }
          static readByte(rawbits, startIndex) {
            let n = rawbits.length - startIndex;
            if (n >= 8) {
              return Decoder.readCode(rawbits, startIndex, 8);
            }
            return Decoder.readCode(rawbits, startIndex, n) << 8 - n;
          }
          static convertBoolArrayToByteArray(boolArr) {
            let byteArr = new Uint8Array((boolArr.length + 7) / 8);
            for (let i = 0; i < byteArr.length; i++) {
              byteArr[i] = Decoder.readByte(boolArr, 8 * i);
            }
            return byteArr;
          }
          totalBitsInLayer(layers, compact) {
            return ((compact ? 88 : 112) + 16 * layers) * layers;
          }
        }
        Decoder.UPPER_TABLE = [
          "CTRL_PS",
          " ",
          "A",
          "B",
          "C",
          "D",
          "E",
          "F",
          "G",
          "H",
          "I",
          "J",
          "K",
          "L",
          "M",
          "N",
          "O",
          "P",
          "Q",
          "R",
          "S",
          "T",
          "U",
          "V",
          "W",
          "X",
          "Y",
          "Z",
          "CTRL_LL",
          "CTRL_ML",
          "CTRL_DL",
          "CTRL_BS"
        ];
        Decoder.LOWER_TABLE = [
          "CTRL_PS",
          " ",
          "a",
          "b",
          "c",
          "d",
          "e",
          "f",
          "g",
          "h",
          "i",
          "j",
          "k",
          "l",
          "m",
          "n",
          "o",
          "p",
          "q",
          "r",
          "s",
          "t",
          "u",
          "v",
          "w",
          "x",
          "y",
          "z",
          "CTRL_US",
          "CTRL_ML",
          "CTRL_DL",
          "CTRL_BS"
        ];
        Decoder.MIXED_TABLE = [
          "CTRL_PS",
          " ",
          "\\1",
          "\\2",
          "\\3",
          "\\4",
          "\\5",
          "\\6",
          "\\7",
          "\b",
          "	",
          "\n",
          "\\13",
          "\f",
          "\r",
          "\\33",
          "\\34",
          "\\35",
          "\\36",
          "\\37",
          "@",
          "\\",
          "^",
          "_",
          "`",
          "|",
          "~",
          "\\177",
          "CTRL_LL",
          "CTRL_UL",
          "CTRL_PL",
          "CTRL_BS"
        ];
        Decoder.PUNCT_TABLE = [
          "",
          "\r",
          "\r\n",
          ". ",
          ", ",
          ": ",
          "!",
          '"',
          "#",
          "$",
          "%",
          "&",
          "'",
          "(",
          ")",
          "*",
          "+",
          ",",
          "-",
          ".",
          "/",
          ":",
          ";",
          "<",
          "=",
          ">",
          "?",
          "[",
          "]",
          "{",
          "}",
          "CTRL_UL"
        ];
        Decoder.DIGIT_TABLE = [
          "CTRL_PS",
          " ",
          "0",
          "1",
          "2",
          "3",
          "4",
          "5",
          "6",
          "7",
          "8",
          "9",
          ",",
          ".",
          "CTRL_UL",
          "CTRL_US"
        ];
        class MathUtils {
          constructor() {
          }
          static round(d) {
            if (d === NaN)
              return 0;
            if (d <= Number.MIN_SAFE_INTEGER)
              return Number.MIN_SAFE_INTEGER;
            if (d >= Number.MAX_SAFE_INTEGER)
              return Number.MAX_SAFE_INTEGER;
            return d + (d < 0 ? -0.5 : 0.5) | 0;
          }
          static distance(aX, aY, bX, bY) {
            const xDiff = aX - bX;
            const yDiff = aY - bY;
            return Math.sqrt(xDiff * xDiff + yDiff * yDiff);
          }
          static sum(array) {
            let count = 0;
            for (let i = 0, length = array.length; i !== length; i++) {
              const a = array[i];
              count += a;
            }
            return count;
          }
        }
        class Float {
          static floatToIntBits(f) {
            return f;
          }
        }
        Float.MAX_VALUE = Number.MAX_SAFE_INTEGER;
        class ResultPoint {
          constructor(x, y) {
            this.x = x;
            this.y = y;
          }
          getX() {
            return this.x;
          }
          getY() {
            return this.y;
          }
          equals(other) {
            if (other instanceof ResultPoint) {
              const otherPoint = other;
              return this.x === otherPoint.x && this.y === otherPoint.y;
            }
            return false;
          }
          hashCode() {
            return 31 * Float.floatToIntBits(this.x) + Float.floatToIntBits(this.y);
          }
          toString() {
            return "(" + this.x + "," + this.y + ")";
          }
          static orderBestPatterns(patterns2) {
            const zeroOneDistance = this.distance(patterns2[0], patterns2[1]);
            const oneTwoDistance = this.distance(patterns2[1], patterns2[2]);
            const zeroTwoDistance = this.distance(patterns2[0], patterns2[2]);
            let pointA;
            let pointB;
            let pointC;
            if (oneTwoDistance >= zeroOneDistance && oneTwoDistance >= zeroTwoDistance) {
              pointB = patterns2[0];
              pointA = patterns2[1];
              pointC = patterns2[2];
            } else if (zeroTwoDistance >= oneTwoDistance && zeroTwoDistance >= zeroOneDistance) {
              pointB = patterns2[1];
              pointA = patterns2[0];
              pointC = patterns2[2];
            } else {
              pointB = patterns2[2];
              pointA = patterns2[0];
              pointC = patterns2[1];
            }
            if (this.crossProductZ(pointA, pointB, pointC) < 0) {
              const temp = pointA;
              pointA = pointC;
              pointC = temp;
            }
            patterns2[0] = pointA;
            patterns2[1] = pointB;
            patterns2[2] = pointC;
          }
          static distance(pattern1, pattern2) {
            return MathUtils.distance(pattern1.x, pattern1.y, pattern2.x, pattern2.y);
          }
          static crossProductZ(pointA, pointB, pointC) {
            const bX = pointB.x;
            const bY = pointB.y;
            return (pointC.x - bX) * (pointA.y - bY) - (pointC.y - bY) * (pointA.x - bX);
          }
        }
        class DetectorResult {
          constructor(bits, points) {
            this.bits = bits;
            this.points = points;
          }
          getBits() {
            return this.bits;
          }
          getPoints() {
            return this.points;
          }
        }
        class AztecDetectorResult extends DetectorResult {
          constructor(bits, points, compact, nbDatablocks, nbLayers) {
            super(bits, points);
            this.compact = compact;
            this.nbDatablocks = nbDatablocks;
            this.nbLayers = nbLayers;
          }
          getNbLayers() {
            return this.nbLayers;
          }
          getNbDatablocks() {
            return this.nbDatablocks;
          }
          isCompact() {
            return this.compact;
          }
        }
        class WhiteRectangleDetector {
          constructor(image, initSize, x, y) {
            this.image = image;
            this.height = image.getHeight();
            this.width = image.getWidth();
            if (initSize === void 0 || initSize === null) {
              initSize = WhiteRectangleDetector.INIT_SIZE;
            }
            if (x === void 0 || x === null) {
              x = image.getWidth() / 2 | 0;
            }
            if (y === void 0 || y === null) {
              y = image.getHeight() / 2 | 0;
            }
            const halfsize = initSize / 2 | 0;
            this.leftInit = x - halfsize;
            this.rightInit = x + halfsize;
            this.upInit = y - halfsize;
            this.downInit = y + halfsize;
            if (this.upInit < 0 || this.leftInit < 0 || this.downInit >= this.height || this.rightInit >= this.width) {
              throw new NotFoundException();
            }
          }
          detect() {
            let left = this.leftInit;
            let right = this.rightInit;
            let up = this.upInit;
            let down = this.downInit;
            let sizeExceeded = false;
            let aBlackPointFoundOnBorder = true;
            let atLeastOneBlackPointFoundOnBorder = false;
            let atLeastOneBlackPointFoundOnRight = false;
            let atLeastOneBlackPointFoundOnBottom = false;
            let atLeastOneBlackPointFoundOnLeft = false;
            let atLeastOneBlackPointFoundOnTop = false;
            const width = this.width;
            const height = this.height;
            while (aBlackPointFoundOnBorder) {
              aBlackPointFoundOnBorder = false;
              let rightBorderNotWhite = true;
              while ((rightBorderNotWhite || !atLeastOneBlackPointFoundOnRight) && right < width) {
                rightBorderNotWhite = this.containsBlackPoint(up, down, right, false);
                if (rightBorderNotWhite) {
                  right++;
                  aBlackPointFoundOnBorder = true;
                  atLeastOneBlackPointFoundOnRight = true;
                } else if (!atLeastOneBlackPointFoundOnRight) {
                  right++;
                }
              }
              if (right >= width) {
                sizeExceeded = true;
                break;
              }
              let bottomBorderNotWhite = true;
              while ((bottomBorderNotWhite || !atLeastOneBlackPointFoundOnBottom) && down < height) {
                bottomBorderNotWhite = this.containsBlackPoint(left, right, down, true);
                if (bottomBorderNotWhite) {
                  down++;
                  aBlackPointFoundOnBorder = true;
                  atLeastOneBlackPointFoundOnBottom = true;
                } else if (!atLeastOneBlackPointFoundOnBottom) {
                  down++;
                }
              }
              if (down >= height) {
                sizeExceeded = true;
                break;
              }
              let leftBorderNotWhite = true;
              while ((leftBorderNotWhite || !atLeastOneBlackPointFoundOnLeft) && left >= 0) {
                leftBorderNotWhite = this.containsBlackPoint(up, down, left, false);
                if (leftBorderNotWhite) {
                  left--;
                  aBlackPointFoundOnBorder = true;
                  atLeastOneBlackPointFoundOnLeft = true;
                } else if (!atLeastOneBlackPointFoundOnLeft) {
                  left--;
                }
              }
              if (left < 0) {
                sizeExceeded = true;
                break;
              }
              let topBorderNotWhite = true;
              while ((topBorderNotWhite || !atLeastOneBlackPointFoundOnTop) && up >= 0) {
                topBorderNotWhite = this.containsBlackPoint(left, right, up, true);
                if (topBorderNotWhite) {
                  up--;
                  aBlackPointFoundOnBorder = true;
                  atLeastOneBlackPointFoundOnTop = true;
                } else if (!atLeastOneBlackPointFoundOnTop) {
                  up--;
                }
              }
              if (up < 0) {
                sizeExceeded = true;
                break;
              }
              if (aBlackPointFoundOnBorder) {
                atLeastOneBlackPointFoundOnBorder = true;
              }
            }
            if (!sizeExceeded && atLeastOneBlackPointFoundOnBorder) {
              const maxSize = right - left;
              let z = null;
              for (let i = 1; z === null && i < maxSize; i++) {
                z = this.getBlackPointOnSegment(left, down - i, left + i, down);
              }
              if (z == null) {
                throw new NotFoundException();
              }
              let t = null;
              for (let i = 1; t === null && i < maxSize; i++) {
                t = this.getBlackPointOnSegment(left, up + i, left + i, up);
              }
              if (t == null) {
                throw new NotFoundException();
              }
              let x = null;
              for (let i = 1; x === null && i < maxSize; i++) {
                x = this.getBlackPointOnSegment(right, up + i, right - i, up);
              }
              if (x == null) {
                throw new NotFoundException();
              }
              let y = null;
              for (let i = 1; y === null && i < maxSize; i++) {
                y = this.getBlackPointOnSegment(right, down - i, right - i, down);
              }
              if (y == null) {
                throw new NotFoundException();
              }
              return this.centerEdges(y, z, x, t);
            } else {
              throw new NotFoundException();
            }
          }
          getBlackPointOnSegment(aX, aY, bX, bY) {
            const dist = MathUtils.round(MathUtils.distance(aX, aY, bX, bY));
            const xStep = (bX - aX) / dist;
            const yStep = (bY - aY) / dist;
            const image = this.image;
            for (let i = 0; i < dist; i++) {
              const x = MathUtils.round(aX + i * xStep);
              const y = MathUtils.round(aY + i * yStep);
              if (image.get(x, y)) {
                return new ResultPoint(x, y);
              }
            }
            return null;
          }
          centerEdges(y, z, x, t) {
            const yi = y.getX();
            const yj = y.getY();
            const zi = z.getX();
            const zj = z.getY();
            const xi = x.getX();
            const xj = x.getY();
            const ti = t.getX();
            const tj = t.getY();
            const CORR = WhiteRectangleDetector.CORR;
            if (yi < this.width / 2) {
              return [
                new ResultPoint(ti - CORR, tj + CORR),
                new ResultPoint(zi + CORR, zj + CORR),
                new ResultPoint(xi - CORR, xj - CORR),
                new ResultPoint(yi + CORR, yj - CORR)
              ];
            } else {
              return [
                new ResultPoint(ti + CORR, tj + CORR),
                new ResultPoint(zi + CORR, zj - CORR),
                new ResultPoint(xi - CORR, xj + CORR),
                new ResultPoint(yi - CORR, yj - CORR)
              ];
            }
          }
          containsBlackPoint(a, b, fixed, horizontal) {
            const image = this.image;
            if (horizontal) {
              for (let x = a; x <= b; x++) {
                if (image.get(x, fixed)) {
                  return true;
                }
              }
            } else {
              for (let y = a; y <= b; y++) {
                if (image.get(fixed, y)) {
                  return true;
                }
              }
            }
            return false;
          }
        }
        WhiteRectangleDetector.INIT_SIZE = 10;
        WhiteRectangleDetector.CORR = 1;
        class GridSampler {
          static checkAndNudgePoints(image, points) {
            const width = image.getWidth();
            const height = image.getHeight();
            let nudged = true;
            for (let offset = 0; offset < points.length && nudged; offset += 2) {
              const x = Math.floor(points[offset]);
              const y = Math.floor(points[offset + 1]);
              if (x < -1 || x > width || y < -1 || y > height) {
                throw new NotFoundException();
              }
              nudged = false;
              if (x === -1) {
                points[offset] = 0;
                nudged = true;
              } else if (x === width) {
                points[offset] = width - 1;
                nudged = true;
              }
              if (y === -1) {
                points[offset + 1] = 0;
                nudged = true;
              } else if (y === height) {
                points[offset + 1] = height - 1;
                nudged = true;
              }
            }
            nudged = true;
            for (let offset = points.length - 2; offset >= 0 && nudged; offset -= 2) {
              const x = Math.floor(points[offset]);
              const y = Math.floor(points[offset + 1]);
              if (x < -1 || x > width || y < -1 || y > height) {
                throw new NotFoundException();
              }
              nudged = false;
              if (x === -1) {
                points[offset] = 0;
                nudged = true;
              } else if (x === width) {
                points[offset] = width - 1;
                nudged = true;
              }
              if (y === -1) {
                points[offset + 1] = 0;
                nudged = true;
              } else if (y === height) {
                points[offset + 1] = height - 1;
                nudged = true;
              }
            }
          }
        }
        class PerspectiveTransform {
          constructor(a11, a21, a31, a12, a22, a32, a13, a23, a33) {
            this.a11 = a11;
            this.a21 = a21;
            this.a31 = a31;
            this.a12 = a12;
            this.a22 = a22;
            this.a32 = a32;
            this.a13 = a13;
            this.a23 = a23;
            this.a33 = a33;
          }
          static quadrilateralToQuadrilateral(x0, y0, x1, y1, x2, y2, x3, y3, x0p, y0p, x1p, y1p, x2p, y2p, x3p, y3p) {
            const qToS = PerspectiveTransform.quadrilateralToSquare(x0, y0, x1, y1, x2, y2, x3, y3);
            const sToQ = PerspectiveTransform.squareToQuadrilateral(x0p, y0p, x1p, y1p, x2p, y2p, x3p, y3p);
            return sToQ.times(qToS);
          }
          transformPoints(points) {
            const max = points.length;
            const a11 = this.a11;
            const a12 = this.a12;
            const a13 = this.a13;
            const a21 = this.a21;
            const a22 = this.a22;
            const a23 = this.a23;
            const a31 = this.a31;
            const a32 = this.a32;
            const a33 = this.a33;
            for (let i = 0; i < max; i += 2) {
              const x = points[i];
              const y = points[i + 1];
              const denominator = a13 * x + a23 * y + a33;
              points[i] = (a11 * x + a21 * y + a31) / denominator;
              points[i + 1] = (a12 * x + a22 * y + a32) / denominator;
            }
          }
          transformPointsWithValues(xValues, yValues) {
            const a11 = this.a11;
            const a12 = this.a12;
            const a13 = this.a13;
            const a21 = this.a21;
            const a22 = this.a22;
            const a23 = this.a23;
            const a31 = this.a31;
            const a32 = this.a32;
            const a33 = this.a33;
            const n = xValues.length;
            for (let i = 0; i < n; i++) {
              const x = xValues[i];
              const y = yValues[i];
              const denominator = a13 * x + a23 * y + a33;
              xValues[i] = (a11 * x + a21 * y + a31) / denominator;
              yValues[i] = (a12 * x + a22 * y + a32) / denominator;
            }
          }
          static squareToQuadrilateral(x0, y0, x1, y1, x2, y2, x3, y3) {
            const dx3 = x0 - x1 + x2 - x3;
            const dy3 = y0 - y1 + y2 - y3;
            if (dx3 === 0 && dy3 === 0) {
              return new PerspectiveTransform(x1 - x0, x2 - x1, x0, y1 - y0, y2 - y1, y0, 0, 0, 1);
            } else {
              const dx1 = x1 - x2;
              const dx2 = x3 - x2;
              const dy1 = y1 - y2;
              const dy2 = y3 - y2;
              const denominator = dx1 * dy2 - dx2 * dy1;
              const a13 = (dx3 * dy2 - dx2 * dy3) / denominator;
              const a23 = (dx1 * dy3 - dx3 * dy1) / denominator;
              return new PerspectiveTransform(x1 - x0 + a13 * x1, x3 - x0 + a23 * x3, x0, y1 - y0 + a13 * y1, y3 - y0 + a23 * y3, y0, a13, a23, 1);
            }
          }
          static quadrilateralToSquare(x0, y0, x1, y1, x2, y2, x3, y3) {
            return PerspectiveTransform.squareToQuadrilateral(x0, y0, x1, y1, x2, y2, x3, y3).buildAdjoint();
          }
          buildAdjoint() {
            return new PerspectiveTransform(this.a22 * this.a33 - this.a23 * this.a32, this.a23 * this.a31 - this.a21 * this.a33, this.a21 * this.a32 - this.a22 * this.a31, this.a13 * this.a32 - this.a12 * this.a33, this.a11 * this.a33 - this.a13 * this.a31, this.a12 * this.a31 - this.a11 * this.a32, this.a12 * this.a23 - this.a13 * this.a22, this.a13 * this.a21 - this.a11 * this.a23, this.a11 * this.a22 - this.a12 * this.a21);
          }
          times(other) {
            return new PerspectiveTransform(this.a11 * other.a11 + this.a21 * other.a12 + this.a31 * other.a13, this.a11 * other.a21 + this.a21 * other.a22 + this.a31 * other.a23, this.a11 * other.a31 + this.a21 * other.a32 + this.a31 * other.a33, this.a12 * other.a11 + this.a22 * other.a12 + this.a32 * other.a13, this.a12 * other.a21 + this.a22 * other.a22 + this.a32 * other.a23, this.a12 * other.a31 + this.a22 * other.a32 + this.a32 * other.a33, this.a13 * other.a11 + this.a23 * other.a12 + this.a33 * other.a13, this.a13 * other.a21 + this.a23 * other.a22 + this.a33 * other.a23, this.a13 * other.a31 + this.a23 * other.a32 + this.a33 * other.a33);
          }
        }
        class DefaultGridSampler extends GridSampler {
          sampleGrid(image, dimensionX, dimensionY, p1ToX, p1ToY, p2ToX, p2ToY, p3ToX, p3ToY, p4ToX, p4ToY, p1FromX, p1FromY, p2FromX, p2FromY, p3FromX, p3FromY, p4FromX, p4FromY) {
            const transform = PerspectiveTransform.quadrilateralToQuadrilateral(p1ToX, p1ToY, p2ToX, p2ToY, p3ToX, p3ToY, p4ToX, p4ToY, p1FromX, p1FromY, p2FromX, p2FromY, p3FromX, p3FromY, p4FromX, p4FromY);
            return this.sampleGridWithTransform(image, dimensionX, dimensionY, transform);
          }
          sampleGridWithTransform(image, dimensionX, dimensionY, transform) {
            if (dimensionX <= 0 || dimensionY <= 0) {
              throw new NotFoundException();
            }
            const bits = new BitMatrix(dimensionX, dimensionY);
            const points = new Float32Array(2 * dimensionX);
            for (let y = 0; y < dimensionY; y++) {
              const max = points.length;
              const iValue = y + 0.5;
              for (let x = 0; x < max; x += 2) {
                points[x] = x / 2 + 0.5;
                points[x + 1] = iValue;
              }
              transform.transformPoints(points);
              GridSampler.checkAndNudgePoints(image, points);
              try {
                for (let x = 0; x < max; x += 2) {
                  if (image.get(Math.floor(points[x]), Math.floor(points[x + 1]))) {
                    bits.set(x / 2, y);
                  }
                }
              } catch (aioobe) {
                throw new NotFoundException();
              }
            }
            return bits;
          }
        }
        class GridSamplerInstance {
          static setGridSampler(newGridSampler) {
            GridSamplerInstance.gridSampler = newGridSampler;
          }
          static getInstance() {
            return GridSamplerInstance.gridSampler;
          }
        }
        GridSamplerInstance.gridSampler = new DefaultGridSampler();
        class Point {
          constructor(x, y) {
            this.x = x;
            this.y = y;
          }
          toResultPoint() {
            return new ResultPoint(this.getX(), this.getY());
          }
          getX() {
            return this.x;
          }
          getY() {
            return this.y;
          }
        }
        class Detector {
          constructor(image) {
            this.EXPECTED_CORNER_BITS = new Int32Array([
              3808,
              476,
              2107,
              1799
            ]);
            this.image = image;
          }
          detect() {
            return this.detectMirror(false);
          }
          detectMirror(isMirror) {
            let pCenter = this.getMatrixCenter();
            let bullsEyeCorners = this.getBullsEyeCorners(pCenter);
            if (isMirror) {
              let temp = bullsEyeCorners[0];
              bullsEyeCorners[0] = bullsEyeCorners[2];
              bullsEyeCorners[2] = temp;
            }
            this.extractParameters(bullsEyeCorners);
            let bits = this.sampleGrid(this.image, bullsEyeCorners[this.shift % 4], bullsEyeCorners[(this.shift + 1) % 4], bullsEyeCorners[(this.shift + 2) % 4], bullsEyeCorners[(this.shift + 3) % 4]);
            let corners = this.getMatrixCornerPoints(bullsEyeCorners);
            return new AztecDetectorResult(bits, corners, this.compact, this.nbDataBlocks, this.nbLayers);
          }
          extractParameters(bullsEyeCorners) {
            if (!this.isValidPoint(bullsEyeCorners[0]) || !this.isValidPoint(bullsEyeCorners[1]) || !this.isValidPoint(bullsEyeCorners[2]) || !this.isValidPoint(bullsEyeCorners[3])) {
              throw new NotFoundException();
            }
            let length = 2 * this.nbCenterLayers;
            let sides = new Int32Array([
              this.sampleLine(bullsEyeCorners[0], bullsEyeCorners[1], length),
              this.sampleLine(bullsEyeCorners[1], bullsEyeCorners[2], length),
              this.sampleLine(bullsEyeCorners[2], bullsEyeCorners[3], length),
              this.sampleLine(bullsEyeCorners[3], bullsEyeCorners[0], length)
            ]);
            this.shift = this.getRotation(sides, length);
            let parameterData = 0;
            for (let i = 0; i < 4; i++) {
              let side = sides[(this.shift + i) % 4];
              if (this.compact) {
                parameterData <<= 7;
                parameterData += side >> 1 & 127;
              } else {
                parameterData <<= 10;
                parameterData += (side >> 2 & 31 << 5) + (side >> 1 & 31);
              }
            }
            let correctedData = this.getCorrectedParameterData(parameterData, this.compact);
            if (this.compact) {
              this.nbLayers = (correctedData >> 6) + 1;
              this.nbDataBlocks = (correctedData & 63) + 1;
            } else {
              this.nbLayers = (correctedData >> 11) + 1;
              this.nbDataBlocks = (correctedData & 2047) + 1;
            }
          }
          getRotation(sides, length) {
            let cornerBits = 0;
            sides.forEach((side, idx, arr) => {
              let t = (side >> length - 2 << 1) + (side & 1);
              cornerBits = (cornerBits << 3) + t;
            });
            cornerBits = ((cornerBits & 1) << 11) + (cornerBits >> 1);
            for (let shift = 0; shift < 4; shift++) {
              if (Integer.bitCount(cornerBits ^ this.EXPECTED_CORNER_BITS[shift]) <= 2) {
                return shift;
              }
            }
            throw new NotFoundException();
          }
          getCorrectedParameterData(parameterData, compact) {
            let numCodewords;
            let numDataCodewords;
            if (compact) {
              numCodewords = 7;
              numDataCodewords = 2;
            } else {
              numCodewords = 10;
              numDataCodewords = 4;
            }
            let numECCodewords = numCodewords - numDataCodewords;
            let parameterWords = new Int32Array(numCodewords);
            for (let i = numCodewords - 1; i >= 0; --i) {
              parameterWords[i] = parameterData & 15;
              parameterData >>= 4;
            }
            try {
              let rsDecoder = new ReedSolomonDecoder(GenericGF.AZTEC_PARAM);
              rsDecoder.decode(parameterWords, numECCodewords);
            } catch (ignored) {
              throw new NotFoundException();
            }
            let result = 0;
            for (let i = 0; i < numDataCodewords; i++) {
              result = (result << 4) + parameterWords[i];
            }
            return result;
          }
          getBullsEyeCorners(pCenter) {
            let pina = pCenter;
            let pinb = pCenter;
            let pinc = pCenter;
            let pind = pCenter;
            let color = true;
            for (this.nbCenterLayers = 1; this.nbCenterLayers < 9; this.nbCenterLayers++) {
              let pouta = this.getFirstDifferent(pina, color, 1, -1);
              let poutb = this.getFirstDifferent(pinb, color, 1, 1);
              let poutc = this.getFirstDifferent(pinc, color, -1, 1);
              let poutd = this.getFirstDifferent(pind, color, -1, -1);
              if (this.nbCenterLayers > 2) {
                let q = this.distancePoint(poutd, pouta) * this.nbCenterLayers / (this.distancePoint(pind, pina) * (this.nbCenterLayers + 2));
                if (q < 0.75 || q > 1.25 || !this.isWhiteOrBlackRectangle(pouta, poutb, poutc, poutd)) {
                  break;
                }
              }
              pina = pouta;
              pinb = poutb;
              pinc = poutc;
              pind = poutd;
              color = !color;
            }
            if (this.nbCenterLayers !== 5 && this.nbCenterLayers !== 7) {
              throw new NotFoundException();
            }
            this.compact = this.nbCenterLayers === 5;
            let pinax = new ResultPoint(pina.getX() + 0.5, pina.getY() - 0.5);
            let pinbx = new ResultPoint(pinb.getX() + 0.5, pinb.getY() + 0.5);
            let pincx = new ResultPoint(pinc.getX() - 0.5, pinc.getY() + 0.5);
            let pindx = new ResultPoint(pind.getX() - 0.5, pind.getY() - 0.5);
            return this.expandSquare([pinax, pinbx, pincx, pindx], 2 * this.nbCenterLayers - 3, 2 * this.nbCenterLayers);
          }
          getMatrixCenter() {
            let pointA;
            let pointB;
            let pointC;
            let pointD;
            try {
              let cornerPoints = new WhiteRectangleDetector(this.image).detect();
              pointA = cornerPoints[0];
              pointB = cornerPoints[1];
              pointC = cornerPoints[2];
              pointD = cornerPoints[3];
            } catch (e) {
              let cx2 = this.image.getWidth() / 2;
              let cy2 = this.image.getHeight() / 2;
              pointA = this.getFirstDifferent(new Point(cx2 + 7, cy2 - 7), false, 1, -1).toResultPoint();
              pointB = this.getFirstDifferent(new Point(cx2 + 7, cy2 + 7), false, 1, 1).toResultPoint();
              pointC = this.getFirstDifferent(new Point(cx2 - 7, cy2 + 7), false, -1, 1).toResultPoint();
              pointD = this.getFirstDifferent(new Point(cx2 - 7, cy2 - 7), false, -1, -1).toResultPoint();
            }
            let cx = MathUtils.round((pointA.getX() + pointD.getX() + pointB.getX() + pointC.getX()) / 4);
            let cy = MathUtils.round((pointA.getY() + pointD.getY() + pointB.getY() + pointC.getY()) / 4);
            try {
              let cornerPoints = new WhiteRectangleDetector(this.image, 15, cx, cy).detect();
              pointA = cornerPoints[0];
              pointB = cornerPoints[1];
              pointC = cornerPoints[2];
              pointD = cornerPoints[3];
            } catch (e) {
              pointA = this.getFirstDifferent(new Point(cx + 7, cy - 7), false, 1, -1).toResultPoint();
              pointB = this.getFirstDifferent(new Point(cx + 7, cy + 7), false, 1, 1).toResultPoint();
              pointC = this.getFirstDifferent(new Point(cx - 7, cy + 7), false, -1, 1).toResultPoint();
              pointD = this.getFirstDifferent(new Point(cx - 7, cy - 7), false, -1, -1).toResultPoint();
            }
            cx = MathUtils.round((pointA.getX() + pointD.getX() + pointB.getX() + pointC.getX()) / 4);
            cy = MathUtils.round((pointA.getY() + pointD.getY() + pointB.getY() + pointC.getY()) / 4);
            return new Point(cx, cy);
          }
          getMatrixCornerPoints(bullsEyeCorners) {
            return this.expandSquare(bullsEyeCorners, 2 * this.nbCenterLayers, this.getDimension());
          }
          sampleGrid(image, topLeft, topRight, bottomRight, bottomLeft) {
            let sampler = GridSamplerInstance.getInstance();
            let dimension = this.getDimension();
            let low = dimension / 2 - this.nbCenterLayers;
            let high = dimension / 2 + this.nbCenterLayers;
            return sampler.sampleGrid(image, dimension, dimension, low, low, high, low, high, high, low, high, topLeft.getX(), topLeft.getY(), topRight.getX(), topRight.getY(), bottomRight.getX(), bottomRight.getY(), bottomLeft.getX(), bottomLeft.getY());
          }
          sampleLine(p1, p2, size2) {
            let result = 0;
            let d = this.distanceResultPoint(p1, p2);
            let moduleSize = d / size2;
            let px = p1.getX();
            let py = p1.getY();
            let dx = moduleSize * (p2.getX() - p1.getX()) / d;
            let dy = moduleSize * (p2.getY() - p1.getY()) / d;
            for (let i = 0; i < size2; i++) {
              if (this.image.get(MathUtils.round(px + i * dx), MathUtils.round(py + i * dy))) {
                result |= 1 << size2 - i - 1;
              }
            }
            return result;
          }
          isWhiteOrBlackRectangle(p1, p2, p3, p4) {
            let corr = 3;
            p1 = new Point(p1.getX() - corr, p1.getY() + corr);
            p2 = new Point(p2.getX() - corr, p2.getY() - corr);
            p3 = new Point(p3.getX() + corr, p3.getY() - corr);
            p4 = new Point(p4.getX() + corr, p4.getY() + corr);
            let cInit = this.getColor(p4, p1);
            if (cInit === 0) {
              return false;
            }
            let c = this.getColor(p1, p2);
            if (c !== cInit) {
              return false;
            }
            c = this.getColor(p2, p3);
            if (c !== cInit) {
              return false;
            }
            c = this.getColor(p3, p4);
            return c === cInit;
          }
          getColor(p1, p2) {
            let d = this.distancePoint(p1, p2);
            let dx = (p2.getX() - p1.getX()) / d;
            let dy = (p2.getY() - p1.getY()) / d;
            let error2 = 0;
            let px = p1.getX();
            let py = p1.getY();
            let colorModel = this.image.get(p1.getX(), p1.getY());
            let iMax = Math.ceil(d);
            for (let i = 0; i < iMax; i++) {
              px += dx;
              py += dy;
              if (this.image.get(MathUtils.round(px), MathUtils.round(py)) !== colorModel) {
                error2++;
              }
            }
            let errRatio = error2 / d;
            if (errRatio > 0.1 && errRatio < 0.9) {
              return 0;
            }
            return errRatio <= 0.1 === colorModel ? 1 : -1;
          }
          getFirstDifferent(init, color, dx, dy) {
            let x = init.getX() + dx;
            let y = init.getY() + dy;
            while (this.isValid(x, y) && this.image.get(x, y) === color) {
              x += dx;
              y += dy;
            }
            x -= dx;
            y -= dy;
            while (this.isValid(x, y) && this.image.get(x, y) === color) {
              x += dx;
            }
            x -= dx;
            while (this.isValid(x, y) && this.image.get(x, y) === color) {
              y += dy;
            }
            y -= dy;
            return new Point(x, y);
          }
          expandSquare(cornerPoints, oldSide, newSide) {
            let ratio = newSide / (2 * oldSide);
            let dx = cornerPoints[0].getX() - cornerPoints[2].getX();
            let dy = cornerPoints[0].getY() - cornerPoints[2].getY();
            let centerx = (cornerPoints[0].getX() + cornerPoints[2].getX()) / 2;
            let centery = (cornerPoints[0].getY() + cornerPoints[2].getY()) / 2;
            let result0 = new ResultPoint(centerx + ratio * dx, centery + ratio * dy);
            let result2 = new ResultPoint(centerx - ratio * dx, centery - ratio * dy);
            dx = cornerPoints[1].getX() - cornerPoints[3].getX();
            dy = cornerPoints[1].getY() - cornerPoints[3].getY();
            centerx = (cornerPoints[1].getX() + cornerPoints[3].getX()) / 2;
            centery = (cornerPoints[1].getY() + cornerPoints[3].getY()) / 2;
            let result1 = new ResultPoint(centerx + ratio * dx, centery + ratio * dy);
            let result3 = new ResultPoint(centerx - ratio * dx, centery - ratio * dy);
            let results = [result0, result1, result2, result3];
            return results;
          }
          isValid(x, y) {
            return x >= 0 && x < this.image.getWidth() && y > 0 && y < this.image.getHeight();
          }
          isValidPoint(point) {
            let x = MathUtils.round(point.getX());
            let y = MathUtils.round(point.getY());
            return this.isValid(x, y);
          }
          distancePoint(a, b) {
            return MathUtils.distance(a.getX(), a.getY(), b.getX(), b.getY());
          }
          distanceResultPoint(a, b) {
            return MathUtils.distance(a.getX(), a.getY(), b.getX(), b.getY());
          }
          getDimension() {
            if (this.compact) {
              return 4 * this.nbLayers + 11;
            }
            if (this.nbLayers <= 4) {
              return 4 * this.nbLayers + 15;
            }
            return 4 * this.nbLayers + 2 * (Integer.truncDivision(this.nbLayers - 4, 8) + 1) + 15;
          }
        }
        class AztecReader {
          decode(image, hints = null) {
            let exception = null;
            let detector = new Detector(image.getBlackMatrix());
            let points = null;
            let decoderResult = null;
            try {
              let detectorResult = detector.detectMirror(false);
              points = detectorResult.getPoints();
              this.reportFoundResultPoints(hints, points);
              decoderResult = new Decoder().decode(detectorResult);
            } catch (e) {
              exception = e;
            }
            if (decoderResult == null) {
              try {
                let detectorResult = detector.detectMirror(true);
                points = detectorResult.getPoints();
                this.reportFoundResultPoints(hints, points);
                decoderResult = new Decoder().decode(detectorResult);
              } catch (e) {
                if (exception != null) {
                  throw exception;
                }
                throw e;
              }
            }
            let result = new Result(decoderResult.getText(), decoderResult.getRawBytes(), decoderResult.getNumBits(), points, BarcodeFormat$1.AZTEC, System.currentTimeMillis());
            let byteSegments = decoderResult.getByteSegments();
            if (byteSegments != null) {
              result.putMetadata(ResultMetadataType$1.BYTE_SEGMENTS, byteSegments);
            }
            let ecLevel = decoderResult.getECLevel();
            if (ecLevel != null) {
              result.putMetadata(ResultMetadataType$1.ERROR_CORRECTION_LEVEL, ecLevel);
            }
            return result;
          }
          reportFoundResultPoints(hints, points) {
            if (hints != null) {
              let rpcb = hints.get(DecodeHintType$1.NEED_RESULT_POINT_CALLBACK);
              if (rpcb != null) {
                points.forEach((point, idx, arr) => {
                  rpcb.foundPossibleResultPoint(point);
                });
              }
            }
          }
          reset() {
          }
        }
        class BrowserAztecCodeReader extends BrowserCodeReader {
          constructor(timeBetweenScansMillis = 500) {
            super(new AztecReader(), timeBetweenScansMillis);
          }
        }
        class OneDReader {
          decode(image, hints) {
            try {
              return this.doDecode(image, hints);
            } catch (nfe) {
              const tryHarder = hints && hints.get(DecodeHintType$1.TRY_HARDER) === true;
              if (tryHarder && image.isRotateSupported()) {
                const rotatedImage = image.rotateCounterClockwise();
                const result = this.doDecode(rotatedImage, hints);
                const metadata = result.getResultMetadata();
                let orientation = 270;
                if (metadata !== null && metadata.get(ResultMetadataType$1.ORIENTATION) === true) {
                  orientation = orientation + metadata.get(ResultMetadataType$1.ORIENTATION) % 360;
                }
                result.putMetadata(ResultMetadataType$1.ORIENTATION, orientation);
                const points = result.getResultPoints();
                if (points !== null) {
                  const height = rotatedImage.getHeight();
                  for (let i = 0; i < points.length; i++) {
                    points[i] = new ResultPoint(height - points[i].getY() - 1, points[i].getX());
                  }
                }
                return result;
              } else {
                throw new NotFoundException();
              }
            }
          }
          reset() {
          }
          doDecode(image, hints) {
            const width = image.getWidth();
            const height = image.getHeight();
            let row = new BitArray(width);
            const tryHarder = hints && hints.get(DecodeHintType$1.TRY_HARDER) === true;
            const rowStep = Math.max(1, height >> (tryHarder ? 8 : 5));
            let maxLines;
            if (tryHarder) {
              maxLines = height;
            } else {
              maxLines = 15;
            }
            const middle = Math.trunc(height / 2);
            for (let x = 0; x < maxLines; x++) {
              const rowStepsAboveOrBelow = Math.trunc((x + 1) / 2);
              const isAbove = (x & 1) === 0;
              const rowNumber = middle + rowStep * (isAbove ? rowStepsAboveOrBelow : -rowStepsAboveOrBelow);
              if (rowNumber < 0 || rowNumber >= height) {
                break;
              }
              try {
                row = image.getBlackRow(rowNumber, row);
              } catch (ignored) {
                continue;
              }
              for (let attempt = 0; attempt < 2; attempt++) {
                if (attempt === 1) {
                  row.reverse();
                  if (hints && hints.get(DecodeHintType$1.NEED_RESULT_POINT_CALLBACK) === true) {
                    const newHints = /* @__PURE__ */ new Map();
                    hints.forEach((hint, key) => newHints.set(key, hint));
                    newHints.delete(DecodeHintType$1.NEED_RESULT_POINT_CALLBACK);
                    hints = newHints;
                  }
                }
                try {
                  const result = this.decodeRow(rowNumber, row, hints);
                  if (attempt === 1) {
                    result.putMetadata(ResultMetadataType$1.ORIENTATION, 180);
                    const points = result.getResultPoints();
                    if (points !== null) {
                      points[0] = new ResultPoint(width - points[0].getX() - 1, points[0].getY());
                      points[1] = new ResultPoint(width - points[1].getX() - 1, points[1].getY());
                    }
                  }
                  return result;
                } catch (re) {
                }
              }
            }
            throw new NotFoundException();
          }
          static recordPattern(row, start2, counters) {
            const numCounters = counters.length;
            for (let index = 0; index < numCounters; index++)
              counters[index] = 0;
            const end = row.getSize();
            if (start2 >= end) {
              throw new NotFoundException();
            }
            let isWhite = !row.get(start2);
            let counterPosition = 0;
            let i = start2;
            while (i < end) {
              if (row.get(i) !== isWhite) {
                counters[counterPosition]++;
              } else {
                if (++counterPosition === numCounters) {
                  break;
                } else {
                  counters[counterPosition] = 1;
                  isWhite = !isWhite;
                }
              }
              i++;
            }
            if (!(counterPosition === numCounters || counterPosition === numCounters - 1 && i === end)) {
              throw new NotFoundException();
            }
          }
          static recordPatternInReverse(row, start2, counters) {
            let numTransitionsLeft = counters.length;
            let last = row.get(start2);
            while (start2 > 0 && numTransitionsLeft >= 0) {
              if (row.get(--start2) !== last) {
                numTransitionsLeft--;
                last = !last;
              }
            }
            if (numTransitionsLeft >= 0) {
              throw new NotFoundException();
            }
            OneDReader.recordPattern(row, start2 + 1, counters);
          }
          static patternMatchVariance(counters, pattern, maxIndividualVariance) {
            const numCounters = counters.length;
            let total = 0;
            let patternLength = 0;
            for (let i = 0; i < numCounters; i++) {
              total += counters[i];
              patternLength += pattern[i];
            }
            if (total < patternLength) {
              return Number.POSITIVE_INFINITY;
            }
            const unitBarWidth = total / patternLength;
            maxIndividualVariance *= unitBarWidth;
            let totalVariance = 0;
            for (let x = 0; x < numCounters; x++) {
              const counter = counters[x];
              const scaledPattern = pattern[x] * unitBarWidth;
              const variance = counter > scaledPattern ? counter - scaledPattern : scaledPattern - counter;
              if (variance > maxIndividualVariance) {
                return Number.POSITIVE_INFINITY;
              }
              totalVariance += variance;
            }
            return totalVariance / total;
          }
        }
        class Code128Reader extends OneDReader {
          static findStartPattern(row) {
            const width = row.getSize();
            const rowOffset = row.getNextSet(0);
            let counterPosition = 0;
            let counters = Int32Array.from([0, 0, 0, 0, 0, 0]);
            let patternStart = rowOffset;
            let isWhite = false;
            const patternLength = 6;
            for (let i = rowOffset; i < width; i++) {
              if (row.get(i) !== isWhite) {
                counters[counterPosition]++;
              } else {
                if (counterPosition === patternLength - 1) {
                  let bestVariance = Code128Reader.MAX_AVG_VARIANCE;
                  let bestMatch = -1;
                  for (let startCode = Code128Reader.CODE_START_A; startCode <= Code128Reader.CODE_START_C; startCode++) {
                    const variance = OneDReader.patternMatchVariance(counters, Code128Reader.CODE_PATTERNS[startCode], Code128Reader.MAX_INDIVIDUAL_VARIANCE);
                    if (variance < bestVariance) {
                      bestVariance = variance;
                      bestMatch = startCode;
                    }
                  }
                  if (bestMatch >= 0 && row.isRange(Math.max(0, patternStart - (i - patternStart) / 2), patternStart, false)) {
                    return Int32Array.from([patternStart, i, bestMatch]);
                  }
                  patternStart += counters[0] + counters[1];
                  counters = counters.slice(2, counters.length - 1);
                  counters[counterPosition - 1] = 0;
                  counters[counterPosition] = 0;
                  counterPosition--;
                } else {
                  counterPosition++;
                }
                counters[counterPosition] = 1;
                isWhite = !isWhite;
              }
            }
            throw new NotFoundException();
          }
          static decodeCode(row, counters, rowOffset) {
            OneDReader.recordPattern(row, rowOffset, counters);
            let bestVariance = Code128Reader.MAX_AVG_VARIANCE;
            let bestMatch = -1;
            for (let d = 0; d < Code128Reader.CODE_PATTERNS.length; d++) {
              const pattern = Code128Reader.CODE_PATTERNS[d];
              const variance = this.patternMatchVariance(counters, pattern, Code128Reader.MAX_INDIVIDUAL_VARIANCE);
              if (variance < bestVariance) {
                bestVariance = variance;
                bestMatch = d;
              }
            }
            if (bestMatch >= 0) {
              return bestMatch;
            } else {
              throw new NotFoundException();
            }
          }
          decodeRow(rowNumber, row, hints) {
            const convertFNC1 = hints && hints.get(DecodeHintType$1.ASSUME_GS1) === true;
            const startPatternInfo = Code128Reader.findStartPattern(row);
            const startCode = startPatternInfo[2];
            let currentRawCodesIndex = 0;
            const rawCodes = new Uint8Array(20);
            rawCodes[currentRawCodesIndex++] = startCode;
            let codeSet;
            switch (startCode) {
              case Code128Reader.CODE_START_A:
                codeSet = Code128Reader.CODE_CODE_A;
                break;
              case Code128Reader.CODE_START_B:
                codeSet = Code128Reader.CODE_CODE_B;
                break;
              case Code128Reader.CODE_START_C:
                codeSet = Code128Reader.CODE_CODE_C;
                break;
              default:
                throw new FormatException();
            }
            let done = false;
            let isNextShifted = false;
            let result = "";
            let lastStart = startPatternInfo[0];
            let nextStart = startPatternInfo[1];
            const counters = Int32Array.from([0, 0, 0, 0, 0, 0]);
            let lastCode = 0;
            let code = 0;
            let checksumTotal = startCode;
            let multiplier = 0;
            let lastCharacterWasPrintable = true;
            let upperMode = false;
            let shiftUpperMode = false;
            while (!done) {
              const unshift = isNextShifted;
              isNextShifted = false;
              lastCode = code;
              code = Code128Reader.decodeCode(row, counters, nextStart);
              rawCodes[currentRawCodesIndex++] = code;
              if (code !== Code128Reader.CODE_STOP) {
                lastCharacterWasPrintable = true;
              }
              if (code !== Code128Reader.CODE_STOP) {
                multiplier++;
                checksumTotal += multiplier * code;
              }
              lastStart = nextStart;
              nextStart += counters.reduce((previous, current) => previous + current, 0);
              switch (code) {
                case Code128Reader.CODE_START_A:
                case Code128Reader.CODE_START_B:
                case Code128Reader.CODE_START_C:
                  throw new FormatException();
              }
              switch (codeSet) {
                case Code128Reader.CODE_CODE_A:
                  if (code < 64) {
                    if (shiftUpperMode === upperMode) {
                      result += String.fromCharCode(" ".charCodeAt(0) + code);
                    } else {
                      result += String.fromCharCode(" ".charCodeAt(0) + code + 128);
                    }
                    shiftUpperMode = false;
                  } else if (code < 96) {
                    if (shiftUpperMode === upperMode) {
                      result += String.fromCharCode(code - 64);
                    } else {
                      result += String.fromCharCode(code + 64);
                    }
                    shiftUpperMode = false;
                  } else {
                    if (code !== Code128Reader.CODE_STOP) {
                      lastCharacterWasPrintable = false;
                    }
                    switch (code) {
                      case Code128Reader.CODE_FNC_1:
                        if (convertFNC1) {
                          if (result.length === 0) {
                            result += "]C1";
                          } else {
                            result += String.fromCharCode(29);
                          }
                        }
                        break;
                      case Code128Reader.CODE_FNC_2:
                      case Code128Reader.CODE_FNC_3:
                        break;
                      case Code128Reader.CODE_FNC_4_A:
                        if (!upperMode && shiftUpperMode) {
                          upperMode = true;
                          shiftUpperMode = false;
                        } else if (upperMode && shiftUpperMode) {
                          upperMode = false;
                          shiftUpperMode = false;
                        } else {
                          shiftUpperMode = true;
                        }
                        break;
                      case Code128Reader.CODE_SHIFT:
                        isNextShifted = true;
                        codeSet = Code128Reader.CODE_CODE_B;
                        break;
                      case Code128Reader.CODE_CODE_B:
                        codeSet = Code128Reader.CODE_CODE_B;
                        break;
                      case Code128Reader.CODE_CODE_C:
                        codeSet = Code128Reader.CODE_CODE_C;
                        break;
                      case Code128Reader.CODE_STOP:
                        done = true;
                        break;
                    }
                  }
                  break;
                case Code128Reader.CODE_CODE_B:
                  if (code < 96) {
                    if (shiftUpperMode === upperMode) {
                      result += String.fromCharCode(" ".charCodeAt(0) + code);
                    } else {
                      result += String.fromCharCode(" ".charCodeAt(0) + code + 128);
                    }
                    shiftUpperMode = false;
                  } else {
                    if (code !== Code128Reader.CODE_STOP) {
                      lastCharacterWasPrintable = false;
                    }
                    switch (code) {
                      case Code128Reader.CODE_FNC_1:
                        if (convertFNC1) {
                          if (result.length === 0) {
                            result += "]C1";
                          } else {
                            result += String.fromCharCode(29);
                          }
                        }
                        break;
                      case Code128Reader.CODE_FNC_2:
                      case Code128Reader.CODE_FNC_3:
                        break;
                      case Code128Reader.CODE_FNC_4_B:
                        if (!upperMode && shiftUpperMode) {
                          upperMode = true;
                          shiftUpperMode = false;
                        } else if (upperMode && shiftUpperMode) {
                          upperMode = false;
                          shiftUpperMode = false;
                        } else {
                          shiftUpperMode = true;
                        }
                        break;
                      case Code128Reader.CODE_SHIFT:
                        isNextShifted = true;
                        codeSet = Code128Reader.CODE_CODE_A;
                        break;
                      case Code128Reader.CODE_CODE_A:
                        codeSet = Code128Reader.CODE_CODE_A;
                        break;
                      case Code128Reader.CODE_CODE_C:
                        codeSet = Code128Reader.CODE_CODE_C;
                        break;
                      case Code128Reader.CODE_STOP:
                        done = true;
                        break;
                    }
                  }
                  break;
                case Code128Reader.CODE_CODE_C:
                  if (code < 100) {
                    if (code < 10) {
                      result += "0";
                    }
                    result += code;
                  } else {
                    if (code !== Code128Reader.CODE_STOP) {
                      lastCharacterWasPrintable = false;
                    }
                    switch (code) {
                      case Code128Reader.CODE_FNC_1:
                        if (convertFNC1) {
                          if (result.length === 0) {
                            result += "]C1";
                          } else {
                            result += String.fromCharCode(29);
                          }
                        }
                        break;
                      case Code128Reader.CODE_CODE_A:
                        codeSet = Code128Reader.CODE_CODE_A;
                        break;
                      case Code128Reader.CODE_CODE_B:
                        codeSet = Code128Reader.CODE_CODE_B;
                        break;
                      case Code128Reader.CODE_STOP:
                        done = true;
                        break;
                    }
                  }
                  break;
              }
              if (unshift) {
                codeSet = codeSet === Code128Reader.CODE_CODE_A ? Code128Reader.CODE_CODE_B : Code128Reader.CODE_CODE_A;
              }
            }
            const lastPatternSize = nextStart - lastStart;
            nextStart = row.getNextUnset(nextStart);
            if (!row.isRange(nextStart, Math.min(row.getSize(), nextStart + (nextStart - lastStart) / 2), false)) {
              throw new NotFoundException();
            }
            checksumTotal -= multiplier * lastCode;
            if (checksumTotal % 103 !== lastCode) {
              throw new ChecksumException();
            }
            const resultLength = result.length;
            if (resultLength === 0) {
              throw new NotFoundException();
            }
            if (resultLength > 0 && lastCharacterWasPrintable) {
              if (codeSet === Code128Reader.CODE_CODE_C) {
                result = result.substring(0, resultLength - 2);
              } else {
                result = result.substring(0, resultLength - 1);
              }
            }
            const left = (startPatternInfo[1] + startPatternInfo[0]) / 2;
            const right = lastStart + lastPatternSize / 2;
            const rawCodesSize = rawCodes.length;
            const rawBytes = new Uint8Array(rawCodesSize);
            for (let i = 0; i < rawCodesSize; i++) {
              rawBytes[i] = rawCodes[i];
            }
            const points = [new ResultPoint(left, rowNumber), new ResultPoint(right, rowNumber)];
            return new Result(result, rawBytes, 0, points, BarcodeFormat$1.CODE_128, new Date().getTime());
          }
        }
        Code128Reader.CODE_PATTERNS = [
          Int32Array.from([2, 1, 2, 2, 2, 2]),
          Int32Array.from([2, 2, 2, 1, 2, 2]),
          Int32Array.from([2, 2, 2, 2, 2, 1]),
          Int32Array.from([1, 2, 1, 2, 2, 3]),
          Int32Array.from([1, 2, 1, 3, 2, 2]),
          Int32Array.from([1, 3, 1, 2, 2, 2]),
          Int32Array.from([1, 2, 2, 2, 1, 3]),
          Int32Array.from([1, 2, 2, 3, 1, 2]),
          Int32Array.from([1, 3, 2, 2, 1, 2]),
          Int32Array.from([2, 2, 1, 2, 1, 3]),
          Int32Array.from([2, 2, 1, 3, 1, 2]),
          Int32Array.from([2, 3, 1, 2, 1, 2]),
          Int32Array.from([1, 1, 2, 2, 3, 2]),
          Int32Array.from([1, 2, 2, 1, 3, 2]),
          Int32Array.from([1, 2, 2, 2, 3, 1]),
          Int32Array.from([1, 1, 3, 2, 2, 2]),
          Int32Array.from([1, 2, 3, 1, 2, 2]),
          Int32Array.from([1, 2, 3, 2, 2, 1]),
          Int32Array.from([2, 2, 3, 2, 1, 1]),
          Int32Array.from([2, 2, 1, 1, 3, 2]),
          Int32Array.from([2, 2, 1, 2, 3, 1]),
          Int32Array.from([2, 1, 3, 2, 1, 2]),
          Int32Array.from([2, 2, 3, 1, 1, 2]),
          Int32Array.from([3, 1, 2, 1, 3, 1]),
          Int32Array.from([3, 1, 1, 2, 2, 2]),
          Int32Array.from([3, 2, 1, 1, 2, 2]),
          Int32Array.from([3, 2, 1, 2, 2, 1]),
          Int32Array.from([3, 1, 2, 2, 1, 2]),
          Int32Array.from([3, 2, 2, 1, 1, 2]),
          Int32Array.from([3, 2, 2, 2, 1, 1]),
          Int32Array.from([2, 1, 2, 1, 2, 3]),
          Int32Array.from([2, 1, 2, 3, 2, 1]),
          Int32Array.from([2, 3, 2, 1, 2, 1]),
          Int32Array.from([1, 1, 1, 3, 2, 3]),
          Int32Array.from([1, 3, 1, 1, 2, 3]),
          Int32Array.from([1, 3, 1, 3, 2, 1]),
          Int32Array.from([1, 1, 2, 3, 1, 3]),
          Int32Array.from([1, 3, 2, 1, 1, 3]),
          Int32Array.from([1, 3, 2, 3, 1, 1]),
          Int32Array.from([2, 1, 1, 3, 1, 3]),
          Int32Array.from([2, 3, 1, 1, 1, 3]),
          Int32Array.from([2, 3, 1, 3, 1, 1]),
          Int32Array.from([1, 1, 2, 1, 3, 3]),
          Int32Array.from([1, 1, 2, 3, 3, 1]),
          Int32Array.from([1, 3, 2, 1, 3, 1]),
          Int32Array.from([1, 1, 3, 1, 2, 3]),
          Int32Array.from([1, 1, 3, 3, 2, 1]),
          Int32Array.from([1, 3, 3, 1, 2, 1]),
          Int32Array.from([3, 1, 3, 1, 2, 1]),
          Int32Array.from([2, 1, 1, 3, 3, 1]),
          Int32Array.from([2, 3, 1, 1, 3, 1]),
          Int32Array.from([2, 1, 3, 1, 1, 3]),
          Int32Array.from([2, 1, 3, 3, 1, 1]),
          Int32Array.from([2, 1, 3, 1, 3, 1]),
          Int32Array.from([3, 1, 1, 1, 2, 3]),
          Int32Array.from([3, 1, 1, 3, 2, 1]),
          Int32Array.from([3, 3, 1, 1, 2, 1]),
          Int32Array.from([3, 1, 2, 1, 1, 3]),
          Int32Array.from([3, 1, 2, 3, 1, 1]),
          Int32Array.from([3, 3, 2, 1, 1, 1]),
          Int32Array.from([3, 1, 4, 1, 1, 1]),
          Int32Array.from([2, 2, 1, 4, 1, 1]),
          Int32Array.from([4, 3, 1, 1, 1, 1]),
          Int32Array.from([1, 1, 1, 2, 2, 4]),
          Int32Array.from([1, 1, 1, 4, 2, 2]),
          Int32Array.from([1, 2, 1, 1, 2, 4]),
          Int32Array.from([1, 2, 1, 4, 2, 1]),
          Int32Array.from([1, 4, 1, 1, 2, 2]),
          Int32Array.from([1, 4, 1, 2, 2, 1]),
          Int32Array.from([1, 1, 2, 2, 1, 4]),
          Int32Array.from([1, 1, 2, 4, 1, 2]),
          Int32Array.from([1, 2, 2, 1, 1, 4]),
          Int32Array.from([1, 2, 2, 4, 1, 1]),
          Int32Array.from([1, 4, 2, 1, 1, 2]),
          Int32Array.from([1, 4, 2, 2, 1, 1]),
          Int32Array.from([2, 4, 1, 2, 1, 1]),
          Int32Array.from([2, 2, 1, 1, 1, 4]),
          Int32Array.from([4, 1, 3, 1, 1, 1]),
          Int32Array.from([2, 4, 1, 1, 1, 2]),
          Int32Array.from([1, 3, 4, 1, 1, 1]),
          Int32Array.from([1, 1, 1, 2, 4, 2]),
          Int32Array.from([1, 2, 1, 1, 4, 2]),
          Int32Array.from([1, 2, 1, 2, 4, 1]),
          Int32Array.from([1, 1, 4, 2, 1, 2]),
          Int32Array.from([1, 2, 4, 1, 1, 2]),
          Int32Array.from([1, 2, 4, 2, 1, 1]),
          Int32Array.from([4, 1, 1, 2, 1, 2]),
          Int32Array.from([4, 2, 1, 1, 1, 2]),
          Int32Array.from([4, 2, 1, 2, 1, 1]),
          Int32Array.from([2, 1, 2, 1, 4, 1]),
          Int32Array.from([2, 1, 4, 1, 2, 1]),
          Int32Array.from([4, 1, 2, 1, 2, 1]),
          Int32Array.from([1, 1, 1, 1, 4, 3]),
          Int32Array.from([1, 1, 1, 3, 4, 1]),
          Int32Array.from([1, 3, 1, 1, 4, 1]),
          Int32Array.from([1, 1, 4, 1, 1, 3]),
          Int32Array.from([1, 1, 4, 3, 1, 1]),
          Int32Array.from([4, 1, 1, 1, 1, 3]),
          Int32Array.from([4, 1, 1, 3, 1, 1]),
          Int32Array.from([1, 1, 3, 1, 4, 1]),
          Int32Array.from([1, 1, 4, 1, 3, 1]),
          Int32Array.from([3, 1, 1, 1, 4, 1]),
          Int32Array.from([4, 1, 1, 1, 3, 1]),
          Int32Array.from([2, 1, 1, 4, 1, 2]),
          Int32Array.from([2, 1, 1, 2, 1, 4]),
          Int32Array.from([2, 1, 1, 2, 3, 2]),
          Int32Array.from([2, 3, 3, 1, 1, 1, 2])
        ];
        Code128Reader.MAX_AVG_VARIANCE = 0.25;
        Code128Reader.MAX_INDIVIDUAL_VARIANCE = 0.7;
        Code128Reader.CODE_SHIFT = 98;
        Code128Reader.CODE_CODE_C = 99;
        Code128Reader.CODE_CODE_B = 100;
        Code128Reader.CODE_CODE_A = 101;
        Code128Reader.CODE_FNC_1 = 102;
        Code128Reader.CODE_FNC_2 = 97;
        Code128Reader.CODE_FNC_3 = 96;
        Code128Reader.CODE_FNC_4_A = 101;
        Code128Reader.CODE_FNC_4_B = 100;
        Code128Reader.CODE_START_A = 103;
        Code128Reader.CODE_START_B = 104;
        Code128Reader.CODE_START_C = 105;
        Code128Reader.CODE_STOP = 106;
        class Code39Reader extends OneDReader {
          constructor(usingCheckDigit = false, extendedMode = false) {
            super();
            this.usingCheckDigit = usingCheckDigit;
            this.extendedMode = extendedMode;
            this.decodeRowResult = "";
            this.counters = new Int32Array(9);
          }
          decodeRow(rowNumber, row, hints) {
            let theCounters = this.counters;
            theCounters.fill(0);
            this.decodeRowResult = "";
            let start2 = Code39Reader.findAsteriskPattern(row, theCounters);
            let nextStart = row.getNextSet(start2[1]);
            let end = row.getSize();
            let decodedChar;
            let lastStart;
            do {
              Code39Reader.recordPattern(row, nextStart, theCounters);
              let pattern = Code39Reader.toNarrowWidePattern(theCounters);
              if (pattern < 0) {
                throw new NotFoundException();
              }
              decodedChar = Code39Reader.patternToChar(pattern);
              this.decodeRowResult += decodedChar;
              lastStart = nextStart;
              for (let counter of theCounters) {
                nextStart += counter;
              }
              nextStart = row.getNextSet(nextStart);
            } while (decodedChar !== "*");
            this.decodeRowResult = this.decodeRowResult.substring(0, this.decodeRowResult.length - 1);
            let lastPatternSize = 0;
            for (let counter of theCounters) {
              lastPatternSize += counter;
            }
            let whiteSpaceAfterEnd = nextStart - lastStart - lastPatternSize;
            if (nextStart !== end && whiteSpaceAfterEnd * 2 < lastPatternSize) {
              throw new NotFoundException();
            }
            if (this.usingCheckDigit) {
              let max = this.decodeRowResult.length - 1;
              let total = 0;
              for (let i = 0; i < max; i++) {
                total += Code39Reader.ALPHABET_STRING.indexOf(this.decodeRowResult.charAt(i));
              }
              if (this.decodeRowResult.charAt(max) !== Code39Reader.ALPHABET_STRING.charAt(total % 43)) {
                throw new ChecksumException();
              }
              this.decodeRowResult = this.decodeRowResult.substring(0, max);
            }
            if (this.decodeRowResult.length === 0) {
              throw new NotFoundException();
            }
            let resultString;
            if (this.extendedMode) {
              resultString = Code39Reader.decodeExtended(this.decodeRowResult);
            } else {
              resultString = this.decodeRowResult;
            }
            let left = (start2[1] + start2[0]) / 2;
            let right = lastStart + lastPatternSize / 2;
            return new Result(resultString, null, 0, [new ResultPoint(left, rowNumber), new ResultPoint(right, rowNumber)], BarcodeFormat$1.CODE_39, new Date().getTime());
          }
          static findAsteriskPattern(row, counters) {
            let width = row.getSize();
            let rowOffset = row.getNextSet(0);
            let counterPosition = 0;
            let patternStart = rowOffset;
            let isWhite = false;
            let patternLength = counters.length;
            for (let i = rowOffset; i < width; i++) {
              if (row.get(i) !== isWhite) {
                counters[counterPosition]++;
              } else {
                if (counterPosition === patternLength - 1) {
                  if (this.toNarrowWidePattern(counters) === Code39Reader.ASTERISK_ENCODING && row.isRange(Math.max(0, patternStart - Math.floor((i - patternStart) / 2)), patternStart, false)) {
                    return [patternStart, i];
                  }
                  patternStart += counters[0] + counters[1];
                  counters.copyWithin(0, 2, 2 + counterPosition - 1);
                  counters[counterPosition - 1] = 0;
                  counters[counterPosition] = 0;
                  counterPosition--;
                } else {
                  counterPosition++;
                }
                counters[counterPosition] = 1;
                isWhite = !isWhite;
              }
            }
            throw new NotFoundException();
          }
          static toNarrowWidePattern(counters) {
            let numCounters = counters.length;
            let maxNarrowCounter = 0;
            let wideCounters;
            do {
              let minCounter = 2147483647;
              for (let counter of counters) {
                if (counter < minCounter && counter > maxNarrowCounter) {
                  minCounter = counter;
                }
              }
              maxNarrowCounter = minCounter;
              wideCounters = 0;
              let totalWideCountersWidth = 0;
              let pattern = 0;
              for (let i = 0; i < numCounters; i++) {
                let counter = counters[i];
                if (counter > maxNarrowCounter) {
                  pattern |= 1 << numCounters - 1 - i;
                  wideCounters++;
                  totalWideCountersWidth += counter;
                }
              }
              if (wideCounters === 3) {
                for (let i = 0; i < numCounters && wideCounters > 0; i++) {
                  let counter = counters[i];
                  if (counter > maxNarrowCounter) {
                    wideCounters--;
                    if (counter * 2 >= totalWideCountersWidth) {
                      return -1;
                    }
                  }
                }
                return pattern;
              }
            } while (wideCounters > 3);
            return -1;
          }
          static patternToChar(pattern) {
            for (let i = 0; i < Code39Reader.CHARACTER_ENCODINGS.length; i++) {
              if (Code39Reader.CHARACTER_ENCODINGS[i] === pattern) {
                return Code39Reader.ALPHABET_STRING.charAt(i);
              }
            }
            if (pattern === Code39Reader.ASTERISK_ENCODING) {
              return "*";
            }
            throw new NotFoundException();
          }
          static decodeExtended(encoded) {
            let length = encoded.length;
            let decoded = "";
            for (let i = 0; i < length; i++) {
              let c = encoded.charAt(i);
              if (c === "+" || c === "$" || c === "%" || c === "/") {
                let next = encoded.charAt(i + 1);
                let decodedChar = "\0";
                switch (c) {
                  case "+":
                    if (next >= "A" && next <= "Z") {
                      decodedChar = String.fromCharCode(next.charCodeAt(0) + 32);
                    } else {
                      throw new FormatException();
                    }
                    break;
                  case "$":
                    if (next >= "A" && next <= "Z") {
                      decodedChar = String.fromCharCode(next.charCodeAt(0) - 64);
                    } else {
                      throw new FormatException();
                    }
                    break;
                  case "%":
                    if (next >= "A" && next <= "E") {
                      decodedChar = String.fromCharCode(next.charCodeAt(0) - 38);
                    } else if (next >= "F" && next <= "J") {
                      decodedChar = String.fromCharCode(next.charCodeAt(0) - 11);
                    } else if (next >= "K" && next <= "O") {
                      decodedChar = String.fromCharCode(next.charCodeAt(0) + 16);
                    } else if (next >= "P" && next <= "T") {
                      decodedChar = String.fromCharCode(next.charCodeAt(0) + 43);
                    } else if (next === "U") {
                      decodedChar = "\0";
                    } else if (next === "V") {
                      decodedChar = "@";
                    } else if (next === "W") {
                      decodedChar = "`";
                    } else if (next === "X" || next === "Y" || next === "Z") {
                      decodedChar = "\x7F";
                    } else {
                      throw new FormatException();
                    }
                    break;
                  case "/":
                    if (next >= "A" && next <= "O") {
                      decodedChar = String.fromCharCode(next.charCodeAt(0) - 32);
                    } else if (next === "Z") {
                      decodedChar = ":";
                    } else {
                      throw new FormatException();
                    }
                    break;
                }
                decoded += decodedChar;
                i++;
              } else {
                decoded += c;
              }
            }
            return decoded;
          }
        }
        Code39Reader.ALPHABET_STRING = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%";
        Code39Reader.CHARACTER_ENCODINGS = [
          52,
          289,
          97,
          352,
          49,
          304,
          112,
          37,
          292,
          100,
          265,
          73,
          328,
          25,
          280,
          88,
          13,
          268,
          76,
          28,
          259,
          67,
          322,
          19,
          274,
          82,
          7,
          262,
          70,
          22,
          385,
          193,
          448,
          145,
          400,
          208,
          133,
          388,
          196,
          168,
          162,
          138,
          42
        ];
        Code39Reader.ASTERISK_ENCODING = 148;
        class ITFReader extends OneDReader {
          constructor() {
            super(...arguments);
            this.narrowLineWidth = -1;
          }
          decodeRow(rowNumber, row, hints) {
            let startRange = this.decodeStart(row);
            let endRange = this.decodeEnd(row);
            let result = new StringBuilder();
            ITFReader.decodeMiddle(row, startRange[1], endRange[0], result);
            let resultString = result.toString();
            let allowedLengths = null;
            if (hints != null) {
              allowedLengths = hints.get(DecodeHintType$1.ALLOWED_LENGTHS);
            }
            if (allowedLengths == null) {
              allowedLengths = ITFReader.DEFAULT_ALLOWED_LENGTHS;
            }
            let length = resultString.length;
            let lengthOK = false;
            let maxAllowedLength = 0;
            for (let value of allowedLengths) {
              if (length === value) {
                lengthOK = true;
                break;
              }
              if (value > maxAllowedLength) {
                maxAllowedLength = value;
              }
            }
            if (!lengthOK && length > maxAllowedLength) {
              lengthOK = true;
            }
            if (!lengthOK) {
              throw new FormatException();
            }
            const points = [new ResultPoint(startRange[1], rowNumber), new ResultPoint(endRange[0], rowNumber)];
            let resultReturn = new Result(resultString, null, 0, points, BarcodeFormat$1.ITF, new Date().getTime());
            return resultReturn;
          }
          static decodeMiddle(row, payloadStart, payloadEnd, resultString) {
            let counterDigitPair = new Int32Array(10);
            let counterBlack = new Int32Array(5);
            let counterWhite = new Int32Array(5);
            counterDigitPair.fill(0);
            counterBlack.fill(0);
            counterWhite.fill(0);
            while (payloadStart < payloadEnd) {
              OneDReader.recordPattern(row, payloadStart, counterDigitPair);
              for (let k = 0; k < 5; k++) {
                let twoK = 2 * k;
                counterBlack[k] = counterDigitPair[twoK];
                counterWhite[k] = counterDigitPair[twoK + 1];
              }
              let bestMatch = ITFReader.decodeDigit(counterBlack);
              resultString.append(bestMatch.toString());
              bestMatch = this.decodeDigit(counterWhite);
              resultString.append(bestMatch.toString());
              counterDigitPair.forEach(function(counterDigit) {
                payloadStart += counterDigit;
              });
            }
          }
          decodeStart(row) {
            let endStart = ITFReader.skipWhiteSpace(row);
            let startPattern = ITFReader.findGuardPattern(row, endStart, ITFReader.START_PATTERN);
            this.narrowLineWidth = (startPattern[1] - startPattern[0]) / 4;
            this.validateQuietZone(row, startPattern[0]);
            return startPattern;
          }
          validateQuietZone(row, startPattern) {
            let quietCount = this.narrowLineWidth * 10;
            quietCount = quietCount < startPattern ? quietCount : startPattern;
            for (let i = startPattern - 1; quietCount > 0 && i >= 0; i--) {
              if (row.get(i)) {
                break;
              }
              quietCount--;
            }
            if (quietCount !== 0) {
              throw new NotFoundException();
            }
          }
          static skipWhiteSpace(row) {
            const width = row.getSize();
            const endStart = row.getNextSet(0);
            if (endStart === width) {
              throw new NotFoundException();
            }
            return endStart;
          }
          decodeEnd(row) {
            row.reverse();
            try {
              let endStart = ITFReader.skipWhiteSpace(row);
              let endPattern;
              try {
                endPattern = ITFReader.findGuardPattern(row, endStart, ITFReader.END_PATTERN_REVERSED[0]);
              } catch (error2) {
                if (error2 instanceof NotFoundException) {
                  endPattern = ITFReader.findGuardPattern(row, endStart, ITFReader.END_PATTERN_REVERSED[1]);
                }
              }
              this.validateQuietZone(row, endPattern[0]);
              let temp = endPattern[0];
              endPattern[0] = row.getSize() - endPattern[1];
              endPattern[1] = row.getSize() - temp;
              return endPattern;
            } finally {
              row.reverse();
            }
          }
          static findGuardPattern(row, rowOffset, pattern) {
            let patternLength = pattern.length;
            let counters = new Int32Array(patternLength);
            let width = row.getSize();
            let isWhite = false;
            let counterPosition = 0;
            let patternStart = rowOffset;
            counters.fill(0);
            for (let x = rowOffset; x < width; x++) {
              if (row.get(x) !== isWhite) {
                counters[counterPosition]++;
              } else {
                if (counterPosition === patternLength - 1) {
                  if (OneDReader.patternMatchVariance(counters, pattern, ITFReader.MAX_INDIVIDUAL_VARIANCE) < ITFReader.MAX_AVG_VARIANCE) {
                    return [patternStart, x];
                  }
                  patternStart += counters[0] + counters[1];
                  System.arraycopy(counters, 2, counters, 0, counterPosition - 1);
                  counters[counterPosition - 1] = 0;
                  counters[counterPosition] = 0;
                  counterPosition--;
                } else {
                  counterPosition++;
                }
                counters[counterPosition] = 1;
                isWhite = !isWhite;
              }
            }
            throw new NotFoundException();
          }
          static decodeDigit(counters) {
            let bestVariance = ITFReader.MAX_AVG_VARIANCE;
            let bestMatch = -1;
            let max = ITFReader.PATTERNS.length;
            for (let i = 0; i < max; i++) {
              let pattern = ITFReader.PATTERNS[i];
              let variance = OneDReader.patternMatchVariance(counters, pattern, ITFReader.MAX_INDIVIDUAL_VARIANCE);
              if (variance < bestVariance) {
                bestVariance = variance;
                bestMatch = i;
              } else if (variance === bestVariance) {
                bestMatch = -1;
              }
            }
            if (bestMatch >= 0) {
              return bestMatch % 10;
            } else {
              throw new NotFoundException();
            }
          }
        }
        ITFReader.PATTERNS = [
          Int32Array.from([1, 1, 2, 2, 1]),
          Int32Array.from([2, 1, 1, 1, 2]),
          Int32Array.from([1, 2, 1, 1, 2]),
          Int32Array.from([2, 2, 1, 1, 1]),
          Int32Array.from([1, 1, 2, 1, 2]),
          Int32Array.from([2, 1, 2, 1, 1]),
          Int32Array.from([1, 2, 2, 1, 1]),
          Int32Array.from([1, 1, 1, 2, 2]),
          Int32Array.from([2, 1, 1, 2, 1]),
          Int32Array.from([1, 2, 1, 2, 1]),
          Int32Array.from([1, 1, 3, 3, 1]),
          Int32Array.from([3, 1, 1, 1, 3]),
          Int32Array.from([1, 3, 1, 1, 3]),
          Int32Array.from([3, 3, 1, 1, 1]),
          Int32Array.from([1, 1, 3, 1, 3]),
          Int32Array.from([3, 1, 3, 1, 1]),
          Int32Array.from([1, 3, 3, 1, 1]),
          Int32Array.from([1, 1, 1, 3, 3]),
          Int32Array.from([3, 1, 1, 3, 1]),
          Int32Array.from([1, 3, 1, 3, 1])
        ];
        ITFReader.MAX_AVG_VARIANCE = 0.38;
        ITFReader.MAX_INDIVIDUAL_VARIANCE = 0.5;
        ITFReader.DEFAULT_ALLOWED_LENGTHS = [6, 8, 10, 12, 14];
        ITFReader.START_PATTERN = Int32Array.from([1, 1, 1, 1]);
        ITFReader.END_PATTERN_REVERSED = [
          Int32Array.from([1, 1, 2]),
          Int32Array.from([1, 1, 3])
        ];
        class AbstractUPCEANReader extends OneDReader {
          constructor() {
            super(...arguments);
            this.decodeRowStringBuffer = "";
          }
          static findStartGuardPattern(row) {
            let foundStart = false;
            let startRange;
            let nextStart = 0;
            let counters = Int32Array.from([0, 0, 0]);
            while (!foundStart) {
              counters = Int32Array.from([0, 0, 0]);
              startRange = AbstractUPCEANReader.findGuardPattern(row, nextStart, false, this.START_END_PATTERN, counters);
              let start2 = startRange[0];
              nextStart = startRange[1];
              let quietStart = start2 - (nextStart - start2);
              if (quietStart >= 0) {
                foundStart = row.isRange(quietStart, start2, false);
              }
            }
            return startRange;
          }
          static checkChecksum(s) {
            return AbstractUPCEANReader.checkStandardUPCEANChecksum(s);
          }
          static checkStandardUPCEANChecksum(s) {
            let length = s.length;
            if (length === 0)
              return false;
            let check = parseInt(s.charAt(length - 1), 10);
            return AbstractUPCEANReader.getStandardUPCEANChecksum(s.substring(0, length - 1)) === check;
          }
          static getStandardUPCEANChecksum(s) {
            let length = s.length;
            let sum = 0;
            for (let i = length - 1; i >= 0; i -= 2) {
              let digit = s.charAt(i).charCodeAt(0) - "0".charCodeAt(0);
              if (digit < 0 || digit > 9) {
                throw new FormatException();
              }
              sum += digit;
            }
            sum *= 3;
            for (let i = length - 2; i >= 0; i -= 2) {
              let digit = s.charAt(i).charCodeAt(0) - "0".charCodeAt(0);
              if (digit < 0 || digit > 9) {
                throw new FormatException();
              }
              sum += digit;
            }
            return (1e3 - sum) % 10;
          }
          static decodeEnd(row, endStart) {
            return AbstractUPCEANReader.findGuardPattern(row, endStart, false, AbstractUPCEANReader.START_END_PATTERN, new Int32Array(AbstractUPCEANReader.START_END_PATTERN.length).fill(0));
          }
          static findGuardPatternWithoutCounters(row, rowOffset, whiteFirst, pattern) {
            return this.findGuardPattern(row, rowOffset, whiteFirst, pattern, new Int32Array(pattern.length));
          }
          static findGuardPattern(row, rowOffset, whiteFirst, pattern, counters) {
            let width = row.getSize();
            rowOffset = whiteFirst ? row.getNextUnset(rowOffset) : row.getNextSet(rowOffset);
            let counterPosition = 0;
            let patternStart = rowOffset;
            let patternLength = pattern.length;
            let isWhite = whiteFirst;
            for (let x = rowOffset; x < width; x++) {
              if (row.get(x) !== isWhite) {
                counters[counterPosition]++;
              } else {
                if (counterPosition === patternLength - 1) {
                  if (OneDReader.patternMatchVariance(counters, pattern, AbstractUPCEANReader.MAX_INDIVIDUAL_VARIANCE) < AbstractUPCEANReader.MAX_AVG_VARIANCE) {
                    return Int32Array.from([patternStart, x]);
                  }
                  patternStart += counters[0] + counters[1];
                  let slice = counters.slice(2, counters.length - 1);
                  for (let i = 0; i < counterPosition - 1; i++) {
                    counters[i] = slice[i];
                  }
                  counters[counterPosition - 1] = 0;
                  counters[counterPosition] = 0;
                  counterPosition--;
                } else {
                  counterPosition++;
                }
                counters[counterPosition] = 1;
                isWhite = !isWhite;
              }
            }
            throw new NotFoundException();
          }
          static decodeDigit(row, counters, rowOffset, patterns2) {
            this.recordPattern(row, rowOffset, counters);
            let bestVariance = this.MAX_AVG_VARIANCE;
            let bestMatch = -1;
            let max = patterns2.length;
            for (let i = 0; i < max; i++) {
              let pattern = patterns2[i];
              let variance = OneDReader.patternMatchVariance(counters, pattern, AbstractUPCEANReader.MAX_INDIVIDUAL_VARIANCE);
              if (variance < bestVariance) {
                bestVariance = variance;
                bestMatch = i;
              }
            }
            if (bestMatch >= 0) {
              return bestMatch;
            } else {
              throw new NotFoundException();
            }
          }
        }
        AbstractUPCEANReader.MAX_AVG_VARIANCE = 0.48;
        AbstractUPCEANReader.MAX_INDIVIDUAL_VARIANCE = 0.7;
        AbstractUPCEANReader.START_END_PATTERN = Int32Array.from([1, 1, 1]);
        AbstractUPCEANReader.MIDDLE_PATTERN = Int32Array.from([1, 1, 1, 1, 1]);
        AbstractUPCEANReader.END_PATTERN = Int32Array.from([1, 1, 1, 1, 1, 1]);
        AbstractUPCEANReader.L_PATTERNS = [
          Int32Array.from([3, 2, 1, 1]),
          Int32Array.from([2, 2, 2, 1]),
          Int32Array.from([2, 1, 2, 2]),
          Int32Array.from([1, 4, 1, 1]),
          Int32Array.from([1, 1, 3, 2]),
          Int32Array.from([1, 2, 3, 1]),
          Int32Array.from([1, 1, 1, 4]),
          Int32Array.from([1, 3, 1, 2]),
          Int32Array.from([1, 2, 1, 3]),
          Int32Array.from([3, 1, 1, 2])
        ];
        class UPCEANExtension5Support {
          constructor() {
            this.CHECK_DIGIT_ENCODINGS = [24, 20, 18, 17, 12, 6, 3, 10, 9, 5];
            this.decodeMiddleCounters = Int32Array.from([0, 0, 0, 0]);
            this.decodeRowStringBuffer = "";
          }
          decodeRow(rowNumber, row, extensionStartRange) {
            let result = this.decodeRowStringBuffer;
            let end = this.decodeMiddle(row, extensionStartRange, result);
            let resultString = result.toString();
            let extensionData = UPCEANExtension5Support.parseExtensionString(resultString);
            let resultPoints = [
              new ResultPoint((extensionStartRange[0] + extensionStartRange[1]) / 2, rowNumber),
              new ResultPoint(end, rowNumber)
            ];
            let extensionResult = new Result(resultString, null, 0, resultPoints, BarcodeFormat$1.UPC_EAN_EXTENSION, new Date().getTime());
            if (extensionData != null) {
              extensionResult.putAllMetadata(extensionData);
            }
            return extensionResult;
          }
          decodeMiddle(row, startRange, resultString) {
            let counters = this.decodeMiddleCounters;
            counters[0] = 0;
            counters[1] = 0;
            counters[2] = 0;
            counters[3] = 0;
            let end = row.getSize();
            let rowOffset = startRange[1];
            let lgPatternFound = 0;
            for (let x = 0; x < 5 && rowOffset < end; x++) {
              let bestMatch = AbstractUPCEANReader.decodeDigit(row, counters, rowOffset, AbstractUPCEANReader.L_AND_G_PATTERNS);
              resultString += String.fromCharCode("0".charCodeAt(0) + bestMatch % 10);
              for (let counter of counters) {
                rowOffset += counter;
              }
              if (bestMatch >= 10) {
                lgPatternFound |= 1 << 4 - x;
              }
              if (x !== 4) {
                rowOffset = row.getNextSet(rowOffset);
                rowOffset = row.getNextUnset(rowOffset);
              }
            }
            if (resultString.length !== 5) {
              throw new NotFoundException();
            }
            let checkDigit = this.determineCheckDigit(lgPatternFound);
            if (UPCEANExtension5Support.extensionChecksum(resultString.toString()) !== checkDigit) {
              throw new NotFoundException();
            }
            return rowOffset;
          }
          static extensionChecksum(s) {
            let length = s.length;
            let sum = 0;
            for (let i = length - 2; i >= 0; i -= 2) {
              sum += s.charAt(i).charCodeAt(0) - "0".charCodeAt(0);
            }
            sum *= 3;
            for (let i = length - 1; i >= 0; i -= 2) {
              sum += s.charAt(i).charCodeAt(0) - "0".charCodeAt(0);
            }
            sum *= 3;
            return sum % 10;
          }
          determineCheckDigit(lgPatternFound) {
            for (let d = 0; d < 10; d++) {
              if (lgPatternFound === this.CHECK_DIGIT_ENCODINGS[d]) {
                return d;
              }
            }
            throw new NotFoundException();
          }
          static parseExtensionString(raw2) {
            if (raw2.length !== 5) {
              return null;
            }
            let value = UPCEANExtension5Support.parseExtension5String(raw2);
            if (value == null) {
              return null;
            }
            return /* @__PURE__ */ new Map([[ResultMetadataType$1.SUGGESTED_PRICE, value]]);
          }
          static parseExtension5String(raw2) {
            let currency;
            switch (raw2.charAt(0)) {
              case "0":
                currency = "\xA3";
                break;
              case "5":
                currency = "$";
                break;
              case "9":
                switch (raw2) {
                  case "90000":
                    return null;
                  case "99991":
                    return "0.00";
                  case "99990":
                    return "Used";
                }
                currency = "";
                break;
              default:
                currency = "";
                break;
            }
            let rawAmount = parseInt(raw2.substring(1));
            let unitsString = (rawAmount / 100).toString();
            let hundredths = rawAmount % 100;
            let hundredthsString = hundredths < 10 ? "0" + hundredths : hundredths.toString();
            return currency + unitsString + "." + hundredthsString;
          }
        }
        class UPCEANExtension2Support {
          constructor() {
            this.decodeMiddleCounters = Int32Array.from([0, 0, 0, 0]);
            this.decodeRowStringBuffer = "";
          }
          decodeRow(rowNumber, row, extensionStartRange) {
            let result = this.decodeRowStringBuffer;
            let end = this.decodeMiddle(row, extensionStartRange, result);
            let resultString = result.toString();
            let extensionData = UPCEANExtension2Support.parseExtensionString(resultString);
            let resultPoints = [
              new ResultPoint((extensionStartRange[0] + extensionStartRange[1]) / 2, rowNumber),
              new ResultPoint(end, rowNumber)
            ];
            let extensionResult = new Result(resultString, null, 0, resultPoints, BarcodeFormat$1.UPC_EAN_EXTENSION, new Date().getTime());
            if (extensionData != null) {
              extensionResult.putAllMetadata(extensionData);
            }
            return extensionResult;
          }
          decodeMiddle(row, startRange, resultString) {
            let counters = this.decodeMiddleCounters;
            counters[0] = 0;
            counters[1] = 0;
            counters[2] = 0;
            counters[3] = 0;
            let end = row.getSize();
            let rowOffset = startRange[1];
            let checkParity = 0;
            for (let x = 0; x < 2 && rowOffset < end; x++) {
              let bestMatch = AbstractUPCEANReader.decodeDigit(row, counters, rowOffset, AbstractUPCEANReader.L_AND_G_PATTERNS);
              resultString += String.fromCharCode("0".charCodeAt(0) + bestMatch % 10);
              for (let counter of counters) {
                rowOffset += counter;
              }
              if (bestMatch >= 10) {
                checkParity |= 1 << 1 - x;
              }
              if (x !== 1) {
                rowOffset = row.getNextSet(rowOffset);
                rowOffset = row.getNextUnset(rowOffset);
              }
            }
            if (resultString.length !== 2) {
              throw new NotFoundException();
            }
            if (parseInt(resultString.toString()) % 4 !== checkParity) {
              throw new NotFoundException();
            }
            return rowOffset;
          }
          static parseExtensionString(raw2) {
            if (raw2.length !== 2) {
              return null;
            }
            return /* @__PURE__ */ new Map([[ResultMetadataType$1.ISSUE_NUMBER, parseInt(raw2)]]);
          }
        }
        class UPCEANExtensionSupport {
          static decodeRow(rowNumber, row, rowOffset) {
            let extensionStartRange = AbstractUPCEANReader.findGuardPattern(row, rowOffset, false, this.EXTENSION_START_PATTERN, new Int32Array(this.EXTENSION_START_PATTERN.length).fill(0));
            try {
              let fiveSupport = new UPCEANExtension5Support();
              return fiveSupport.decodeRow(rowNumber, row, extensionStartRange);
            } catch (err) {
              let twoSupport = new UPCEANExtension2Support();
              return twoSupport.decodeRow(rowNumber, row, extensionStartRange);
            }
          }
        }
        UPCEANExtensionSupport.EXTENSION_START_PATTERN = Int32Array.from([1, 1, 2]);
        class UPCEANReader extends AbstractUPCEANReader {
          constructor() {
            super();
            this.decodeRowStringBuffer = "";
            UPCEANReader.L_AND_G_PATTERNS = UPCEANReader.L_PATTERNS.map((arr) => Int32Array.from(arr));
            for (let i = 10; i < 20; i++) {
              let widths = UPCEANReader.L_PATTERNS[i - 10];
              let reversedWidths = new Int32Array(widths.length);
              for (let j = 0; j < widths.length; j++) {
                reversedWidths[j] = widths[widths.length - j - 1];
              }
              UPCEANReader.L_AND_G_PATTERNS[i] = reversedWidths;
            }
          }
          decodeRow(rowNumber, row, hints) {
            let startGuardRange = UPCEANReader.findStartGuardPattern(row);
            let resultPointCallback = hints == null ? null : hints.get(DecodeHintType$1.NEED_RESULT_POINT_CALLBACK);
            if (resultPointCallback != null) {
              const resultPoint2 = new ResultPoint((startGuardRange[0] + startGuardRange[1]) / 2, rowNumber);
              resultPointCallback.foundPossibleResultPoint(resultPoint2);
            }
            let budello = this.decodeMiddle(row, startGuardRange, this.decodeRowStringBuffer);
            let endStart = budello.rowOffset;
            let result = budello.resultString;
            if (resultPointCallback != null) {
              const resultPoint2 = new ResultPoint(endStart, rowNumber);
              resultPointCallback.foundPossibleResultPoint(resultPoint2);
            }
            let endRange = this.decodeEnd(row, endStart);
            if (resultPointCallback != null) {
              const resultPoint2 = new ResultPoint((endRange[0] + endRange[1]) / 2, rowNumber);
              resultPointCallback.foundPossibleResultPoint(resultPoint2);
            }
            let end = endRange[1];
            let quietEnd = end + (end - endRange[0]);
            if (quietEnd >= row.getSize() || !row.isRange(end, quietEnd, false)) {
              throw new NotFoundException();
            }
            let resultString = result.toString();
            if (resultString.length < 8) {
              throw new FormatException();
            }
            if (!UPCEANReader.checkChecksum(resultString)) {
              throw new ChecksumException();
            }
            let left = (startGuardRange[1] + startGuardRange[0]) / 2;
            let right = (endRange[1] + endRange[0]) / 2;
            let format = this.getBarcodeFormat();
            let resultPoint = [new ResultPoint(left, rowNumber), new ResultPoint(right, rowNumber)];
            let decodeResult = new Result(resultString, null, 0, resultPoint, format, new Date().getTime());
            let extensionLength = 0;
            try {
              let extensionResult = UPCEANExtensionSupport.decodeRow(rowNumber, row, endRange[1]);
              decodeResult.putMetadata(ResultMetadataType$1.UPC_EAN_EXTENSION, extensionResult.getText());
              decodeResult.putAllMetadata(extensionResult.getResultMetadata());
              decodeResult.addResultPoints(extensionResult.getResultPoints());
              extensionLength = extensionResult.getText().length;
            } catch (ignoreError) {
            }
            let allowedExtensions = hints == null ? null : hints.get(DecodeHintType$1.ALLOWED_EAN_EXTENSIONS);
            if (allowedExtensions != null) {
              let valid = false;
              for (let length in allowedExtensions) {
                if (extensionLength.toString() === length) {
                  valid = true;
                  break;
                }
              }
              if (!valid) {
                throw new NotFoundException();
              }
            }
            return decodeResult;
          }
          decodeEnd(row, endStart) {
            return UPCEANReader.findGuardPattern(row, endStart, false, UPCEANReader.START_END_PATTERN, new Int32Array(UPCEANReader.START_END_PATTERN.length).fill(0));
          }
          static checkChecksum(s) {
            return UPCEANReader.checkStandardUPCEANChecksum(s);
          }
          static checkStandardUPCEANChecksum(s) {
            let length = s.length;
            if (length === 0)
              return false;
            let check = parseInt(s.charAt(length - 1), 10);
            return UPCEANReader.getStandardUPCEANChecksum(s.substring(0, length - 1)) === check;
          }
          static getStandardUPCEANChecksum(s) {
            let length = s.length;
            let sum = 0;
            for (let i = length - 1; i >= 0; i -= 2) {
              let digit = s.charAt(i).charCodeAt(0) - "0".charCodeAt(0);
              if (digit < 0 || digit > 9) {
                throw new FormatException();
              }
              sum += digit;
            }
            sum *= 3;
            for (let i = length - 2; i >= 0; i -= 2) {
              let digit = s.charAt(i).charCodeAt(0) - "0".charCodeAt(0);
              if (digit < 0 || digit > 9) {
                throw new FormatException();
              }
              sum += digit;
            }
            return (1e3 - sum) % 10;
          }
        }
        class EAN13Reader extends UPCEANReader {
          constructor() {
            super();
            this.decodeMiddleCounters = Int32Array.from([0, 0, 0, 0]);
          }
          decodeMiddle(row, startRange, resultString) {
            let counters = this.decodeMiddleCounters;
            counters[0] = 0;
            counters[1] = 0;
            counters[2] = 0;
            counters[3] = 0;
            let end = row.getSize();
            let rowOffset = startRange[1];
            let lgPatternFound = 0;
            for (let x = 0; x < 6 && rowOffset < end; x++) {
              let bestMatch = UPCEANReader.decodeDigit(row, counters, rowOffset, UPCEANReader.L_AND_G_PATTERNS);
              resultString += String.fromCharCode("0".charCodeAt(0) + bestMatch % 10);
              for (let counter of counters) {
                rowOffset += counter;
              }
              if (bestMatch >= 10) {
                lgPatternFound |= 1 << 5 - x;
              }
            }
            resultString = EAN13Reader.determineFirstDigit(resultString, lgPatternFound);
            let middleRange = UPCEANReader.findGuardPattern(row, rowOffset, true, UPCEANReader.MIDDLE_PATTERN, new Int32Array(UPCEANReader.MIDDLE_PATTERN.length).fill(0));
            rowOffset = middleRange[1];
            for (let x = 0; x < 6 && rowOffset < end; x++) {
              let bestMatch = UPCEANReader.decodeDigit(row, counters, rowOffset, UPCEANReader.L_PATTERNS);
              resultString += String.fromCharCode("0".charCodeAt(0) + bestMatch);
              for (let counter of counters) {
                rowOffset += counter;
              }
            }
            return { rowOffset, resultString };
          }
          getBarcodeFormat() {
            return BarcodeFormat$1.EAN_13;
          }
          static determineFirstDigit(resultString, lgPatternFound) {
            for (let d = 0; d < 10; d++) {
              if (lgPatternFound === this.FIRST_DIGIT_ENCODINGS[d]) {
                resultString = String.fromCharCode("0".charCodeAt(0) + d) + resultString;
                return resultString;
              }
            }
            throw new NotFoundException();
          }
        }
        EAN13Reader.FIRST_DIGIT_ENCODINGS = [0, 11, 13, 14, 19, 25, 28, 21, 22, 26];
        class EAN8Reader extends UPCEANReader {
          constructor() {
            super();
            this.decodeMiddleCounters = Int32Array.from([0, 0, 0, 0]);
          }
          decodeMiddle(row, startRange, resultString) {
            const counters = this.decodeMiddleCounters;
            counters[0] = 0;
            counters[1] = 0;
            counters[2] = 0;
            counters[3] = 0;
            let end = row.getSize();
            let rowOffset = startRange[1];
            for (let x = 0; x < 4 && rowOffset < end; x++) {
              let bestMatch = UPCEANReader.decodeDigit(row, counters, rowOffset, UPCEANReader.L_PATTERNS);
              resultString += String.fromCharCode("0".charCodeAt(0) + bestMatch);
              for (let counter of counters) {
                rowOffset += counter;
              }
            }
            let middleRange = UPCEANReader.findGuardPattern(row, rowOffset, true, UPCEANReader.MIDDLE_PATTERN, new Int32Array(UPCEANReader.MIDDLE_PATTERN.length).fill(0));
            rowOffset = middleRange[1];
            for (let x = 0; x < 4 && rowOffset < end; x++) {
              let bestMatch = UPCEANReader.decodeDigit(row, counters, rowOffset, UPCEANReader.L_PATTERNS);
              resultString += String.fromCharCode("0".charCodeAt(0) + bestMatch);
              for (let counter of counters) {
                rowOffset += counter;
              }
            }
            return { rowOffset, resultString };
          }
          getBarcodeFormat() {
            return BarcodeFormat$1.EAN_8;
          }
        }
        class UPCAReader extends UPCEANReader {
          constructor() {
            super(...arguments);
            this.ean13Reader = new EAN13Reader();
          }
          getBarcodeFormat() {
            return BarcodeFormat$1.UPC_A;
          }
          decode(image, hints) {
            return this.maybeReturnResult(this.ean13Reader.decode(image));
          }
          decodeRow(rowNumber, row, hints) {
            return this.maybeReturnResult(this.ean13Reader.decodeRow(rowNumber, row, hints));
          }
          decodeMiddle(row, startRange, resultString) {
            return this.ean13Reader.decodeMiddle(row, startRange, resultString);
          }
          maybeReturnResult(result) {
            let text = result.getText();
            if (text.charAt(0) === "0") {
              let upcaResult = new Result(text.substring(1), null, null, result.getResultPoints(), BarcodeFormat$1.UPC_A);
              if (result.getResultMetadata() != null) {
                upcaResult.putAllMetadata(result.getResultMetadata());
              }
              return upcaResult;
            } else {
              throw new NotFoundException();
            }
          }
          reset() {
            this.ean13Reader.reset();
          }
        }
        class UPCEReader extends UPCEANReader {
          constructor() {
            super();
            this.decodeMiddleCounters = new Int32Array(4);
          }
          decodeMiddle(row, startRange, result) {
            const counters = this.decodeMiddleCounters.map((x) => x);
            counters[0] = 0;
            counters[1] = 0;
            counters[2] = 0;
            counters[3] = 0;
            const end = row.getSize();
            let rowOffset = startRange[1];
            let lgPatternFound = 0;
            for (let x = 0; x < 6 && rowOffset < end; x++) {
              const bestMatch = UPCEReader.decodeDigit(row, counters, rowOffset, UPCEReader.L_AND_G_PATTERNS);
              result += String.fromCharCode("0".charCodeAt(0) + bestMatch % 10);
              for (let counter of counters) {
                rowOffset += counter;
              }
              if (bestMatch >= 10) {
                lgPatternFound |= 1 << 5 - x;
              }
            }
            let resultString = UPCEReader.determineNumSysAndCheckDigit(result, lgPatternFound);
            return { rowOffset, resultString };
          }
          decodeEnd(row, endStart) {
            return UPCEReader.findGuardPatternWithoutCounters(row, endStart, true, UPCEReader.MIDDLE_END_PATTERN);
          }
          checkChecksum(s) {
            return UPCEANReader.checkChecksum(UPCEReader.convertUPCEtoUPCA(s));
          }
          static determineNumSysAndCheckDigit(resultString, lgPatternFound) {
            for (let numSys = 0; numSys <= 1; numSys++) {
              for (let d = 0; d < 10; d++) {
                if (lgPatternFound === this.NUMSYS_AND_CHECK_DIGIT_PATTERNS[numSys][d]) {
                  let prefix2 = String.fromCharCode("0".charCodeAt(0) + numSys);
                  let suffix = String.fromCharCode("0".charCodeAt(0) + d);
                  return prefix2 + resultString + suffix;
                }
              }
            }
            throw NotFoundException.getNotFoundInstance();
          }
          getBarcodeFormat() {
            return BarcodeFormat$1.UPC_E;
          }
          static convertUPCEtoUPCA(upce) {
            const upceChars = upce.slice(1, 7).split("").map((x) => x.charCodeAt(0));
            const result = new StringBuilder();
            result.append(upce.charAt(0));
            let lastChar = upceChars[5];
            switch (lastChar) {
              case 0:
              case 1:
              case 2:
                result.appendChars(upceChars, 0, 2);
                result.append(lastChar);
                result.append("0000");
                result.appendChars(upceChars, 2, 3);
                break;
              case 3:
                result.appendChars(upceChars, 0, 3);
                result.append("00000");
                result.appendChars(upceChars, 3, 2);
                break;
              case 4:
                result.appendChars(upceChars, 0, 4);
                result.append("00000");
                result.append(upceChars[4]);
                break;
              default:
                result.appendChars(upceChars, 0, 5);
                result.append("0000");
                result.append(lastChar);
                break;
            }
            if (upce.length >= 8) {
              result.append(upce.charAt(7));
            }
            return result.toString();
          }
        }
        UPCEReader.MIDDLE_END_PATTERN = Int32Array.from([1, 1, 1, 1, 1, 1]);
        UPCEReader.NUMSYS_AND_CHECK_DIGIT_PATTERNS = [
          Int32Array.from([56, 52, 50, 49, 44, 38, 35, 42, 41, 37]),
          Int32Array.from([7, 11, 13, 14, 19, 25, 28, 21, 22, 26])
        ];
        class MultiFormatUPCEANReader extends OneDReader {
          constructor(hints) {
            super();
            let possibleFormats = hints == null ? null : hints.get(DecodeHintType$1.POSSIBLE_FORMATS);
            let readers = [];
            if (!isNullOrUndefined2(possibleFormats)) {
              if (possibleFormats.indexOf(BarcodeFormat$1.EAN_13) > -1) {
                readers.push(new EAN13Reader());
              }
              if (possibleFormats.indexOf(BarcodeFormat$1.UPC_A) > -1) {
                readers.push(new UPCAReader());
              }
              if (possibleFormats.indexOf(BarcodeFormat$1.EAN_8) > -1) {
                readers.push(new EAN8Reader());
              }
              if (possibleFormats.indexOf(BarcodeFormat$1.UPC_E) > -1) {
                readers.push(new UPCEReader());
              }
            } else {
              readers.push(new EAN13Reader());
              readers.push(new UPCAReader());
              readers.push(new EAN8Reader());
              readers.push(new UPCEReader());
            }
            this.readers = readers;
          }
          decodeRow(rowNumber, row, hints) {
            for (let reader of this.readers) {
              try {
                const result = reader.decodeRow(rowNumber, row, hints);
                const ean13MayBeUPCA = result.getBarcodeFormat() === BarcodeFormat$1.EAN_13 && result.getText().charAt(0) === "0";
                const possibleFormats = hints == null ? null : hints.get(DecodeHintType$1.POSSIBLE_FORMATS);
                const canReturnUPCA = possibleFormats == null || possibleFormats.includes(BarcodeFormat$1.UPC_A);
                if (ean13MayBeUPCA && canReturnUPCA) {
                  const rawBytes = result.getRawBytes();
                  const resultUPCA = new Result(result.getText().substring(1), rawBytes, rawBytes ? rawBytes.length : null, result.getResultPoints(), BarcodeFormat$1.UPC_A);
                  resultUPCA.putAllMetadata(result.getResultMetadata());
                  return resultUPCA;
                }
                return result;
              } catch (err) {
              }
            }
            throw new NotFoundException();
          }
          reset() {
            for (let reader of this.readers) {
              reader.reset();
            }
          }
        }
        class AbstractRSSReader extends OneDReader {
          constructor() {
            super();
            this.decodeFinderCounters = new Int32Array(4);
            this.dataCharacterCounters = new Int32Array(8);
            this.oddRoundingErrors = new Array(4);
            this.evenRoundingErrors = new Array(4);
            this.oddCounts = new Array(this.dataCharacterCounters.length / 2);
            this.evenCounts = new Array(this.dataCharacterCounters.length / 2);
          }
          getDecodeFinderCounters() {
            return this.decodeFinderCounters;
          }
          getDataCharacterCounters() {
            return this.dataCharacterCounters;
          }
          getOddRoundingErrors() {
            return this.oddRoundingErrors;
          }
          getEvenRoundingErrors() {
            return this.evenRoundingErrors;
          }
          getOddCounts() {
            return this.oddCounts;
          }
          getEvenCounts() {
            return this.evenCounts;
          }
          parseFinderValue(counters, finderPatterns) {
            for (let value = 0; value < finderPatterns.length; value++) {
              if (OneDReader.patternMatchVariance(counters, finderPatterns[value], AbstractRSSReader.MAX_INDIVIDUAL_VARIANCE) < AbstractRSSReader.MAX_AVG_VARIANCE) {
                return value;
              }
            }
            throw new NotFoundException();
          }
          static count(array) {
            return MathUtils.sum(new Int32Array(array));
          }
          static increment(array, errors) {
            let index = 0;
            let biggestError = errors[0];
            for (let i = 1; i < array.length; i++) {
              if (errors[i] > biggestError) {
                biggestError = errors[i];
                index = i;
              }
            }
            array[index]++;
          }
          static decrement(array, errors) {
            let index = 0;
            let biggestError = errors[0];
            for (let i = 1; i < array.length; i++) {
              if (errors[i] < biggestError) {
                biggestError = errors[i];
                index = i;
              }
            }
            array[index]--;
          }
          static isFinderPattern(counters) {
            let firstTwoSum = counters[0] + counters[1];
            let sum = firstTwoSum + counters[2] + counters[3];
            let ratio = firstTwoSum / sum;
            if (ratio >= AbstractRSSReader.MIN_FINDER_PATTERN_RATIO && ratio <= AbstractRSSReader.MAX_FINDER_PATTERN_RATIO) {
              let minCounter = Number.MAX_SAFE_INTEGER;
              let maxCounter = Number.MIN_SAFE_INTEGER;
              for (let counter of counters) {
                if (counter > maxCounter) {
                  maxCounter = counter;
                }
                if (counter < minCounter) {
                  minCounter = counter;
                }
              }
              return maxCounter < 10 * minCounter;
            }
            return false;
          }
        }
        AbstractRSSReader.MAX_AVG_VARIANCE = 0.2;
        AbstractRSSReader.MAX_INDIVIDUAL_VARIANCE = 0.45;
        AbstractRSSReader.MIN_FINDER_PATTERN_RATIO = 9.5 / 12;
        AbstractRSSReader.MAX_FINDER_PATTERN_RATIO = 12.5 / 14;
        class DataCharacter {
          constructor(value, checksumPortion) {
            this.value = value;
            this.checksumPortion = checksumPortion;
          }
          getValue() {
            return this.value;
          }
          getChecksumPortion() {
            return this.checksumPortion;
          }
          toString() {
            return this.value + "(" + this.checksumPortion + ")";
          }
          equals(o) {
            if (!(o instanceof DataCharacter)) {
              return false;
            }
            const that = o;
            return this.value === that.value && this.checksumPortion === that.checksumPortion;
          }
          hashCode() {
            return this.value ^ this.checksumPortion;
          }
        }
        class FinderPattern {
          constructor(value, startEnd, start2, end, rowNumber) {
            this.value = value;
            this.startEnd = startEnd;
            this.value = value;
            this.startEnd = startEnd;
            this.resultPoints = new Array();
            this.resultPoints.push(new ResultPoint(start2, rowNumber));
            this.resultPoints.push(new ResultPoint(end, rowNumber));
          }
          getValue() {
            return this.value;
          }
          getStartEnd() {
            return this.startEnd;
          }
          getResultPoints() {
            return this.resultPoints;
          }
          equals(o) {
            if (!(o instanceof FinderPattern)) {
              return false;
            }
            const that = o;
            return this.value === that.value;
          }
          hashCode() {
            return this.value;
          }
        }
        class RSSUtils {
          constructor() {
          }
          static getRSSvalue(widths, maxWidth, noNarrow) {
            let n = 0;
            for (let width of widths) {
              n += width;
            }
            let val = 0;
            let narrowMask = 0;
            let elements = widths.length;
            for (let bar = 0; bar < elements - 1; bar++) {
              let elmWidth;
              for (elmWidth = 1, narrowMask |= 1 << bar; elmWidth < widths[bar]; elmWidth++, narrowMask &= ~(1 << bar)) {
                let subVal = RSSUtils.combins(n - elmWidth - 1, elements - bar - 2);
                if (noNarrow && narrowMask === 0 && n - elmWidth - (elements - bar - 1) >= elements - bar - 1) {
                  subVal -= RSSUtils.combins(n - elmWidth - (elements - bar), elements - bar - 2);
                }
                if (elements - bar - 1 > 1) {
                  let lessVal = 0;
                  for (let mxwElement = n - elmWidth - (elements - bar - 2); mxwElement > maxWidth; mxwElement--) {
                    lessVal += RSSUtils.combins(n - elmWidth - mxwElement - 1, elements - bar - 3);
                  }
                  subVal -= lessVal * (elements - 1 - bar);
                } else if (n - elmWidth > maxWidth) {
                  subVal--;
                }
                val += subVal;
              }
              n -= elmWidth;
            }
            return val;
          }
          static combins(n, r) {
            let maxDenom;
            let minDenom;
            if (n - r > r) {
              minDenom = r;
              maxDenom = n - r;
            } else {
              minDenom = n - r;
              maxDenom = r;
            }
            let val = 1;
            let j = 1;
            for (let i = n; i > maxDenom; i--) {
              val *= i;
              if (j <= minDenom) {
                val /= j;
                j++;
              }
            }
            while (j <= minDenom) {
              val /= j;
              j++;
            }
            return val;
          }
        }
        class BitArrayBuilder {
          static buildBitArray(pairs) {
            let charNumber = pairs.length * 2 - 1;
            if (pairs[pairs.length - 1].getRightChar() == null) {
              charNumber -= 1;
            }
            let size2 = 12 * charNumber;
            let binary = new BitArray(size2);
            let accPos = 0;
            let firstPair = pairs[0];
            let firstValue = firstPair.getRightChar().getValue();
            for (let i = 11; i >= 0; --i) {
              if ((firstValue & 1 << i) != 0) {
                binary.set(accPos);
              }
              accPos++;
            }
            for (let i = 1; i < pairs.length; ++i) {
              let currentPair = pairs[i];
              let leftValue = currentPair.getLeftChar().getValue();
              for (let j = 11; j >= 0; --j) {
                if ((leftValue & 1 << j) != 0) {
                  binary.set(accPos);
                }
                accPos++;
              }
              if (currentPair.getRightChar() != null) {
                let rightValue = currentPair.getRightChar().getValue();
                for (let j = 11; j >= 0; --j) {
                  if ((rightValue & 1 << j) != 0) {
                    binary.set(accPos);
                  }
                  accPos++;
                }
              }
            }
            return binary;
          }
        }
        class BlockParsedResult {
          constructor(finished, decodedInformation) {
            if (decodedInformation) {
              this.decodedInformation = null;
            } else {
              this.finished = finished;
              this.decodedInformation = decodedInformation;
            }
          }
          getDecodedInformation() {
            return this.decodedInformation;
          }
          isFinished() {
            return this.finished;
          }
        }
        class DecodedObject {
          constructor(newPosition) {
            this.newPosition = newPosition;
          }
          getNewPosition() {
            return this.newPosition;
          }
        }
        class DecodedChar extends DecodedObject {
          constructor(newPosition, value) {
            super(newPosition);
            this.value = value;
          }
          getValue() {
            return this.value;
          }
          isFNC1() {
            return this.value === DecodedChar.FNC1;
          }
        }
        DecodedChar.FNC1 = "$";
        class DecodedInformation extends DecodedObject {
          constructor(newPosition, newString, remainingValue) {
            super(newPosition);
            if (remainingValue) {
              this.remaining = true;
              this.remainingValue = this.remainingValue;
            } else {
              this.remaining = false;
              this.remainingValue = 0;
            }
            this.newString = newString;
          }
          getNewString() {
            return this.newString;
          }
          isRemaining() {
            return this.remaining;
          }
          getRemainingValue() {
            return this.remainingValue;
          }
        }
        class DecodedNumeric extends DecodedObject {
          constructor(newPosition, firstDigit, secondDigit) {
            super(newPosition);
            if (firstDigit < 0 || firstDigit > 10 || secondDigit < 0 || secondDigit > 10) {
              throw new FormatException();
            }
            this.firstDigit = firstDigit;
            this.secondDigit = secondDigit;
          }
          getFirstDigit() {
            return this.firstDigit;
          }
          getSecondDigit() {
            return this.secondDigit;
          }
          getValue() {
            return this.firstDigit * 10 + this.secondDigit;
          }
          isFirstDigitFNC1() {
            return this.firstDigit === DecodedNumeric.FNC1;
          }
          isSecondDigitFNC1() {
            return this.secondDigit === DecodedNumeric.FNC1;
          }
          isAnyFNC1() {
            return this.firstDigit === DecodedNumeric.FNC1 || this.secondDigit === DecodedNumeric.FNC1;
          }
        }
        DecodedNumeric.FNC1 = 10;
        class FieldParser {
          constructor() {
          }
          static parseFieldsInGeneralPurpose(rawInformation) {
            if (!rawInformation) {
              return null;
            }
            if (rawInformation.length < 2) {
              throw new NotFoundException();
            }
            let firstTwoDigits = rawInformation.substring(0, 2);
            for (let dataLength of FieldParser.TWO_DIGIT_DATA_LENGTH) {
              if (dataLength[0] === firstTwoDigits) {
                if (dataLength[1] === FieldParser.VARIABLE_LENGTH) {
                  return FieldParser.processVariableAI(2, dataLength[2], rawInformation);
                }
                return FieldParser.processFixedAI(2, dataLength[1], rawInformation);
              }
            }
            if (rawInformation.length < 3) {
              throw new NotFoundException();
            }
            let firstThreeDigits = rawInformation.substring(0, 3);
            for (let dataLength of FieldParser.THREE_DIGIT_DATA_LENGTH) {
              if (dataLength[0] === firstThreeDigits) {
                if (dataLength[1] === FieldParser.VARIABLE_LENGTH) {
                  return FieldParser.processVariableAI(3, dataLength[2], rawInformation);
                }
                return FieldParser.processFixedAI(3, dataLength[1], rawInformation);
              }
            }
            for (let dataLength of FieldParser.THREE_DIGIT_PLUS_DIGIT_DATA_LENGTH) {
              if (dataLength[0] === firstThreeDigits) {
                if (dataLength[1] === FieldParser.VARIABLE_LENGTH) {
                  return FieldParser.processVariableAI(4, dataLength[2], rawInformation);
                }
                return FieldParser.processFixedAI(4, dataLength[1], rawInformation);
              }
            }
            if (rawInformation.length < 4) {
              throw new NotFoundException();
            }
            let firstFourDigits = rawInformation.substring(0, 4);
            for (let dataLength of FieldParser.FOUR_DIGIT_DATA_LENGTH) {
              if (dataLength[0] === firstFourDigits) {
                if (dataLength[1] === FieldParser.VARIABLE_LENGTH) {
                  return FieldParser.processVariableAI(4, dataLength[2], rawInformation);
                }
                return FieldParser.processFixedAI(4, dataLength[1], rawInformation);
              }
            }
            throw new NotFoundException();
          }
          static processFixedAI(aiSize, fieldSize, rawInformation) {
            if (rawInformation.length < aiSize) {
              throw new NotFoundException();
            }
            let ai = rawInformation.substring(0, aiSize);
            if (rawInformation.length < aiSize + fieldSize) {
              throw new NotFoundException();
            }
            let field = rawInformation.substring(aiSize, aiSize + fieldSize);
            let remaining = rawInformation.substring(aiSize + fieldSize);
            let result = "(" + ai + ")" + field;
            let parsedAI = FieldParser.parseFieldsInGeneralPurpose(remaining);
            return parsedAI == null ? result : result + parsedAI;
          }
          static processVariableAI(aiSize, variableFieldSize, rawInformation) {
            let ai = rawInformation.substring(0, aiSize);
            let maxSize;
            if (rawInformation.length < aiSize + variableFieldSize) {
              maxSize = rawInformation.length;
            } else {
              maxSize = aiSize + variableFieldSize;
            }
            let field = rawInformation.substring(aiSize, maxSize);
            let remaining = rawInformation.substring(maxSize);
            let result = "(" + ai + ")" + field;
            let parsedAI = FieldParser.parseFieldsInGeneralPurpose(remaining);
            return parsedAI == null ? result : result + parsedAI;
          }
        }
        FieldParser.VARIABLE_LENGTH = [];
        FieldParser.TWO_DIGIT_DATA_LENGTH = [
          ["00", 18],
          ["01", 14],
          ["02", 14],
          ["10", FieldParser.VARIABLE_LENGTH, 20],
          ["11", 6],
          ["12", 6],
          ["13", 6],
          ["15", 6],
          ["17", 6],
          ["20", 2],
          ["21", FieldParser.VARIABLE_LENGTH, 20],
          ["22", FieldParser.VARIABLE_LENGTH, 29],
          ["30", FieldParser.VARIABLE_LENGTH, 8],
          ["37", FieldParser.VARIABLE_LENGTH, 8],
          ["90", FieldParser.VARIABLE_LENGTH, 30],
          ["91", FieldParser.VARIABLE_LENGTH, 30],
          ["92", FieldParser.VARIABLE_LENGTH, 30],
          ["93", FieldParser.VARIABLE_LENGTH, 30],
          ["94", FieldParser.VARIABLE_LENGTH, 30],
          ["95", FieldParser.VARIABLE_LENGTH, 30],
          ["96", FieldParser.VARIABLE_LENGTH, 30],
          ["97", FieldParser.VARIABLE_LENGTH, 3],
          ["98", FieldParser.VARIABLE_LENGTH, 30],
          ["99", FieldParser.VARIABLE_LENGTH, 30]
        ];
        FieldParser.THREE_DIGIT_DATA_LENGTH = [
          ["240", FieldParser.VARIABLE_LENGTH, 30],
          ["241", FieldParser.VARIABLE_LENGTH, 30],
          ["242", FieldParser.VARIABLE_LENGTH, 6],
          ["250", FieldParser.VARIABLE_LENGTH, 30],
          ["251", FieldParser.VARIABLE_LENGTH, 30],
          ["253", FieldParser.VARIABLE_LENGTH, 17],
          ["254", FieldParser.VARIABLE_LENGTH, 20],
          ["400", FieldParser.VARIABLE_LENGTH, 30],
          ["401", FieldParser.VARIABLE_LENGTH, 30],
          ["402", 17],
          ["403", FieldParser.VARIABLE_LENGTH, 30],
          ["410", 13],
          ["411", 13],
          ["412", 13],
          ["413", 13],
          ["414", 13],
          ["420", FieldParser.VARIABLE_LENGTH, 20],
          ["421", FieldParser.VARIABLE_LENGTH, 15],
          ["422", 3],
          ["423", FieldParser.VARIABLE_LENGTH, 15],
          ["424", 3],
          ["425", 3],
          ["426", 3]
        ];
        FieldParser.THREE_DIGIT_PLUS_DIGIT_DATA_LENGTH = [
          ["310", 6],
          ["311", 6],
          ["312", 6],
          ["313", 6],
          ["314", 6],
          ["315", 6],
          ["316", 6],
          ["320", 6],
          ["321", 6],
          ["322", 6],
          ["323", 6],
          ["324", 6],
          ["325", 6],
          ["326", 6],
          ["327", 6],
          ["328", 6],
          ["329", 6],
          ["330", 6],
          ["331", 6],
          ["332", 6],
          ["333", 6],
          ["334", 6],
          ["335", 6],
          ["336", 6],
          ["340", 6],
          ["341", 6],
          ["342", 6],
          ["343", 6],
          ["344", 6],
          ["345", 6],
          ["346", 6],
          ["347", 6],
          ["348", 6],
          ["349", 6],
          ["350", 6],
          ["351", 6],
          ["352", 6],
          ["353", 6],
          ["354", 6],
          ["355", 6],
          ["356", 6],
          ["357", 6],
          ["360", 6],
          ["361", 6],
          ["362", 6],
          ["363", 6],
          ["364", 6],
          ["365", 6],
          ["366", 6],
          ["367", 6],
          ["368", 6],
          ["369", 6],
          ["390", FieldParser.VARIABLE_LENGTH, 15],
          ["391", FieldParser.VARIABLE_LENGTH, 18],
          ["392", FieldParser.VARIABLE_LENGTH, 15],
          ["393", FieldParser.VARIABLE_LENGTH, 18],
          ["703", FieldParser.VARIABLE_LENGTH, 30]
        ];
        FieldParser.FOUR_DIGIT_DATA_LENGTH = [
          ["7001", 13],
          ["7002", FieldParser.VARIABLE_LENGTH, 30],
          ["7003", 10],
          ["8001", 14],
          ["8002", FieldParser.VARIABLE_LENGTH, 20],
          ["8003", FieldParser.VARIABLE_LENGTH, 30],
          ["8004", FieldParser.VARIABLE_LENGTH, 30],
          ["8005", 6],
          ["8006", 18],
          ["8007", FieldParser.VARIABLE_LENGTH, 30],
          ["8008", FieldParser.VARIABLE_LENGTH, 12],
          ["8018", 18],
          ["8020", FieldParser.VARIABLE_LENGTH, 25],
          ["8100", 6],
          ["8101", 10],
          ["8102", 2],
          ["8110", FieldParser.VARIABLE_LENGTH, 70],
          ["8200", FieldParser.VARIABLE_LENGTH, 70]
        ];
        class GeneralAppIdDecoder {
          constructor(information) {
            this.buffer = new StringBuilder();
            this.information = information;
          }
          decodeAllCodes(buff, initialPosition) {
            let currentPosition = initialPosition;
            let remaining = null;
            do {
              let info = this.decodeGeneralPurposeField(currentPosition, remaining);
              let parsedFields = FieldParser.parseFieldsInGeneralPurpose(info.getNewString());
              if (parsedFields != null) {
                buff.append(parsedFields);
              }
              if (info.isRemaining()) {
                remaining = "" + info.getRemainingValue();
              } else {
                remaining = null;
              }
              if (currentPosition === info.getNewPosition()) {
                break;
              }
              currentPosition = info.getNewPosition();
            } while (true);
            return buff.toString();
          }
          isStillNumeric(pos) {
            if (pos + 7 > this.information.getSize()) {
              return pos + 4 <= this.information.getSize();
            }
            for (let i = pos; i < pos + 3; ++i) {
              if (this.information.get(i)) {
                return true;
              }
            }
            return this.information.get(pos + 3);
          }
          decodeNumeric(pos) {
            if (pos + 7 > this.information.getSize()) {
              let numeric2 = this.extractNumericValueFromBitArray(pos, 4);
              if (numeric2 === 0) {
                return new DecodedNumeric(this.information.getSize(), DecodedNumeric.FNC1, DecodedNumeric.FNC1);
              }
              return new DecodedNumeric(this.information.getSize(), numeric2 - 1, DecodedNumeric.FNC1);
            }
            let numeric = this.extractNumericValueFromBitArray(pos, 7);
            let digit1 = (numeric - 8) / 11;
            let digit2 = (numeric - 8) % 11;
            return new DecodedNumeric(pos + 7, digit1, digit2);
          }
          extractNumericValueFromBitArray(pos, bits) {
            return GeneralAppIdDecoder.extractNumericValueFromBitArray(this.information, pos, bits);
          }
          static extractNumericValueFromBitArray(information, pos, bits) {
            let value = 0;
            for (let i = 0; i < bits; ++i) {
              if (information.get(pos + i)) {
                value |= 1 << bits - i - 1;
              }
            }
            return value;
          }
          decodeGeneralPurposeField(pos, remaining) {
            this.buffer.setLengthToZero();
            if (remaining != null) {
              this.buffer.append(remaining);
            }
            this.current.setPosition(pos);
            let lastDecoded = this.parseBlocks();
            if (lastDecoded != null && lastDecoded.isRemaining()) {
              return new DecodedInformation(this.current.getPosition(), this.buffer.toString(), lastDecoded.getRemainingValue());
            }
            return new DecodedInformation(this.current.getPosition(), this.buffer.toString());
          }
          parseBlocks() {
            let isFinished;
            let result;
            do {
              let initialPosition = this.current.getPosition();
              if (this.current.isAlpha()) {
                result = this.parseAlphaBlock();
                isFinished = result.isFinished();
              } else if (this.current.isIsoIec646()) {
                result = this.parseIsoIec646Block();
                isFinished = result.isFinished();
              } else {
                result = this.parseNumericBlock();
                isFinished = result.isFinished();
              }
              let positionChanged = initialPosition !== this.current.getPosition();
              if (!positionChanged && !isFinished) {
                break;
              }
            } while (!isFinished);
            return result.getDecodedInformation();
          }
          parseNumericBlock() {
            while (this.isStillNumeric(this.current.getPosition())) {
              let numeric = this.decodeNumeric(this.current.getPosition());
              this.current.setPosition(numeric.getNewPosition());
              if (numeric.isFirstDigitFNC1()) {
                let information;
                if (numeric.isSecondDigitFNC1()) {
                  information = new DecodedInformation(this.current.getPosition(), this.buffer.toString());
                } else {
                  information = new DecodedInformation(this.current.getPosition(), this.buffer.toString(), numeric.getSecondDigit());
                }
                return new BlockParsedResult(true, information);
              }
              this.buffer.append(numeric.getFirstDigit());
              if (numeric.isSecondDigitFNC1()) {
                let information = new DecodedInformation(this.current.getPosition(), this.buffer.toString());
                return new BlockParsedResult(true, information);
              }
              this.buffer.append(numeric.getSecondDigit());
            }
            if (this.isNumericToAlphaNumericLatch(this.current.getPosition())) {
              this.current.setAlpha();
              this.current.incrementPosition(4);
            }
            return new BlockParsedResult(false);
          }
          parseIsoIec646Block() {
            while (this.isStillIsoIec646(this.current.getPosition())) {
              let iso = this.decodeIsoIec646(this.current.getPosition());
              this.current.setPosition(iso.getNewPosition());
              if (iso.isFNC1()) {
                let information = new DecodedInformation(this.current.getPosition(), this.buffer.toString());
                return new BlockParsedResult(true, information);
              }
              this.buffer.append(iso.getValue());
            }
            if (this.isAlphaOr646ToNumericLatch(this.current.getPosition())) {
              this.current.incrementPosition(3);
              this.current.setNumeric();
            } else if (this.isAlphaTo646ToAlphaLatch(this.current.getPosition())) {
              if (this.current.getPosition() + 5 < this.information.getSize()) {
                this.current.incrementPosition(5);
              } else {
                this.current.setPosition(this.information.getSize());
              }
              this.current.setAlpha();
            }
            return new BlockParsedResult(false);
          }
          parseAlphaBlock() {
            while (this.isStillAlpha(this.current.getPosition())) {
              let alpha = this.decodeAlphanumeric(this.current.getPosition());
              this.current.setPosition(alpha.getNewPosition());
              if (alpha.isFNC1()) {
                let information = new DecodedInformation(this.current.getPosition(), this.buffer.toString());
                return new BlockParsedResult(true, information);
              }
              this.buffer.append(alpha.getValue());
            }
            if (this.isAlphaOr646ToNumericLatch(this.current.getPosition())) {
              this.current.incrementPosition(3);
              this.current.setNumeric();
            } else if (this.isAlphaTo646ToAlphaLatch(this.current.getPosition())) {
              if (this.current.getPosition() + 5 < this.information.getSize()) {
                this.current.incrementPosition(5);
              } else {
                this.current.setPosition(this.information.getSize());
              }
              this.current.setIsoIec646();
            }
            return new BlockParsedResult(false);
          }
          isStillIsoIec646(pos) {
            if (pos + 5 > this.information.getSize()) {
              return false;
            }
            let fiveBitValue = this.extractNumericValueFromBitArray(pos, 5);
            if (fiveBitValue >= 5 && fiveBitValue < 16) {
              return true;
            }
            if (pos + 7 > this.information.getSize()) {
              return false;
            }
            let sevenBitValue = this.extractNumericValueFromBitArray(pos, 7);
            if (sevenBitValue >= 64 && sevenBitValue < 116) {
              return true;
            }
            if (pos + 8 > this.information.getSize()) {
              return false;
            }
            let eightBitValue = this.extractNumericValueFromBitArray(pos, 8);
            return eightBitValue >= 232 && eightBitValue < 253;
          }
          decodeIsoIec646(pos) {
            let fiveBitValue = this.extractNumericValueFromBitArray(pos, 5);
            if (fiveBitValue === 15) {
              return new DecodedChar(pos + 5, DecodedChar.FNC1);
            }
            if (fiveBitValue >= 5 && fiveBitValue < 15) {
              return new DecodedChar(pos + 5, "0" + (fiveBitValue - 5));
            }
            let sevenBitValue = this.extractNumericValueFromBitArray(pos, 7);
            if (sevenBitValue >= 64 && sevenBitValue < 90) {
              return new DecodedChar(pos + 7, "" + (sevenBitValue + 1));
            }
            if (sevenBitValue >= 90 && sevenBitValue < 116) {
              return new DecodedChar(pos + 7, "" + (sevenBitValue + 7));
            }
            let eightBitValue = this.extractNumericValueFromBitArray(pos, 8);
            let c;
            switch (eightBitValue) {
              case 232:
                c = "!";
                break;
              case 233:
                c = '"';
                break;
              case 234:
                c = "%";
                break;
              case 235:
                c = "&";
                break;
              case 236:
                c = "'";
                break;
              case 237:
                c = "(";
                break;
              case 238:
                c = ")";
                break;
              case 239:
                c = "*";
                break;
              case 240:
                c = "+";
                break;
              case 241:
                c = ",";
                break;
              case 242:
                c = "-";
                break;
              case 243:
                c = ".";
                break;
              case 244:
                c = "/";
                break;
              case 245:
                c = ":";
                break;
              case 246:
                c = ";";
                break;
              case 247:
                c = "<";
                break;
              case 248:
                c = "=";
                break;
              case 249:
                c = ">";
                break;
              case 250:
                c = "?";
                break;
              case 251:
                c = "_";
                break;
              case 252:
                c = " ";
                break;
              default:
                throw new FormatException();
            }
            return new DecodedChar(pos + 8, c);
          }
          isStillAlpha(pos) {
            if (pos + 5 > this.information.getSize()) {
              return false;
            }
            let fiveBitValue = this.extractNumericValueFromBitArray(pos, 5);
            if (fiveBitValue >= 5 && fiveBitValue < 16) {
              return true;
            }
            if (pos + 6 > this.information.getSize()) {
              return false;
            }
            let sixBitValue = this.extractNumericValueFromBitArray(pos, 6);
            return sixBitValue >= 16 && sixBitValue < 63;
          }
          decodeAlphanumeric(pos) {
            let fiveBitValue = this.extractNumericValueFromBitArray(pos, 5);
            if (fiveBitValue === 15) {
              return new DecodedChar(pos + 5, DecodedChar.FNC1);
            }
            if (fiveBitValue >= 5 && fiveBitValue < 15) {
              return new DecodedChar(pos + 5, "0" + (fiveBitValue - 5));
            }
            let sixBitValue = this.extractNumericValueFromBitArray(pos, 6);
            if (sixBitValue >= 32 && sixBitValue < 58) {
              return new DecodedChar(pos + 6, "" + (sixBitValue + 33));
            }
            let c;
            switch (sixBitValue) {
              case 58:
                c = "*";
                break;
              case 59:
                c = ",";
                break;
              case 60:
                c = "-";
                break;
              case 61:
                c = ".";
                break;
              case 62:
                c = "/";
                break;
              default:
                throw new IllegalStateException("Decoding invalid alphanumeric value: " + sixBitValue);
            }
            return new DecodedChar(pos + 6, c);
          }
          isAlphaTo646ToAlphaLatch(pos) {
            if (pos + 1 > this.information.getSize()) {
              return false;
            }
            for (let i = 0; i < 5 && i + pos < this.information.getSize(); ++i) {
              if (i === 2) {
                if (!this.information.get(pos + 2)) {
                  return false;
                }
              } else if (this.information.get(pos + i)) {
                return false;
              }
            }
            return true;
          }
          isAlphaOr646ToNumericLatch(pos) {
            if (pos + 3 > this.information.getSize()) {
              return false;
            }
            for (let i = pos; i < pos + 3; ++i) {
              if (this.information.get(i)) {
                return false;
              }
            }
            return true;
          }
          isNumericToAlphaNumericLatch(pos) {
            if (pos + 1 > this.information.getSize()) {
              return false;
            }
            for (let i = 0; i < 4 && i + pos < this.information.getSize(); ++i) {
              if (this.information.get(pos + i)) {
                return false;
              }
            }
            return true;
          }
        }
        class AbstractExpandedDecoder {
          constructor(information) {
            this.information = information;
            this.generalDecoder = new GeneralAppIdDecoder(information);
          }
          getInformation() {
            return this.information;
          }
          getGeneralDecoder() {
            return this.generalDecoder;
          }
        }
        class AI01decoder extends AbstractExpandedDecoder {
          constructor(information) {
            super(information);
          }
          encodeCompressedGtin(buf, currentPos) {
            buf.append("(01)");
            let initialPosition = buf.length();
            buf.append("9");
            this.encodeCompressedGtinWithoutAI(buf, currentPos, initialPosition);
          }
          encodeCompressedGtinWithoutAI(buf, currentPos, initialBufferPosition) {
            for (let i = 0; i < 4; ++i) {
              let currentBlock = this.getGeneralDecoder().extractNumericValueFromBitArray(currentPos + 10 * i, 10);
              if (currentBlock / 100 === 0) {
                buf.append("0");
              }
              if (currentBlock / 10 === 0) {
                buf.append("0");
              }
              buf.append(currentBlock);
            }
            AI01decoder.appendCheckDigit(buf, initialBufferPosition);
          }
          static appendCheckDigit(buf, currentPos) {
            let checkDigit = 0;
            for (let i = 0; i < 13; i++) {
              let digit = buf.charAt(i + currentPos).charCodeAt(0) - "0".charCodeAt(0);
              checkDigit += (i & 1) === 0 ? 3 * digit : digit;
            }
            checkDigit = 10 - checkDigit % 10;
            if (checkDigit === 10) {
              checkDigit = 0;
            }
            buf.append(checkDigit);
          }
        }
        AI01decoder.GTIN_SIZE = 40;
        class AI01AndOtherAIs extends AI01decoder {
          constructor(information) {
            super(information);
          }
          parseInformation() {
            let buff = new StringBuilder();
            buff.append("(01)");
            let initialGtinPosition = buff.length();
            let firstGtinDigit = this.getGeneralDecoder().extractNumericValueFromBitArray(AI01AndOtherAIs.HEADER_SIZE, 4);
            buff.append(firstGtinDigit);
            this.encodeCompressedGtinWithoutAI(buff, AI01AndOtherAIs.HEADER_SIZE + 4, initialGtinPosition);
            return this.getGeneralDecoder().decodeAllCodes(buff, AI01AndOtherAIs.HEADER_SIZE + 44);
          }
        }
        AI01AndOtherAIs.HEADER_SIZE = 1 + 1 + 2;
        class AnyAIDecoder extends AbstractExpandedDecoder {
          constructor(information) {
            super(information);
          }
          parseInformation() {
            let buf = new StringBuilder();
            return this.getGeneralDecoder().decodeAllCodes(buf, AnyAIDecoder.HEADER_SIZE);
          }
        }
        AnyAIDecoder.HEADER_SIZE = 2 + 1 + 2;
        class AI01weightDecoder extends AI01decoder {
          constructor(information) {
            super(information);
          }
          encodeCompressedWeight(buf, currentPos, weightSize) {
            let originalWeightNumeric = this.getGeneralDecoder().extractNumericValueFromBitArray(currentPos, weightSize);
            this.addWeightCode(buf, originalWeightNumeric);
            let weightNumeric = this.checkWeight(originalWeightNumeric);
            let currentDivisor = 1e5;
            for (let i = 0; i < 5; ++i) {
              if (weightNumeric / currentDivisor === 0) {
                buf.append("0");
              }
              currentDivisor /= 10;
            }
            buf.append(weightNumeric);
          }
        }
        class AI013x0xDecoder extends AI01weightDecoder {
          constructor(information) {
            super(information);
          }
          parseInformation() {
            if (this.getInformation().getSize() != AI013x0xDecoder.HEADER_SIZE + AI01weightDecoder.GTIN_SIZE + AI013x0xDecoder.WEIGHT_SIZE) {
              throw new NotFoundException();
            }
            let buf = new StringBuilder();
            this.encodeCompressedGtin(buf, AI013x0xDecoder.HEADER_SIZE);
            this.encodeCompressedWeight(buf, AI013x0xDecoder.HEADER_SIZE + AI01weightDecoder.GTIN_SIZE, AI013x0xDecoder.WEIGHT_SIZE);
            return buf.toString();
          }
        }
        AI013x0xDecoder.HEADER_SIZE = 4 + 1;
        AI013x0xDecoder.WEIGHT_SIZE = 15;
        class AI013103decoder extends AI013x0xDecoder {
          constructor(information) {
            super(information);
          }
          addWeightCode(buf, weight) {
            buf.append("(3103)");
          }
          checkWeight(weight) {
            return weight;
          }
        }
        class AI01320xDecoder extends AI013x0xDecoder {
          constructor(information) {
            super(information);
          }
          addWeightCode(buf, weight) {
            if (weight < 1e4) {
              buf.append("(3202)");
            } else {
              buf.append("(3203)");
            }
          }
          checkWeight(weight) {
            if (weight < 1e4) {
              return weight;
            }
            return weight - 1e4;
          }
        }
        class AI01392xDecoder extends AI01decoder {
          constructor(information) {
            super(information);
          }
          parseInformation() {
            if (this.getInformation().getSize() < AI01392xDecoder.HEADER_SIZE + AI01decoder.GTIN_SIZE) {
              throw new NotFoundException();
            }
            let buf = new StringBuilder();
            this.encodeCompressedGtin(buf, AI01392xDecoder.HEADER_SIZE);
            let lastAIdigit = this.getGeneralDecoder().extractNumericValueFromBitArray(AI01392xDecoder.HEADER_SIZE + AI01decoder.GTIN_SIZE, AI01392xDecoder.LAST_DIGIT_SIZE);
            buf.append("(392");
            buf.append(lastAIdigit);
            buf.append(")");
            let decodedInformation = this.getGeneralDecoder().decodeGeneralPurposeField(AI01392xDecoder.HEADER_SIZE + AI01decoder.GTIN_SIZE + AI01392xDecoder.LAST_DIGIT_SIZE, null);
            buf.append(decodedInformation.getNewString());
            return buf.toString();
          }
        }
        AI01392xDecoder.HEADER_SIZE = 5 + 1 + 2;
        AI01392xDecoder.LAST_DIGIT_SIZE = 2;
        class AI01393xDecoder extends AI01decoder {
          constructor(information) {
            super(information);
          }
          parseInformation() {
            if (this.getInformation().getSize() < AI01393xDecoder.HEADER_SIZE + AI01decoder.GTIN_SIZE) {
              throw new NotFoundException();
            }
            let buf = new StringBuilder();
            this.encodeCompressedGtin(buf, AI01393xDecoder.HEADER_SIZE);
            let lastAIdigit = this.getGeneralDecoder().extractNumericValueFromBitArray(AI01393xDecoder.HEADER_SIZE + AI01decoder.GTIN_SIZE, AI01393xDecoder.LAST_DIGIT_SIZE);
            buf.append("(393");
            buf.append(lastAIdigit);
            buf.append(")");
            let firstThreeDigits = this.getGeneralDecoder().extractNumericValueFromBitArray(AI01393xDecoder.HEADER_SIZE + AI01decoder.GTIN_SIZE + AI01393xDecoder.LAST_DIGIT_SIZE, AI01393xDecoder.FIRST_THREE_DIGITS_SIZE);
            if (firstThreeDigits / 100 == 0) {
              buf.append("0");
            }
            if (firstThreeDigits / 10 == 0) {
              buf.append("0");
            }
            buf.append(firstThreeDigits);
            let generalInformation = this.getGeneralDecoder().decodeGeneralPurposeField(AI01393xDecoder.HEADER_SIZE + AI01decoder.GTIN_SIZE + AI01393xDecoder.LAST_DIGIT_SIZE + AI01393xDecoder.FIRST_THREE_DIGITS_SIZE, null);
            buf.append(generalInformation.getNewString());
            return buf.toString();
          }
        }
        AI01393xDecoder.HEADER_SIZE = 5 + 1 + 2;
        AI01393xDecoder.LAST_DIGIT_SIZE = 2;
        AI01393xDecoder.FIRST_THREE_DIGITS_SIZE = 10;
        class AI013x0x1xDecoder extends AI01weightDecoder {
          constructor(information, firstAIdigits, dateCode) {
            super(information);
            this.dateCode = dateCode;
            this.firstAIdigits = firstAIdigits;
          }
          parseInformation() {
            if (this.getInformation().getSize() != AI013x0x1xDecoder.HEADER_SIZE + AI013x0x1xDecoder.GTIN_SIZE + AI013x0x1xDecoder.WEIGHT_SIZE + AI013x0x1xDecoder.DATE_SIZE) {
              throw new NotFoundException();
            }
            let buf = new StringBuilder();
            this.encodeCompressedGtin(buf, AI013x0x1xDecoder.HEADER_SIZE);
            this.encodeCompressedWeight(buf, AI013x0x1xDecoder.HEADER_SIZE + AI013x0x1xDecoder.GTIN_SIZE, AI013x0x1xDecoder.WEIGHT_SIZE);
            this.encodeCompressedDate(buf, AI013x0x1xDecoder.HEADER_SIZE + AI013x0x1xDecoder.GTIN_SIZE + AI013x0x1xDecoder.WEIGHT_SIZE);
            return buf.toString();
          }
          encodeCompressedDate(buf, currentPos) {
            let numericDate = this.getGeneralDecoder().extractNumericValueFromBitArray(currentPos, AI013x0x1xDecoder.DATE_SIZE);
            if (numericDate == 38400) {
              return;
            }
            buf.append("(");
            buf.append(this.dateCode);
            buf.append(")");
            let day = numericDate % 32;
            numericDate /= 32;
            let month = numericDate % 12 + 1;
            numericDate /= 12;
            let year = numericDate;
            if (year / 10 == 0) {
              buf.append("0");
            }
            buf.append(year);
            if (month / 10 == 0) {
              buf.append("0");
            }
            buf.append(month);
            if (day / 10 == 0) {
              buf.append("0");
            }
            buf.append(day);
          }
          addWeightCode(buf, weight) {
            buf.append("(");
            buf.append(this.firstAIdigits);
            buf.append(weight / 1e5);
            buf.append(")");
          }
          checkWeight(weight) {
            return weight % 1e5;
          }
        }
        AI013x0x1xDecoder.HEADER_SIZE = 7 + 1;
        AI013x0x1xDecoder.WEIGHT_SIZE = 20;
        AI013x0x1xDecoder.DATE_SIZE = 16;
        function createDecoder(information) {
          try {
            if (information.get(1)) {
              return new AI01AndOtherAIs(information);
            }
            if (!information.get(2)) {
              return new AnyAIDecoder(information);
            }
            let fourBitEncodationMethod = GeneralAppIdDecoder.extractNumericValueFromBitArray(information, 1, 4);
            switch (fourBitEncodationMethod) {
              case 4:
                return new AI013103decoder(information);
              case 5:
                return new AI01320xDecoder(information);
            }
            let fiveBitEncodationMethod = GeneralAppIdDecoder.extractNumericValueFromBitArray(information, 1, 5);
            switch (fiveBitEncodationMethod) {
              case 12:
                return new AI01392xDecoder(information);
              case 13:
                return new AI01393xDecoder(information);
            }
            let sevenBitEncodationMethod = GeneralAppIdDecoder.extractNumericValueFromBitArray(information, 1, 7);
            switch (sevenBitEncodationMethod) {
              case 56:
                return new AI013x0x1xDecoder(information, "310", "11");
              case 57:
                return new AI013x0x1xDecoder(information, "320", "11");
              case 58:
                return new AI013x0x1xDecoder(information, "310", "13");
              case 59:
                return new AI013x0x1xDecoder(information, "320", "13");
              case 60:
                return new AI013x0x1xDecoder(information, "310", "15");
              case 61:
                return new AI013x0x1xDecoder(information, "320", "15");
              case 62:
                return new AI013x0x1xDecoder(information, "310", "17");
              case 63:
                return new AI013x0x1xDecoder(information, "320", "17");
            }
          } catch (e) {
            console.log(e);
            throw new IllegalStateException("unknown decoder: " + information);
          }
        }
        class ExpandedPair {
          constructor(leftChar, rightChar, finderPatter, mayBeLast) {
            this.leftchar = leftChar;
            this.rightchar = rightChar;
            this.finderpattern = finderPatter;
            this.maybeLast = mayBeLast;
          }
          mayBeLast() {
            return this.maybeLast;
          }
          getLeftChar() {
            return this.leftchar;
          }
          getRightChar() {
            return this.rightchar;
          }
          getFinderPattern() {
            return this.finderpattern;
          }
          mustBeLast() {
            return this.rightchar == null;
          }
          toString() {
            return "[ " + this.leftchar + ", " + this.rightchar + " : " + (this.finderpattern == null ? "null" : this.finderpattern.getValue()) + " ]";
          }
          static equals(o1, o2) {
            if (!(o1 instanceof ExpandedPair)) {
              return false;
            }
            return ExpandedPair.equalsOrNull(o1.leftchar, o2.leftchar) && ExpandedPair.equalsOrNull(o1.rightchar, o2.rightchar) && ExpandedPair.equalsOrNull(o1.finderpattern, o2.finderpattern);
          }
          static equalsOrNull(o1, o2) {
            return o1 === null ? o2 === null : ExpandedPair.equals(o1, o2);
          }
          hashCode() {
            let value = this.leftchar.getValue() ^ this.rightchar.getValue() ^ this.finderpattern.getValue();
            return value;
          }
        }
        class ExpandedRow {
          constructor(pairs, rowNumber, wasReversed) {
            this.pairs = pairs;
            this.rowNumber = rowNumber;
            this.wasReversed = wasReversed;
          }
          getPairs() {
            return this.pairs;
          }
          getRowNumber() {
            return this.rowNumber;
          }
          isReversed() {
            return this.wasReversed;
          }
          isEquivalent(otherPairs) {
            return this.checkEqualitity(this, otherPairs);
          }
          toString() {
            return "{ " + this.pairs + " }";
          }
          equals(o1, o2) {
            if (!(o1 instanceof ExpandedRow)) {
              return false;
            }
            return this.checkEqualitity(o1, o2) && o1.wasReversed === o2.wasReversed;
          }
          checkEqualitity(pair1, pair2) {
            if (!pair1 || !pair2)
              return;
            let result;
            pair1.forEach((e1, i) => {
              pair2.forEach((e2) => {
                if (e1.getLeftChar().getValue() === e2.getLeftChar().getValue() && e1.getRightChar().getValue() === e2.getRightChar().getValue() && e1.getFinderPatter().getValue() === e2.getFinderPatter().getValue()) {
                  result = true;
                }
              });
            });
            return result;
          }
        }
        class RSSExpandedReader extends AbstractRSSReader {
          constructor(verbose) {
            super(...arguments);
            this.pairs = new Array(RSSExpandedReader.MAX_PAIRS);
            this.rows = new Array();
            this.startEnd = [2];
            this.verbose = verbose === true;
          }
          decodeRow(rowNumber, row, hints) {
            this.pairs.length = 0;
            this.startFromEven = false;
            try {
              return RSSExpandedReader.constructResult(this.decodeRow2pairs(rowNumber, row));
            } catch (e) {
              if (this.verbose) {
                console.log(e);
              }
            }
            this.pairs.length = 0;
            this.startFromEven = true;
            return RSSExpandedReader.constructResult(this.decodeRow2pairs(rowNumber, row));
          }
          reset() {
            this.pairs.length = 0;
            this.rows.length = 0;
          }
          decodeRow2pairs(rowNumber, row) {
            let done = false;
            while (!done) {
              try {
                this.pairs.push(this.retrieveNextPair(row, this.pairs, rowNumber));
              } catch (error2) {
                if (error2 instanceof NotFoundException) {
                  if (!this.pairs.length) {
                    throw new NotFoundException();
                  }
                  done = true;
                }
              }
            }
            if (this.checkChecksum()) {
              return this.pairs;
            }
            let tryStackedDecode;
            if (this.rows.length) {
              tryStackedDecode = true;
            } else {
              tryStackedDecode = false;
            }
            this.storeRow(rowNumber, false);
            if (tryStackedDecode) {
              let ps = this.checkRowsBoolean(false);
              if (ps != null) {
                return ps;
              }
              ps = this.checkRowsBoolean(true);
              if (ps != null) {
                return ps;
              }
            }
            throw new NotFoundException();
          }
          checkRowsBoolean(reverse) {
            if (this.rows.length > 25) {
              this.rows.length = 0;
              return null;
            }
            this.pairs.length = 0;
            if (reverse) {
              this.rows = this.rows.reverse();
            }
            let ps = null;
            try {
              ps = this.checkRows(new Array(), 0);
            } catch (e) {
              if (this.verbose) {
                console.log(e);
              }
            }
            if (reverse) {
              this.rows = this.rows.reverse();
            }
            return ps;
          }
          checkRows(collectedRows, currentRow) {
            for (let i = currentRow; i < this.rows.length; i++) {
              let row = this.rows[i];
              this.pairs.length = 0;
              for (let collectedRow of collectedRows) {
                this.pairs.push(collectedRow.getPairs());
              }
              this.pairs.push(row.getPairs());
              if (!RSSExpandedReader.isValidSequence(this.pairs)) {
                continue;
              }
              if (this.checkChecksum()) {
                return this.pairs;
              }
              let rs = new Array(collectedRows);
              rs.push(row);
              try {
                return this.checkRows(rs, i + 1);
              } catch (e) {
                if (this.verbose) {
                  console.log(e);
                }
              }
            }
            throw new NotFoundException();
          }
          static isValidSequence(pairs) {
            for (let sequence of RSSExpandedReader.FINDER_PATTERN_SEQUENCES) {
              if (pairs.length > sequence.length) {
                continue;
              }
              let stop2 = true;
              for (let j = 0; j < pairs.length; j++) {
                if (pairs[j].getFinderPattern().getValue() != sequence[j]) {
                  stop2 = false;
                  break;
                }
              }
              if (stop2) {
                return true;
              }
            }
            return false;
          }
          storeRow(rowNumber, wasReversed) {
            let insertPos = 0;
            let prevIsSame = false;
            let nextIsSame = false;
            while (insertPos < this.rows.length) {
              let erow = this.rows[insertPos];
              if (erow.getRowNumber() > rowNumber) {
                nextIsSame = erow.isEquivalent(this.pairs);
                break;
              }
              prevIsSame = erow.isEquivalent(this.pairs);
              insertPos++;
            }
            if (nextIsSame || prevIsSame) {
              return;
            }
            if (RSSExpandedReader.isPartialRow(this.pairs, this.rows)) {
              return;
            }
            this.rows.push(insertPos, new ExpandedRow(this.pairs, rowNumber, wasReversed));
            this.removePartialRows(this.pairs, this.rows);
          }
          removePartialRows(pairs, rows) {
            for (let row of rows) {
              if (row.getPairs().length === pairs.length) {
                continue;
              }
              for (let p of row.getPairs()) {
                for (let pp of pairs) {
                  if (ExpandedPair.equals(p, pp)) {
                    break;
                  }
                }
              }
            }
          }
          static isPartialRow(pairs, rows) {
            for (let r of rows) {
              let allFound = true;
              for (let p of pairs) {
                let found = false;
                for (let pp of r.getPairs()) {
                  if (p.equals(pp)) {
                    found = true;
                    break;
                  }
                }
                if (!found) {
                  allFound = false;
                  break;
                }
              }
              if (allFound) {
                return true;
              }
            }
            return false;
          }
          getRows() {
            return this.rows;
          }
          static constructResult(pairs) {
            let binary = BitArrayBuilder.buildBitArray(pairs);
            let decoder = createDecoder(binary);
            let resultingString = decoder.parseInformation();
            let firstPoints = pairs[0].getFinderPattern().getResultPoints();
            let lastPoints = pairs[pairs.length - 1].getFinderPattern().getResultPoints();
            let points = [firstPoints[0], firstPoints[1], lastPoints[0], lastPoints[1]];
            return new Result(resultingString, null, null, points, BarcodeFormat$1.RSS_EXPANDED, null);
          }
          checkChecksum() {
            let firstPair = this.pairs.get(0);
            let checkCharacter = firstPair.getLeftChar();
            let firstCharacter = firstPair.getRightChar();
            if (firstCharacter == null) {
              return false;
            }
            let checksum = firstCharacter.getChecksumPortion();
            let s = 2;
            for (let i = 1; i < this.pairs.size(); ++i) {
              let currentPair = this.pairs.get(i);
              checksum += currentPair.getLeftChar().getChecksumPortion();
              s++;
              let currentRightChar = currentPair.getRightChar();
              if (currentRightChar != null) {
                checksum += currentRightChar.getChecksumPortion();
                s++;
              }
            }
            checksum %= 211;
            let checkCharacterValue = 211 * (s - 4) + checksum;
            return checkCharacterValue == checkCharacter.getValue();
          }
          static getNextSecondBar(row, initialPos) {
            let currentPos;
            if (row.get(initialPos)) {
              currentPos = row.getNextUnset(initialPos);
              currentPos = row.getNextSet(currentPos);
            } else {
              currentPos = row.getNextSet(initialPos);
              currentPos = row.getNextUnset(currentPos);
            }
            return currentPos;
          }
          retrieveNextPair(row, previousPairs, rowNumber) {
            let isOddPattern = previousPairs.length % 2 == 0;
            if (this.startFromEven) {
              isOddPattern = !isOddPattern;
            }
            let pattern;
            let keepFinding = true;
            let forcedOffset = -1;
            do {
              this.findNextPair(row, previousPairs, forcedOffset);
              pattern = this.parseFoundFinderPattern(row, rowNumber, isOddPattern);
              if (pattern == null) {
                forcedOffset = RSSExpandedReader.getNextSecondBar(row, this.startEnd[0]);
              } else {
                keepFinding = false;
              }
            } while (keepFinding);
            let leftChar = this.decodeDataCharacter(row, pattern, isOddPattern, true);
            if (!this.isEmptyPair(previousPairs) && previousPairs[previousPairs.length - 1].mustBeLast()) {
              throw new NotFoundException();
            }
            let rightChar;
            try {
              rightChar = this.decodeDataCharacter(row, pattern, isOddPattern, false);
            } catch (e) {
              rightChar = null;
              if (this.verbose) {
                console.log(e);
              }
            }
            return new ExpandedPair(leftChar, rightChar, pattern, true);
          }
          isEmptyPair(pairs) {
            if (pairs.length === 0) {
              return true;
            }
            return false;
          }
          findNextPair(row, previousPairs, forcedOffset) {
            let counters = this.getDecodeFinderCounters();
            counters[0] = 0;
            counters[1] = 0;
            counters[2] = 0;
            counters[3] = 0;
            let width = row.getSize();
            let rowOffset;
            if (forcedOffset >= 0) {
              rowOffset = forcedOffset;
            } else if (this.isEmptyPair(previousPairs)) {
              rowOffset = 0;
            } else {
              let lastPair = previousPairs[previousPairs.length - 1];
              rowOffset = lastPair.getFinderPattern().getStartEnd()[1];
            }
            let searchingEvenPair = previousPairs.length % 2 != 0;
            if (this.startFromEven) {
              searchingEvenPair = !searchingEvenPair;
            }
            let isWhite = false;
            while (rowOffset < width) {
              isWhite = !row.get(rowOffset);
              if (!isWhite) {
                break;
              }
              rowOffset++;
            }
            let counterPosition = 0;
            let patternStart = rowOffset;
            for (let x = rowOffset; x < width; x++) {
              if (row.get(x) != isWhite) {
                counters[counterPosition]++;
              } else {
                if (counterPosition == 3) {
                  if (searchingEvenPair) {
                    RSSExpandedReader.reverseCounters(counters);
                  }
                  if (RSSExpandedReader.isFinderPattern(counters)) {
                    this.startEnd[0] = patternStart;
                    this.startEnd[1] = x;
                    return;
                  }
                  if (searchingEvenPair) {
                    RSSExpandedReader.reverseCounters(counters);
                  }
                  patternStart += counters[0] + counters[1];
                  counters[0] = counters[2];
                  counters[1] = counters[3];
                  counters[2] = 0;
                  counters[3] = 0;
                  counterPosition--;
                } else {
                  counterPosition++;
                }
                counters[counterPosition] = 1;
                isWhite = !isWhite;
              }
            }
            throw new NotFoundException();
          }
          static reverseCounters(counters) {
            let length = counters.length;
            for (let i = 0; i < length / 2; ++i) {
              let tmp = counters[i];
              counters[i] = counters[length - i - 1];
              counters[length - i - 1] = tmp;
            }
          }
          parseFoundFinderPattern(row, rowNumber, oddPattern) {
            let firstCounter;
            let start2;
            let end;
            if (oddPattern) {
              let firstElementStart = this.startEnd[0] - 1;
              while (firstElementStart >= 0 && !row.get(firstElementStart)) {
                firstElementStart--;
              }
              firstElementStart++;
              firstCounter = this.startEnd[0] - firstElementStart;
              start2 = firstElementStart;
              end = this.startEnd[1];
            } else {
              start2 = this.startEnd[0];
              end = row.getNextUnset(this.startEnd[1] + 1);
              firstCounter = end - this.startEnd[1];
            }
            let counters = this.getDecodeFinderCounters();
            System.arraycopy(counters, 0, counters, 1, counters.length - 1);
            counters[0] = firstCounter;
            let value;
            try {
              value = this.parseFinderValue(counters, RSSExpandedReader.FINDER_PATTERNS);
            } catch (e) {
              return null;
            }
            return new FinderPattern(value, [start2, end], start2, end, rowNumber);
          }
          decodeDataCharacter(row, pattern, isOddPattern, leftChar) {
            let counters = this.getDataCharacterCounters();
            for (let x = 0; x < counters.length; x++) {
              counters[x] = 0;
            }
            if (leftChar) {
              RSSExpandedReader.recordPatternInReverse(row, pattern.getStartEnd()[0], counters);
            } else {
              RSSExpandedReader.recordPattern(row, pattern.getStartEnd()[1], counters);
              for (let i = 0, j = counters.length - 1; i < j; i++, j--) {
                let temp = counters[i];
                counters[i] = counters[j];
                counters[j] = temp;
              }
            }
            let numModules = 17;
            let elementWidth = MathUtils.sum(new Int32Array(counters)) / numModules;
            let expectedElementWidth = (pattern.getStartEnd()[1] - pattern.getStartEnd()[0]) / 15;
            if (Math.abs(elementWidth - expectedElementWidth) / expectedElementWidth > 0.3) {
              throw new NotFoundException();
            }
            let oddCounts = this.getOddCounts();
            let evenCounts = this.getEvenCounts();
            let oddRoundingErrors = this.getOddRoundingErrors();
            let evenRoundingErrors = this.getEvenRoundingErrors();
            for (let i = 0; i < counters.length; i++) {
              let value2 = 1 * counters[i] / elementWidth;
              let count = value2 + 0.5;
              if (count < 1) {
                if (value2 < 0.3) {
                  throw new NotFoundException();
                }
                count = 1;
              } else if (count > 8) {
                if (value2 > 8.7) {
                  throw new NotFoundException();
                }
                count = 8;
              }
              let offset = i / 2;
              if ((i & 1) == 0) {
                oddCounts[offset] = count;
                oddRoundingErrors[offset] = value2 - count;
              } else {
                evenCounts[offset] = count;
                evenRoundingErrors[offset] = value2 - count;
              }
            }
            this.adjustOddEvenCounts(numModules);
            let weightRowNumber = 4 * pattern.getValue() + (isOddPattern ? 0 : 2) + (leftChar ? 0 : 1) - 1;
            let oddSum = 0;
            let oddChecksumPortion = 0;
            for (let i = oddCounts.length - 1; i >= 0; i--) {
              if (RSSExpandedReader.isNotA1left(pattern, isOddPattern, leftChar)) {
                let weight = RSSExpandedReader.WEIGHTS[weightRowNumber][2 * i];
                oddChecksumPortion += oddCounts[i] * weight;
              }
              oddSum += oddCounts[i];
            }
            let evenChecksumPortion = 0;
            for (let i = evenCounts.length - 1; i >= 0; i--) {
              if (RSSExpandedReader.isNotA1left(pattern, isOddPattern, leftChar)) {
                let weight = RSSExpandedReader.WEIGHTS[weightRowNumber][2 * i + 1];
                evenChecksumPortion += evenCounts[i] * weight;
              }
            }
            let checksumPortion = oddChecksumPortion + evenChecksumPortion;
            if ((oddSum & 1) != 0 || oddSum > 13 || oddSum < 4) {
              throw new NotFoundException();
            }
            let group = (13 - oddSum) / 2;
            let oddWidest = RSSExpandedReader.SYMBOL_WIDEST[group];
            let evenWidest = 9 - oddWidest;
            let vOdd = RSSUtils.getRSSvalue(oddCounts, oddWidest, true);
            let vEven = RSSUtils.getRSSvalue(evenCounts, evenWidest, false);
            let tEven = RSSExpandedReader.EVEN_TOTAL_SUBSET[group];
            let gSum = RSSExpandedReader.GSUM[group];
            let value = vOdd * tEven + vEven + gSum;
            return new DataCharacter(value, checksumPortion);
          }
          static isNotA1left(pattern, isOddPattern, leftChar) {
            return !(pattern.getValue() == 0 && isOddPattern && leftChar);
          }
          adjustOddEvenCounts(numModules) {
            let oddSum = MathUtils.sum(new Int32Array(this.getOddCounts()));
            let evenSum = MathUtils.sum(new Int32Array(this.getEvenCounts()));
            let incrementOdd = false;
            let decrementOdd = false;
            if (oddSum > 13) {
              decrementOdd = true;
            } else if (oddSum < 4) {
              incrementOdd = true;
            }
            let incrementEven = false;
            let decrementEven = false;
            if (evenSum > 13) {
              decrementEven = true;
            } else if (evenSum < 4) {
              incrementEven = true;
            }
            let mismatch = oddSum + evenSum - numModules;
            let oddParityBad = (oddSum & 1) == 1;
            let evenParityBad = (evenSum & 1) == 0;
            if (mismatch == 1) {
              if (oddParityBad) {
                if (evenParityBad) {
                  throw new NotFoundException();
                }
                decrementOdd = true;
              } else {
                if (!evenParityBad) {
                  throw new NotFoundException();
                }
                decrementEven = true;
              }
            } else if (mismatch == -1) {
              if (oddParityBad) {
                if (evenParityBad) {
                  throw new NotFoundException();
                }
                incrementOdd = true;
              } else {
                if (!evenParityBad) {
                  throw new NotFoundException();
                }
                incrementEven = true;
              }
            } else if (mismatch == 0) {
              if (oddParityBad) {
                if (!evenParityBad) {
                  throw new NotFoundException();
                }
                if (oddSum < evenSum) {
                  incrementOdd = true;
                  decrementEven = true;
                } else {
                  decrementOdd = true;
                  incrementEven = true;
                }
              } else {
                if (evenParityBad) {
                  throw new NotFoundException();
                }
              }
            } else {
              throw new NotFoundException();
            }
            if (incrementOdd) {
              if (decrementOdd) {
                throw new NotFoundException();
              }
              RSSExpandedReader.increment(this.getOddCounts(), this.getOddRoundingErrors());
            }
            if (decrementOdd) {
              RSSExpandedReader.decrement(this.getOddCounts(), this.getOddRoundingErrors());
            }
            if (incrementEven) {
              if (decrementEven) {
                throw new NotFoundException();
              }
              RSSExpandedReader.increment(this.getEvenCounts(), this.getOddRoundingErrors());
            }
            if (decrementEven) {
              RSSExpandedReader.decrement(this.getEvenCounts(), this.getEvenRoundingErrors());
            }
          }
        }
        RSSExpandedReader.SYMBOL_WIDEST = [7, 5, 4, 3, 1];
        RSSExpandedReader.EVEN_TOTAL_SUBSET = [4, 20, 52, 104, 204];
        RSSExpandedReader.GSUM = [0, 348, 1388, 2948, 3988];
        RSSExpandedReader.FINDER_PATTERNS = [
          Int32Array.from([1, 8, 4, 1]),
          Int32Array.from([3, 6, 4, 1]),
          Int32Array.from([3, 4, 6, 1]),
          Int32Array.from([3, 2, 8, 1]),
          Int32Array.from([2, 6, 5, 1]),
          Int32Array.from([2, 2, 9, 1])
        ];
        RSSExpandedReader.WEIGHTS = [
          [1, 3, 9, 27, 81, 32, 96, 77],
          [20, 60, 180, 118, 143, 7, 21, 63],
          [189, 145, 13, 39, 117, 140, 209, 205],
          [193, 157, 49, 147, 19, 57, 171, 91],
          [62, 186, 136, 197, 169, 85, 44, 132],
          [185, 133, 188, 142, 4, 12, 36, 108],
          [113, 128, 173, 97, 80, 29, 87, 50],
          [150, 28, 84, 41, 123, 158, 52, 156],
          [46, 138, 203, 187, 139, 206, 196, 166],
          [76, 17, 51, 153, 37, 111, 122, 155],
          [43, 129, 176, 106, 107, 110, 119, 146],
          [16, 48, 144, 10, 30, 90, 59, 177],
          [109, 116, 137, 200, 178, 112, 125, 164],
          [70, 210, 208, 202, 184, 130, 179, 115],
          [134, 191, 151, 31, 93, 68, 204, 190],
          [148, 22, 66, 198, 172, 94, 71, 2],
          [6, 18, 54, 162, 64, 192, 154, 40],
          [120, 149, 25, 75, 14, 42, 126, 167],
          [79, 26, 78, 23, 69, 207, 199, 175],
          [103, 98, 83, 38, 114, 131, 182, 124],
          [161, 61, 183, 127, 170, 88, 53, 159],
          [55, 165, 73, 8, 24, 72, 5, 15],
          [45, 135, 194, 160, 58, 174, 100, 89]
        ];
        RSSExpandedReader.FINDER_PAT_A = 0;
        RSSExpandedReader.FINDER_PAT_B = 1;
        RSSExpandedReader.FINDER_PAT_C = 2;
        RSSExpandedReader.FINDER_PAT_D = 3;
        RSSExpandedReader.FINDER_PAT_E = 4;
        RSSExpandedReader.FINDER_PAT_F = 5;
        RSSExpandedReader.FINDER_PATTERN_SEQUENCES = [
          [RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_A],
          [RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_B, RSSExpandedReader.FINDER_PAT_B],
          [RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_C, RSSExpandedReader.FINDER_PAT_B, RSSExpandedReader.FINDER_PAT_D],
          [RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_E, RSSExpandedReader.FINDER_PAT_B, RSSExpandedReader.FINDER_PAT_D, RSSExpandedReader.FINDER_PAT_C],
          [RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_E, RSSExpandedReader.FINDER_PAT_B, RSSExpandedReader.FINDER_PAT_D, RSSExpandedReader.FINDER_PAT_D, RSSExpandedReader.FINDER_PAT_F],
          [RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_E, RSSExpandedReader.FINDER_PAT_B, RSSExpandedReader.FINDER_PAT_D, RSSExpandedReader.FINDER_PAT_E, RSSExpandedReader.FINDER_PAT_F, RSSExpandedReader.FINDER_PAT_F],
          [RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_B, RSSExpandedReader.FINDER_PAT_B, RSSExpandedReader.FINDER_PAT_C, RSSExpandedReader.FINDER_PAT_C, RSSExpandedReader.FINDER_PAT_D, RSSExpandedReader.FINDER_PAT_D],
          [RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_B, RSSExpandedReader.FINDER_PAT_B, RSSExpandedReader.FINDER_PAT_C, RSSExpandedReader.FINDER_PAT_C, RSSExpandedReader.FINDER_PAT_D, RSSExpandedReader.FINDER_PAT_E, RSSExpandedReader.FINDER_PAT_E],
          [RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_B, RSSExpandedReader.FINDER_PAT_B, RSSExpandedReader.FINDER_PAT_C, RSSExpandedReader.FINDER_PAT_C, RSSExpandedReader.FINDER_PAT_D, RSSExpandedReader.FINDER_PAT_E, RSSExpandedReader.FINDER_PAT_F, RSSExpandedReader.FINDER_PAT_F],
          [RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_B, RSSExpandedReader.FINDER_PAT_B, RSSExpandedReader.FINDER_PAT_C, RSSExpandedReader.FINDER_PAT_D, RSSExpandedReader.FINDER_PAT_D, RSSExpandedReader.FINDER_PAT_E, RSSExpandedReader.FINDER_PAT_E, RSSExpandedReader.FINDER_PAT_F, RSSExpandedReader.FINDER_PAT_F]
        ];
        RSSExpandedReader.MAX_PAIRS = 11;
        class Pair extends DataCharacter {
          constructor(value, checksumPortion, finderPattern) {
            super(value, checksumPortion);
            this.count = 0;
            this.finderPattern = finderPattern;
          }
          getFinderPattern() {
            return this.finderPattern;
          }
          getCount() {
            return this.count;
          }
          incrementCount() {
            this.count++;
          }
        }
        class RSS14Reader extends AbstractRSSReader {
          constructor() {
            super(...arguments);
            this.possibleLeftPairs = [];
            this.possibleRightPairs = [];
          }
          decodeRow(rowNumber, row, hints) {
            const leftPair = this.decodePair(row, false, rowNumber, hints);
            RSS14Reader.addOrTally(this.possibleLeftPairs, leftPair);
            row.reverse();
            let rightPair = this.decodePair(row, true, rowNumber, hints);
            RSS14Reader.addOrTally(this.possibleRightPairs, rightPair);
            row.reverse();
            for (let left of this.possibleLeftPairs) {
              if (left.getCount() > 1) {
                for (let right of this.possibleRightPairs) {
                  if (right.getCount() > 1 && RSS14Reader.checkChecksum(left, right)) {
                    return RSS14Reader.constructResult(left, right);
                  }
                }
              }
            }
            throw new NotFoundException();
          }
          static addOrTally(possiblePairs, pair) {
            if (pair == null) {
              return;
            }
            let found = false;
            for (let other of possiblePairs) {
              if (other.getValue() === pair.getValue()) {
                other.incrementCount();
                found = true;
                break;
              }
            }
            if (!found) {
              possiblePairs.push(pair);
            }
          }
          reset() {
            this.possibleLeftPairs.length = 0;
            this.possibleRightPairs.length = 0;
          }
          static constructResult(leftPair, rightPair) {
            let symbolValue = 4537077 * leftPair.getValue() + rightPair.getValue();
            let text = new String(symbolValue).toString();
            let buffer = new StringBuilder();
            for (let i = 13 - text.length; i > 0; i--) {
              buffer.append("0");
            }
            buffer.append(text);
            let checkDigit = 0;
            for (let i = 0; i < 13; i++) {
              let digit = buffer.charAt(i).charCodeAt(0) - "0".charCodeAt(0);
              checkDigit += (i & 1) === 0 ? 3 * digit : digit;
            }
            checkDigit = 10 - checkDigit % 10;
            if (checkDigit === 10) {
              checkDigit = 0;
            }
            buffer.append(checkDigit.toString());
            let leftPoints = leftPair.getFinderPattern().getResultPoints();
            let rightPoints = rightPair.getFinderPattern().getResultPoints();
            return new Result(buffer.toString(), null, 0, [leftPoints[0], leftPoints[1], rightPoints[0], rightPoints[1]], BarcodeFormat$1.RSS_14, new Date().getTime());
          }
          static checkChecksum(leftPair, rightPair) {
            let checkValue = (leftPair.getChecksumPortion() + 16 * rightPair.getChecksumPortion()) % 79;
            let targetCheckValue = 9 * leftPair.getFinderPattern().getValue() + rightPair.getFinderPattern().getValue();
            if (targetCheckValue > 72) {
              targetCheckValue--;
            }
            if (targetCheckValue > 8) {
              targetCheckValue--;
            }
            return checkValue === targetCheckValue;
          }
          decodePair(row, right, rowNumber, hints) {
            try {
              let startEnd = this.findFinderPattern(row, right);
              let pattern = this.parseFoundFinderPattern(row, rowNumber, right, startEnd);
              let resultPointCallback = hints == null ? null : hints.get(DecodeHintType$1.NEED_RESULT_POINT_CALLBACK);
              if (resultPointCallback != null) {
                let center = (startEnd[0] + startEnd[1]) / 2;
                if (right) {
                  center = row.getSize() - 1 - center;
                }
                resultPointCallback.foundPossibleResultPoint(new ResultPoint(center, rowNumber));
              }
              let outside = this.decodeDataCharacter(row, pattern, true);
              let inside = this.decodeDataCharacter(row, pattern, false);
              return new Pair(1597 * outside.getValue() + inside.getValue(), outside.getChecksumPortion() + 4 * inside.getChecksumPortion(), pattern);
            } catch (err) {
              return null;
            }
          }
          decodeDataCharacter(row, pattern, outsideChar) {
            let counters = this.getDataCharacterCounters();
            for (let x = 0; x < counters.length; x++) {
              counters[x] = 0;
            }
            if (outsideChar) {
              OneDReader.recordPatternInReverse(row, pattern.getStartEnd()[0], counters);
            } else {
              OneDReader.recordPattern(row, pattern.getStartEnd()[1] + 1, counters);
              for (let i = 0, j = counters.length - 1; i < j; i++, j--) {
                let temp = counters[i];
                counters[i] = counters[j];
                counters[j] = temp;
              }
            }
            let numModules = outsideChar ? 16 : 15;
            let elementWidth = MathUtils.sum(new Int32Array(counters)) / numModules;
            let oddCounts = this.getOddCounts();
            let evenCounts = this.getEvenCounts();
            let oddRoundingErrors = this.getOddRoundingErrors();
            let evenRoundingErrors = this.getEvenRoundingErrors();
            for (let i = 0; i < counters.length; i++) {
              let value = counters[i] / elementWidth;
              let count = Math.floor(value + 0.5);
              if (count < 1) {
                count = 1;
              } else if (count > 8) {
                count = 8;
              }
              let offset = Math.floor(i / 2);
              if ((i & 1) === 0) {
                oddCounts[offset] = count;
                oddRoundingErrors[offset] = value - count;
              } else {
                evenCounts[offset] = count;
                evenRoundingErrors[offset] = value - count;
              }
            }
            this.adjustOddEvenCounts(outsideChar, numModules);
            let oddSum = 0;
            let oddChecksumPortion = 0;
            for (let i = oddCounts.length - 1; i >= 0; i--) {
              oddChecksumPortion *= 9;
              oddChecksumPortion += oddCounts[i];
              oddSum += oddCounts[i];
            }
            let evenChecksumPortion = 0;
            let evenSum = 0;
            for (let i = evenCounts.length - 1; i >= 0; i--) {
              evenChecksumPortion *= 9;
              evenChecksumPortion += evenCounts[i];
              evenSum += evenCounts[i];
            }
            let checksumPortion = oddChecksumPortion + 3 * evenChecksumPortion;
            if (outsideChar) {
              if ((oddSum & 1) !== 0 || oddSum > 12 || oddSum < 4) {
                throw new NotFoundException();
              }
              let group = (12 - oddSum) / 2;
              let oddWidest = RSS14Reader.OUTSIDE_ODD_WIDEST[group];
              let evenWidest = 9 - oddWidest;
              let vOdd = RSSUtils.getRSSvalue(oddCounts, oddWidest, false);
              let vEven = RSSUtils.getRSSvalue(evenCounts, evenWidest, true);
              let tEven = RSS14Reader.OUTSIDE_EVEN_TOTAL_SUBSET[group];
              let gSum = RSS14Reader.OUTSIDE_GSUM[group];
              return new DataCharacter(vOdd * tEven + vEven + gSum, checksumPortion);
            } else {
              if ((evenSum & 1) !== 0 || evenSum > 10 || evenSum < 4) {
                throw new NotFoundException();
              }
              let group = (10 - evenSum) / 2;
              let oddWidest = RSS14Reader.INSIDE_ODD_WIDEST[group];
              let evenWidest = 9 - oddWidest;
              let vOdd = RSSUtils.getRSSvalue(oddCounts, oddWidest, true);
              let vEven = RSSUtils.getRSSvalue(evenCounts, evenWidest, false);
              let tOdd = RSS14Reader.INSIDE_ODD_TOTAL_SUBSET[group];
              let gSum = RSS14Reader.INSIDE_GSUM[group];
              return new DataCharacter(vEven * tOdd + vOdd + gSum, checksumPortion);
            }
          }
          findFinderPattern(row, rightFinderPattern) {
            let counters = this.getDecodeFinderCounters();
            counters[0] = 0;
            counters[1] = 0;
            counters[2] = 0;
            counters[3] = 0;
            let width = row.getSize();
            let isWhite = false;
            let rowOffset = 0;
            while (rowOffset < width) {
              isWhite = !row.get(rowOffset);
              if (rightFinderPattern === isWhite) {
                break;
              }
              rowOffset++;
            }
            let counterPosition = 0;
            let patternStart = rowOffset;
            for (let x = rowOffset; x < width; x++) {
              if (row.get(x) !== isWhite) {
                counters[counterPosition]++;
              } else {
                if (counterPosition === 3) {
                  if (AbstractRSSReader.isFinderPattern(counters)) {
                    return [patternStart, x];
                  }
                  patternStart += counters[0] + counters[1];
                  counters[0] = counters[2];
                  counters[1] = counters[3];
                  counters[2] = 0;
                  counters[3] = 0;
                  counterPosition--;
                } else {
                  counterPosition++;
                }
                counters[counterPosition] = 1;
                isWhite = !isWhite;
              }
            }
            throw new NotFoundException();
          }
          parseFoundFinderPattern(row, rowNumber, right, startEnd) {
            let firstIsBlack = row.get(startEnd[0]);
            let firstElementStart = startEnd[0] - 1;
            while (firstElementStart >= 0 && firstIsBlack !== row.get(firstElementStart)) {
              firstElementStart--;
            }
            firstElementStart++;
            const firstCounter = startEnd[0] - firstElementStart;
            const counters = this.getDecodeFinderCounters();
            const copy = new Int32Array(counters.length);
            System.arraycopy(counters, 0, copy, 1, counters.length - 1);
            copy[0] = firstCounter;
            const value = this.parseFinderValue(copy, RSS14Reader.FINDER_PATTERNS);
            let start2 = firstElementStart;
            let end = startEnd[1];
            if (right) {
              start2 = row.getSize() - 1 - start2;
              end = row.getSize() - 1 - end;
            }
            return new FinderPattern(value, [firstElementStart, startEnd[1]], start2, end, rowNumber);
          }
          adjustOddEvenCounts(outsideChar, numModules) {
            let oddSum = MathUtils.sum(new Int32Array(this.getOddCounts()));
            let evenSum = MathUtils.sum(new Int32Array(this.getEvenCounts()));
            let incrementOdd = false;
            let decrementOdd = false;
            let incrementEven = false;
            let decrementEven = false;
            if (outsideChar) {
              if (oddSum > 12) {
                decrementOdd = true;
              } else if (oddSum < 4) {
                incrementOdd = true;
              }
              if (evenSum > 12) {
                decrementEven = true;
              } else if (evenSum < 4) {
                incrementEven = true;
              }
            } else {
              if (oddSum > 11) {
                decrementOdd = true;
              } else if (oddSum < 5) {
                incrementOdd = true;
              }
              if (evenSum > 10) {
                decrementEven = true;
              } else if (evenSum < 4) {
                incrementEven = true;
              }
            }
            let mismatch = oddSum + evenSum - numModules;
            let oddParityBad = (oddSum & 1) === (outsideChar ? 1 : 0);
            let evenParityBad = (evenSum & 1) === 1;
            if (mismatch === 1) {
              if (oddParityBad) {
                if (evenParityBad) {
                  throw new NotFoundException();
                }
                decrementOdd = true;
              } else {
                if (!evenParityBad) {
                  throw new NotFoundException();
                }
                decrementEven = true;
              }
            } else if (mismatch === -1) {
              if (oddParityBad) {
                if (evenParityBad) {
                  throw new NotFoundException();
                }
                incrementOdd = true;
              } else {
                if (!evenParityBad) {
                  throw new NotFoundException();
                }
                incrementEven = true;
              }
            } else if (mismatch === 0) {
              if (oddParityBad) {
                if (!evenParityBad) {
                  throw new NotFoundException();
                }
                if (oddSum < evenSum) {
                  incrementOdd = true;
                  decrementEven = true;
                } else {
                  decrementOdd = true;
                  incrementEven = true;
                }
              } else {
                if (evenParityBad) {
                  throw new NotFoundException();
                }
              }
            } else {
              throw new NotFoundException();
            }
            if (incrementOdd) {
              if (decrementOdd) {
                throw new NotFoundException();
              }
              AbstractRSSReader.increment(this.getOddCounts(), this.getOddRoundingErrors());
            }
            if (decrementOdd) {
              AbstractRSSReader.decrement(this.getOddCounts(), this.getOddRoundingErrors());
            }
            if (incrementEven) {
              if (decrementEven) {
                throw new NotFoundException();
              }
              AbstractRSSReader.increment(this.getEvenCounts(), this.getOddRoundingErrors());
            }
            if (decrementEven) {
              AbstractRSSReader.decrement(this.getEvenCounts(), this.getEvenRoundingErrors());
            }
          }
        }
        RSS14Reader.OUTSIDE_EVEN_TOTAL_SUBSET = [1, 10, 34, 70, 126];
        RSS14Reader.INSIDE_ODD_TOTAL_SUBSET = [4, 20, 48, 81];
        RSS14Reader.OUTSIDE_GSUM = [0, 161, 961, 2015, 2715];
        RSS14Reader.INSIDE_GSUM = [0, 336, 1036, 1516];
        RSS14Reader.OUTSIDE_ODD_WIDEST = [8, 6, 4, 3, 1];
        RSS14Reader.INSIDE_ODD_WIDEST = [2, 4, 6, 8];
        RSS14Reader.FINDER_PATTERNS = [
          Int32Array.from([3, 8, 2, 1]),
          Int32Array.from([3, 5, 5, 1]),
          Int32Array.from([3, 3, 7, 1]),
          Int32Array.from([3, 1, 9, 1]),
          Int32Array.from([2, 7, 4, 1]),
          Int32Array.from([2, 5, 6, 1]),
          Int32Array.from([2, 3, 8, 1]),
          Int32Array.from([1, 5, 7, 1]),
          Int32Array.from([1, 3, 9, 1])
        ];
        class MultiFormatOneDReader extends OneDReader {
          constructor(hints, verbose) {
            super();
            this.readers = [];
            this.verbose = verbose === true;
            const possibleFormats = !hints ? null : hints.get(DecodeHintType$1.POSSIBLE_FORMATS);
            const useCode39CheckDigit = hints && hints.get(DecodeHintType$1.ASSUME_CODE_39_CHECK_DIGIT) !== void 0;
            if (possibleFormats) {
              if (possibleFormats.includes(BarcodeFormat$1.EAN_13) || possibleFormats.includes(BarcodeFormat$1.UPC_A) || possibleFormats.includes(BarcodeFormat$1.EAN_8) || possibleFormats.includes(BarcodeFormat$1.UPC_E)) {
                this.readers.push(new MultiFormatUPCEANReader(hints));
              }
              if (possibleFormats.includes(BarcodeFormat$1.CODE_39)) {
                this.readers.push(new Code39Reader(useCode39CheckDigit));
              }
              if (possibleFormats.includes(BarcodeFormat$1.CODE_128)) {
                this.readers.push(new Code128Reader());
              }
              if (possibleFormats.includes(BarcodeFormat$1.ITF)) {
                this.readers.push(new ITFReader());
              }
              if (possibleFormats.includes(BarcodeFormat$1.RSS_14)) {
                this.readers.push(new RSS14Reader());
              }
              if (possibleFormats.includes(BarcodeFormat$1.RSS_EXPANDED)) {
                this.readers.push(new RSSExpandedReader(this.verbose));
              }
            } else {
              this.readers.push(new MultiFormatUPCEANReader(hints));
              this.readers.push(new Code39Reader());
              this.readers.push(new MultiFormatUPCEANReader(hints));
              this.readers.push(new Code128Reader());
              this.readers.push(new ITFReader());
              this.readers.push(new RSS14Reader());
              this.readers.push(new RSSExpandedReader(this.verbose));
            }
          }
          decodeRow(rowNumber, row, hints) {
            for (let i = 0; i < this.readers.length; i++) {
              try {
                return this.readers[i].decodeRow(rowNumber, row, hints);
              } catch (re) {
              }
            }
            throw new NotFoundException();
          }
          reset() {
            this.readers.forEach((reader) => reader.reset());
          }
        }
        class BrowserBarcodeReader extends BrowserCodeReader {
          constructor(timeBetweenScansMillis = 500, hints) {
            super(new MultiFormatOneDReader(hints), timeBetweenScansMillis, hints);
          }
        }
        class ECBlocks {
          constructor(ecCodewords, ecBlocks1, ecBlocks2) {
            this.ecCodewords = ecCodewords;
            this.ecBlocks = [ecBlocks1];
            ecBlocks2 && this.ecBlocks.push(ecBlocks2);
          }
          getECCodewords() {
            return this.ecCodewords;
          }
          getECBlocks() {
            return this.ecBlocks;
          }
        }
        class ECB {
          constructor(count, dataCodewords) {
            this.count = count;
            this.dataCodewords = dataCodewords;
          }
          getCount() {
            return this.count;
          }
          getDataCodewords() {
            return this.dataCodewords;
          }
        }
        class Version {
          constructor(versionNumber, symbolSizeRows, symbolSizeColumns, dataRegionSizeRows, dataRegionSizeColumns, ecBlocks) {
            this.versionNumber = versionNumber;
            this.symbolSizeRows = symbolSizeRows;
            this.symbolSizeColumns = symbolSizeColumns;
            this.dataRegionSizeRows = dataRegionSizeRows;
            this.dataRegionSizeColumns = dataRegionSizeColumns;
            this.ecBlocks = ecBlocks;
            let total = 0;
            const ecCodewords = ecBlocks.getECCodewords();
            const ecbArray = ecBlocks.getECBlocks();
            for (let ecBlock of ecbArray) {
              total += ecBlock.getCount() * (ecBlock.getDataCodewords() + ecCodewords);
            }
            this.totalCodewords = total;
          }
          getVersionNumber() {
            return this.versionNumber;
          }
          getSymbolSizeRows() {
            return this.symbolSizeRows;
          }
          getSymbolSizeColumns() {
            return this.symbolSizeColumns;
          }
          getDataRegionSizeRows() {
            return this.dataRegionSizeRows;
          }
          getDataRegionSizeColumns() {
            return this.dataRegionSizeColumns;
          }
          getTotalCodewords() {
            return this.totalCodewords;
          }
          getECBlocks() {
            return this.ecBlocks;
          }
          static getVersionForDimensions(numRows, numColumns) {
            if ((numRows & 1) !== 0 || (numColumns & 1) !== 0) {
              throw new FormatException();
            }
            for (let version of Version.VERSIONS) {
              if (version.symbolSizeRows === numRows && version.symbolSizeColumns === numColumns) {
                return version;
              }
            }
            throw new FormatException();
          }
          toString() {
            return "" + this.versionNumber;
          }
          static buildVersions() {
            return [
              new Version(1, 10, 10, 8, 8, new ECBlocks(5, new ECB(1, 3))),
              new Version(2, 12, 12, 10, 10, new ECBlocks(7, new ECB(1, 5))),
              new Version(3, 14, 14, 12, 12, new ECBlocks(10, new ECB(1, 8))),
              new Version(4, 16, 16, 14, 14, new ECBlocks(12, new ECB(1, 12))),
              new Version(5, 18, 18, 16, 16, new ECBlocks(14, new ECB(1, 18))),
              new Version(6, 20, 20, 18, 18, new ECBlocks(18, new ECB(1, 22))),
              new Version(7, 22, 22, 20, 20, new ECBlocks(20, new ECB(1, 30))),
              new Version(8, 24, 24, 22, 22, new ECBlocks(24, new ECB(1, 36))),
              new Version(9, 26, 26, 24, 24, new ECBlocks(28, new ECB(1, 44))),
              new Version(10, 32, 32, 14, 14, new ECBlocks(36, new ECB(1, 62))),
              new Version(11, 36, 36, 16, 16, new ECBlocks(42, new ECB(1, 86))),
              new Version(12, 40, 40, 18, 18, new ECBlocks(48, new ECB(1, 114))),
              new Version(13, 44, 44, 20, 20, new ECBlocks(56, new ECB(1, 144))),
              new Version(14, 48, 48, 22, 22, new ECBlocks(68, new ECB(1, 174))),
              new Version(15, 52, 52, 24, 24, new ECBlocks(42, new ECB(2, 102))),
              new Version(16, 64, 64, 14, 14, new ECBlocks(56, new ECB(2, 140))),
              new Version(17, 72, 72, 16, 16, new ECBlocks(36, new ECB(4, 92))),
              new Version(18, 80, 80, 18, 18, new ECBlocks(48, new ECB(4, 114))),
              new Version(19, 88, 88, 20, 20, new ECBlocks(56, new ECB(4, 144))),
              new Version(20, 96, 96, 22, 22, new ECBlocks(68, new ECB(4, 174))),
              new Version(21, 104, 104, 24, 24, new ECBlocks(56, new ECB(6, 136))),
              new Version(22, 120, 120, 18, 18, new ECBlocks(68, new ECB(6, 175))),
              new Version(23, 132, 132, 20, 20, new ECBlocks(62, new ECB(8, 163))),
              new Version(24, 144, 144, 22, 22, new ECBlocks(62, new ECB(8, 156), new ECB(2, 155))),
              new Version(25, 8, 18, 6, 16, new ECBlocks(7, new ECB(1, 5))),
              new Version(26, 8, 32, 6, 14, new ECBlocks(11, new ECB(1, 10))),
              new Version(27, 12, 26, 10, 24, new ECBlocks(14, new ECB(1, 16))),
              new Version(28, 12, 36, 10, 16, new ECBlocks(18, new ECB(1, 22))),
              new Version(29, 16, 36, 14, 16, new ECBlocks(24, new ECB(1, 32))),
              new Version(30, 16, 48, 14, 22, new ECBlocks(28, new ECB(1, 49)))
            ];
          }
        }
        Version.VERSIONS = Version.buildVersions();
        class BitMatrixParser {
          constructor(bitMatrix) {
            const dimension = bitMatrix.getHeight();
            if (dimension < 8 || dimension > 144 || (dimension & 1) !== 0) {
              throw new FormatException();
            }
            this.version = BitMatrixParser.readVersion(bitMatrix);
            this.mappingBitMatrix = this.extractDataRegion(bitMatrix);
            this.readMappingMatrix = new BitMatrix(this.mappingBitMatrix.getWidth(), this.mappingBitMatrix.getHeight());
          }
          getVersion() {
            return this.version;
          }
          static readVersion(bitMatrix) {
            const numRows = bitMatrix.getHeight();
            const numColumns = bitMatrix.getWidth();
            return Version.getVersionForDimensions(numRows, numColumns);
          }
          readCodewords() {
            const result = new Int8Array(this.version.getTotalCodewords());
            let resultOffset = 0;
            let row = 4;
            let column = 0;
            const numRows = this.mappingBitMatrix.getHeight();
            const numColumns = this.mappingBitMatrix.getWidth();
            let corner1Read = false;
            let corner2Read = false;
            let corner3Read = false;
            let corner4Read = false;
            do {
              if (row === numRows && column === 0 && !corner1Read) {
                result[resultOffset++] = this.readCorner1(numRows, numColumns) & 255;
                row -= 2;
                column += 2;
                corner1Read = true;
              } else if (row === numRows - 2 && column === 0 && (numColumns & 3) !== 0 && !corner2Read) {
                result[resultOffset++] = this.readCorner2(numRows, numColumns) & 255;
                row -= 2;
                column += 2;
                corner2Read = true;
              } else if (row === numRows + 4 && column === 2 && (numColumns & 7) === 0 && !corner3Read) {
                result[resultOffset++] = this.readCorner3(numRows, numColumns) & 255;
                row -= 2;
                column += 2;
                corner3Read = true;
              } else if (row === numRows - 2 && column === 0 && (numColumns & 7) === 4 && !corner4Read) {
                result[resultOffset++] = this.readCorner4(numRows, numColumns) & 255;
                row -= 2;
                column += 2;
                corner4Read = true;
              } else {
                do {
                  if (row < numRows && column >= 0 && !this.readMappingMatrix.get(column, row)) {
                    result[resultOffset++] = this.readUtah(row, column, numRows, numColumns) & 255;
                  }
                  row -= 2;
                  column += 2;
                } while (row >= 0 && column < numColumns);
                row += 1;
                column += 3;
                do {
                  if (row >= 0 && column < numColumns && !this.readMappingMatrix.get(column, row)) {
                    result[resultOffset++] = this.readUtah(row, column, numRows, numColumns) & 255;
                  }
                  row += 2;
                  column -= 2;
                } while (row < numRows && column >= 0);
                row += 3;
                column += 1;
              }
            } while (row < numRows || column < numColumns);
            if (resultOffset !== this.version.getTotalCodewords()) {
              throw new FormatException();
            }
            return result;
          }
          readModule(row, column, numRows, numColumns) {
            if (row < 0) {
              row += numRows;
              column += 4 - (numRows + 4 & 7);
            }
            if (column < 0) {
              column += numColumns;
              row += 4 - (numColumns + 4 & 7);
            }
            this.readMappingMatrix.set(column, row);
            return this.mappingBitMatrix.get(column, row);
          }
          readUtah(row, column, numRows, numColumns) {
            let currentByte = 0;
            if (this.readModule(row - 2, column - 2, numRows, numColumns)) {
              currentByte |= 1;
            }
            currentByte <<= 1;
            if (this.readModule(row - 2, column - 1, numRows, numColumns)) {
              currentByte |= 1;
            }
            currentByte <<= 1;
            if (this.readModule(row - 1, column - 2, numRows, numColumns)) {
              currentByte |= 1;
            }
            currentByte <<= 1;
            if (this.readModule(row - 1, column - 1, numRows, numColumns)) {
              currentByte |= 1;
            }
            currentByte <<= 1;
            if (this.readModule(row - 1, column, numRows, numColumns)) {
              currentByte |= 1;
            }
            currentByte <<= 1;
            if (this.readModule(row, column - 2, numRows, numColumns)) {
              currentByte |= 1;
            }
            currentByte <<= 1;
            if (this.readModule(row, column - 1, numRows, numColumns)) {
              currentByte |= 1;
            }
            currentByte <<= 1;
            if (this.readModule(row, column, numRows, numColumns)) {
              currentByte |= 1;
            }
            return currentByte;
          }
          readCorner1(numRows, numColumns) {
            let currentByte = 0;
            if (this.readModule(numRows - 1, 0, numRows, numColumns)) {
              currentByte |= 1;
            }
            currentByte <<= 1;
            if (this.readModule(numRows - 1, 1, numRows, numColumns)) {
              currentByte |= 1;
            }
            currentByte <<= 1;
            if (this.readModule(numRows - 1, 2, numRows, numColumns)) {
              currentByte |= 1;
            }
            currentByte <<= 1;
            if (this.readModule(0, numColumns - 2, numRows, numColumns)) {
              currentByte |= 1;
            }
            currentByte <<= 1;
            if (this.readModule(0, numColumns - 1, numRows, numColumns)) {
              currentByte |= 1;
            }
            currentByte <<= 1;
            if (this.readModule(1, numColumns - 1, numRows, numColumns)) {
              currentByte |= 1;
            }
            currentByte <<= 1;
            if (this.readModule(2, numColumns - 1, numRows, numColumns)) {
              currentByte |= 1;
            }
            currentByte <<= 1;
            if (this.readModule(3, numColumns - 1, numRows, numColumns)) {
              currentByte |= 1;
            }
            return currentByte;
          }
          readCorner2(numRows, numColumns) {
            let currentByte = 0;
            if (this.readModule(numRows - 3, 0, numRows, numColumns)) {
              currentByte |= 1;
            }
            currentByte <<= 1;
            if (this.readModule(numRows - 2, 0, numRows, numColumns)) {
              currentByte |= 1;
            }
            currentByte <<= 1;
            if (this.readModule(numRows - 1, 0, numRows, numColumns)) {
              currentByte |= 1;
            }
            currentByte <<= 1;
            if (this.readModule(0, numColumns - 4, numRows, numColumns)) {
              currentByte |= 1;
            }
            currentByte <<= 1;
            if (this.readModule(0, numColumns - 3, numRows, numColumns)) {
              currentByte |= 1;
            }
            currentByte <<= 1;
            if (this.readModule(0, numColumns - 2, numRows, numColumns)) {
              currentByte |= 1;
            }
            currentByte <<= 1;
            if (this.readModule(0, numColumns - 1, numRows, numColumns)) {
              currentByte |= 1;
            }
            currentByte <<= 1;
            if (this.readModule(1, numColumns - 1, numRows, numColumns)) {
              currentByte |= 1;
            }
            return currentByte;
          }
          readCorner3(numRows, numColumns) {
            let currentByte = 0;
            if (this.readModule(numRows - 1, 0, numRows, numColumns)) {
              currentByte |= 1;
            }
            currentByte <<= 1;
            if (this.readModule(numRows - 1, numColumns - 1, numRows, numColumns)) {
              currentByte |= 1;
            }
            currentByte <<= 1;
            if (this.readModule(0, numColumns - 3, numRows, numColumns)) {
              currentByte |= 1;
            }
            currentByte <<= 1;
            if (this.readModule(0, numColumns - 2, numRows, numColumns)) {
              currentByte |= 1;
            }
            currentByte <<= 1;
            if (this.readModule(0, numColumns - 1, numRows, numColumns)) {
              currentByte |= 1;
            }
            currentByte <<= 1;
            if (this.readModule(1, numColumns - 3, numRows, numColumns)) {
              currentByte |= 1;
            }
            currentByte <<= 1;
            if (this.readModule(1, numColumns - 2, numRows, numColumns)) {
              currentByte |= 1;
            }
            currentByte <<= 1;
            if (this.readModule(1, numColumns - 1, numRows, numColumns)) {
              currentByte |= 1;
            }
            return currentByte;
          }
          readCorner4(numRows, numColumns) {
            let currentByte = 0;
            if (this.readModule(numRows - 3, 0, numRows, numColumns)) {
              currentByte |= 1;
            }
            currentByte <<= 1;
            if (this.readModule(numRows - 2, 0, numRows, numColumns)) {
              currentByte |= 1;
            }
            currentByte <<= 1;
            if (this.readModule(numRows - 1, 0, numRows, numColumns)) {
              currentByte |= 1;
            }
            currentByte <<= 1;
            if (this.readModule(0, numColumns - 2, numRows, numColumns)) {
              currentByte |= 1;
            }
            currentByte <<= 1;
            if (this.readModule(0, numColumns - 1, numRows, numColumns)) {
              currentByte |= 1;
            }
            currentByte <<= 1;
            if (this.readModule(1, numColumns - 1, numRows, numColumns)) {
              currentByte |= 1;
            }
            currentByte <<= 1;
            if (this.readModule(2, numColumns - 1, numRows, numColumns)) {
              currentByte |= 1;
            }
            currentByte <<= 1;
            if (this.readModule(3, numColumns - 1, numRows, numColumns)) {
              currentByte |= 1;
            }
            return currentByte;
          }
          extractDataRegion(bitMatrix) {
            const symbolSizeRows = this.version.getSymbolSizeRows();
            const symbolSizeColumns = this.version.getSymbolSizeColumns();
            if (bitMatrix.getHeight() !== symbolSizeRows) {
              throw new IllegalArgumentException("Dimension of bitMatrix must match the version size");
            }
            const dataRegionSizeRows = this.version.getDataRegionSizeRows();
            const dataRegionSizeColumns = this.version.getDataRegionSizeColumns();
            const numDataRegionsRow = symbolSizeRows / dataRegionSizeRows | 0;
            const numDataRegionsColumn = symbolSizeColumns / dataRegionSizeColumns | 0;
            const sizeDataRegionRow = numDataRegionsRow * dataRegionSizeRows;
            const sizeDataRegionColumn = numDataRegionsColumn * dataRegionSizeColumns;
            const bitMatrixWithoutAlignment = new BitMatrix(sizeDataRegionColumn, sizeDataRegionRow);
            for (let dataRegionRow = 0; dataRegionRow < numDataRegionsRow; ++dataRegionRow) {
              const dataRegionRowOffset = dataRegionRow * dataRegionSizeRows;
              for (let dataRegionColumn = 0; dataRegionColumn < numDataRegionsColumn; ++dataRegionColumn) {
                const dataRegionColumnOffset = dataRegionColumn * dataRegionSizeColumns;
                for (let i = 0; i < dataRegionSizeRows; ++i) {
                  const readRowOffset = dataRegionRow * (dataRegionSizeRows + 2) + 1 + i;
                  const writeRowOffset = dataRegionRowOffset + i;
                  for (let j = 0; j < dataRegionSizeColumns; ++j) {
                    const readColumnOffset = dataRegionColumn * (dataRegionSizeColumns + 2) + 1 + j;
                    if (bitMatrix.get(readColumnOffset, readRowOffset)) {
                      const writeColumnOffset = dataRegionColumnOffset + j;
                      bitMatrixWithoutAlignment.set(writeColumnOffset, writeRowOffset);
                    }
                  }
                }
              }
            }
            return bitMatrixWithoutAlignment;
          }
        }
        class DataBlock {
          constructor(numDataCodewords, codewords) {
            this.numDataCodewords = numDataCodewords;
            this.codewords = codewords;
          }
          static getDataBlocks(rawCodewords, version) {
            const ecBlocks = version.getECBlocks();
            let totalBlocks = 0;
            const ecBlockArray = ecBlocks.getECBlocks();
            for (let ecBlock of ecBlockArray) {
              totalBlocks += ecBlock.getCount();
            }
            const result = new Array(totalBlocks);
            let numResultBlocks = 0;
            for (let ecBlock of ecBlockArray) {
              for (let i = 0; i < ecBlock.getCount(); i++) {
                const numDataCodewords = ecBlock.getDataCodewords();
                const numBlockCodewords = ecBlocks.getECCodewords() + numDataCodewords;
                result[numResultBlocks++] = new DataBlock(numDataCodewords, new Uint8Array(numBlockCodewords));
              }
            }
            const longerBlocksTotalCodewords = result[0].codewords.length;
            const longerBlocksNumDataCodewords = longerBlocksTotalCodewords - ecBlocks.getECCodewords();
            const shorterBlocksNumDataCodewords = longerBlocksNumDataCodewords - 1;
            let rawCodewordsOffset = 0;
            for (let i = 0; i < shorterBlocksNumDataCodewords; i++) {
              for (let j = 0; j < numResultBlocks; j++) {
                result[j].codewords[i] = rawCodewords[rawCodewordsOffset++];
              }
            }
            const specialVersion = version.getVersionNumber() === 24;
            const numLongerBlocks = specialVersion ? 8 : numResultBlocks;
            for (let j = 0; j < numLongerBlocks; j++) {
              result[j].codewords[longerBlocksNumDataCodewords - 1] = rawCodewords[rawCodewordsOffset++];
            }
            const max = result[0].codewords.length;
            for (let i = longerBlocksNumDataCodewords; i < max; i++) {
              for (let j = 0; j < numResultBlocks; j++) {
                const jOffset = specialVersion ? (j + 8) % numResultBlocks : j;
                const iOffset = specialVersion && jOffset > 7 ? i - 1 : i;
                result[jOffset].codewords[iOffset] = rawCodewords[rawCodewordsOffset++];
              }
            }
            if (rawCodewordsOffset !== rawCodewords.length) {
              throw new IllegalArgumentException();
            }
            return result;
          }
          getNumDataCodewords() {
            return this.numDataCodewords;
          }
          getCodewords() {
            return this.codewords;
          }
        }
        class BitSource {
          constructor(bytes) {
            this.bytes = bytes;
            this.byteOffset = 0;
            this.bitOffset = 0;
          }
          getBitOffset() {
            return this.bitOffset;
          }
          getByteOffset() {
            return this.byteOffset;
          }
          readBits(numBits) {
            if (numBits < 1 || numBits > 32 || numBits > this.available()) {
              throw new IllegalArgumentException("" + numBits);
            }
            let result = 0;
            let bitOffset = this.bitOffset;
            let byteOffset = this.byteOffset;
            const bytes = this.bytes;
            if (bitOffset > 0) {
              const bitsLeft = 8 - bitOffset;
              const toRead = numBits < bitsLeft ? numBits : bitsLeft;
              const bitsToNotRead = bitsLeft - toRead;
              const mask = 255 >> 8 - toRead << bitsToNotRead;
              result = (bytes[byteOffset] & mask) >> bitsToNotRead;
              numBits -= toRead;
              bitOffset += toRead;
              if (bitOffset === 8) {
                bitOffset = 0;
                byteOffset++;
              }
            }
            if (numBits > 0) {
              while (numBits >= 8) {
                result = result << 8 | bytes[byteOffset] & 255;
                byteOffset++;
                numBits -= 8;
              }
              if (numBits > 0) {
                const bitsToNotRead = 8 - numBits;
                const mask = 255 >> bitsToNotRead << bitsToNotRead;
                result = result << numBits | (bytes[byteOffset] & mask) >> bitsToNotRead;
                bitOffset += numBits;
              }
            }
            this.bitOffset = bitOffset;
            this.byteOffset = byteOffset;
            return result;
          }
          available() {
            return 8 * (this.bytes.length - this.byteOffset) - this.bitOffset;
          }
        }
        var Mode;
        (function(Mode2) {
          Mode2[Mode2["PAD_ENCODE"] = 0] = "PAD_ENCODE";
          Mode2[Mode2["ASCII_ENCODE"] = 1] = "ASCII_ENCODE";
          Mode2[Mode2["C40_ENCODE"] = 2] = "C40_ENCODE";
          Mode2[Mode2["TEXT_ENCODE"] = 3] = "TEXT_ENCODE";
          Mode2[Mode2["ANSIX12_ENCODE"] = 4] = "ANSIX12_ENCODE";
          Mode2[Mode2["EDIFACT_ENCODE"] = 5] = "EDIFACT_ENCODE";
          Mode2[Mode2["BASE256_ENCODE"] = 6] = "BASE256_ENCODE";
        })(Mode || (Mode = {}));
        class DecodedBitStreamParser {
          static decode(bytes) {
            const bits = new BitSource(bytes);
            const result = new StringBuilder();
            const resultTrailer = new StringBuilder();
            const byteSegments = new Array();
            let mode = Mode.ASCII_ENCODE;
            do {
              if (mode === Mode.ASCII_ENCODE) {
                mode = this.decodeAsciiSegment(bits, result, resultTrailer);
              } else {
                switch (mode) {
                  case Mode.C40_ENCODE:
                    this.decodeC40Segment(bits, result);
                    break;
                  case Mode.TEXT_ENCODE:
                    this.decodeTextSegment(bits, result);
                    break;
                  case Mode.ANSIX12_ENCODE:
                    this.decodeAnsiX12Segment(bits, result);
                    break;
                  case Mode.EDIFACT_ENCODE:
                    this.decodeEdifactSegment(bits, result);
                    break;
                  case Mode.BASE256_ENCODE:
                    this.decodeBase256Segment(bits, result, byteSegments);
                    break;
                  default:
                    throw new FormatException();
                }
                mode = Mode.ASCII_ENCODE;
              }
            } while (mode !== Mode.PAD_ENCODE && bits.available() > 0);
            if (resultTrailer.length() > 0) {
              result.append(resultTrailer.toString());
            }
            return new DecoderResult(bytes, result.toString(), byteSegments.length === 0 ? null : byteSegments, null);
          }
          static decodeAsciiSegment(bits, result, resultTrailer) {
            let upperShift = false;
            do {
              let oneByte = bits.readBits(8);
              if (oneByte === 0) {
                throw new FormatException();
              } else if (oneByte <= 128) {
                if (upperShift) {
                  oneByte += 128;
                }
                result.append(String.fromCharCode(oneByte - 1));
                return Mode.ASCII_ENCODE;
              } else if (oneByte === 129) {
                return Mode.PAD_ENCODE;
              } else if (oneByte <= 229) {
                const value = oneByte - 130;
                if (value < 10) {
                  result.append("0");
                }
                result.append("" + value);
              } else {
                switch (oneByte) {
                  case 230:
                    return Mode.C40_ENCODE;
                  case 231:
                    return Mode.BASE256_ENCODE;
                  case 232:
                    result.append(String.fromCharCode(29));
                    break;
                  case 233:
                  case 234:
                    break;
                  case 235:
                    upperShift = true;
                    break;
                  case 236:
                    result.append("[)>05");
                    resultTrailer.insert(0, "");
                    break;
                  case 237:
                    result.append("[)>06");
                    resultTrailer.insert(0, "");
                    break;
                  case 238:
                    return Mode.ANSIX12_ENCODE;
                  case 239:
                    return Mode.TEXT_ENCODE;
                  case 240:
                    return Mode.EDIFACT_ENCODE;
                  case 241:
                    break;
                  default:
                    if (oneByte !== 254 || bits.available() !== 0) {
                      throw new FormatException();
                    }
                    break;
                }
              }
            } while (bits.available() > 0);
            return Mode.ASCII_ENCODE;
          }
          static decodeC40Segment(bits, result) {
            let upperShift = false;
            const cValues = [];
            let shift = 0;
            do {
              if (bits.available() === 8) {
                return;
              }
              const firstByte = bits.readBits(8);
              if (firstByte === 254) {
                return;
              }
              this.parseTwoBytes(firstByte, bits.readBits(8), cValues);
              for (let i = 0; i < 3; i++) {
                const cValue = cValues[i];
                switch (shift) {
                  case 0:
                    if (cValue < 3) {
                      shift = cValue + 1;
                    } else if (cValue < this.C40_BASIC_SET_CHARS.length) {
                      const c40char = this.C40_BASIC_SET_CHARS[cValue];
                      if (upperShift) {
                        result.append(String.fromCharCode(c40char.charCodeAt(0) + 128));
                        upperShift = false;
                      } else {
                        result.append(c40char);
                      }
                    } else {
                      throw new FormatException();
                    }
                    break;
                  case 1:
                    if (upperShift) {
                      result.append(String.fromCharCode(cValue + 128));
                      upperShift = false;
                    } else {
                      result.append(String.fromCharCode(cValue));
                    }
                    shift = 0;
                    break;
                  case 2:
                    if (cValue < this.C40_SHIFT2_SET_CHARS.length) {
                      const c40char = this.C40_SHIFT2_SET_CHARS[cValue];
                      if (upperShift) {
                        result.append(String.fromCharCode(c40char.charCodeAt(0) + 128));
                        upperShift = false;
                      } else {
                        result.append(c40char);
                      }
                    } else {
                      switch (cValue) {
                        case 27:
                          result.append(String.fromCharCode(29));
                          break;
                        case 30:
                          upperShift = true;
                          break;
                        default:
                          throw new FormatException();
                      }
                    }
                    shift = 0;
                    break;
                  case 3:
                    if (upperShift) {
                      result.append(String.fromCharCode(cValue + 224));
                      upperShift = false;
                    } else {
                      result.append(String.fromCharCode(cValue + 96));
                    }
                    shift = 0;
                    break;
                  default:
                    throw new FormatException();
                }
              }
            } while (bits.available() > 0);
          }
          static decodeTextSegment(bits, result) {
            let upperShift = false;
            let cValues = [];
            let shift = 0;
            do {
              if (bits.available() === 8) {
                return;
              }
              const firstByte = bits.readBits(8);
              if (firstByte === 254) {
                return;
              }
              this.parseTwoBytes(firstByte, bits.readBits(8), cValues);
              for (let i = 0; i < 3; i++) {
                const cValue = cValues[i];
                switch (shift) {
                  case 0:
                    if (cValue < 3) {
                      shift = cValue + 1;
                    } else if (cValue < this.TEXT_BASIC_SET_CHARS.length) {
                      const textChar = this.TEXT_BASIC_SET_CHARS[cValue];
                      if (upperShift) {
                        result.append(String.fromCharCode(textChar.charCodeAt(0) + 128));
                        upperShift = false;
                      } else {
                        result.append(textChar);
                      }
                    } else {
                      throw new FormatException();
                    }
                    break;
                  case 1:
                    if (upperShift) {
                      result.append(String.fromCharCode(cValue + 128));
                      upperShift = false;
                    } else {
                      result.append(String.fromCharCode(cValue));
                    }
                    shift = 0;
                    break;
                  case 2:
                    if (cValue < this.TEXT_SHIFT2_SET_CHARS.length) {
                      const textChar = this.TEXT_SHIFT2_SET_CHARS[cValue];
                      if (upperShift) {
                        result.append(String.fromCharCode(textChar.charCodeAt(0) + 128));
                        upperShift = false;
                      } else {
                        result.append(textChar);
                      }
                    } else {
                      switch (cValue) {
                        case 27:
                          result.append(String.fromCharCode(29));
                          break;
                        case 30:
                          upperShift = true;
                          break;
                        default:
                          throw new FormatException();
                      }
                    }
                    shift = 0;
                    break;
                  case 3:
                    if (cValue < this.TEXT_SHIFT3_SET_CHARS.length) {
                      const textChar = this.TEXT_SHIFT3_SET_CHARS[cValue];
                      if (upperShift) {
                        result.append(String.fromCharCode(textChar.charCodeAt(0) + 128));
                        upperShift = false;
                      } else {
                        result.append(textChar);
                      }
                      shift = 0;
                    } else {
                      throw new FormatException();
                    }
                    break;
                  default:
                    throw new FormatException();
                }
              }
            } while (bits.available() > 0);
          }
          static decodeAnsiX12Segment(bits, result) {
            const cValues = [];
            do {
              if (bits.available() === 8) {
                return;
              }
              const firstByte = bits.readBits(8);
              if (firstByte === 254) {
                return;
              }
              this.parseTwoBytes(firstByte, bits.readBits(8), cValues);
              for (let i = 0; i < 3; i++) {
                const cValue = cValues[i];
                switch (cValue) {
                  case 0:
                    result.append("\r");
                    break;
                  case 1:
                    result.append("*");
                    break;
                  case 2:
                    result.append(">");
                    break;
                  case 3:
                    result.append(" ");
                    break;
                  default:
                    if (cValue < 14) {
                      result.append(String.fromCharCode(cValue + 44));
                    } else if (cValue < 40) {
                      result.append(String.fromCharCode(cValue + 51));
                    } else {
                      throw new FormatException();
                    }
                    break;
                }
              }
            } while (bits.available() > 0);
          }
          static parseTwoBytes(firstByte, secondByte, result) {
            let fullBitValue = (firstByte << 8) + secondByte - 1;
            let temp = Math.floor(fullBitValue / 1600);
            result[0] = temp;
            fullBitValue -= temp * 1600;
            temp = Math.floor(fullBitValue / 40);
            result[1] = temp;
            result[2] = fullBitValue - temp * 40;
          }
          static decodeEdifactSegment(bits, result) {
            do {
              if (bits.available() <= 16) {
                return;
              }
              for (let i = 0; i < 4; i++) {
                let edifactValue = bits.readBits(6);
                if (edifactValue === 31) {
                  const bitsLeft = 8 - bits.getBitOffset();
                  if (bitsLeft !== 8) {
                    bits.readBits(bitsLeft);
                  }
                  return;
                }
                if ((edifactValue & 32) === 0) {
                  edifactValue |= 64;
                }
                result.append(String.fromCharCode(edifactValue));
              }
            } while (bits.available() > 0);
          }
          static decodeBase256Segment(bits, result, byteSegments) {
            let codewordPosition = 1 + bits.getByteOffset();
            const d1 = this.unrandomize255State(bits.readBits(8), codewordPosition++);
            let count;
            if (d1 === 0) {
              count = bits.available() / 8 | 0;
            } else if (d1 < 250) {
              count = d1;
            } else {
              count = 250 * (d1 - 249) + this.unrandomize255State(bits.readBits(8), codewordPosition++);
            }
            if (count < 0) {
              throw new FormatException();
            }
            const bytes = new Uint8Array(count);
            for (let i = 0; i < count; i++) {
              if (bits.available() < 8) {
                throw new FormatException();
              }
              bytes[i] = this.unrandomize255State(bits.readBits(8), codewordPosition++);
            }
            byteSegments.push(bytes);
            try {
              result.append(StringEncoding.decode(bytes, StringUtils.ISO88591));
            } catch (uee) {
              throw new IllegalStateException("Platform does not support required encoding: " + uee.message);
            }
          }
          static unrandomize255State(randomizedBase256Codeword, base256CodewordPosition) {
            const pseudoRandomNumber = 149 * base256CodewordPosition % 255 + 1;
            const tempVariable = randomizedBase256Codeword - pseudoRandomNumber;
            return tempVariable >= 0 ? tempVariable : tempVariable + 256;
          }
        }
        DecodedBitStreamParser.C40_BASIC_SET_CHARS = [
          "*",
          "*",
          "*",
          " ",
          "0",
          "1",
          "2",
          "3",
          "4",
          "5",
          "6",
          "7",
          "8",
          "9",
          "A",
          "B",
          "C",
          "D",
          "E",
          "F",
          "G",
          "H",
          "I",
          "J",
          "K",
          "L",
          "M",
          "N",
          "O",
          "P",
          "Q",
          "R",
          "S",
          "T",
          "U",
          "V",
          "W",
          "X",
          "Y",
          "Z"
        ];
        DecodedBitStreamParser.C40_SHIFT2_SET_CHARS = [
          "!",
          '"',
          "#",
          "$",
          "%",
          "&",
          "'",
          "(",
          ")",
          "*",
          "+",
          ",",
          "-",
          ".",
          "/",
          ":",
          ";",
          "<",
          "=",
          ">",
          "?",
          "@",
          "[",
          "\\",
          "]",
          "^",
          "_"
        ];
        DecodedBitStreamParser.TEXT_BASIC_SET_CHARS = [
          "*",
          "*",
          "*",
          " ",
          "0",
          "1",
          "2",
          "3",
          "4",
          "5",
          "6",
          "7",
          "8",
          "9",
          "a",
          "b",
          "c",
          "d",
          "e",
          "f",
          "g",
          "h",
          "i",
          "j",
          "k",
          "l",
          "m",
          "n",
          "o",
          "p",
          "q",
          "r",
          "s",
          "t",
          "u",
          "v",
          "w",
          "x",
          "y",
          "z"
        ];
        DecodedBitStreamParser.TEXT_SHIFT2_SET_CHARS = DecodedBitStreamParser.C40_SHIFT2_SET_CHARS;
        DecodedBitStreamParser.TEXT_SHIFT3_SET_CHARS = [
          "`",
          "A",
          "B",
          "C",
          "D",
          "E",
          "F",
          "G",
          "H",
          "I",
          "J",
          "K",
          "L",
          "M",
          "N",
          "O",
          "P",
          "Q",
          "R",
          "S",
          "T",
          "U",
          "V",
          "W",
          "X",
          "Y",
          "Z",
          "{",
          "|",
          "}",
          "~",
          String.fromCharCode(127)
        ];
        class Decoder$1 {
          constructor() {
            this.rsDecoder = new ReedSolomonDecoder(GenericGF.DATA_MATRIX_FIELD_256);
          }
          decode(bits) {
            const parser = new BitMatrixParser(bits);
            const version = parser.getVersion();
            const codewords = parser.readCodewords();
            const dataBlocks = DataBlock.getDataBlocks(codewords, version);
            let totalBytes = 0;
            for (let db of dataBlocks) {
              totalBytes += db.getNumDataCodewords();
            }
            const resultBytes = new Uint8Array(totalBytes);
            const dataBlocksCount = dataBlocks.length;
            for (let j = 0; j < dataBlocksCount; j++) {
              const dataBlock = dataBlocks[j];
              const codewordBytes = dataBlock.getCodewords();
              const numDataCodewords = dataBlock.getNumDataCodewords();
              this.correctErrors(codewordBytes, numDataCodewords);
              for (let i = 0; i < numDataCodewords; i++) {
                resultBytes[i * dataBlocksCount + j] = codewordBytes[i];
              }
            }
            return DecodedBitStreamParser.decode(resultBytes);
          }
          correctErrors(codewordBytes, numDataCodewords) {
            const codewordsInts = new Int32Array(codewordBytes);
            try {
              this.rsDecoder.decode(codewordsInts, codewordBytes.length - numDataCodewords);
            } catch (ignored) {
              throw new ChecksumException();
            }
            for (let i = 0; i < numDataCodewords; i++) {
              codewordBytes[i] = codewordsInts[i];
            }
          }
        }
        class Detector$1 {
          constructor(image) {
            this.image = image;
            this.rectangleDetector = new WhiteRectangleDetector(this.image);
          }
          detect() {
            const cornerPoints = this.rectangleDetector.detect();
            let points = this.detectSolid1(cornerPoints);
            points = this.detectSolid2(points);
            points[3] = this.correctTopRight(points);
            if (!points[3]) {
              throw new NotFoundException();
            }
            points = this.shiftToModuleCenter(points);
            const topLeft = points[0];
            const bottomLeft = points[1];
            const bottomRight = points[2];
            const topRight = points[3];
            let dimensionTop = this.transitionsBetween(topLeft, topRight) + 1;
            let dimensionRight = this.transitionsBetween(bottomRight, topRight) + 1;
            if ((dimensionTop & 1) === 1) {
              dimensionTop += 1;
            }
            if ((dimensionRight & 1) === 1) {
              dimensionRight += 1;
            }
            if (4 * dimensionTop < 7 * dimensionRight && 4 * dimensionRight < 7 * dimensionTop) {
              dimensionTop = dimensionRight = Math.max(dimensionTop, dimensionRight);
            }
            let bits = Detector$1.sampleGrid(this.image, topLeft, bottomLeft, bottomRight, topRight, dimensionTop, dimensionRight);
            return new DetectorResult(bits, [topLeft, bottomLeft, bottomRight, topRight]);
          }
          static shiftPoint(point, to, div) {
            let x = (to.getX() - point.getX()) / (div + 1);
            let y = (to.getY() - point.getY()) / (div + 1);
            return new ResultPoint(point.getX() + x, point.getY() + y);
          }
          static moveAway(point, fromX, fromY) {
            let x = point.getX();
            let y = point.getY();
            if (x < fromX) {
              x -= 1;
            } else {
              x += 1;
            }
            if (y < fromY) {
              y -= 1;
            } else {
              y += 1;
            }
            return new ResultPoint(x, y);
          }
          detectSolid1(cornerPoints) {
            let pointA = cornerPoints[0];
            let pointB = cornerPoints[1];
            let pointC = cornerPoints[3];
            let pointD = cornerPoints[2];
            let trAB = this.transitionsBetween(pointA, pointB);
            let trBC = this.transitionsBetween(pointB, pointC);
            let trCD = this.transitionsBetween(pointC, pointD);
            let trDA = this.transitionsBetween(pointD, pointA);
            let min = trAB;
            let points = [pointD, pointA, pointB, pointC];
            if (min > trBC) {
              min = trBC;
              points[0] = pointA;
              points[1] = pointB;
              points[2] = pointC;
              points[3] = pointD;
            }
            if (min > trCD) {
              min = trCD;
              points[0] = pointB;
              points[1] = pointC;
              points[2] = pointD;
              points[3] = pointA;
            }
            if (min > trDA) {
              points[0] = pointC;
              points[1] = pointD;
              points[2] = pointA;
              points[3] = pointB;
            }
            return points;
          }
          detectSolid2(points) {
            let pointA = points[0];
            let pointB = points[1];
            let pointC = points[2];
            let pointD = points[3];
            let tr = this.transitionsBetween(pointA, pointD);
            let pointBs = Detector$1.shiftPoint(pointB, pointC, (tr + 1) * 4);
            let pointCs = Detector$1.shiftPoint(pointC, pointB, (tr + 1) * 4);
            let trBA = this.transitionsBetween(pointBs, pointA);
            let trCD = this.transitionsBetween(pointCs, pointD);
            if (trBA < trCD) {
              points[0] = pointA;
              points[1] = pointB;
              points[2] = pointC;
              points[3] = pointD;
            } else {
              points[0] = pointB;
              points[1] = pointC;
              points[2] = pointD;
              points[3] = pointA;
            }
            return points;
          }
          correctTopRight(points) {
            let pointA = points[0];
            let pointB = points[1];
            let pointC = points[2];
            let pointD = points[3];
            let trTop = this.transitionsBetween(pointA, pointD);
            let trRight = this.transitionsBetween(pointB, pointD);
            let pointAs = Detector$1.shiftPoint(pointA, pointB, (trRight + 1) * 4);
            let pointCs = Detector$1.shiftPoint(pointC, pointB, (trTop + 1) * 4);
            trTop = this.transitionsBetween(pointAs, pointD);
            trRight = this.transitionsBetween(pointCs, pointD);
            let candidate1 = new ResultPoint(pointD.getX() + (pointC.getX() - pointB.getX()) / (trTop + 1), pointD.getY() + (pointC.getY() - pointB.getY()) / (trTop + 1));
            let candidate2 = new ResultPoint(pointD.getX() + (pointA.getX() - pointB.getX()) / (trRight + 1), pointD.getY() + (pointA.getY() - pointB.getY()) / (trRight + 1));
            if (!this.isValid(candidate1)) {
              if (this.isValid(candidate2)) {
                return candidate2;
              }
              return null;
            }
            if (!this.isValid(candidate2)) {
              return candidate1;
            }
            let sumc1 = this.transitionsBetween(pointAs, candidate1) + this.transitionsBetween(pointCs, candidate1);
            let sumc2 = this.transitionsBetween(pointAs, candidate2) + this.transitionsBetween(pointCs, candidate2);
            if (sumc1 > sumc2) {
              return candidate1;
            } else {
              return candidate2;
            }
          }
          shiftToModuleCenter(points) {
            let pointA = points[0];
            let pointB = points[1];
            let pointC = points[2];
            let pointD = points[3];
            let dimH = this.transitionsBetween(pointA, pointD) + 1;
            let dimV = this.transitionsBetween(pointC, pointD) + 1;
            let pointAs = Detector$1.shiftPoint(pointA, pointB, dimV * 4);
            let pointCs = Detector$1.shiftPoint(pointC, pointB, dimH * 4);
            dimH = this.transitionsBetween(pointAs, pointD) + 1;
            dimV = this.transitionsBetween(pointCs, pointD) + 1;
            if ((dimH & 1) === 1) {
              dimH += 1;
            }
            if ((dimV & 1) === 1) {
              dimV += 1;
            }
            let centerX = (pointA.getX() + pointB.getX() + pointC.getX() + pointD.getX()) / 4;
            let centerY = (pointA.getY() + pointB.getY() + pointC.getY() + pointD.getY()) / 4;
            pointA = Detector$1.moveAway(pointA, centerX, centerY);
            pointB = Detector$1.moveAway(pointB, centerX, centerY);
            pointC = Detector$1.moveAway(pointC, centerX, centerY);
            pointD = Detector$1.moveAway(pointD, centerX, centerY);
            let pointBs;
            let pointDs;
            pointAs = Detector$1.shiftPoint(pointA, pointB, dimV * 4);
            pointAs = Detector$1.shiftPoint(pointAs, pointD, dimH * 4);
            pointBs = Detector$1.shiftPoint(pointB, pointA, dimV * 4);
            pointBs = Detector$1.shiftPoint(pointBs, pointC, dimH * 4);
            pointCs = Detector$1.shiftPoint(pointC, pointD, dimV * 4);
            pointCs = Detector$1.shiftPoint(pointCs, pointB, dimH * 4);
            pointDs = Detector$1.shiftPoint(pointD, pointC, dimV * 4);
            pointDs = Detector$1.shiftPoint(pointDs, pointA, dimH * 4);
            return [pointAs, pointBs, pointCs, pointDs];
          }
          isValid(p) {
            return p.getX() >= 0 && p.getX() < this.image.getWidth() && p.getY() > 0 && p.getY() < this.image.getHeight();
          }
          static sampleGrid(image, topLeft, bottomLeft, bottomRight, topRight, dimensionX, dimensionY) {
            const sampler = GridSamplerInstance.getInstance();
            return sampler.sampleGrid(image, dimensionX, dimensionY, 0.5, 0.5, dimensionX - 0.5, 0.5, dimensionX - 0.5, dimensionY - 0.5, 0.5, dimensionY - 0.5, topLeft.getX(), topLeft.getY(), topRight.getX(), topRight.getY(), bottomRight.getX(), bottomRight.getY(), bottomLeft.getX(), bottomLeft.getY());
          }
          transitionsBetween(from, to) {
            let fromX = Math.trunc(from.getX());
            let fromY = Math.trunc(from.getY());
            let toX = Math.trunc(to.getX());
            let toY = Math.trunc(to.getY());
            let steep = Math.abs(toY - fromY) > Math.abs(toX - fromX);
            if (steep) {
              let temp = fromX;
              fromX = fromY;
              fromY = temp;
              temp = toX;
              toX = toY;
              toY = temp;
            }
            let dx = Math.abs(toX - fromX);
            let dy = Math.abs(toY - fromY);
            let error2 = -dx / 2;
            let ystep = fromY < toY ? 1 : -1;
            let xstep = fromX < toX ? 1 : -1;
            let transitions = 0;
            let inBlack = this.image.get(steep ? fromY : fromX, steep ? fromX : fromY);
            for (let x = fromX, y = fromY; x !== toX; x += xstep) {
              let isBlack = this.image.get(steep ? y : x, steep ? x : y);
              if (isBlack !== inBlack) {
                transitions++;
                inBlack = isBlack;
              }
              error2 += dy;
              if (error2 > 0) {
                if (y === toY) {
                  break;
                }
                y += ystep;
                error2 -= dx;
              }
            }
            return transitions;
          }
        }
        class DataMatrixReader {
          constructor() {
            this.decoder = new Decoder$1();
          }
          decode(image, hints = null) {
            let decoderResult;
            let points;
            if (hints != null && hints.has(DecodeHintType$1.PURE_BARCODE)) {
              const bits = DataMatrixReader.extractPureBits(image.getBlackMatrix());
              decoderResult = this.decoder.decode(bits);
              points = DataMatrixReader.NO_POINTS;
            } else {
              const detectorResult = new Detector$1(image.getBlackMatrix()).detect();
              decoderResult = this.decoder.decode(detectorResult.getBits());
              points = detectorResult.getPoints();
            }
            const rawBytes = decoderResult.getRawBytes();
            const result = new Result(decoderResult.getText(), rawBytes, 8 * rawBytes.length, points, BarcodeFormat$1.DATA_MATRIX, System.currentTimeMillis());
            const byteSegments = decoderResult.getByteSegments();
            if (byteSegments != null) {
              result.putMetadata(ResultMetadataType$1.BYTE_SEGMENTS, byteSegments);
            }
            const ecLevel = decoderResult.getECLevel();
            if (ecLevel != null) {
              result.putMetadata(ResultMetadataType$1.ERROR_CORRECTION_LEVEL, ecLevel);
            }
            return result;
          }
          reset() {
          }
          static extractPureBits(image) {
            const leftTopBlack = image.getTopLeftOnBit();
            const rightBottomBlack = image.getBottomRightOnBit();
            if (leftTopBlack == null || rightBottomBlack == null) {
              throw new NotFoundException();
            }
            const moduleSize = this.moduleSize(leftTopBlack, image);
            let top = leftTopBlack[1];
            const bottom = rightBottomBlack[1];
            let left = leftTopBlack[0];
            const right = rightBottomBlack[0];
            const matrixWidth = (right - left + 1) / moduleSize;
            const matrixHeight = (bottom - top + 1) / moduleSize;
            if (matrixWidth <= 0 || matrixHeight <= 0) {
              throw new NotFoundException();
            }
            const nudge = moduleSize / 2;
            top += nudge;
            left += nudge;
            const bits = new BitMatrix(matrixWidth, matrixHeight);
            for (let y = 0; y < matrixHeight; y++) {
              const iOffset = top + y * moduleSize;
              for (let x = 0; x < matrixWidth; x++) {
                if (image.get(left + x * moduleSize, iOffset)) {
                  bits.set(x, y);
                }
              }
            }
            return bits;
          }
          static moduleSize(leftTopBlack, image) {
            const width = image.getWidth();
            let x = leftTopBlack[0];
            const y = leftTopBlack[1];
            while (x < width && image.get(x, y)) {
              x++;
            }
            if (x === width) {
              throw new NotFoundException();
            }
            const moduleSize = x - leftTopBlack[0];
            if (moduleSize === 0) {
              throw new NotFoundException();
            }
            return moduleSize;
          }
        }
        DataMatrixReader.NO_POINTS = [];
        class BrowserDatamatrixCodeReader extends BrowserCodeReader {
          constructor(timeBetweenScansMillis = 500) {
            super(new DataMatrixReader(), timeBetweenScansMillis);
          }
        }
        var ErrorCorrectionLevelValues;
        (function(ErrorCorrectionLevelValues2) {
          ErrorCorrectionLevelValues2[ErrorCorrectionLevelValues2["L"] = 0] = "L";
          ErrorCorrectionLevelValues2[ErrorCorrectionLevelValues2["M"] = 1] = "M";
          ErrorCorrectionLevelValues2[ErrorCorrectionLevelValues2["Q"] = 2] = "Q";
          ErrorCorrectionLevelValues2[ErrorCorrectionLevelValues2["H"] = 3] = "H";
        })(ErrorCorrectionLevelValues || (ErrorCorrectionLevelValues = {}));
        class ErrorCorrectionLevel {
          constructor(value, stringValue, bits) {
            this.value = value;
            this.stringValue = stringValue;
            this.bits = bits;
            ErrorCorrectionLevel.FOR_BITS.set(bits, this);
            ErrorCorrectionLevel.FOR_VALUE.set(value, this);
          }
          getValue() {
            return this.value;
          }
          getBits() {
            return this.bits;
          }
          static fromString(s) {
            switch (s) {
              case "L":
                return ErrorCorrectionLevel.L;
              case "M":
                return ErrorCorrectionLevel.M;
              case "Q":
                return ErrorCorrectionLevel.Q;
              case "H":
                return ErrorCorrectionLevel.H;
              default:
                throw new ArgumentException(s + "not available");
            }
          }
          toString() {
            return this.stringValue;
          }
          equals(o) {
            if (!(o instanceof ErrorCorrectionLevel)) {
              return false;
            }
            const other = o;
            return this.value === other.value;
          }
          static forBits(bits) {
            if (bits < 0 || bits >= ErrorCorrectionLevel.FOR_BITS.size) {
              throw new IllegalArgumentException();
            }
            return ErrorCorrectionLevel.FOR_BITS.get(bits);
          }
        }
        ErrorCorrectionLevel.FOR_BITS = /* @__PURE__ */ new Map();
        ErrorCorrectionLevel.FOR_VALUE = /* @__PURE__ */ new Map();
        ErrorCorrectionLevel.L = new ErrorCorrectionLevel(ErrorCorrectionLevelValues.L, "L", 1);
        ErrorCorrectionLevel.M = new ErrorCorrectionLevel(ErrorCorrectionLevelValues.M, "M", 0);
        ErrorCorrectionLevel.Q = new ErrorCorrectionLevel(ErrorCorrectionLevelValues.Q, "Q", 3);
        ErrorCorrectionLevel.H = new ErrorCorrectionLevel(ErrorCorrectionLevelValues.H, "H", 2);
        class FormatInformation {
          constructor(formatInfo) {
            this.errorCorrectionLevel = ErrorCorrectionLevel.forBits(formatInfo >> 3 & 3);
            this.dataMask = formatInfo & 7;
          }
          static numBitsDiffering(a, b) {
            return Integer.bitCount(a ^ b);
          }
          static decodeFormatInformation(maskedFormatInfo1, maskedFormatInfo2) {
            const formatInfo = FormatInformation.doDecodeFormatInformation(maskedFormatInfo1, maskedFormatInfo2);
            if (formatInfo !== null) {
              return formatInfo;
            }
            return FormatInformation.doDecodeFormatInformation(maskedFormatInfo1 ^ FormatInformation.FORMAT_INFO_MASK_QR, maskedFormatInfo2 ^ FormatInformation.FORMAT_INFO_MASK_QR);
          }
          static doDecodeFormatInformation(maskedFormatInfo1, maskedFormatInfo2) {
            let bestDifference = Number.MAX_SAFE_INTEGER;
            let bestFormatInfo = 0;
            for (const decodeInfo of FormatInformation.FORMAT_INFO_DECODE_LOOKUP) {
              const targetInfo = decodeInfo[0];
              if (targetInfo === maskedFormatInfo1 || targetInfo === maskedFormatInfo2) {
                return new FormatInformation(decodeInfo[1]);
              }
              let bitsDifference = FormatInformation.numBitsDiffering(maskedFormatInfo1, targetInfo);
              if (bitsDifference < bestDifference) {
                bestFormatInfo = decodeInfo[1];
                bestDifference = bitsDifference;
              }
              if (maskedFormatInfo1 !== maskedFormatInfo2) {
                bitsDifference = FormatInformation.numBitsDiffering(maskedFormatInfo2, targetInfo);
                if (bitsDifference < bestDifference) {
                  bestFormatInfo = decodeInfo[1];
                  bestDifference = bitsDifference;
                }
              }
            }
            if (bestDifference <= 3) {
              return new FormatInformation(bestFormatInfo);
            }
            return null;
          }
          getErrorCorrectionLevel() {
            return this.errorCorrectionLevel;
          }
          getDataMask() {
            return this.dataMask;
          }
          hashCode() {
            return this.errorCorrectionLevel.getBits() << 3 | this.dataMask;
          }
          equals(o) {
            if (!(o instanceof FormatInformation)) {
              return false;
            }
            const other = o;
            return this.errorCorrectionLevel === other.errorCorrectionLevel && this.dataMask === other.dataMask;
          }
        }
        FormatInformation.FORMAT_INFO_MASK_QR = 21522;
        FormatInformation.FORMAT_INFO_DECODE_LOOKUP = [
          Int32Array.from([21522, 0]),
          Int32Array.from([20773, 1]),
          Int32Array.from([24188, 2]),
          Int32Array.from([23371, 3]),
          Int32Array.from([17913, 4]),
          Int32Array.from([16590, 5]),
          Int32Array.from([20375, 6]),
          Int32Array.from([19104, 7]),
          Int32Array.from([30660, 8]),
          Int32Array.from([29427, 9]),
          Int32Array.from([32170, 10]),
          Int32Array.from([30877, 11]),
          Int32Array.from([26159, 12]),
          Int32Array.from([25368, 13]),
          Int32Array.from([27713, 14]),
          Int32Array.from([26998, 15]),
          Int32Array.from([5769, 16]),
          Int32Array.from([5054, 17]),
          Int32Array.from([7399, 18]),
          Int32Array.from([6608, 19]),
          Int32Array.from([1890, 20]),
          Int32Array.from([597, 21]),
          Int32Array.from([3340, 22]),
          Int32Array.from([2107, 23]),
          Int32Array.from([13663, 24]),
          Int32Array.from([12392, 25]),
          Int32Array.from([16177, 26]),
          Int32Array.from([14854, 27]),
          Int32Array.from([9396, 28]),
          Int32Array.from([8579, 29]),
          Int32Array.from([11994, 30]),
          Int32Array.from([11245, 31])
        ];
        class ECBlocks$1 {
          constructor(ecCodewordsPerBlock, ...ecBlocks) {
            this.ecCodewordsPerBlock = ecCodewordsPerBlock;
            this.ecBlocks = ecBlocks;
          }
          getECCodewordsPerBlock() {
            return this.ecCodewordsPerBlock;
          }
          getNumBlocks() {
            let total = 0;
            const ecBlocks = this.ecBlocks;
            for (const ecBlock of ecBlocks) {
              total += ecBlock.getCount();
            }
            return total;
          }
          getTotalECCodewords() {
            return this.ecCodewordsPerBlock * this.getNumBlocks();
          }
          getECBlocks() {
            return this.ecBlocks;
          }
        }
        class ECB$1 {
          constructor(count, dataCodewords) {
            this.count = count;
            this.dataCodewords = dataCodewords;
          }
          getCount() {
            return this.count;
          }
          getDataCodewords() {
            return this.dataCodewords;
          }
        }
        class Version$1 {
          constructor(versionNumber, alignmentPatternCenters, ...ecBlocks) {
            this.versionNumber = versionNumber;
            this.alignmentPatternCenters = alignmentPatternCenters;
            this.ecBlocks = ecBlocks;
            let total = 0;
            const ecCodewords = ecBlocks[0].getECCodewordsPerBlock();
            const ecbArray = ecBlocks[0].getECBlocks();
            for (const ecBlock of ecbArray) {
              total += ecBlock.getCount() * (ecBlock.getDataCodewords() + ecCodewords);
            }
            this.totalCodewords = total;
          }
          getVersionNumber() {
            return this.versionNumber;
          }
          getAlignmentPatternCenters() {
            return this.alignmentPatternCenters;
          }
          getTotalCodewords() {
            return this.totalCodewords;
          }
          getDimensionForVersion() {
            return 17 + 4 * this.versionNumber;
          }
          getECBlocksForLevel(ecLevel) {
            return this.ecBlocks[ecLevel.getValue()];
          }
          static getProvisionalVersionForDimension(dimension) {
            if (dimension % 4 !== 1) {
              throw new FormatException();
            }
            try {
              return this.getVersionForNumber((dimension - 17) / 4);
            } catch (ignored) {
              throw new FormatException();
            }
          }
          static getVersionForNumber(versionNumber) {
            if (versionNumber < 1 || versionNumber > 40) {
              throw new IllegalArgumentException();
            }
            return Version$1.VERSIONS[versionNumber - 1];
          }
          static decodeVersionInformation(versionBits) {
            let bestDifference = Number.MAX_SAFE_INTEGER;
            let bestVersion = 0;
            for (let i = 0; i < Version$1.VERSION_DECODE_INFO.length; i++) {
              const targetVersion = Version$1.VERSION_DECODE_INFO[i];
              if (targetVersion === versionBits) {
                return Version$1.getVersionForNumber(i + 7);
              }
              const bitsDifference = FormatInformation.numBitsDiffering(versionBits, targetVersion);
              if (bitsDifference < bestDifference) {
                bestVersion = i + 7;
                bestDifference = bitsDifference;
              }
            }
            if (bestDifference <= 3) {
              return Version$1.getVersionForNumber(bestVersion);
            }
            return null;
          }
          buildFunctionPattern() {
            const dimension = this.getDimensionForVersion();
            const bitMatrix = new BitMatrix(dimension);
            bitMatrix.setRegion(0, 0, 9, 9);
            bitMatrix.setRegion(dimension - 8, 0, 8, 9);
            bitMatrix.setRegion(0, dimension - 8, 9, 8);
            const max = this.alignmentPatternCenters.length;
            for (let x = 0; x < max; x++) {
              const i = this.alignmentPatternCenters[x] - 2;
              for (let y = 0; y < max; y++) {
                if (x === 0 && (y === 0 || y === max - 1) || x === max - 1 && y === 0) {
                  continue;
                }
                bitMatrix.setRegion(this.alignmentPatternCenters[y] - 2, i, 5, 5);
              }
            }
            bitMatrix.setRegion(6, 9, 1, dimension - 17);
            bitMatrix.setRegion(9, 6, dimension - 17, 1);
            if (this.versionNumber > 6) {
              bitMatrix.setRegion(dimension - 11, 0, 3, 6);
              bitMatrix.setRegion(0, dimension - 11, 6, 3);
            }
            return bitMatrix;
          }
          toString() {
            return "" + this.versionNumber;
          }
        }
        Version$1.VERSION_DECODE_INFO = Int32Array.from([
          31892,
          34236,
          39577,
          42195,
          48118,
          51042,
          55367,
          58893,
          63784,
          68472,
          70749,
          76311,
          79154,
          84390,
          87683,
          92361,
          96236,
          102084,
          102881,
          110507,
          110734,
          117786,
          119615,
          126325,
          127568,
          133589,
          136944,
          141498,
          145311,
          150283,
          152622,
          158308,
          161089,
          167017
        ]);
        Version$1.VERSIONS = [
          new Version$1(1, new Int32Array(0), new ECBlocks$1(7, new ECB$1(1, 19)), new ECBlocks$1(10, new ECB$1(1, 16)), new ECBlocks$1(13, new ECB$1(1, 13)), new ECBlocks$1(17, new ECB$1(1, 9))),
          new Version$1(2, Int32Array.from([6, 18]), new ECBlocks$1(10, new ECB$1(1, 34)), new ECBlocks$1(16, new ECB$1(1, 28)), new ECBlocks$1(22, new ECB$1(1, 22)), new ECBlocks$1(28, new ECB$1(1, 16))),
          new Version$1(3, Int32Array.from([6, 22]), new ECBlocks$1(15, new ECB$1(1, 55)), new ECBlocks$1(26, new ECB$1(1, 44)), new ECBlocks$1(18, new ECB$1(2, 17)), new ECBlocks$1(22, new ECB$1(2, 13))),
          new Version$1(4, Int32Array.from([6, 26]), new ECBlocks$1(20, new ECB$1(1, 80)), new ECBlocks$1(18, new ECB$1(2, 32)), new ECBlocks$1(26, new ECB$1(2, 24)), new ECBlocks$1(16, new ECB$1(4, 9))),
          new Version$1(5, Int32Array.from([6, 30]), new ECBlocks$1(26, new ECB$1(1, 108)), new ECBlocks$1(24, new ECB$1(2, 43)), new ECBlocks$1(18, new ECB$1(2, 15), new ECB$1(2, 16)), new ECBlocks$1(22, new ECB$1(2, 11), new ECB$1(2, 12))),
          new Version$1(6, Int32Array.from([6, 34]), new ECBlocks$1(18, new ECB$1(2, 68)), new ECBlocks$1(16, new ECB$1(4, 27)), new ECBlocks$1(24, new ECB$1(4, 19)), new ECBlocks$1(28, new ECB$1(4, 15))),
          new Version$1(7, Int32Array.from([6, 22, 38]), new ECBlocks$1(20, new ECB$1(2, 78)), new ECBlocks$1(18, new ECB$1(4, 31)), new ECBlocks$1(18, new ECB$1(2, 14), new ECB$1(4, 15)), new ECBlocks$1(26, new ECB$1(4, 13), new ECB$1(1, 14))),
          new Version$1(8, Int32Array.from([6, 24, 42]), new ECBlocks$1(24, new ECB$1(2, 97)), new ECBlocks$1(22, new ECB$1(2, 38), new ECB$1(2, 39)), new ECBlocks$1(22, new ECB$1(4, 18), new ECB$1(2, 19)), new ECBlocks$1(26, new ECB$1(4, 14), new ECB$1(2, 15))),
          new Version$1(9, Int32Array.from([6, 26, 46]), new ECBlocks$1(30, new ECB$1(2, 116)), new ECBlocks$1(22, new ECB$1(3, 36), new ECB$1(2, 37)), new ECBlocks$1(20, new ECB$1(4, 16), new ECB$1(4, 17)), new ECBlocks$1(24, new ECB$1(4, 12), new ECB$1(4, 13))),
          new Version$1(10, Int32Array.from([6, 28, 50]), new ECBlocks$1(18, new ECB$1(2, 68), new ECB$1(2, 69)), new ECBlocks$1(26, new ECB$1(4, 43), new ECB$1(1, 44)), new ECBlocks$1(24, new ECB$1(6, 19), new ECB$1(2, 20)), new ECBlocks$1(28, new ECB$1(6, 15), new ECB$1(2, 16))),
          new Version$1(11, Int32Array.from([6, 30, 54]), new ECBlocks$1(20, new ECB$1(4, 81)), new ECBlocks$1(30, new ECB$1(1, 50), new ECB$1(4, 51)), new ECBlocks$1(28, new ECB$1(4, 22), new ECB$1(4, 23)), new ECBlocks$1(24, new ECB$1(3, 12), new ECB$1(8, 13))),
          new Version$1(12, Int32Array.from([6, 32, 58]), new ECBlocks$1(24, new ECB$1(2, 92), new ECB$1(2, 93)), new ECBlocks$1(22, new ECB$1(6, 36), new ECB$1(2, 37)), new ECBlocks$1(26, new ECB$1(4, 20), new ECB$1(6, 21)), new ECBlocks$1(28, new ECB$1(7, 14), new ECB$1(4, 15))),
          new Version$1(13, Int32Array.from([6, 34, 62]), new ECBlocks$1(26, new ECB$1(4, 107)), new ECBlocks$1(22, new ECB$1(8, 37), new ECB$1(1, 38)), new ECBlocks$1(24, new ECB$1(8, 20), new ECB$1(4, 21)), new ECBlocks$1(22, new ECB$1(12, 11), new ECB$1(4, 12))),
          new Version$1(14, Int32Array.from([6, 26, 46, 66]), new ECBlocks$1(30, new ECB$1(3, 115), new ECB$1(1, 116)), new ECBlocks$1(24, new ECB$1(4, 40), new ECB$1(5, 41)), new ECBlocks$1(20, new ECB$1(11, 16), new ECB$1(5, 17)), new ECBlocks$1(24, new ECB$1(11, 12), new ECB$1(5, 13))),
          new Version$1(15, Int32Array.from([6, 26, 48, 70]), new ECBlocks$1(22, new ECB$1(5, 87), new ECB$1(1, 88)), new ECBlocks$1(24, new ECB$1(5, 41), new ECB$1(5, 42)), new ECBlocks$1(30, new ECB$1(5, 24), new ECB$1(7, 25)), new ECBlocks$1(24, new ECB$1(11, 12), new ECB$1(7, 13))),
          new Version$1(16, Int32Array.from([6, 26, 50, 74]), new ECBlocks$1(24, new ECB$1(5, 98), new ECB$1(1, 99)), new ECBlocks$1(28, new ECB$1(7, 45), new ECB$1(3, 46)), new ECBlocks$1(24, new ECB$1(15, 19), new ECB$1(2, 20)), new ECBlocks$1(30, new ECB$1(3, 15), new ECB$1(13, 16))),
          new Version$1(17, Int32Array.from([6, 30, 54, 78]), new ECBlocks$1(28, new ECB$1(1, 107), new ECB$1(5, 108)), new ECBlocks$1(28, new ECB$1(10, 46), new ECB$1(1, 47)), new ECBlocks$1(28, new ECB$1(1, 22), new ECB$1(15, 23)), new ECBlocks$1(28, new ECB$1(2, 14), new ECB$1(17, 15))),
          new Version$1(18, Int32Array.from([6, 30, 56, 82]), new ECBlocks$1(30, new ECB$1(5, 120), new ECB$1(1, 121)), new ECBlocks$1(26, new ECB$1(9, 43), new ECB$1(4, 44)), new ECBlocks$1(28, new ECB$1(17, 22), new ECB$1(1, 23)), new ECBlocks$1(28, new ECB$1(2, 14), new ECB$1(19, 15))),
          new Version$1(19, Int32Array.from([6, 30, 58, 86]), new ECBlocks$1(28, new ECB$1(3, 113), new ECB$1(4, 114)), new ECBlocks$1(26, new ECB$1(3, 44), new ECB$1(11, 45)), new ECBlocks$1(26, new ECB$1(17, 21), new ECB$1(4, 22)), new ECBlocks$1(26, new ECB$1(9, 13), new ECB$1(16, 14))),
          new Version$1(20, Int32Array.from([6, 34, 62, 90]), new ECBlocks$1(28, new ECB$1(3, 107), new ECB$1(5, 108)), new ECBlocks$1(26, new ECB$1(3, 41), new ECB$1(13, 42)), new ECBlocks$1(30, new ECB$1(15, 24), new ECB$1(5, 25)), new ECBlocks$1(28, new ECB$1(15, 15), new ECB$1(10, 16))),
          new Version$1(21, Int32Array.from([6, 28, 50, 72, 94]), new ECBlocks$1(28, new ECB$1(4, 116), new ECB$1(4, 117)), new ECBlocks$1(26, new ECB$1(17, 42)), new ECBlocks$1(28, new ECB$1(17, 22), new ECB$1(6, 23)), new ECBlocks$1(30, new ECB$1(19, 16), new ECB$1(6, 17))),
          new Version$1(22, Int32Array.from([6, 26, 50, 74, 98]), new ECBlocks$1(28, new ECB$1(2, 111), new ECB$1(7, 112)), new ECBlocks$1(28, new ECB$1(17, 46)), new ECBlocks$1(30, new ECB$1(7, 24), new ECB$1(16, 25)), new ECBlocks$1(24, new ECB$1(34, 13))),
          new Version$1(23, Int32Array.from([6, 30, 54, 78, 102]), new ECBlocks$1(30, new ECB$1(4, 121), new ECB$1(5, 122)), new ECBlocks$1(28, new ECB$1(4, 47), new ECB$1(14, 48)), new ECBlocks$1(30, new ECB$1(11, 24), new ECB$1(14, 25)), new ECBlocks$1(30, new ECB$1(16, 15), new ECB$1(14, 16))),
          new Version$1(24, Int32Array.from([6, 28, 54, 80, 106]), new ECBlocks$1(30, new ECB$1(6, 117), new ECB$1(4, 118)), new ECBlocks$1(28, new ECB$1(6, 45), new ECB$1(14, 46)), new ECBlocks$1(30, new ECB$1(11, 24), new ECB$1(16, 25)), new ECBlocks$1(30, new ECB$1(30, 16), new ECB$1(2, 17))),
          new Version$1(25, Int32Array.from([6, 32, 58, 84, 110]), new ECBlocks$1(26, new ECB$1(8, 106), new ECB$1(4, 107)), new ECBlocks$1(28, new ECB$1(8, 47), new ECB$1(13, 48)), new ECBlocks$1(30, new ECB$1(7, 24), new ECB$1(22, 25)), new ECBlocks$1(30, new ECB$1(22, 15), new ECB$1(13, 16))),
          new Version$1(26, Int32Array.from([6, 30, 58, 86, 114]), new ECBlocks$1(28, new ECB$1(10, 114), new ECB$1(2, 115)), new ECBlocks$1(28, new ECB$1(19, 46), new ECB$1(4, 47)), new ECBlocks$1(28, new ECB$1(28, 22), new ECB$1(6, 23)), new ECBlocks$1(30, new ECB$1(33, 16), new ECB$1(4, 17))),
          new Version$1(27, Int32Array.from([6, 34, 62, 90, 118]), new ECBlocks$1(30, new ECB$1(8, 122), new ECB$1(4, 123)), new ECBlocks$1(28, new ECB$1(22, 45), new ECB$1(3, 46)), new ECBlocks$1(30, new ECB$1(8, 23), new ECB$1(26, 24)), new ECBlocks$1(30, new ECB$1(12, 15), new ECB$1(28, 16))),
          new Version$1(28, Int32Array.from([6, 26, 50, 74, 98, 122]), new ECBlocks$1(30, new ECB$1(3, 117), new ECB$1(10, 118)), new ECBlocks$1(28, new ECB$1(3, 45), new ECB$1(23, 46)), new ECBlocks$1(30, new ECB$1(4, 24), new ECB$1(31, 25)), new ECBlocks$1(30, new ECB$1(11, 15), new ECB$1(31, 16))),
          new Version$1(29, Int32Array.from([6, 30, 54, 78, 102, 126]), new ECBlocks$1(30, new ECB$1(7, 116), new ECB$1(7, 117)), new ECBlocks$1(28, new ECB$1(21, 45), new ECB$1(7, 46)), new ECBlocks$1(30, new ECB$1(1, 23), new ECB$1(37, 24)), new ECBlocks$1(30, new ECB$1(19, 15), new ECB$1(26, 16))),
          new Version$1(30, Int32Array.from([6, 26, 52, 78, 104, 130]), new ECBlocks$1(30, new ECB$1(5, 115), new ECB$1(10, 116)), new ECBlocks$1(28, new ECB$1(19, 47), new ECB$1(10, 48)), new ECBlocks$1(30, new ECB$1(15, 24), new ECB$1(25, 25)), new ECBlocks$1(30, new ECB$1(23, 15), new ECB$1(25, 16))),
          new Version$1(31, Int32Array.from([6, 30, 56, 82, 108, 134]), new ECBlocks$1(30, new ECB$1(13, 115), new ECB$1(3, 116)), new ECBlocks$1(28, new ECB$1(2, 46), new ECB$1(29, 47)), new ECBlocks$1(30, new ECB$1(42, 24), new ECB$1(1, 25)), new ECBlocks$1(30, new ECB$1(23, 15), new ECB$1(28, 16))),
          new Version$1(32, Int32Array.from([6, 34, 60, 86, 112, 138]), new ECBlocks$1(30, new ECB$1(17, 115)), new ECBlocks$1(28, new ECB$1(10, 46), new ECB$1(23, 47)), new ECBlocks$1(30, new ECB$1(10, 24), new ECB$1(35, 25)), new ECBlocks$1(30, new ECB$1(19, 15), new ECB$1(35, 16))),
          new Version$1(33, Int32Array.from([6, 30, 58, 86, 114, 142]), new ECBlocks$1(30, new ECB$1(17, 115), new ECB$1(1, 116)), new ECBlocks$1(28, new ECB$1(14, 46), new ECB$1(21, 47)), new ECBlocks$1(30, new ECB$1(29, 24), new ECB$1(19, 25)), new ECBlocks$1(30, new ECB$1(11, 15), new ECB$1(46, 16))),
          new Version$1(34, Int32Array.from([6, 34, 62, 90, 118, 146]), new ECBlocks$1(30, new ECB$1(13, 115), new ECB$1(6, 116)), new ECBlocks$1(28, new ECB$1(14, 46), new ECB$1(23, 47)), new ECBlocks$1(30, new ECB$1(44, 24), new ECB$1(7, 25)), new ECBlocks$1(30, new ECB$1(59, 16), new ECB$1(1, 17))),
          new Version$1(35, Int32Array.from([6, 30, 54, 78, 102, 126, 150]), new ECBlocks$1(30, new ECB$1(12, 121), new ECB$1(7, 122)), new ECBlocks$1(28, new ECB$1(12, 47), new ECB$1(26, 48)), new ECBlocks$1(30, new ECB$1(39, 24), new ECB$1(14, 25)), new ECBlocks$1(30, new ECB$1(22, 15), new ECB$1(41, 16))),
          new Version$1(36, Int32Array.from([6, 24, 50, 76, 102, 128, 154]), new ECBlocks$1(30, new ECB$1(6, 121), new ECB$1(14, 122)), new ECBlocks$1(28, new ECB$1(6, 47), new ECB$1(34, 48)), new ECBlocks$1(30, new ECB$1(46, 24), new ECB$1(10, 25)), new ECBlocks$1(30, new ECB$1(2, 15), new ECB$1(64, 16))),
          new Version$1(37, Int32Array.from([6, 28, 54, 80, 106, 132, 158]), new ECBlocks$1(30, new ECB$1(17, 122), new ECB$1(4, 123)), new ECBlocks$1(28, new ECB$1(29, 46), new ECB$1(14, 47)), new ECBlocks$1(30, new ECB$1(49, 24), new ECB$1(10, 25)), new ECBlocks$1(30, new ECB$1(24, 15), new ECB$1(46, 16))),
          new Version$1(38, Int32Array.from([6, 32, 58, 84, 110, 136, 162]), new ECBlocks$1(30, new ECB$1(4, 122), new ECB$1(18, 123)), new ECBlocks$1(28, new ECB$1(13, 46), new ECB$1(32, 47)), new ECBlocks$1(30, new ECB$1(48, 24), new ECB$1(14, 25)), new ECBlocks$1(30, new ECB$1(42, 15), new ECB$1(32, 16))),
          new Version$1(39, Int32Array.from([6, 26, 54, 82, 110, 138, 166]), new ECBlocks$1(30, new ECB$1(20, 117), new ECB$1(4, 118)), new ECBlocks$1(28, new ECB$1(40, 47), new ECB$1(7, 48)), new ECBlocks$1(30, new ECB$1(43, 24), new ECB$1(22, 25)), new ECBlocks$1(30, new ECB$1(10, 15), new ECB$1(67, 16))),
          new Version$1(40, Int32Array.from([6, 30, 58, 86, 114, 142, 170]), new ECBlocks$1(30, new ECB$1(19, 118), new ECB$1(6, 119)), new ECBlocks$1(28, new ECB$1(18, 47), new ECB$1(31, 48)), new ECBlocks$1(30, new ECB$1(34, 24), new ECB$1(34, 25)), new ECBlocks$1(30, new ECB$1(20, 15), new ECB$1(61, 16)))
        ];
        var DataMaskValues;
        (function(DataMaskValues2) {
          DataMaskValues2[DataMaskValues2["DATA_MASK_000"] = 0] = "DATA_MASK_000";
          DataMaskValues2[DataMaskValues2["DATA_MASK_001"] = 1] = "DATA_MASK_001";
          DataMaskValues2[DataMaskValues2["DATA_MASK_010"] = 2] = "DATA_MASK_010";
          DataMaskValues2[DataMaskValues2["DATA_MASK_011"] = 3] = "DATA_MASK_011";
          DataMaskValues2[DataMaskValues2["DATA_MASK_100"] = 4] = "DATA_MASK_100";
          DataMaskValues2[DataMaskValues2["DATA_MASK_101"] = 5] = "DATA_MASK_101";
          DataMaskValues2[DataMaskValues2["DATA_MASK_110"] = 6] = "DATA_MASK_110";
          DataMaskValues2[DataMaskValues2["DATA_MASK_111"] = 7] = "DATA_MASK_111";
        })(DataMaskValues || (DataMaskValues = {}));
        class DataMask {
          constructor(value, isMasked) {
            this.value = value;
            this.isMasked = isMasked;
          }
          unmaskBitMatrix(bits, dimension) {
            for (let i = 0; i < dimension; i++) {
              for (let j = 0; j < dimension; j++) {
                if (this.isMasked(i, j)) {
                  bits.flip(j, i);
                }
              }
            }
          }
        }
        DataMask.values = /* @__PURE__ */ new Map([
          [DataMaskValues.DATA_MASK_000, new DataMask(DataMaskValues.DATA_MASK_000, (i, j) => {
            return (i + j & 1) === 0;
          })],
          [DataMaskValues.DATA_MASK_001, new DataMask(DataMaskValues.DATA_MASK_001, (i, j) => {
            return (i & 1) === 0;
          })],
          [DataMaskValues.DATA_MASK_010, new DataMask(DataMaskValues.DATA_MASK_010, (i, j) => {
            return j % 3 === 0;
          })],
          [DataMaskValues.DATA_MASK_011, new DataMask(DataMaskValues.DATA_MASK_011, (i, j) => {
            return (i + j) % 3 === 0;
          })],
          [DataMaskValues.DATA_MASK_100, new DataMask(DataMaskValues.DATA_MASK_100, (i, j) => {
            return (Math.floor(i / 2) + Math.floor(j / 3) & 1) === 0;
          })],
          [DataMaskValues.DATA_MASK_101, new DataMask(DataMaskValues.DATA_MASK_101, (i, j) => {
            return i * j % 6 === 0;
          })],
          [DataMaskValues.DATA_MASK_110, new DataMask(DataMaskValues.DATA_MASK_110, (i, j) => {
            return i * j % 6 < 3;
          })],
          [DataMaskValues.DATA_MASK_111, new DataMask(DataMaskValues.DATA_MASK_111, (i, j) => {
            return (i + j + i * j % 3 & 1) === 0;
          })]
        ]);
        class BitMatrixParser$1 {
          constructor(bitMatrix) {
            const dimension = bitMatrix.getHeight();
            if (dimension < 21 || (dimension & 3) !== 1) {
              throw new FormatException();
            }
            this.bitMatrix = bitMatrix;
          }
          readFormatInformation() {
            if (this.parsedFormatInfo !== null && this.parsedFormatInfo !== void 0) {
              return this.parsedFormatInfo;
            }
            let formatInfoBits1 = 0;
            for (let i = 0; i < 6; i++) {
              formatInfoBits1 = this.copyBit(i, 8, formatInfoBits1);
            }
            formatInfoBits1 = this.copyBit(7, 8, formatInfoBits1);
            formatInfoBits1 = this.copyBit(8, 8, formatInfoBits1);
            formatInfoBits1 = this.copyBit(8, 7, formatInfoBits1);
            for (let j = 5; j >= 0; j--) {
              formatInfoBits1 = this.copyBit(8, j, formatInfoBits1);
            }
            const dimension = this.bitMatrix.getHeight();
            let formatInfoBits2 = 0;
            const jMin = dimension - 7;
            for (let j = dimension - 1; j >= jMin; j--) {
              formatInfoBits2 = this.copyBit(8, j, formatInfoBits2);
            }
            for (let i = dimension - 8; i < dimension; i++) {
              formatInfoBits2 = this.copyBit(i, 8, formatInfoBits2);
            }
            this.parsedFormatInfo = FormatInformation.decodeFormatInformation(formatInfoBits1, formatInfoBits2);
            if (this.parsedFormatInfo !== null) {
              return this.parsedFormatInfo;
            }
            throw new FormatException();
          }
          readVersion() {
            if (this.parsedVersion !== null && this.parsedVersion !== void 0) {
              return this.parsedVersion;
            }
            const dimension = this.bitMatrix.getHeight();
            const provisionalVersion = Math.floor((dimension - 17) / 4);
            if (provisionalVersion <= 6) {
              return Version$1.getVersionForNumber(provisionalVersion);
            }
            let versionBits = 0;
            const ijMin = dimension - 11;
            for (let j = 5; j >= 0; j--) {
              for (let i = dimension - 9; i >= ijMin; i--) {
                versionBits = this.copyBit(i, j, versionBits);
              }
            }
            let theParsedVersion = Version$1.decodeVersionInformation(versionBits);
            if (theParsedVersion !== null && theParsedVersion.getDimensionForVersion() === dimension) {
              this.parsedVersion = theParsedVersion;
              return theParsedVersion;
            }
            versionBits = 0;
            for (let i = 5; i >= 0; i--) {
              for (let j = dimension - 9; j >= ijMin; j--) {
                versionBits = this.copyBit(i, j, versionBits);
              }
            }
            theParsedVersion = Version$1.decodeVersionInformation(versionBits);
            if (theParsedVersion !== null && theParsedVersion.getDimensionForVersion() === dimension) {
              this.parsedVersion = theParsedVersion;
              return theParsedVersion;
            }
            throw new FormatException();
          }
          copyBit(i, j, versionBits) {
            const bit = this.isMirror ? this.bitMatrix.get(j, i) : this.bitMatrix.get(i, j);
            return bit ? versionBits << 1 | 1 : versionBits << 1;
          }
          readCodewords() {
            const formatInfo = this.readFormatInformation();
            const version = this.readVersion();
            const dataMask = DataMask.values.get(formatInfo.getDataMask());
            const dimension = this.bitMatrix.getHeight();
            dataMask.unmaskBitMatrix(this.bitMatrix, dimension);
            const functionPattern = version.buildFunctionPattern();
            let readingUp = true;
            const result = new Uint8Array(version.getTotalCodewords());
            let resultOffset = 0;
            let currentByte = 0;
            let bitsRead = 0;
            for (let j = dimension - 1; j > 0; j -= 2) {
              if (j === 6) {
                j--;
              }
              for (let count = 0; count < dimension; count++) {
                const i = readingUp ? dimension - 1 - count : count;
                for (let col = 0; col < 2; col++) {
                  if (!functionPattern.get(j - col, i)) {
                    bitsRead++;
                    currentByte <<= 1;
                    if (this.bitMatrix.get(j - col, i)) {
                      currentByte |= 1;
                    }
                    if (bitsRead === 8) {
                      result[resultOffset++] = currentByte;
                      bitsRead = 0;
                      currentByte = 0;
                    }
                  }
                }
              }
              readingUp = !readingUp;
            }
            if (resultOffset !== version.getTotalCodewords()) {
              throw new FormatException();
            }
            return result;
          }
          remask() {
            if (this.parsedFormatInfo === null) {
              return;
            }
            const dataMask = DataMask.values[this.parsedFormatInfo.getDataMask()];
            const dimension = this.bitMatrix.getHeight();
            dataMask.unmaskBitMatrix(this.bitMatrix, dimension);
          }
          setMirror(isMirror) {
            this.parsedVersion = null;
            this.parsedFormatInfo = null;
            this.isMirror = isMirror;
          }
          mirror() {
            const bitMatrix = this.bitMatrix;
            for (let x = 0, width = bitMatrix.getWidth(); x < width; x++) {
              for (let y = x + 1, height = bitMatrix.getHeight(); y < height; y++) {
                if (bitMatrix.get(x, y) !== bitMatrix.get(y, x)) {
                  bitMatrix.flip(y, x);
                  bitMatrix.flip(x, y);
                }
              }
            }
          }
        }
        class DataBlock$1 {
          constructor(numDataCodewords, codewords) {
            this.numDataCodewords = numDataCodewords;
            this.codewords = codewords;
          }
          static getDataBlocks(rawCodewords, version, ecLevel) {
            if (rawCodewords.length !== version.getTotalCodewords()) {
              throw new IllegalArgumentException();
            }
            const ecBlocks = version.getECBlocksForLevel(ecLevel);
            let totalBlocks = 0;
            const ecBlockArray = ecBlocks.getECBlocks();
            for (const ecBlock of ecBlockArray) {
              totalBlocks += ecBlock.getCount();
            }
            const result = new Array(totalBlocks);
            let numResultBlocks = 0;
            for (const ecBlock of ecBlockArray) {
              for (let i = 0; i < ecBlock.getCount(); i++) {
                const numDataCodewords = ecBlock.getDataCodewords();
                const numBlockCodewords = ecBlocks.getECCodewordsPerBlock() + numDataCodewords;
                result[numResultBlocks++] = new DataBlock$1(numDataCodewords, new Uint8Array(numBlockCodewords));
              }
            }
            const shorterBlocksTotalCodewords = result[0].codewords.length;
            let longerBlocksStartAt = result.length - 1;
            while (longerBlocksStartAt >= 0) {
              const numCodewords = result[longerBlocksStartAt].codewords.length;
              if (numCodewords === shorterBlocksTotalCodewords) {
                break;
              }
              longerBlocksStartAt--;
            }
            longerBlocksStartAt++;
            const shorterBlocksNumDataCodewords = shorterBlocksTotalCodewords - ecBlocks.getECCodewordsPerBlock();
            let rawCodewordsOffset = 0;
            for (let i = 0; i < shorterBlocksNumDataCodewords; i++) {
              for (let j = 0; j < numResultBlocks; j++) {
                result[j].codewords[i] = rawCodewords[rawCodewordsOffset++];
              }
            }
            for (let j = longerBlocksStartAt; j < numResultBlocks; j++) {
              result[j].codewords[shorterBlocksNumDataCodewords] = rawCodewords[rawCodewordsOffset++];
            }
            const max = result[0].codewords.length;
            for (let i = shorterBlocksNumDataCodewords; i < max; i++) {
              for (let j = 0; j < numResultBlocks; j++) {
                const iOffset = j < longerBlocksStartAt ? i : i + 1;
                result[j].codewords[iOffset] = rawCodewords[rawCodewordsOffset++];
              }
            }
            return result;
          }
          getNumDataCodewords() {
            return this.numDataCodewords;
          }
          getCodewords() {
            return this.codewords;
          }
        }
        var ModeValues;
        (function(ModeValues2) {
          ModeValues2[ModeValues2["TERMINATOR"] = 0] = "TERMINATOR";
          ModeValues2[ModeValues2["NUMERIC"] = 1] = "NUMERIC";
          ModeValues2[ModeValues2["ALPHANUMERIC"] = 2] = "ALPHANUMERIC";
          ModeValues2[ModeValues2["STRUCTURED_APPEND"] = 3] = "STRUCTURED_APPEND";
          ModeValues2[ModeValues2["BYTE"] = 4] = "BYTE";
          ModeValues2[ModeValues2["ECI"] = 5] = "ECI";
          ModeValues2[ModeValues2["KANJI"] = 6] = "KANJI";
          ModeValues2[ModeValues2["FNC1_FIRST_POSITION"] = 7] = "FNC1_FIRST_POSITION";
          ModeValues2[ModeValues2["FNC1_SECOND_POSITION"] = 8] = "FNC1_SECOND_POSITION";
          ModeValues2[ModeValues2["HANZI"] = 9] = "HANZI";
        })(ModeValues || (ModeValues = {}));
        class Mode$1 {
          constructor(value, stringValue, characterCountBitsForVersions, bits) {
            this.value = value;
            this.stringValue = stringValue;
            this.characterCountBitsForVersions = characterCountBitsForVersions;
            this.bits = bits;
            Mode$1.FOR_BITS.set(bits, this);
            Mode$1.FOR_VALUE.set(value, this);
          }
          static forBits(bits) {
            const mode = Mode$1.FOR_BITS.get(bits);
            if (mode === void 0) {
              throw new IllegalArgumentException();
            }
            return mode;
          }
          getCharacterCountBits(version) {
            const versionNumber = version.getVersionNumber();
            let offset;
            if (versionNumber <= 9) {
              offset = 0;
            } else if (versionNumber <= 26) {
              offset = 1;
            } else {
              offset = 2;
            }
            return this.characterCountBitsForVersions[offset];
          }
          getValue() {
            return this.value;
          }
          getBits() {
            return this.bits;
          }
          equals(o) {
            if (!(o instanceof Mode$1)) {
              return false;
            }
            const other = o;
            return this.value === other.value;
          }
          toString() {
            return this.stringValue;
          }
        }
        Mode$1.FOR_BITS = /* @__PURE__ */ new Map();
        Mode$1.FOR_VALUE = /* @__PURE__ */ new Map();
        Mode$1.TERMINATOR = new Mode$1(ModeValues.TERMINATOR, "TERMINATOR", Int32Array.from([0, 0, 0]), 0);
        Mode$1.NUMERIC = new Mode$1(ModeValues.NUMERIC, "NUMERIC", Int32Array.from([10, 12, 14]), 1);
        Mode$1.ALPHANUMERIC = new Mode$1(ModeValues.ALPHANUMERIC, "ALPHANUMERIC", Int32Array.from([9, 11, 13]), 2);
        Mode$1.STRUCTURED_APPEND = new Mode$1(ModeValues.STRUCTURED_APPEND, "STRUCTURED_APPEND", Int32Array.from([0, 0, 0]), 3);
        Mode$1.BYTE = new Mode$1(ModeValues.BYTE, "BYTE", Int32Array.from([8, 16, 16]), 4);
        Mode$1.ECI = new Mode$1(ModeValues.ECI, "ECI", Int32Array.from([0, 0, 0]), 7);
        Mode$1.KANJI = new Mode$1(ModeValues.KANJI, "KANJI", Int32Array.from([8, 10, 12]), 8);
        Mode$1.FNC1_FIRST_POSITION = new Mode$1(ModeValues.FNC1_FIRST_POSITION, "FNC1_FIRST_POSITION", Int32Array.from([0, 0, 0]), 5);
        Mode$1.FNC1_SECOND_POSITION = new Mode$1(ModeValues.FNC1_SECOND_POSITION, "FNC1_SECOND_POSITION", Int32Array.from([0, 0, 0]), 9);
        Mode$1.HANZI = new Mode$1(ModeValues.HANZI, "HANZI", Int32Array.from([8, 10, 12]), 13);
        class DecodedBitStreamParser$1 {
          static decode(bytes, version, ecLevel, hints) {
            const bits = new BitSource(bytes);
            let result = new StringBuilder();
            const byteSegments = new Array();
            let symbolSequence = -1;
            let parityData = -1;
            try {
              let currentCharacterSetECI = null;
              let fc1InEffect = false;
              let mode;
              do {
                if (bits.available() < 4) {
                  mode = Mode$1.TERMINATOR;
                } else {
                  const modeBits = bits.readBits(4);
                  mode = Mode$1.forBits(modeBits);
                }
                switch (mode) {
                  case Mode$1.TERMINATOR:
                    break;
                  case Mode$1.FNC1_FIRST_POSITION:
                  case Mode$1.FNC1_SECOND_POSITION:
                    fc1InEffect = true;
                    break;
                  case Mode$1.STRUCTURED_APPEND:
                    if (bits.available() < 16) {
                      throw new FormatException();
                    }
                    symbolSequence = bits.readBits(8);
                    parityData = bits.readBits(8);
                    break;
                  case Mode$1.ECI:
                    const value = DecodedBitStreamParser$1.parseECIValue(bits);
                    currentCharacterSetECI = CharacterSetECI.getCharacterSetECIByValue(value);
                    if (currentCharacterSetECI === null) {
                      throw new FormatException();
                    }
                    break;
                  case Mode$1.HANZI:
                    const subset = bits.readBits(4);
                    const countHanzi = bits.readBits(mode.getCharacterCountBits(version));
                    if (subset === DecodedBitStreamParser$1.GB2312_SUBSET) {
                      DecodedBitStreamParser$1.decodeHanziSegment(bits, result, countHanzi);
                    }
                    break;
                  default:
                    const count = bits.readBits(mode.getCharacterCountBits(version));
                    switch (mode) {
                      case Mode$1.NUMERIC:
                        DecodedBitStreamParser$1.decodeNumericSegment(bits, result, count);
                        break;
                      case Mode$1.ALPHANUMERIC:
                        DecodedBitStreamParser$1.decodeAlphanumericSegment(bits, result, count, fc1InEffect);
                        break;
                      case Mode$1.BYTE:
                        DecodedBitStreamParser$1.decodeByteSegment(bits, result, count, currentCharacterSetECI, byteSegments, hints);
                        break;
                      case Mode$1.KANJI:
                        DecodedBitStreamParser$1.decodeKanjiSegment(bits, result, count);
                        break;
                      default:
                        throw new FormatException();
                    }
                    break;
                }
              } while (mode !== Mode$1.TERMINATOR);
            } catch (iae) {
              throw new FormatException();
            }
            return new DecoderResult(bytes, result.toString(), byteSegments.length === 0 ? null : byteSegments, ecLevel === null ? null : ecLevel.toString(), symbolSequence, parityData);
          }
          static decodeHanziSegment(bits, result, count) {
            if (count * 13 > bits.available()) {
              throw new FormatException();
            }
            const buffer = new Uint8Array(2 * count);
            let offset = 0;
            while (count > 0) {
              const twoBytes = bits.readBits(13);
              let assembledTwoBytes = twoBytes / 96 << 8 & 4294967295 | twoBytes % 96;
              if (assembledTwoBytes < 959) {
                assembledTwoBytes += 41377;
              } else {
                assembledTwoBytes += 42657;
              }
              buffer[offset] = assembledTwoBytes >> 8 & 255;
              buffer[offset + 1] = assembledTwoBytes & 255;
              offset += 2;
              count--;
            }
            try {
              result.append(StringEncoding.decode(buffer, StringUtils.GB2312));
            } catch (ignored) {
              throw new FormatException(ignored);
            }
          }
          static decodeKanjiSegment(bits, result, count) {
            if (count * 13 > bits.available()) {
              throw new FormatException();
            }
            const buffer = new Uint8Array(2 * count);
            let offset = 0;
            while (count > 0) {
              const twoBytes = bits.readBits(13);
              let assembledTwoBytes = twoBytes / 192 << 8 & 4294967295 | twoBytes % 192;
              if (assembledTwoBytes < 7936) {
                assembledTwoBytes += 33088;
              } else {
                assembledTwoBytes += 49472;
              }
              buffer[offset] = assembledTwoBytes >> 8;
              buffer[offset + 1] = assembledTwoBytes;
              offset += 2;
              count--;
            }
            try {
              result.append(StringEncoding.decode(buffer, StringUtils.SHIFT_JIS));
            } catch (ignored) {
              throw new FormatException(ignored);
            }
          }
          static decodeByteSegment(bits, result, count, currentCharacterSetECI, byteSegments, hints) {
            if (8 * count > bits.available()) {
              throw new FormatException();
            }
            const readBytes = new Uint8Array(count);
            for (let i = 0; i < count; i++) {
              readBytes[i] = bits.readBits(8);
            }
            let encoding;
            if (currentCharacterSetECI === null) {
              encoding = StringUtils.guessEncoding(readBytes, hints);
            } else {
              encoding = currentCharacterSetECI.getName();
            }
            try {
              result.append(StringEncoding.decode(readBytes, encoding));
            } catch (ignored) {
              throw new FormatException(ignored);
            }
            byteSegments.push(readBytes);
          }
          static toAlphaNumericChar(value) {
            if (value >= DecodedBitStreamParser$1.ALPHANUMERIC_CHARS.length) {
              throw new FormatException();
            }
            return DecodedBitStreamParser$1.ALPHANUMERIC_CHARS[value];
          }
          static decodeAlphanumericSegment(bits, result, count, fc1InEffect) {
            const start2 = result.length();
            while (count > 1) {
              if (bits.available() < 11) {
                throw new FormatException();
              }
              const nextTwoCharsBits = bits.readBits(11);
              result.append(DecodedBitStreamParser$1.toAlphaNumericChar(Math.floor(nextTwoCharsBits / 45)));
              result.append(DecodedBitStreamParser$1.toAlphaNumericChar(nextTwoCharsBits % 45));
              count -= 2;
            }
            if (count === 1) {
              if (bits.available() < 6) {
                throw new FormatException();
              }
              result.append(DecodedBitStreamParser$1.toAlphaNumericChar(bits.readBits(6)));
            }
            if (fc1InEffect) {
              for (let i = start2; i < result.length(); i++) {
                if (result.charAt(i) === "%") {
                  if (i < result.length() - 1 && result.charAt(i + 1) === "%") {
                    result.deleteCharAt(i + 1);
                  } else {
                    result.setCharAt(i, String.fromCharCode(29));
                  }
                }
              }
            }
          }
          static decodeNumericSegment(bits, result, count) {
            while (count >= 3) {
              if (bits.available() < 10) {
                throw new FormatException();
              }
              const threeDigitsBits = bits.readBits(10);
              if (threeDigitsBits >= 1e3) {
                throw new FormatException();
              }
              result.append(DecodedBitStreamParser$1.toAlphaNumericChar(Math.floor(threeDigitsBits / 100)));
              result.append(DecodedBitStreamParser$1.toAlphaNumericChar(Math.floor(threeDigitsBits / 10) % 10));
              result.append(DecodedBitStreamParser$1.toAlphaNumericChar(threeDigitsBits % 10));
              count -= 3;
            }
            if (count === 2) {
              if (bits.available() < 7) {
                throw new FormatException();
              }
              const twoDigitsBits = bits.readBits(7);
              if (twoDigitsBits >= 100) {
                throw new FormatException();
              }
              result.append(DecodedBitStreamParser$1.toAlphaNumericChar(Math.floor(twoDigitsBits / 10)));
              result.append(DecodedBitStreamParser$1.toAlphaNumericChar(twoDigitsBits % 10));
            } else if (count === 1) {
              if (bits.available() < 4) {
                throw new FormatException();
              }
              const digitBits = bits.readBits(4);
              if (digitBits >= 10) {
                throw new FormatException();
              }
              result.append(DecodedBitStreamParser$1.toAlphaNumericChar(digitBits));
            }
          }
          static parseECIValue(bits) {
            const firstByte = bits.readBits(8);
            if ((firstByte & 128) === 0) {
              return firstByte & 127;
            }
            if ((firstByte & 192) === 128) {
              const secondByte = bits.readBits(8);
              return (firstByte & 63) << 8 & 4294967295 | secondByte;
            }
            if ((firstByte & 224) === 192) {
              const secondThirdBytes = bits.readBits(16);
              return (firstByte & 31) << 16 & 4294967295 | secondThirdBytes;
            }
            throw new FormatException();
          }
        }
        DecodedBitStreamParser$1.ALPHANUMERIC_CHARS = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:";
        DecodedBitStreamParser$1.GB2312_SUBSET = 1;
        class QRCodeDecoderMetaData {
          constructor(mirrored) {
            this.mirrored = mirrored;
          }
          isMirrored() {
            return this.mirrored;
          }
          applyMirroredCorrection(points) {
            if (!this.mirrored || points === null || points.length < 3) {
              return;
            }
            const bottomLeft = points[0];
            points[0] = points[2];
            points[2] = bottomLeft;
          }
        }
        class Decoder$2 {
          constructor() {
            this.rsDecoder = new ReedSolomonDecoder(GenericGF.QR_CODE_FIELD_256);
          }
          decodeBooleanArray(image, hints) {
            return this.decodeBitMatrix(BitMatrix.parseFromBooleanArray(image), hints);
          }
          decodeBitMatrix(bits, hints) {
            const parser = new BitMatrixParser$1(bits);
            let ex = null;
            try {
              return this.decodeBitMatrixParser(parser, hints);
            } catch (e) {
              ex = e;
            }
            try {
              parser.remask();
              parser.setMirror(true);
              parser.readVersion();
              parser.readFormatInformation();
              parser.mirror();
              const result = this.decodeBitMatrixParser(parser, hints);
              result.setOther(new QRCodeDecoderMetaData(true));
              return result;
            } catch (e) {
              if (ex !== null) {
                throw ex;
              }
              throw e;
            }
          }
          decodeBitMatrixParser(parser, hints) {
            const version = parser.readVersion();
            const ecLevel = parser.readFormatInformation().getErrorCorrectionLevel();
            const codewords = parser.readCodewords();
            const dataBlocks = DataBlock$1.getDataBlocks(codewords, version, ecLevel);
            let totalBytes = 0;
            for (const dataBlock of dataBlocks) {
              totalBytes += dataBlock.getNumDataCodewords();
            }
            const resultBytes = new Uint8Array(totalBytes);
            let resultOffset = 0;
            for (const dataBlock of dataBlocks) {
              const codewordBytes = dataBlock.getCodewords();
              const numDataCodewords = dataBlock.getNumDataCodewords();
              this.correctErrors(codewordBytes, numDataCodewords);
              for (let i = 0; i < numDataCodewords; i++) {
                resultBytes[resultOffset++] = codewordBytes[i];
              }
            }
            return DecodedBitStreamParser$1.decode(resultBytes, version, ecLevel, hints);
          }
          correctErrors(codewordBytes, numDataCodewords) {
            const codewordsInts = new Int32Array(codewordBytes);
            try {
              this.rsDecoder.decode(codewordsInts, codewordBytes.length - numDataCodewords);
            } catch (ignored) {
              throw new ChecksumException();
            }
            for (let i = 0; i < numDataCodewords; i++) {
              codewordBytes[i] = codewordsInts[i];
            }
          }
        }
        class AlignmentPattern extends ResultPoint {
          constructor(posX, posY, estimatedModuleSize) {
            super(posX, posY);
            this.estimatedModuleSize = estimatedModuleSize;
          }
          aboutEquals(moduleSize, i, j) {
            if (Math.abs(i - this.getY()) <= moduleSize && Math.abs(j - this.getX()) <= moduleSize) {
              const moduleSizeDiff = Math.abs(moduleSize - this.estimatedModuleSize);
              return moduleSizeDiff <= 1 || moduleSizeDiff <= this.estimatedModuleSize;
            }
            return false;
          }
          combineEstimate(i, j, newModuleSize) {
            const combinedX = (this.getX() + j) / 2;
            const combinedY = (this.getY() + i) / 2;
            const combinedModuleSize = (this.estimatedModuleSize + newModuleSize) / 2;
            return new AlignmentPattern(combinedX, combinedY, combinedModuleSize);
          }
        }
        class AlignmentPatternFinder {
          constructor(image, startX, startY, width, height, moduleSize, resultPointCallback) {
            this.image = image;
            this.startX = startX;
            this.startY = startY;
            this.width = width;
            this.height = height;
            this.moduleSize = moduleSize;
            this.resultPointCallback = resultPointCallback;
            this.possibleCenters = [];
            this.crossCheckStateCount = new Int32Array(3);
          }
          find() {
            const startX = this.startX;
            const height = this.height;
            const width = this.width;
            const maxJ = startX + width;
            const middleI = this.startY + height / 2;
            const stateCount = new Int32Array(3);
            const image = this.image;
            for (let iGen = 0; iGen < height; iGen++) {
              const i = middleI + ((iGen & 1) === 0 ? Math.floor((iGen + 1) / 2) : -Math.floor((iGen + 1) / 2));
              stateCount[0] = 0;
              stateCount[1] = 0;
              stateCount[2] = 0;
              let j = startX;
              while (j < maxJ && !image.get(j, i)) {
                j++;
              }
              let currentState = 0;
              while (j < maxJ) {
                if (image.get(j, i)) {
                  if (currentState === 1) {
                    stateCount[1]++;
                  } else {
                    if (currentState === 2) {
                      if (this.foundPatternCross(stateCount)) {
                        const confirmed = this.handlePossibleCenter(stateCount, i, j);
                        if (confirmed !== null) {
                          return confirmed;
                        }
                      }
                      stateCount[0] = stateCount[2];
                      stateCount[1] = 1;
                      stateCount[2] = 0;
                      currentState = 1;
                    } else {
                      stateCount[++currentState]++;
                    }
                  }
                } else {
                  if (currentState === 1) {
                    currentState++;
                  }
                  stateCount[currentState]++;
                }
                j++;
              }
              if (this.foundPatternCross(stateCount)) {
                const confirmed = this.handlePossibleCenter(stateCount, i, maxJ);
                if (confirmed !== null) {
                  return confirmed;
                }
              }
            }
            if (this.possibleCenters.length !== 0) {
              return this.possibleCenters[0];
            }
            throw new NotFoundException();
          }
          static centerFromEnd(stateCount, end) {
            return end - stateCount[2] - stateCount[1] / 2;
          }
          foundPatternCross(stateCount) {
            const moduleSize = this.moduleSize;
            const maxVariance = moduleSize / 2;
            for (let i = 0; i < 3; i++) {
              if (Math.abs(moduleSize - stateCount[i]) >= maxVariance) {
                return false;
              }
            }
            return true;
          }
          crossCheckVertical(startI, centerJ, maxCount, originalStateCountTotal) {
            const image = this.image;
            const maxI = image.getHeight();
            const stateCount = this.crossCheckStateCount;
            stateCount[0] = 0;
            stateCount[1] = 0;
            stateCount[2] = 0;
            let i = startI;
            while (i >= 0 && image.get(centerJ, i) && stateCount[1] <= maxCount) {
              stateCount[1]++;
              i--;
            }
            if (i < 0 || stateCount[1] > maxCount) {
              return NaN;
            }
            while (i >= 0 && !image.get(centerJ, i) && stateCount[0] <= maxCount) {
              stateCount[0]++;
              i--;
            }
            if (stateCount[0] > maxCount) {
              return NaN;
            }
            i = startI + 1;
            while (i < maxI && image.get(centerJ, i) && stateCount[1] <= maxCount) {
              stateCount[1]++;
              i++;
            }
            if (i === maxI || stateCount[1] > maxCount) {
              return NaN;
            }
            while (i < maxI && !image.get(centerJ, i) && stateCount[2] <= maxCount) {
              stateCount[2]++;
              i++;
            }
            if (stateCount[2] > maxCount) {
              return NaN;
            }
            const stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2];
            if (5 * Math.abs(stateCountTotal - originalStateCountTotal) >= 2 * originalStateCountTotal) {
              return NaN;
            }
            return this.foundPatternCross(stateCount) ? AlignmentPatternFinder.centerFromEnd(stateCount, i) : NaN;
          }
          handlePossibleCenter(stateCount, i, j) {
            const stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2];
            const centerJ = AlignmentPatternFinder.centerFromEnd(stateCount, j);
            const centerI = this.crossCheckVertical(i, centerJ, 2 * stateCount[1], stateCountTotal);
            if (!isNaN(centerI)) {
              const estimatedModuleSize = (stateCount[0] + stateCount[1] + stateCount[2]) / 3;
              for (const center of this.possibleCenters) {
                if (center.aboutEquals(estimatedModuleSize, centerI, centerJ)) {
                  return center.combineEstimate(centerI, centerJ, estimatedModuleSize);
                }
              }
              const point = new AlignmentPattern(centerJ, centerI, estimatedModuleSize);
              this.possibleCenters.push(point);
              if (this.resultPointCallback !== null && this.resultPointCallback !== void 0) {
                this.resultPointCallback.foundPossibleResultPoint(point);
              }
            }
            return null;
          }
        }
        class FinderPattern$1 extends ResultPoint {
          constructor(posX, posY, estimatedModuleSize, count) {
            super(posX, posY);
            this.estimatedModuleSize = estimatedModuleSize;
            this.count = count;
            if (count === void 0) {
              this.count = 1;
            }
          }
          getEstimatedModuleSize() {
            return this.estimatedModuleSize;
          }
          getCount() {
            return this.count;
          }
          aboutEquals(moduleSize, i, j) {
            if (Math.abs(i - this.getY()) <= moduleSize && Math.abs(j - this.getX()) <= moduleSize) {
              const moduleSizeDiff = Math.abs(moduleSize - this.estimatedModuleSize);
              return moduleSizeDiff <= 1 || moduleSizeDiff <= this.estimatedModuleSize;
            }
            return false;
          }
          combineEstimate(i, j, newModuleSize) {
            const combinedCount = this.count + 1;
            const combinedX = (this.count * this.getX() + j) / combinedCount;
            const combinedY = (this.count * this.getY() + i) / combinedCount;
            const combinedModuleSize = (this.count * this.estimatedModuleSize + newModuleSize) / combinedCount;
            return new FinderPattern$1(combinedX, combinedY, combinedModuleSize, combinedCount);
          }
        }
        class FinderPatternInfo {
          constructor(patternCenters) {
            this.bottomLeft = patternCenters[0];
            this.topLeft = patternCenters[1];
            this.topRight = patternCenters[2];
          }
          getBottomLeft() {
            return this.bottomLeft;
          }
          getTopLeft() {
            return this.topLeft;
          }
          getTopRight() {
            return this.topRight;
          }
        }
        class FinderPatternFinder {
          constructor(image, resultPointCallback) {
            this.image = image;
            this.resultPointCallback = resultPointCallback;
            this.possibleCenters = [];
            this.crossCheckStateCount = new Int32Array(5);
            this.resultPointCallback = resultPointCallback;
          }
          getImage() {
            return this.image;
          }
          getPossibleCenters() {
            return this.possibleCenters;
          }
          find(hints) {
            const tryHarder = hints !== null && hints !== void 0 && hints.get(DecodeHintType$1.TRY_HARDER) !== void 0;
            const pureBarcode = hints !== null && hints !== void 0 && hints.get(DecodeHintType$1.PURE_BARCODE) !== void 0;
            const image = this.image;
            const maxI = image.getHeight();
            const maxJ = image.getWidth();
            let iSkip = Math.floor(3 * maxI / (4 * FinderPatternFinder.MAX_MODULES));
            if (iSkip < FinderPatternFinder.MIN_SKIP || tryHarder) {
              iSkip = FinderPatternFinder.MIN_SKIP;
            }
            let done = false;
            const stateCount = new Int32Array(5);
            for (let i = iSkip - 1; i < maxI && !done; i += iSkip) {
              stateCount[0] = 0;
              stateCount[1] = 0;
              stateCount[2] = 0;
              stateCount[3] = 0;
              stateCount[4] = 0;
              let currentState = 0;
              for (let j = 0; j < maxJ; j++) {
                if (image.get(j, i)) {
                  if ((currentState & 1) === 1) {
                    currentState++;
                  }
                  stateCount[currentState]++;
                } else {
                  if ((currentState & 1) === 0) {
                    if (currentState === 4) {
                      if (FinderPatternFinder.foundPatternCross(stateCount)) {
                        const confirmed = this.handlePossibleCenter(stateCount, i, j, pureBarcode);
                        if (confirmed === true) {
                          iSkip = 2;
                          if (this.hasSkipped === true) {
                            done = this.haveMultiplyConfirmedCenters();
                          } else {
                            const rowSkip = this.findRowSkip();
                            if (rowSkip > stateCount[2]) {
                              i += rowSkip - stateCount[2] - iSkip;
                              j = maxJ - 1;
                            }
                          }
                        } else {
                          stateCount[0] = stateCount[2];
                          stateCount[1] = stateCount[3];
                          stateCount[2] = stateCount[4];
                          stateCount[3] = 1;
                          stateCount[4] = 0;
                          currentState = 3;
                          continue;
                        }
                        currentState = 0;
                        stateCount[0] = 0;
                        stateCount[1] = 0;
                        stateCount[2] = 0;
                        stateCount[3] = 0;
                        stateCount[4] = 0;
                      } else {
                        stateCount[0] = stateCount[2];
                        stateCount[1] = stateCount[3];
                        stateCount[2] = stateCount[4];
                        stateCount[3] = 1;
                        stateCount[4] = 0;
                        currentState = 3;
                      }
                    } else {
                      stateCount[++currentState]++;
                    }
                  } else {
                    stateCount[currentState]++;
                  }
                }
              }
              if (FinderPatternFinder.foundPatternCross(stateCount)) {
                const confirmed = this.handlePossibleCenter(stateCount, i, maxJ, pureBarcode);
                if (confirmed === true) {
                  iSkip = stateCount[0];
                  if (this.hasSkipped) {
                    done = this.haveMultiplyConfirmedCenters();
                  }
                }
              }
            }
            const patternInfo = this.selectBestPatterns();
            ResultPoint.orderBestPatterns(patternInfo);
            return new FinderPatternInfo(patternInfo);
          }
          static centerFromEnd(stateCount, end) {
            return end - stateCount[4] - stateCount[3] - stateCount[2] / 2;
          }
          static foundPatternCross(stateCount) {
            let totalModuleSize = 0;
            for (let i = 0; i < 5; i++) {
              const count = stateCount[i];
              if (count === 0) {
                return false;
              }
              totalModuleSize += count;
            }
            if (totalModuleSize < 7) {
              return false;
            }
            const moduleSize = totalModuleSize / 7;
            const maxVariance = moduleSize / 2;
            return Math.abs(moduleSize - stateCount[0]) < maxVariance && Math.abs(moduleSize - stateCount[1]) < maxVariance && Math.abs(3 * moduleSize - stateCount[2]) < 3 * maxVariance && Math.abs(moduleSize - stateCount[3]) < maxVariance && Math.abs(moduleSize - stateCount[4]) < maxVariance;
          }
          getCrossCheckStateCount() {
            const crossCheckStateCount = this.crossCheckStateCount;
            crossCheckStateCount[0] = 0;
            crossCheckStateCount[1] = 0;
            crossCheckStateCount[2] = 0;
            crossCheckStateCount[3] = 0;
            crossCheckStateCount[4] = 0;
            return crossCheckStateCount;
          }
          crossCheckDiagonal(startI, centerJ, maxCount, originalStateCountTotal) {
            const stateCount = this.getCrossCheckStateCount();
            let i = 0;
            const image = this.image;
            while (startI >= i && centerJ >= i && image.get(centerJ - i, startI - i)) {
              stateCount[2]++;
              i++;
            }
            if (startI < i || centerJ < i) {
              return false;
            }
            while (startI >= i && centerJ >= i && !image.get(centerJ - i, startI - i) && stateCount[1] <= maxCount) {
              stateCount[1]++;
              i++;
            }
            if (startI < i || centerJ < i || stateCount[1] > maxCount) {
              return false;
            }
            while (startI >= i && centerJ >= i && image.get(centerJ - i, startI - i) && stateCount[0] <= maxCount) {
              stateCount[0]++;
              i++;
            }
            if (stateCount[0] > maxCount) {
              return false;
            }
            const maxI = image.getHeight();
            const maxJ = image.getWidth();
            i = 1;
            while (startI + i < maxI && centerJ + i < maxJ && image.get(centerJ + i, startI + i)) {
              stateCount[2]++;
              i++;
            }
            if (startI + i >= maxI || centerJ + i >= maxJ) {
              return false;
            }
            while (startI + i < maxI && centerJ + i < maxJ && !image.get(centerJ + i, startI + i) && stateCount[3] < maxCount) {
              stateCount[3]++;
              i++;
            }
            if (startI + i >= maxI || centerJ + i >= maxJ || stateCount[3] >= maxCount) {
              return false;
            }
            while (startI + i < maxI && centerJ + i < maxJ && image.get(centerJ + i, startI + i) && stateCount[4] < maxCount) {
              stateCount[4]++;
              i++;
            }
            if (stateCount[4] >= maxCount) {
              return false;
            }
            const stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2] + stateCount[3] + stateCount[4];
            return Math.abs(stateCountTotal - originalStateCountTotal) < 2 * originalStateCountTotal && FinderPatternFinder.foundPatternCross(stateCount);
          }
          crossCheckVertical(startI, centerJ, maxCount, originalStateCountTotal) {
            const image = this.image;
            const maxI = image.getHeight();
            const stateCount = this.getCrossCheckStateCount();
            let i = startI;
            while (i >= 0 && image.get(centerJ, i)) {
              stateCount[2]++;
              i--;
            }
            if (i < 0) {
              return NaN;
            }
            while (i >= 0 && !image.get(centerJ, i) && stateCount[1] <= maxCount) {
              stateCount[1]++;
              i--;
            }
            if (i < 0 || stateCount[1] > maxCount) {
              return NaN;
            }
            while (i >= 0 && image.get(centerJ, i) && stateCount[0] <= maxCount) {
              stateCount[0]++;
              i--;
            }
            if (stateCount[0] > maxCount) {
              return NaN;
            }
            i = startI + 1;
            while (i < maxI && image.get(centerJ, i)) {
              stateCount[2]++;
              i++;
            }
            if (i === maxI) {
              return NaN;
            }
            while (i < maxI && !image.get(centerJ, i) && stateCount[3] < maxCount) {
              stateCount[3]++;
              i++;
            }
            if (i === maxI || stateCount[3] >= maxCount) {
              return NaN;
            }
            while (i < maxI && image.get(centerJ, i) && stateCount[4] < maxCount) {
              stateCount[4]++;
              i++;
            }
            if (stateCount[4] >= maxCount) {
              return NaN;
            }
            const stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2] + stateCount[3] + stateCount[4];
            if (5 * Math.abs(stateCountTotal - originalStateCountTotal) >= 2 * originalStateCountTotal) {
              return NaN;
            }
            return FinderPatternFinder.foundPatternCross(stateCount) ? FinderPatternFinder.centerFromEnd(stateCount, i) : NaN;
          }
          crossCheckHorizontal(startJ, centerI, maxCount, originalStateCountTotal) {
            const image = this.image;
            const maxJ = image.getWidth();
            const stateCount = this.getCrossCheckStateCount();
            let j = startJ;
            while (j >= 0 && image.get(j, centerI)) {
              stateCount[2]++;
              j--;
            }
            if (j < 0) {
              return NaN;
            }
            while (j >= 0 && !image.get(j, centerI) && stateCount[1] <= maxCount) {
              stateCount[1]++;
              j--;
            }
            if (j < 0 || stateCount[1] > maxCount) {
              return NaN;
            }
            while (j >= 0 && image.get(j, centerI) && stateCount[0] <= maxCount) {
              stateCount[0]++;
              j--;
            }
            if (stateCount[0] > maxCount) {
              return NaN;
            }
            j = startJ + 1;
            while (j < maxJ && image.get(j, centerI)) {
              stateCount[2]++;
              j++;
            }
            if (j === maxJ) {
              return NaN;
            }
            while (j < maxJ && !image.get(j, centerI) && stateCount[3] < maxCount) {
              stateCount[3]++;
              j++;
            }
            if (j === maxJ || stateCount[3] >= maxCount) {
              return NaN;
            }
            while (j < maxJ && image.get(j, centerI) && stateCount[4] < maxCount) {
              stateCount[4]++;
              j++;
            }
            if (stateCount[4] >= maxCount) {
              return NaN;
            }
            const stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2] + stateCount[3] + stateCount[4];
            if (5 * Math.abs(stateCountTotal - originalStateCountTotal) >= originalStateCountTotal) {
              return NaN;
            }
            return FinderPatternFinder.foundPatternCross(stateCount) ? FinderPatternFinder.centerFromEnd(stateCount, j) : NaN;
          }
          handlePossibleCenter(stateCount, i, j, pureBarcode) {
            const stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2] + stateCount[3] + stateCount[4];
            let centerJ = FinderPatternFinder.centerFromEnd(stateCount, j);
            let centerI = this.crossCheckVertical(i, Math.floor(centerJ), stateCount[2], stateCountTotal);
            if (!isNaN(centerI)) {
              centerJ = this.crossCheckHorizontal(Math.floor(centerJ), Math.floor(centerI), stateCount[2], stateCountTotal);
              if (!isNaN(centerJ) && (!pureBarcode || this.crossCheckDiagonal(Math.floor(centerI), Math.floor(centerJ), stateCount[2], stateCountTotal))) {
                const estimatedModuleSize = stateCountTotal / 7;
                let found = false;
                const possibleCenters = this.possibleCenters;
                for (let index = 0, length = possibleCenters.length; index < length; index++) {
                  const center = possibleCenters[index];
                  if (center.aboutEquals(estimatedModuleSize, centerI, centerJ)) {
                    possibleCenters[index] = center.combineEstimate(centerI, centerJ, estimatedModuleSize);
                    found = true;
                    break;
                  }
                }
                if (!found) {
                  const point = new FinderPattern$1(centerJ, centerI, estimatedModuleSize);
                  possibleCenters.push(point);
                  if (this.resultPointCallback !== null && this.resultPointCallback !== void 0) {
                    this.resultPointCallback.foundPossibleResultPoint(point);
                  }
                }
                return true;
              }
            }
            return false;
          }
          findRowSkip() {
            const max = this.possibleCenters.length;
            if (max <= 1) {
              return 0;
            }
            let firstConfirmedCenter = null;
            for (const center of this.possibleCenters) {
              if (center.getCount() >= FinderPatternFinder.CENTER_QUORUM) {
                if (firstConfirmedCenter == null) {
                  firstConfirmedCenter = center;
                } else {
                  this.hasSkipped = true;
                  return Math.floor((Math.abs(firstConfirmedCenter.getX() - center.getX()) - Math.abs(firstConfirmedCenter.getY() - center.getY())) / 2);
                }
              }
            }
            return 0;
          }
          haveMultiplyConfirmedCenters() {
            let confirmedCount = 0;
            let totalModuleSize = 0;
            const max = this.possibleCenters.length;
            for (const pattern of this.possibleCenters) {
              if (pattern.getCount() >= FinderPatternFinder.CENTER_QUORUM) {
                confirmedCount++;
                totalModuleSize += pattern.getEstimatedModuleSize();
              }
            }
            if (confirmedCount < 3) {
              return false;
            }
            const average = totalModuleSize / max;
            let totalDeviation = 0;
            for (const pattern of this.possibleCenters) {
              totalDeviation += Math.abs(pattern.getEstimatedModuleSize() - average);
            }
            return totalDeviation <= 0.05 * totalModuleSize;
          }
          selectBestPatterns() {
            const startSize = this.possibleCenters.length;
            if (startSize < 3) {
              throw new NotFoundException();
            }
            const possibleCenters = this.possibleCenters;
            let average;
            if (startSize > 3) {
              let totalModuleSize = 0;
              let square = 0;
              for (const center of this.possibleCenters) {
                const size2 = center.getEstimatedModuleSize();
                totalModuleSize += size2;
                square += size2 * size2;
              }
              average = totalModuleSize / startSize;
              let stdDev = Math.sqrt(square / startSize - average * average);
              possibleCenters.sort((center1, center2) => {
                const dA = Math.abs(center2.getEstimatedModuleSize() - average);
                const dB = Math.abs(center1.getEstimatedModuleSize() - average);
                return dA < dB ? -1 : dA > dB ? 1 : 0;
              });
              const limit = Math.max(0.2 * average, stdDev);
              for (let i = 0; i < possibleCenters.length && possibleCenters.length > 3; i++) {
                const pattern = possibleCenters[i];
                if (Math.abs(pattern.getEstimatedModuleSize() - average) > limit) {
                  possibleCenters.splice(i, 1);
                  i--;
                }
              }
            }
            if (possibleCenters.length > 3) {
              let totalModuleSize = 0;
              for (const possibleCenter of possibleCenters) {
                totalModuleSize += possibleCenter.getEstimatedModuleSize();
              }
              average = totalModuleSize / possibleCenters.length;
              possibleCenters.sort((center1, center2) => {
                if (center2.getCount() === center1.getCount()) {
                  const dA = Math.abs(center2.getEstimatedModuleSize() - average);
                  const dB = Math.abs(center1.getEstimatedModuleSize() - average);
                  return dA < dB ? 1 : dA > dB ? -1 : 0;
                } else {
                  return center2.getCount() - center1.getCount();
                }
              });
              possibleCenters.splice(3);
            }
            return [
              possibleCenters[0],
              possibleCenters[1],
              possibleCenters[2]
            ];
          }
        }
        FinderPatternFinder.CENTER_QUORUM = 2;
        FinderPatternFinder.MIN_SKIP = 3;
        FinderPatternFinder.MAX_MODULES = 57;
        class Detector$2 {
          constructor(image) {
            this.image = image;
          }
          getImage() {
            return this.image;
          }
          getResultPointCallback() {
            return this.resultPointCallback;
          }
          detect(hints) {
            this.resultPointCallback = hints === null || hints === void 0 ? null : hints.get(DecodeHintType$1.NEED_RESULT_POINT_CALLBACK);
            const finder = new FinderPatternFinder(this.image, this.resultPointCallback);
            const info = finder.find(hints);
            return this.processFinderPatternInfo(info);
          }
          processFinderPatternInfo(info) {
            const topLeft = info.getTopLeft();
            const topRight = info.getTopRight();
            const bottomLeft = info.getBottomLeft();
            const moduleSize = this.calculateModuleSize(topLeft, topRight, bottomLeft);
            if (moduleSize < 1) {
              throw new NotFoundException("No pattern found in proccess finder.");
            }
            const dimension = Detector$2.computeDimension(topLeft, topRight, bottomLeft, moduleSize);
            const provisionalVersion = Version$1.getProvisionalVersionForDimension(dimension);
            const modulesBetweenFPCenters = provisionalVersion.getDimensionForVersion() - 7;
            let alignmentPattern = null;
            if (provisionalVersion.getAlignmentPatternCenters().length > 0) {
              const bottomRightX = topRight.getX() - topLeft.getX() + bottomLeft.getX();
              const bottomRightY = topRight.getY() - topLeft.getY() + bottomLeft.getY();
              const correctionToTopLeft = 1 - 3 / modulesBetweenFPCenters;
              const estAlignmentX = Math.floor(topLeft.getX() + correctionToTopLeft * (bottomRightX - topLeft.getX()));
              const estAlignmentY = Math.floor(topLeft.getY() + correctionToTopLeft * (bottomRightY - topLeft.getY()));
              for (let i = 4; i <= 16; i <<= 1) {
                try {
                  alignmentPattern = this.findAlignmentInRegion(moduleSize, estAlignmentX, estAlignmentY, i);
                  break;
                } catch (re) {
                  if (!(re instanceof NotFoundException)) {
                    throw re;
                  }
                }
              }
            }
            const transform = Detector$2.createTransform(topLeft, topRight, bottomLeft, alignmentPattern, dimension);
            const bits = Detector$2.sampleGrid(this.image, transform, dimension);
            let points;
            if (alignmentPattern === null) {
              points = [bottomLeft, topLeft, topRight];
            } else {
              points = [bottomLeft, topLeft, topRight, alignmentPattern];
            }
            return new DetectorResult(bits, points);
          }
          static createTransform(topLeft, topRight, bottomLeft, alignmentPattern, dimension) {
            const dimMinusThree = dimension - 3.5;
            let bottomRightX;
            let bottomRightY;
            let sourceBottomRightX;
            let sourceBottomRightY;
            if (alignmentPattern !== null) {
              bottomRightX = alignmentPattern.getX();
              bottomRightY = alignmentPattern.getY();
              sourceBottomRightX = dimMinusThree - 3;
              sourceBottomRightY = sourceBottomRightX;
            } else {
              bottomRightX = topRight.getX() - topLeft.getX() + bottomLeft.getX();
              bottomRightY = topRight.getY() - topLeft.getY() + bottomLeft.getY();
              sourceBottomRightX = dimMinusThree;
              sourceBottomRightY = dimMinusThree;
            }
            return PerspectiveTransform.quadrilateralToQuadrilateral(3.5, 3.5, dimMinusThree, 3.5, sourceBottomRightX, sourceBottomRightY, 3.5, dimMinusThree, topLeft.getX(), topLeft.getY(), topRight.getX(), topRight.getY(), bottomRightX, bottomRightY, bottomLeft.getX(), bottomLeft.getY());
          }
          static sampleGrid(image, transform, dimension) {
            const sampler = GridSamplerInstance.getInstance();
            return sampler.sampleGridWithTransform(image, dimension, dimension, transform);
          }
          static computeDimension(topLeft, topRight, bottomLeft, moduleSize) {
            const tltrCentersDimension = MathUtils.round(ResultPoint.distance(topLeft, topRight) / moduleSize);
            const tlblCentersDimension = MathUtils.round(ResultPoint.distance(topLeft, bottomLeft) / moduleSize);
            let dimension = Math.floor((tltrCentersDimension + tlblCentersDimension) / 2) + 7;
            switch (dimension & 3) {
              case 0:
                dimension++;
                break;
              case 2:
                dimension--;
                break;
              case 3:
                throw new NotFoundException("Dimensions could be not found.");
            }
            return dimension;
          }
          calculateModuleSize(topLeft, topRight, bottomLeft) {
            return (this.calculateModuleSizeOneWay(topLeft, topRight) + this.calculateModuleSizeOneWay(topLeft, bottomLeft)) / 2;
          }
          calculateModuleSizeOneWay(pattern, otherPattern) {
            const moduleSizeEst1 = this.sizeOfBlackWhiteBlackRunBothWays(Math.floor(pattern.getX()), Math.floor(pattern.getY()), Math.floor(otherPattern.getX()), Math.floor(otherPattern.getY()));
            const moduleSizeEst2 = this.sizeOfBlackWhiteBlackRunBothWays(Math.floor(otherPattern.getX()), Math.floor(otherPattern.getY()), Math.floor(pattern.getX()), Math.floor(pattern.getY()));
            if (isNaN(moduleSizeEst1)) {
              return moduleSizeEst2 / 7;
            }
            if (isNaN(moduleSizeEst2)) {
              return moduleSizeEst1 / 7;
            }
            return (moduleSizeEst1 + moduleSizeEst2) / 14;
          }
          sizeOfBlackWhiteBlackRunBothWays(fromX, fromY, toX, toY) {
            let result = this.sizeOfBlackWhiteBlackRun(fromX, fromY, toX, toY);
            let scale = 1;
            let otherToX = fromX - (toX - fromX);
            if (otherToX < 0) {
              scale = fromX / (fromX - otherToX);
              otherToX = 0;
            } else if (otherToX >= this.image.getWidth()) {
              scale = (this.image.getWidth() - 1 - fromX) / (otherToX - fromX);
              otherToX = this.image.getWidth() - 1;
            }
            let otherToY = Math.floor(fromY - (toY - fromY) * scale);
            scale = 1;
            if (otherToY < 0) {
              scale = fromY / (fromY - otherToY);
              otherToY = 0;
            } else if (otherToY >= this.image.getHeight()) {
              scale = (this.image.getHeight() - 1 - fromY) / (otherToY - fromY);
              otherToY = this.image.getHeight() - 1;
            }
            otherToX = Math.floor(fromX + (otherToX - fromX) * scale);
            result += this.sizeOfBlackWhiteBlackRun(fromX, fromY, otherToX, otherToY);
            return result - 1;
          }
          sizeOfBlackWhiteBlackRun(fromX, fromY, toX, toY) {
            const steep = Math.abs(toY - fromY) > Math.abs(toX - fromX);
            if (steep) {
              let temp = fromX;
              fromX = fromY;
              fromY = temp;
              temp = toX;
              toX = toY;
              toY = temp;
            }
            const dx = Math.abs(toX - fromX);
            const dy = Math.abs(toY - fromY);
            let error2 = -dx / 2;
            const xstep = fromX < toX ? 1 : -1;
            const ystep = fromY < toY ? 1 : -1;
            let state = 0;
            const xLimit = toX + xstep;
            for (let x = fromX, y = fromY; x !== xLimit; x += xstep) {
              const realX = steep ? y : x;
              const realY = steep ? x : y;
              if (state === 1 === this.image.get(realX, realY)) {
                if (state === 2) {
                  return MathUtils.distance(x, y, fromX, fromY);
                }
                state++;
              }
              error2 += dy;
              if (error2 > 0) {
                if (y === toY) {
                  break;
                }
                y += ystep;
                error2 -= dx;
              }
            }
            if (state === 2) {
              return MathUtils.distance(toX + xstep, toY, fromX, fromY);
            }
            return NaN;
          }
          findAlignmentInRegion(overallEstModuleSize, estAlignmentX, estAlignmentY, allowanceFactor) {
            const allowance = Math.floor(allowanceFactor * overallEstModuleSize);
            const alignmentAreaLeftX = Math.max(0, estAlignmentX - allowance);
            const alignmentAreaRightX = Math.min(this.image.getWidth() - 1, estAlignmentX + allowance);
            if (alignmentAreaRightX - alignmentAreaLeftX < overallEstModuleSize * 3) {
              throw new NotFoundException("Alignment top exceeds estimated module size.");
            }
            const alignmentAreaTopY = Math.max(0, estAlignmentY - allowance);
            const alignmentAreaBottomY = Math.min(this.image.getHeight() - 1, estAlignmentY + allowance);
            if (alignmentAreaBottomY - alignmentAreaTopY < overallEstModuleSize * 3) {
              throw new NotFoundException("Alignment bottom exceeds estimated module size.");
            }
            const alignmentFinder = new AlignmentPatternFinder(this.image, alignmentAreaLeftX, alignmentAreaTopY, alignmentAreaRightX - alignmentAreaLeftX, alignmentAreaBottomY - alignmentAreaTopY, overallEstModuleSize, this.resultPointCallback);
            return alignmentFinder.find();
          }
        }
        class QRCodeReader {
          constructor() {
            this.decoder = new Decoder$2();
          }
          getDecoder() {
            return this.decoder;
          }
          decode(image, hints) {
            let decoderResult;
            let points;
            if (hints !== void 0 && hints !== null && hints.get(DecodeHintType$1.PURE_BARCODE) !== void 0) {
              const bits = QRCodeReader.extractPureBits(image.getBlackMatrix());
              decoderResult = this.decoder.decodeBitMatrix(bits, hints);
              points = QRCodeReader.NO_POINTS;
            } else {
              const detectorResult = new Detector$2(image.getBlackMatrix()).detect(hints);
              decoderResult = this.decoder.decodeBitMatrix(detectorResult.getBits(), hints);
              points = detectorResult.getPoints();
            }
            if (decoderResult.getOther() instanceof QRCodeDecoderMetaData) {
              decoderResult.getOther().applyMirroredCorrection(points);
            }
            const result = new Result(decoderResult.getText(), decoderResult.getRawBytes(), void 0, points, BarcodeFormat$1.QR_CODE, void 0);
            const byteSegments = decoderResult.getByteSegments();
            if (byteSegments !== null) {
              result.putMetadata(ResultMetadataType$1.BYTE_SEGMENTS, byteSegments);
            }
            const ecLevel = decoderResult.getECLevel();
            if (ecLevel !== null) {
              result.putMetadata(ResultMetadataType$1.ERROR_CORRECTION_LEVEL, ecLevel);
            }
            if (decoderResult.hasStructuredAppend()) {
              result.putMetadata(ResultMetadataType$1.STRUCTURED_APPEND_SEQUENCE, decoderResult.getStructuredAppendSequenceNumber());
              result.putMetadata(ResultMetadataType$1.STRUCTURED_APPEND_PARITY, decoderResult.getStructuredAppendParity());
            }
            return result;
          }
          reset() {
          }
          static extractPureBits(image) {
            const leftTopBlack = image.getTopLeftOnBit();
            const rightBottomBlack = image.getBottomRightOnBit();
            if (leftTopBlack === null || rightBottomBlack === null) {
              throw new NotFoundException();
            }
            const moduleSize = this.moduleSize(leftTopBlack, image);
            let top = leftTopBlack[1];
            let bottom = rightBottomBlack[1];
            let left = leftTopBlack[0];
            let right = rightBottomBlack[0];
            if (left >= right || top >= bottom) {
              throw new NotFoundException();
            }
            if (bottom - top !== right - left) {
              right = left + (bottom - top);
              if (right >= image.getWidth()) {
                throw new NotFoundException();
              }
            }
            const matrixWidth = Math.round((right - left + 1) / moduleSize);
            const matrixHeight = Math.round((bottom - top + 1) / moduleSize);
            if (matrixWidth <= 0 || matrixHeight <= 0) {
              throw new NotFoundException();
            }
            if (matrixHeight !== matrixWidth) {
              throw new NotFoundException();
            }
            const nudge = Math.floor(moduleSize / 2);
            top += nudge;
            left += nudge;
            const nudgedTooFarRight = left + Math.floor((matrixWidth - 1) * moduleSize) - right;
            if (nudgedTooFarRight > 0) {
              if (nudgedTooFarRight > nudge) {
                throw new NotFoundException();
              }
              left -= nudgedTooFarRight;
            }
            const nudgedTooFarDown = top + Math.floor((matrixHeight - 1) * moduleSize) - bottom;
            if (nudgedTooFarDown > 0) {
              if (nudgedTooFarDown > nudge) {
                throw new NotFoundException();
              }
              top -= nudgedTooFarDown;
            }
            const bits = new BitMatrix(matrixWidth, matrixHeight);
            for (let y = 0; y < matrixHeight; y++) {
              const iOffset = top + Math.floor(y * moduleSize);
              for (let x = 0; x < matrixWidth; x++) {
                if (image.get(left + Math.floor(x * moduleSize), iOffset)) {
                  bits.set(x, y);
                }
              }
            }
            return bits;
          }
          static moduleSize(leftTopBlack, image) {
            const height = image.getHeight();
            const width = image.getWidth();
            let x = leftTopBlack[0];
            let y = leftTopBlack[1];
            let inBlack = true;
            let transitions = 0;
            while (x < width && y < height) {
              if (inBlack !== image.get(x, y)) {
                if (++transitions === 5) {
                  break;
                }
                inBlack = !inBlack;
              }
              x++;
              y++;
            }
            if (x === width || y === height) {
              throw new NotFoundException();
            }
            return (x - leftTopBlack[0]) / 7;
          }
        }
        QRCodeReader.NO_POINTS = new Array();
        class PDF417Common {
          PDF417Common() {
          }
          static getBitCountSum(moduleBitCount) {
            return MathUtils.sum(moduleBitCount);
          }
          static toIntArray(list) {
            if (list == null || !list.length) {
              return PDF417Common.EMPTY_INT_ARRAY;
            }
            const result = new Int32Array(list.length);
            let i = 0;
            for (const integer of list) {
              result[i++] = integer;
            }
            return result;
          }
          static getCodeword(symbol) {
            const i = Arrays.binarySearch(PDF417Common.SYMBOL_TABLE, symbol & 262143);
            if (i < 0) {
              return -1;
            }
            return (PDF417Common.CODEWORD_TABLE[i] - 1) % PDF417Common.NUMBER_OF_CODEWORDS;
          }
        }
        PDF417Common.NUMBER_OF_CODEWORDS = 929;
        PDF417Common.MAX_CODEWORDS_IN_BARCODE = PDF417Common.NUMBER_OF_CODEWORDS - 1;
        PDF417Common.MIN_ROWS_IN_BARCODE = 3;
        PDF417Common.MAX_ROWS_IN_BARCODE = 90;
        PDF417Common.MODULES_IN_CODEWORD = 17;
        PDF417Common.MODULES_IN_STOP_PATTERN = 18;
        PDF417Common.BARS_IN_MODULE = 8;
        PDF417Common.EMPTY_INT_ARRAY = new Int32Array([]);
        PDF417Common.SYMBOL_TABLE = Int32Array.from([
          66142,
          66170,
          66206,
          66236,
          66290,
          66292,
          66350,
          66382,
          66396,
          66454,
          66470,
          66476,
          66594,
          66600,
          66614,
          66626,
          66628,
          66632,
          66640,
          66654,
          66662,
          66668,
          66682,
          66690,
          66718,
          66720,
          66748,
          66758,
          66776,
          66798,
          66802,
          66804,
          66820,
          66824,
          66832,
          66846,
          66848,
          66876,
          66880,
          66936,
          66950,
          66956,
          66968,
          66992,
          67006,
          67022,
          67036,
          67042,
          67044,
          67048,
          67062,
          67118,
          67150,
          67164,
          67214,
          67228,
          67256,
          67294,
          67322,
          67350,
          67366,
          67372,
          67398,
          67404,
          67416,
          67438,
          67474,
          67476,
          67490,
          67492,
          67496,
          67510,
          67618,
          67624,
          67650,
          67656,
          67664,
          67678,
          67686,
          67692,
          67706,
          67714,
          67716,
          67728,
          67742,
          67744,
          67772,
          67782,
          67788,
          67800,
          67822,
          67826,
          67828,
          67842,
          67848,
          67870,
          67872,
          67900,
          67904,
          67960,
          67974,
          67992,
          68016,
          68030,
          68046,
          68060,
          68066,
          68068,
          68072,
          68086,
          68104,
          68112,
          68126,
          68128,
          68156,
          68160,
          68216,
          68336,
          68358,
          68364,
          68376,
          68400,
          68414,
          68448,
          68476,
          68494,
          68508,
          68536,
          68546,
          68548,
          68552,
          68560,
          68574,
          68582,
          68588,
          68654,
          68686,
          68700,
          68706,
          68708,
          68712,
          68726,
          68750,
          68764,
          68792,
          68802,
          68804,
          68808,
          68816,
          68830,
          68838,
          68844,
          68858,
          68878,
          68892,
          68920,
          68976,
          68990,
          68994,
          68996,
          69e3,
          69008,
          69022,
          69024,
          69052,
          69062,
          69068,
          69080,
          69102,
          69106,
          69108,
          69142,
          69158,
          69164,
          69190,
          69208,
          69230,
          69254,
          69260,
          69272,
          69296,
          69310,
          69326,
          69340,
          69386,
          69394,
          69396,
          69410,
          69416,
          69430,
          69442,
          69444,
          69448,
          69456,
          69470,
          69478,
          69484,
          69554,
          69556,
          69666,
          69672,
          69698,
          69704,
          69712,
          69726,
          69754,
          69762,
          69764,
          69776,
          69790,
          69792,
          69820,
          69830,
          69836,
          69848,
          69870,
          69874,
          69876,
          69890,
          69918,
          69920,
          69948,
          69952,
          70008,
          70022,
          70040,
          70064,
          70078,
          70094,
          70108,
          70114,
          70116,
          70120,
          70134,
          70152,
          70174,
          70176,
          70264,
          70384,
          70412,
          70448,
          70462,
          70496,
          70524,
          70542,
          70556,
          70584,
          70594,
          70600,
          70608,
          70622,
          70630,
          70636,
          70664,
          70672,
          70686,
          70688,
          70716,
          70720,
          70776,
          70896,
          71136,
          71180,
          71192,
          71216,
          71230,
          71264,
          71292,
          71360,
          71416,
          71452,
          71480,
          71536,
          71550,
          71554,
          71556,
          71560,
          71568,
          71582,
          71584,
          71612,
          71622,
          71628,
          71640,
          71662,
          71726,
          71732,
          71758,
          71772,
          71778,
          71780,
          71784,
          71798,
          71822,
          71836,
          71864,
          71874,
          71880,
          71888,
          71902,
          71910,
          71916,
          71930,
          71950,
          71964,
          71992,
          72048,
          72062,
          72066,
          72068,
          72080,
          72094,
          72096,
          72124,
          72134,
          72140,
          72152,
          72174,
          72178,
          72180,
          72206,
          72220,
          72248,
          72304,
          72318,
          72416,
          72444,
          72456,
          72464,
          72478,
          72480,
          72508,
          72512,
          72568,
          72588,
          72600,
          72624,
          72638,
          72654,
          72668,
          72674,
          72676,
          72680,
          72694,
          72726,
          72742,
          72748,
          72774,
          72780,
          72792,
          72814,
          72838,
          72856,
          72880,
          72894,
          72910,
          72924,
          72930,
          72932,
          72936,
          72950,
          72966,
          72972,
          72984,
          73008,
          73022,
          73056,
          73084,
          73102,
          73116,
          73144,
          73156,
          73160,
          73168,
          73182,
          73190,
          73196,
          73210,
          73226,
          73234,
          73236,
          73250,
          73252,
          73256,
          73270,
          73282,
          73284,
          73296,
          73310,
          73318,
          73324,
          73346,
          73348,
          73352,
          73360,
          73374,
          73376,
          73404,
          73414,
          73420,
          73432,
          73454,
          73498,
          73518,
          73522,
          73524,
          73550,
          73564,
          73570,
          73572,
          73576,
          73590,
          73800,
          73822,
          73858,
          73860,
          73872,
          73886,
          73888,
          73916,
          73944,
          73970,
          73972,
          73992,
          74014,
          74016,
          74044,
          74048,
          74104,
          74118,
          74136,
          74160,
          74174,
          74210,
          74212,
          74216,
          74230,
          74244,
          74256,
          74270,
          74272,
          74360,
          74480,
          74502,
          74508,
          74544,
          74558,
          74592,
          74620,
          74638,
          74652,
          74680,
          74690,
          74696,
          74704,
          74726,
          74732,
          74782,
          74784,
          74812,
          74992,
          75232,
          75288,
          75326,
          75360,
          75388,
          75456,
          75512,
          75576,
          75632,
          75646,
          75650,
          75652,
          75664,
          75678,
          75680,
          75708,
          75718,
          75724,
          75736,
          75758,
          75808,
          75836,
          75840,
          75896,
          76016,
          76256,
          76736,
          76824,
          76848,
          76862,
          76896,
          76924,
          76992,
          77048,
          77296,
          77340,
          77368,
          77424,
          77438,
          77536,
          77564,
          77572,
          77576,
          77584,
          77600,
          77628,
          77632,
          77688,
          77702,
          77708,
          77720,
          77744,
          77758,
          77774,
          77788,
          77870,
          77902,
          77916,
          77922,
          77928,
          77966,
          77980,
          78008,
          78018,
          78024,
          78032,
          78046,
          78060,
          78074,
          78094,
          78136,
          78192,
          78206,
          78210,
          78212,
          78224,
          78238,
          78240,
          78268,
          78278,
          78284,
          78296,
          78322,
          78324,
          78350,
          78364,
          78448,
          78462,
          78560,
          78588,
          78600,
          78622,
          78624,
          78652,
          78656,
          78712,
          78726,
          78744,
          78768,
          78782,
          78798,
          78812,
          78818,
          78820,
          78824,
          78838,
          78862,
          78876,
          78904,
          78960,
          78974,
          79072,
          79100,
          79296,
          79352,
          79368,
          79376,
          79390,
          79392,
          79420,
          79424,
          79480,
          79600,
          79628,
          79640,
          79664,
          79678,
          79712,
          79740,
          79772,
          79800,
          79810,
          79812,
          79816,
          79824,
          79838,
          79846,
          79852,
          79894,
          79910,
          79916,
          79942,
          79948,
          79960,
          79982,
          79988,
          80006,
          80024,
          80048,
          80062,
          80078,
          80092,
          80098,
          80100,
          80104,
          80134,
          80140,
          80176,
          80190,
          80224,
          80252,
          80270,
          80284,
          80312,
          80328,
          80336,
          80350,
          80358,
          80364,
          80378,
          80390,
          80396,
          80408,
          80432,
          80446,
          80480,
          80508,
          80576,
          80632,
          80654,
          80668,
          80696,
          80752,
          80766,
          80776,
          80784,
          80798,
          80800,
          80828,
          80844,
          80856,
          80878,
          80882,
          80884,
          80914,
          80916,
          80930,
          80932,
          80936,
          80950,
          80962,
          80968,
          80976,
          80990,
          80998,
          81004,
          81026,
          81028,
          81040,
          81054,
          81056,
          81084,
          81094,
          81100,
          81112,
          81134,
          81154,
          81156,
          81160,
          81168,
          81182,
          81184,
          81212,
          81216,
          81272,
          81286,
          81292,
          81304,
          81328,
          81342,
          81358,
          81372,
          81380,
          81384,
          81398,
          81434,
          81454,
          81458,
          81460,
          81486,
          81500,
          81506,
          81508,
          81512,
          81526,
          81550,
          81564,
          81592,
          81602,
          81604,
          81608,
          81616,
          81630,
          81638,
          81644,
          81702,
          81708,
          81722,
          81734,
          81740,
          81752,
          81774,
          81778,
          81780,
          82050,
          82078,
          82080,
          82108,
          82180,
          82184,
          82192,
          82206,
          82208,
          82236,
          82240,
          82296,
          82316,
          82328,
          82352,
          82366,
          82402,
          82404,
          82408,
          82440,
          82448,
          82462,
          82464,
          82492,
          82496,
          82552,
          82672,
          82694,
          82700,
          82712,
          82736,
          82750,
          82784,
          82812,
          82830,
          82882,
          82884,
          82888,
          82896,
          82918,
          82924,
          82952,
          82960,
          82974,
          82976,
          83004,
          83008,
          83064,
          83184,
          83424,
          83468,
          83480,
          83504,
          83518,
          83552,
          83580,
          83648,
          83704,
          83740,
          83768,
          83824,
          83838,
          83842,
          83844,
          83848,
          83856,
          83872,
          83900,
          83910,
          83916,
          83928,
          83950,
          83984,
          84e3,
          84028,
          84032,
          84088,
          84208,
          84448,
          84928,
          85040,
          85054,
          85088,
          85116,
          85184,
          85240,
          85488,
          85560,
          85616,
          85630,
          85728,
          85756,
          85764,
          85768,
          85776,
          85790,
          85792,
          85820,
          85824,
          85880,
          85894,
          85900,
          85912,
          85936,
          85966,
          85980,
          86048,
          86080,
          86136,
          86256,
          86496,
          86976,
          88160,
          88188,
          88256,
          88312,
          88560,
          89056,
          89200,
          89214,
          89312,
          89340,
          89536,
          89592,
          89608,
          89616,
          89632,
          89664,
          89720,
          89840,
          89868,
          89880,
          89904,
          89952,
          89980,
          89998,
          90012,
          90040,
          90190,
          90204,
          90254,
          90268,
          90296,
          90306,
          90308,
          90312,
          90334,
          90382,
          90396,
          90424,
          90480,
          90494,
          90500,
          90504,
          90512,
          90526,
          90528,
          90556,
          90566,
          90572,
          90584,
          90610,
          90612,
          90638,
          90652,
          90680,
          90736,
          90750,
          90848,
          90876,
          90884,
          90888,
          90896,
          90910,
          90912,
          90940,
          90944,
          91e3,
          91014,
          91020,
          91032,
          91056,
          91070,
          91086,
          91100,
          91106,
          91108,
          91112,
          91126,
          91150,
          91164,
          91192,
          91248,
          91262,
          91360,
          91388,
          91584,
          91640,
          91664,
          91678,
          91680,
          91708,
          91712,
          91768,
          91888,
          91928,
          91952,
          91966,
          92e3,
          92028,
          92046,
          92060,
          92088,
          92098,
          92100,
          92104,
          92112,
          92126,
          92134,
          92140,
          92188,
          92216,
          92272,
          92384,
          92412,
          92608,
          92664,
          93168,
          93200,
          93214,
          93216,
          93244,
          93248,
          93304,
          93424,
          93664,
          93720,
          93744,
          93758,
          93792,
          93820,
          93888,
          93944,
          93980,
          94008,
          94064,
          94078,
          94084,
          94088,
          94096,
          94110,
          94112,
          94140,
          94150,
          94156,
          94168,
          94246,
          94252,
          94278,
          94284,
          94296,
          94318,
          94342,
          94348,
          94360,
          94384,
          94398,
          94414,
          94428,
          94440,
          94470,
          94476,
          94488,
          94512,
          94526,
          94560,
          94588,
          94606,
          94620,
          94648,
          94658,
          94660,
          94664,
          94672,
          94686,
          94694,
          94700,
          94714,
          94726,
          94732,
          94744,
          94768,
          94782,
          94816,
          94844,
          94912,
          94968,
          94990,
          95004,
          95032,
          95088,
          95102,
          95112,
          95120,
          95134,
          95136,
          95164,
          95180,
          95192,
          95214,
          95218,
          95220,
          95244,
          95256,
          95280,
          95294,
          95328,
          95356,
          95424,
          95480,
          95728,
          95758,
          95772,
          95800,
          95856,
          95870,
          95968,
          95996,
          96008,
          96016,
          96030,
          96032,
          96060,
          96064,
          96120,
          96152,
          96176,
          96190,
          96220,
          96226,
          96228,
          96232,
          96290,
          96292,
          96296,
          96310,
          96322,
          96324,
          96328,
          96336,
          96350,
          96358,
          96364,
          96386,
          96388,
          96392,
          96400,
          96414,
          96416,
          96444,
          96454,
          96460,
          96472,
          96494,
          96498,
          96500,
          96514,
          96516,
          96520,
          96528,
          96542,
          96544,
          96572,
          96576,
          96632,
          96646,
          96652,
          96664,
          96688,
          96702,
          96718,
          96732,
          96738,
          96740,
          96744,
          96758,
          96772,
          96776,
          96784,
          96798,
          96800,
          96828,
          96832,
          96888,
          97008,
          97030,
          97036,
          97048,
          97072,
          97086,
          97120,
          97148,
          97166,
          97180,
          97208,
          97220,
          97224,
          97232,
          97246,
          97254,
          97260,
          97326,
          97330,
          97332,
          97358,
          97372,
          97378,
          97380,
          97384,
          97398,
          97422,
          97436,
          97464,
          97474,
          97476,
          97480,
          97488,
          97502,
          97510,
          97516,
          97550,
          97564,
          97592,
          97648,
          97666,
          97668,
          97672,
          97680,
          97694,
          97696,
          97724,
          97734,
          97740,
          97752,
          97774,
          97830,
          97836,
          97850,
          97862,
          97868,
          97880,
          97902,
          97906,
          97908,
          97926,
          97932,
          97944,
          97968,
          97998,
          98012,
          98018,
          98020,
          98024,
          98038,
          98618,
          98674,
          98676,
          98838,
          98854,
          98874,
          98892,
          98904,
          98926,
          98930,
          98932,
          98968,
          99006,
          99042,
          99044,
          99048,
          99062,
          99166,
          99194,
          99246,
          99286,
          99350,
          99366,
          99372,
          99386,
          99398,
          99416,
          99438,
          99442,
          99444,
          99462,
          99504,
          99518,
          99534,
          99548,
          99554,
          99556,
          99560,
          99574,
          99590,
          99596,
          99608,
          99632,
          99646,
          99680,
          99708,
          99726,
          99740,
          99768,
          99778,
          99780,
          99784,
          99792,
          99806,
          99814,
          99820,
          99834,
          99858,
          99860,
          99874,
          99880,
          99894,
          99906,
          99920,
          99934,
          99962,
          99970,
          99972,
          99976,
          99984,
          99998,
          1e5,
          100028,
          100038,
          100044,
          100056,
          100078,
          100082,
          100084,
          100142,
          100174,
          100188,
          100246,
          100262,
          100268,
          100306,
          100308,
          100390,
          100396,
          100410,
          100422,
          100428,
          100440,
          100462,
          100466,
          100468,
          100486,
          100504,
          100528,
          100542,
          100558,
          100572,
          100578,
          100580,
          100584,
          100598,
          100620,
          100656,
          100670,
          100704,
          100732,
          100750,
          100792,
          100802,
          100808,
          100816,
          100830,
          100838,
          100844,
          100858,
          100888,
          100912,
          100926,
          100960,
          100988,
          101056,
          101112,
          101148,
          101176,
          101232,
          101246,
          101250,
          101252,
          101256,
          101264,
          101278,
          101280,
          101308,
          101318,
          101324,
          101336,
          101358,
          101362,
          101364,
          101410,
          101412,
          101416,
          101430,
          101442,
          101448,
          101456,
          101470,
          101478,
          101498,
          101506,
          101508,
          101520,
          101534,
          101536,
          101564,
          101580,
          101618,
          101620,
          101636,
          101640,
          101648,
          101662,
          101664,
          101692,
          101696,
          101752,
          101766,
          101784,
          101838,
          101858,
          101860,
          101864,
          101934,
          101938,
          101940,
          101966,
          101980,
          101986,
          101988,
          101992,
          102030,
          102044,
          102072,
          102082,
          102084,
          102088,
          102096,
          102138,
          102166,
          102182,
          102188,
          102214,
          102220,
          102232,
          102254,
          102282,
          102290,
          102292,
          102306,
          102308,
          102312,
          102326,
          102444,
          102458,
          102470,
          102476,
          102488,
          102514,
          102516,
          102534,
          102552,
          102576,
          102590,
          102606,
          102620,
          102626,
          102632,
          102646,
          102662,
          102668,
          102704,
          102718,
          102752,
          102780,
          102798,
          102812,
          102840,
          102850,
          102856,
          102864,
          102878,
          102886,
          102892,
          102906,
          102936,
          102974,
          103008,
          103036,
          103104,
          103160,
          103224,
          103280,
          103294,
          103298,
          103300,
          103312,
          103326,
          103328,
          103356,
          103366,
          103372,
          103384,
          103406,
          103410,
          103412,
          103472,
          103486,
          103520,
          103548,
          103616,
          103672,
          103920,
          103992,
          104048,
          104062,
          104160,
          104188,
          104194,
          104196,
          104200,
          104208,
          104224,
          104252,
          104256,
          104312,
          104326,
          104332,
          104344,
          104368,
          104382,
          104398,
          104412,
          104418,
          104420,
          104424,
          104482,
          104484,
          104514,
          104520,
          104528,
          104542,
          104550,
          104570,
          104578,
          104580,
          104592,
          104606,
          104608,
          104636,
          104652,
          104690,
          104692,
          104706,
          104712,
          104734,
          104736,
          104764,
          104768,
          104824,
          104838,
          104856,
          104910,
          104930,
          104932,
          104936,
          104968,
          104976,
          104990,
          104992,
          105020,
          105024,
          105080,
          105200,
          105240,
          105278,
          105312,
          105372,
          105410,
          105412,
          105416,
          105424,
          105446,
          105518,
          105524,
          105550,
          105564,
          105570,
          105572,
          105576,
          105614,
          105628,
          105656,
          105666,
          105672,
          105680,
          105702,
          105722,
          105742,
          105756,
          105784,
          105840,
          105854,
          105858,
          105860,
          105864,
          105872,
          105888,
          105932,
          105970,
          105972,
          106006,
          106022,
          106028,
          106054,
          106060,
          106072,
          106100,
          106118,
          106124,
          106136,
          106160,
          106174,
          106190,
          106210,
          106212,
          106216,
          106250,
          106258,
          106260,
          106274,
          106276,
          106280,
          106306,
          106308,
          106312,
          106320,
          106334,
          106348,
          106394,
          106414,
          106418,
          106420,
          106566,
          106572,
          106610,
          106612,
          106630,
          106636,
          106648,
          106672,
          106686,
          106722,
          106724,
          106728,
          106742,
          106758,
          106764,
          106776,
          106800,
          106814,
          106848,
          106876,
          106894,
          106908,
          106936,
          106946,
          106948,
          106952,
          106960,
          106974,
          106982,
          106988,
          107032,
          107056,
          107070,
          107104,
          107132,
          107200,
          107256,
          107292,
          107320,
          107376,
          107390,
          107394,
          107396,
          107400,
          107408,
          107422,
          107424,
          107452,
          107462,
          107468,
          107480,
          107502,
          107506,
          107508,
          107544,
          107568,
          107582,
          107616,
          107644,
          107712,
          107768,
          108016,
          108060,
          108088,
          108144,
          108158,
          108256,
          108284,
          108290,
          108292,
          108296,
          108304,
          108318,
          108320,
          108348,
          108352,
          108408,
          108422,
          108428,
          108440,
          108464,
          108478,
          108494,
          108508,
          108514,
          108516,
          108520,
          108592,
          108640,
          108668,
          108736,
          108792,
          109040,
          109536,
          109680,
          109694,
          109792,
          109820,
          110016,
          110072,
          110084,
          110088,
          110096,
          110112,
          110140,
          110144,
          110200,
          110320,
          110342,
          110348,
          110360,
          110384,
          110398,
          110432,
          110460,
          110478,
          110492,
          110520,
          110532,
          110536,
          110544,
          110558,
          110658,
          110686,
          110714,
          110722,
          110724,
          110728,
          110736,
          110750,
          110752,
          110780,
          110796,
          110834,
          110836,
          110850,
          110852,
          110856,
          110864,
          110878,
          110880,
          110908,
          110912,
          110968,
          110982,
          111e3,
          111054,
          111074,
          111076,
          111080,
          111108,
          111112,
          111120,
          111134,
          111136,
          111164,
          111168,
          111224,
          111344,
          111372,
          111422,
          111456,
          111516,
          111554,
          111556,
          111560,
          111568,
          111590,
          111632,
          111646,
          111648,
          111676,
          111680,
          111736,
          111856,
          112096,
          112152,
          112224,
          112252,
          112320,
          112440,
          112514,
          112516,
          112520,
          112528,
          112542,
          112544,
          112588,
          112686,
          112718,
          112732,
          112782,
          112796,
          112824,
          112834,
          112836,
          112840,
          112848,
          112870,
          112890,
          112910,
          112924,
          112952,
          113008,
          113022,
          113026,
          113028,
          113032,
          113040,
          113054,
          113056,
          113100,
          113138,
          113140,
          113166,
          113180,
          113208,
          113264,
          113278,
          113376,
          113404,
          113416,
          113424,
          113440,
          113468,
          113472,
          113560,
          113614,
          113634,
          113636,
          113640,
          113686,
          113702,
          113708,
          113734,
          113740,
          113752,
          113778,
          113780,
          113798,
          113804,
          113816,
          113840,
          113854,
          113870,
          113890,
          113892,
          113896,
          113926,
          113932,
          113944,
          113968,
          113982,
          114016,
          114044,
          114076,
          114114,
          114116,
          114120,
          114128,
          114150,
          114170,
          114194,
          114196,
          114210,
          114212,
          114216,
          114242,
          114244,
          114248,
          114256,
          114270,
          114278,
          114306,
          114308,
          114312,
          114320,
          114334,
          114336,
          114364,
          114380,
          114420,
          114458,
          114478,
          114482,
          114484,
          114510,
          114524,
          114530,
          114532,
          114536,
          114842,
          114866,
          114868,
          114970,
          114994,
          114996,
          115042,
          115044,
          115048,
          115062,
          115130,
          115226,
          115250,
          115252,
          115278,
          115292,
          115298,
          115300,
          115304,
          115318,
          115342,
          115394,
          115396,
          115400,
          115408,
          115422,
          115430,
          115436,
          115450,
          115478,
          115494,
          115514,
          115526,
          115532,
          115570,
          115572,
          115738,
          115758,
          115762,
          115764,
          115790,
          115804,
          115810,
          115812,
          115816,
          115830,
          115854,
          115868,
          115896,
          115906,
          115912,
          115920,
          115934,
          115942,
          115948,
          115962,
          115996,
          116024,
          116080,
          116094,
          116098,
          116100,
          116104,
          116112,
          116126,
          116128,
          116156,
          116166,
          116172,
          116184,
          116206,
          116210,
          116212,
          116246,
          116262,
          116268,
          116282,
          116294,
          116300,
          116312,
          116334,
          116338,
          116340,
          116358,
          116364,
          116376,
          116400,
          116414,
          116430,
          116444,
          116450,
          116452,
          116456,
          116498,
          116500,
          116514,
          116520,
          116534,
          116546,
          116548,
          116552,
          116560,
          116574,
          116582,
          116588,
          116602,
          116654,
          116694,
          116714,
          116762,
          116782,
          116786,
          116788,
          116814,
          116828,
          116834,
          116836,
          116840,
          116854,
          116878,
          116892,
          116920,
          116930,
          116936,
          116944,
          116958,
          116966,
          116972,
          116986,
          117006,
          117048,
          117104,
          117118,
          117122,
          117124,
          117136,
          117150,
          117152,
          117180,
          117190,
          117196,
          117208,
          117230,
          117234,
          117236,
          117304,
          117360,
          117374,
          117472,
          117500,
          117506,
          117508,
          117512,
          117520,
          117536,
          117564,
          117568,
          117624,
          117638,
          117644,
          117656,
          117680,
          117694,
          117710,
          117724,
          117730,
          117732,
          117736,
          117750,
          117782,
          117798,
          117804,
          117818,
          117830,
          117848,
          117874,
          117876,
          117894,
          117936,
          117950,
          117966,
          117986,
          117988,
          117992,
          118022,
          118028,
          118040,
          118064,
          118078,
          118112,
          118140,
          118172,
          118210,
          118212,
          118216,
          118224,
          118238,
          118246,
          118266,
          118306,
          118312,
          118338,
          118352,
          118366,
          118374,
          118394,
          118402,
          118404,
          118408,
          118416,
          118430,
          118432,
          118460,
          118476,
          118514,
          118516,
          118574,
          118578,
          118580,
          118606,
          118620,
          118626,
          118628,
          118632,
          118678,
          118694,
          118700,
          118730,
          118738,
          118740,
          118830,
          118834,
          118836,
          118862,
          118876,
          118882,
          118884,
          118888,
          118902,
          118926,
          118940,
          118968,
          118978,
          118980,
          118984,
          118992,
          119006,
          119014,
          119020,
          119034,
          119068,
          119096,
          119152,
          119166,
          119170,
          119172,
          119176,
          119184,
          119198,
          119200,
          119228,
          119238,
          119244,
          119256,
          119278,
          119282,
          119284,
          119324,
          119352,
          119408,
          119422,
          119520,
          119548,
          119554,
          119556,
          119560,
          119568,
          119582,
          119584,
          119612,
          119616,
          119672,
          119686,
          119692,
          119704,
          119728,
          119742,
          119758,
          119772,
          119778,
          119780,
          119784,
          119798,
          119920,
          119934,
          120032,
          120060,
          120256,
          120312,
          120324,
          120328,
          120336,
          120352,
          120384,
          120440,
          120560,
          120582,
          120588,
          120600,
          120624,
          120638,
          120672,
          120700,
          120718,
          120732,
          120760,
          120770,
          120772,
          120776,
          120784,
          120798,
          120806,
          120812,
          120870,
          120876,
          120890,
          120902,
          120908,
          120920,
          120946,
          120948,
          120966,
          120972,
          120984,
          121008,
          121022,
          121038,
          121058,
          121060,
          121064,
          121078,
          121100,
          121112,
          121136,
          121150,
          121184,
          121212,
          121244,
          121282,
          121284,
          121288,
          121296,
          121318,
          121338,
          121356,
          121368,
          121392,
          121406,
          121440,
          121468,
          121536,
          121592,
          121656,
          121730,
          121732,
          121736,
          121744,
          121758,
          121760,
          121804,
          121842,
          121844,
          121890,
          121922,
          121924,
          121928,
          121936,
          121950,
          121958,
          121978,
          121986,
          121988,
          121992,
          122e3,
          122014,
          122016,
          122044,
          122060,
          122098,
          122100,
          122116,
          122120,
          122128,
          122142,
          122144,
          122172,
          122176,
          122232,
          122246,
          122264,
          122318,
          122338,
          122340,
          122344,
          122414,
          122418,
          122420,
          122446,
          122460,
          122466,
          122468,
          122472,
          122510,
          122524,
          122552,
          122562,
          122564,
          122568,
          122576,
          122598,
          122618,
          122646,
          122662,
          122668,
          122694,
          122700,
          122712,
          122738,
          122740,
          122762,
          122770,
          122772,
          122786,
          122788,
          122792,
          123018,
          123026,
          123028,
          123042,
          123044,
          123048,
          123062,
          123098,
          123146,
          123154,
          123156,
          123170,
          123172,
          123176,
          123190,
          123202,
          123204,
          123208,
          123216,
          123238,
          123244,
          123258,
          123290,
          123314,
          123316,
          123402,
          123410,
          123412,
          123426,
          123428,
          123432,
          123446,
          123458,
          123464,
          123472,
          123486,
          123494,
          123500,
          123514,
          123522,
          123524,
          123528,
          123536,
          123552,
          123580,
          123590,
          123596,
          123608,
          123630,
          123634,
          123636,
          123674,
          123698,
          123700,
          123740,
          123746,
          123748,
          123752,
          123834,
          123914,
          123922,
          123924,
          123938,
          123944,
          123958,
          123970,
          123976,
          123984,
          123998,
          124006,
          124012,
          124026,
          124034,
          124036,
          124048,
          124062,
          124064,
          124092,
          124102,
          124108,
          124120,
          124142,
          124146,
          124148,
          124162,
          124164,
          124168,
          124176,
          124190,
          124192,
          124220,
          124224,
          124280,
          124294,
          124300,
          124312,
          124336,
          124350,
          124366,
          124380,
          124386,
          124388,
          124392,
          124406,
          124442,
          124462,
          124466,
          124468,
          124494,
          124508,
          124514,
          124520,
          124558,
          124572,
          124600,
          124610,
          124612,
          124616,
          124624,
          124646,
          124666,
          124694,
          124710,
          124716,
          124730,
          124742,
          124748,
          124760,
          124786,
          124788,
          124818,
          124820,
          124834,
          124836,
          124840,
          124854,
          124946,
          124948,
          124962,
          124964,
          124968,
          124982,
          124994,
          124996,
          125e3,
          125008,
          125022,
          125030,
          125036,
          125050,
          125058,
          125060,
          125064,
          125072,
          125086,
          125088,
          125116,
          125126,
          125132,
          125144,
          125166,
          125170,
          125172,
          125186,
          125188,
          125192,
          125200,
          125216,
          125244,
          125248,
          125304,
          125318,
          125324,
          125336,
          125360,
          125374,
          125390,
          125404,
          125410,
          125412,
          125416,
          125430,
          125444,
          125448,
          125456,
          125472,
          125504,
          125560,
          125680,
          125702,
          125708,
          125720,
          125744,
          125758,
          125792,
          125820,
          125838,
          125852,
          125880,
          125890,
          125892,
          125896,
          125904,
          125918,
          125926,
          125932,
          125978,
          125998,
          126002,
          126004,
          126030,
          126044,
          126050,
          126052,
          126056,
          126094,
          126108,
          126136,
          126146,
          126148,
          126152,
          126160,
          126182,
          126202,
          126222,
          126236,
          126264,
          126320,
          126334,
          126338,
          126340,
          126344,
          126352,
          126366,
          126368,
          126412,
          126450,
          126452,
          126486,
          126502,
          126508,
          126522,
          126534,
          126540,
          126552,
          126574,
          126578,
          126580,
          126598,
          126604,
          126616,
          126640,
          126654,
          126670,
          126684,
          126690,
          126692,
          126696,
          126738,
          126754,
          126756,
          126760,
          126774,
          126786,
          126788,
          126792,
          126800,
          126814,
          126822,
          126828,
          126842,
          126894,
          126898,
          126900,
          126934,
          127126,
          127142,
          127148,
          127162,
          127178,
          127186,
          127188,
          127254,
          127270,
          127276,
          127290,
          127302,
          127308,
          127320,
          127342,
          127346,
          127348,
          127370,
          127378,
          127380,
          127394,
          127396,
          127400,
          127450,
          127510,
          127526,
          127532,
          127546,
          127558,
          127576,
          127598,
          127602,
          127604,
          127622,
          127628,
          127640,
          127664,
          127678,
          127694,
          127708,
          127714,
          127716,
          127720,
          127734,
          127754,
          127762,
          127764,
          127778,
          127784,
          127810,
          127812,
          127816,
          127824,
          127838,
          127846,
          127866,
          127898,
          127918,
          127922,
          127924,
          128022,
          128038,
          128044,
          128058,
          128070,
          128076,
          128088,
          128110,
          128114,
          128116,
          128134,
          128140,
          128152,
          128176,
          128190,
          128206,
          128220,
          128226,
          128228,
          128232,
          128246,
          128262,
          128268,
          128280,
          128304,
          128318,
          128352,
          128380,
          128398,
          128412,
          128440,
          128450,
          128452,
          128456,
          128464,
          128478,
          128486,
          128492,
          128506,
          128522,
          128530,
          128532,
          128546,
          128548,
          128552,
          128566,
          128578,
          128580,
          128584,
          128592,
          128606,
          128614,
          128634,
          128642,
          128644,
          128648,
          128656,
          128670,
          128672,
          128700,
          128716,
          128754,
          128756,
          128794,
          128814,
          128818,
          128820,
          128846,
          128860,
          128866,
          128868,
          128872,
          128886,
          128918,
          128934,
          128940,
          128954,
          128978,
          128980,
          129178,
          129198,
          129202,
          129204,
          129238,
          129258,
          129306,
          129326,
          129330,
          129332,
          129358,
          129372,
          129378,
          129380,
          129384,
          129398,
          129430,
          129446,
          129452,
          129466,
          129482,
          129490,
          129492,
          129562,
          129582,
          129586,
          129588,
          129614,
          129628,
          129634,
          129636,
          129640,
          129654,
          129678,
          129692,
          129720,
          129730,
          129732,
          129736,
          129744,
          129758,
          129766,
          129772,
          129814,
          129830,
          129836,
          129850,
          129862,
          129868,
          129880,
          129902,
          129906,
          129908,
          129930,
          129938,
          129940,
          129954,
          129956,
          129960,
          129974,
          130010
        ]);
        PDF417Common.CODEWORD_TABLE = Int32Array.from([
          2627,
          1819,
          2622,
          2621,
          1813,
          1812,
          2729,
          2724,
          2723,
          2779,
          2774,
          2773,
          902,
          896,
          908,
          868,
          865,
          861,
          859,
          2511,
          873,
          871,
          1780,
          835,
          2493,
          825,
          2491,
          842,
          837,
          844,
          1764,
          1762,
          811,
          810,
          809,
          2483,
          807,
          2482,
          806,
          2480,
          815,
          814,
          813,
          812,
          2484,
          817,
          816,
          1745,
          1744,
          1742,
          1746,
          2655,
          2637,
          2635,
          2626,
          2625,
          2623,
          2628,
          1820,
          2752,
          2739,
          2737,
          2728,
          2727,
          2725,
          2730,
          2785,
          2783,
          2778,
          2777,
          2775,
          2780,
          787,
          781,
          747,
          739,
          736,
          2413,
          754,
          752,
          1719,
          692,
          689,
          681,
          2371,
          678,
          2369,
          700,
          697,
          694,
          703,
          1688,
          1686,
          642,
          638,
          2343,
          631,
          2341,
          627,
          2338,
          651,
          646,
          643,
          2345,
          654,
          652,
          1652,
          1650,
          1647,
          1654,
          601,
          599,
          2322,
          596,
          2321,
          594,
          2319,
          2317,
          611,
          610,
          608,
          606,
          2324,
          603,
          2323,
          615,
          614,
          612,
          1617,
          1616,
          1614,
          1612,
          616,
          1619,
          1618,
          2575,
          2538,
          2536,
          905,
          901,
          898,
          909,
          2509,
          2507,
          2504,
          870,
          867,
          864,
          860,
          2512,
          875,
          872,
          1781,
          2490,
          2489,
          2487,
          2485,
          1748,
          836,
          834,
          832,
          830,
          2494,
          827,
          2492,
          843,
          841,
          839,
          845,
          1765,
          1763,
          2701,
          2676,
          2674,
          2653,
          2648,
          2656,
          2634,
          2633,
          2631,
          2629,
          1821,
          2638,
          2636,
          2770,
          2763,
          2761,
          2750,
          2745,
          2753,
          2736,
          2735,
          2733,
          2731,
          1848,
          2740,
          2738,
          2786,
          2784,
          591,
          588,
          576,
          569,
          566,
          2296,
          1590,
          537,
          534,
          526,
          2276,
          522,
          2274,
          545,
          542,
          539,
          548,
          1572,
          1570,
          481,
          2245,
          466,
          2242,
          462,
          2239,
          492,
          485,
          482,
          2249,
          496,
          494,
          1534,
          1531,
          1528,
          1538,
          413,
          2196,
          406,
          2191,
          2188,
          425,
          419,
          2202,
          415,
          2199,
          432,
          430,
          427,
          1472,
          1467,
          1464,
          433,
          1476,
          1474,
          368,
          367,
          2160,
          365,
          2159,
          362,
          2157,
          2155,
          2152,
          378,
          377,
          375,
          2166,
          372,
          2165,
          369,
          2162,
          383,
          381,
          379,
          2168,
          1419,
          1418,
          1416,
          1414,
          385,
          1411,
          384,
          1423,
          1422,
          1420,
          1424,
          2461,
          802,
          2441,
          2439,
          790,
          786,
          783,
          794,
          2409,
          2406,
          2403,
          750,
          742,
          738,
          2414,
          756,
          753,
          1720,
          2367,
          2365,
          2362,
          2359,
          1663,
          693,
          691,
          684,
          2373,
          680,
          2370,
          702,
          699,
          696,
          704,
          1690,
          1687,
          2337,
          2336,
          2334,
          2332,
          1624,
          2329,
          1622,
          640,
          637,
          2344,
          634,
          2342,
          630,
          2340,
          650,
          648,
          645,
          2346,
          655,
          653,
          1653,
          1651,
          1649,
          1655,
          2612,
          2597,
          2595,
          2571,
          2568,
          2565,
          2576,
          2534,
          2529,
          2526,
          1787,
          2540,
          2537,
          907,
          904,
          900,
          910,
          2503,
          2502,
          2500,
          2498,
          1768,
          2495,
          1767,
          2510,
          2508,
          2506,
          869,
          866,
          863,
          2513,
          876,
          874,
          1782,
          2720,
          2713,
          2711,
          2697,
          2694,
          2691,
          2702,
          2672,
          2670,
          2664,
          1828,
          2678,
          2675,
          2647,
          2646,
          2644,
          2642,
          1823,
          2639,
          1822,
          2654,
          2652,
          2650,
          2657,
          2771,
          1855,
          2765,
          2762,
          1850,
          1849,
          2751,
          2749,
          2747,
          2754,
          353,
          2148,
          344,
          342,
          336,
          2142,
          332,
          2140,
          345,
          1375,
          1373,
          306,
          2130,
          299,
          2128,
          295,
          2125,
          319,
          314,
          311,
          2132,
          1354,
          1352,
          1349,
          1356,
          262,
          257,
          2101,
          253,
          2096,
          2093,
          274,
          273,
          267,
          2107,
          263,
          2104,
          280,
          278,
          275,
          1316,
          1311,
          1308,
          1320,
          1318,
          2052,
          202,
          2050,
          2044,
          2040,
          219,
          2063,
          212,
          2060,
          208,
          2055,
          224,
          221,
          2066,
          1260,
          1258,
          1252,
          231,
          1248,
          229,
          1266,
          1264,
          1261,
          1268,
          155,
          1998,
          153,
          1996,
          1994,
          1991,
          1988,
          165,
          164,
          2007,
          162,
          2006,
          159,
          2003,
          2e3,
          172,
          171,
          169,
          2012,
          166,
          2010,
          1186,
          1184,
          1182,
          1179,
          175,
          1176,
          173,
          1192,
          1191,
          1189,
          1187,
          176,
          1194,
          1193,
          2313,
          2307,
          2305,
          592,
          589,
          2294,
          2292,
          2289,
          578,
          572,
          568,
          2297,
          580,
          1591,
          2272,
          2267,
          2264,
          1547,
          538,
          536,
          529,
          2278,
          525,
          2275,
          547,
          544,
          541,
          1574,
          1571,
          2237,
          2235,
          2229,
          1493,
          2225,
          1489,
          478,
          2247,
          470,
          2244,
          465,
          2241,
          493,
          488,
          484,
          2250,
          498,
          495,
          1536,
          1533,
          1530,
          1539,
          2187,
          2186,
          2184,
          2182,
          1432,
          2179,
          1430,
          2176,
          1427,
          414,
          412,
          2197,
          409,
          2195,
          405,
          2193,
          2190,
          426,
          424,
          421,
          2203,
          418,
          2201,
          431,
          429,
          1473,
          1471,
          1469,
          1466,
          434,
          1477,
          1475,
          2478,
          2472,
          2470,
          2459,
          2457,
          2454,
          2462,
          803,
          2437,
          2432,
          2429,
          1726,
          2443,
          2440,
          792,
          789,
          785,
          2401,
          2399,
          2393,
          1702,
          2389,
          1699,
          2411,
          2408,
          2405,
          745,
          741,
          2415,
          758,
          755,
          1721,
          2358,
          2357,
          2355,
          2353,
          1661,
          2350,
          1660,
          2347,
          1657,
          2368,
          2366,
          2364,
          2361,
          1666,
          690,
          687,
          2374,
          683,
          2372,
          701,
          698,
          705,
          1691,
          1689,
          2619,
          2617,
          2610,
          2608,
          2605,
          2613,
          2593,
          2588,
          2585,
          1803,
          2599,
          2596,
          2563,
          2561,
          2555,
          1797,
          2551,
          1795,
          2573,
          2570,
          2567,
          2577,
          2525,
          2524,
          2522,
          2520,
          1786,
          2517,
          1785,
          2514,
          1783,
          2535,
          2533,
          2531,
          2528,
          1788,
          2541,
          2539,
          906,
          903,
          911,
          2721,
          1844,
          2715,
          2712,
          1838,
          1836,
          2699,
          2696,
          2693,
          2703,
          1827,
          1826,
          1824,
          2673,
          2671,
          2669,
          2666,
          1829,
          2679,
          2677,
          1858,
          1857,
          2772,
          1854,
          1853,
          1851,
          1856,
          2766,
          2764,
          143,
          1987,
          139,
          1986,
          135,
          133,
          131,
          1984,
          128,
          1983,
          125,
          1981,
          138,
          137,
          136,
          1985,
          1133,
          1132,
          1130,
          112,
          110,
          1974,
          107,
          1973,
          104,
          1971,
          1969,
          122,
          121,
          119,
          117,
          1977,
          114,
          1976,
          124,
          1115,
          1114,
          1112,
          1110,
          1117,
          1116,
          84,
          83,
          1953,
          81,
          1952,
          78,
          1950,
          1948,
          1945,
          94,
          93,
          91,
          1959,
          88,
          1958,
          85,
          1955,
          99,
          97,
          95,
          1961,
          1086,
          1085,
          1083,
          1081,
          1078,
          100,
          1090,
          1089,
          1087,
          1091,
          49,
          47,
          1917,
          44,
          1915,
          1913,
          1910,
          1907,
          59,
          1926,
          56,
          1925,
          53,
          1922,
          1919,
          66,
          64,
          1931,
          61,
          1929,
          1042,
          1040,
          1038,
          71,
          1035,
          70,
          1032,
          68,
          1048,
          1047,
          1045,
          1043,
          1050,
          1049,
          12,
          10,
          1869,
          1867,
          1864,
          1861,
          21,
          1880,
          19,
          1877,
          1874,
          1871,
          28,
          1888,
          25,
          1886,
          22,
          1883,
          982,
          980,
          977,
          974,
          32,
          30,
          991,
          989,
          987,
          984,
          34,
          995,
          994,
          992,
          2151,
          2150,
          2147,
          2146,
          2144,
          356,
          355,
          354,
          2149,
          2139,
          2138,
          2136,
          2134,
          1359,
          343,
          341,
          338,
          2143,
          335,
          2141,
          348,
          347,
          346,
          1376,
          1374,
          2124,
          2123,
          2121,
          2119,
          1326,
          2116,
          1324,
          310,
          308,
          305,
          2131,
          302,
          2129,
          298,
          2127,
          320,
          318,
          316,
          313,
          2133,
          322,
          321,
          1355,
          1353,
          1351,
          1357,
          2092,
          2091,
          2089,
          2087,
          1276,
          2084,
          1274,
          2081,
          1271,
          259,
          2102,
          256,
          2100,
          252,
          2098,
          2095,
          272,
          269,
          2108,
          266,
          2106,
          281,
          279,
          277,
          1317,
          1315,
          1313,
          1310,
          282,
          1321,
          1319,
          2039,
          2037,
          2035,
          2032,
          1203,
          2029,
          1200,
          1197,
          207,
          2053,
          205,
          2051,
          201,
          2049,
          2046,
          2043,
          220,
          218,
          2064,
          215,
          2062,
          211,
          2059,
          228,
          226,
          223,
          2069,
          1259,
          1257,
          1254,
          232,
          1251,
          230,
          1267,
          1265,
          1263,
          2316,
          2315,
          2312,
          2311,
          2309,
          2314,
          2304,
          2303,
          2301,
          2299,
          1593,
          2308,
          2306,
          590,
          2288,
          2287,
          2285,
          2283,
          1578,
          2280,
          1577,
          2295,
          2293,
          2291,
          579,
          577,
          574,
          571,
          2298,
          582,
          581,
          1592,
          2263,
          2262,
          2260,
          2258,
          1545,
          2255,
          1544,
          2252,
          1541,
          2273,
          2271,
          2269,
          2266,
          1550,
          535,
          532,
          2279,
          528,
          2277,
          546,
          543,
          549,
          1575,
          1573,
          2224,
          2222,
          2220,
          1486,
          2217,
          1485,
          2214,
          1482,
          1479,
          2238,
          2236,
          2234,
          2231,
          1496,
          2228,
          1492,
          480,
          477,
          2248,
          473,
          2246,
          469,
          2243,
          490,
          487,
          2251,
          497,
          1537,
          1535,
          1532,
          2477,
          2476,
          2474,
          2479,
          2469,
          2468,
          2466,
          2464,
          1730,
          2473,
          2471,
          2453,
          2452,
          2450,
          2448,
          1729,
          2445,
          1728,
          2460,
          2458,
          2456,
          2463,
          805,
          804,
          2428,
          2427,
          2425,
          2423,
          1725,
          2420,
          1724,
          2417,
          1722,
          2438,
          2436,
          2434,
          2431,
          1727,
          2444,
          2442,
          793,
          791,
          788,
          795,
          2388,
          2386,
          2384,
          1697,
          2381,
          1696,
          2378,
          1694,
          1692,
          2402,
          2400,
          2398,
          2395,
          1703,
          2392,
          1701,
          2412,
          2410,
          2407,
          751,
          748,
          744,
          2416,
          759,
          757,
          1807,
          2620,
          2618,
          1806,
          1805,
          2611,
          2609,
          2607,
          2614,
          1802,
          1801,
          1799,
          2594,
          2592,
          2590,
          2587,
          1804,
          2600,
          2598,
          1794,
          1793,
          1791,
          1789,
          2564,
          2562,
          2560,
          2557,
          1798,
          2554,
          1796,
          2574,
          2572,
          2569,
          2578,
          1847,
          1846,
          2722,
          1843,
          1842,
          1840,
          1845,
          2716,
          2714,
          1835,
          1834,
          1832,
          1830,
          1839,
          1837,
          2700,
          2698,
          2695,
          2704,
          1817,
          1811,
          1810,
          897,
          862,
          1777,
          829,
          826,
          838,
          1760,
          1758,
          808,
          2481,
          1741,
          1740,
          1738,
          1743,
          2624,
          1818,
          2726,
          2776,
          782,
          740,
          737,
          1715,
          686,
          679,
          695,
          1682,
          1680,
          639,
          628,
          2339,
          647,
          644,
          1645,
          1643,
          1640,
          1648,
          602,
          600,
          597,
          595,
          2320,
          593,
          2318,
          609,
          607,
          604,
          1611,
          1610,
          1608,
          1606,
          613,
          1615,
          1613,
          2328,
          926,
          924,
          892,
          886,
          899,
          857,
          850,
          2505,
          1778,
          824,
          823,
          821,
          819,
          2488,
          818,
          2486,
          833,
          831,
          828,
          840,
          1761,
          1759,
          2649,
          2632,
          2630,
          2746,
          2734,
          2732,
          2782,
          2781,
          570,
          567,
          1587,
          531,
          527,
          523,
          540,
          1566,
          1564,
          476,
          467,
          463,
          2240,
          486,
          483,
          1524,
          1521,
          1518,
          1529,
          411,
          403,
          2192,
          399,
          2189,
          423,
          416,
          1462,
          1457,
          1454,
          428,
          1468,
          1465,
          2210,
          366,
          363,
          2158,
          360,
          2156,
          357,
          2153,
          376,
          373,
          370,
          2163,
          1410,
          1409,
          1407,
          1405,
          382,
          1402,
          380,
          1417,
          1415,
          1412,
          1421,
          2175,
          2174,
          777,
          774,
          771,
          784,
          732,
          725,
          722,
          2404,
          743,
          1716,
          676,
          674,
          668,
          2363,
          665,
          2360,
          685,
          1684,
          1681,
          626,
          624,
          622,
          2335,
          620,
          2333,
          617,
          2330,
          641,
          635,
          649,
          1646,
          1644,
          1642,
          2566,
          928,
          925,
          2530,
          2527,
          894,
          891,
          888,
          2501,
          2499,
          2496,
          858,
          856,
          854,
          851,
          1779,
          2692,
          2668,
          2665,
          2645,
          2643,
          2640,
          2651,
          2768,
          2759,
          2757,
          2744,
          2743,
          2741,
          2748,
          352,
          1382,
          340,
          337,
          333,
          1371,
          1369,
          307,
          300,
          296,
          2126,
          315,
          312,
          1347,
          1342,
          1350,
          261,
          258,
          250,
          2097,
          246,
          2094,
          271,
          268,
          264,
          1306,
          1301,
          1298,
          276,
          1312,
          1309,
          2115,
          203,
          2048,
          195,
          2045,
          191,
          2041,
          213,
          209,
          2056,
          1246,
          1244,
          1238,
          225,
          1234,
          222,
          1256,
          1253,
          1249,
          1262,
          2080,
          2079,
          154,
          1997,
          150,
          1995,
          147,
          1992,
          1989,
          163,
          160,
          2004,
          156,
          2001,
          1175,
          1174,
          1172,
          1170,
          1167,
          170,
          1164,
          167,
          1185,
          1183,
          1180,
          1177,
          174,
          1190,
          1188,
          2025,
          2024,
          2022,
          587,
          586,
          564,
          559,
          556,
          2290,
          573,
          1588,
          520,
          518,
          512,
          2268,
          508,
          2265,
          530,
          1568,
          1565,
          461,
          457,
          2233,
          450,
          2230,
          446,
          2226,
          479,
          471,
          489,
          1526,
          1523,
          1520,
          397,
          395,
          2185,
          392,
          2183,
          389,
          2180,
          2177,
          410,
          2194,
          402,
          422,
          1463,
          1461,
          1459,
          1456,
          1470,
          2455,
          799,
          2433,
          2430,
          779,
          776,
          773,
          2397,
          2394,
          2390,
          734,
          728,
          724,
          746,
          1717,
          2356,
          2354,
          2351,
          2348,
          1658,
          677,
          675,
          673,
          670,
          667,
          688,
          1685,
          1683,
          2606,
          2589,
          2586,
          2559,
          2556,
          2552,
          927,
          2523,
          2521,
          2518,
          2515,
          1784,
          2532,
          895,
          893,
          890,
          2718,
          2709,
          2707,
          2689,
          2687,
          2684,
          2663,
          2662,
          2660,
          2658,
          1825,
          2667,
          2769,
          1852,
          2760,
          2758,
          142,
          141,
          1139,
          1138,
          134,
          132,
          129,
          126,
          1982,
          1129,
          1128,
          1126,
          1131,
          113,
          111,
          108,
          105,
          1972,
          101,
          1970,
          120,
          118,
          115,
          1109,
          1108,
          1106,
          1104,
          123,
          1113,
          1111,
          82,
          79,
          1951,
          75,
          1949,
          72,
          1946,
          92,
          89,
          86,
          1956,
          1077,
          1076,
          1074,
          1072,
          98,
          1069,
          96,
          1084,
          1082,
          1079,
          1088,
          1968,
          1967,
          48,
          45,
          1916,
          42,
          1914,
          39,
          1911,
          1908,
          60,
          57,
          54,
          1923,
          50,
          1920,
          1031,
          1030,
          1028,
          1026,
          67,
          1023,
          65,
          1020,
          62,
          1041,
          1039,
          1036,
          1033,
          69,
          1046,
          1044,
          1944,
          1943,
          1941,
          11,
          9,
          1868,
          7,
          1865,
          1862,
          1859,
          20,
          1878,
          16,
          1875,
          13,
          1872,
          970,
          968,
          966,
          963,
          29,
          960,
          26,
          23,
          983,
          981,
          978,
          975,
          33,
          971,
          31,
          990,
          988,
          985,
          1906,
          1904,
          1902,
          993,
          351,
          2145,
          1383,
          331,
          330,
          328,
          326,
          2137,
          323,
          2135,
          339,
          1372,
          1370,
          294,
          293,
          291,
          289,
          2122,
          286,
          2120,
          283,
          2117,
          309,
          303,
          317,
          1348,
          1346,
          1344,
          245,
          244,
          242,
          2090,
          239,
          2088,
          236,
          2085,
          2082,
          260,
          2099,
          249,
          270,
          1307,
          1305,
          1303,
          1300,
          1314,
          189,
          2038,
          186,
          2036,
          183,
          2033,
          2030,
          2026,
          206,
          198,
          2047,
          194,
          216,
          1247,
          1245,
          1243,
          1240,
          227,
          1237,
          1255,
          2310,
          2302,
          2300,
          2286,
          2284,
          2281,
          565,
          563,
          561,
          558,
          575,
          1589,
          2261,
          2259,
          2256,
          2253,
          1542,
          521,
          519,
          517,
          514,
          2270,
          511,
          533,
          1569,
          1567,
          2223,
          2221,
          2218,
          2215,
          1483,
          2211,
          1480,
          459,
          456,
          453,
          2232,
          449,
          474,
          491,
          1527,
          1525,
          1522,
          2475,
          2467,
          2465,
          2451,
          2449,
          2446,
          801,
          800,
          2426,
          2424,
          2421,
          2418,
          1723,
          2435,
          780,
          778,
          775,
          2387,
          2385,
          2382,
          2379,
          1695,
          2375,
          1693,
          2396,
          735,
          733,
          730,
          727,
          749,
          1718,
          2616,
          2615,
          2604,
          2603,
          2601,
          2584,
          2583,
          2581,
          2579,
          1800,
          2591,
          2550,
          2549,
          2547,
          2545,
          1792,
          2542,
          1790,
          2558,
          929,
          2719,
          1841,
          2710,
          2708,
          1833,
          1831,
          2690,
          2688,
          2686,
          1815,
          1809,
          1808,
          1774,
          1756,
          1754,
          1737,
          1736,
          1734,
          1739,
          1816,
          1711,
          1676,
          1674,
          633,
          629,
          1638,
          1636,
          1633,
          1641,
          598,
          1605,
          1604,
          1602,
          1600,
          605,
          1609,
          1607,
          2327,
          887,
          853,
          1775,
          822,
          820,
          1757,
          1755,
          1584,
          524,
          1560,
          1558,
          468,
          464,
          1514,
          1511,
          1508,
          1519,
          408,
          404,
          400,
          1452,
          1447,
          1444,
          417,
          1458,
          1455,
          2208,
          364,
          361,
          358,
          2154,
          1401,
          1400,
          1398,
          1396,
          374,
          1393,
          371,
          1408,
          1406,
          1403,
          1413,
          2173,
          2172,
          772,
          726,
          723,
          1712,
          672,
          669,
          666,
          682,
          1678,
          1675,
          625,
          623,
          621,
          618,
          2331,
          636,
          632,
          1639,
          1637,
          1635,
          920,
          918,
          884,
          880,
          889,
          849,
          848,
          847,
          846,
          2497,
          855,
          852,
          1776,
          2641,
          2742,
          2787,
          1380,
          334,
          1367,
          1365,
          301,
          297,
          1340,
          1338,
          1335,
          1343,
          255,
          251,
          247,
          1296,
          1291,
          1288,
          265,
          1302,
          1299,
          2113,
          204,
          196,
          192,
          2042,
          1232,
          1230,
          1224,
          214,
          1220,
          210,
          1242,
          1239,
          1235,
          1250,
          2077,
          2075,
          151,
          148,
          1993,
          144,
          1990,
          1163,
          1162,
          1160,
          1158,
          1155,
          161,
          1152,
          157,
          1173,
          1171,
          1168,
          1165,
          168,
          1181,
          1178,
          2021,
          2020,
          2018,
          2023,
          585,
          560,
          557,
          1585,
          516,
          509,
          1562,
          1559,
          458,
          447,
          2227,
          472,
          1516,
          1513,
          1510,
          398,
          396,
          393,
          390,
          2181,
          386,
          2178,
          407,
          1453,
          1451,
          1449,
          1446,
          420,
          1460,
          2209,
          769,
          764,
          720,
          712,
          2391,
          729,
          1713,
          664,
          663,
          661,
          659,
          2352,
          656,
          2349,
          671,
          1679,
          1677,
          2553,
          922,
          919,
          2519,
          2516,
          885,
          883,
          881,
          2685,
          2661,
          2659,
          2767,
          2756,
          2755,
          140,
          1137,
          1136,
          130,
          127,
          1125,
          1124,
          1122,
          1127,
          109,
          106,
          102,
          1103,
          1102,
          1100,
          1098,
          116,
          1107,
          1105,
          1980,
          80,
          76,
          73,
          1947,
          1068,
          1067,
          1065,
          1063,
          90,
          1060,
          87,
          1075,
          1073,
          1070,
          1080,
          1966,
          1965,
          46,
          43,
          40,
          1912,
          36,
          1909,
          1019,
          1018,
          1016,
          1014,
          58,
          1011,
          55,
          1008,
          51,
          1029,
          1027,
          1024,
          1021,
          63,
          1037,
          1034,
          1940,
          1939,
          1937,
          1942,
          8,
          1866,
          4,
          1863,
          1,
          1860,
          956,
          954,
          952,
          949,
          946,
          17,
          14,
          969,
          967,
          964,
          961,
          27,
          957,
          24,
          979,
          976,
          972,
          1901,
          1900,
          1898,
          1896,
          986,
          1905,
          1903,
          350,
          349,
          1381,
          329,
          327,
          324,
          1368,
          1366,
          292,
          290,
          287,
          284,
          2118,
          304,
          1341,
          1339,
          1337,
          1345,
          243,
          240,
          237,
          2086,
          233,
          2083,
          254,
          1297,
          1295,
          1293,
          1290,
          1304,
          2114,
          190,
          187,
          184,
          2034,
          180,
          2031,
          177,
          2027,
          199,
          1233,
          1231,
          1229,
          1226,
          217,
          1223,
          1241,
          2078,
          2076,
          584,
          555,
          554,
          552,
          550,
          2282,
          562,
          1586,
          507,
          506,
          504,
          502,
          2257,
          499,
          2254,
          515,
          1563,
          1561,
          445,
          443,
          441,
          2219,
          438,
          2216,
          435,
          2212,
          460,
          454,
          475,
          1517,
          1515,
          1512,
          2447,
          798,
          797,
          2422,
          2419,
          770,
          768,
          766,
          2383,
          2380,
          2376,
          721,
          719,
          717,
          714,
          731,
          1714,
          2602,
          2582,
          2580,
          2548,
          2546,
          2543,
          923,
          921,
          2717,
          2706,
          2705,
          2683,
          2682,
          2680,
          1771,
          1752,
          1750,
          1733,
          1732,
          1731,
          1735,
          1814,
          1707,
          1670,
          1668,
          1631,
          1629,
          1626,
          1634,
          1599,
          1598,
          1596,
          1594,
          1603,
          1601,
          2326,
          1772,
          1753,
          1751,
          1581,
          1554,
          1552,
          1504,
          1501,
          1498,
          1509,
          1442,
          1437,
          1434,
          401,
          1448,
          1445,
          2206,
          1392,
          1391,
          1389,
          1387,
          1384,
          359,
          1399,
          1397,
          1394,
          1404,
          2171,
          2170,
          1708,
          1672,
          1669,
          619,
          1632,
          1630,
          1628,
          1773,
          1378,
          1363,
          1361,
          1333,
          1328,
          1336,
          1286,
          1281,
          1278,
          248,
          1292,
          1289,
          2111,
          1218,
          1216,
          1210,
          197,
          1206,
          193,
          1228,
          1225,
          1221,
          1236,
          2073,
          2071,
          1151,
          1150,
          1148,
          1146,
          152,
          1143,
          149,
          1140,
          145,
          1161,
          1159,
          1156,
          1153,
          158,
          1169,
          1166,
          2017,
          2016,
          2014,
          2019,
          1582,
          510,
          1556,
          1553,
          452,
          448,
          1506,
          1500,
          394,
          391,
          387,
          1443,
          1441,
          1439,
          1436,
          1450,
          2207,
          765,
          716,
          713,
          1709,
          662,
          660,
          657,
          1673,
          1671,
          916,
          914,
          879,
          878,
          877,
          882,
          1135,
          1134,
          1121,
          1120,
          1118,
          1123,
          1097,
          1096,
          1094,
          1092,
          103,
          1101,
          1099,
          1979,
          1059,
          1058,
          1056,
          1054,
          77,
          1051,
          74,
          1066,
          1064,
          1061,
          1071,
          1964,
          1963,
          1007,
          1006,
          1004,
          1002,
          999,
          41,
          996,
          37,
          1017,
          1015,
          1012,
          1009,
          52,
          1025,
          1022,
          1936,
          1935,
          1933,
          1938,
          942,
          940,
          938,
          935,
          932,
          5,
          2,
          955,
          953,
          950,
          947,
          18,
          943,
          15,
          965,
          962,
          958,
          1895,
          1894,
          1892,
          1890,
          973,
          1899,
          1897,
          1379,
          325,
          1364,
          1362,
          288,
          285,
          1334,
          1332,
          1330,
          241,
          238,
          234,
          1287,
          1285,
          1283,
          1280,
          1294,
          2112,
          188,
          185,
          181,
          178,
          2028,
          1219,
          1217,
          1215,
          1212,
          200,
          1209,
          1227,
          2074,
          2072,
          583,
          553,
          551,
          1583,
          505,
          503,
          500,
          513,
          1557,
          1555,
          444,
          442,
          439,
          436,
          2213,
          455,
          451,
          1507,
          1505,
          1502,
          796,
          763,
          762,
          760,
          767,
          711,
          710,
          708,
          706,
          2377,
          718,
          715,
          1710,
          2544,
          917,
          915,
          2681,
          1627,
          1597,
          1595,
          2325,
          1769,
          1749,
          1747,
          1499,
          1438,
          1435,
          2204,
          1390,
          1388,
          1385,
          1395,
          2169,
          2167,
          1704,
          1665,
          1662,
          1625,
          1623,
          1620,
          1770,
          1329,
          1282,
          1279,
          2109,
          1214,
          1207,
          1222,
          2068,
          2065,
          1149,
          1147,
          1144,
          1141,
          146,
          1157,
          1154,
          2013,
          2011,
          2008,
          2015,
          1579,
          1549,
          1546,
          1495,
          1487,
          1433,
          1431,
          1428,
          1425,
          388,
          1440,
          2205,
          1705,
          658,
          1667,
          1664,
          1119,
          1095,
          1093,
          1978,
          1057,
          1055,
          1052,
          1062,
          1962,
          1960,
          1005,
          1003,
          1e3,
          997,
          38,
          1013,
          1010,
          1932,
          1930,
          1927,
          1934,
          941,
          939,
          936,
          933,
          6,
          930,
          3,
          951,
          948,
          944,
          1889,
          1887,
          1884,
          1881,
          959,
          1893,
          1891,
          35,
          1377,
          1360,
          1358,
          1327,
          1325,
          1322,
          1331,
          1277,
          1275,
          1272,
          1269,
          235,
          1284,
          2110,
          1205,
          1204,
          1201,
          1198,
          182,
          1195,
          179,
          1213,
          2070,
          2067,
          1580,
          501,
          1551,
          1548,
          440,
          437,
          1497,
          1494,
          1490,
          1503,
          761,
          709,
          707,
          1706,
          913,
          912,
          2198,
          1386,
          2164,
          2161,
          1621,
          1766,
          2103,
          1208,
          2058,
          2054,
          1145,
          1142,
          2005,
          2002,
          1999,
          2009,
          1488,
          1429,
          1426,
          2200,
          1698,
          1659,
          1656,
          1975,
          1053,
          1957,
          1954,
          1001,
          998,
          1924,
          1921,
          1918,
          1928,
          937,
          934,
          931,
          1879,
          1876,
          1873,
          1870,
          945,
          1885,
          1882,
          1323,
          1273,
          1270,
          2105,
          1202,
          1199,
          1196,
          1211,
          2061,
          2057,
          1576,
          1543,
          1540,
          1484,
          1481,
          1478,
          1491,
          1700
        ]);
        class PDF417DetectorResult {
          constructor(bits, points) {
            this.bits = bits;
            this.points = points;
          }
          getBits() {
            return this.bits;
          }
          getPoints() {
            return this.points;
          }
        }
        class Detector$3 {
          static detectMultiple(image, hints, multiple) {
            let bitMatrix = image.getBlackMatrix();
            let barcodeCoordinates = Detector$3.detect(multiple, bitMatrix);
            if (!barcodeCoordinates.length) {
              bitMatrix = bitMatrix.clone();
              bitMatrix.rotate180();
              barcodeCoordinates = Detector$3.detect(multiple, bitMatrix);
            }
            return new PDF417DetectorResult(bitMatrix, barcodeCoordinates);
          }
          static detect(multiple, bitMatrix) {
            const barcodeCoordinates = new Array();
            let row = 0;
            let column = 0;
            let foundBarcodeInRow = false;
            while (row < bitMatrix.getHeight()) {
              const vertices = Detector$3.findVertices(bitMatrix, row, column);
              if (vertices[0] == null && vertices[3] == null) {
                if (!foundBarcodeInRow) {
                  break;
                }
                foundBarcodeInRow = false;
                column = 0;
                for (const barcodeCoordinate of barcodeCoordinates) {
                  if (barcodeCoordinate[1] != null) {
                    row = Math.trunc(Math.max(row, barcodeCoordinate[1].getY()));
                  }
                  if (barcodeCoordinate[3] != null) {
                    row = Math.max(row, Math.trunc(barcodeCoordinate[3].getY()));
                  }
                }
                row += Detector$3.ROW_STEP;
                continue;
              }
              foundBarcodeInRow = true;
              barcodeCoordinates.push(vertices);
              if (!multiple) {
                break;
              }
              if (vertices[2] != null) {
                column = Math.trunc(vertices[2].getX());
                row = Math.trunc(vertices[2].getY());
              } else {
                column = Math.trunc(vertices[4].getX());
                row = Math.trunc(vertices[4].getY());
              }
            }
            return barcodeCoordinates;
          }
          static findVertices(matrix, startRow, startColumn) {
            const height = matrix.getHeight();
            const width = matrix.getWidth();
            const result = new Array(8);
            Detector$3.copyToResult(result, Detector$3.findRowsWithPattern(matrix, height, width, startRow, startColumn, Detector$3.START_PATTERN), Detector$3.INDEXES_START_PATTERN);
            if (result[4] != null) {
              startColumn = Math.trunc(result[4].getX());
              startRow = Math.trunc(result[4].getY());
            }
            Detector$3.copyToResult(result, Detector$3.findRowsWithPattern(matrix, height, width, startRow, startColumn, Detector$3.STOP_PATTERN), Detector$3.INDEXES_STOP_PATTERN);
            return result;
          }
          static copyToResult(result, tmpResult, destinationIndexes) {
            for (let i = 0; i < destinationIndexes.length; i++) {
              result[destinationIndexes[i]] = tmpResult[i];
            }
          }
          static findRowsWithPattern(matrix, height, width, startRow, startColumn, pattern) {
            const result = new Array(4);
            let found = false;
            const counters = new Int32Array(pattern.length);
            for (; startRow < height; startRow += Detector$3.ROW_STEP) {
              let loc = Detector$3.findGuardPattern(matrix, startColumn, startRow, width, false, pattern, counters);
              if (loc != null) {
                while (startRow > 0) {
                  const previousRowLoc = Detector$3.findGuardPattern(matrix, startColumn, --startRow, width, false, pattern, counters);
                  if (previousRowLoc != null) {
                    loc = previousRowLoc;
                  } else {
                    startRow++;
                    break;
                  }
                }
                result[0] = new ResultPoint(loc[0], startRow);
                result[1] = new ResultPoint(loc[1], startRow);
                found = true;
                break;
              }
            }
            let stopRow = startRow + 1;
            if (found) {
              let skippedRowCount = 0;
              let previousRowLoc = Int32Array.from([Math.trunc(result[0].getX()), Math.trunc(result[1].getX())]);
              for (; stopRow < height; stopRow++) {
                const loc = Detector$3.findGuardPattern(matrix, previousRowLoc[0], stopRow, width, false, pattern, counters);
                if (loc != null && Math.abs(previousRowLoc[0] - loc[0]) < Detector$3.MAX_PATTERN_DRIFT && Math.abs(previousRowLoc[1] - loc[1]) < Detector$3.MAX_PATTERN_DRIFT) {
                  previousRowLoc = loc;
                  skippedRowCount = 0;
                } else {
                  if (skippedRowCount > Detector$3.SKIPPED_ROW_COUNT_MAX) {
                    break;
                  } else {
                    skippedRowCount++;
                  }
                }
              }
              stopRow -= skippedRowCount + 1;
              result[2] = new ResultPoint(previousRowLoc[0], stopRow);
              result[3] = new ResultPoint(previousRowLoc[1], stopRow);
            }
            if (stopRow - startRow < Detector$3.BARCODE_MIN_HEIGHT) {
              Arrays.fill(result, null);
            }
            return result;
          }
          static findGuardPattern(matrix, column, row, width, whiteFirst, pattern, counters) {
            Arrays.fillWithin(counters, 0, counters.length, 0);
            let patternStart = column;
            let pixelDrift = 0;
            while (matrix.get(patternStart, row) && patternStart > 0 && pixelDrift++ < Detector$3.MAX_PIXEL_DRIFT) {
              patternStart--;
            }
            let x = patternStart;
            let counterPosition = 0;
            let patternLength = pattern.length;
            for (let isWhite = whiteFirst; x < width; x++) {
              let pixel = matrix.get(x, row);
              if (pixel !== isWhite) {
                counters[counterPosition]++;
              } else {
                if (counterPosition === patternLength - 1) {
                  if (Detector$3.patternMatchVariance(counters, pattern, Detector$3.MAX_INDIVIDUAL_VARIANCE) < Detector$3.MAX_AVG_VARIANCE) {
                    return new Int32Array([patternStart, x]);
                  }
                  patternStart += counters[0] + counters[1];
                  System.arraycopy(counters, 2, counters, 0, counterPosition - 1);
                  counters[counterPosition - 1] = 0;
                  counters[counterPosition] = 0;
                  counterPosition--;
                } else {
                  counterPosition++;
                }
                counters[counterPosition] = 1;
                isWhite = !isWhite;
              }
            }
            if (counterPosition === patternLength - 1 && Detector$3.patternMatchVariance(counters, pattern, Detector$3.MAX_INDIVIDUAL_VARIANCE) < Detector$3.MAX_AVG_VARIANCE) {
              return new Int32Array([patternStart, x - 1]);
            }
            return null;
          }
          static patternMatchVariance(counters, pattern, maxIndividualVariance) {
            let numCounters = counters.length;
            let total = 0;
            let patternLength = 0;
            for (let i = 0; i < numCounters; i++) {
              total += counters[i];
              patternLength += pattern[i];
            }
            if (total < patternLength) {
              return Infinity;
            }
            let unitBarWidth = total / patternLength;
            maxIndividualVariance *= unitBarWidth;
            let totalVariance = 0;
            for (let x = 0; x < numCounters; x++) {
              let counter = counters[x];
              let scaledPattern = pattern[x] * unitBarWidth;
              let variance = counter > scaledPattern ? counter - scaledPattern : scaledPattern - counter;
              if (variance > maxIndividualVariance) {
                return Infinity;
              }
              totalVariance += variance;
            }
            return totalVariance / total;
          }
        }
        Detector$3.INDEXES_START_PATTERN = Int32Array.from([0, 4, 1, 5]);
        Detector$3.INDEXES_STOP_PATTERN = Int32Array.from([6, 2, 7, 3]);
        Detector$3.MAX_AVG_VARIANCE = 0.42;
        Detector$3.MAX_INDIVIDUAL_VARIANCE = 0.8;
        Detector$3.START_PATTERN = Int32Array.from([8, 1, 1, 1, 1, 1, 1, 3]);
        Detector$3.STOP_PATTERN = Int32Array.from([7, 1, 1, 3, 1, 1, 1, 2, 1]);
        Detector$3.MAX_PIXEL_DRIFT = 3;
        Detector$3.MAX_PATTERN_DRIFT = 5;
        Detector$3.SKIPPED_ROW_COUNT_MAX = 25;
        Detector$3.ROW_STEP = 5;
        Detector$3.BARCODE_MIN_HEIGHT = 10;
        class ModulusPoly {
          constructor(field, coefficients) {
            if (coefficients.length === 0) {
              throw new IllegalArgumentException();
            }
            this.field = field;
            let coefficientsLength = coefficients.length;
            if (coefficientsLength > 1 && coefficients[0] === 0) {
              let firstNonZero = 1;
              while (firstNonZero < coefficientsLength && coefficients[firstNonZero] === 0) {
                firstNonZero++;
              }
              if (firstNonZero === coefficientsLength) {
                this.coefficients = new Int32Array([0]);
              } else {
                this.coefficients = new Int32Array(coefficientsLength - firstNonZero);
                System.arraycopy(coefficients, firstNonZero, this.coefficients, 0, this.coefficients.length);
              }
            } else {
              this.coefficients = coefficients;
            }
          }
          getCoefficients() {
            return this.coefficients;
          }
          getDegree() {
            return this.coefficients.length - 1;
          }
          isZero() {
            return this.coefficients[0] === 0;
          }
          getCoefficient(degree) {
            return this.coefficients[this.coefficients.length - 1 - degree];
          }
          evaluateAt(a) {
            if (a === 0) {
              return this.getCoefficient(0);
            }
            if (a === 1) {
              let sum = 0;
              for (let coefficient of this.coefficients) {
                sum = this.field.add(sum, coefficient);
              }
              return sum;
            }
            let result = this.coefficients[0];
            let size2 = this.coefficients.length;
            for (let i = 1; i < size2; i++) {
              result = this.field.add(this.field.multiply(a, result), this.coefficients[i]);
            }
            return result;
          }
          add(other) {
            if (!this.field.equals(other.field)) {
              throw new IllegalArgumentException("ModulusPolys do not have same ModulusGF field");
            }
            if (this.isZero()) {
              return other;
            }
            if (other.isZero()) {
              return this;
            }
            let smallerCoefficients = this.coefficients;
            let largerCoefficients = other.coefficients;
            if (smallerCoefficients.length > largerCoefficients.length) {
              let temp = smallerCoefficients;
              smallerCoefficients = largerCoefficients;
              largerCoefficients = temp;
            }
            let sumDiff = new Int32Array(largerCoefficients.length);
            let lengthDiff = largerCoefficients.length - smallerCoefficients.length;
            System.arraycopy(largerCoefficients, 0, sumDiff, 0, lengthDiff);
            for (let i = lengthDiff; i < largerCoefficients.length; i++) {
              sumDiff[i] = this.field.add(smallerCoefficients[i - lengthDiff], largerCoefficients[i]);
            }
            return new ModulusPoly(this.field, sumDiff);
          }
          subtract(other) {
            if (!this.field.equals(other.field)) {
              throw new IllegalArgumentException("ModulusPolys do not have same ModulusGF field");
            }
            if (other.isZero()) {
              return this;
            }
            return this.add(other.negative());
          }
          multiply(other) {
            if (other instanceof ModulusPoly) {
              return this.multiplyOther(other);
            }
            return this.multiplyScalar(other);
          }
          multiplyOther(other) {
            if (!this.field.equals(other.field)) {
              throw new IllegalArgumentException("ModulusPolys do not have same ModulusGF field");
            }
            if (this.isZero() || other.isZero()) {
              return new ModulusPoly(this.field, new Int32Array([0]));
            }
            let aCoefficients = this.coefficients;
            let aLength = aCoefficients.length;
            let bCoefficients = other.coefficients;
            let bLength = bCoefficients.length;
            let product = new Int32Array(aLength + bLength - 1);
            for (let i = 0; i < aLength; i++) {
              let aCoeff = aCoefficients[i];
              for (let j = 0; j < bLength; j++) {
                product[i + j] = this.field.add(product[i + j], this.field.multiply(aCoeff, bCoefficients[j]));
              }
            }
            return new ModulusPoly(this.field, product);
          }
          negative() {
            let size2 = this.coefficients.length;
            let negativeCoefficients = new Int32Array(size2);
            for (let i = 0; i < size2; i++) {
              negativeCoefficients[i] = this.field.subtract(0, this.coefficients[i]);
            }
            return new ModulusPoly(this.field, negativeCoefficients);
          }
          multiplyScalar(scalar) {
            if (scalar === 0) {
              return new ModulusPoly(this.field, new Int32Array([0]));
            }
            if (scalar === 1) {
              return this;
            }
            let size2 = this.coefficients.length;
            let product = new Int32Array(size2);
            for (let i = 0; i < size2; i++) {
              product[i] = this.field.multiply(this.coefficients[i], scalar);
            }
            return new ModulusPoly(this.field, product);
          }
          multiplyByMonomial(degree, coefficient) {
            if (degree < 0) {
              throw new IllegalArgumentException();
            }
            if (coefficient === 0) {
              return new ModulusPoly(this.field, new Int32Array([0]));
            }
            let size2 = this.coefficients.length;
            let product = new Int32Array(size2 + degree);
            for (let i = 0; i < size2; i++) {
              product[i] = this.field.multiply(this.coefficients[i], coefficient);
            }
            return new ModulusPoly(this.field, product);
          }
          toString() {
            let result = new StringBuilder();
            for (let degree = this.getDegree(); degree >= 0; degree--) {
              let coefficient = this.getCoefficient(degree);
              if (coefficient !== 0) {
                if (coefficient < 0) {
                  result.append(" - ");
                  coefficient = -coefficient;
                } else {
                  if (result.length() > 0) {
                    result.append(" + ");
                  }
                }
                if (degree === 0 || coefficient !== 1) {
                  result.append(coefficient);
                }
                if (degree !== 0) {
                  if (degree === 1) {
                    result.append("x");
                  } else {
                    result.append("x^");
                    result.append(degree);
                  }
                }
              }
            }
            return result.toString();
          }
        }
        class ModulusBase {
          add(a, b) {
            return (a + b) % this.modulus;
          }
          subtract(a, b) {
            return (this.modulus + a - b) % this.modulus;
          }
          exp(a) {
            return this.expTable[a];
          }
          log(a) {
            if (a === 0) {
              throw new IllegalArgumentException();
            }
            return this.logTable[a];
          }
          inverse(a) {
            if (a === 0) {
              throw new ArithmeticException();
            }
            return this.expTable[this.modulus - this.logTable[a] - 1];
          }
          multiply(a, b) {
            if (a === 0 || b === 0) {
              return 0;
            }
            return this.expTable[(this.logTable[a] + this.logTable[b]) % (this.modulus - 1)];
          }
          getSize() {
            return this.modulus;
          }
          equals(o) {
            return o === this;
          }
        }
        class ModulusGF extends ModulusBase {
          constructor(modulus, generator) {
            super();
            this.modulus = modulus;
            this.expTable = new Int32Array(modulus);
            this.logTable = new Int32Array(modulus);
            let x = 1;
            for (let i = 0; i < modulus; i++) {
              this.expTable[i] = x;
              x = x * generator % modulus;
            }
            for (let i = 0; i < modulus - 1; i++) {
              this.logTable[this.expTable[i]] = i;
            }
            this.zero = new ModulusPoly(this, new Int32Array([0]));
            this.one = new ModulusPoly(this, new Int32Array([1]));
          }
          getZero() {
            return this.zero;
          }
          getOne() {
            return this.one;
          }
          buildMonomial(degree, coefficient) {
            if (degree < 0) {
              throw new IllegalArgumentException();
            }
            if (coefficient === 0) {
              return this.zero;
            }
            let coefficients = new Int32Array(degree + 1);
            coefficients[0] = coefficient;
            return new ModulusPoly(this, coefficients);
          }
        }
        ModulusGF.PDF417_GF = new ModulusGF(PDF417Common.NUMBER_OF_CODEWORDS, 3);
        class ErrorCorrection {
          constructor() {
            this.field = ModulusGF.PDF417_GF;
          }
          decode(received, numECCodewords, erasures) {
            let poly = new ModulusPoly(this.field, received);
            let S = new Int32Array(numECCodewords);
            let error2 = false;
            for (let i = numECCodewords; i > 0; i--) {
              let evaluation = poly.evaluateAt(this.field.exp(i));
              S[numECCodewords - i] = evaluation;
              if (evaluation !== 0) {
                error2 = true;
              }
            }
            if (!error2) {
              return 0;
            }
            let knownErrors = this.field.getOne();
            if (erasures != null) {
              for (const erasure of erasures) {
                let b = this.field.exp(received.length - 1 - erasure);
                let term = new ModulusPoly(this.field, new Int32Array([this.field.subtract(0, b), 1]));
                knownErrors = knownErrors.multiply(term);
              }
            }
            let syndrome = new ModulusPoly(this.field, S);
            let sigmaOmega = this.runEuclideanAlgorithm(this.field.buildMonomial(numECCodewords, 1), syndrome, numECCodewords);
            let sigma = sigmaOmega[0];
            let omega = sigmaOmega[1];
            let errorLocations = this.findErrorLocations(sigma);
            let errorMagnitudes = this.findErrorMagnitudes(omega, sigma, errorLocations);
            for (let i = 0; i < errorLocations.length; i++) {
              let position = received.length - 1 - this.field.log(errorLocations[i]);
              if (position < 0) {
                throw ChecksumException.getChecksumInstance();
              }
              received[position] = this.field.subtract(received[position], errorMagnitudes[i]);
            }
            return errorLocations.length;
          }
          runEuclideanAlgorithm(a, b, R) {
            if (a.getDegree() < b.getDegree()) {
              let temp = a;
              a = b;
              b = temp;
            }
            let rLast = a;
            let r = b;
            let tLast = this.field.getZero();
            let t = this.field.getOne();
            while (r.getDegree() >= Math.round(R / 2)) {
              let rLastLast = rLast;
              let tLastLast = tLast;
              rLast = r;
              tLast = t;
              if (rLast.isZero()) {
                throw ChecksumException.getChecksumInstance();
              }
              r = rLastLast;
              let q = this.field.getZero();
              let denominatorLeadingTerm = rLast.getCoefficient(rLast.getDegree());
              let dltInverse = this.field.inverse(denominatorLeadingTerm);
              while (r.getDegree() >= rLast.getDegree() && !r.isZero()) {
                let degreeDiff = r.getDegree() - rLast.getDegree();
                let scale = this.field.multiply(r.getCoefficient(r.getDegree()), dltInverse);
                q = q.add(this.field.buildMonomial(degreeDiff, scale));
                r = r.subtract(rLast.multiplyByMonomial(degreeDiff, scale));
              }
              t = q.multiply(tLast).subtract(tLastLast).negative();
            }
            let sigmaTildeAtZero = t.getCoefficient(0);
            if (sigmaTildeAtZero === 0) {
              throw ChecksumException.getChecksumInstance();
            }
            let inverse = this.field.inverse(sigmaTildeAtZero);
            let sigma = t.multiply(inverse);
            let omega = r.multiply(inverse);
            return [sigma, omega];
          }
          findErrorLocations(errorLocator) {
            let numErrors = errorLocator.getDegree();
            let result = new Int32Array(numErrors);
            let e = 0;
            for (let i = 1; i < this.field.getSize() && e < numErrors; i++) {
              if (errorLocator.evaluateAt(i) === 0) {
                result[e] = this.field.inverse(i);
                e++;
              }
            }
            if (e !== numErrors) {
              throw ChecksumException.getChecksumInstance();
            }
            return result;
          }
          findErrorMagnitudes(errorEvaluator, errorLocator, errorLocations) {
            let errorLocatorDegree = errorLocator.getDegree();
            let formalDerivativeCoefficients = new Int32Array(errorLocatorDegree);
            for (let i = 1; i <= errorLocatorDegree; i++) {
              formalDerivativeCoefficients[errorLocatorDegree - i] = this.field.multiply(i, errorLocator.getCoefficient(i));
            }
            let formalDerivative = new ModulusPoly(this.field, formalDerivativeCoefficients);
            let s = errorLocations.length;
            let result = new Int32Array(s);
            for (let i = 0; i < s; i++) {
              let xiInverse = this.field.inverse(errorLocations[i]);
              let numerator = this.field.subtract(0, errorEvaluator.evaluateAt(xiInverse));
              let denominator = this.field.inverse(formalDerivative.evaluateAt(xiInverse));
              result[i] = this.field.multiply(numerator, denominator);
            }
            return result;
          }
        }
        class BoundingBox {
          constructor(image, topLeft, bottomLeft, topRight, bottomRight) {
            if (image instanceof BoundingBox) {
              this.constructor_2(image);
            } else {
              this.constructor_1(image, topLeft, bottomLeft, topRight, bottomRight);
            }
          }
          constructor_1(image, topLeft, bottomLeft, topRight, bottomRight) {
            const leftUnspecified = topLeft == null || bottomLeft == null;
            const rightUnspecified = topRight == null || bottomRight == null;
            if (leftUnspecified && rightUnspecified) {
              throw new NotFoundException();
            }
            if (leftUnspecified) {
              topLeft = new ResultPoint(0, topRight.getY());
              bottomLeft = new ResultPoint(0, bottomRight.getY());
            } else if (rightUnspecified) {
              topRight = new ResultPoint(image.getWidth() - 1, topLeft.getY());
              bottomRight = new ResultPoint(image.getWidth() - 1, bottomLeft.getY());
            }
            this.image = image;
            this.topLeft = topLeft;
            this.bottomLeft = bottomLeft;
            this.topRight = topRight;
            this.bottomRight = bottomRight;
            this.minX = Math.trunc(Math.min(topLeft.getX(), bottomLeft.getX()));
            this.maxX = Math.trunc(Math.max(topRight.getX(), bottomRight.getX()));
            this.minY = Math.trunc(Math.min(topLeft.getY(), topRight.getY()));
            this.maxY = Math.trunc(Math.max(bottomLeft.getY(), bottomRight.getY()));
          }
          constructor_2(boundingBox) {
            this.image = boundingBox.image;
            this.topLeft = boundingBox.getTopLeft();
            this.bottomLeft = boundingBox.getBottomLeft();
            this.topRight = boundingBox.getTopRight();
            this.bottomRight = boundingBox.getBottomRight();
            this.minX = boundingBox.getMinX();
            this.maxX = boundingBox.getMaxX();
            this.minY = boundingBox.getMinY();
            this.maxY = boundingBox.getMaxY();
          }
          static merge(leftBox, rightBox) {
            if (leftBox == null) {
              return rightBox;
            }
            if (rightBox == null) {
              return leftBox;
            }
            return new BoundingBox(leftBox.image, leftBox.topLeft, leftBox.bottomLeft, rightBox.topRight, rightBox.bottomRight);
          }
          addMissingRows(missingStartRows, missingEndRows, isLeft) {
            let newTopLeft = this.topLeft;
            let newBottomLeft = this.bottomLeft;
            let newTopRight = this.topRight;
            let newBottomRight = this.bottomRight;
            if (missingStartRows > 0) {
              let top = isLeft ? this.topLeft : this.topRight;
              let newMinY = Math.trunc(top.getY() - missingStartRows);
              if (newMinY < 0) {
                newMinY = 0;
              }
              let newTop = new ResultPoint(top.getX(), newMinY);
              if (isLeft) {
                newTopLeft = newTop;
              } else {
                newTopRight = newTop;
              }
            }
            if (missingEndRows > 0) {
              let bottom = isLeft ? this.bottomLeft : this.bottomRight;
              let newMaxY = Math.trunc(bottom.getY() + missingEndRows);
              if (newMaxY >= this.image.getHeight()) {
                newMaxY = this.image.getHeight() - 1;
              }
              let newBottom = new ResultPoint(bottom.getX(), newMaxY);
              if (isLeft) {
                newBottomLeft = newBottom;
              } else {
                newBottomRight = newBottom;
              }
            }
            return new BoundingBox(this.image, newTopLeft, newBottomLeft, newTopRight, newBottomRight);
          }
          getMinX() {
            return this.minX;
          }
          getMaxX() {
            return this.maxX;
          }
          getMinY() {
            return this.minY;
          }
          getMaxY() {
            return this.maxY;
          }
          getTopLeft() {
            return this.topLeft;
          }
          getTopRight() {
            return this.topRight;
          }
          getBottomLeft() {
            return this.bottomLeft;
          }
          getBottomRight() {
            return this.bottomRight;
          }
        }
        class BarcodeMetadata {
          constructor(columnCount, rowCountUpperPart, rowCountLowerPart, errorCorrectionLevel) {
            this.columnCount = columnCount;
            this.errorCorrectionLevel = errorCorrectionLevel;
            this.rowCountUpperPart = rowCountUpperPart;
            this.rowCountLowerPart = rowCountLowerPart;
            this.rowCount = rowCountUpperPart + rowCountLowerPart;
          }
          getColumnCount() {
            return this.columnCount;
          }
          getErrorCorrectionLevel() {
            return this.errorCorrectionLevel;
          }
          getRowCount() {
            return this.rowCount;
          }
          getRowCountUpperPart() {
            return this.rowCountUpperPart;
          }
          getRowCountLowerPart() {
            return this.rowCountLowerPart;
          }
        }
        class Formatter {
          constructor() {
            this.buffer = "";
          }
          static form(str, arr) {
            let i = -1;
            function callback(exp, p0, p1, p2, p3, p4) {
              if (exp === "%%")
                return "%";
              if (arr[++i] === void 0)
                return void 0;
              exp = p2 ? parseInt(p2.substr(1)) : void 0;
              let base = p3 ? parseInt(p3.substr(1)) : void 0;
              let val;
              switch (p4) {
                case "s":
                  val = arr[i];
                  break;
                case "c":
                  val = arr[i][0];
                  break;
                case "f":
                  val = parseFloat(arr[i]).toFixed(exp);
                  break;
                case "p":
                  val = parseFloat(arr[i]).toPrecision(exp);
                  break;
                case "e":
                  val = parseFloat(arr[i]).toExponential(exp);
                  break;
                case "x":
                  val = parseInt(arr[i]).toString(base ? base : 16);
                  break;
                case "d":
                  val = parseFloat(parseInt(arr[i], base ? base : 10).toPrecision(exp)).toFixed(0);
                  break;
              }
              val = typeof val === "object" ? JSON.stringify(val) : (+val).toString(base);
              let size2 = parseInt(p1);
              let ch = p1 && p1[0] + "" === "0" ? "0" : " ";
              while (val.length < size2)
                val = p0 !== void 0 ? val + ch : ch + val;
              return val;
            }
            let regex = /%(-)?(0?[0-9]+)?([.][0-9]+)?([#][0-9]+)?([scfpexd%])/g;
            return str.replace(regex, callback);
          }
          format(append, ...args) {
            this.buffer += Formatter.form(append, args);
          }
          toString() {
            return this.buffer;
          }
        }
        class DetectionResultColumn {
          constructor(boundingBox) {
            this.boundingBox = new BoundingBox(boundingBox);
            this.codewords = new Array(boundingBox.getMaxY() - boundingBox.getMinY() + 1);
          }
          getCodewordNearby(imageRow) {
            let codeword = this.getCodeword(imageRow);
            if (codeword != null) {
              return codeword;
            }
            for (let i = 1; i < DetectionResultColumn.MAX_NEARBY_DISTANCE; i++) {
              let nearImageRow = this.imageRowToCodewordIndex(imageRow) - i;
              if (nearImageRow >= 0) {
                codeword = this.codewords[nearImageRow];
                if (codeword != null) {
                  return codeword;
                }
              }
              nearImageRow = this.imageRowToCodewordIndex(imageRow) + i;
              if (nearImageRow < this.codewords.length) {
                codeword = this.codewords[nearImageRow];
                if (codeword != null) {
                  return codeword;
                }
              }
            }
            return null;
          }
          imageRowToCodewordIndex(imageRow) {
            return imageRow - this.boundingBox.getMinY();
          }
          setCodeword(imageRow, codeword) {
            this.codewords[this.imageRowToCodewordIndex(imageRow)] = codeword;
          }
          getCodeword(imageRow) {
            return this.codewords[this.imageRowToCodewordIndex(imageRow)];
          }
          getBoundingBox() {
            return this.boundingBox;
          }
          getCodewords() {
            return this.codewords;
          }
          toString() {
            const formatter = new Formatter();
            let row = 0;
            for (const codeword of this.codewords) {
              if (codeword == null) {
                formatter.format("%3d:    |   %n", row++);
                continue;
              }
              formatter.format("%3d: %3d|%3d%n", row++, codeword.getRowNumber(), codeword.getValue());
            }
            return formatter.toString();
          }
        }
        DetectionResultColumn.MAX_NEARBY_DISTANCE = 5;
        class BarcodeValue {
          constructor() {
            this.values = /* @__PURE__ */ new Map();
          }
          setValue(value) {
            value = Math.trunc(value);
            let confidence = this.values.get(value);
            if (confidence == null) {
              confidence = 0;
            }
            confidence++;
            this.values.set(value, confidence);
          }
          getValue() {
            let maxConfidence = -1;
            let result = new Array();
            for (const [key, value] of this.values.entries()) {
              const entry = {
                getKey: () => key,
                getValue: () => value
              };
              if (entry.getValue() > maxConfidence) {
                maxConfidence = entry.getValue();
                result = [];
                result.push(entry.getKey());
              } else if (entry.getValue() === maxConfidence) {
                result.push(entry.getKey());
              }
            }
            return PDF417Common.toIntArray(result);
          }
          getConfidence(value) {
            return this.values.get(value);
          }
        }
        class DetectionResultRowIndicatorColumn extends DetectionResultColumn {
          constructor(boundingBox, isLeft) {
            super(boundingBox);
            this._isLeft = isLeft;
          }
          setRowNumbers() {
            for (let codeword of this.getCodewords()) {
              if (codeword != null) {
                codeword.setRowNumberAsRowIndicatorColumn();
              }
            }
          }
          adjustCompleteIndicatorColumnRowNumbers(barcodeMetadata) {
            let codewords = this.getCodewords();
            this.setRowNumbers();
            this.removeIncorrectCodewords(codewords, barcodeMetadata);
            let boundingBox = this.getBoundingBox();
            let top = this._isLeft ? boundingBox.getTopLeft() : boundingBox.getTopRight();
            let bottom = this._isLeft ? boundingBox.getBottomLeft() : boundingBox.getBottomRight();
            let firstRow = this.imageRowToCodewordIndex(Math.trunc(top.getY()));
            let lastRow = this.imageRowToCodewordIndex(Math.trunc(bottom.getY()));
            let barcodeRow = -1;
            let maxRowHeight = 1;
            let currentRowHeight = 0;
            for (let codewordsRow = firstRow; codewordsRow < lastRow; codewordsRow++) {
              if (codewords[codewordsRow] == null) {
                continue;
              }
              let codeword = codewords[codewordsRow];
              let rowDifference = codeword.getRowNumber() - barcodeRow;
              if (rowDifference === 0) {
                currentRowHeight++;
              } else if (rowDifference === 1) {
                maxRowHeight = Math.max(maxRowHeight, currentRowHeight);
                currentRowHeight = 1;
                barcodeRow = codeword.getRowNumber();
              } else if (rowDifference < 0 || codeword.getRowNumber() >= barcodeMetadata.getRowCount() || rowDifference > codewordsRow) {
                codewords[codewordsRow] = null;
              } else {
                let checkedRows;
                if (maxRowHeight > 2) {
                  checkedRows = (maxRowHeight - 2) * rowDifference;
                } else {
                  checkedRows = rowDifference;
                }
                let closePreviousCodewordFound = checkedRows >= codewordsRow;
                for (let i = 1; i <= checkedRows && !closePreviousCodewordFound; i++) {
                  closePreviousCodewordFound = codewords[codewordsRow - i] != null;
                }
                if (closePreviousCodewordFound) {
                  codewords[codewordsRow] = null;
                } else {
                  barcodeRow = codeword.getRowNumber();
                  currentRowHeight = 1;
                }
              }
            }
          }
          getRowHeights() {
            let barcodeMetadata = this.getBarcodeMetadata();
            if (barcodeMetadata == null) {
              return null;
            }
            this.adjustIncompleteIndicatorColumnRowNumbers(barcodeMetadata);
            let result = new Int32Array(barcodeMetadata.getRowCount());
            for (let codeword of this.getCodewords()) {
              if (codeword != null) {
                let rowNumber = codeword.getRowNumber();
                if (rowNumber >= result.length) {
                  continue;
                }
                result[rowNumber]++;
              }
            }
            return result;
          }
          adjustIncompleteIndicatorColumnRowNumbers(barcodeMetadata) {
            let boundingBox = this.getBoundingBox();
            let top = this._isLeft ? boundingBox.getTopLeft() : boundingBox.getTopRight();
            let bottom = this._isLeft ? boundingBox.getBottomLeft() : boundingBox.getBottomRight();
            let firstRow = this.imageRowToCodewordIndex(Math.trunc(top.getY()));
            let lastRow = this.imageRowToCodewordIndex(Math.trunc(bottom.getY()));
            let codewords = this.getCodewords();
            let barcodeRow = -1;
            for (let codewordsRow = firstRow; codewordsRow < lastRow; codewordsRow++) {
              if (codewords[codewordsRow] == null) {
                continue;
              }
              let codeword = codewords[codewordsRow];
              codeword.setRowNumberAsRowIndicatorColumn();
              let rowDifference = codeword.getRowNumber() - barcodeRow;
              if (rowDifference === 0)
                ;
              else if (rowDifference === 1) {
                barcodeRow = codeword.getRowNumber();
              } else if (codeword.getRowNumber() >= barcodeMetadata.getRowCount()) {
                codewords[codewordsRow] = null;
              } else {
                barcodeRow = codeword.getRowNumber();
              }
            }
          }
          getBarcodeMetadata() {
            let codewords = this.getCodewords();
            let barcodeColumnCount = new BarcodeValue();
            let barcodeRowCountUpperPart = new BarcodeValue();
            let barcodeRowCountLowerPart = new BarcodeValue();
            let barcodeECLevel = new BarcodeValue();
            for (let codeword of codewords) {
              if (codeword == null) {
                continue;
              }
              codeword.setRowNumberAsRowIndicatorColumn();
              let rowIndicatorValue = codeword.getValue() % 30;
              let codewordRowNumber = codeword.getRowNumber();
              if (!this._isLeft) {
                codewordRowNumber += 2;
              }
              switch (codewordRowNumber % 3) {
                case 0:
                  barcodeRowCountUpperPart.setValue(rowIndicatorValue * 3 + 1);
                  break;
                case 1:
                  barcodeECLevel.setValue(rowIndicatorValue / 3);
                  barcodeRowCountLowerPart.setValue(rowIndicatorValue % 3);
                  break;
                case 2:
                  barcodeColumnCount.setValue(rowIndicatorValue + 1);
                  break;
              }
            }
            if (barcodeColumnCount.getValue().length === 0 || barcodeRowCountUpperPart.getValue().length === 0 || barcodeRowCountLowerPart.getValue().length === 0 || barcodeECLevel.getValue().length === 0 || barcodeColumnCount.getValue()[0] < 1 || barcodeRowCountUpperPart.getValue()[0] + barcodeRowCountLowerPart.getValue()[0] < PDF417Common.MIN_ROWS_IN_BARCODE || barcodeRowCountUpperPart.getValue()[0] + barcodeRowCountLowerPart.getValue()[0] > PDF417Common.MAX_ROWS_IN_BARCODE) {
              return null;
            }
            let barcodeMetadata = new BarcodeMetadata(barcodeColumnCount.getValue()[0], barcodeRowCountUpperPart.getValue()[0], barcodeRowCountLowerPart.getValue()[0], barcodeECLevel.getValue()[0]);
            this.removeIncorrectCodewords(codewords, barcodeMetadata);
            return barcodeMetadata;
          }
          removeIncorrectCodewords(codewords, barcodeMetadata) {
            for (let codewordRow = 0; codewordRow < codewords.length; codewordRow++) {
              let codeword = codewords[codewordRow];
              if (codewords[codewordRow] == null) {
                continue;
              }
              let rowIndicatorValue = codeword.getValue() % 30;
              let codewordRowNumber = codeword.getRowNumber();
              if (codewordRowNumber > barcodeMetadata.getRowCount()) {
                codewords[codewordRow] = null;
                continue;
              }
              if (!this._isLeft) {
                codewordRowNumber += 2;
              }
              switch (codewordRowNumber % 3) {
                case 0:
                  if (rowIndicatorValue * 3 + 1 !== barcodeMetadata.getRowCountUpperPart()) {
                    codewords[codewordRow] = null;
                  }
                  break;
                case 1:
                  if (Math.trunc(rowIndicatorValue / 3) !== barcodeMetadata.getErrorCorrectionLevel() || rowIndicatorValue % 3 !== barcodeMetadata.getRowCountLowerPart()) {
                    codewords[codewordRow] = null;
                  }
                  break;
                case 2:
                  if (rowIndicatorValue + 1 !== barcodeMetadata.getColumnCount()) {
                    codewords[codewordRow] = null;
                  }
                  break;
              }
            }
          }
          isLeft() {
            return this._isLeft;
          }
          toString() {
            return "IsLeft: " + this._isLeft + "\n" + super.toString();
          }
        }
        class DetectionResult {
          constructor(barcodeMetadata, boundingBox) {
            this.ADJUST_ROW_NUMBER_SKIP = 2;
            this.barcodeMetadata = barcodeMetadata;
            this.barcodeColumnCount = barcodeMetadata.getColumnCount();
            this.boundingBox = boundingBox;
            this.detectionResultColumns = new Array(this.barcodeColumnCount + 2);
          }
          getDetectionResultColumns() {
            this.adjustIndicatorColumnRowNumbers(this.detectionResultColumns[0]);
            this.adjustIndicatorColumnRowNumbers(this.detectionResultColumns[this.barcodeColumnCount + 1]);
            let unadjustedCodewordCount = PDF417Common.MAX_CODEWORDS_IN_BARCODE;
            let previousUnadjustedCount;
            do {
              previousUnadjustedCount = unadjustedCodewordCount;
              unadjustedCodewordCount = this.adjustRowNumbersAndGetCount();
            } while (unadjustedCodewordCount > 0 && unadjustedCodewordCount < previousUnadjustedCount);
            return this.detectionResultColumns;
          }
          adjustIndicatorColumnRowNumbers(detectionResultColumn) {
            if (detectionResultColumn != null) {
              detectionResultColumn.adjustCompleteIndicatorColumnRowNumbers(this.barcodeMetadata);
            }
          }
          adjustRowNumbersAndGetCount() {
            let unadjustedCount = this.adjustRowNumbersByRow();
            if (unadjustedCount === 0) {
              return 0;
            }
            for (let barcodeColumn = 1; barcodeColumn < this.barcodeColumnCount + 1; barcodeColumn++) {
              let codewords = this.detectionResultColumns[barcodeColumn].getCodewords();
              for (let codewordsRow = 0; codewordsRow < codewords.length; codewordsRow++) {
                if (codewords[codewordsRow] == null) {
                  continue;
                }
                if (!codewords[codewordsRow].hasValidRowNumber()) {
                  this.adjustRowNumbers(barcodeColumn, codewordsRow, codewords);
                }
              }
            }
            return unadjustedCount;
          }
          adjustRowNumbersByRow() {
            this.adjustRowNumbersFromBothRI();
            let unadjustedCount = this.adjustRowNumbersFromLRI();
            return unadjustedCount + this.adjustRowNumbersFromRRI();
          }
          adjustRowNumbersFromBothRI() {
            if (this.detectionResultColumns[0] == null || this.detectionResultColumns[this.barcodeColumnCount + 1] == null) {
              return;
            }
            let LRIcodewords = this.detectionResultColumns[0].getCodewords();
            let RRIcodewords = this.detectionResultColumns[this.barcodeColumnCount + 1].getCodewords();
            for (let codewordsRow = 0; codewordsRow < LRIcodewords.length; codewordsRow++) {
              if (LRIcodewords[codewordsRow] != null && RRIcodewords[codewordsRow] != null && LRIcodewords[codewordsRow].getRowNumber() === RRIcodewords[codewordsRow].getRowNumber()) {
                for (let barcodeColumn = 1; barcodeColumn <= this.barcodeColumnCount; barcodeColumn++) {
                  let codeword = this.detectionResultColumns[barcodeColumn].getCodewords()[codewordsRow];
                  if (codeword == null) {
                    continue;
                  }
                  codeword.setRowNumber(LRIcodewords[codewordsRow].getRowNumber());
                  if (!codeword.hasValidRowNumber()) {
                    this.detectionResultColumns[barcodeColumn].getCodewords()[codewordsRow] = null;
                  }
                }
              }
            }
          }
          adjustRowNumbersFromRRI() {
            if (this.detectionResultColumns[this.barcodeColumnCount + 1] == null) {
              return 0;
            }
            let unadjustedCount = 0;
            let codewords = this.detectionResultColumns[this.barcodeColumnCount + 1].getCodewords();
            for (let codewordsRow = 0; codewordsRow < codewords.length; codewordsRow++) {
              if (codewords[codewordsRow] == null) {
                continue;
              }
              let rowIndicatorRowNumber = codewords[codewordsRow].getRowNumber();
              let invalidRowCounts = 0;
              for (let barcodeColumn = this.barcodeColumnCount + 1; barcodeColumn > 0 && invalidRowCounts < this.ADJUST_ROW_NUMBER_SKIP; barcodeColumn--) {
                let codeword = this.detectionResultColumns[barcodeColumn].getCodewords()[codewordsRow];
                if (codeword != null) {
                  invalidRowCounts = DetectionResult.adjustRowNumberIfValid(rowIndicatorRowNumber, invalidRowCounts, codeword);
                  if (!codeword.hasValidRowNumber()) {
                    unadjustedCount++;
                  }
                }
              }
            }
            return unadjustedCount;
          }
          adjustRowNumbersFromLRI() {
            if (this.detectionResultColumns[0] == null) {
              return 0;
            }
            let unadjustedCount = 0;
            let codewords = this.detectionResultColumns[0].getCodewords();
            for (let codewordsRow = 0; codewordsRow < codewords.length; codewordsRow++) {
              if (codewords[codewordsRow] == null) {
                continue;
              }
              let rowIndicatorRowNumber = codewords[codewordsRow].getRowNumber();
              let invalidRowCounts = 0;
              for (let barcodeColumn = 1; barcodeColumn < this.barcodeColumnCount + 1 && invalidRowCounts < this.ADJUST_ROW_NUMBER_SKIP; barcodeColumn++) {
                let codeword = this.detectionResultColumns[barcodeColumn].getCodewords()[codewordsRow];
                if (codeword != null) {
                  invalidRowCounts = DetectionResult.adjustRowNumberIfValid(rowIndicatorRowNumber, invalidRowCounts, codeword);
                  if (!codeword.hasValidRowNumber()) {
                    unadjustedCount++;
                  }
                }
              }
            }
            return unadjustedCount;
          }
          static adjustRowNumberIfValid(rowIndicatorRowNumber, invalidRowCounts, codeword) {
            if (codeword == null) {
              return invalidRowCounts;
            }
            if (!codeword.hasValidRowNumber()) {
              if (codeword.isValidRowNumber(rowIndicatorRowNumber)) {
                codeword.setRowNumber(rowIndicatorRowNumber);
                invalidRowCounts = 0;
              } else {
                ++invalidRowCounts;
              }
            }
            return invalidRowCounts;
          }
          adjustRowNumbers(barcodeColumn, codewordsRow, codewords) {
            if (!this.detectionResultColumns[barcodeColumn - 1]) {
              return;
            }
            let codeword = codewords[codewordsRow];
            let previousColumnCodewords = this.detectionResultColumns[barcodeColumn - 1].getCodewords();
            let nextColumnCodewords = previousColumnCodewords;
            if (this.detectionResultColumns[barcodeColumn + 1] != null) {
              nextColumnCodewords = this.detectionResultColumns[barcodeColumn + 1].getCodewords();
            }
            let otherCodewords = new Array(14);
            otherCodewords[2] = previousColumnCodewords[codewordsRow];
            otherCodewords[3] = nextColumnCodewords[codewordsRow];
            if (codewordsRow > 0) {
              otherCodewords[0] = codewords[codewordsRow - 1];
              otherCodewords[4] = previousColumnCodewords[codewordsRow - 1];
              otherCodewords[5] = nextColumnCodewords[codewordsRow - 1];
            }
            if (codewordsRow > 1) {
              otherCodewords[8] = codewords[codewordsRow - 2];
              otherCodewords[10] = previousColumnCodewords[codewordsRow - 2];
              otherCodewords[11] = nextColumnCodewords[codewordsRow - 2];
            }
            if (codewordsRow < codewords.length - 1) {
              otherCodewords[1] = codewords[codewordsRow + 1];
              otherCodewords[6] = previousColumnCodewords[codewordsRow + 1];
              otherCodewords[7] = nextColumnCodewords[codewordsRow + 1];
            }
            if (codewordsRow < codewords.length - 2) {
              otherCodewords[9] = codewords[codewordsRow + 2];
              otherCodewords[12] = previousColumnCodewords[codewordsRow + 2];
              otherCodewords[13] = nextColumnCodewords[codewordsRow + 2];
            }
            for (let otherCodeword of otherCodewords) {
              if (DetectionResult.adjustRowNumber(codeword, otherCodeword)) {
                return;
              }
            }
          }
          static adjustRowNumber(codeword, otherCodeword) {
            if (otherCodeword == null) {
              return false;
            }
            if (otherCodeword.hasValidRowNumber() && otherCodeword.getBucket() === codeword.getBucket()) {
              codeword.setRowNumber(otherCodeword.getRowNumber());
              return true;
            }
            return false;
          }
          getBarcodeColumnCount() {
            return this.barcodeColumnCount;
          }
          getBarcodeRowCount() {
            return this.barcodeMetadata.getRowCount();
          }
          getBarcodeECLevel() {
            return this.barcodeMetadata.getErrorCorrectionLevel();
          }
          setBoundingBox(boundingBox) {
            this.boundingBox = boundingBox;
          }
          getBoundingBox() {
            return this.boundingBox;
          }
          setDetectionResultColumn(barcodeColumn, detectionResultColumn) {
            this.detectionResultColumns[barcodeColumn] = detectionResultColumn;
          }
          getDetectionResultColumn(barcodeColumn) {
            return this.detectionResultColumns[barcodeColumn];
          }
          toString() {
            let rowIndicatorColumn = this.detectionResultColumns[0];
            if (rowIndicatorColumn == null) {
              rowIndicatorColumn = this.detectionResultColumns[this.barcodeColumnCount + 1];
            }
            let formatter = new Formatter();
            for (let codewordsRow = 0; codewordsRow < rowIndicatorColumn.getCodewords().length; codewordsRow++) {
              formatter.format("CW %3d:", codewordsRow);
              for (let barcodeColumn = 0; barcodeColumn < this.barcodeColumnCount + 2; barcodeColumn++) {
                if (this.detectionResultColumns[barcodeColumn] == null) {
                  formatter.format("    |   ");
                  continue;
                }
                let codeword = this.detectionResultColumns[barcodeColumn].getCodewords()[codewordsRow];
                if (codeword == null) {
                  formatter.format("    |   ");
                  continue;
                }
                formatter.format(" %3d|%3d", codeword.getRowNumber(), codeword.getValue());
              }
              formatter.format("%n");
            }
            return formatter.toString();
          }
        }
        class Codeword {
          constructor(startX, endX, bucket, value) {
            this.rowNumber = Codeword.BARCODE_ROW_UNKNOWN;
            this.startX = Math.trunc(startX);
            this.endX = Math.trunc(endX);
            this.bucket = Math.trunc(bucket);
            this.value = Math.trunc(value);
          }
          hasValidRowNumber() {
            return this.isValidRowNumber(this.rowNumber);
          }
          isValidRowNumber(rowNumber) {
            return rowNumber !== Codeword.BARCODE_ROW_UNKNOWN && this.bucket === rowNumber % 3 * 3;
          }
          setRowNumberAsRowIndicatorColumn() {
            this.rowNumber = Math.trunc(Math.trunc(this.value / 30) * 3 + Math.trunc(this.bucket / 3));
          }
          getWidth() {
            return this.endX - this.startX;
          }
          getStartX() {
            return this.startX;
          }
          getEndX() {
            return this.endX;
          }
          getBucket() {
            return this.bucket;
          }
          getValue() {
            return this.value;
          }
          getRowNumber() {
            return this.rowNumber;
          }
          setRowNumber(rowNumber) {
            this.rowNumber = rowNumber;
          }
          toString() {
            return this.rowNumber + "|" + this.value;
          }
        }
        Codeword.BARCODE_ROW_UNKNOWN = -1;
        class PDF417CodewordDecoder {
          static initialize() {
            for (let i = 0; i < PDF417Common.SYMBOL_TABLE.length; i++) {
              let currentSymbol = PDF417Common.SYMBOL_TABLE[i];
              let currentBit = currentSymbol & 1;
              for (let j = 0; j < PDF417Common.BARS_IN_MODULE; j++) {
                let size2 = 0;
                while ((currentSymbol & 1) === currentBit) {
                  size2 += 1;
                  currentSymbol >>= 1;
                }
                currentBit = currentSymbol & 1;
                if (!PDF417CodewordDecoder.RATIOS_TABLE[i]) {
                  PDF417CodewordDecoder.RATIOS_TABLE[i] = new Array(PDF417Common.BARS_IN_MODULE);
                }
                PDF417CodewordDecoder.RATIOS_TABLE[i][PDF417Common.BARS_IN_MODULE - j - 1] = Math.fround(size2 / PDF417Common.MODULES_IN_CODEWORD);
              }
            }
            this.bSymbolTableReady = true;
          }
          static getDecodedValue(moduleBitCount) {
            let decodedValue = PDF417CodewordDecoder.getDecodedCodewordValue(PDF417CodewordDecoder.sampleBitCounts(moduleBitCount));
            if (decodedValue !== -1) {
              return decodedValue;
            }
            return PDF417CodewordDecoder.getClosestDecodedValue(moduleBitCount);
          }
          static sampleBitCounts(moduleBitCount) {
            let bitCountSum = MathUtils.sum(moduleBitCount);
            let result = new Int32Array(PDF417Common.BARS_IN_MODULE);
            let bitCountIndex = 0;
            let sumPreviousBits = 0;
            for (let i = 0; i < PDF417Common.MODULES_IN_CODEWORD; i++) {
              let sampleIndex = bitCountSum / (2 * PDF417Common.MODULES_IN_CODEWORD) + i * bitCountSum / PDF417Common.MODULES_IN_CODEWORD;
              if (sumPreviousBits + moduleBitCount[bitCountIndex] <= sampleIndex) {
                sumPreviousBits += moduleBitCount[bitCountIndex];
                bitCountIndex++;
              }
              result[bitCountIndex]++;
            }
            return result;
          }
          static getDecodedCodewordValue(moduleBitCount) {
            let decodedValue = PDF417CodewordDecoder.getBitValue(moduleBitCount);
            return PDF417Common.getCodeword(decodedValue) === -1 ? -1 : decodedValue;
          }
          static getBitValue(moduleBitCount) {
            let result = 0;
            for (let i = 0; i < moduleBitCount.length; i++) {
              for (let bit = 0; bit < moduleBitCount[i]; bit++) {
                result = result << 1 | (i % 2 === 0 ? 1 : 0);
              }
            }
            return Math.trunc(result);
          }
          static getClosestDecodedValue(moduleBitCount) {
            let bitCountSum = MathUtils.sum(moduleBitCount);
            let bitCountRatios = new Array(PDF417Common.BARS_IN_MODULE);
            if (bitCountSum > 1) {
              for (let i = 0; i < bitCountRatios.length; i++) {
                bitCountRatios[i] = Math.fround(moduleBitCount[i] / bitCountSum);
              }
            }
            let bestMatchError = Float.MAX_VALUE;
            let bestMatch = -1;
            if (!this.bSymbolTableReady) {
              PDF417CodewordDecoder.initialize();
            }
            for (let j = 0; j < PDF417CodewordDecoder.RATIOS_TABLE.length; j++) {
              let error2 = 0;
              let ratioTableRow = PDF417CodewordDecoder.RATIOS_TABLE[j];
              for (let k = 0; k < PDF417Common.BARS_IN_MODULE; k++) {
                let diff = Math.fround(ratioTableRow[k] - bitCountRatios[k]);
                error2 += Math.fround(diff * diff);
                if (error2 >= bestMatchError) {
                  break;
                }
              }
              if (error2 < bestMatchError) {
                bestMatchError = error2;
                bestMatch = PDF417Common.SYMBOL_TABLE[j];
              }
            }
            return bestMatch;
          }
        }
        PDF417CodewordDecoder.bSymbolTableReady = false;
        PDF417CodewordDecoder.RATIOS_TABLE = new Array(PDF417Common.SYMBOL_TABLE.length).map((x) => x = new Array(PDF417Common.BARS_IN_MODULE));
        class PDF417ResultMetadata {
          constructor() {
            this.segmentCount = -1;
            this.fileSize = -1;
            this.timestamp = -1;
            this.checksum = -1;
          }
          getSegmentIndex() {
            return this.segmentIndex;
          }
          setSegmentIndex(segmentIndex) {
            this.segmentIndex = segmentIndex;
          }
          getFileId() {
            return this.fileId;
          }
          setFileId(fileId) {
            this.fileId = fileId;
          }
          getOptionalData() {
            return this.optionalData;
          }
          setOptionalData(optionalData) {
            this.optionalData = optionalData;
          }
          isLastSegment() {
            return this.lastSegment;
          }
          setLastSegment(lastSegment) {
            this.lastSegment = lastSegment;
          }
          getSegmentCount() {
            return this.segmentCount;
          }
          setSegmentCount(segmentCount) {
            this.segmentCount = segmentCount;
          }
          getSender() {
            return this.sender || null;
          }
          setSender(sender) {
            this.sender = sender;
          }
          getAddressee() {
            return this.addressee || null;
          }
          setAddressee(addressee) {
            this.addressee = addressee;
          }
          getFileName() {
            return this.fileName;
          }
          setFileName(fileName) {
            this.fileName = fileName;
          }
          getFileSize() {
            return this.fileSize;
          }
          setFileSize(fileSize) {
            this.fileSize = fileSize;
          }
          getChecksum() {
            return this.checksum;
          }
          setChecksum(checksum) {
            this.checksum = checksum;
          }
          getTimestamp() {
            return this.timestamp;
          }
          setTimestamp(timestamp) {
            this.timestamp = timestamp;
          }
        }
        class Long {
          static parseLong(num, radix = void 0) {
            return parseInt(num, radix);
          }
        }
        class NullPointerException extends Exception {
        }
        NullPointerException.kind = "NullPointerException";
        class OutputStream {
          writeBytes(b) {
            this.writeBytesOffset(b, 0, b.length);
          }
          writeBytesOffset(b, off, len) {
            if (b == null) {
              throw new NullPointerException();
            } else if (off < 0 || off > b.length || len < 0 || off + len > b.length || off + len < 0) {
              throw new IndexOutOfBoundsException();
            } else if (len === 0) {
              return;
            }
            for (let i = 0; i < len; i++) {
              this.write(b[off + i]);
            }
          }
          flush() {
          }
          close() {
          }
        }
        class OutOfMemoryError extends Exception {
        }
        class ByteArrayOutputStream extends OutputStream {
          constructor(size2 = 32) {
            super();
            this.count = 0;
            if (size2 < 0) {
              throw new IllegalArgumentException("Negative initial size: " + size2);
            }
            this.buf = new Uint8Array(size2);
          }
          ensureCapacity(minCapacity) {
            if (minCapacity - this.buf.length > 0)
              this.grow(minCapacity);
          }
          grow(minCapacity) {
            let oldCapacity = this.buf.length;
            let newCapacity = oldCapacity << 1;
            if (newCapacity - minCapacity < 0)
              newCapacity = minCapacity;
            if (newCapacity < 0) {
              if (minCapacity < 0)
                throw new OutOfMemoryError();
              newCapacity = Integer.MAX_VALUE;
            }
            this.buf = Arrays.copyOfUint8Array(this.buf, newCapacity);
          }
          write(b) {
            this.ensureCapacity(this.count + 1);
            this.buf[this.count] = b;
            this.count += 1;
          }
          writeBytesOffset(b, off, len) {
            if (off < 0 || off > b.length || len < 0 || off + len - b.length > 0) {
              throw new IndexOutOfBoundsException();
            }
            this.ensureCapacity(this.count + len);
            System.arraycopy(b, off, this.buf, this.count, len);
            this.count += len;
          }
          writeTo(out) {
            out.writeBytesOffset(this.buf, 0, this.count);
          }
          reset() {
            this.count = 0;
          }
          toByteArray() {
            return Arrays.copyOfUint8Array(this.buf, this.count);
          }
          size() {
            return this.count;
          }
          toString(param) {
            if (!param) {
              return this.toString_void();
            }
            if (typeof param === "string") {
              return this.toString_string(param);
            }
            return this.toString_number(param);
          }
          toString_void() {
            return new String(this.buf).toString();
          }
          toString_string(charsetName) {
            return new String(this.buf).toString();
          }
          toString_number(hibyte) {
            return new String(this.buf).toString();
          }
          close() {
          }
        }
        var Mode$2;
        (function(Mode2) {
          Mode2[Mode2["ALPHA"] = 0] = "ALPHA";
          Mode2[Mode2["LOWER"] = 1] = "LOWER";
          Mode2[Mode2["MIXED"] = 2] = "MIXED";
          Mode2[Mode2["PUNCT"] = 3] = "PUNCT";
          Mode2[Mode2["ALPHA_SHIFT"] = 4] = "ALPHA_SHIFT";
          Mode2[Mode2["PUNCT_SHIFT"] = 5] = "PUNCT_SHIFT";
        })(Mode$2 || (Mode$2 = {}));
        function getBigIntConstructor() {
          if (typeof window !== "undefined") {
            return window["BigInt"] || null;
          }
          if (typeof global !== "undefined") {
            return global["BigInt"] || null;
          }
          if (typeof self !== "undefined") {
            return self["BigInt"] || null;
          }
          throw new Error("Can't search globals for BigInt!");
        }
        let BigInteger;
        function createBigInt(num) {
          if (typeof BigInteger === "undefined") {
            BigInteger = getBigIntConstructor();
          }
          if (BigInteger === null) {
            throw new Error("BigInt is not supported!");
          }
          return BigInteger(num);
        }
        function getEXP900() {
          let EXP900 = [];
          EXP900[0] = createBigInt(1);
          let nineHundred = createBigInt(900);
          EXP900[1] = nineHundred;
          for (let i = 2; i < 16; i++) {
            EXP900[i] = EXP900[i - 1] * nineHundred;
          }
          return EXP900;
        }
        class DecodedBitStreamParser$2 {
          static decode(codewords, ecLevel) {
            let result = new StringBuilder("");
            let encoding = CharacterSetECI.ISO8859_1;
            result.enableDecoding(encoding);
            let codeIndex = 1;
            let code = codewords[codeIndex++];
            let resultMetadata = new PDF417ResultMetadata();
            while (codeIndex < codewords[0]) {
              switch (code) {
                case DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH:
                  codeIndex = DecodedBitStreamParser$2.textCompaction(codewords, codeIndex, result);
                  break;
                case DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH:
                case DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH_6:
                  codeIndex = DecodedBitStreamParser$2.byteCompaction(code, codewords, encoding, codeIndex, result);
                  break;
                case DecodedBitStreamParser$2.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:
                  result.append(codewords[codeIndex++]);
                  break;
                case DecodedBitStreamParser$2.NUMERIC_COMPACTION_MODE_LATCH:
                  codeIndex = DecodedBitStreamParser$2.numericCompaction(codewords, codeIndex, result);
                  break;
                case DecodedBitStreamParser$2.ECI_CHARSET:
                  let charsetECI = CharacterSetECI.getCharacterSetECIByValue(codewords[codeIndex++]);
                  break;
                case DecodedBitStreamParser$2.ECI_GENERAL_PURPOSE:
                  codeIndex += 2;
                  break;
                case DecodedBitStreamParser$2.ECI_USER_DEFINED:
                  codeIndex++;
                  break;
                case DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_CONTROL_BLOCK:
                  codeIndex = DecodedBitStreamParser$2.decodeMacroBlock(codewords, codeIndex, resultMetadata);
                  break;
                case DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:
                case DecodedBitStreamParser$2.MACRO_PDF417_TERMINATOR:
                  throw new FormatException();
                default:
                  codeIndex--;
                  codeIndex = DecodedBitStreamParser$2.textCompaction(codewords, codeIndex, result);
                  break;
              }
              if (codeIndex < codewords.length) {
                code = codewords[codeIndex++];
              } else {
                throw FormatException.getFormatInstance();
              }
            }
            if (result.length() === 0) {
              throw FormatException.getFormatInstance();
            }
            let decoderResult = new DecoderResult(null, result.toString(), null, ecLevel);
            decoderResult.setOther(resultMetadata);
            return decoderResult;
          }
          static decodeMacroBlock(codewords, codeIndex, resultMetadata) {
            if (codeIndex + DecodedBitStreamParser$2.NUMBER_OF_SEQUENCE_CODEWORDS > codewords[0]) {
              throw FormatException.getFormatInstance();
            }
            let segmentIndexArray = new Int32Array(DecodedBitStreamParser$2.NUMBER_OF_SEQUENCE_CODEWORDS);
            for (let i = 0; i < DecodedBitStreamParser$2.NUMBER_OF_SEQUENCE_CODEWORDS; i++, codeIndex++) {
              segmentIndexArray[i] = codewords[codeIndex];
            }
            resultMetadata.setSegmentIndex(Integer.parseInt(DecodedBitStreamParser$2.decodeBase900toBase10(segmentIndexArray, DecodedBitStreamParser$2.NUMBER_OF_SEQUENCE_CODEWORDS)));
            let fileId = new StringBuilder();
            codeIndex = DecodedBitStreamParser$2.textCompaction(codewords, codeIndex, fileId);
            resultMetadata.setFileId(fileId.toString());
            let optionalFieldsStart = -1;
            if (codewords[codeIndex] === DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_OPTIONAL_FIELD) {
              optionalFieldsStart = codeIndex + 1;
            }
            while (codeIndex < codewords[0]) {
              switch (codewords[codeIndex]) {
                case DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:
                  codeIndex++;
                  switch (codewords[codeIndex]) {
                    case DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_FILE_NAME:
                      let fileName = new StringBuilder();
                      codeIndex = DecodedBitStreamParser$2.textCompaction(codewords, codeIndex + 1, fileName);
                      resultMetadata.setFileName(fileName.toString());
                      break;
                    case DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_SENDER:
                      let sender = new StringBuilder();
                      codeIndex = DecodedBitStreamParser$2.textCompaction(codewords, codeIndex + 1, sender);
                      resultMetadata.setSender(sender.toString());
                      break;
                    case DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_ADDRESSEE:
                      let addressee = new StringBuilder();
                      codeIndex = DecodedBitStreamParser$2.textCompaction(codewords, codeIndex + 1, addressee);
                      resultMetadata.setAddressee(addressee.toString());
                      break;
                    case DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_SEGMENT_COUNT:
                      let segmentCount = new StringBuilder();
                      codeIndex = DecodedBitStreamParser$2.numericCompaction(codewords, codeIndex + 1, segmentCount);
                      resultMetadata.setSegmentCount(Integer.parseInt(segmentCount.toString()));
                      break;
                    case DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_TIME_STAMP:
                      let timestamp = new StringBuilder();
                      codeIndex = DecodedBitStreamParser$2.numericCompaction(codewords, codeIndex + 1, timestamp);
                      resultMetadata.setTimestamp(Long.parseLong(timestamp.toString()));
                      break;
                    case DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_CHECKSUM:
                      let checksum = new StringBuilder();
                      codeIndex = DecodedBitStreamParser$2.numericCompaction(codewords, codeIndex + 1, checksum);
                      resultMetadata.setChecksum(Integer.parseInt(checksum.toString()));
                      break;
                    case DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_FILE_SIZE:
                      let fileSize = new StringBuilder();
                      codeIndex = DecodedBitStreamParser$2.numericCompaction(codewords, codeIndex + 1, fileSize);
                      resultMetadata.setFileSize(Long.parseLong(fileSize.toString()));
                      break;
                    default:
                      throw FormatException.getFormatInstance();
                  }
                  break;
                case DecodedBitStreamParser$2.MACRO_PDF417_TERMINATOR:
                  codeIndex++;
                  resultMetadata.setLastSegment(true);
                  break;
                default:
                  throw FormatException.getFormatInstance();
              }
            }
            if (optionalFieldsStart !== -1) {
              let optionalFieldsLength = codeIndex - optionalFieldsStart;
              if (resultMetadata.isLastSegment()) {
                optionalFieldsLength--;
              }
              resultMetadata.setOptionalData(Arrays.copyOfRange(codewords, optionalFieldsStart, optionalFieldsStart + optionalFieldsLength));
            }
            return codeIndex;
          }
          static textCompaction(codewords, codeIndex, result) {
            let textCompactionData = new Int32Array((codewords[0] - codeIndex) * 2);
            let byteCompactionData = new Int32Array((codewords[0] - codeIndex) * 2);
            let index = 0;
            let end = false;
            while (codeIndex < codewords[0] && !end) {
              let code = codewords[codeIndex++];
              if (code < DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH) {
                textCompactionData[index] = code / 30;
                textCompactionData[index + 1] = code % 30;
                index += 2;
              } else {
                switch (code) {
                  case DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH:
                    textCompactionData[index++] = DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH;
                    break;
                  case DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH:
                  case DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH_6:
                  case DecodedBitStreamParser$2.NUMERIC_COMPACTION_MODE_LATCH:
                  case DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_CONTROL_BLOCK:
                  case DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:
                  case DecodedBitStreamParser$2.MACRO_PDF417_TERMINATOR:
                    codeIndex--;
                    end = true;
                    break;
                  case DecodedBitStreamParser$2.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:
                    textCompactionData[index] = DecodedBitStreamParser$2.MODE_SHIFT_TO_BYTE_COMPACTION_MODE;
                    code = codewords[codeIndex++];
                    byteCompactionData[index] = code;
                    index++;
                    break;
                }
              }
            }
            DecodedBitStreamParser$2.decodeTextCompaction(textCompactionData, byteCompactionData, index, result);
            return codeIndex;
          }
          static decodeTextCompaction(textCompactionData, byteCompactionData, length, result) {
            let subMode = Mode$2.ALPHA;
            let priorToShiftMode = Mode$2.ALPHA;
            let i = 0;
            while (i < length) {
              let subModeCh = textCompactionData[i];
              let ch = "";
              switch (subMode) {
                case Mode$2.ALPHA:
                  if (subModeCh < 26) {
                    ch = String.fromCharCode(65 + subModeCh);
                  } else {
                    switch (subModeCh) {
                      case 26:
                        ch = " ";
                        break;
                      case DecodedBitStreamParser$2.LL:
                        subMode = Mode$2.LOWER;
                        break;
                      case DecodedBitStreamParser$2.ML:
                        subMode = Mode$2.MIXED;
                        break;
                      case DecodedBitStreamParser$2.PS:
                        priorToShiftMode = subMode;
                        subMode = Mode$2.PUNCT_SHIFT;
                        break;
                      case DecodedBitStreamParser$2.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:
                        result.append(byteCompactionData[i]);
                        break;
                      case DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH:
                        subMode = Mode$2.ALPHA;
                        break;
                    }
                  }
                  break;
                case Mode$2.LOWER:
                  if (subModeCh < 26) {
                    ch = String.fromCharCode(97 + subModeCh);
                  } else {
                    switch (subModeCh) {
                      case 26:
                        ch = " ";
                        break;
                      case DecodedBitStreamParser$2.AS:
                        priorToShiftMode = subMode;
                        subMode = Mode$2.ALPHA_SHIFT;
                        break;
                      case DecodedBitStreamParser$2.ML:
                        subMode = Mode$2.MIXED;
                        break;
                      case DecodedBitStreamParser$2.PS:
                        priorToShiftMode = subMode;
                        subMode = Mode$2.PUNCT_SHIFT;
                        break;
                      case DecodedBitStreamParser$2.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:
                        result.append(byteCompactionData[i]);
                        break;
                      case DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH:
                        subMode = Mode$2.ALPHA;
                        break;
                    }
                  }
                  break;
                case Mode$2.MIXED:
                  if (subModeCh < DecodedBitStreamParser$2.PL) {
                    ch = DecodedBitStreamParser$2.MIXED_CHARS[subModeCh];
                  } else {
                    switch (subModeCh) {
                      case DecodedBitStreamParser$2.PL:
                        subMode = Mode$2.PUNCT;
                        break;
                      case 26:
                        ch = " ";
                        break;
                      case DecodedBitStreamParser$2.LL:
                        subMode = Mode$2.LOWER;
                        break;
                      case DecodedBitStreamParser$2.AL:
                        subMode = Mode$2.ALPHA;
                        break;
                      case DecodedBitStreamParser$2.PS:
                        priorToShiftMode = subMode;
                        subMode = Mode$2.PUNCT_SHIFT;
                        break;
                      case DecodedBitStreamParser$2.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:
                        result.append(byteCompactionData[i]);
                        break;
                      case DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH:
                        subMode = Mode$2.ALPHA;
                        break;
                    }
                  }
                  break;
                case Mode$2.PUNCT:
                  if (subModeCh < DecodedBitStreamParser$2.PAL) {
                    ch = DecodedBitStreamParser$2.PUNCT_CHARS[subModeCh];
                  } else {
                    switch (subModeCh) {
                      case DecodedBitStreamParser$2.PAL:
                        subMode = Mode$2.ALPHA;
                        break;
                      case DecodedBitStreamParser$2.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:
                        result.append(byteCompactionData[i]);
                        break;
                      case DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH:
                        subMode = Mode$2.ALPHA;
                        break;
                    }
                  }
                  break;
                case Mode$2.ALPHA_SHIFT:
                  subMode = priorToShiftMode;
                  if (subModeCh < 26) {
                    ch = String.fromCharCode(65 + subModeCh);
                  } else {
                    switch (subModeCh) {
                      case 26:
                        ch = " ";
                        break;
                      case DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH:
                        subMode = Mode$2.ALPHA;
                        break;
                    }
                  }
                  break;
                case Mode$2.PUNCT_SHIFT:
                  subMode = priorToShiftMode;
                  if (subModeCh < DecodedBitStreamParser$2.PAL) {
                    ch = DecodedBitStreamParser$2.PUNCT_CHARS[subModeCh];
                  } else {
                    switch (subModeCh) {
                      case DecodedBitStreamParser$2.PAL:
                        subMode = Mode$2.ALPHA;
                        break;
                      case DecodedBitStreamParser$2.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:
                        result.append(byteCompactionData[i]);
                        break;
                      case DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH:
                        subMode = Mode$2.ALPHA;
                        break;
                    }
                  }
                  break;
              }
              if (ch !== "") {
                result.append(ch);
              }
              i++;
            }
          }
          static byteCompaction(mode, codewords, encoding, codeIndex, result) {
            let decodedBytes = new ByteArrayOutputStream();
            let count = 0;
            let value = 0;
            let end = false;
            switch (mode) {
              case DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH:
                let byteCompactedCodewords = new Int32Array(6);
                let nextCode = codewords[codeIndex++];
                while (codeIndex < codewords[0] && !end) {
                  byteCompactedCodewords[count++] = nextCode;
                  value = 900 * value + nextCode;
                  nextCode = codewords[codeIndex++];
                  switch (nextCode) {
                    case DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH:
                    case DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH:
                    case DecodedBitStreamParser$2.NUMERIC_COMPACTION_MODE_LATCH:
                    case DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH_6:
                    case DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_CONTROL_BLOCK:
                    case DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:
                    case DecodedBitStreamParser$2.MACRO_PDF417_TERMINATOR:
                      codeIndex--;
                      end = true;
                      break;
                    default:
                      if (count % 5 === 0 && count > 0) {
                        for (let j = 0; j < 6; ++j) {
                          decodedBytes.write(Number(createBigInt(value) >> createBigInt(8 * (5 - j))));
                        }
                        value = 0;
                        count = 0;
                      }
                      break;
                  }
                }
                if (codeIndex === codewords[0] && nextCode < DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH) {
                  byteCompactedCodewords[count++] = nextCode;
                }
                for (let i = 0; i < count; i++) {
                  decodedBytes.write(byteCompactedCodewords[i]);
                }
                break;
              case DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH_6:
                while (codeIndex < codewords[0] && !end) {
                  let code = codewords[codeIndex++];
                  if (code < DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH) {
                    count++;
                    value = 900 * value + code;
                  } else {
                    switch (code) {
                      case DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH:
                      case DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH:
                      case DecodedBitStreamParser$2.NUMERIC_COMPACTION_MODE_LATCH:
                      case DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH_6:
                      case DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_CONTROL_BLOCK:
                      case DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:
                      case DecodedBitStreamParser$2.MACRO_PDF417_TERMINATOR:
                        codeIndex--;
                        end = true;
                        break;
                    }
                  }
                  if (count % 5 === 0 && count > 0) {
                    for (let j = 0; j < 6; ++j) {
                      decodedBytes.write(Number(createBigInt(value) >> createBigInt(8 * (5 - j))));
                    }
                    value = 0;
                    count = 0;
                  }
                }
                break;
            }
            result.append(StringEncoding.decode(decodedBytes.toByteArray(), encoding));
            return codeIndex;
          }
          static numericCompaction(codewords, codeIndex, result) {
            let count = 0;
            let end = false;
            let numericCodewords = new Int32Array(DecodedBitStreamParser$2.MAX_NUMERIC_CODEWORDS);
            while (codeIndex < codewords[0] && !end) {
              let code = codewords[codeIndex++];
              if (codeIndex === codewords[0]) {
                end = true;
              }
              if (code < DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH) {
                numericCodewords[count] = code;
                count++;
              } else {
                switch (code) {
                  case DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH:
                  case DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH:
                  case DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH_6:
                  case DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_CONTROL_BLOCK:
                  case DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:
                  case DecodedBitStreamParser$2.MACRO_PDF417_TERMINATOR:
                    codeIndex--;
                    end = true;
                    break;
                }
              }
              if ((count % DecodedBitStreamParser$2.MAX_NUMERIC_CODEWORDS === 0 || code === DecodedBitStreamParser$2.NUMERIC_COMPACTION_MODE_LATCH || end) && count > 0) {
                result.append(DecodedBitStreamParser$2.decodeBase900toBase10(numericCodewords, count));
                count = 0;
              }
            }
            return codeIndex;
          }
          static decodeBase900toBase10(codewords, count) {
            let result = createBigInt(0);
            for (let i = 0; i < count; i++) {
              result += DecodedBitStreamParser$2.EXP900[count - i - 1] * createBigInt(codewords[i]);
            }
            let resultString = result.toString();
            if (resultString.charAt(0) !== "1") {
              throw new FormatException();
            }
            return resultString.substring(1);
          }
        }
        DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH = 900;
        DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH = 901;
        DecodedBitStreamParser$2.NUMERIC_COMPACTION_MODE_LATCH = 902;
        DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH_6 = 924;
        DecodedBitStreamParser$2.ECI_USER_DEFINED = 925;
        DecodedBitStreamParser$2.ECI_GENERAL_PURPOSE = 926;
        DecodedBitStreamParser$2.ECI_CHARSET = 927;
        DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_CONTROL_BLOCK = 928;
        DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_OPTIONAL_FIELD = 923;
        DecodedBitStreamParser$2.MACRO_PDF417_TERMINATOR = 922;
        DecodedBitStreamParser$2.MODE_SHIFT_TO_BYTE_COMPACTION_MODE = 913;
        DecodedBitStreamParser$2.MAX_NUMERIC_CODEWORDS = 15;
        DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_FILE_NAME = 0;
        DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_SEGMENT_COUNT = 1;
        DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_TIME_STAMP = 2;
        DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_SENDER = 3;
        DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_ADDRESSEE = 4;
        DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_FILE_SIZE = 5;
        DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_CHECKSUM = 6;
        DecodedBitStreamParser$2.PL = 25;
        DecodedBitStreamParser$2.LL = 27;
        DecodedBitStreamParser$2.AS = 27;
        DecodedBitStreamParser$2.ML = 28;
        DecodedBitStreamParser$2.AL = 28;
        DecodedBitStreamParser$2.PS = 29;
        DecodedBitStreamParser$2.PAL = 29;
        DecodedBitStreamParser$2.PUNCT_CHARS = ";<>@[\\]_`~!\r	,:\n-.$/\"|*()?{}'";
        DecodedBitStreamParser$2.MIXED_CHARS = "0123456789&\r	,:#-.$/+%*=^";
        DecodedBitStreamParser$2.EXP900 = getBigIntConstructor() ? getEXP900() : [];
        DecodedBitStreamParser$2.NUMBER_OF_SEQUENCE_CODEWORDS = 2;
        class PDF417ScanningDecoder {
          constructor() {
          }
          static decode(image, imageTopLeft, imageBottomLeft, imageTopRight, imageBottomRight, minCodewordWidth, maxCodewordWidth) {
            let boundingBox = new BoundingBox(image, imageTopLeft, imageBottomLeft, imageTopRight, imageBottomRight);
            let leftRowIndicatorColumn = null;
            let rightRowIndicatorColumn = null;
            let detectionResult;
            for (let firstPass = true; ; firstPass = false) {
              if (imageTopLeft != null) {
                leftRowIndicatorColumn = PDF417ScanningDecoder.getRowIndicatorColumn(image, boundingBox, imageTopLeft, true, minCodewordWidth, maxCodewordWidth);
              }
              if (imageTopRight != null) {
                rightRowIndicatorColumn = PDF417ScanningDecoder.getRowIndicatorColumn(image, boundingBox, imageTopRight, false, minCodewordWidth, maxCodewordWidth);
              }
              detectionResult = PDF417ScanningDecoder.merge(leftRowIndicatorColumn, rightRowIndicatorColumn);
              if (detectionResult == null) {
                throw NotFoundException.getNotFoundInstance();
              }
              let resultBox = detectionResult.getBoundingBox();
              if (firstPass && resultBox != null && (resultBox.getMinY() < boundingBox.getMinY() || resultBox.getMaxY() > boundingBox.getMaxY())) {
                boundingBox = resultBox;
              } else {
                break;
              }
            }
            detectionResult.setBoundingBox(boundingBox);
            let maxBarcodeColumn = detectionResult.getBarcodeColumnCount() + 1;
            detectionResult.setDetectionResultColumn(0, leftRowIndicatorColumn);
            detectionResult.setDetectionResultColumn(maxBarcodeColumn, rightRowIndicatorColumn);
            let leftToRight = leftRowIndicatorColumn != null;
            for (let barcodeColumnCount = 1; barcodeColumnCount <= maxBarcodeColumn; barcodeColumnCount++) {
              let barcodeColumn = leftToRight ? barcodeColumnCount : maxBarcodeColumn - barcodeColumnCount;
              if (detectionResult.getDetectionResultColumn(barcodeColumn) !== void 0) {
                continue;
              }
              let detectionResultColumn;
              if (barcodeColumn === 0 || barcodeColumn === maxBarcodeColumn) {
                detectionResultColumn = new DetectionResultRowIndicatorColumn(boundingBox, barcodeColumn === 0);
              } else {
                detectionResultColumn = new DetectionResultColumn(boundingBox);
              }
              detectionResult.setDetectionResultColumn(barcodeColumn, detectionResultColumn);
              let startColumn = -1;
              let previousStartColumn = startColumn;
              for (let imageRow = boundingBox.getMinY(); imageRow <= boundingBox.getMaxY(); imageRow++) {
                startColumn = PDF417ScanningDecoder.getStartColumn(detectionResult, barcodeColumn, imageRow, leftToRight);
                if (startColumn < 0 || startColumn > boundingBox.getMaxX()) {
                  if (previousStartColumn === -1) {
                    continue;
                  }
                  startColumn = previousStartColumn;
                }
                let codeword = PDF417ScanningDecoder.detectCodeword(image, boundingBox.getMinX(), boundingBox.getMaxX(), leftToRight, startColumn, imageRow, minCodewordWidth, maxCodewordWidth);
                if (codeword != null) {
                  detectionResultColumn.setCodeword(imageRow, codeword);
                  previousStartColumn = startColumn;
                  minCodewordWidth = Math.min(minCodewordWidth, codeword.getWidth());
                  maxCodewordWidth = Math.max(maxCodewordWidth, codeword.getWidth());
                }
              }
            }
            return PDF417ScanningDecoder.createDecoderResult(detectionResult);
          }
          static merge(leftRowIndicatorColumn, rightRowIndicatorColumn) {
            if (leftRowIndicatorColumn == null && rightRowIndicatorColumn == null) {
              return null;
            }
            let barcodeMetadata = PDF417ScanningDecoder.getBarcodeMetadata(leftRowIndicatorColumn, rightRowIndicatorColumn);
            if (barcodeMetadata == null) {
              return null;
            }
            let boundingBox = BoundingBox.merge(PDF417ScanningDecoder.adjustBoundingBox(leftRowIndicatorColumn), PDF417ScanningDecoder.adjustBoundingBox(rightRowIndicatorColumn));
            return new DetectionResult(barcodeMetadata, boundingBox);
          }
          static adjustBoundingBox(rowIndicatorColumn) {
            if (rowIndicatorColumn == null) {
              return null;
            }
            let rowHeights = rowIndicatorColumn.getRowHeights();
            if (rowHeights == null) {
              return null;
            }
            let maxRowHeight = PDF417ScanningDecoder.getMax(rowHeights);
            let missingStartRows = 0;
            for (let rowHeight of rowHeights) {
              missingStartRows += maxRowHeight - rowHeight;
              if (rowHeight > 0) {
                break;
              }
            }
            let codewords = rowIndicatorColumn.getCodewords();
            for (let row = 0; missingStartRows > 0 && codewords[row] == null; row++) {
              missingStartRows--;
            }
            let missingEndRows = 0;
            for (let row = rowHeights.length - 1; row >= 0; row--) {
              missingEndRows += maxRowHeight - rowHeights[row];
              if (rowHeights[row] > 0) {
                break;
              }
            }
            for (let row = codewords.length - 1; missingEndRows > 0 && codewords[row] == null; row--) {
              missingEndRows--;
            }
            return rowIndicatorColumn.getBoundingBox().addMissingRows(missingStartRows, missingEndRows, rowIndicatorColumn.isLeft());
          }
          static getMax(values) {
            let maxValue = -1;
            for (let value of values) {
              maxValue = Math.max(maxValue, value);
            }
            return maxValue;
          }
          static getBarcodeMetadata(leftRowIndicatorColumn, rightRowIndicatorColumn) {
            let leftBarcodeMetadata;
            if (leftRowIndicatorColumn == null || (leftBarcodeMetadata = leftRowIndicatorColumn.getBarcodeMetadata()) == null) {
              return rightRowIndicatorColumn == null ? null : rightRowIndicatorColumn.getBarcodeMetadata();
            }
            let rightBarcodeMetadata;
            if (rightRowIndicatorColumn == null || (rightBarcodeMetadata = rightRowIndicatorColumn.getBarcodeMetadata()) == null) {
              return leftBarcodeMetadata;
            }
            if (leftBarcodeMetadata.getColumnCount() !== rightBarcodeMetadata.getColumnCount() && leftBarcodeMetadata.getErrorCorrectionLevel() !== rightBarcodeMetadata.getErrorCorrectionLevel() && leftBarcodeMetadata.getRowCount() !== rightBarcodeMetadata.getRowCount()) {
              return null;
            }
            return leftBarcodeMetadata;
          }
          static getRowIndicatorColumn(image, boundingBox, startPoint, leftToRight, minCodewordWidth, maxCodewordWidth) {
            let rowIndicatorColumn = new DetectionResultRowIndicatorColumn(boundingBox, leftToRight);
            for (let i = 0; i < 2; i++) {
              let increment = i === 0 ? 1 : -1;
              let startColumn = Math.trunc(Math.trunc(startPoint.getX()));
              for (let imageRow = Math.trunc(Math.trunc(startPoint.getY())); imageRow <= boundingBox.getMaxY() && imageRow >= boundingBox.getMinY(); imageRow += increment) {
                let codeword = PDF417ScanningDecoder.detectCodeword(image, 0, image.getWidth(), leftToRight, startColumn, imageRow, minCodewordWidth, maxCodewordWidth);
                if (codeword != null) {
                  rowIndicatorColumn.setCodeword(imageRow, codeword);
                  if (leftToRight) {
                    startColumn = codeword.getStartX();
                  } else {
                    startColumn = codeword.getEndX();
                  }
                }
              }
            }
            return rowIndicatorColumn;
          }
          static adjustCodewordCount(detectionResult, barcodeMatrix) {
            let barcodeMatrix01 = barcodeMatrix[0][1];
            let numberOfCodewords = barcodeMatrix01.getValue();
            let calculatedNumberOfCodewords = detectionResult.getBarcodeColumnCount() * detectionResult.getBarcodeRowCount() - PDF417ScanningDecoder.getNumberOfECCodeWords(detectionResult.getBarcodeECLevel());
            if (numberOfCodewords.length === 0) {
              if (calculatedNumberOfCodewords < 1 || calculatedNumberOfCodewords > PDF417Common.MAX_CODEWORDS_IN_BARCODE) {
                throw NotFoundException.getNotFoundInstance();
              }
              barcodeMatrix01.setValue(calculatedNumberOfCodewords);
            } else if (numberOfCodewords[0] !== calculatedNumberOfCodewords) {
              barcodeMatrix01.setValue(calculatedNumberOfCodewords);
            }
          }
          static createDecoderResult(detectionResult) {
            let barcodeMatrix = PDF417ScanningDecoder.createBarcodeMatrix(detectionResult);
            PDF417ScanningDecoder.adjustCodewordCount(detectionResult, barcodeMatrix);
            let erasures = new Array();
            let codewords = new Int32Array(detectionResult.getBarcodeRowCount() * detectionResult.getBarcodeColumnCount());
            let ambiguousIndexValuesList = [];
            let ambiguousIndexesList = new Array();
            for (let row = 0; row < detectionResult.getBarcodeRowCount(); row++) {
              for (let column = 0; column < detectionResult.getBarcodeColumnCount(); column++) {
                let values = barcodeMatrix[row][column + 1].getValue();
                let codewordIndex = row * detectionResult.getBarcodeColumnCount() + column;
                if (values.length === 0) {
                  erasures.push(codewordIndex);
                } else if (values.length === 1) {
                  codewords[codewordIndex] = values[0];
                } else {
                  ambiguousIndexesList.push(codewordIndex);
                  ambiguousIndexValuesList.push(values);
                }
              }
            }
            let ambiguousIndexValues = new Array(ambiguousIndexValuesList.length);
            for (let i = 0; i < ambiguousIndexValues.length; i++) {
              ambiguousIndexValues[i] = ambiguousIndexValuesList[i];
            }
            return PDF417ScanningDecoder.createDecoderResultFromAmbiguousValues(detectionResult.getBarcodeECLevel(), codewords, PDF417Common.toIntArray(erasures), PDF417Common.toIntArray(ambiguousIndexesList), ambiguousIndexValues);
          }
          static createDecoderResultFromAmbiguousValues(ecLevel, codewords, erasureArray, ambiguousIndexes, ambiguousIndexValues) {
            let ambiguousIndexCount = new Int32Array(ambiguousIndexes.length);
            let tries = 100;
            while (tries-- > 0) {
              for (let i = 0; i < ambiguousIndexCount.length; i++) {
                codewords[ambiguousIndexes[i]] = ambiguousIndexValues[i][ambiguousIndexCount[i]];
              }
              try {
                return PDF417ScanningDecoder.decodeCodewords(codewords, ecLevel, erasureArray);
              } catch (err) {
                let ignored = err instanceof ChecksumException;
                if (!ignored) {
                  throw err;
                }
              }
              if (ambiguousIndexCount.length === 0) {
                throw ChecksumException.getChecksumInstance();
              }
              for (let i = 0; i < ambiguousIndexCount.length; i++) {
                if (ambiguousIndexCount[i] < ambiguousIndexValues[i].length - 1) {
                  ambiguousIndexCount[i]++;
                  break;
                } else {
                  ambiguousIndexCount[i] = 0;
                  if (i === ambiguousIndexCount.length - 1) {
                    throw ChecksumException.getChecksumInstance();
                  }
                }
              }
            }
            throw ChecksumException.getChecksumInstance();
          }
          static createBarcodeMatrix(detectionResult) {
            let barcodeMatrix = Array.from({ length: detectionResult.getBarcodeRowCount() }, () => new Array(detectionResult.getBarcodeColumnCount() + 2));
            for (let row = 0; row < barcodeMatrix.length; row++) {
              for (let column2 = 0; column2 < barcodeMatrix[row].length; column2++) {
                barcodeMatrix[row][column2] = new BarcodeValue();
              }
            }
            let column = 0;
            for (let detectionResultColumn of detectionResult.getDetectionResultColumns()) {
              if (detectionResultColumn != null) {
                for (let codeword of detectionResultColumn.getCodewords()) {
                  if (codeword != null) {
                    let rowNumber = codeword.getRowNumber();
                    if (rowNumber >= 0) {
                      if (rowNumber >= barcodeMatrix.length) {
                        continue;
                      }
                      barcodeMatrix[rowNumber][column].setValue(codeword.getValue());
                    }
                  }
                }
              }
              column++;
            }
            return barcodeMatrix;
          }
          static isValidBarcodeColumn(detectionResult, barcodeColumn) {
            return barcodeColumn >= 0 && barcodeColumn <= detectionResult.getBarcodeColumnCount() + 1;
          }
          static getStartColumn(detectionResult, barcodeColumn, imageRow, leftToRight) {
            let offset = leftToRight ? 1 : -1;
            let codeword = null;
            if (PDF417ScanningDecoder.isValidBarcodeColumn(detectionResult, barcodeColumn - offset)) {
              codeword = detectionResult.getDetectionResultColumn(barcodeColumn - offset).getCodeword(imageRow);
            }
            if (codeword != null) {
              return leftToRight ? codeword.getEndX() : codeword.getStartX();
            }
            codeword = detectionResult.getDetectionResultColumn(barcodeColumn).getCodewordNearby(imageRow);
            if (codeword != null) {
              return leftToRight ? codeword.getStartX() : codeword.getEndX();
            }
            if (PDF417ScanningDecoder.isValidBarcodeColumn(detectionResult, barcodeColumn - offset)) {
              codeword = detectionResult.getDetectionResultColumn(barcodeColumn - offset).getCodewordNearby(imageRow);
            }
            if (codeword != null) {
              return leftToRight ? codeword.getEndX() : codeword.getStartX();
            }
            let skippedColumns = 0;
            while (PDF417ScanningDecoder.isValidBarcodeColumn(detectionResult, barcodeColumn - offset)) {
              barcodeColumn -= offset;
              for (let previousRowCodeword of detectionResult.getDetectionResultColumn(barcodeColumn).getCodewords()) {
                if (previousRowCodeword != null) {
                  return (leftToRight ? previousRowCodeword.getEndX() : previousRowCodeword.getStartX()) + offset * skippedColumns * (previousRowCodeword.getEndX() - previousRowCodeword.getStartX());
                }
              }
              skippedColumns++;
            }
            return leftToRight ? detectionResult.getBoundingBox().getMinX() : detectionResult.getBoundingBox().getMaxX();
          }
          static detectCodeword(image, minColumn, maxColumn, leftToRight, startColumn, imageRow, minCodewordWidth, maxCodewordWidth) {
            startColumn = PDF417ScanningDecoder.adjustCodewordStartColumn(image, minColumn, maxColumn, leftToRight, startColumn, imageRow);
            let moduleBitCount = PDF417ScanningDecoder.getModuleBitCount(image, minColumn, maxColumn, leftToRight, startColumn, imageRow);
            if (moduleBitCount == null) {
              return null;
            }
            let endColumn;
            let codewordBitCount = MathUtils.sum(moduleBitCount);
            if (leftToRight) {
              endColumn = startColumn + codewordBitCount;
            } else {
              for (let i = 0; i < moduleBitCount.length / 2; i++) {
                let tmpCount = moduleBitCount[i];
                moduleBitCount[i] = moduleBitCount[moduleBitCount.length - 1 - i];
                moduleBitCount[moduleBitCount.length - 1 - i] = tmpCount;
              }
              endColumn = startColumn;
              startColumn = endColumn - codewordBitCount;
            }
            if (!PDF417ScanningDecoder.checkCodewordSkew(codewordBitCount, minCodewordWidth, maxCodewordWidth)) {
              return null;
            }
            let decodedValue = PDF417CodewordDecoder.getDecodedValue(moduleBitCount);
            let codeword = PDF417Common.getCodeword(decodedValue);
            if (codeword === -1) {
              return null;
            }
            return new Codeword(startColumn, endColumn, PDF417ScanningDecoder.getCodewordBucketNumber(decodedValue), codeword);
          }
          static getModuleBitCount(image, minColumn, maxColumn, leftToRight, startColumn, imageRow) {
            let imageColumn = startColumn;
            let moduleBitCount = new Int32Array(8);
            let moduleNumber = 0;
            let increment = leftToRight ? 1 : -1;
            let previousPixelValue = leftToRight;
            while ((leftToRight ? imageColumn < maxColumn : imageColumn >= minColumn) && moduleNumber < moduleBitCount.length) {
              if (image.get(imageColumn, imageRow) === previousPixelValue) {
                moduleBitCount[moduleNumber]++;
                imageColumn += increment;
              } else {
                moduleNumber++;
                previousPixelValue = !previousPixelValue;
              }
            }
            if (moduleNumber === moduleBitCount.length || imageColumn === (leftToRight ? maxColumn : minColumn) && moduleNumber === moduleBitCount.length - 1) {
              return moduleBitCount;
            }
            return null;
          }
          static getNumberOfECCodeWords(barcodeECLevel) {
            return 2 << barcodeECLevel;
          }
          static adjustCodewordStartColumn(image, minColumn, maxColumn, leftToRight, codewordStartColumn, imageRow) {
            let correctedStartColumn = codewordStartColumn;
            let increment = leftToRight ? -1 : 1;
            for (let i = 0; i < 2; i++) {
              while ((leftToRight ? correctedStartColumn >= minColumn : correctedStartColumn < maxColumn) && leftToRight === image.get(correctedStartColumn, imageRow)) {
                if (Math.abs(codewordStartColumn - correctedStartColumn) > PDF417ScanningDecoder.CODEWORD_SKEW_SIZE) {
                  return codewordStartColumn;
                }
                correctedStartColumn += increment;
              }
              increment = -increment;
              leftToRight = !leftToRight;
            }
            return correctedStartColumn;
          }
          static checkCodewordSkew(codewordSize, minCodewordWidth, maxCodewordWidth) {
            return minCodewordWidth - PDF417ScanningDecoder.CODEWORD_SKEW_SIZE <= codewordSize && codewordSize <= maxCodewordWidth + PDF417ScanningDecoder.CODEWORD_SKEW_SIZE;
          }
          static decodeCodewords(codewords, ecLevel, erasures) {
            if (codewords.length === 0) {
              throw FormatException.getFormatInstance();
            }
            let numECCodewords = 1 << ecLevel + 1;
            let correctedErrorsCount = PDF417ScanningDecoder.correctErrors(codewords, erasures, numECCodewords);
            PDF417ScanningDecoder.verifyCodewordCount(codewords, numECCodewords);
            let decoderResult = DecodedBitStreamParser$2.decode(codewords, "" + ecLevel);
            decoderResult.setErrorsCorrected(correctedErrorsCount);
            decoderResult.setErasures(erasures.length);
            return decoderResult;
          }
          static correctErrors(codewords, erasures, numECCodewords) {
            if (erasures != null && erasures.length > numECCodewords / 2 + PDF417ScanningDecoder.MAX_ERRORS || numECCodewords < 0 || numECCodewords > PDF417ScanningDecoder.MAX_EC_CODEWORDS) {
              throw ChecksumException.getChecksumInstance();
            }
            return PDF417ScanningDecoder.errorCorrection.decode(codewords, numECCodewords, erasures);
          }
          static verifyCodewordCount(codewords, numECCodewords) {
            if (codewords.length < 4) {
              throw FormatException.getFormatInstance();
            }
            let numberOfCodewords = codewords[0];
            if (numberOfCodewords > codewords.length) {
              throw FormatException.getFormatInstance();
            }
            if (numberOfCodewords === 0) {
              if (numECCodewords < codewords.length) {
                codewords[0] = codewords.length - numECCodewords;
              } else {
                throw FormatException.getFormatInstance();
              }
            }
          }
          static getBitCountForCodeword(codeword) {
            let result = new Int32Array(8);
            let previousValue = 0;
            let i = result.length - 1;
            while (true) {
              if ((codeword & 1) !== previousValue) {
                previousValue = codeword & 1;
                i--;
                if (i < 0) {
                  break;
                }
              }
              result[i]++;
              codeword >>= 1;
            }
            return result;
          }
          static getCodewordBucketNumber(codeword) {
            if (codeword instanceof Int32Array) {
              return this.getCodewordBucketNumber_Int32Array(codeword);
            }
            return this.getCodewordBucketNumber_number(codeword);
          }
          static getCodewordBucketNumber_number(codeword) {
            return PDF417ScanningDecoder.getCodewordBucketNumber(PDF417ScanningDecoder.getBitCountForCodeword(codeword));
          }
          static getCodewordBucketNumber_Int32Array(moduleBitCount) {
            return (moduleBitCount[0] - moduleBitCount[2] + moduleBitCount[4] - moduleBitCount[6] + 9) % 9;
          }
          static toString(barcodeMatrix) {
            let formatter = new Formatter();
            for (let row = 0; row < barcodeMatrix.length; row++) {
              formatter.format("Row %2d: ", row);
              for (let column = 0; column < barcodeMatrix[row].length; column++) {
                let barcodeValue = barcodeMatrix[row][column];
                if (barcodeValue.getValue().length === 0) {
                  formatter.format("        ", null);
                } else {
                  formatter.format("%4d(%2d)", barcodeValue.getValue()[0], barcodeValue.getConfidence(barcodeValue.getValue()[0]));
                }
              }
              formatter.format("%n");
            }
            return formatter.toString();
          }
        }
        PDF417ScanningDecoder.CODEWORD_SKEW_SIZE = 2;
        PDF417ScanningDecoder.MAX_ERRORS = 3;
        PDF417ScanningDecoder.MAX_EC_CODEWORDS = 512;
        PDF417ScanningDecoder.errorCorrection = new ErrorCorrection();
        class PDF417Reader {
          decode(image, hints = null) {
            let result = PDF417Reader.decode(image, hints, false);
            if (result == null || result.length === 0 || result[0] == null) {
              throw NotFoundException.getNotFoundInstance();
            }
            return result[0];
          }
          decodeMultiple(image, hints = null) {
            try {
              return PDF417Reader.decode(image, hints, true);
            } catch (ignored) {
              if (ignored instanceof FormatException || ignored instanceof ChecksumException) {
                throw NotFoundException.getNotFoundInstance();
              }
              throw ignored;
            }
          }
          static decode(image, hints, multiple) {
            const results = new Array();
            const detectorResult = Detector$3.detectMultiple(image, hints, multiple);
            for (const points of detectorResult.getPoints()) {
              const decoderResult = PDF417ScanningDecoder.decode(detectorResult.getBits(), points[4], points[5], points[6], points[7], PDF417Reader.getMinCodewordWidth(points), PDF417Reader.getMaxCodewordWidth(points));
              const result = new Result(decoderResult.getText(), decoderResult.getRawBytes(), void 0, points, BarcodeFormat$1.PDF_417);
              result.putMetadata(ResultMetadataType$1.ERROR_CORRECTION_LEVEL, decoderResult.getECLevel());
              const pdf417ResultMetadata = decoderResult.getOther();
              if (pdf417ResultMetadata != null) {
                result.putMetadata(ResultMetadataType$1.PDF417_EXTRA_METADATA, pdf417ResultMetadata);
              }
              results.push(result);
            }
            return results.map((x) => x);
          }
          static getMaxWidth(p1, p2) {
            if (p1 == null || p2 == null) {
              return 0;
            }
            return Math.trunc(Math.abs(p1.getX() - p2.getX()));
          }
          static getMinWidth(p1, p2) {
            if (p1 == null || p2 == null) {
              return Integer.MAX_VALUE;
            }
            return Math.trunc(Math.abs(p1.getX() - p2.getX()));
          }
          static getMaxCodewordWidth(p) {
            return Math.floor(Math.max(Math.max(PDF417Reader.getMaxWidth(p[0], p[4]), PDF417Reader.getMaxWidth(p[6], p[2]) * PDF417Common.MODULES_IN_CODEWORD / PDF417Common.MODULES_IN_STOP_PATTERN), Math.max(PDF417Reader.getMaxWidth(p[1], p[5]), PDF417Reader.getMaxWidth(p[7], p[3]) * PDF417Common.MODULES_IN_CODEWORD / PDF417Common.MODULES_IN_STOP_PATTERN)));
          }
          static getMinCodewordWidth(p) {
            return Math.floor(Math.min(Math.min(PDF417Reader.getMinWidth(p[0], p[4]), PDF417Reader.getMinWidth(p[6], p[2]) * PDF417Common.MODULES_IN_CODEWORD / PDF417Common.MODULES_IN_STOP_PATTERN), Math.min(PDF417Reader.getMinWidth(p[1], p[5]), PDF417Reader.getMinWidth(p[7], p[3]) * PDF417Common.MODULES_IN_CODEWORD / PDF417Common.MODULES_IN_STOP_PATTERN)));
          }
          reset() {
          }
        }
        class ReaderException extends Exception {
        }
        ReaderException.kind = "ReaderException";
        class MultiFormatReader {
          constructor(verbose, hints) {
            this.verbose = verbose === true;
            if (hints) {
              this.setHints(hints);
            }
          }
          decode(image, hints) {
            if (hints) {
              this.setHints(hints);
            }
            return this.decodeInternal(image);
          }
          decodeWithState(image) {
            if (this.readers === null || this.readers === void 0) {
              this.setHints(null);
            }
            return this.decodeInternal(image);
          }
          setHints(hints) {
            this.hints = hints;
            const tryHarder = !isNullOrUndefined2(hints) && hints.get(DecodeHintType$1.TRY_HARDER) === true;
            const formats = isNullOrUndefined2(hints) ? null : hints.get(DecodeHintType$1.POSSIBLE_FORMATS);
            const readers = new Array();
            if (!isNullOrUndefined2(formats)) {
              const addOneDReader = formats.some((f) => {
                return f === BarcodeFormat$1.UPC_A || f === BarcodeFormat$1.UPC_E || f === BarcodeFormat$1.EAN_13 || f === BarcodeFormat$1.EAN_8 || f === BarcodeFormat$1.CODABAR || f === BarcodeFormat$1.CODE_39 || f === BarcodeFormat$1.CODE_93 || f === BarcodeFormat$1.CODE_128 || f === BarcodeFormat$1.ITF || f === BarcodeFormat$1.RSS_14 || f === BarcodeFormat$1.RSS_EXPANDED;
              });
              if (addOneDReader && !tryHarder) {
                readers.push(new MultiFormatOneDReader(hints, this.verbose));
              }
              if (formats.includes(BarcodeFormat$1.QR_CODE)) {
                readers.push(new QRCodeReader());
              }
              if (formats.includes(BarcodeFormat$1.DATA_MATRIX)) {
                readers.push(new DataMatrixReader());
              }
              if (formats.includes(BarcodeFormat$1.AZTEC)) {
                readers.push(new AztecReader());
              }
              if (formats.includes(BarcodeFormat$1.PDF_417)) {
                readers.push(new PDF417Reader());
              }
              if (addOneDReader && tryHarder) {
                readers.push(new MultiFormatOneDReader(hints, this.verbose));
              }
            }
            if (readers.length === 0) {
              if (!tryHarder) {
                readers.push(new MultiFormatOneDReader(hints, this.verbose));
              }
              readers.push(new QRCodeReader());
              readers.push(new DataMatrixReader());
              readers.push(new AztecReader());
              readers.push(new PDF417Reader());
              if (tryHarder) {
                readers.push(new MultiFormatOneDReader(hints, this.verbose));
              }
            }
            this.readers = readers;
          }
          reset() {
            if (this.readers !== null) {
              for (const reader of this.readers) {
                reader.reset();
              }
            }
          }
          decodeInternal(image) {
            if (this.readers === null) {
              throw new ReaderException("No readers where selected, nothing can be read.");
            }
            for (const reader of this.readers) {
              try {
                return reader.decode(image, this.hints);
              } catch (ex) {
                if (ex instanceof ReaderException) {
                  continue;
                }
              }
            }
            throw new NotFoundException("No MultiFormat Readers were able to detect the code.");
          }
        }
        class BrowserMultiFormatReader extends BrowserCodeReader {
          constructor(hints = null, timeBetweenScansMillis = 500) {
            const reader = new MultiFormatReader();
            reader.setHints(hints);
            super(reader, timeBetweenScansMillis);
          }
          decodeBitmap(binaryBitmap) {
            return this.reader.decodeWithState(binaryBitmap);
          }
        }
        class BrowserPDF417Reader extends BrowserCodeReader {
          constructor(timeBetweenScansMillis = 500) {
            super(new PDF417Reader(), timeBetweenScansMillis);
          }
        }
        class BrowserQRCodeReader extends BrowserCodeReader {
          constructor(timeBetweenScansMillis = 500) {
            super(new QRCodeReader(), timeBetweenScansMillis);
          }
        }
        var EncodeHintType;
        (function(EncodeHintType2) {
          EncodeHintType2[EncodeHintType2["ERROR_CORRECTION"] = 0] = "ERROR_CORRECTION";
          EncodeHintType2[EncodeHintType2["CHARACTER_SET"] = 1] = "CHARACTER_SET";
          EncodeHintType2[EncodeHintType2["DATA_MATRIX_SHAPE"] = 2] = "DATA_MATRIX_SHAPE";
          EncodeHintType2[EncodeHintType2["MIN_SIZE"] = 3] = "MIN_SIZE";
          EncodeHintType2[EncodeHintType2["MAX_SIZE"] = 4] = "MAX_SIZE";
          EncodeHintType2[EncodeHintType2["MARGIN"] = 5] = "MARGIN";
          EncodeHintType2[EncodeHintType2["PDF417_COMPACT"] = 6] = "PDF417_COMPACT";
          EncodeHintType2[EncodeHintType2["PDF417_COMPACTION"] = 7] = "PDF417_COMPACTION";
          EncodeHintType2[EncodeHintType2["PDF417_DIMENSIONS"] = 8] = "PDF417_DIMENSIONS";
          EncodeHintType2[EncodeHintType2["AZTEC_LAYERS"] = 9] = "AZTEC_LAYERS";
          EncodeHintType2[EncodeHintType2["QR_VERSION"] = 10] = "QR_VERSION";
        })(EncodeHintType || (EncodeHintType = {}));
        var EncodeHintType$1 = EncodeHintType;
        class ReedSolomonEncoder {
          constructor(field) {
            this.field = field;
            this.cachedGenerators = [];
            this.cachedGenerators.push(new GenericGFPoly(field, Int32Array.from([1])));
          }
          buildGenerator(degree) {
            const cachedGenerators = this.cachedGenerators;
            if (degree >= cachedGenerators.length) {
              let lastGenerator = cachedGenerators[cachedGenerators.length - 1];
              const field = this.field;
              for (let d = cachedGenerators.length; d <= degree; d++) {
                const nextGenerator = lastGenerator.multiply(new GenericGFPoly(field, Int32Array.from([1, field.exp(d - 1 + field.getGeneratorBase())])));
                cachedGenerators.push(nextGenerator);
                lastGenerator = nextGenerator;
              }
            }
            return cachedGenerators[degree];
          }
          encode(toEncode, ecBytes) {
            if (ecBytes === 0) {
              throw new IllegalArgumentException("No error correction bytes");
            }
            const dataBytes = toEncode.length - ecBytes;
            if (dataBytes <= 0) {
              throw new IllegalArgumentException("No data bytes provided");
            }
            const generator = this.buildGenerator(ecBytes);
            const infoCoefficients = new Int32Array(dataBytes);
            System.arraycopy(toEncode, 0, infoCoefficients, 0, dataBytes);
            let info = new GenericGFPoly(this.field, infoCoefficients);
            info = info.multiplyByMonomial(ecBytes, 1);
            const remainder = info.divide(generator)[1];
            const coefficients = remainder.getCoefficients();
            const numZeroCoefficients = ecBytes - coefficients.length;
            for (let i = 0; i < numZeroCoefficients; i++) {
              toEncode[dataBytes + i] = 0;
            }
            System.arraycopy(coefficients, 0, toEncode, dataBytes + numZeroCoefficients, coefficients.length);
          }
        }
        class MaskUtil {
          constructor() {
          }
          static applyMaskPenaltyRule1(matrix) {
            return MaskUtil.applyMaskPenaltyRule1Internal(matrix, true) + MaskUtil.applyMaskPenaltyRule1Internal(matrix, false);
          }
          static applyMaskPenaltyRule2(matrix) {
            let penalty = 0;
            const array = matrix.getArray();
            const width = matrix.getWidth();
            const height = matrix.getHeight();
            for (let y = 0; y < height - 1; y++) {
              const arrayY = array[y];
              for (let x = 0; x < width - 1; x++) {
                const value = arrayY[x];
                if (value === arrayY[x + 1] && value === array[y + 1][x] && value === array[y + 1][x + 1]) {
                  penalty++;
                }
              }
            }
            return MaskUtil.N2 * penalty;
          }
          static applyMaskPenaltyRule3(matrix) {
            let numPenalties = 0;
            const array = matrix.getArray();
            const width = matrix.getWidth();
            const height = matrix.getHeight();
            for (let y = 0; y < height; y++) {
              for (let x = 0; x < width; x++) {
                const arrayY = array[y];
                if (x + 6 < width && arrayY[x] === 1 && arrayY[x + 1] === 0 && arrayY[x + 2] === 1 && arrayY[x + 3] === 1 && arrayY[x + 4] === 1 && arrayY[x + 5] === 0 && arrayY[x + 6] === 1 && (MaskUtil.isWhiteHorizontal(arrayY, x - 4, x) || MaskUtil.isWhiteHorizontal(arrayY, x + 7, x + 11))) {
                  numPenalties++;
                }
                if (y + 6 < height && array[y][x] === 1 && array[y + 1][x] === 0 && array[y + 2][x] === 1 && array[y + 3][x] === 1 && array[y + 4][x] === 1 && array[y + 5][x] === 0 && array[y + 6][x] === 1 && (MaskUtil.isWhiteVertical(array, x, y - 4, y) || MaskUtil.isWhiteVertical(array, x, y + 7, y + 11))) {
                  numPenalties++;
                }
              }
            }
            return numPenalties * MaskUtil.N3;
          }
          static isWhiteHorizontal(rowArray, from, to) {
            from = Math.max(from, 0);
            to = Math.min(to, rowArray.length);
            for (let i = from; i < to; i++) {
              if (rowArray[i] === 1) {
                return false;
              }
            }
            return true;
          }
          static isWhiteVertical(array, col, from, to) {
            from = Math.max(from, 0);
            to = Math.min(to, array.length);
            for (let i = from; i < to; i++) {
              if (array[i][col] === 1) {
                return false;
              }
            }
            return true;
          }
          static applyMaskPenaltyRule4(matrix) {
            let numDarkCells = 0;
            const array = matrix.getArray();
            const width = matrix.getWidth();
            const height = matrix.getHeight();
            for (let y = 0; y < height; y++) {
              const arrayY = array[y];
              for (let x = 0; x < width; x++) {
                if (arrayY[x] === 1) {
                  numDarkCells++;
                }
              }
            }
            const numTotalCells = matrix.getHeight() * matrix.getWidth();
            const fivePercentVariances = Math.floor(Math.abs(numDarkCells * 2 - numTotalCells) * 10 / numTotalCells);
            return fivePercentVariances * MaskUtil.N4;
          }
          static getDataMaskBit(maskPattern, x, y) {
            let intermediate;
            let temp;
            switch (maskPattern) {
              case 0:
                intermediate = y + x & 1;
                break;
              case 1:
                intermediate = y & 1;
                break;
              case 2:
                intermediate = x % 3;
                break;
              case 3:
                intermediate = (y + x) % 3;
                break;
              case 4:
                intermediate = Math.floor(y / 2) + Math.floor(x / 3) & 1;
                break;
              case 5:
                temp = y * x;
                intermediate = (temp & 1) + temp % 3;
                break;
              case 6:
                temp = y * x;
                intermediate = (temp & 1) + temp % 3 & 1;
                break;
              case 7:
                temp = y * x;
                intermediate = temp % 3 + (y + x & 1) & 1;
                break;
              default:
                throw new IllegalArgumentException("Invalid mask pattern: " + maskPattern);
            }
            return intermediate === 0;
          }
          static applyMaskPenaltyRule1Internal(matrix, isHorizontal) {
            let penalty = 0;
            const iLimit = isHorizontal ? matrix.getHeight() : matrix.getWidth();
            const jLimit = isHorizontal ? matrix.getWidth() : matrix.getHeight();
            const array = matrix.getArray();
            for (let i = 0; i < iLimit; i++) {
              let numSameBitCells = 0;
              let prevBit = -1;
              for (let j = 0; j < jLimit; j++) {
                const bit = isHorizontal ? array[i][j] : array[j][i];
                if (bit === prevBit) {
                  numSameBitCells++;
                } else {
                  if (numSameBitCells >= 5) {
                    penalty += MaskUtil.N1 + (numSameBitCells - 5);
                  }
                  numSameBitCells = 1;
                  prevBit = bit;
                }
              }
              if (numSameBitCells >= 5) {
                penalty += MaskUtil.N1 + (numSameBitCells - 5);
              }
            }
            return penalty;
          }
        }
        MaskUtil.N1 = 3;
        MaskUtil.N2 = 3;
        MaskUtil.N3 = 40;
        MaskUtil.N4 = 10;
        class ByteMatrix {
          constructor(width, height) {
            this.width = width;
            this.height = height;
            const bytes = new Array(height);
            for (let i = 0; i !== height; i++) {
              bytes[i] = new Uint8Array(width);
            }
            this.bytes = bytes;
          }
          getHeight() {
            return this.height;
          }
          getWidth() {
            return this.width;
          }
          get(x, y) {
            return this.bytes[y][x];
          }
          getArray() {
            return this.bytes;
          }
          setNumber(x, y, value) {
            this.bytes[y][x] = value;
          }
          setBoolean(x, y, value) {
            this.bytes[y][x] = value ? 1 : 0;
          }
          clear(value) {
            for (const aByte of this.bytes) {
              Arrays.fill(aByte, value);
            }
          }
          equals(o) {
            if (!(o instanceof ByteMatrix)) {
              return false;
            }
            const other = o;
            if (this.width !== other.width) {
              return false;
            }
            if (this.height !== other.height) {
              return false;
            }
            for (let y = 0, height = this.height; y < height; ++y) {
              const bytesY = this.bytes[y];
              const otherBytesY = other.bytes[y];
              for (let x = 0, width = this.width; x < width; ++x) {
                if (bytesY[x] !== otherBytesY[x]) {
                  return false;
                }
              }
            }
            return true;
          }
          toString() {
            const result = new StringBuilder();
            for (let y = 0, height = this.height; y < height; ++y) {
              const bytesY = this.bytes[y];
              for (let x = 0, width = this.width; x < width; ++x) {
                switch (bytesY[x]) {
                  case 0:
                    result.append(" 0");
                    break;
                  case 1:
                    result.append(" 1");
                    break;
                  default:
                    result.append("  ");
                    break;
                }
              }
              result.append("\n");
            }
            return result.toString();
          }
        }
        class QRCode {
          constructor() {
            this.maskPattern = -1;
          }
          getMode() {
            return this.mode;
          }
          getECLevel() {
            return this.ecLevel;
          }
          getVersion() {
            return this.version;
          }
          getMaskPattern() {
            return this.maskPattern;
          }
          getMatrix() {
            return this.matrix;
          }
          toString() {
            const result = new StringBuilder();
            result.append("<<\n");
            result.append(" mode: ");
            result.append(this.mode ? this.mode.toString() : "null");
            result.append("\n ecLevel: ");
            result.append(this.ecLevel ? this.ecLevel.toString() : "null");
            result.append("\n version: ");
            result.append(this.version ? this.version.toString() : "null");
            result.append("\n maskPattern: ");
            result.append(this.maskPattern.toString());
            if (this.matrix) {
              result.append("\n matrix:\n");
              result.append(this.matrix.toString());
            } else {
              result.append("\n matrix: null\n");
            }
            result.append(">>\n");
            return result.toString();
          }
          setMode(value) {
            this.mode = value;
          }
          setECLevel(value) {
            this.ecLevel = value;
          }
          setVersion(version) {
            this.version = version;
          }
          setMaskPattern(value) {
            this.maskPattern = value;
          }
          setMatrix(value) {
            this.matrix = value;
          }
          static isValidMaskPattern(maskPattern) {
            return maskPattern >= 0 && maskPattern < QRCode.NUM_MASK_PATTERNS;
          }
        }
        QRCode.NUM_MASK_PATTERNS = 8;
        class WriterException extends Exception {
        }
        WriterException.kind = "WriterException";
        class MatrixUtil {
          constructor() {
          }
          static clearMatrix(matrix) {
            matrix.clear(255);
          }
          static buildMatrix(dataBits, ecLevel, version, maskPattern, matrix) {
            MatrixUtil.clearMatrix(matrix);
            MatrixUtil.embedBasicPatterns(version, matrix);
            MatrixUtil.embedTypeInfo(ecLevel, maskPattern, matrix);
            MatrixUtil.maybeEmbedVersionInfo(version, matrix);
            MatrixUtil.embedDataBits(dataBits, maskPattern, matrix);
          }
          static embedBasicPatterns(version, matrix) {
            MatrixUtil.embedPositionDetectionPatternsAndSeparators(matrix);
            MatrixUtil.embedDarkDotAtLeftBottomCorner(matrix);
            MatrixUtil.maybeEmbedPositionAdjustmentPatterns(version, matrix);
            MatrixUtil.embedTimingPatterns(matrix);
          }
          static embedTypeInfo(ecLevel, maskPattern, matrix) {
            const typeInfoBits = new BitArray();
            MatrixUtil.makeTypeInfoBits(ecLevel, maskPattern, typeInfoBits);
            for (let i = 0, size2 = typeInfoBits.getSize(); i < size2; ++i) {
              const bit = typeInfoBits.get(typeInfoBits.getSize() - 1 - i);
              const coordinates = MatrixUtil.TYPE_INFO_COORDINATES[i];
              const x1 = coordinates[0];
              const y1 = coordinates[1];
              matrix.setBoolean(x1, y1, bit);
              if (i < 8) {
                const x2 = matrix.getWidth() - i - 1;
                const y2 = 8;
                matrix.setBoolean(x2, y2, bit);
              } else {
                const x2 = 8;
                const y2 = matrix.getHeight() - 7 + (i - 8);
                matrix.setBoolean(x2, y2, bit);
              }
            }
          }
          static maybeEmbedVersionInfo(version, matrix) {
            if (version.getVersionNumber() < 7) {
              return;
            }
            const versionInfoBits = new BitArray();
            MatrixUtil.makeVersionInfoBits(version, versionInfoBits);
            let bitIndex = 6 * 3 - 1;
            for (let i = 0; i < 6; ++i) {
              for (let j = 0; j < 3; ++j) {
                const bit = versionInfoBits.get(bitIndex);
                bitIndex--;
                matrix.setBoolean(i, matrix.getHeight() - 11 + j, bit);
                matrix.setBoolean(matrix.getHeight() - 11 + j, i, bit);
              }
            }
          }
          static embedDataBits(dataBits, maskPattern, matrix) {
            let bitIndex = 0;
            let direction = -1;
            let x = matrix.getWidth() - 1;
            let y = matrix.getHeight() - 1;
            while (x > 0) {
              if (x === 6) {
                x -= 1;
              }
              while (y >= 0 && y < matrix.getHeight()) {
                for (let i = 0; i < 2; ++i) {
                  const xx = x - i;
                  if (!MatrixUtil.isEmpty(matrix.get(xx, y))) {
                    continue;
                  }
                  let bit;
                  if (bitIndex < dataBits.getSize()) {
                    bit = dataBits.get(bitIndex);
                    ++bitIndex;
                  } else {
                    bit = false;
                  }
                  if (maskPattern !== 255 && MaskUtil.getDataMaskBit(maskPattern, xx, y)) {
                    bit = !bit;
                  }
                  matrix.setBoolean(xx, y, bit);
                }
                y += direction;
              }
              direction = -direction;
              y += direction;
              x -= 2;
            }
            if (bitIndex !== dataBits.getSize()) {
              throw new WriterException("Not all bits consumed: " + bitIndex + "/" + dataBits.getSize());
            }
          }
          static findMSBSet(value) {
            return 32 - Integer.numberOfLeadingZeros(value);
          }
          static calculateBCHCode(value, poly) {
            if (poly === 0) {
              throw new IllegalArgumentException("0 polynomial");
            }
            const msbSetInPoly = MatrixUtil.findMSBSet(poly);
            value <<= msbSetInPoly - 1;
            while (MatrixUtil.findMSBSet(value) >= msbSetInPoly) {
              value ^= poly << MatrixUtil.findMSBSet(value) - msbSetInPoly;
            }
            return value;
          }
          static makeTypeInfoBits(ecLevel, maskPattern, bits) {
            if (!QRCode.isValidMaskPattern(maskPattern)) {
              throw new WriterException("Invalid mask pattern");
            }
            const typeInfo = ecLevel.getBits() << 3 | maskPattern;
            bits.appendBits(typeInfo, 5);
            const bchCode = MatrixUtil.calculateBCHCode(typeInfo, MatrixUtil.TYPE_INFO_POLY);
            bits.appendBits(bchCode, 10);
            const maskBits = new BitArray();
            maskBits.appendBits(MatrixUtil.TYPE_INFO_MASK_PATTERN, 15);
            bits.xor(maskBits);
            if (bits.getSize() !== 15) {
              throw new WriterException("should not happen but we got: " + bits.getSize());
            }
          }
          static makeVersionInfoBits(version, bits) {
            bits.appendBits(version.getVersionNumber(), 6);
            const bchCode = MatrixUtil.calculateBCHCode(version.getVersionNumber(), MatrixUtil.VERSION_INFO_POLY);
            bits.appendBits(bchCode, 12);
            if (bits.getSize() !== 18) {
              throw new WriterException("should not happen but we got: " + bits.getSize());
            }
          }
          static isEmpty(value) {
            return value === 255;
          }
          static embedTimingPatterns(matrix) {
            for (let i = 8; i < matrix.getWidth() - 8; ++i) {
              const bit = (i + 1) % 2;
              if (MatrixUtil.isEmpty(matrix.get(i, 6))) {
                matrix.setNumber(i, 6, bit);
              }
              if (MatrixUtil.isEmpty(matrix.get(6, i))) {
                matrix.setNumber(6, i, bit);
              }
            }
          }
          static embedDarkDotAtLeftBottomCorner(matrix) {
            if (matrix.get(8, matrix.getHeight() - 8) === 0) {
              throw new WriterException();
            }
            matrix.setNumber(8, matrix.getHeight() - 8, 1);
          }
          static embedHorizontalSeparationPattern(xStart, yStart, matrix) {
            for (let x = 0; x < 8; ++x) {
              if (!MatrixUtil.isEmpty(matrix.get(xStart + x, yStart))) {
                throw new WriterException();
              }
              matrix.setNumber(xStart + x, yStart, 0);
            }
          }
          static embedVerticalSeparationPattern(xStart, yStart, matrix) {
            for (let y = 0; y < 7; ++y) {
              if (!MatrixUtil.isEmpty(matrix.get(xStart, yStart + y))) {
                throw new WriterException();
              }
              matrix.setNumber(xStart, yStart + y, 0);
            }
          }
          static embedPositionAdjustmentPattern(xStart, yStart, matrix) {
            for (let y = 0; y < 5; ++y) {
              const patternY = MatrixUtil.POSITION_ADJUSTMENT_PATTERN[y];
              for (let x = 0; x < 5; ++x) {
                matrix.setNumber(xStart + x, yStart + y, patternY[x]);
              }
            }
          }
          static embedPositionDetectionPattern(xStart, yStart, matrix) {
            for (let y = 0; y < 7; ++y) {
              const patternY = MatrixUtil.POSITION_DETECTION_PATTERN[y];
              for (let x = 0; x < 7; ++x) {
                matrix.setNumber(xStart + x, yStart + y, patternY[x]);
              }
            }
          }
          static embedPositionDetectionPatternsAndSeparators(matrix) {
            const pdpWidth = MatrixUtil.POSITION_DETECTION_PATTERN[0].length;
            MatrixUtil.embedPositionDetectionPattern(0, 0, matrix);
            MatrixUtil.embedPositionDetectionPattern(matrix.getWidth() - pdpWidth, 0, matrix);
            MatrixUtil.embedPositionDetectionPattern(0, matrix.getWidth() - pdpWidth, matrix);
            const hspWidth = 8;
            MatrixUtil.embedHorizontalSeparationPattern(0, hspWidth - 1, matrix);
            MatrixUtil.embedHorizontalSeparationPattern(matrix.getWidth() - hspWidth, hspWidth - 1, matrix);
            MatrixUtil.embedHorizontalSeparationPattern(0, matrix.getWidth() - hspWidth, matrix);
            const vspSize = 7;
            MatrixUtil.embedVerticalSeparationPattern(vspSize, 0, matrix);
            MatrixUtil.embedVerticalSeparationPattern(matrix.getHeight() - vspSize - 1, 0, matrix);
            MatrixUtil.embedVerticalSeparationPattern(vspSize, matrix.getHeight() - vspSize, matrix);
          }
          static maybeEmbedPositionAdjustmentPatterns(version, matrix) {
            if (version.getVersionNumber() < 2) {
              return;
            }
            const index = version.getVersionNumber() - 1;
            const coordinates = MatrixUtil.POSITION_ADJUSTMENT_PATTERN_COORDINATE_TABLE[index];
            for (let i = 0, length = coordinates.length; i !== length; i++) {
              const y = coordinates[i];
              if (y >= 0) {
                for (let j = 0; j !== length; j++) {
                  const x = coordinates[j];
                  if (x >= 0 && MatrixUtil.isEmpty(matrix.get(x, y))) {
                    MatrixUtil.embedPositionAdjustmentPattern(x - 2, y - 2, matrix);
                  }
                }
              }
            }
          }
        }
        MatrixUtil.POSITION_DETECTION_PATTERN = Array.from([
          Int32Array.from([1, 1, 1, 1, 1, 1, 1]),
          Int32Array.from([1, 0, 0, 0, 0, 0, 1]),
          Int32Array.from([1, 0, 1, 1, 1, 0, 1]),
          Int32Array.from([1, 0, 1, 1, 1, 0, 1]),
          Int32Array.from([1, 0, 1, 1, 1, 0, 1]),
          Int32Array.from([1, 0, 0, 0, 0, 0, 1]),
          Int32Array.from([1, 1, 1, 1, 1, 1, 1])
        ]);
        MatrixUtil.POSITION_ADJUSTMENT_PATTERN = Array.from([
          Int32Array.from([1, 1, 1, 1, 1]),
          Int32Array.from([1, 0, 0, 0, 1]),
          Int32Array.from([1, 0, 1, 0, 1]),
          Int32Array.from([1, 0, 0, 0, 1]),
          Int32Array.from([1, 1, 1, 1, 1])
        ]);
        MatrixUtil.POSITION_ADJUSTMENT_PATTERN_COORDINATE_TABLE = Array.from([
          Int32Array.from([-1, -1, -1, -1, -1, -1, -1]),
          Int32Array.from([6, 18, -1, -1, -1, -1, -1]),
          Int32Array.from([6, 22, -1, -1, -1, -1, -1]),
          Int32Array.from([6, 26, -1, -1, -1, -1, -1]),
          Int32Array.from([6, 30, -1, -1, -1, -1, -1]),
          Int32Array.from([6, 34, -1, -1, -1, -1, -1]),
          Int32Array.from([6, 22, 38, -1, -1, -1, -1]),
          Int32Array.from([6, 24, 42, -1, -1, -1, -1]),
          Int32Array.from([6, 26, 46, -1, -1, -1, -1]),
          Int32Array.from([6, 28, 50, -1, -1, -1, -1]),
          Int32Array.from([6, 30, 54, -1, -1, -1, -1]),
          Int32Array.from([6, 32, 58, -1, -1, -1, -1]),
          Int32Array.from([6, 34, 62, -1, -1, -1, -1]),
          Int32Array.from([6, 26, 46, 66, -1, -1, -1]),
          Int32Array.from([6, 26, 48, 70, -1, -1, -1]),
          Int32Array.from([6, 26, 50, 74, -1, -1, -1]),
          Int32Array.from([6, 30, 54, 78, -1, -1, -1]),
          Int32Array.from([6, 30, 56, 82, -1, -1, -1]),
          Int32Array.from([6, 30, 58, 86, -1, -1, -1]),
          Int32Array.from([6, 34, 62, 90, -1, -1, -1]),
          Int32Array.from([6, 28, 50, 72, 94, -1, -1]),
          Int32Array.from([6, 26, 50, 74, 98, -1, -1]),
          Int32Array.from([6, 30, 54, 78, 102, -1, -1]),
          Int32Array.from([6, 28, 54, 80, 106, -1, -1]),
          Int32Array.from([6, 32, 58, 84, 110, -1, -1]),
          Int32Array.from([6, 30, 58, 86, 114, -1, -1]),
          Int32Array.from([6, 34, 62, 90, 118, -1, -1]),
          Int32Array.from([6, 26, 50, 74, 98, 122, -1]),
          Int32Array.from([6, 30, 54, 78, 102, 126, -1]),
          Int32Array.from([6, 26, 52, 78, 104, 130, -1]),
          Int32Array.from([6, 30, 56, 82, 108, 134, -1]),
          Int32Array.from([6, 34, 60, 86, 112, 138, -1]),
          Int32Array.from([6, 30, 58, 86, 114, 142, -1]),
          Int32Array.from([6, 34, 62, 90, 118, 146, -1]),
          Int32Array.from([6, 30, 54, 78, 102, 126, 150]),
          Int32Array.from([6, 24, 50, 76, 102, 128, 154]),
          Int32Array.from([6, 28, 54, 80, 106, 132, 158]),
          Int32Array.from([6, 32, 58, 84, 110, 136, 162]),
          Int32Array.from([6, 26, 54, 82, 110, 138, 166]),
          Int32Array.from([6, 30, 58, 86, 114, 142, 170])
        ]);
        MatrixUtil.TYPE_INFO_COORDINATES = Array.from([
          Int32Array.from([8, 0]),
          Int32Array.from([8, 1]),
          Int32Array.from([8, 2]),
          Int32Array.from([8, 3]),
          Int32Array.from([8, 4]),
          Int32Array.from([8, 5]),
          Int32Array.from([8, 7]),
          Int32Array.from([8, 8]),
          Int32Array.from([7, 8]),
          Int32Array.from([5, 8]),
          Int32Array.from([4, 8]),
          Int32Array.from([3, 8]),
          Int32Array.from([2, 8]),
          Int32Array.from([1, 8]),
          Int32Array.from([0, 8])
        ]);
        MatrixUtil.VERSION_INFO_POLY = 7973;
        MatrixUtil.TYPE_INFO_POLY = 1335;
        MatrixUtil.TYPE_INFO_MASK_PATTERN = 21522;
        class BlockPair {
          constructor(dataBytes, errorCorrectionBytes) {
            this.dataBytes = dataBytes;
            this.errorCorrectionBytes = errorCorrectionBytes;
          }
          getDataBytes() {
            return this.dataBytes;
          }
          getErrorCorrectionBytes() {
            return this.errorCorrectionBytes;
          }
        }
        class Encoder {
          constructor() {
          }
          static calculateMaskPenalty(matrix) {
            return MaskUtil.applyMaskPenaltyRule1(matrix) + MaskUtil.applyMaskPenaltyRule2(matrix) + MaskUtil.applyMaskPenaltyRule3(matrix) + MaskUtil.applyMaskPenaltyRule4(matrix);
          }
          static encode(content, ecLevel, hints = null) {
            let encoding = Encoder.DEFAULT_BYTE_MODE_ENCODING;
            const hasEncodingHint = hints !== null && hints.get(EncodeHintType$1.CHARACTER_SET) !== void 0;
            if (hasEncodingHint) {
              encoding = hints.get(EncodeHintType$1.CHARACTER_SET).toString();
            }
            const mode = this.chooseMode(content, encoding);
            const headerBits = new BitArray();
            if (mode === Mode$1.BYTE && (hasEncodingHint || Encoder.DEFAULT_BYTE_MODE_ENCODING !== encoding)) {
              const eci = CharacterSetECI.getCharacterSetECIByName(encoding);
              if (eci !== void 0) {
                this.appendECI(eci, headerBits);
              }
            }
            this.appendModeInfo(mode, headerBits);
            const dataBits = new BitArray();
            this.appendBytes(content, mode, dataBits, encoding);
            let version;
            if (hints !== null && hints.get(EncodeHintType$1.QR_VERSION) !== void 0) {
              const versionNumber = Number.parseInt(hints.get(EncodeHintType$1.QR_VERSION).toString(), 10);
              version = Version$1.getVersionForNumber(versionNumber);
              const bitsNeeded = this.calculateBitsNeeded(mode, headerBits, dataBits, version);
              if (!this.willFit(bitsNeeded, version, ecLevel)) {
                throw new WriterException("Data too big for requested version");
              }
            } else {
              version = this.recommendVersion(ecLevel, mode, headerBits, dataBits);
            }
            const headerAndDataBits = new BitArray();
            headerAndDataBits.appendBitArray(headerBits);
            const numLetters = mode === Mode$1.BYTE ? dataBits.getSizeInBytes() : content.length;
            this.appendLengthInfo(numLetters, version, mode, headerAndDataBits);
            headerAndDataBits.appendBitArray(dataBits);
            const ecBlocks = version.getECBlocksForLevel(ecLevel);
            const numDataBytes = version.getTotalCodewords() - ecBlocks.getTotalECCodewords();
            this.terminateBits(numDataBytes, headerAndDataBits);
            const finalBits = this.interleaveWithECBytes(headerAndDataBits, version.getTotalCodewords(), numDataBytes, ecBlocks.getNumBlocks());
            const qrCode = new QRCode();
            qrCode.setECLevel(ecLevel);
            qrCode.setMode(mode);
            qrCode.setVersion(version);
            const dimension = version.getDimensionForVersion();
            const matrix = new ByteMatrix(dimension, dimension);
            const maskPattern = this.chooseMaskPattern(finalBits, ecLevel, version, matrix);
            qrCode.setMaskPattern(maskPattern);
            MatrixUtil.buildMatrix(finalBits, ecLevel, version, maskPattern, matrix);
            qrCode.setMatrix(matrix);
            return qrCode;
          }
          static recommendVersion(ecLevel, mode, headerBits, dataBits) {
            const provisionalBitsNeeded = this.calculateBitsNeeded(mode, headerBits, dataBits, Version$1.getVersionForNumber(1));
            const provisionalVersion = this.chooseVersion(provisionalBitsNeeded, ecLevel);
            const bitsNeeded = this.calculateBitsNeeded(mode, headerBits, dataBits, provisionalVersion);
            return this.chooseVersion(bitsNeeded, ecLevel);
          }
          static calculateBitsNeeded(mode, headerBits, dataBits, version) {
            return headerBits.getSize() + mode.getCharacterCountBits(version) + dataBits.getSize();
          }
          static getAlphanumericCode(code) {
            if (code < Encoder.ALPHANUMERIC_TABLE.length) {
              return Encoder.ALPHANUMERIC_TABLE[code];
            }
            return -1;
          }
          static chooseMode(content, encoding = null) {
            if (CharacterSetECI.SJIS.getName() === encoding && this.isOnlyDoubleByteKanji(content)) {
              return Mode$1.KANJI;
            }
            let hasNumeric = false;
            let hasAlphanumeric = false;
            for (let i = 0, length = content.length; i < length; ++i) {
              const c = content.charAt(i);
              if (Encoder.isDigit(c)) {
                hasNumeric = true;
              } else if (this.getAlphanumericCode(c.charCodeAt(0)) !== -1) {
                hasAlphanumeric = true;
              } else {
                return Mode$1.BYTE;
              }
            }
            if (hasAlphanumeric) {
              return Mode$1.ALPHANUMERIC;
            }
            if (hasNumeric) {
              return Mode$1.NUMERIC;
            }
            return Mode$1.BYTE;
          }
          static isOnlyDoubleByteKanji(content) {
            let bytes;
            try {
              bytes = StringEncoding.encode(content, CharacterSetECI.SJIS);
            } catch (ignored) {
              return false;
            }
            const length = bytes.length;
            if (length % 2 !== 0) {
              return false;
            }
            for (let i = 0; i < length; i += 2) {
              const byte1 = bytes[i] & 255;
              if ((byte1 < 129 || byte1 > 159) && (byte1 < 224 || byte1 > 235)) {
                return false;
              }
            }
            return true;
          }
          static chooseMaskPattern(bits, ecLevel, version, matrix) {
            let minPenalty = Number.MAX_SAFE_INTEGER;
            let bestMaskPattern = -1;
            for (let maskPattern = 0; maskPattern < QRCode.NUM_MASK_PATTERNS; maskPattern++) {
              MatrixUtil.buildMatrix(bits, ecLevel, version, maskPattern, matrix);
              let penalty = this.calculateMaskPenalty(matrix);
              if (penalty < minPenalty) {
                minPenalty = penalty;
                bestMaskPattern = maskPattern;
              }
            }
            return bestMaskPattern;
          }
          static chooseVersion(numInputBits, ecLevel) {
            for (let versionNum = 1; versionNum <= 40; versionNum++) {
              const version = Version$1.getVersionForNumber(versionNum);
              if (Encoder.willFit(numInputBits, version, ecLevel)) {
                return version;
              }
            }
            throw new WriterException("Data too big");
          }
          static willFit(numInputBits, version, ecLevel) {
            const numBytes = version.getTotalCodewords();
            const ecBlocks = version.getECBlocksForLevel(ecLevel);
            const numEcBytes = ecBlocks.getTotalECCodewords();
            const numDataBytes = numBytes - numEcBytes;
            const totalInputBytes = (numInputBits + 7) / 8;
            return numDataBytes >= totalInputBytes;
          }
          static terminateBits(numDataBytes, bits) {
            const capacity = numDataBytes * 8;
            if (bits.getSize() > capacity) {
              throw new WriterException("data bits cannot fit in the QR Code" + bits.getSize() + " > " + capacity);
            }
            for (let i = 0; i < 4 && bits.getSize() < capacity; ++i) {
              bits.appendBit(false);
            }
            const numBitsInLastByte = bits.getSize() & 7;
            if (numBitsInLastByte > 0) {
              for (let i = numBitsInLastByte; i < 8; i++) {
                bits.appendBit(false);
              }
            }
            const numPaddingBytes = numDataBytes - bits.getSizeInBytes();
            for (let i = 0; i < numPaddingBytes; ++i) {
              bits.appendBits((i & 1) === 0 ? 236 : 17, 8);
            }
            if (bits.getSize() !== capacity) {
              throw new WriterException("Bits size does not equal capacity");
            }
          }
          static getNumDataBytesAndNumECBytesForBlockID(numTotalBytes, numDataBytes, numRSBlocks, blockID, numDataBytesInBlock, numECBytesInBlock) {
            if (blockID >= numRSBlocks) {
              throw new WriterException("Block ID too large");
            }
            const numRsBlocksInGroup2 = numTotalBytes % numRSBlocks;
            const numRsBlocksInGroup1 = numRSBlocks - numRsBlocksInGroup2;
            const numTotalBytesInGroup1 = Math.floor(numTotalBytes / numRSBlocks);
            const numTotalBytesInGroup2 = numTotalBytesInGroup1 + 1;
            const numDataBytesInGroup1 = Math.floor(numDataBytes / numRSBlocks);
            const numDataBytesInGroup2 = numDataBytesInGroup1 + 1;
            const numEcBytesInGroup1 = numTotalBytesInGroup1 - numDataBytesInGroup1;
            const numEcBytesInGroup2 = numTotalBytesInGroup2 - numDataBytesInGroup2;
            if (numEcBytesInGroup1 !== numEcBytesInGroup2) {
              throw new WriterException("EC bytes mismatch");
            }
            if (numRSBlocks !== numRsBlocksInGroup1 + numRsBlocksInGroup2) {
              throw new WriterException("RS blocks mismatch");
            }
            if (numTotalBytes !== (numDataBytesInGroup1 + numEcBytesInGroup1) * numRsBlocksInGroup1 + (numDataBytesInGroup2 + numEcBytesInGroup2) * numRsBlocksInGroup2) {
              throw new WriterException("Total bytes mismatch");
            }
            if (blockID < numRsBlocksInGroup1) {
              numDataBytesInBlock[0] = numDataBytesInGroup1;
              numECBytesInBlock[0] = numEcBytesInGroup1;
            } else {
              numDataBytesInBlock[0] = numDataBytesInGroup2;
              numECBytesInBlock[0] = numEcBytesInGroup2;
            }
          }
          static interleaveWithECBytes(bits, numTotalBytes, numDataBytes, numRSBlocks) {
            if (bits.getSizeInBytes() !== numDataBytes) {
              throw new WriterException("Number of bits and data bytes does not match");
            }
            let dataBytesOffset = 0;
            let maxNumDataBytes = 0;
            let maxNumEcBytes = 0;
            const blocks = new Array();
            for (let i = 0; i < numRSBlocks; ++i) {
              const numDataBytesInBlock = new Int32Array(1);
              const numEcBytesInBlock = new Int32Array(1);
              Encoder.getNumDataBytesAndNumECBytesForBlockID(numTotalBytes, numDataBytes, numRSBlocks, i, numDataBytesInBlock, numEcBytesInBlock);
              const size2 = numDataBytesInBlock[0];
              const dataBytes = new Uint8Array(size2);
              bits.toBytes(8 * dataBytesOffset, dataBytes, 0, size2);
              const ecBytes = Encoder.generateECBytes(dataBytes, numEcBytesInBlock[0]);
              blocks.push(new BlockPair(dataBytes, ecBytes));
              maxNumDataBytes = Math.max(maxNumDataBytes, size2);
              maxNumEcBytes = Math.max(maxNumEcBytes, ecBytes.length);
              dataBytesOffset += numDataBytesInBlock[0];
            }
            if (numDataBytes !== dataBytesOffset) {
              throw new WriterException("Data bytes does not match offset");
            }
            const result = new BitArray();
            for (let i = 0; i < maxNumDataBytes; ++i) {
              for (const block of blocks) {
                const dataBytes = block.getDataBytes();
                if (i < dataBytes.length) {
                  result.appendBits(dataBytes[i], 8);
                }
              }
            }
            for (let i = 0; i < maxNumEcBytes; ++i) {
              for (const block of blocks) {
                const ecBytes = block.getErrorCorrectionBytes();
                if (i < ecBytes.length) {
                  result.appendBits(ecBytes[i], 8);
                }
              }
            }
            if (numTotalBytes !== result.getSizeInBytes()) {
              throw new WriterException("Interleaving error: " + numTotalBytes + " and " + result.getSizeInBytes() + " differ.");
            }
            return result;
          }
          static generateECBytes(dataBytes, numEcBytesInBlock) {
            const numDataBytes = dataBytes.length;
            const toEncode = new Int32Array(numDataBytes + numEcBytesInBlock);
            for (let i = 0; i < numDataBytes; i++) {
              toEncode[i] = dataBytes[i] & 255;
            }
            new ReedSolomonEncoder(GenericGF.QR_CODE_FIELD_256).encode(toEncode, numEcBytesInBlock);
            const ecBytes = new Uint8Array(numEcBytesInBlock);
            for (let i = 0; i < numEcBytesInBlock; i++) {
              ecBytes[i] = toEncode[numDataBytes + i];
            }
            return ecBytes;
          }
          static appendModeInfo(mode, bits) {
            bits.appendBits(mode.getBits(), 4);
          }
          static appendLengthInfo(numLetters, version, mode, bits) {
            const numBits = mode.getCharacterCountBits(version);
            if (numLetters >= 1 << numBits) {
              throw new WriterException(numLetters + " is bigger than " + ((1 << numBits) - 1));
            }
            bits.appendBits(numLetters, numBits);
          }
          static appendBytes(content, mode, bits, encoding) {
            switch (mode) {
              case Mode$1.NUMERIC:
                Encoder.appendNumericBytes(content, bits);
                break;
              case Mode$1.ALPHANUMERIC:
                Encoder.appendAlphanumericBytes(content, bits);
                break;
              case Mode$1.BYTE:
                Encoder.append8BitBytes(content, bits, encoding);
                break;
              case Mode$1.KANJI:
                Encoder.appendKanjiBytes(content, bits);
                break;
              default:
                throw new WriterException("Invalid mode: " + mode);
            }
          }
          static getDigit(singleCharacter) {
            return singleCharacter.charCodeAt(0) - 48;
          }
          static isDigit(singleCharacter) {
            const cn = Encoder.getDigit(singleCharacter);
            return cn >= 0 && cn <= 9;
          }
          static appendNumericBytes(content, bits) {
            const length = content.length;
            let i = 0;
            while (i < length) {
              const num1 = Encoder.getDigit(content.charAt(i));
              if (i + 2 < length) {
                const num2 = Encoder.getDigit(content.charAt(i + 1));
                const num3 = Encoder.getDigit(content.charAt(i + 2));
                bits.appendBits(num1 * 100 + num2 * 10 + num3, 10);
                i += 3;
              } else if (i + 1 < length) {
                const num2 = Encoder.getDigit(content.charAt(i + 1));
                bits.appendBits(num1 * 10 + num2, 7);
                i += 2;
              } else {
                bits.appendBits(num1, 4);
                i++;
              }
            }
          }
          static appendAlphanumericBytes(content, bits) {
            const length = content.length;
            let i = 0;
            while (i < length) {
              const code1 = Encoder.getAlphanumericCode(content.charCodeAt(i));
              if (code1 === -1) {
                throw new WriterException();
              }
              if (i + 1 < length) {
                const code2 = Encoder.getAlphanumericCode(content.charCodeAt(i + 1));
                if (code2 === -1) {
                  throw new WriterException();
                }
                bits.appendBits(code1 * 45 + code2, 11);
                i += 2;
              } else {
                bits.appendBits(code1, 6);
                i++;
              }
            }
          }
          static append8BitBytes(content, bits, encoding) {
            let bytes;
            try {
              bytes = StringEncoding.encode(content, encoding);
            } catch (uee) {
              throw new WriterException(uee);
            }
            for (let i = 0, length = bytes.length; i !== length; i++) {
              const b = bytes[i];
              bits.appendBits(b, 8);
            }
          }
          static appendKanjiBytes(content, bits) {
            let bytes;
            try {
              bytes = StringEncoding.encode(content, CharacterSetECI.SJIS);
            } catch (uee) {
              throw new WriterException(uee);
            }
            const length = bytes.length;
            for (let i = 0; i < length; i += 2) {
              const byte1 = bytes[i] & 255;
              const byte2 = bytes[i + 1] & 255;
              const code = byte1 << 8 & 4294967295 | byte2;
              let subtracted = -1;
              if (code >= 33088 && code <= 40956) {
                subtracted = code - 33088;
              } else if (code >= 57408 && code <= 60351) {
                subtracted = code - 49472;
              }
              if (subtracted === -1) {
                throw new WriterException("Invalid byte sequence");
              }
              const encoded = (subtracted >> 8) * 192 + (subtracted & 255);
              bits.appendBits(encoded, 13);
            }
          }
          static appendECI(eci, bits) {
            bits.appendBits(Mode$1.ECI.getBits(), 4);
            bits.appendBits(eci.getValue(), 8);
          }
        }
        Encoder.ALPHANUMERIC_TABLE = Int32Array.from([
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          36,
          -1,
          -1,
          -1,
          37,
          38,
          -1,
          -1,
          -1,
          -1,
          39,
          40,
          -1,
          41,
          42,
          43,
          0,
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          44,
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          10,
          11,
          12,
          13,
          14,
          15,
          16,
          17,
          18,
          19,
          20,
          21,
          22,
          23,
          24,
          25,
          26,
          27,
          28,
          29,
          30,
          31,
          32,
          33,
          34,
          35,
          -1,
          -1,
          -1,
          -1,
          -1
        ]);
        Encoder.DEFAULT_BYTE_MODE_ENCODING = CharacterSetECI.UTF8.getName();
        class BrowserQRCodeSvgWriter {
          write(contents, width, height, hints = null) {
            if (contents.length === 0) {
              throw new IllegalArgumentException("Found empty contents");
            }
            if (width < 0 || height < 0) {
              throw new IllegalArgumentException("Requested dimensions are too small: " + width + "x" + height);
            }
            let errorCorrectionLevel = ErrorCorrectionLevel.L;
            let quietZone = BrowserQRCodeSvgWriter.QUIET_ZONE_SIZE;
            if (hints !== null) {
              if (hints.get(EncodeHintType$1.ERROR_CORRECTION) !== void 0) {
                errorCorrectionLevel = ErrorCorrectionLevel.fromString(hints.get(EncodeHintType$1.ERROR_CORRECTION).toString());
              }
              if (hints.get(EncodeHintType$1.MARGIN) !== void 0) {
                quietZone = Number.parseInt(hints.get(EncodeHintType$1.MARGIN).toString(), 10);
              }
            }
            const code = Encoder.encode(contents, errorCorrectionLevel, hints);
            return this.renderResult(code, width, height, quietZone);
          }
          writeToDom(containerElement, contents, width, height, hints = null) {
            if (typeof containerElement === "string") {
              containerElement = document.querySelector(containerElement);
            }
            const svgElement = this.write(contents, width, height, hints);
            if (containerElement)
              containerElement.appendChild(svgElement);
          }
          renderResult(code, width, height, quietZone) {
            const input = code.getMatrix();
            if (input === null) {
              throw new IllegalStateException();
            }
            const inputWidth = input.getWidth();
            const inputHeight = input.getHeight();
            const qrWidth = inputWidth + quietZone * 2;
            const qrHeight = inputHeight + quietZone * 2;
            const outputWidth = Math.max(width, qrWidth);
            const outputHeight = Math.max(height, qrHeight);
            const multiple = Math.min(Math.floor(outputWidth / qrWidth), Math.floor(outputHeight / qrHeight));
            const leftPadding = Math.floor((outputWidth - inputWidth * multiple) / 2);
            const topPadding = Math.floor((outputHeight - inputHeight * multiple) / 2);
            const svgElement = this.createSVGElement(outputWidth, outputHeight);
            for (let inputY = 0, outputY = topPadding; inputY < inputHeight; inputY++, outputY += multiple) {
              for (let inputX = 0, outputX = leftPadding; inputX < inputWidth; inputX++, outputX += multiple) {
                if (input.get(inputX, inputY) === 1) {
                  const svgRectElement = this.createSvgRectElement(outputX, outputY, multiple, multiple);
                  svgElement.appendChild(svgRectElement);
                }
              }
            }
            return svgElement;
          }
          createSVGElement(w, h) {
            const svgElement = document.createElementNS(BrowserQRCodeSvgWriter.SVG_NS, "svg");
            svgElement.setAttributeNS(null, "height", w.toString());
            svgElement.setAttributeNS(null, "width", h.toString());
            return svgElement;
          }
          createSvgRectElement(x, y, w, h) {
            const rect = document.createElementNS(BrowserQRCodeSvgWriter.SVG_NS, "rect");
            rect.setAttributeNS(null, "x", x.toString());
            rect.setAttributeNS(null, "y", y.toString());
            rect.setAttributeNS(null, "height", w.toString());
            rect.setAttributeNS(null, "width", h.toString());
            rect.setAttributeNS(null, "fill", "#000000");
            return rect;
          }
        }
        BrowserQRCodeSvgWriter.QUIET_ZONE_SIZE = 4;
        BrowserQRCodeSvgWriter.SVG_NS = "http://www.w3.org/2000/svg";
        class QRCodeWriter {
          encode(contents, format, width, height, hints) {
            if (contents.length === 0) {
              throw new IllegalArgumentException("Found empty contents");
            }
            if (format !== BarcodeFormat$1.QR_CODE) {
              throw new IllegalArgumentException("Can only encode QR_CODE, but got " + format);
            }
            if (width < 0 || height < 0) {
              throw new IllegalArgumentException(`Requested dimensions are too small: ${width}x${height}`);
            }
            let errorCorrectionLevel = ErrorCorrectionLevel.L;
            let quietZone = QRCodeWriter.QUIET_ZONE_SIZE;
            if (hints !== null) {
              if (hints.get(EncodeHintType$1.ERROR_CORRECTION) !== void 0) {
                errorCorrectionLevel = ErrorCorrectionLevel.fromString(hints.get(EncodeHintType$1.ERROR_CORRECTION).toString());
              }
              if (hints.get(EncodeHintType$1.MARGIN) !== void 0) {
                quietZone = Number.parseInt(hints.get(EncodeHintType$1.MARGIN).toString(), 10);
              }
            }
            const code = Encoder.encode(contents, errorCorrectionLevel, hints);
            return QRCodeWriter.renderResult(code, width, height, quietZone);
          }
          static renderResult(code, width, height, quietZone) {
            const input = code.getMatrix();
            if (input === null) {
              throw new IllegalStateException();
            }
            const inputWidth = input.getWidth();
            const inputHeight = input.getHeight();
            const qrWidth = inputWidth + quietZone * 2;
            const qrHeight = inputHeight + quietZone * 2;
            const outputWidth = Math.max(width, qrWidth);
            const outputHeight = Math.max(height, qrHeight);
            const multiple = Math.min(Math.floor(outputWidth / qrWidth), Math.floor(outputHeight / qrHeight));
            const leftPadding = Math.floor((outputWidth - inputWidth * multiple) / 2);
            const topPadding = Math.floor((outputHeight - inputHeight * multiple) / 2);
            const output = new BitMatrix(outputWidth, outputHeight);
            for (let inputY = 0, outputY = topPadding; inputY < inputHeight; inputY++, outputY += multiple) {
              for (let inputX = 0, outputX = leftPadding; inputX < inputWidth; inputX++, outputX += multiple) {
                if (input.get(inputX, inputY) === 1) {
                  output.setRegion(outputX, outputY, multiple, multiple);
                }
              }
            }
            return output;
          }
        }
        QRCodeWriter.QUIET_ZONE_SIZE = 4;
        class MultiFormatWriter {
          encode(contents, format, width, height, hints) {
            let writer;
            switch (format) {
              case BarcodeFormat$1.QR_CODE:
                writer = new QRCodeWriter();
                break;
              default:
                throw new IllegalArgumentException("No encoder available for format " + format);
            }
            return writer.encode(contents, format, width, height, hints);
          }
        }
        class PlanarYUVLuminanceSource extends LuminanceSource {
          constructor(yuvData, dataWidth, dataHeight, left, top, width, height, reverseHorizontal) {
            super(width, height);
            this.yuvData = yuvData;
            this.dataWidth = dataWidth;
            this.dataHeight = dataHeight;
            this.left = left;
            this.top = top;
            if (left + width > dataWidth || top + height > dataHeight) {
              throw new IllegalArgumentException("Crop rectangle does not fit within image data.");
            }
            if (reverseHorizontal) {
              this.reverseHorizontal(width, height);
            }
          }
          getRow(y, row) {
            if (y < 0 || y >= this.getHeight()) {
              throw new IllegalArgumentException("Requested row is outside the image: " + y);
            }
            const width = this.getWidth();
            if (row === null || row === void 0 || row.length < width) {
              row = new Uint8ClampedArray(width);
            }
            const offset = (y + this.top) * this.dataWidth + this.left;
            System.arraycopy(this.yuvData, offset, row, 0, width);
            return row;
          }
          getMatrix() {
            const width = this.getWidth();
            const height = this.getHeight();
            if (width === this.dataWidth && height === this.dataHeight) {
              return this.yuvData;
            }
            const area = width * height;
            const matrix = new Uint8ClampedArray(area);
            let inputOffset = this.top * this.dataWidth + this.left;
            if (width === this.dataWidth) {
              System.arraycopy(this.yuvData, inputOffset, matrix, 0, area);
              return matrix;
            }
            for (let y = 0; y < height; y++) {
              const outputOffset = y * width;
              System.arraycopy(this.yuvData, inputOffset, matrix, outputOffset, width);
              inputOffset += this.dataWidth;
            }
            return matrix;
          }
          isCropSupported() {
            return true;
          }
          crop(left, top, width, height) {
            return new PlanarYUVLuminanceSource(this.yuvData, this.dataWidth, this.dataHeight, this.left + left, this.top + top, width, height, false);
          }
          renderThumbnail() {
            const width = this.getWidth() / PlanarYUVLuminanceSource.THUMBNAIL_SCALE_FACTOR;
            const height = this.getHeight() / PlanarYUVLuminanceSource.THUMBNAIL_SCALE_FACTOR;
            const pixels = new Int32Array(width * height);
            const yuv = this.yuvData;
            let inputOffset = this.top * this.dataWidth + this.left;
            for (let y = 0; y < height; y++) {
              const outputOffset = y * width;
              for (let x = 0; x < width; x++) {
                const grey = yuv[inputOffset + x * PlanarYUVLuminanceSource.THUMBNAIL_SCALE_FACTOR] & 255;
                pixels[outputOffset + x] = 4278190080 | grey * 65793;
              }
              inputOffset += this.dataWidth * PlanarYUVLuminanceSource.THUMBNAIL_SCALE_FACTOR;
            }
            return pixels;
          }
          getThumbnailWidth() {
            return this.getWidth() / PlanarYUVLuminanceSource.THUMBNAIL_SCALE_FACTOR;
          }
          getThumbnailHeight() {
            return this.getHeight() / PlanarYUVLuminanceSource.THUMBNAIL_SCALE_FACTOR;
          }
          reverseHorizontal(width, height) {
            const yuvData = this.yuvData;
            for (let y = 0, rowStart = this.top * this.dataWidth + this.left; y < height; y++, rowStart += this.dataWidth) {
              const middle = rowStart + width / 2;
              for (let x1 = rowStart, x2 = rowStart + width - 1; x1 < middle; x1++, x2--) {
                const temp = yuvData[x1];
                yuvData[x1] = yuvData[x2];
                yuvData[x2] = temp;
              }
            }
          }
          invert() {
            return new InvertedLuminanceSource(this);
          }
        }
        PlanarYUVLuminanceSource.THUMBNAIL_SCALE_FACTOR = 2;
        class RGBLuminanceSource extends LuminanceSource {
          constructor(luminances, width, height, dataWidth, dataHeight, left, top) {
            super(width, height);
            this.dataWidth = dataWidth;
            this.dataHeight = dataHeight;
            this.left = left;
            this.top = top;
            if (luminances.BYTES_PER_ELEMENT === 4) {
              const size2 = width * height;
              const luminancesUint8Array = new Uint8ClampedArray(size2);
              for (let offset = 0; offset < size2; offset++) {
                const pixel = luminances[offset];
                const r = pixel >> 16 & 255;
                const g2 = pixel >> 7 & 510;
                const b = pixel & 255;
                luminancesUint8Array[offset] = (r + g2 + b) / 4 & 255;
              }
              this.luminances = luminancesUint8Array;
            } else {
              this.luminances = luminances;
            }
            if (dataWidth === void 0) {
              this.dataWidth = width;
            }
            if (dataHeight === void 0) {
              this.dataHeight = height;
            }
            if (left === void 0) {
              this.left = 0;
            }
            if (top === void 0) {
              this.top = 0;
            }
            if (this.left + width > this.dataWidth || this.top + height > this.dataHeight) {
              throw new IllegalArgumentException("Crop rectangle does not fit within image data.");
            }
          }
          getRow(y, row) {
            if (y < 0 || y >= this.getHeight()) {
              throw new IllegalArgumentException("Requested row is outside the image: " + y);
            }
            const width = this.getWidth();
            if (row === null || row === void 0 || row.length < width) {
              row = new Uint8ClampedArray(width);
            }
            const offset = (y + this.top) * this.dataWidth + this.left;
            System.arraycopy(this.luminances, offset, row, 0, width);
            return row;
          }
          getMatrix() {
            const width = this.getWidth();
            const height = this.getHeight();
            if (width === this.dataWidth && height === this.dataHeight) {
              return this.luminances;
            }
            const area = width * height;
            const matrix = new Uint8ClampedArray(area);
            let inputOffset = this.top * this.dataWidth + this.left;
            if (width === this.dataWidth) {
              System.arraycopy(this.luminances, inputOffset, matrix, 0, area);
              return matrix;
            }
            for (let y = 0; y < height; y++) {
              const outputOffset = y * width;
              System.arraycopy(this.luminances, inputOffset, matrix, outputOffset, width);
              inputOffset += this.dataWidth;
            }
            return matrix;
          }
          isCropSupported() {
            return true;
          }
          crop(left, top, width, height) {
            return new RGBLuminanceSource(this.luminances, width, height, this.dataWidth, this.dataHeight, this.left + left, this.top + top);
          }
          invert() {
            return new InvertedLuminanceSource(this);
          }
        }
        class Charset extends CharacterSetECI {
          static forName(name) {
            return this.getCharacterSetECIByName(name);
          }
        }
        class StandardCharsets {
        }
        StandardCharsets.ISO_8859_1 = CharacterSetECI.ISO8859_1;
        class AztecCode {
          isCompact() {
            return this.compact;
          }
          setCompact(compact) {
            this.compact = compact;
          }
          getSize() {
            return this.size;
          }
          setSize(size2) {
            this.size = size2;
          }
          getLayers() {
            return this.layers;
          }
          setLayers(layers) {
            this.layers = layers;
          }
          getCodeWords() {
            return this.codeWords;
          }
          setCodeWords(codeWords) {
            this.codeWords = codeWords;
          }
          getMatrix() {
            return this.matrix;
          }
          setMatrix(matrix) {
            this.matrix = matrix;
          }
        }
        class Collections {
          static singletonList(item) {
            return [item];
          }
          static min(collection, comparator) {
            return collection.sort(comparator)[0];
          }
        }
        class Token {
          constructor(previous) {
            this.previous = previous;
          }
          getPrevious() {
            return this.previous;
          }
        }
        class SimpleToken extends Token {
          constructor(previous, value, bitCount) {
            super(previous);
            this.value = value;
            this.bitCount = bitCount;
          }
          appendTo(bitArray, text) {
            bitArray.appendBits(this.value, this.bitCount);
          }
          add(value, bitCount) {
            return new SimpleToken(this, value, bitCount);
          }
          addBinaryShift(start2, byteCount) {
            console.warn("addBinaryShift on SimpleToken, this simply returns a copy of this token");
            return new SimpleToken(this, start2, byteCount);
          }
          toString() {
            let value = this.value & (1 << this.bitCount) - 1;
            value |= 1 << this.bitCount;
            return "<" + Integer.toBinaryString(value | 1 << this.bitCount).substring(1) + ">";
          }
        }
        class BinaryShiftToken extends SimpleToken {
          constructor(previous, binaryShiftStart, binaryShiftByteCount) {
            super(previous, 0, 0);
            this.binaryShiftStart = binaryShiftStart;
            this.binaryShiftByteCount = binaryShiftByteCount;
          }
          appendTo(bitArray, text) {
            for (let i = 0; i < this.binaryShiftByteCount; i++) {
              if (i === 0 || i === 31 && this.binaryShiftByteCount <= 62) {
                bitArray.appendBits(31, 5);
                if (this.binaryShiftByteCount > 62) {
                  bitArray.appendBits(this.binaryShiftByteCount - 31, 16);
                } else if (i === 0) {
                  bitArray.appendBits(Math.min(this.binaryShiftByteCount, 31), 5);
                } else {
                  bitArray.appendBits(this.binaryShiftByteCount - 31, 5);
                }
              }
              bitArray.appendBits(text[this.binaryShiftStart + i], 8);
            }
          }
          addBinaryShift(start2, byteCount) {
            return new BinaryShiftToken(this, start2, byteCount);
          }
          toString() {
            return "<" + this.binaryShiftStart + "::" + (this.binaryShiftStart + this.binaryShiftByteCount - 1) + ">";
          }
        }
        function addBinaryShift(token, start2, byteCount) {
          return new BinaryShiftToken(token, start2, byteCount);
        }
        function add2(token, value, bitCount) {
          return new SimpleToken(token, value, bitCount);
        }
        const MODE_NAMES = [
          "UPPER",
          "LOWER",
          "DIGIT",
          "MIXED",
          "PUNCT"
        ];
        const MODE_UPPER = 0;
        const MODE_LOWER = 1;
        const MODE_DIGIT = 2;
        const MODE_MIXED = 3;
        const MODE_PUNCT = 4;
        const EMPTY_TOKEN = new SimpleToken(null, 0, 0);
        const LATCH_TABLE = [
          Int32Array.from([
            0,
            (5 << 16) + 28,
            (5 << 16) + 30,
            (5 << 16) + 29,
            (10 << 16) + (29 << 5) + 30
          ]),
          Int32Array.from([
            (9 << 16) + (30 << 4) + 14,
            0,
            (5 << 16) + 30,
            (5 << 16) + 29,
            (10 << 16) + (29 << 5) + 30
          ]),
          Int32Array.from([
            (4 << 16) + 14,
            (9 << 16) + (14 << 5) + 28,
            0,
            (9 << 16) + (14 << 5) + 29,
            (14 << 16) + (14 << 10) + (29 << 5) + 30
          ]),
          Int32Array.from([
            (5 << 16) + 29,
            (5 << 16) + 28,
            (10 << 16) + (29 << 5) + 30,
            0,
            (5 << 16) + 30
          ]),
          Int32Array.from([
            (5 << 16) + 31,
            (10 << 16) + (31 << 5) + 28,
            (10 << 16) + (31 << 5) + 30,
            (10 << 16) + (31 << 5) + 29,
            0
          ])
        ];
        function static_SHIFT_TABLE(SHIFT_TABLE2) {
          for (let table of SHIFT_TABLE2) {
            Arrays.fill(table, -1);
          }
          SHIFT_TABLE2[MODE_UPPER][MODE_PUNCT] = 0;
          SHIFT_TABLE2[MODE_LOWER][MODE_PUNCT] = 0;
          SHIFT_TABLE2[MODE_LOWER][MODE_UPPER] = 28;
          SHIFT_TABLE2[MODE_MIXED][MODE_PUNCT] = 0;
          SHIFT_TABLE2[MODE_DIGIT][MODE_PUNCT] = 0;
          SHIFT_TABLE2[MODE_DIGIT][MODE_UPPER] = 15;
          return SHIFT_TABLE2;
        }
        const SHIFT_TABLE = static_SHIFT_TABLE(Arrays.createInt32Array(6, 6));
        class State {
          constructor(token, mode, binaryBytes, bitCount) {
            this.token = token;
            this.mode = mode;
            this.binaryShiftByteCount = binaryBytes;
            this.bitCount = bitCount;
          }
          getMode() {
            return this.mode;
          }
          getToken() {
            return this.token;
          }
          getBinaryShiftByteCount() {
            return this.binaryShiftByteCount;
          }
          getBitCount() {
            return this.bitCount;
          }
          latchAndAppend(mode, value) {
            let bitCount = this.bitCount;
            let token = this.token;
            if (mode !== this.mode) {
              let latch = LATCH_TABLE[this.mode][mode];
              token = add2(token, latch & 65535, latch >> 16);
              bitCount += latch >> 16;
            }
            let latchModeBitCount = mode === MODE_DIGIT ? 4 : 5;
            token = add2(token, value, latchModeBitCount);
            return new State(token, mode, 0, bitCount + latchModeBitCount);
          }
          shiftAndAppend(mode, value) {
            let token = this.token;
            let thisModeBitCount = this.mode === MODE_DIGIT ? 4 : 5;
            token = add2(token, SHIFT_TABLE[this.mode][mode], thisModeBitCount);
            token = add2(token, value, 5);
            return new State(token, this.mode, 0, this.bitCount + thisModeBitCount + 5);
          }
          addBinaryShiftChar(index) {
            let token = this.token;
            let mode = this.mode;
            let bitCount = this.bitCount;
            if (this.mode === MODE_PUNCT || this.mode === MODE_DIGIT) {
              let latch = LATCH_TABLE[mode][MODE_UPPER];
              token = add2(token, latch & 65535, latch >> 16);
              bitCount += latch >> 16;
              mode = MODE_UPPER;
            }
            let deltaBitCount = this.binaryShiftByteCount === 0 || this.binaryShiftByteCount === 31 ? 18 : this.binaryShiftByteCount === 62 ? 9 : 8;
            let result = new State(token, mode, this.binaryShiftByteCount + 1, bitCount + deltaBitCount);
            if (result.binaryShiftByteCount === 2047 + 31) {
              result = result.endBinaryShift(index + 1);
            }
            return result;
          }
          endBinaryShift(index) {
            if (this.binaryShiftByteCount === 0) {
              return this;
            }
            let token = this.token;
            token = addBinaryShift(token, index - this.binaryShiftByteCount, this.binaryShiftByteCount);
            return new State(token, this.mode, 0, this.bitCount);
          }
          isBetterThanOrEqualTo(other) {
            let newModeBitCount = this.bitCount + (LATCH_TABLE[this.mode][other.mode] >> 16);
            if (this.binaryShiftByteCount < other.binaryShiftByteCount) {
              newModeBitCount += State.calculateBinaryShiftCost(other) - State.calculateBinaryShiftCost(this);
            } else if (this.binaryShiftByteCount > other.binaryShiftByteCount && other.binaryShiftByteCount > 0) {
              newModeBitCount += 10;
            }
            return newModeBitCount <= other.bitCount;
          }
          toBitArray(text) {
            let symbols = [];
            for (let token = this.endBinaryShift(text.length).token; token !== null; token = token.getPrevious()) {
              symbols.unshift(token);
            }
            let bitArray = new BitArray();
            for (const symbol of symbols) {
              symbol.appendTo(bitArray, text);
            }
            return bitArray;
          }
          toString() {
            return StringUtils.format("%s bits=%d bytes=%d", MODE_NAMES[this.mode], this.bitCount, this.binaryShiftByteCount);
          }
          static calculateBinaryShiftCost(state) {
            if (state.binaryShiftByteCount > 62) {
              return 21;
            }
            if (state.binaryShiftByteCount > 31) {
              return 20;
            }
            if (state.binaryShiftByteCount > 0) {
              return 10;
            }
            return 0;
          }
        }
        State.INITIAL_STATE = new State(EMPTY_TOKEN, MODE_UPPER, 0, 0);
        function static_CHAR_MAP(CHAR_MAP2) {
          const spaceCharCode = StringUtils.getCharCode(" ");
          const pointCharCode = StringUtils.getCharCode(".");
          const commaCharCode = StringUtils.getCharCode(",");
          CHAR_MAP2[MODE_UPPER][spaceCharCode] = 1;
          const zUpperCharCode = StringUtils.getCharCode("Z");
          const aUpperCharCode = StringUtils.getCharCode("A");
          for (let c = aUpperCharCode; c <= zUpperCharCode; c++) {
            CHAR_MAP2[MODE_UPPER][c] = c - aUpperCharCode + 2;
          }
          CHAR_MAP2[MODE_LOWER][spaceCharCode] = 1;
          const zLowerCharCode = StringUtils.getCharCode("z");
          const aLowerCharCode = StringUtils.getCharCode("a");
          for (let c = aLowerCharCode; c <= zLowerCharCode; c++) {
            CHAR_MAP2[MODE_LOWER][c] = c - aLowerCharCode + 2;
          }
          CHAR_MAP2[MODE_DIGIT][spaceCharCode] = 1;
          const nineCharCode = StringUtils.getCharCode("9");
          const zeroCharCode = StringUtils.getCharCode("0");
          for (let c = zeroCharCode; c <= nineCharCode; c++) {
            CHAR_MAP2[MODE_DIGIT][c] = c - zeroCharCode + 2;
          }
          CHAR_MAP2[MODE_DIGIT][commaCharCode] = 12;
          CHAR_MAP2[MODE_DIGIT][pointCharCode] = 13;
          const mixedTable = [
            "\0",
            " ",
            "",
            "",
            "",
            "",
            "",
            "",
            "\x07",
            "\b",
            "	",
            "\n",
            "\v",
            "\f",
            "\r",
            "",
            "",
            "",
            "",
            "",
            "@",
            "\\",
            "^",
            "_",
            "`",
            "|",
            "~",
            "\x7F"
          ];
          for (let i = 0; i < mixedTable.length; i++) {
            CHAR_MAP2[MODE_MIXED][StringUtils.getCharCode(mixedTable[i])] = i;
          }
          const punctTable = [
            "\0",
            "\r",
            "\0",
            "\0",
            "\0",
            "\0",
            "!",
            "'",
            "#",
            "$",
            "%",
            "&",
            "'",
            "(",
            ")",
            "*",
            "+",
            ",",
            "-",
            ".",
            "/",
            ":",
            ";",
            "<",
            "=",
            ">",
            "?",
            "[",
            "]",
            "{",
            "}"
          ];
          for (let i = 0; i < punctTable.length; i++) {
            if (StringUtils.getCharCode(punctTable[i]) > 0) {
              CHAR_MAP2[MODE_PUNCT][StringUtils.getCharCode(punctTable[i])] = i;
            }
          }
          return CHAR_MAP2;
        }
        const CHAR_MAP = static_CHAR_MAP(Arrays.createInt32Array(5, 256));
        class HighLevelEncoder {
          constructor(text) {
            this.text = text;
          }
          encode() {
            const spaceCharCode = StringUtils.getCharCode(" ");
            const lineBreakCharCode = StringUtils.getCharCode("\n");
            let states = Collections.singletonList(State.INITIAL_STATE);
            for (let index = 0; index < this.text.length; index++) {
              let pairCode;
              let nextChar = index + 1 < this.text.length ? this.text[index + 1] : 0;
              switch (this.text[index]) {
                case StringUtils.getCharCode("\r"):
                  pairCode = nextChar === lineBreakCharCode ? 2 : 0;
                  break;
                case StringUtils.getCharCode("."):
                  pairCode = nextChar === spaceCharCode ? 3 : 0;
                  break;
                case StringUtils.getCharCode(","):
                  pairCode = nextChar === spaceCharCode ? 4 : 0;
                  break;
                case StringUtils.getCharCode(":"):
                  pairCode = nextChar === spaceCharCode ? 5 : 0;
                  break;
                default:
                  pairCode = 0;
              }
              if (pairCode > 0) {
                states = HighLevelEncoder.updateStateListForPair(states, index, pairCode);
                index++;
              } else {
                states = this.updateStateListForChar(states, index);
              }
            }
            const minState = Collections.min(states, (a, b) => {
              return a.getBitCount() - b.getBitCount();
            });
            return minState.toBitArray(this.text);
          }
          updateStateListForChar(states, index) {
            const result = [];
            for (let state of states) {
              this.updateStateForChar(state, index, result);
            }
            return HighLevelEncoder.simplifyStates(result);
          }
          updateStateForChar(state, index, result) {
            let ch = this.text[index] & 255;
            let charInCurrentTable = CHAR_MAP[state.getMode()][ch] > 0;
            let stateNoBinary = null;
            for (let mode = 0; mode <= MODE_PUNCT; mode++) {
              let charInMode = CHAR_MAP[mode][ch];
              if (charInMode > 0) {
                if (stateNoBinary == null) {
                  stateNoBinary = state.endBinaryShift(index);
                }
                if (!charInCurrentTable || mode === state.getMode() || mode === MODE_DIGIT) {
                  const latchState = stateNoBinary.latchAndAppend(mode, charInMode);
                  result.push(latchState);
                }
                if (!charInCurrentTable && SHIFT_TABLE[state.getMode()][mode] >= 0) {
                  const shiftState = stateNoBinary.shiftAndAppend(mode, charInMode);
                  result.push(shiftState);
                }
              }
            }
            if (state.getBinaryShiftByteCount() > 0 || CHAR_MAP[state.getMode()][ch] === 0) {
              let binaryState = state.addBinaryShiftChar(index);
              result.push(binaryState);
            }
          }
          static updateStateListForPair(states, index, pairCode) {
            const result = [];
            for (let state of states) {
              this.updateStateForPair(state, index, pairCode, result);
            }
            return this.simplifyStates(result);
          }
          static updateStateForPair(state, index, pairCode, result) {
            let stateNoBinary = state.endBinaryShift(index);
            result.push(stateNoBinary.latchAndAppend(MODE_PUNCT, pairCode));
            if (state.getMode() !== MODE_PUNCT) {
              result.push(stateNoBinary.shiftAndAppend(MODE_PUNCT, pairCode));
            }
            if (pairCode === 3 || pairCode === 4) {
              let digitState = stateNoBinary.latchAndAppend(MODE_DIGIT, 16 - pairCode).latchAndAppend(MODE_DIGIT, 1);
              result.push(digitState);
            }
            if (state.getBinaryShiftByteCount() > 0) {
              let binaryState = state.addBinaryShiftChar(index).addBinaryShiftChar(index + 1);
              result.push(binaryState);
            }
          }
          static simplifyStates(states) {
            let result = [];
            for (const newState of states) {
              let add3 = true;
              for (const oldState of result) {
                if (oldState.isBetterThanOrEqualTo(newState)) {
                  add3 = false;
                  break;
                }
                if (newState.isBetterThanOrEqualTo(oldState)) {
                  result = result.filter((x) => x !== oldState);
                }
              }
              if (add3) {
                result.push(newState);
              }
            }
            return result;
          }
        }
        class Encoder$1 {
          constructor() {
          }
          static encodeBytes(data2) {
            return Encoder$1.encode(data2, Encoder$1.DEFAULT_EC_PERCENT, Encoder$1.DEFAULT_AZTEC_LAYERS);
          }
          static encode(data2, minECCPercent, userSpecifiedLayers) {
            let bits = new HighLevelEncoder(data2).encode();
            let eccBits = Integer.truncDivision(bits.getSize() * minECCPercent, 100) + 11;
            let totalSizeBits = bits.getSize() + eccBits;
            let compact;
            let layers;
            let totalBitsInLayer;
            let wordSize;
            let stuffedBits;
            if (userSpecifiedLayers !== Encoder$1.DEFAULT_AZTEC_LAYERS) {
              compact = userSpecifiedLayers < 0;
              layers = Math.abs(userSpecifiedLayers);
              if (layers > (compact ? Encoder$1.MAX_NB_BITS_COMPACT : Encoder$1.MAX_NB_BITS)) {
                throw new IllegalArgumentException(StringUtils.format("Illegal value %s for layers", userSpecifiedLayers));
              }
              totalBitsInLayer = Encoder$1.totalBitsInLayer(layers, compact);
              wordSize = Encoder$1.WORD_SIZE[layers];
              let usableBitsInLayers = totalBitsInLayer - totalBitsInLayer % wordSize;
              stuffedBits = Encoder$1.stuffBits(bits, wordSize);
              if (stuffedBits.getSize() + eccBits > usableBitsInLayers) {
                throw new IllegalArgumentException("Data to large for user specified layer");
              }
              if (compact && stuffedBits.getSize() > wordSize * 64) {
                throw new IllegalArgumentException("Data to large for user specified layer");
              }
            } else {
              wordSize = 0;
              stuffedBits = null;
              for (let i = 0; ; i++) {
                if (i > Encoder$1.MAX_NB_BITS) {
                  throw new IllegalArgumentException("Data too large for an Aztec code");
                }
                compact = i <= 3;
                layers = compact ? i + 1 : i;
                totalBitsInLayer = Encoder$1.totalBitsInLayer(layers, compact);
                if (totalSizeBits > totalBitsInLayer) {
                  continue;
                }
                if (stuffedBits == null || wordSize !== Encoder$1.WORD_SIZE[layers]) {
                  wordSize = Encoder$1.WORD_SIZE[layers];
                  stuffedBits = Encoder$1.stuffBits(bits, wordSize);
                }
                let usableBitsInLayers = totalBitsInLayer - totalBitsInLayer % wordSize;
                if (compact && stuffedBits.getSize() > wordSize * 64) {
                  continue;
                }
                if (stuffedBits.getSize() + eccBits <= usableBitsInLayers) {
                  break;
                }
              }
            }
            let messageBits = Encoder$1.generateCheckWords(stuffedBits, totalBitsInLayer, wordSize);
            let messageSizeInWords = stuffedBits.getSize() / wordSize;
            let modeMessage = Encoder$1.generateModeMessage(compact, layers, messageSizeInWords);
            let baseMatrixSize = (compact ? 11 : 14) + layers * 4;
            let alignmentMap = new Int32Array(baseMatrixSize);
            let matrixSize;
            if (compact) {
              matrixSize = baseMatrixSize;
              for (let i = 0; i < alignmentMap.length; i++) {
                alignmentMap[i] = i;
              }
            } else {
              matrixSize = baseMatrixSize + 1 + 2 * Integer.truncDivision(Integer.truncDivision(baseMatrixSize, 2) - 1, 15);
              let origCenter = Integer.truncDivision(baseMatrixSize, 2);
              let center = Integer.truncDivision(matrixSize, 2);
              for (let i = 0; i < origCenter; i++) {
                let newOffset = i + Integer.truncDivision(i, 15);
                alignmentMap[origCenter - i - 1] = center - newOffset - 1;
                alignmentMap[origCenter + i] = center + newOffset + 1;
              }
            }
            let matrix = new BitMatrix(matrixSize);
            for (let i = 0, rowOffset = 0; i < layers; i++) {
              let rowSize = (layers - i) * 4 + (compact ? 9 : 12);
              for (let j = 0; j < rowSize; j++) {
                let columnOffset = j * 2;
                for (let k = 0; k < 2; k++) {
                  if (messageBits.get(rowOffset + columnOffset + k)) {
                    matrix.set(alignmentMap[i * 2 + k], alignmentMap[i * 2 + j]);
                  }
                  if (messageBits.get(rowOffset + rowSize * 2 + columnOffset + k)) {
                    matrix.set(alignmentMap[i * 2 + j], alignmentMap[baseMatrixSize - 1 - i * 2 - k]);
                  }
                  if (messageBits.get(rowOffset + rowSize * 4 + columnOffset + k)) {
                    matrix.set(alignmentMap[baseMatrixSize - 1 - i * 2 - k], alignmentMap[baseMatrixSize - 1 - i * 2 - j]);
                  }
                  if (messageBits.get(rowOffset + rowSize * 6 + columnOffset + k)) {
                    matrix.set(alignmentMap[baseMatrixSize - 1 - i * 2 - j], alignmentMap[i * 2 + k]);
                  }
                }
              }
              rowOffset += rowSize * 8;
            }
            Encoder$1.drawModeMessage(matrix, compact, matrixSize, modeMessage);
            if (compact) {
              Encoder$1.drawBullsEye(matrix, Integer.truncDivision(matrixSize, 2), 5);
            } else {
              Encoder$1.drawBullsEye(matrix, Integer.truncDivision(matrixSize, 2), 7);
              for (let i = 0, j = 0; i < Integer.truncDivision(baseMatrixSize, 2) - 1; i += 15, j += 16) {
                for (let k = Integer.truncDivision(matrixSize, 2) & 1; k < matrixSize; k += 2) {
                  matrix.set(Integer.truncDivision(matrixSize, 2) - j, k);
                  matrix.set(Integer.truncDivision(matrixSize, 2) + j, k);
                  matrix.set(k, Integer.truncDivision(matrixSize, 2) - j);
                  matrix.set(k, Integer.truncDivision(matrixSize, 2) + j);
                }
              }
            }
            let aztec = new AztecCode();
            aztec.setCompact(compact);
            aztec.setSize(matrixSize);
            aztec.setLayers(layers);
            aztec.setCodeWords(messageSizeInWords);
            aztec.setMatrix(matrix);
            return aztec;
          }
          static drawBullsEye(matrix, center, size2) {
            for (let i = 0; i < size2; i += 2) {
              for (let j = center - i; j <= center + i; j++) {
                matrix.set(j, center - i);
                matrix.set(j, center + i);
                matrix.set(center - i, j);
                matrix.set(center + i, j);
              }
            }
            matrix.set(center - size2, center - size2);
            matrix.set(center - size2 + 1, center - size2);
            matrix.set(center - size2, center - size2 + 1);
            matrix.set(center + size2, center - size2);
            matrix.set(center + size2, center - size2 + 1);
            matrix.set(center + size2, center + size2 - 1);
          }
          static generateModeMessage(compact, layers, messageSizeInWords) {
            let modeMessage = new BitArray();
            if (compact) {
              modeMessage.appendBits(layers - 1, 2);
              modeMessage.appendBits(messageSizeInWords - 1, 6);
              modeMessage = Encoder$1.generateCheckWords(modeMessage, 28, 4);
            } else {
              modeMessage.appendBits(layers - 1, 5);
              modeMessage.appendBits(messageSizeInWords - 1, 11);
              modeMessage = Encoder$1.generateCheckWords(modeMessage, 40, 4);
            }
            return modeMessage;
          }
          static drawModeMessage(matrix, compact, matrixSize, modeMessage) {
            let center = Integer.truncDivision(matrixSize, 2);
            if (compact) {
              for (let i = 0; i < 7; i++) {
                let offset = center - 3 + i;
                if (modeMessage.get(i)) {
                  matrix.set(offset, center - 5);
                }
                if (modeMessage.get(i + 7)) {
                  matrix.set(center + 5, offset);
                }
                if (modeMessage.get(20 - i)) {
                  matrix.set(offset, center + 5);
                }
                if (modeMessage.get(27 - i)) {
                  matrix.set(center - 5, offset);
                }
              }
            } else {
              for (let i = 0; i < 10; i++) {
                let offset = center - 5 + i + Integer.truncDivision(i, 5);
                if (modeMessage.get(i)) {
                  matrix.set(offset, center - 7);
                }
                if (modeMessage.get(i + 10)) {
                  matrix.set(center + 7, offset);
                }
                if (modeMessage.get(29 - i)) {
                  matrix.set(offset, center + 7);
                }
                if (modeMessage.get(39 - i)) {
                  matrix.set(center - 7, offset);
                }
              }
            }
          }
          static generateCheckWords(bitArray, totalBits, wordSize) {
            let messageSizeInWords = bitArray.getSize() / wordSize;
            let rs = new ReedSolomonEncoder(Encoder$1.getGF(wordSize));
            let totalWords = Integer.truncDivision(totalBits, wordSize);
            let messageWords = Encoder$1.bitsToWords(bitArray, wordSize, totalWords);
            rs.encode(messageWords, totalWords - messageSizeInWords);
            let startPad = totalBits % wordSize;
            let messageBits = new BitArray();
            messageBits.appendBits(0, startPad);
            for (const messageWord of Array.from(messageWords)) {
              messageBits.appendBits(messageWord, wordSize);
            }
            return messageBits;
          }
          static bitsToWords(stuffedBits, wordSize, totalWords) {
            let message = new Int32Array(totalWords);
            let i;
            let n;
            for (i = 0, n = stuffedBits.getSize() / wordSize; i < n; i++) {
              let value = 0;
              for (let j = 0; j < wordSize; j++) {
                value |= stuffedBits.get(i * wordSize + j) ? 1 << wordSize - j - 1 : 0;
              }
              message[i] = value;
            }
            return message;
          }
          static getGF(wordSize) {
            switch (wordSize) {
              case 4:
                return GenericGF.AZTEC_PARAM;
              case 6:
                return GenericGF.AZTEC_DATA_6;
              case 8:
                return GenericGF.AZTEC_DATA_8;
              case 10:
                return GenericGF.AZTEC_DATA_10;
              case 12:
                return GenericGF.AZTEC_DATA_12;
              default:
                throw new IllegalArgumentException("Unsupported word size " + wordSize);
            }
          }
          static stuffBits(bits, wordSize) {
            let out = new BitArray();
            let n = bits.getSize();
            let mask = (1 << wordSize) - 2;
            for (let i = 0; i < n; i += wordSize) {
              let word = 0;
              for (let j = 0; j < wordSize; j++) {
                if (i + j >= n || bits.get(i + j)) {
                  word |= 1 << wordSize - 1 - j;
                }
              }
              if ((word & mask) === mask) {
                out.appendBits(word & mask, wordSize);
                i--;
              } else if ((word & mask) === 0) {
                out.appendBits(word | 1, wordSize);
                i--;
              } else {
                out.appendBits(word, wordSize);
              }
            }
            return out;
          }
          static totalBitsInLayer(layers, compact) {
            return ((compact ? 88 : 112) + 16 * layers) * layers;
          }
        }
        Encoder$1.DEFAULT_EC_PERCENT = 33;
        Encoder$1.DEFAULT_AZTEC_LAYERS = 0;
        Encoder$1.MAX_NB_BITS = 32;
        Encoder$1.MAX_NB_BITS_COMPACT = 4;
        Encoder$1.WORD_SIZE = Int32Array.from([
          4,
          6,
          6,
          8,
          8,
          8,
          8,
          8,
          8,
          10,
          10,
          10,
          10,
          10,
          10,
          10,
          10,
          10,
          10,
          10,
          10,
          10,
          10,
          12,
          12,
          12,
          12,
          12,
          12,
          12,
          12,
          12,
          12
        ]);
        class AztecWriter {
          encode(contents, format, width, height) {
            return this.encodeWithHints(contents, format, width, height, null);
          }
          encodeWithHints(contents, format, width, height, hints) {
            let charset = StandardCharsets.ISO_8859_1;
            let eccPercent = Encoder$1.DEFAULT_EC_PERCENT;
            let layers = Encoder$1.DEFAULT_AZTEC_LAYERS;
            if (hints != null) {
              if (hints.has(EncodeHintType$1.CHARACTER_SET)) {
                charset = Charset.forName(hints.get(EncodeHintType$1.CHARACTER_SET).toString());
              }
              if (hints.has(EncodeHintType$1.ERROR_CORRECTION)) {
                eccPercent = Integer.parseInt(hints.get(EncodeHintType$1.ERROR_CORRECTION).toString());
              }
              if (hints.has(EncodeHintType$1.AZTEC_LAYERS)) {
                layers = Integer.parseInt(hints.get(EncodeHintType$1.AZTEC_LAYERS).toString());
              }
            }
            return AztecWriter.encodeLayers(contents, format, width, height, charset, eccPercent, layers);
          }
          static encodeLayers(contents, format, width, height, charset, eccPercent, layers) {
            if (format !== BarcodeFormat$1.AZTEC) {
              throw new IllegalArgumentException("Can only encode AZTEC, but got " + format);
            }
            let aztec = Encoder$1.encode(StringUtils.getBytes(contents, charset), eccPercent, layers);
            return AztecWriter.renderResult(aztec, width, height);
          }
          static renderResult(code, width, height) {
            let input = code.getMatrix();
            if (input == null) {
              throw new IllegalStateException();
            }
            let inputWidth = input.getWidth();
            let inputHeight = input.getHeight();
            let outputWidth = Math.max(width, inputWidth);
            let outputHeight = Math.max(height, inputHeight);
            let multiple = Math.min(outputWidth / inputWidth, outputHeight / inputHeight);
            let leftPadding = (outputWidth - inputWidth * multiple) / 2;
            let topPadding = (outputHeight - inputHeight * multiple) / 2;
            let output = new BitMatrix(outputWidth, outputHeight);
            for (let inputY = 0, outputY = topPadding; inputY < inputHeight; inputY++, outputY += multiple) {
              for (let inputX = 0, outputX = leftPadding; inputX < inputWidth; inputX++, outputX += multiple) {
                if (input.get(inputX, inputY)) {
                  output.setRegion(outputX, outputY, multiple, multiple);
                }
              }
            }
            return output;
          }
        }
        exports2.AbstractExpandedDecoder = AbstractExpandedDecoder;
        exports2.ArgumentException = ArgumentException;
        exports2.ArithmeticException = ArithmeticException;
        exports2.AztecCode = AztecCode;
        exports2.AztecCodeReader = AztecReader;
        exports2.AztecCodeWriter = AztecWriter;
        exports2.AztecDecoder = Decoder;
        exports2.AztecDetector = Detector;
        exports2.AztecDetectorResult = AztecDetectorResult;
        exports2.AztecEncoder = Encoder$1;
        exports2.AztecHighLevelEncoder = HighLevelEncoder;
        exports2.AztecPoint = Point;
        exports2.BarcodeFormat = BarcodeFormat$1;
        exports2.Binarizer = Binarizer;
        exports2.BinaryBitmap = BinaryBitmap;
        exports2.BitArray = BitArray;
        exports2.BitMatrix = BitMatrix;
        exports2.BitSource = BitSource;
        exports2.BrowserAztecCodeReader = BrowserAztecCodeReader;
        exports2.BrowserBarcodeReader = BrowserBarcodeReader;
        exports2.BrowserCodeReader = BrowserCodeReader;
        exports2.BrowserDatamatrixCodeReader = BrowserDatamatrixCodeReader;
        exports2.BrowserMultiFormatReader = BrowserMultiFormatReader;
        exports2.BrowserPDF417Reader = BrowserPDF417Reader;
        exports2.BrowserQRCodeReader = BrowserQRCodeReader;
        exports2.BrowserQRCodeSvgWriter = BrowserQRCodeSvgWriter;
        exports2.CharacterSetECI = CharacterSetECI;
        exports2.ChecksumException = ChecksumException;
        exports2.Code128Reader = Code128Reader;
        exports2.Code39Reader = Code39Reader;
        exports2.DataMatrixDecodedBitStreamParser = DecodedBitStreamParser;
        exports2.DataMatrixReader = DataMatrixReader;
        exports2.DecodeHintType = DecodeHintType$1;
        exports2.DecoderResult = DecoderResult;
        exports2.DefaultGridSampler = DefaultGridSampler;
        exports2.DetectorResult = DetectorResult;
        exports2.EAN13Reader = EAN13Reader;
        exports2.EncodeHintType = EncodeHintType$1;
        exports2.Exception = Exception;
        exports2.FormatException = FormatException;
        exports2.GenericGF = GenericGF;
        exports2.GenericGFPoly = GenericGFPoly;
        exports2.GlobalHistogramBinarizer = GlobalHistogramBinarizer;
        exports2.GridSampler = GridSampler;
        exports2.GridSamplerInstance = GridSamplerInstance;
        exports2.HTMLCanvasElementLuminanceSource = HTMLCanvasElementLuminanceSource;
        exports2.HybridBinarizer = HybridBinarizer;
        exports2.ITFReader = ITFReader;
        exports2.IllegalArgumentException = IllegalArgumentException;
        exports2.IllegalStateException = IllegalStateException;
        exports2.InvertedLuminanceSource = InvertedLuminanceSource;
        exports2.LuminanceSource = LuminanceSource;
        exports2.MathUtils = MathUtils;
        exports2.MultiFormatOneDReader = MultiFormatOneDReader;
        exports2.MultiFormatReader = MultiFormatReader;
        exports2.MultiFormatWriter = MultiFormatWriter;
        exports2.NotFoundException = NotFoundException;
        exports2.OneDReader = OneDReader;
        exports2.PDF417DecodedBitStreamParser = DecodedBitStreamParser$2;
        exports2.PDF417DecoderErrorCorrection = ErrorCorrection;
        exports2.PDF417Reader = PDF417Reader;
        exports2.PDF417ResultMetadata = PDF417ResultMetadata;
        exports2.PerspectiveTransform = PerspectiveTransform;
        exports2.PlanarYUVLuminanceSource = PlanarYUVLuminanceSource;
        exports2.QRCodeByteMatrix = ByteMatrix;
        exports2.QRCodeDataMask = DataMask;
        exports2.QRCodeDecodedBitStreamParser = DecodedBitStreamParser$1;
        exports2.QRCodeDecoderErrorCorrectionLevel = ErrorCorrectionLevel;
        exports2.QRCodeDecoderFormatInformation = FormatInformation;
        exports2.QRCodeEncoder = Encoder;
        exports2.QRCodeEncoderQRCode = QRCode;
        exports2.QRCodeMaskUtil = MaskUtil;
        exports2.QRCodeMatrixUtil = MatrixUtil;
        exports2.QRCodeMode = Mode$1;
        exports2.QRCodeReader = QRCodeReader;
        exports2.QRCodeVersion = Version$1;
        exports2.QRCodeWriter = QRCodeWriter;
        exports2.RGBLuminanceSource = RGBLuminanceSource;
        exports2.RSS14Reader = RSS14Reader;
        exports2.RSSExpandedReader = RSSExpandedReader;
        exports2.ReaderException = ReaderException;
        exports2.ReedSolomonDecoder = ReedSolomonDecoder;
        exports2.ReedSolomonEncoder = ReedSolomonEncoder;
        exports2.ReedSolomonException = ReedSolomonException;
        exports2.Result = Result;
        exports2.ResultMetadataType = ResultMetadataType$1;
        exports2.ResultPoint = ResultPoint;
        exports2.StringUtils = StringUtils;
        exports2.UnsupportedOperationException = UnsupportedOperationException;
        exports2.VideoInputDevice = VideoInputDevice;
        exports2.WhiteRectangleDetector = WhiteRectangleDetector;
        exports2.WriterException = WriterException;
        exports2.ZXingArrays = Arrays;
        exports2.ZXingCharset = Charset;
        exports2.ZXingInteger = Integer;
        exports2.ZXingStandardCharsets = StandardCharsets;
        exports2.ZXingStringBuilder = StringBuilder;
        exports2.ZXingStringEncoding = StringEncoding;
        exports2.ZXingSystem = System;
        exports2.createAbstractExpandedDecoder = createDecoder;
        Object.defineProperty(exports2, "__esModule", { value: true });
      });
    }
  });

  // ../deps/phoenix_html/priv/static/phoenix_html.js
  "use strict";
  (function() {
    var PolyfillEvent = eventConstructor();
    function eventConstructor() {
      if (typeof window.CustomEvent === "function")
        return window.CustomEvent;
      function CustomEvent2(event, params) {
        params = params || { bubbles: false, cancelable: false, detail: void 0 };
        var evt = document.createEvent("CustomEvent");
        evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);
        return evt;
      }
      CustomEvent2.prototype = window.Event.prototype;
      return CustomEvent2;
    }
    function buildHiddenInput(name, value) {
      var input = document.createElement("input");
      input.type = "hidden";
      input.name = name;
      input.value = value;
      return input;
    }
    function handleClick(element, targetModifierKey) {
      var to = element.getAttribute("data-to"), method = buildHiddenInput("_method", element.getAttribute("data-method")), csrf = buildHiddenInput("_csrf_token", element.getAttribute("data-csrf")), form = document.createElement("form"), target = element.getAttribute("target");
      form.method = element.getAttribute("data-method") === "get" ? "get" : "post";
      form.action = to;
      form.style.display = "hidden";
      if (target)
        form.target = target;
      else if (targetModifierKey)
        form.target = "_blank";
      form.appendChild(csrf);
      form.appendChild(method);
      document.body.appendChild(form);
      form.submit();
    }
    window.addEventListener("click", function(e) {
      var element = e.target;
      if (e.defaultPrevented)
        return;
      while (element && element.getAttribute) {
        var phoenixLinkEvent = new PolyfillEvent("phoenix.link.click", {
          "bubbles": true,
          "cancelable": true
        });
        if (!element.dispatchEvent(phoenixLinkEvent)) {
          e.preventDefault();
          e.stopImmediatePropagation();
          return false;
        }
        if (element.getAttribute("data-method")) {
          handleClick(element, e.metaKey || e.shiftKey);
          e.preventDefault();
          return false;
        } else {
          element = element.parentNode;
        }
      }
    }, false);
    window.addEventListener("phoenix.link.click", function(e) {
      var message = e.target.getAttribute("data-confirm");
      if (message && !window.confirm(message)) {
        e.preventDefault();
      }
    }, false);
  })();

  // ../deps/phoenix/priv/static/phoenix.mjs
  var closure = (value) => {
    if (typeof value === "function") {
      return value;
    } else {
      let closure22 = function() {
        return value;
      };
      return closure22;
    }
  };
  var globalSelf = typeof self !== "undefined" ? self : null;
  var phxWindow = typeof window !== "undefined" ? window : null;
  var global2 = globalSelf || phxWindow || global2;
  var DEFAULT_VSN = "2.0.0";
  var SOCKET_STATES = { connecting: 0, open: 1, closing: 2, closed: 3 };
  var DEFAULT_TIMEOUT = 1e4;
  var WS_CLOSE_NORMAL = 1e3;
  var CHANNEL_STATES = {
    closed: "closed",
    errored: "errored",
    joined: "joined",
    joining: "joining",
    leaving: "leaving"
  };
  var CHANNEL_EVENTS = {
    close: "phx_close",
    error: "phx_error",
    join: "phx_join",
    reply: "phx_reply",
    leave: "phx_leave"
  };
  var TRANSPORTS = {
    longpoll: "longpoll",
    websocket: "websocket"
  };
  var XHR_STATES = {
    complete: 4
  };
  var Push = class {
    constructor(channel, event, payload, timeout) {
      this.channel = channel;
      this.event = event;
      this.payload = payload || function() {
        return {};
      };
      this.receivedResp = null;
      this.timeout = timeout;
      this.timeoutTimer = null;
      this.recHooks = [];
      this.sent = false;
    }
    resend(timeout) {
      this.timeout = timeout;
      this.reset();
      this.send();
    }
    send() {
      if (this.hasReceived("timeout")) {
        return;
      }
      this.startTimeout();
      this.sent = true;
      this.channel.socket.push({
        topic: this.channel.topic,
        event: this.event,
        payload: this.payload(),
        ref: this.ref,
        join_ref: this.channel.joinRef()
      });
    }
    receive(status, callback) {
      if (this.hasReceived(status)) {
        callback(this.receivedResp.response);
      }
      this.recHooks.push({ status, callback });
      return this;
    }
    reset() {
      this.cancelRefEvent();
      this.ref = null;
      this.refEvent = null;
      this.receivedResp = null;
      this.sent = false;
    }
    matchReceive({ status, response, _ref }) {
      this.recHooks.filter((h) => h.status === status).forEach((h) => h.callback(response));
    }
    cancelRefEvent() {
      if (!this.refEvent) {
        return;
      }
      this.channel.off(this.refEvent);
    }
    cancelTimeout() {
      clearTimeout(this.timeoutTimer);
      this.timeoutTimer = null;
    }
    startTimeout() {
      if (this.timeoutTimer) {
        this.cancelTimeout();
      }
      this.ref = this.channel.socket.makeRef();
      this.refEvent = this.channel.replyEventName(this.ref);
      this.channel.on(this.refEvent, (payload) => {
        this.cancelRefEvent();
        this.cancelTimeout();
        this.receivedResp = payload;
        this.matchReceive(payload);
      });
      this.timeoutTimer = setTimeout(() => {
        this.trigger("timeout", {});
      }, this.timeout);
    }
    hasReceived(status) {
      return this.receivedResp && this.receivedResp.status === status;
    }
    trigger(status, response) {
      this.channel.trigger(this.refEvent, { status, response });
    }
  };
  var Timer = class {
    constructor(callback, timerCalc) {
      this.callback = callback;
      this.timerCalc = timerCalc;
      this.timer = null;
      this.tries = 0;
    }
    reset() {
      this.tries = 0;
      clearTimeout(this.timer);
    }
    scheduleTimeout() {
      clearTimeout(this.timer);
      this.timer = setTimeout(() => {
        this.tries = this.tries + 1;
        this.callback();
      }, this.timerCalc(this.tries + 1));
    }
  };
  var Channel = class {
    constructor(topic, params, socket) {
      this.state = CHANNEL_STATES.closed;
      this.topic = topic;
      this.params = closure(params || {});
      this.socket = socket;
      this.bindings = [];
      this.bindingRef = 0;
      this.timeout = this.socket.timeout;
      this.joinedOnce = false;
      this.joinPush = new Push(this, CHANNEL_EVENTS.join, this.params, this.timeout);
      this.pushBuffer = [];
      this.stateChangeRefs = [];
      this.rejoinTimer = new Timer(() => {
        if (this.socket.isConnected()) {
          this.rejoin();
        }
      }, this.socket.rejoinAfterMs);
      this.stateChangeRefs.push(this.socket.onError(() => this.rejoinTimer.reset()));
      this.stateChangeRefs.push(this.socket.onOpen(() => {
        this.rejoinTimer.reset();
        if (this.isErrored()) {
          this.rejoin();
        }
      }));
      this.joinPush.receive("ok", () => {
        this.state = CHANNEL_STATES.joined;
        this.rejoinTimer.reset();
        this.pushBuffer.forEach((pushEvent) => pushEvent.send());
        this.pushBuffer = [];
      });
      this.joinPush.receive("error", () => {
        this.state = CHANNEL_STATES.errored;
        if (this.socket.isConnected()) {
          this.rejoinTimer.scheduleTimeout();
        }
      });
      this.onClose(() => {
        this.rejoinTimer.reset();
        if (this.socket.hasLogger())
          this.socket.log("channel", `close ${this.topic} ${this.joinRef()}`);
        this.state = CHANNEL_STATES.closed;
        this.socket.remove(this);
      });
      this.onError((reason) => {
        if (this.socket.hasLogger())
          this.socket.log("channel", `error ${this.topic}`, reason);
        if (this.isJoining()) {
          this.joinPush.reset();
        }
        this.state = CHANNEL_STATES.errored;
        if (this.socket.isConnected()) {
          this.rejoinTimer.scheduleTimeout();
        }
      });
      this.joinPush.receive("timeout", () => {
        if (this.socket.hasLogger())
          this.socket.log("channel", `timeout ${this.topic} (${this.joinRef()})`, this.joinPush.timeout);
        let leavePush = new Push(this, CHANNEL_EVENTS.leave, closure({}), this.timeout);
        leavePush.send();
        this.state = CHANNEL_STATES.errored;
        this.joinPush.reset();
        if (this.socket.isConnected()) {
          this.rejoinTimer.scheduleTimeout();
        }
      });
      this.on(CHANNEL_EVENTS.reply, (payload, ref) => {
        this.trigger(this.replyEventName(ref), payload);
      });
    }
    join(timeout = this.timeout) {
      if (this.joinedOnce) {
        throw new Error("tried to join multiple times. 'join' can only be called a single time per channel instance");
      } else {
        this.timeout = timeout;
        this.joinedOnce = true;
        this.rejoin();
        return this.joinPush;
      }
    }
    onClose(callback) {
      this.on(CHANNEL_EVENTS.close, callback);
    }
    onError(callback) {
      return this.on(CHANNEL_EVENTS.error, (reason) => callback(reason));
    }
    on(event, callback) {
      let ref = this.bindingRef++;
      this.bindings.push({ event, ref, callback });
      return ref;
    }
    off(event, ref) {
      this.bindings = this.bindings.filter((bind3) => {
        return !(bind3.event === event && (typeof ref === "undefined" || ref === bind3.ref));
      });
    }
    canPush() {
      return this.socket.isConnected() && this.isJoined();
    }
    push(event, payload, timeout = this.timeout) {
      payload = payload || {};
      if (!this.joinedOnce) {
        throw new Error(`tried to push '${event}' to '${this.topic}' before joining. Use channel.join() before pushing events`);
      }
      let pushEvent = new Push(this, event, function() {
        return payload;
      }, timeout);
      if (this.canPush()) {
        pushEvent.send();
      } else {
        pushEvent.startTimeout();
        this.pushBuffer.push(pushEvent);
      }
      return pushEvent;
    }
    leave(timeout = this.timeout) {
      this.rejoinTimer.reset();
      this.joinPush.cancelTimeout();
      this.state = CHANNEL_STATES.leaving;
      let onClose = () => {
        if (this.socket.hasLogger())
          this.socket.log("channel", `leave ${this.topic}`);
        this.trigger(CHANNEL_EVENTS.close, "leave");
      };
      let leavePush = new Push(this, CHANNEL_EVENTS.leave, closure({}), timeout);
      leavePush.receive("ok", () => onClose()).receive("timeout", () => onClose());
      leavePush.send();
      if (!this.canPush()) {
        leavePush.trigger("ok", {});
      }
      return leavePush;
    }
    onMessage(_event, payload, _ref) {
      return payload;
    }
    isMember(topic, event, payload, joinRef) {
      if (this.topic !== topic) {
        return false;
      }
      if (joinRef && joinRef !== this.joinRef()) {
        if (this.socket.hasLogger())
          this.socket.log("channel", "dropping outdated message", { topic, event, payload, joinRef });
        return false;
      } else {
        return true;
      }
    }
    joinRef() {
      return this.joinPush.ref;
    }
    rejoin(timeout = this.timeout) {
      if (this.isLeaving()) {
        return;
      }
      this.socket.leaveOpenTopic(this.topic);
      this.state = CHANNEL_STATES.joining;
      this.joinPush.resend(timeout);
    }
    trigger(event, payload, ref, joinRef) {
      let handledPayload = this.onMessage(event, payload, ref, joinRef);
      if (payload && !handledPayload) {
        throw new Error("channel onMessage callbacks must return the payload, modified or unmodified");
      }
      let eventBindings = this.bindings.filter((bind3) => bind3.event === event);
      for (let i = 0; i < eventBindings.length; i++) {
        let bind3 = eventBindings[i];
        bind3.callback(handledPayload, ref, joinRef || this.joinRef());
      }
    }
    replyEventName(ref) {
      return `chan_reply_${ref}`;
    }
    isClosed() {
      return this.state === CHANNEL_STATES.closed;
    }
    isErrored() {
      return this.state === CHANNEL_STATES.errored;
    }
    isJoined() {
      return this.state === CHANNEL_STATES.joined;
    }
    isJoining() {
      return this.state === CHANNEL_STATES.joining;
    }
    isLeaving() {
      return this.state === CHANNEL_STATES.leaving;
    }
  };
  var Ajax = class {
    static request(method, endPoint, accept, body, timeout, ontimeout, callback) {
      if (global2.XDomainRequest) {
        let req = new global2.XDomainRequest();
        this.xdomainRequest(req, method, endPoint, body, timeout, ontimeout, callback);
      } else {
        let req = new global2.XMLHttpRequest();
        this.xhrRequest(req, method, endPoint, accept, body, timeout, ontimeout, callback);
      }
    }
    static xdomainRequest(req, method, endPoint, body, timeout, ontimeout, callback) {
      req.timeout = timeout;
      req.open(method, endPoint);
      req.onload = () => {
        let response = this.parseJSON(req.responseText);
        callback && callback(response);
      };
      if (ontimeout) {
        req.ontimeout = ontimeout;
      }
      req.onprogress = () => {
      };
      req.send(body);
    }
    static xhrRequest(req, method, endPoint, accept, body, timeout, ontimeout, callback) {
      req.open(method, endPoint, true);
      req.timeout = timeout;
      req.setRequestHeader("Content-Type", accept);
      req.onerror = () => {
        callback && callback(null);
      };
      req.onreadystatechange = () => {
        if (req.readyState === XHR_STATES.complete && callback) {
          let response = this.parseJSON(req.responseText);
          callback(response);
        }
      };
      if (ontimeout) {
        req.ontimeout = ontimeout;
      }
      req.send(body);
    }
    static parseJSON(resp) {
      if (!resp || resp === "") {
        return null;
      }
      try {
        return JSON.parse(resp);
      } catch (e) {
        console && console.log("failed to parse JSON response", resp);
        return null;
      }
    }
    static serialize(obj, parentKey) {
      let queryStr = [];
      for (var key in obj) {
        if (!Object.prototype.hasOwnProperty.call(obj, key)) {
          continue;
        }
        let paramKey = parentKey ? `${parentKey}[${key}]` : key;
        let paramVal = obj[key];
        if (typeof paramVal === "object") {
          queryStr.push(this.serialize(paramVal, paramKey));
        } else {
          queryStr.push(encodeURIComponent(paramKey) + "=" + encodeURIComponent(paramVal));
        }
      }
      return queryStr.join("&");
    }
    static appendParams(url, params) {
      if (Object.keys(params).length === 0) {
        return url;
      }
      let prefix2 = url.match(/\?/) ? "&" : "?";
      return `${url}${prefix2}${this.serialize(params)}`;
    }
  };
  var LongPoll = class {
    constructor(endPoint) {
      this.endPoint = null;
      this.token = null;
      this.skipHeartbeat = true;
      this.onopen = function() {
      };
      this.onerror = function() {
      };
      this.onmessage = function() {
      };
      this.onclose = function() {
      };
      this.pollEndpoint = this.normalizeEndpoint(endPoint);
      this.readyState = SOCKET_STATES.connecting;
      this.poll();
    }
    normalizeEndpoint(endPoint) {
      return endPoint.replace("ws://", "http://").replace("wss://", "https://").replace(new RegExp("(.*)/" + TRANSPORTS.websocket), "$1/" + TRANSPORTS.longpoll);
    }
    endpointURL() {
      return Ajax.appendParams(this.pollEndpoint, { token: this.token });
    }
    closeAndRetry(code, reason, wasClean) {
      this.close(code, reason, wasClean);
      this.readyState = SOCKET_STATES.connecting;
    }
    ontimeout() {
      this.onerror("timeout");
      this.closeAndRetry(1005, "timeout", false);
    }
    poll() {
      if (!(this.readyState === SOCKET_STATES.open || this.readyState === SOCKET_STATES.connecting)) {
        return;
      }
      Ajax.request("GET", this.endpointURL(), "application/json", null, this.timeout, this.ontimeout.bind(this), (resp) => {
        if (resp) {
          var { status, token, messages } = resp;
          this.token = token;
        } else {
          status = 0;
        }
        switch (status) {
          case 200:
            messages.forEach((msg) => {
              setTimeout(() => {
                this.onmessage({ data: msg });
              }, 0);
            });
            this.poll();
            break;
          case 204:
            this.poll();
            break;
          case 410:
            this.readyState = SOCKET_STATES.open;
            this.onopen({});
            this.poll();
            break;
          case 403:
            this.onerror(403);
            this.close(1008, "forbidden", false);
            break;
          case 0:
          case 500:
            this.onerror(500);
            this.closeAndRetry(1011, "internal server error", 500);
            break;
          default:
            throw new Error(`unhandled poll status ${status}`);
        }
      });
    }
    send(body) {
      Ajax.request("POST", this.endpointURL(), "application/json", body, this.timeout, this.onerror.bind(this, "timeout"), (resp) => {
        if (!resp || resp.status !== 200) {
          this.onerror(resp && resp.status);
          this.closeAndRetry(1011, "internal server error", false);
        }
      });
    }
    close(code, reason, wasClean) {
      this.readyState = SOCKET_STATES.closed;
      let opts = Object.assign({ code: 1e3, reason: void 0, wasClean: true }, { code, reason, wasClean });
      if (typeof CloseEvent !== "undefined") {
        this.onclose(new CloseEvent("close", opts));
      } else {
        this.onclose(opts);
      }
    }
  };
  var serializer_default = {
    HEADER_LENGTH: 1,
    META_LENGTH: 4,
    KINDS: { push: 0, reply: 1, broadcast: 2 },
    encode(msg, callback) {
      if (msg.payload.constructor === ArrayBuffer) {
        return callback(this.binaryEncode(msg));
      } else {
        let payload = [msg.join_ref, msg.ref, msg.topic, msg.event, msg.payload];
        return callback(JSON.stringify(payload));
      }
    },
    decode(rawPayload, callback) {
      if (rawPayload.constructor === ArrayBuffer) {
        return callback(this.binaryDecode(rawPayload));
      } else {
        let [join_ref, ref, topic, event, payload] = JSON.parse(rawPayload);
        return callback({ join_ref, ref, topic, event, payload });
      }
    },
    binaryEncode(message) {
      let { join_ref, ref, event, topic, payload } = message;
      let metaLength = this.META_LENGTH + join_ref.length + ref.length + topic.length + event.length;
      let header = new ArrayBuffer(this.HEADER_LENGTH + metaLength);
      let view = new DataView(header);
      let offset = 0;
      view.setUint8(offset++, this.KINDS.push);
      view.setUint8(offset++, join_ref.length);
      view.setUint8(offset++, ref.length);
      view.setUint8(offset++, topic.length);
      view.setUint8(offset++, event.length);
      Array.from(join_ref, (char) => view.setUint8(offset++, char.charCodeAt(0)));
      Array.from(ref, (char) => view.setUint8(offset++, char.charCodeAt(0)));
      Array.from(topic, (char) => view.setUint8(offset++, char.charCodeAt(0)));
      Array.from(event, (char) => view.setUint8(offset++, char.charCodeAt(0)));
      var combined = new Uint8Array(header.byteLength + payload.byteLength);
      combined.set(new Uint8Array(header), 0);
      combined.set(new Uint8Array(payload), header.byteLength);
      return combined.buffer;
    },
    binaryDecode(buffer) {
      let view = new DataView(buffer);
      let kind = view.getUint8(0);
      let decoder = new TextDecoder();
      switch (kind) {
        case this.KINDS.push:
          return this.decodePush(buffer, view, decoder);
        case this.KINDS.reply:
          return this.decodeReply(buffer, view, decoder);
        case this.KINDS.broadcast:
          return this.decodeBroadcast(buffer, view, decoder);
      }
    },
    decodePush(buffer, view, decoder) {
      let joinRefSize = view.getUint8(1);
      let topicSize = view.getUint8(2);
      let eventSize = view.getUint8(3);
      let offset = this.HEADER_LENGTH + this.META_LENGTH - 1;
      let joinRef = decoder.decode(buffer.slice(offset, offset + joinRefSize));
      offset = offset + joinRefSize;
      let topic = decoder.decode(buffer.slice(offset, offset + topicSize));
      offset = offset + topicSize;
      let event = decoder.decode(buffer.slice(offset, offset + eventSize));
      offset = offset + eventSize;
      let data2 = buffer.slice(offset, buffer.byteLength);
      return { join_ref: joinRef, ref: null, topic, event, payload: data2 };
    },
    decodeReply(buffer, view, decoder) {
      let joinRefSize = view.getUint8(1);
      let refSize = view.getUint8(2);
      let topicSize = view.getUint8(3);
      let eventSize = view.getUint8(4);
      let offset = this.HEADER_LENGTH + this.META_LENGTH;
      let joinRef = decoder.decode(buffer.slice(offset, offset + joinRefSize));
      offset = offset + joinRefSize;
      let ref = decoder.decode(buffer.slice(offset, offset + refSize));
      offset = offset + refSize;
      let topic = decoder.decode(buffer.slice(offset, offset + topicSize));
      offset = offset + topicSize;
      let event = decoder.decode(buffer.slice(offset, offset + eventSize));
      offset = offset + eventSize;
      let data2 = buffer.slice(offset, buffer.byteLength);
      let payload = { status: event, response: data2 };
      return { join_ref: joinRef, ref, topic, event: CHANNEL_EVENTS.reply, payload };
    },
    decodeBroadcast(buffer, view, decoder) {
      let topicSize = view.getUint8(1);
      let eventSize = view.getUint8(2);
      let offset = this.HEADER_LENGTH + 2;
      let topic = decoder.decode(buffer.slice(offset, offset + topicSize));
      offset = offset + topicSize;
      let event = decoder.decode(buffer.slice(offset, offset + eventSize));
      offset = offset + eventSize;
      let data2 = buffer.slice(offset, buffer.byteLength);
      return { join_ref: null, ref: null, topic, event, payload: data2 };
    }
  };
  var Socket = class {
    constructor(endPoint, opts = {}) {
      this.stateChangeCallbacks = { open: [], close: [], error: [], message: [] };
      this.channels = [];
      this.sendBuffer = [];
      this.ref = 0;
      this.timeout = opts.timeout || DEFAULT_TIMEOUT;
      this.transport = opts.transport || global2.WebSocket || LongPoll;
      this.establishedConnections = 0;
      this.defaultEncoder = serializer_default.encode.bind(serializer_default);
      this.defaultDecoder = serializer_default.decode.bind(serializer_default);
      this.closeWasClean = false;
      this.binaryType = opts.binaryType || "arraybuffer";
      this.connectClock = 1;
      if (this.transport !== LongPoll) {
        this.encode = opts.encode || this.defaultEncoder;
        this.decode = opts.decode || this.defaultDecoder;
      } else {
        this.encode = this.defaultEncoder;
        this.decode = this.defaultDecoder;
      }
      let awaitingConnectionOnPageShow = null;
      if (phxWindow && phxWindow.addEventListener) {
        phxWindow.addEventListener("pagehide", (_e) => {
          if (this.conn) {
            this.disconnect();
            awaitingConnectionOnPageShow = this.connectClock;
          }
        });
        phxWindow.addEventListener("pageshow", (_e) => {
          if (awaitingConnectionOnPageShow === this.connectClock) {
            awaitingConnectionOnPageShow = null;
            this.connect();
          }
        });
      }
      this.heartbeatIntervalMs = opts.heartbeatIntervalMs || 3e4;
      this.rejoinAfterMs = (tries) => {
        if (opts.rejoinAfterMs) {
          return opts.rejoinAfterMs(tries);
        } else {
          return [1e3, 2e3, 5e3][tries - 1] || 1e4;
        }
      };
      this.reconnectAfterMs = (tries) => {
        if (opts.reconnectAfterMs) {
          return opts.reconnectAfterMs(tries);
        } else {
          return [10, 50, 100, 150, 200, 250, 500, 1e3, 2e3][tries - 1] || 5e3;
        }
      };
      this.logger = opts.logger || null;
      this.longpollerTimeout = opts.longpollerTimeout || 2e4;
      this.params = closure(opts.params || {});
      this.endPoint = `${endPoint}/${TRANSPORTS.websocket}`;
      this.vsn = opts.vsn || DEFAULT_VSN;
      this.heartbeatTimer = null;
      this.pendingHeartbeatRef = null;
      this.reconnectTimer = new Timer(() => {
        this.teardown(() => this.connect());
      }, this.reconnectAfterMs);
    }
    replaceTransport(newTransport) {
      this.disconnect();
      this.transport = newTransport;
    }
    protocol() {
      return location.protocol.match(/^https/) ? "wss" : "ws";
    }
    endPointURL() {
      let uri = Ajax.appendParams(Ajax.appendParams(this.endPoint, this.params()), { vsn: this.vsn });
      if (uri.charAt(0) !== "/") {
        return uri;
      }
      if (uri.charAt(1) === "/") {
        return `${this.protocol()}:${uri}`;
      }
      return `${this.protocol()}://${location.host}${uri}`;
    }
    disconnect(callback, code, reason) {
      this.connectClock++;
      this.closeWasClean = true;
      this.reconnectTimer.reset();
      this.teardown(callback, code, reason);
    }
    connect(params) {
      this.connectClock++;
      if (params) {
        console && console.log("passing params to connect is deprecated. Instead pass :params to the Socket constructor");
        this.params = closure(params);
      }
      if (this.conn) {
        return;
      }
      this.closeWasClean = false;
      this.conn = new this.transport(this.endPointURL());
      this.conn.binaryType = this.binaryType;
      this.conn.timeout = this.longpollerTimeout;
      this.conn.onopen = () => this.onConnOpen();
      this.conn.onerror = (error2) => this.onConnError(error2);
      this.conn.onmessage = (event) => this.onConnMessage(event);
      this.conn.onclose = (event) => this.onConnClose(event);
    }
    log(kind, msg, data2) {
      this.logger(kind, msg, data2);
    }
    hasLogger() {
      return this.logger !== null;
    }
    onOpen(callback) {
      let ref = this.makeRef();
      this.stateChangeCallbacks.open.push([ref, callback]);
      return ref;
    }
    onClose(callback) {
      let ref = this.makeRef();
      this.stateChangeCallbacks.close.push([ref, callback]);
      return ref;
    }
    onError(callback) {
      let ref = this.makeRef();
      this.stateChangeCallbacks.error.push([ref, callback]);
      return ref;
    }
    onMessage(callback) {
      let ref = this.makeRef();
      this.stateChangeCallbacks.message.push([ref, callback]);
      return ref;
    }
    onConnOpen() {
      if (this.hasLogger())
        this.log("transport", `connected to ${this.endPointURL()}`);
      this.closeWasClean = false;
      this.establishedConnections++;
      this.flushSendBuffer();
      this.reconnectTimer.reset();
      this.resetHeartbeat();
      this.stateChangeCallbacks.open.forEach(([, callback]) => callback());
    }
    heartbeatTimeout() {
      if (this.pendingHeartbeatRef) {
        this.pendingHeartbeatRef = null;
        if (this.hasLogger()) {
          this.log("transport", "heartbeat timeout. Attempting to re-establish connection");
        }
        this.abnormalClose("heartbeat timeout");
      }
    }
    resetHeartbeat() {
      if (this.conn && this.conn.skipHeartbeat) {
        return;
      }
      this.pendingHeartbeatRef = null;
      clearTimeout(this.heartbeatTimer);
      setTimeout(() => this.sendHeartbeat(), this.heartbeatIntervalMs);
    }
    teardown(callback, code, reason) {
      if (!this.conn) {
        return callback && callback();
      }
      this.waitForBufferDone(() => {
        if (this.conn) {
          if (code) {
            this.conn.close(code, reason || "");
          } else {
            this.conn.close();
          }
        }
        this.waitForSocketClosed(() => {
          if (this.conn) {
            this.conn.onclose = function() {
            };
            this.conn = null;
          }
          callback && callback();
        });
      });
    }
    waitForBufferDone(callback, tries = 1) {
      if (tries === 5 || !this.conn || !this.conn.bufferedAmount) {
        callback();
        return;
      }
      setTimeout(() => {
        this.waitForBufferDone(callback, tries + 1);
      }, 150 * tries);
    }
    waitForSocketClosed(callback, tries = 1) {
      if (tries === 5 || !this.conn || this.conn.readyState === SOCKET_STATES.closed) {
        callback();
        return;
      }
      setTimeout(() => {
        this.waitForSocketClosed(callback, tries + 1);
      }, 150 * tries);
    }
    onConnClose(event) {
      let closeCode = event && event.code;
      if (this.hasLogger())
        this.log("transport", "close", event);
      this.triggerChanError();
      clearTimeout(this.heartbeatTimer);
      if (!this.closeWasClean && closeCode !== 1e3) {
        this.reconnectTimer.scheduleTimeout();
      }
      this.stateChangeCallbacks.close.forEach(([, callback]) => callback(event));
    }
    onConnError(error2) {
      if (this.hasLogger())
        this.log("transport", error2);
      let transportBefore = this.transport;
      let establishedBefore = this.establishedConnections;
      this.stateChangeCallbacks.error.forEach(([, callback]) => {
        callback(error2, transportBefore, establishedBefore);
      });
      if (transportBefore === this.transport || establishedBefore > 0) {
        this.triggerChanError();
      }
    }
    triggerChanError() {
      this.channels.forEach((channel) => {
        if (!(channel.isErrored() || channel.isLeaving() || channel.isClosed())) {
          channel.trigger(CHANNEL_EVENTS.error);
        }
      });
    }
    connectionState() {
      switch (this.conn && this.conn.readyState) {
        case SOCKET_STATES.connecting:
          return "connecting";
        case SOCKET_STATES.open:
          return "open";
        case SOCKET_STATES.closing:
          return "closing";
        default:
          return "closed";
      }
    }
    isConnected() {
      return this.connectionState() === "open";
    }
    remove(channel) {
      this.off(channel.stateChangeRefs);
      this.channels = this.channels.filter((c) => c.joinRef() !== channel.joinRef());
    }
    off(refs) {
      for (let key in this.stateChangeCallbacks) {
        this.stateChangeCallbacks[key] = this.stateChangeCallbacks[key].filter(([ref]) => {
          return refs.indexOf(ref) === -1;
        });
      }
    }
    channel(topic, chanParams = {}) {
      let chan = new Channel(topic, chanParams, this);
      this.channels.push(chan);
      return chan;
    }
    push(data2) {
      if (this.hasLogger()) {
        let { topic, event, payload, ref, join_ref } = data2;
        this.log("push", `${topic} ${event} (${join_ref}, ${ref})`, payload);
      }
      if (this.isConnected()) {
        this.encode(data2, (result) => this.conn.send(result));
      } else {
        this.sendBuffer.push(() => this.encode(data2, (result) => this.conn.send(result)));
      }
    }
    makeRef() {
      let newRef = this.ref + 1;
      if (newRef === this.ref) {
        this.ref = 0;
      } else {
        this.ref = newRef;
      }
      return this.ref.toString();
    }
    sendHeartbeat() {
      if (this.pendingHeartbeatRef && !this.isConnected()) {
        return;
      }
      this.pendingHeartbeatRef = this.makeRef();
      this.push({ topic: "phoenix", event: "heartbeat", payload: {}, ref: this.pendingHeartbeatRef });
      this.heartbeatTimer = setTimeout(() => this.heartbeatTimeout(), this.heartbeatIntervalMs);
    }
    abnormalClose(reason) {
      this.closeWasClean = false;
      if (this.isConnected()) {
        this.conn.close(WS_CLOSE_NORMAL, reason);
      }
    }
    flushSendBuffer() {
      if (this.isConnected() && this.sendBuffer.length > 0) {
        this.sendBuffer.forEach((callback) => callback());
        this.sendBuffer = [];
      }
    }
    onConnMessage(rawMessage) {
      this.decode(rawMessage.data, (msg) => {
        let { topic, event, payload, ref, join_ref } = msg;
        if (ref && ref === this.pendingHeartbeatRef) {
          clearTimeout(this.heartbeatTimer);
          this.pendingHeartbeatRef = null;
          setTimeout(() => this.sendHeartbeat(), this.heartbeatIntervalMs);
        }
        if (this.hasLogger())
          this.log("receive", `${payload.status || ""} ${topic} ${event} ${ref && "(" + ref + ")" || ""}`, payload);
        for (let i = 0; i < this.channels.length; i++) {
          const channel = this.channels[i];
          if (!channel.isMember(topic, event, payload, join_ref)) {
            continue;
          }
          channel.trigger(event, payload, ref, join_ref);
        }
        for (let i = 0; i < this.stateChangeCallbacks.message.length; i++) {
          let [, callback] = this.stateChangeCallbacks.message[i];
          callback(msg);
        }
      });
    }
    leaveOpenTopic(topic) {
      let dupChannel = this.channels.find((c) => c.topic === topic && (c.isJoined() || c.isJoining()));
      if (dupChannel) {
        if (this.hasLogger())
          this.log("transport", `leaving duplicate topic "${topic}"`);
        dupChannel.leave();
      }
    }
  };

  // ../deps/phoenix_live_view/priv/static/phoenix_live_view.esm.js
  var CONSECUTIVE_RELOADS = "consecutive-reloads";
  var MAX_RELOADS = 10;
  var RELOAD_JITTER_MIN = 1e3;
  var RELOAD_JITTER_MAX = 3e3;
  var FAILSAFE_JITTER = 3e4;
  var PHX_EVENT_CLASSES = [
    "phx-click-loading",
    "phx-change-loading",
    "phx-submit-loading",
    "phx-keydown-loading",
    "phx-keyup-loading",
    "phx-blur-loading",
    "phx-focus-loading"
  ];
  var PHX_COMPONENT = "data-phx-component";
  var PHX_LIVE_LINK = "data-phx-link";
  var PHX_TRACK_STATIC = "track-static";
  var PHX_LINK_STATE = "data-phx-link-state";
  var PHX_REF = "data-phx-ref";
  var PHX_REF_SRC = "data-phx-ref-src";
  var PHX_TRACK_UPLOADS = "track-uploads";
  var PHX_UPLOAD_REF = "data-phx-upload-ref";
  var PHX_PREFLIGHTED_REFS = "data-phx-preflighted-refs";
  var PHX_DONE_REFS = "data-phx-done-refs";
  var PHX_DROP_TARGET = "drop-target";
  var PHX_ACTIVE_ENTRY_REFS = "data-phx-active-refs";
  var PHX_LIVE_FILE_UPDATED = "phx:live-file:updated";
  var PHX_SKIP = "data-phx-skip";
  var PHX_PRUNE = "data-phx-prune";
  var PHX_PAGE_LOADING = "page-loading";
  var PHX_CONNECTED_CLASS = "phx-connected";
  var PHX_DISCONNECTED_CLASS = "phx-loading";
  var PHX_NO_FEEDBACK_CLASS = "phx-no-feedback";
  var PHX_ERROR_CLASS = "phx-error";
  var PHX_PARENT_ID = "data-phx-parent-id";
  var PHX_MAIN = "data-phx-main";
  var PHX_ROOT_ID = "data-phx-root-id";
  var PHX_TRIGGER_ACTION = "trigger-action";
  var PHX_FEEDBACK_FOR = "feedback-for";
  var PHX_HAS_FOCUSED = "phx-has-focused";
  var FOCUSABLE_INPUTS = ["text", "textarea", "number", "email", "password", "search", "tel", "url", "date", "time", "datetime-local", "color", "range"];
  var CHECKABLE_INPUTS = ["checkbox", "radio"];
  var PHX_HAS_SUBMITTED = "phx-has-submitted";
  var PHX_SESSION = "data-phx-session";
  var PHX_VIEW_SELECTOR = `[${PHX_SESSION}]`;
  var PHX_STICKY = "data-phx-sticky";
  var PHX_STATIC = "data-phx-static";
  var PHX_READONLY = "data-phx-readonly";
  var PHX_DISABLED = "data-phx-disabled";
  var PHX_DISABLE_WITH = "disable-with";
  var PHX_DISABLE_WITH_RESTORE = "data-phx-disable-with-restore";
  var PHX_HOOK = "hook";
  var PHX_DEBOUNCE = "debounce";
  var PHX_THROTTLE = "throttle";
  var PHX_UPDATE = "update";
  var PHX_KEY = "key";
  var PHX_PRIVATE = "phxPrivate";
  var PHX_AUTO_RECOVER = "auto-recover";
  var PHX_LV_DEBUG = "phx:live-socket:debug";
  var PHX_LV_PROFILE = "phx:live-socket:profiling";
  var PHX_LV_LATENCY_SIM = "phx:live-socket:latency-sim";
  var PHX_PROGRESS = "progress";
  var LOADER_TIMEOUT = 1;
  var BEFORE_UNLOAD_LOADER_TIMEOUT = 200;
  var BINDING_PREFIX = "phx-";
  var PUSH_TIMEOUT = 3e4;
  var DEBOUNCE_TRIGGER = "debounce-trigger";
  var THROTTLED = "throttled";
  var DEBOUNCE_PREV_KEY = "debounce-prev-key";
  var DEFAULTS = {
    debounce: 300,
    throttle: 300
  };
  var DYNAMICS = "d";
  var STATIC = "s";
  var COMPONENTS = "c";
  var EVENTS = "e";
  var REPLY = "r";
  var TITLE = "t";
  var TEMPLATES = "p";
  var EntryUploader = class {
    constructor(entry, chunkSize, liveSocket2) {
      this.liveSocket = liveSocket2;
      this.entry = entry;
      this.offset = 0;
      this.chunkSize = chunkSize;
      this.chunkTimer = null;
      this.uploadChannel = liveSocket2.channel(`lvu:${entry.ref}`, { token: entry.metadata() });
    }
    error(reason) {
      clearTimeout(this.chunkTimer);
      this.uploadChannel.leave();
      this.entry.error(reason);
    }
    upload() {
      this.uploadChannel.onError((reason) => this.error(reason));
      this.uploadChannel.join().receive("ok", (_data) => this.readNextChunk()).receive("error", (reason) => this.error(reason));
    }
    isDone() {
      return this.offset >= this.entry.file.size;
    }
    readNextChunk() {
      let reader = new window.FileReader();
      let blob = this.entry.file.slice(this.offset, this.chunkSize + this.offset);
      reader.onload = (e) => {
        if (e.target.error === null) {
          this.offset += e.target.result.byteLength;
          this.pushChunk(e.target.result);
        } else {
          return logError("Read error: " + e.target.error);
        }
      };
      reader.readAsArrayBuffer(blob);
    }
    pushChunk(chunk) {
      if (!this.uploadChannel.isJoined()) {
        return;
      }
      this.uploadChannel.push("chunk", chunk).receive("ok", () => {
        this.entry.progress(this.offset / this.entry.file.size * 100);
        if (!this.isDone()) {
          this.chunkTimer = setTimeout(() => this.readNextChunk(), this.liveSocket.getLatencySim() || 0);
        }
      });
    }
  };
  var logError = (msg, obj) => console.error && console.error(msg, obj);
  var isCid = (cid) => {
    let type = typeof cid;
    return type === "number" || type === "string" && /^(0|[1-9]\d*)$/.test(cid);
  };
  function detectDuplicateIds() {
    let ids = /* @__PURE__ */ new Set();
    let elems = document.querySelectorAll("*[id]");
    for (let i = 0, len = elems.length; i < len; i++) {
      if (ids.has(elems[i].id)) {
        console.error(`Multiple IDs detected: ${elems[i].id}. Ensure unique element ids.`);
      } else {
        ids.add(elems[i].id);
      }
    }
  }
  var debug = (view, kind, msg, obj) => {
    if (view.liveSocket.isDebugEnabled()) {
      console.log(`${view.id} ${kind}: ${msg} - `, obj);
    }
  };
  var closure2 = (val) => typeof val === "function" ? val : function() {
    return val;
  };
  var clone = (obj) => {
    return JSON.parse(JSON.stringify(obj));
  };
  var closestPhxBinding = (el, binding, borderEl) => {
    do {
      if (el.matches(`[${binding}]`)) {
        return el;
      }
      el = el.parentElement || el.parentNode;
    } while (el !== null && el.nodeType === 1 && !(borderEl && borderEl.isSameNode(el) || el.matches(PHX_VIEW_SELECTOR)));
    return null;
  };
  var isObject = (obj) => {
    return obj !== null && typeof obj === "object" && !(obj instanceof Array);
  };
  var isEqualObj = (obj1, obj2) => JSON.stringify(obj1) === JSON.stringify(obj2);
  var isEmpty = (obj) => {
    for (let x in obj) {
      return false;
    }
    return true;
  };
  var maybe = (el, callback) => el && callback(el);
  var channelUploader = function(entries, onError, resp, liveSocket2) {
    entries.forEach((entry) => {
      let entryUploader = new EntryUploader(entry, resp.config.chunk_size, liveSocket2);
      entryUploader.upload();
    });
  };
  var Browser = {
    canPushState() {
      return typeof history.pushState !== "undefined";
    },
    dropLocal(localStorage2, namespace, subkey) {
      return localStorage2.removeItem(this.localKey(namespace, subkey));
    },
    updateLocal(localStorage2, namespace, subkey, initial, func) {
      let current = this.getLocal(localStorage2, namespace, subkey);
      let key = this.localKey(namespace, subkey);
      let newVal = current === null ? initial : func(current);
      localStorage2.setItem(key, JSON.stringify(newVal));
      return newVal;
    },
    getLocal(localStorage2, namespace, subkey) {
      return JSON.parse(localStorage2.getItem(this.localKey(namespace, subkey)));
    },
    updateCurrentState(callback) {
      if (!this.canPushState()) {
        return;
      }
      history.replaceState(callback(history.state || {}), "", window.location.href);
    },
    pushState(kind, meta, to) {
      if (this.canPushState()) {
        if (to !== window.location.href) {
          if (meta.type == "redirect" && meta.scroll) {
            let currentState = history.state || {};
            currentState.scroll = meta.scroll;
            history.replaceState(currentState, "", window.location.href);
          }
          delete meta.scroll;
          history[kind + "State"](meta, "", to || null);
          let hashEl = this.getHashTargetEl(window.location.hash);
          if (hashEl) {
            hashEl.scrollIntoView();
          } else if (meta.type === "redirect") {
            window.scroll(0, 0);
          }
        }
      } else {
        this.redirect(to);
      }
    },
    setCookie(name, value) {
      document.cookie = `${name}=${value}`;
    },
    getCookie(name) {
      return document.cookie.replace(new RegExp(`(?:(?:^|.*;s*)${name}s*=s*([^;]*).*$)|^.*$`), "$1");
    },
    redirect(toURL, flash) {
      if (flash) {
        Browser.setCookie("__phoenix_flash__", flash + "; max-age=60000; path=/");
      }
      window.location = toURL;
    },
    localKey(namespace, subkey) {
      return `${namespace}-${subkey}`;
    },
    getHashTargetEl(maybeHash) {
      let hash = maybeHash.toString().substring(1);
      if (hash === "") {
        return;
      }
      return document.getElementById(hash) || document.querySelector(`a[name="${hash}"]`);
    }
  };
  var browser_default = Browser;
  var DOM = {
    byId(id) {
      return document.getElementById(id) || logError(`no id found for ${id}`);
    },
    removeClass(el, className) {
      el.classList.remove(className);
      if (el.classList.length === 0) {
        el.removeAttribute("class");
      }
    },
    all(node, query, callback) {
      if (!node) {
        return [];
      }
      let array = Array.from(node.querySelectorAll(query));
      return callback ? array.forEach(callback) : array;
    },
    childNodeLength(html) {
      let template = document.createElement("template");
      template.innerHTML = html;
      return template.content.childElementCount;
    },
    isUploadInput(el) {
      return el.type === "file" && el.getAttribute(PHX_UPLOAD_REF) !== null;
    },
    findUploadInputs(node) {
      return this.all(node, `input[type="file"][${PHX_UPLOAD_REF}]`);
    },
    findComponentNodeList(node, cid) {
      return this.filterWithinSameLiveView(this.all(node, `[${PHX_COMPONENT}="${cid}"]`), node);
    },
    isPhxDestroyed(node) {
      return node.id && DOM.private(node, "destroyed") ? true : false;
    },
    markPhxChildDestroyed(el) {
      if (this.isPhxChild(el)) {
        el.setAttribute(PHX_SESSION, "");
      }
      this.putPrivate(el, "destroyed", true);
    },
    findPhxChildrenInFragment(html, parentId) {
      let template = document.createElement("template");
      template.innerHTML = html;
      return this.findPhxChildren(template.content, parentId);
    },
    isIgnored(el, phxUpdate) {
      return (el.getAttribute(phxUpdate) || el.getAttribute("data-phx-update")) === "ignore";
    },
    isPhxUpdate(el, phxUpdate, updateTypes) {
      return el.getAttribute && updateTypes.indexOf(el.getAttribute(phxUpdate)) >= 0;
    },
    findPhxSticky(el) {
      return this.all(el, `[${PHX_STICKY}]`);
    },
    findPhxChildren(el, parentId) {
      return this.all(el, `${PHX_VIEW_SELECTOR}[${PHX_PARENT_ID}="${parentId}"]`);
    },
    findParentCIDs(node, cids) {
      let initial = new Set(cids);
      return cids.reduce((acc, cid) => {
        let selector = `[${PHX_COMPONENT}="${cid}"] [${PHX_COMPONENT}]`;
        this.filterWithinSameLiveView(this.all(node, selector), node).map((el) => parseInt(el.getAttribute(PHX_COMPONENT))).forEach((childCID) => acc.delete(childCID));
        return acc;
      }, initial);
    },
    filterWithinSameLiveView(nodes, parent) {
      if (parent.querySelector(PHX_VIEW_SELECTOR)) {
        return nodes.filter((el) => this.withinSameLiveView(el, parent));
      } else {
        return nodes;
      }
    },
    withinSameLiveView(node, parent) {
      while (node = node.parentNode) {
        if (node.isSameNode(parent)) {
          return true;
        }
        if (node.getAttribute(PHX_SESSION) !== null) {
          return false;
        }
      }
    },
    private(el, key) {
      return el[PHX_PRIVATE] && el[PHX_PRIVATE][key];
    },
    deletePrivate(el, key) {
      el[PHX_PRIVATE] && delete el[PHX_PRIVATE][key];
    },
    putPrivate(el, key, value) {
      if (!el[PHX_PRIVATE]) {
        el[PHX_PRIVATE] = {};
      }
      el[PHX_PRIVATE][key] = value;
    },
    updatePrivate(el, key, defaultVal, updateFunc) {
      let existing = this.private(el, key);
      if (existing === void 0) {
        this.putPrivate(el, key, updateFunc(defaultVal));
      } else {
        this.putPrivate(el, key, updateFunc(existing));
      }
    },
    copyPrivates(target, source) {
      if (source[PHX_PRIVATE]) {
        target[PHX_PRIVATE] = source[PHX_PRIVATE];
      }
    },
    putTitle(str) {
      let titleEl = document.querySelector("title");
      let { prefix: prefix2, suffix } = titleEl.dataset;
      document.title = `${prefix2 || ""}${str}${suffix || ""}`;
    },
    debounce(el, event, phxDebounce, defaultDebounce, phxThrottle, defaultThrottle, callback) {
      let debounce2 = el.getAttribute(phxDebounce);
      let throttle2 = el.getAttribute(phxThrottle);
      if (debounce2 === "") {
        debounce2 = defaultDebounce;
      }
      if (throttle2 === "") {
        throttle2 = defaultThrottle;
      }
      let value = debounce2 || throttle2;
      switch (value) {
        case null:
          return callback();
        case "blur":
          if (this.once(el, "debounce-blur")) {
            el.addEventListener("blur", () => callback());
          }
          return;
        default:
          let timeout = parseInt(value);
          let trigger2 = () => throttle2 ? this.deletePrivate(el, THROTTLED) : callback();
          let currentCycle = this.incCycle(el, DEBOUNCE_TRIGGER, trigger2);
          if (isNaN(timeout)) {
            return logError(`invalid throttle/debounce value: ${value}`);
          }
          if (throttle2) {
            let newKeyDown = false;
            if (event.type === "keydown") {
              let prevKey = this.private(el, DEBOUNCE_PREV_KEY);
              this.putPrivate(el, DEBOUNCE_PREV_KEY, event.key);
              newKeyDown = prevKey !== event.key;
            }
            if (!newKeyDown && this.private(el, THROTTLED)) {
              return false;
            } else {
              callback();
              this.putPrivate(el, THROTTLED, true);
              setTimeout(() => this.triggerCycle(el, DEBOUNCE_TRIGGER), timeout);
            }
          } else {
            setTimeout(() => this.triggerCycle(el, DEBOUNCE_TRIGGER, currentCycle), timeout);
          }
          let form = el.form;
          if (form && this.once(form, "bind-debounce")) {
            form.addEventListener("submit", () => {
              Array.from(new FormData(form).entries(), ([name]) => {
                let input = form.querySelector(`[name="${name}"]`);
                this.incCycle(input, DEBOUNCE_TRIGGER);
                this.deletePrivate(input, THROTTLED);
              });
            });
          }
          if (this.once(el, "bind-debounce")) {
            el.addEventListener("blur", () => this.triggerCycle(el, DEBOUNCE_TRIGGER));
          }
      }
    },
    triggerCycle(el, key, currentCycle) {
      let [cycle, trigger2] = this.private(el, key);
      if (!currentCycle) {
        currentCycle = cycle;
      }
      if (currentCycle === cycle) {
        this.incCycle(el, key);
        trigger2();
      }
    },
    once(el, key) {
      if (this.private(el, key) === true) {
        return false;
      }
      this.putPrivate(el, key, true);
      return true;
    },
    incCycle(el, key, trigger2 = function() {
    }) {
      let [currentCycle] = this.private(el, key) || [0, trigger2];
      currentCycle++;
      this.putPrivate(el, key, [currentCycle, trigger2]);
      return currentCycle;
    },
    discardError(container, el, phxFeedbackFor) {
      let field = el.getAttribute && el.getAttribute(phxFeedbackFor);
      let input = field && container.querySelector(`[id="${field}"], [name="${field}"]`);
      if (!input) {
        return;
      }
      if (!(this.private(input, PHX_HAS_FOCUSED) || this.private(input.form, PHX_HAS_SUBMITTED))) {
        el.classList.add(PHX_NO_FEEDBACK_CLASS);
      }
    },
    showError(inputEl, phxFeedbackFor) {
      if (inputEl.id || inputEl.name) {
        this.all(inputEl.form, `[${phxFeedbackFor}="${inputEl.id}"], [${phxFeedbackFor}="${inputEl.name}"]`, (el) => {
          this.removeClass(el, PHX_NO_FEEDBACK_CLASS);
        });
      }
    },
    isPhxChild(node) {
      return node.getAttribute && node.getAttribute(PHX_PARENT_ID);
    },
    isPhxSticky(node) {
      return node.getAttribute && node.getAttribute(PHX_STICKY) !== null;
    },
    firstPhxChild(el) {
      return this.isPhxChild(el) ? el : this.all(el, `[${PHX_PARENT_ID}]`)[0];
    },
    dispatchEvent(target, name, opts = {}) {
      let bubbles = opts.bubbles === void 0 ? true : !!opts.bubbles;
      let eventOpts = { bubbles, cancelable: true, detail: opts.detail || {} };
      let event = name === "click" ? new MouseEvent("click", eventOpts) : new CustomEvent(name, eventOpts);
      target.dispatchEvent(event);
    },
    cloneNode(node, html) {
      if (typeof html === "undefined") {
        return node.cloneNode(true);
      } else {
        let cloned = node.cloneNode(false);
        cloned.innerHTML = html;
        return cloned;
      }
    },
    mergeAttrs(target, source, opts = {}) {
      let exclude = opts.exclude || [];
      let isIgnored = opts.isIgnored;
      let sourceAttrs = source.attributes;
      for (let i = sourceAttrs.length - 1; i >= 0; i--) {
        let name = sourceAttrs[i].name;
        if (exclude.indexOf(name) < 0) {
          target.setAttribute(name, source.getAttribute(name));
        }
      }
      let targetAttrs = target.attributes;
      for (let i = targetAttrs.length - 1; i >= 0; i--) {
        let name = targetAttrs[i].name;
        if (isIgnored) {
          if (name.startsWith("data-") && !source.hasAttribute(name)) {
            target.removeAttribute(name);
          }
        } else {
          if (!source.hasAttribute(name)) {
            target.removeAttribute(name);
          }
        }
      }
    },
    mergeFocusedInput(target, source) {
      if (!(target instanceof HTMLSelectElement)) {
        DOM.mergeAttrs(target, source, { exclude: ["value"] });
      }
      if (source.readOnly) {
        target.setAttribute("readonly", true);
      } else {
        target.removeAttribute("readonly");
      }
    },
    hasSelectionRange(el) {
      return el.setSelectionRange && (el.type === "text" || el.type === "textarea");
    },
    restoreFocus(focused, selectionStart, selectionEnd) {
      if (!DOM.isTextualInput(focused)) {
        return;
      }
      let wasFocused = focused.matches(":focus");
      if (focused.readOnly) {
        focused.blur();
      }
      if (!wasFocused) {
        focused.focus();
      }
      if (this.hasSelectionRange(focused)) {
        focused.setSelectionRange(selectionStart, selectionEnd);
      }
    },
    isFormInput(el) {
      return /^(?:input|select|textarea)$/i.test(el.tagName) && el.type !== "button";
    },
    syncAttrsToProps(el) {
      if (el instanceof HTMLInputElement && CHECKABLE_INPUTS.indexOf(el.type.toLocaleLowerCase()) >= 0) {
        el.checked = el.getAttribute("checked") !== null;
      }
    },
    isTextualInput(el) {
      return FOCUSABLE_INPUTS.indexOf(el.type) >= 0;
    },
    isNowTriggerFormExternal(el, phxTriggerExternal) {
      return el.getAttribute && el.getAttribute(phxTriggerExternal) !== null;
    },
    syncPendingRef(fromEl, toEl, disableWith) {
      let ref = fromEl.getAttribute(PHX_REF);
      if (ref === null) {
        return true;
      }
      let refSrc = fromEl.getAttribute(PHX_REF_SRC);
      if (DOM.isFormInput(fromEl) || fromEl.getAttribute(disableWith) !== null) {
        if (DOM.isUploadInput(fromEl)) {
          DOM.mergeAttrs(fromEl, toEl, { isIgnored: true });
        }
        DOM.putPrivate(fromEl, PHX_REF, toEl);
        return false;
      } else {
        PHX_EVENT_CLASSES.forEach((className) => {
          fromEl.classList.contains(className) && toEl.classList.add(className);
        });
        toEl.setAttribute(PHX_REF, ref);
        toEl.setAttribute(PHX_REF_SRC, refSrc);
        return true;
      }
    },
    cleanChildNodes(container, phxUpdate) {
      if (DOM.isPhxUpdate(container, phxUpdate, ["append", "prepend"])) {
        let toRemove = [];
        container.childNodes.forEach((childNode) => {
          if (!childNode.id) {
            let isEmptyTextNode = childNode.nodeType === Node.TEXT_NODE && childNode.nodeValue.trim() === "";
            if (!isEmptyTextNode) {
              logError(`only HTML element tags with an id are allowed inside containers with phx-update.

removing illegal node: "${(childNode.outerHTML || childNode.nodeValue).trim()}"

`);
            }
            toRemove.push(childNode);
          }
        });
        toRemove.forEach((childNode) => childNode.remove());
      }
    },
    replaceRootContainer(container, tagName, attrs) {
      let retainedAttrs = /* @__PURE__ */ new Set(["id", PHX_SESSION, PHX_STATIC, PHX_MAIN, PHX_ROOT_ID]);
      if (container.tagName.toLowerCase() === tagName.toLowerCase()) {
        Array.from(container.attributes).filter((attr) => !retainedAttrs.has(attr.name.toLowerCase())).forEach((attr) => container.removeAttribute(attr.name));
        Object.keys(attrs).filter((name) => !retainedAttrs.has(name.toLowerCase())).forEach((attr) => container.setAttribute(attr, attrs[attr]));
        return container;
      } else {
        let newContainer = document.createElement(tagName);
        Object.keys(attrs).forEach((attr) => newContainer.setAttribute(attr, attrs[attr]));
        retainedAttrs.forEach((attr) => newContainer.setAttribute(attr, container.getAttribute(attr)));
        newContainer.innerHTML = container.innerHTML;
        container.replaceWith(newContainer);
        return newContainer;
      }
    },
    getSticky(el, name, defaultVal) {
      let op = (DOM.private(el, "sticky") || []).find(([existingName]) => name === existingName);
      if (op) {
        let [_name, _op, stashedResult] = op;
        return stashedResult;
      } else {
        return typeof defaultVal === "function" ? defaultVal() : defaultVal;
      }
    },
    deleteSticky(el, name) {
      this.updatePrivate(el, "sticky", [], (ops) => {
        return ops.filter(([existingName, _]) => existingName !== name);
      });
    },
    putSticky(el, name, op) {
      let stashedResult = op(el);
      this.updatePrivate(el, "sticky", [], (ops) => {
        let existingIndex = ops.findIndex(([existingName]) => name === existingName);
        if (existingIndex >= 0) {
          ops[existingIndex] = [name, op, stashedResult];
        } else {
          ops.push([name, op, stashedResult]);
        }
        return ops;
      });
    },
    applyStickyOperations(el) {
      let ops = DOM.private(el, "sticky");
      if (!ops) {
        return;
      }
      ops.forEach(([name, op, _stashed]) => this.putSticky(el, name, op));
    }
  };
  var dom_default = DOM;
  var UploadEntry = class {
    static isActive(fileEl, file) {
      let isNew = file._phxRef === void 0;
      let activeRefs = fileEl.getAttribute(PHX_ACTIVE_ENTRY_REFS).split(",");
      let isActive = activeRefs.indexOf(LiveUploader.genFileRef(file)) >= 0;
      return file.size > 0 && (isNew || isActive);
    }
    static isPreflighted(fileEl, file) {
      let preflightedRefs = fileEl.getAttribute(PHX_PREFLIGHTED_REFS).split(",");
      let isPreflighted = preflightedRefs.indexOf(LiveUploader.genFileRef(file)) >= 0;
      return isPreflighted && this.isActive(fileEl, file);
    }
    constructor(fileEl, file, view) {
      this.ref = LiveUploader.genFileRef(file);
      this.fileEl = fileEl;
      this.file = file;
      this.view = view;
      this.meta = null;
      this._isCancelled = false;
      this._isDone = false;
      this._progress = 0;
      this._lastProgressSent = -1;
      this._onDone = function() {
      };
      this._onElUpdated = this.onElUpdated.bind(this);
      this.fileEl.addEventListener(PHX_LIVE_FILE_UPDATED, this._onElUpdated);
    }
    metadata() {
      return this.meta;
    }
    progress(progress) {
      this._progress = Math.floor(progress);
      if (this._progress > this._lastProgressSent) {
        if (this._progress >= 100) {
          this._progress = 100;
          this._lastProgressSent = 100;
          this._isDone = true;
          this.view.pushFileProgress(this.fileEl, this.ref, 100, () => {
            LiveUploader.untrackFile(this.fileEl, this.file);
            this._onDone();
          });
        } else {
          this._lastProgressSent = this._progress;
          this.view.pushFileProgress(this.fileEl, this.ref, this._progress);
        }
      }
    }
    cancel() {
      this._isCancelled = true;
      this._isDone = true;
      this._onDone();
    }
    isDone() {
      return this._isDone;
    }
    error(reason = "failed") {
      this.view.pushFileProgress(this.fileEl, this.ref, { error: reason });
      LiveUploader.clearFiles(this.fileEl);
    }
    onDone(callback) {
      this._onDone = () => {
        this.fileEl.removeEventListener(PHX_LIVE_FILE_UPDATED, this._onElUpdated);
        callback();
      };
    }
    onElUpdated() {
      let activeRefs = this.fileEl.getAttribute(PHX_ACTIVE_ENTRY_REFS).split(",");
      if (activeRefs.indexOf(this.ref) === -1) {
        this.cancel();
      }
    }
    toPreflightPayload() {
      return {
        last_modified: this.file.lastModified,
        name: this.file.name,
        size: this.file.size,
        type: this.file.type,
        ref: this.ref
      };
    }
    uploader(uploaders) {
      if (this.meta.uploader) {
        let callback = uploaders[this.meta.uploader] || logError(`no uploader configured for ${this.meta.uploader}`);
        return { name: this.meta.uploader, callback };
      } else {
        return { name: "channel", callback: channelUploader };
      }
    }
    zipPostFlight(resp) {
      this.meta = resp.entries[this.ref];
      if (!this.meta) {
        logError(`no preflight upload response returned with ref ${this.ref}`, { input: this.fileEl, response: resp });
      }
    }
  };
  var liveUploaderFileRef = 0;
  var LiveUploader = class {
    static genFileRef(file) {
      let ref = file._phxRef;
      if (ref !== void 0) {
        return ref;
      } else {
        file._phxRef = (liveUploaderFileRef++).toString();
        return file._phxRef;
      }
    }
    static getEntryDataURL(inputEl, ref, callback) {
      let file = this.activeFiles(inputEl).find((file2) => this.genFileRef(file2) === ref);
      callback(URL.createObjectURL(file));
    }
    static hasUploadsInProgress(formEl) {
      let active = 0;
      dom_default.findUploadInputs(formEl).forEach((input) => {
        if (input.getAttribute(PHX_PREFLIGHTED_REFS) !== input.getAttribute(PHX_DONE_REFS)) {
          active++;
        }
      });
      return active > 0;
    }
    static serializeUploads(inputEl) {
      let files = this.activeFiles(inputEl);
      let fileData = {};
      files.forEach((file) => {
        let entry = { path: inputEl.name };
        let uploadRef = inputEl.getAttribute(PHX_UPLOAD_REF);
        fileData[uploadRef] = fileData[uploadRef] || [];
        entry.ref = this.genFileRef(file);
        entry.name = file.name || entry.ref;
        entry.type = file.type;
        entry.size = file.size;
        fileData[uploadRef].push(entry);
      });
      return fileData;
    }
    static clearFiles(inputEl) {
      inputEl.value = null;
      inputEl.removeAttribute(PHX_UPLOAD_REF);
      dom_default.putPrivate(inputEl, "files", []);
    }
    static untrackFile(inputEl, file) {
      dom_default.putPrivate(inputEl, "files", dom_default.private(inputEl, "files").filter((f) => !Object.is(f, file)));
    }
    static trackFiles(inputEl, files) {
      if (inputEl.getAttribute("multiple") !== null) {
        let newFiles = files.filter((file) => !this.activeFiles(inputEl).find((f) => Object.is(f, file)));
        dom_default.putPrivate(inputEl, "files", this.activeFiles(inputEl).concat(newFiles));
        inputEl.value = null;
      } else {
        dom_default.putPrivate(inputEl, "files", files);
      }
    }
    static activeFileInputs(formEl) {
      let fileInputs = dom_default.findUploadInputs(formEl);
      return Array.from(fileInputs).filter((el) => el.files && this.activeFiles(el).length > 0);
    }
    static activeFiles(input) {
      return (dom_default.private(input, "files") || []).filter((f) => UploadEntry.isActive(input, f));
    }
    static inputsAwaitingPreflight(formEl) {
      let fileInputs = dom_default.findUploadInputs(formEl);
      return Array.from(fileInputs).filter((input) => this.filesAwaitingPreflight(input).length > 0);
    }
    static filesAwaitingPreflight(input) {
      return this.activeFiles(input).filter((f) => !UploadEntry.isPreflighted(input, f));
    }
    constructor(inputEl, view, onComplete) {
      this.view = view;
      this.onComplete = onComplete;
      this._entries = Array.from(LiveUploader.filesAwaitingPreflight(inputEl) || []).map((file) => new UploadEntry(inputEl, file, view));
      this.numEntriesInProgress = this._entries.length;
    }
    entries() {
      return this._entries;
    }
    initAdapterUpload(resp, onError, liveSocket2) {
      this._entries = this._entries.map((entry) => {
        entry.zipPostFlight(resp);
        entry.onDone(() => {
          this.numEntriesInProgress--;
          if (this.numEntriesInProgress === 0) {
            this.onComplete();
          }
        });
        return entry;
      });
      let groupedEntries = this._entries.reduce((acc, entry) => {
        let { name, callback } = entry.uploader(liveSocket2.uploaders);
        acc[name] = acc[name] || { callback, entries: [] };
        acc[name].entries.push(entry);
        return acc;
      }, {});
      for (let name in groupedEntries) {
        let { callback, entries } = groupedEntries[name];
        callback(entries, onError, resp, liveSocket2);
      }
    }
  };
  var Hooks = {
    LiveFileUpload: {
      activeRefs() {
        return this.el.getAttribute(PHX_ACTIVE_ENTRY_REFS);
      },
      preflightedRefs() {
        return this.el.getAttribute(PHX_PREFLIGHTED_REFS);
      },
      mounted() {
        this.preflightedWas = this.preflightedRefs();
      },
      updated() {
        let newPreflights = this.preflightedRefs();
        if (this.preflightedWas !== newPreflights) {
          this.preflightedWas = newPreflights;
          if (newPreflights === "") {
            this.__view.cancelSubmit(this.el.form);
          }
        }
        if (this.activeRefs() === "") {
          this.el.value = null;
        }
        this.el.dispatchEvent(new CustomEvent(PHX_LIVE_FILE_UPDATED));
      }
    },
    LiveImgPreview: {
      mounted() {
        this.ref = this.el.getAttribute("data-phx-entry-ref");
        this.inputEl = document.getElementById(this.el.getAttribute(PHX_UPLOAD_REF));
        LiveUploader.getEntryDataURL(this.inputEl, this.ref, (url) => {
          this.url = url;
          this.el.src = url;
        });
      },
      destroyed() {
        URL.revokeObjectURL(this.url);
      }
    }
  };
  var hooks_default = Hooks;
  var DOMPostMorphRestorer = class {
    constructor(containerBefore, containerAfter, updateType) {
      let idsBefore = /* @__PURE__ */ new Set();
      let idsAfter = new Set([...containerAfter.children].map((child) => child.id));
      let elementsToModify = [];
      Array.from(containerBefore.children).forEach((child) => {
        if (child.id) {
          idsBefore.add(child.id);
          if (idsAfter.has(child.id)) {
            let previousElementId = child.previousElementSibling && child.previousElementSibling.id;
            elementsToModify.push({ elementId: child.id, previousElementId });
          }
        }
      });
      this.containerId = containerAfter.id;
      this.updateType = updateType;
      this.elementsToModify = elementsToModify;
      this.elementIdsToAdd = [...idsAfter].filter((id) => !idsBefore.has(id));
    }
    perform() {
      let container = dom_default.byId(this.containerId);
      this.elementsToModify.forEach((elementToModify) => {
        if (elementToModify.previousElementId) {
          maybe(document.getElementById(elementToModify.previousElementId), (previousElem) => {
            maybe(document.getElementById(elementToModify.elementId), (elem) => {
              let isInRightPlace = elem.previousElementSibling && elem.previousElementSibling.id == previousElem.id;
              if (!isInRightPlace) {
                previousElem.insertAdjacentElement("afterend", elem);
              }
            });
          });
        } else {
          maybe(document.getElementById(elementToModify.elementId), (elem) => {
            let isInRightPlace = elem.previousElementSibling == null;
            if (!isInRightPlace) {
              container.insertAdjacentElement("afterbegin", elem);
            }
          });
        }
      });
      if (this.updateType == "prepend") {
        this.elementIdsToAdd.reverse().forEach((elemId) => {
          maybe(document.getElementById(elemId), (elem) => container.insertAdjacentElement("afterbegin", elem));
        });
      }
    }
  };
  var DOCUMENT_FRAGMENT_NODE = 11;
  function morphAttrs(fromNode, toNode) {
    var toNodeAttrs = toNode.attributes;
    var attr;
    var attrName;
    var attrNamespaceURI;
    var attrValue;
    var fromValue;
    if (toNode.nodeType === DOCUMENT_FRAGMENT_NODE || fromNode.nodeType === DOCUMENT_FRAGMENT_NODE) {
      return;
    }
    for (var i = toNodeAttrs.length - 1; i >= 0; i--) {
      attr = toNodeAttrs[i];
      attrName = attr.name;
      attrNamespaceURI = attr.namespaceURI;
      attrValue = attr.value;
      if (attrNamespaceURI) {
        attrName = attr.localName || attrName;
        fromValue = fromNode.getAttributeNS(attrNamespaceURI, attrName);
        if (fromValue !== attrValue) {
          if (attr.prefix === "xmlns") {
            attrName = attr.name;
          }
          fromNode.setAttributeNS(attrNamespaceURI, attrName, attrValue);
        }
      } else {
        fromValue = fromNode.getAttribute(attrName);
        if (fromValue !== attrValue) {
          fromNode.setAttribute(attrName, attrValue);
        }
      }
    }
    var fromNodeAttrs = fromNode.attributes;
    for (var d = fromNodeAttrs.length - 1; d >= 0; d--) {
      attr = fromNodeAttrs[d];
      attrName = attr.name;
      attrNamespaceURI = attr.namespaceURI;
      if (attrNamespaceURI) {
        attrName = attr.localName || attrName;
        if (!toNode.hasAttributeNS(attrNamespaceURI, attrName)) {
          fromNode.removeAttributeNS(attrNamespaceURI, attrName);
        }
      } else {
        if (!toNode.hasAttribute(attrName)) {
          fromNode.removeAttribute(attrName);
        }
      }
    }
  }
  var range;
  var NS_XHTML = "http://www.w3.org/1999/xhtml";
  var doc = typeof document === "undefined" ? void 0 : document;
  var HAS_TEMPLATE_SUPPORT = !!doc && "content" in doc.createElement("template");
  var HAS_RANGE_SUPPORT = !!doc && doc.createRange && "createContextualFragment" in doc.createRange();
  function createFragmentFromTemplate(str) {
    var template = doc.createElement("template");
    template.innerHTML = str;
    return template.content.childNodes[0];
  }
  function createFragmentFromRange(str) {
    if (!range) {
      range = doc.createRange();
      range.selectNode(doc.body);
    }
    var fragment = range.createContextualFragment(str);
    return fragment.childNodes[0];
  }
  function createFragmentFromWrap(str) {
    var fragment = doc.createElement("body");
    fragment.innerHTML = str;
    return fragment.childNodes[0];
  }
  function toElement(str) {
    str = str.trim();
    if (HAS_TEMPLATE_SUPPORT) {
      return createFragmentFromTemplate(str);
    } else if (HAS_RANGE_SUPPORT) {
      return createFragmentFromRange(str);
    }
    return createFragmentFromWrap(str);
  }
  function compareNodeNames(fromEl, toEl) {
    var fromNodeName = fromEl.nodeName;
    var toNodeName = toEl.nodeName;
    var fromCodeStart, toCodeStart;
    if (fromNodeName === toNodeName) {
      return true;
    }
    fromCodeStart = fromNodeName.charCodeAt(0);
    toCodeStart = toNodeName.charCodeAt(0);
    if (fromCodeStart <= 90 && toCodeStart >= 97) {
      return fromNodeName === toNodeName.toUpperCase();
    } else if (toCodeStart <= 90 && fromCodeStart >= 97) {
      return toNodeName === fromNodeName.toUpperCase();
    } else {
      return false;
    }
  }
  function createElementNS(name, namespaceURI) {
    return !namespaceURI || namespaceURI === NS_XHTML ? doc.createElement(name) : doc.createElementNS(namespaceURI, name);
  }
  function moveChildren(fromEl, toEl) {
    var curChild = fromEl.firstChild;
    while (curChild) {
      var nextChild = curChild.nextSibling;
      toEl.appendChild(curChild);
      curChild = nextChild;
    }
    return toEl;
  }
  function syncBooleanAttrProp(fromEl, toEl, name) {
    if (fromEl[name] !== toEl[name]) {
      fromEl[name] = toEl[name];
      if (fromEl[name]) {
        fromEl.setAttribute(name, "");
      } else {
        fromEl.removeAttribute(name);
      }
    }
  }
  var specialElHandlers = {
    OPTION: function(fromEl, toEl) {
      var parentNode = fromEl.parentNode;
      if (parentNode) {
        var parentName = parentNode.nodeName.toUpperCase();
        if (parentName === "OPTGROUP") {
          parentNode = parentNode.parentNode;
          parentName = parentNode && parentNode.nodeName.toUpperCase();
        }
        if (parentName === "SELECT" && !parentNode.hasAttribute("multiple")) {
          if (fromEl.hasAttribute("selected") && !toEl.selected) {
            fromEl.setAttribute("selected", "selected");
            fromEl.removeAttribute("selected");
          }
          parentNode.selectedIndex = -1;
        }
      }
      syncBooleanAttrProp(fromEl, toEl, "selected");
    },
    INPUT: function(fromEl, toEl) {
      syncBooleanAttrProp(fromEl, toEl, "checked");
      syncBooleanAttrProp(fromEl, toEl, "disabled");
      if (fromEl.value !== toEl.value) {
        fromEl.value = toEl.value;
      }
      if (!toEl.hasAttribute("value")) {
        fromEl.removeAttribute("value");
      }
    },
    TEXTAREA: function(fromEl, toEl) {
      var newValue = toEl.value;
      if (fromEl.value !== newValue) {
        fromEl.value = newValue;
      }
      var firstChild = fromEl.firstChild;
      if (firstChild) {
        var oldValue = firstChild.nodeValue;
        if (oldValue == newValue || !newValue && oldValue == fromEl.placeholder) {
          return;
        }
        firstChild.nodeValue = newValue;
      }
    },
    SELECT: function(fromEl, toEl) {
      if (!toEl.hasAttribute("multiple")) {
        var selectedIndex = -1;
        var i = 0;
        var curChild = fromEl.firstChild;
        var optgroup;
        var nodeName;
        while (curChild) {
          nodeName = curChild.nodeName && curChild.nodeName.toUpperCase();
          if (nodeName === "OPTGROUP") {
            optgroup = curChild;
            curChild = optgroup.firstChild;
          } else {
            if (nodeName === "OPTION") {
              if (curChild.hasAttribute("selected")) {
                selectedIndex = i;
                break;
              }
              i++;
            }
            curChild = curChild.nextSibling;
            if (!curChild && optgroup) {
              curChild = optgroup.nextSibling;
              optgroup = null;
            }
          }
        }
        fromEl.selectedIndex = selectedIndex;
      }
    }
  };
  var ELEMENT_NODE = 1;
  var DOCUMENT_FRAGMENT_NODE$1 = 11;
  var TEXT_NODE = 3;
  var COMMENT_NODE = 8;
  function noop() {
  }
  function defaultGetNodeKey(node) {
    if (node) {
      return node.getAttribute && node.getAttribute("id") || node.id;
    }
  }
  function morphdomFactory(morphAttrs2) {
    return function morphdom2(fromNode, toNode, options) {
      if (!options) {
        options = {};
      }
      if (typeof toNode === "string") {
        if (fromNode.nodeName === "#document" || fromNode.nodeName === "HTML" || fromNode.nodeName === "BODY") {
          var toNodeHtml = toNode;
          toNode = doc.createElement("html");
          toNode.innerHTML = toNodeHtml;
        } else {
          toNode = toElement(toNode);
        }
      }
      var getNodeKey = options.getNodeKey || defaultGetNodeKey;
      var onBeforeNodeAdded = options.onBeforeNodeAdded || noop;
      var onNodeAdded = options.onNodeAdded || noop;
      var onBeforeElUpdated = options.onBeforeElUpdated || noop;
      var onElUpdated = options.onElUpdated || noop;
      var onBeforeNodeDiscarded = options.onBeforeNodeDiscarded || noop;
      var onNodeDiscarded = options.onNodeDiscarded || noop;
      var onBeforeElChildrenUpdated = options.onBeforeElChildrenUpdated || noop;
      var childrenOnly = options.childrenOnly === true;
      var fromNodesLookup = Object.create(null);
      var keyedRemovalList = [];
      function addKeyedRemoval(key) {
        keyedRemovalList.push(key);
      }
      function walkDiscardedChildNodes(node, skipKeyedNodes) {
        if (node.nodeType === ELEMENT_NODE) {
          var curChild = node.firstChild;
          while (curChild) {
            var key = void 0;
            if (skipKeyedNodes && (key = getNodeKey(curChild))) {
              addKeyedRemoval(key);
            } else {
              onNodeDiscarded(curChild);
              if (curChild.firstChild) {
                walkDiscardedChildNodes(curChild, skipKeyedNodes);
              }
            }
            curChild = curChild.nextSibling;
          }
        }
      }
      function removeNode(node, parentNode, skipKeyedNodes) {
        if (onBeforeNodeDiscarded(node) === false) {
          return;
        }
        if (parentNode) {
          parentNode.removeChild(node);
        }
        onNodeDiscarded(node);
        walkDiscardedChildNodes(node, skipKeyedNodes);
      }
      function indexTree(node) {
        if (node.nodeType === ELEMENT_NODE || node.nodeType === DOCUMENT_FRAGMENT_NODE$1) {
          var curChild = node.firstChild;
          while (curChild) {
            var key = getNodeKey(curChild);
            if (key) {
              fromNodesLookup[key] = curChild;
            }
            indexTree(curChild);
            curChild = curChild.nextSibling;
          }
        }
      }
      indexTree(fromNode);
      function handleNodeAdded(el) {
        onNodeAdded(el);
        var curChild = el.firstChild;
        while (curChild) {
          var nextSibling = curChild.nextSibling;
          var key = getNodeKey(curChild);
          if (key) {
            var unmatchedFromEl = fromNodesLookup[key];
            if (unmatchedFromEl && compareNodeNames(curChild, unmatchedFromEl)) {
              curChild.parentNode.replaceChild(unmatchedFromEl, curChild);
              morphEl(unmatchedFromEl, curChild);
            } else {
              handleNodeAdded(curChild);
            }
          } else {
            handleNodeAdded(curChild);
          }
          curChild = nextSibling;
        }
      }
      function cleanupFromEl(fromEl, curFromNodeChild, curFromNodeKey) {
        while (curFromNodeChild) {
          var fromNextSibling = curFromNodeChild.nextSibling;
          if (curFromNodeKey = getNodeKey(curFromNodeChild)) {
            addKeyedRemoval(curFromNodeKey);
          } else {
            removeNode(curFromNodeChild, fromEl, true);
          }
          curFromNodeChild = fromNextSibling;
        }
      }
      function morphEl(fromEl, toEl, childrenOnly2) {
        var toElKey = getNodeKey(toEl);
        if (toElKey) {
          delete fromNodesLookup[toElKey];
        }
        if (!childrenOnly2) {
          if (onBeforeElUpdated(fromEl, toEl) === false) {
            return;
          }
          morphAttrs2(fromEl, toEl);
          onElUpdated(fromEl);
          if (onBeforeElChildrenUpdated(fromEl, toEl) === false) {
            return;
          }
        }
        if (fromEl.nodeName !== "TEXTAREA") {
          morphChildren(fromEl, toEl);
        } else {
          specialElHandlers.TEXTAREA(fromEl, toEl);
        }
      }
      function morphChildren(fromEl, toEl) {
        var curToNodeChild = toEl.firstChild;
        var curFromNodeChild = fromEl.firstChild;
        var curToNodeKey;
        var curFromNodeKey;
        var fromNextSibling;
        var toNextSibling;
        var matchingFromEl;
        outer:
          while (curToNodeChild) {
            toNextSibling = curToNodeChild.nextSibling;
            curToNodeKey = getNodeKey(curToNodeChild);
            while (curFromNodeChild) {
              fromNextSibling = curFromNodeChild.nextSibling;
              if (curToNodeChild.isSameNode && curToNodeChild.isSameNode(curFromNodeChild)) {
                curToNodeChild = toNextSibling;
                curFromNodeChild = fromNextSibling;
                continue outer;
              }
              curFromNodeKey = getNodeKey(curFromNodeChild);
              var curFromNodeType = curFromNodeChild.nodeType;
              var isCompatible = void 0;
              if (curFromNodeType === curToNodeChild.nodeType) {
                if (curFromNodeType === ELEMENT_NODE) {
                  if (curToNodeKey) {
                    if (curToNodeKey !== curFromNodeKey) {
                      if (matchingFromEl = fromNodesLookup[curToNodeKey]) {
                        if (fromNextSibling === matchingFromEl) {
                          isCompatible = false;
                        } else {
                          fromEl.insertBefore(matchingFromEl, curFromNodeChild);
                          if (curFromNodeKey) {
                            addKeyedRemoval(curFromNodeKey);
                          } else {
                            removeNode(curFromNodeChild, fromEl, true);
                          }
                          curFromNodeChild = matchingFromEl;
                        }
                      } else {
                        isCompatible = false;
                      }
                    }
                  } else if (curFromNodeKey) {
                    isCompatible = false;
                  }
                  isCompatible = isCompatible !== false && compareNodeNames(curFromNodeChild, curToNodeChild);
                  if (isCompatible) {
                    morphEl(curFromNodeChild, curToNodeChild);
                  }
                } else if (curFromNodeType === TEXT_NODE || curFromNodeType == COMMENT_NODE) {
                  isCompatible = true;
                  if (curFromNodeChild.nodeValue !== curToNodeChild.nodeValue) {
                    curFromNodeChild.nodeValue = curToNodeChild.nodeValue;
                  }
                }
              }
              if (isCompatible) {
                curToNodeChild = toNextSibling;
                curFromNodeChild = fromNextSibling;
                continue outer;
              }
              if (curFromNodeKey) {
                addKeyedRemoval(curFromNodeKey);
              } else {
                removeNode(curFromNodeChild, fromEl, true);
              }
              curFromNodeChild = fromNextSibling;
            }
            if (curToNodeKey && (matchingFromEl = fromNodesLookup[curToNodeKey]) && compareNodeNames(matchingFromEl, curToNodeChild)) {
              fromEl.appendChild(matchingFromEl);
              morphEl(matchingFromEl, curToNodeChild);
            } else {
              var onBeforeNodeAddedResult = onBeforeNodeAdded(curToNodeChild);
              if (onBeforeNodeAddedResult !== false) {
                if (onBeforeNodeAddedResult) {
                  curToNodeChild = onBeforeNodeAddedResult;
                }
                if (curToNodeChild.actualize) {
                  curToNodeChild = curToNodeChild.actualize(fromEl.ownerDocument || doc);
                }
                fromEl.appendChild(curToNodeChild);
                handleNodeAdded(curToNodeChild);
              }
            }
            curToNodeChild = toNextSibling;
            curFromNodeChild = fromNextSibling;
          }
        cleanupFromEl(fromEl, curFromNodeChild, curFromNodeKey);
        var specialElHandler = specialElHandlers[fromEl.nodeName];
        if (specialElHandler) {
          specialElHandler(fromEl, toEl);
        }
      }
      var morphedNode = fromNode;
      var morphedNodeType = morphedNode.nodeType;
      var toNodeType = toNode.nodeType;
      if (!childrenOnly) {
        if (morphedNodeType === ELEMENT_NODE) {
          if (toNodeType === ELEMENT_NODE) {
            if (!compareNodeNames(fromNode, toNode)) {
              onNodeDiscarded(fromNode);
              morphedNode = moveChildren(fromNode, createElementNS(toNode.nodeName, toNode.namespaceURI));
            }
          } else {
            morphedNode = toNode;
          }
        } else if (morphedNodeType === TEXT_NODE || morphedNodeType === COMMENT_NODE) {
          if (toNodeType === morphedNodeType) {
            if (morphedNode.nodeValue !== toNode.nodeValue) {
              morphedNode.nodeValue = toNode.nodeValue;
            }
            return morphedNode;
          } else {
            morphedNode = toNode;
          }
        }
      }
      if (morphedNode === toNode) {
        onNodeDiscarded(fromNode);
      } else {
        if (toNode.isSameNode && toNode.isSameNode(morphedNode)) {
          return;
        }
        morphEl(morphedNode, toNode, childrenOnly);
        if (keyedRemovalList) {
          for (var i = 0, len = keyedRemovalList.length; i < len; i++) {
            var elToRemove = fromNodesLookup[keyedRemovalList[i]];
            if (elToRemove) {
              removeNode(elToRemove, elToRemove.parentNode, false);
            }
          }
        }
      }
      if (!childrenOnly && morphedNode !== fromNode && fromNode.parentNode) {
        if (morphedNode.actualize) {
          morphedNode = morphedNode.actualize(fromNode.ownerDocument || doc);
        }
        fromNode.parentNode.replaceChild(morphedNode, fromNode);
      }
      return morphedNode;
    };
  }
  var morphdom = morphdomFactory(morphAttrs);
  var morphdom_esm_default = morphdom;
  var DOMPatch = class {
    static patchEl(fromEl, toEl, activeElement) {
      morphdom_esm_default(fromEl, toEl, {
        childrenOnly: false,
        onBeforeElUpdated: (fromEl2, toEl2) => {
          if (activeElement && activeElement.isSameNode(fromEl2) && dom_default.isFormInput(fromEl2)) {
            dom_default.mergeFocusedInput(fromEl2, toEl2);
            return false;
          }
        }
      });
    }
    constructor(view, container, id, html, targetCID) {
      this.view = view;
      this.liveSocket = view.liveSocket;
      this.container = container;
      this.id = id;
      this.rootID = view.root.id;
      this.html = html;
      this.targetCID = targetCID;
      this.cidPatch = isCid(this.targetCID);
      this.callbacks = {
        beforeadded: [],
        beforeupdated: [],
        beforephxChildAdded: [],
        afteradded: [],
        afterupdated: [],
        afterdiscarded: [],
        afterphxChildAdded: [],
        aftertransitionsDiscarded: []
      };
    }
    before(kind, callback) {
      this.callbacks[`before${kind}`].push(callback);
    }
    after(kind, callback) {
      this.callbacks[`after${kind}`].push(callback);
    }
    trackBefore(kind, ...args) {
      this.callbacks[`before${kind}`].forEach((callback) => callback(...args));
    }
    trackAfter(kind, ...args) {
      this.callbacks[`after${kind}`].forEach((callback) => callback(...args));
    }
    markPrunableContentForRemoval() {
      dom_default.all(this.container, "[phx-update=append] > *, [phx-update=prepend] > *", (el) => {
        el.setAttribute(PHX_PRUNE, "");
      });
    }
    perform() {
      let { view, liveSocket: liveSocket2, container, html } = this;
      let targetContainer = this.isCIDPatch() ? this.targetCIDContainer(html) : container;
      if (this.isCIDPatch() && !targetContainer) {
        return;
      }
      let focused = liveSocket2.getActiveElement();
      let { selectionStart, selectionEnd } = focused && dom_default.hasSelectionRange(focused) ? focused : {};
      let phxUpdate = liveSocket2.binding(PHX_UPDATE);
      let phxFeedbackFor = liveSocket2.binding(PHX_FEEDBACK_FOR);
      let disableWith = liveSocket2.binding(PHX_DISABLE_WITH);
      let phxTriggerExternal = liveSocket2.binding(PHX_TRIGGER_ACTION);
      let phxRemove = liveSocket2.binding("remove");
      let added = [];
      let updates = [];
      let appendPrependUpdates = [];
      let pendingRemoves = [];
      let externalFormTriggered = null;
      let diffHTML = liveSocket2.time("premorph container prep", () => {
        return this.buildDiffHTML(container, html, phxUpdate, targetContainer);
      });
      this.trackBefore("added", container);
      this.trackBefore("updated", container, container);
      liveSocket2.time("morphdom", () => {
        morphdom_esm_default(targetContainer, diffHTML, {
          childrenOnly: targetContainer.getAttribute(PHX_COMPONENT) === null,
          getNodeKey: (node) => {
            return dom_default.isPhxDestroyed(node) ? null : node.id;
          },
          onBeforeNodeAdded: (el) => {
            this.trackBefore("added", el);
            return el;
          },
          onNodeAdded: (el) => {
            if (el instanceof HTMLImageElement && el.srcset) {
              el.srcset = el.srcset;
            } else if (el instanceof HTMLVideoElement && el.autoplay) {
              el.play();
            }
            if (dom_default.isNowTriggerFormExternal(el, phxTriggerExternal)) {
              externalFormTriggered = el;
            }
            dom_default.discardError(targetContainer, el, phxFeedbackFor);
            if (dom_default.isPhxChild(el) && view.ownsElement(el) || dom_default.isPhxSticky(el) && view.ownsElement(el.parentNode)) {
              this.trackAfter("phxChildAdded", el);
            }
            added.push(el);
          },
          onNodeDiscarded: (el) => {
            if (dom_default.isPhxChild(el) || dom_default.isPhxSticky(el)) {
              liveSocket2.destroyViewByEl(el);
            }
            this.trackAfter("discarded", el);
          },
          onBeforeNodeDiscarded: (el) => {
            if (el.getAttribute && el.getAttribute(PHX_PRUNE) !== null) {
              return true;
            }
            if (el.parentNode !== null && dom_default.isPhxUpdate(el.parentNode, phxUpdate, ["append", "prepend"]) && el.id) {
              return false;
            }
            if (el.getAttribute && el.getAttribute(phxRemove)) {
              pendingRemoves.push(el);
              return false;
            }
            if (this.skipCIDSibling(el)) {
              return false;
            }
            return true;
          },
          onElUpdated: (el) => {
            if (dom_default.isNowTriggerFormExternal(el, phxTriggerExternal)) {
              externalFormTriggered = el;
            }
            updates.push(el);
          },
          onBeforeElUpdated: (fromEl, toEl) => {
            dom_default.cleanChildNodes(toEl, phxUpdate);
            if (this.skipCIDSibling(toEl)) {
              return false;
            }
            if (dom_default.isPhxSticky(fromEl)) {
              return false;
            }
            if (dom_default.isIgnored(fromEl, phxUpdate)) {
              this.trackBefore("updated", fromEl, toEl);
              dom_default.mergeAttrs(fromEl, toEl, { isIgnored: true });
              updates.push(fromEl);
              dom_default.applyStickyOperations(fromEl);
              return false;
            }
            if (fromEl.type === "number" && (fromEl.validity && fromEl.validity.badInput)) {
              return false;
            }
            if (!dom_default.syncPendingRef(fromEl, toEl, disableWith)) {
              if (dom_default.isUploadInput(fromEl)) {
                this.trackBefore("updated", fromEl, toEl);
                updates.push(fromEl);
              }
              dom_default.applyStickyOperations(fromEl);
              return false;
            }
            if (dom_default.isPhxChild(toEl)) {
              let prevSession = fromEl.getAttribute(PHX_SESSION);
              dom_default.mergeAttrs(fromEl, toEl, { exclude: [PHX_STATIC] });
              if (prevSession !== "") {
                fromEl.setAttribute(PHX_SESSION, prevSession);
              }
              fromEl.setAttribute(PHX_ROOT_ID, this.rootID);
              dom_default.applyStickyOperations(fromEl);
              return false;
            }
            dom_default.copyPrivates(toEl, fromEl);
            dom_default.discardError(targetContainer, toEl, phxFeedbackFor);
            let isFocusedFormEl = focused && fromEl.isSameNode(focused) && dom_default.isFormInput(fromEl);
            if (isFocusedFormEl) {
              this.trackBefore("updated", fromEl, toEl);
              dom_default.mergeFocusedInput(fromEl, toEl);
              dom_default.syncAttrsToProps(fromEl);
              updates.push(fromEl);
              dom_default.applyStickyOperations(fromEl);
              return false;
            } else {
              if (dom_default.isPhxUpdate(toEl, phxUpdate, ["append", "prepend"])) {
                appendPrependUpdates.push(new DOMPostMorphRestorer(fromEl, toEl, toEl.getAttribute(phxUpdate)));
              }
              dom_default.syncAttrsToProps(toEl);
              dom_default.applyStickyOperations(toEl);
              this.trackBefore("updated", fromEl, toEl);
              return true;
            }
          }
        });
      });
      if (liveSocket2.isDebugEnabled()) {
        detectDuplicateIds();
      }
      if (appendPrependUpdates.length > 0) {
        liveSocket2.time("post-morph append/prepend restoration", () => {
          appendPrependUpdates.forEach((update) => update.perform());
        });
      }
      liveSocket2.silenceEvents(() => dom_default.restoreFocus(focused, selectionStart, selectionEnd));
      dom_default.dispatchEvent(document, "phx:update");
      added.forEach((el) => this.trackAfter("added", el));
      updates.forEach((el) => this.trackAfter("updated", el));
      if (pendingRemoves.length > 0) {
        liveSocket2.transitionRemoves(pendingRemoves);
        liveSocket2.requestDOMUpdate(() => {
          pendingRemoves.forEach((el) => {
            let child = dom_default.firstPhxChild(el);
            if (child) {
              liveSocket2.destroyViewByEl(child);
            }
            el.remove();
          });
          this.trackAfter("transitionsDiscarded", pendingRemoves);
        });
      }
      if (externalFormTriggered) {
        liveSocket2.disconnect();
        externalFormTriggered.submit();
      }
      return true;
    }
    isCIDPatch() {
      return this.cidPatch;
    }
    skipCIDSibling(el) {
      return el.nodeType === Node.ELEMENT_NODE && el.getAttribute(PHX_SKIP) !== null;
    }
    targetCIDContainer(html) {
      if (!this.isCIDPatch()) {
        return;
      }
      let [first, ...rest] = dom_default.findComponentNodeList(this.container, this.targetCID);
      if (rest.length === 0 && dom_default.childNodeLength(html) === 1) {
        return first;
      } else {
        return first && first.parentNode;
      }
    }
    buildDiffHTML(container, html, phxUpdate, targetContainer) {
      let isCIDPatch = this.isCIDPatch();
      let isCIDWithSingleRoot = isCIDPatch && targetContainer.getAttribute(PHX_COMPONENT) === this.targetCID.toString();
      if (!isCIDPatch || isCIDWithSingleRoot) {
        return html;
      } else {
        let diffContainer = null;
        let template = document.createElement("template");
        diffContainer = dom_default.cloneNode(targetContainer);
        let [firstComponent, ...rest] = dom_default.findComponentNodeList(diffContainer, this.targetCID);
        template.innerHTML = html;
        rest.forEach((el) => el.remove());
        Array.from(diffContainer.childNodes).forEach((child) => {
          if (child.id && child.nodeType === Node.ELEMENT_NODE && child.getAttribute(PHX_COMPONENT) !== this.targetCID.toString()) {
            child.setAttribute(PHX_SKIP, "");
            child.innerHTML = "";
          }
        });
        Array.from(template.content.childNodes).forEach((el) => diffContainer.insertBefore(el, firstComponent));
        firstComponent.remove();
        return diffContainer.outerHTML;
      }
    }
  };
  var Rendered = class {
    static extract(diff) {
      let { [REPLY]: reply, [EVENTS]: events, [TITLE]: title } = diff;
      delete diff[REPLY];
      delete diff[EVENTS];
      delete diff[TITLE];
      return { diff, title, reply: reply || null, events: events || [] };
    }
    constructor(viewId, rendered) {
      this.viewId = viewId;
      this.rendered = {};
      this.mergeDiff(rendered);
    }
    parentViewId() {
      return this.viewId;
    }
    toString(onlyCids) {
      return this.recursiveToString(this.rendered, this.rendered[COMPONENTS], onlyCids);
    }
    recursiveToString(rendered, components = rendered[COMPONENTS], onlyCids) {
      onlyCids = onlyCids ? new Set(onlyCids) : null;
      let output = { buffer: "", components, onlyCids };
      this.toOutputBuffer(rendered, null, output);
      return output.buffer;
    }
    componentCIDs(diff) {
      return Object.keys(diff[COMPONENTS] || {}).map((i) => parseInt(i));
    }
    isComponentOnlyDiff(diff) {
      if (!diff[COMPONENTS]) {
        return false;
      }
      return Object.keys(diff).length === 1;
    }
    getComponent(diff, cid) {
      return diff[COMPONENTS][cid];
    }
    mergeDiff(diff) {
      let newc = diff[COMPONENTS];
      let cache = {};
      delete diff[COMPONENTS];
      this.rendered = this.mutableMerge(this.rendered, diff);
      this.rendered[COMPONENTS] = this.rendered[COMPONENTS] || {};
      if (newc) {
        let oldc = this.rendered[COMPONENTS];
        for (let cid in newc) {
          newc[cid] = this.cachedFindComponent(cid, newc[cid], oldc, newc, cache);
        }
        for (let cid in newc) {
          oldc[cid] = newc[cid];
        }
        diff[COMPONENTS] = newc;
      }
    }
    cachedFindComponent(cid, cdiff, oldc, newc, cache) {
      if (cache[cid]) {
        return cache[cid];
      } else {
        let ndiff, stat, scid = cdiff[STATIC];
        if (isCid(scid)) {
          let tdiff;
          if (scid > 0) {
            tdiff = this.cachedFindComponent(scid, newc[scid], oldc, newc, cache);
          } else {
            tdiff = oldc[-scid];
          }
          stat = tdiff[STATIC];
          ndiff = this.cloneMerge(tdiff, cdiff);
          ndiff[STATIC] = stat;
        } else {
          ndiff = cdiff[STATIC] !== void 0 ? cdiff : this.cloneMerge(oldc[cid] || {}, cdiff);
        }
        cache[cid] = ndiff;
        return ndiff;
      }
    }
    mutableMerge(target, source) {
      if (source[STATIC] !== void 0) {
        return source;
      } else {
        this.doMutableMerge(target, source);
        return target;
      }
    }
    doMutableMerge(target, source) {
      for (let key in source) {
        let val = source[key];
        let targetVal = target[key];
        if (isObject(val) && val[STATIC] === void 0 && isObject(targetVal)) {
          this.doMutableMerge(targetVal, val);
        } else {
          target[key] = val;
        }
      }
    }
    cloneMerge(target, source) {
      let merged = __spreadValues(__spreadValues({}, target), source);
      for (let key in merged) {
        let val = source[key];
        let targetVal = target[key];
        if (isObject(val) && val[STATIC] === void 0 && isObject(targetVal)) {
          merged[key] = this.cloneMerge(targetVal, val);
        }
      }
      return merged;
    }
    componentToString(cid) {
      return this.recursiveCIDToString(this.rendered[COMPONENTS], cid);
    }
    pruneCIDs(cids) {
      cids.forEach((cid) => delete this.rendered[COMPONENTS][cid]);
    }
    get() {
      return this.rendered;
    }
    isNewFingerprint(diff = {}) {
      return !!diff[STATIC];
    }
    templateStatic(part, templates) {
      if (typeof part === "number") {
        return templates[part];
      } else {
        return part;
      }
    }
    toOutputBuffer(rendered, templates, output) {
      if (rendered[DYNAMICS]) {
        return this.comprehensionToBuffer(rendered, templates, output);
      }
      let { [STATIC]: statics } = rendered;
      statics = this.templateStatic(statics, templates);
      output.buffer += statics[0];
      for (let i = 1; i < statics.length; i++) {
        this.dynamicToBuffer(rendered[i - 1], templates, output);
        output.buffer += statics[i];
      }
    }
    comprehensionToBuffer(rendered, templates, output) {
      let { [DYNAMICS]: dynamics, [STATIC]: statics } = rendered;
      statics = this.templateStatic(statics, templates);
      let compTemplates = templates || rendered[TEMPLATES];
      for (let d = 0; d < dynamics.length; d++) {
        let dynamic = dynamics[d];
        output.buffer += statics[0];
        for (let i = 1; i < statics.length; i++) {
          this.dynamicToBuffer(dynamic[i - 1], compTemplates, output);
          output.buffer += statics[i];
        }
      }
    }
    dynamicToBuffer(rendered, templates, output) {
      if (typeof rendered === "number") {
        output.buffer += this.recursiveCIDToString(output.components, rendered, output.onlyCids);
      } else if (isObject(rendered)) {
        this.toOutputBuffer(rendered, templates, output);
      } else {
        output.buffer += rendered;
      }
    }
    recursiveCIDToString(components, cid, onlyCids) {
      let component = components[cid] || logError(`no component for CID ${cid}`, components);
      let template = document.createElement("template");
      template.innerHTML = this.recursiveToString(component, components, onlyCids);
      let container = template.content;
      let skip = onlyCids && !onlyCids.has(cid);
      let [hasChildNodes, hasChildComponents] = Array.from(container.childNodes).reduce(([hasNodes, hasComponents], child, i) => {
        if (child.nodeType === Node.ELEMENT_NODE) {
          if (child.getAttribute(PHX_COMPONENT)) {
            return [hasNodes, true];
          }
          child.setAttribute(PHX_COMPONENT, cid);
          if (!child.id) {
            child.id = `${this.parentViewId()}-${cid}-${i}`;
          }
          if (skip) {
            child.setAttribute(PHX_SKIP, "");
            child.innerHTML = "";
          }
          return [true, hasComponents];
        } else {
          if (child.nodeValue.trim() !== "") {
            logError(`only HTML element tags are allowed at the root of components.

got: "${child.nodeValue.trim()}"

within:
`, template.innerHTML.trim());
            child.replaceWith(this.createSpan(child.nodeValue, cid));
            return [true, hasComponents];
          } else {
            child.remove();
            return [hasNodes, hasComponents];
          }
        }
      }, [false, false]);
      if (!hasChildNodes && !hasChildComponents) {
        logError("expected at least one HTML element tag inside a component, but the component is empty:\n", template.innerHTML.trim());
        return this.createSpan("", cid).outerHTML;
      } else if (!hasChildNodes && hasChildComponents) {
        logError("expected at least one HTML element tag directly inside a component, but only subcomponents were found. A component must render at least one HTML tag directly inside itself.", template.innerHTML.trim());
        return template.innerHTML;
      } else {
        return template.innerHTML;
      }
    }
    createSpan(text, cid) {
      let span = document.createElement("span");
      span.innerText = text;
      span.setAttribute(PHX_COMPONENT, cid);
      return span;
    }
  };
  var viewHookID = 1;
  var ViewHook = class {
    static makeID() {
      return viewHookID++;
    }
    static elementID(el) {
      return el.phxHookId;
    }
    constructor(view, el, callbacks) {
      this.__view = view;
      this.liveSocket = view.liveSocket;
      this.__callbacks = callbacks;
      this.__listeners = /* @__PURE__ */ new Set();
      this.__isDisconnected = false;
      this.el = el;
      this.el.phxHookId = this.constructor.makeID();
      for (let key in this.__callbacks) {
        this[key] = this.__callbacks[key];
      }
    }
    __mounted() {
      this.mounted && this.mounted();
    }
    __updated() {
      this.updated && this.updated();
    }
    __beforeUpdate() {
      this.beforeUpdate && this.beforeUpdate();
    }
    __destroyed() {
      this.destroyed && this.destroyed();
    }
    __reconnected() {
      if (this.__isDisconnected) {
        this.__isDisconnected = false;
        this.reconnected && this.reconnected();
      }
    }
    __disconnected() {
      this.__isDisconnected = true;
      this.disconnected && this.disconnected();
    }
    pushEvent(event, payload = {}, onReply = function() {
    }) {
      return this.__view.pushHookEvent(null, event, payload, onReply);
    }
    pushEventTo(phxTarget, event, payload = {}, onReply = function() {
    }) {
      return this.__view.withinTargets(phxTarget, (view, targetCtx) => {
        return view.pushHookEvent(targetCtx, event, payload, onReply);
      });
    }
    handleEvent(event, callback) {
      let callbackRef = (customEvent, bypass) => bypass ? event : callback(customEvent.detail);
      window.addEventListener(`phx:${event}`, callbackRef);
      this.__listeners.add(callbackRef);
      return callbackRef;
    }
    removeHandleEvent(callbackRef) {
      let event = callbackRef(null, true);
      window.removeEventListener(`phx:${event}`, callbackRef);
      this.__listeners.delete(callbackRef);
    }
    upload(name, files) {
      return this.__view.dispatchUploads(name, files);
    }
    uploadTo(phxTarget, name, files) {
      return this.__view.withinTargets(phxTarget, (view) => view.dispatchUploads(name, files));
    }
    __cleanup__() {
      this.__listeners.forEach((callbackRef) => this.removeHandleEvent(callbackRef));
    }
  };
  var JS = {
    exec(eventType, phxEvent, view, sourceEl, defaults) {
      let [defaultKind, defaultArgs] = defaults || [null, {}];
      let commands = phxEvent.charAt(0) === "[" ? JSON.parse(phxEvent) : [[defaultKind, defaultArgs]];
      commands.forEach(([kind, args]) => {
        if (kind === defaultKind && defaultArgs.data) {
          args.data = Object.assign(args.data || {}, defaultArgs.data);
        }
        this.filterToEls(sourceEl, args).forEach((el) => {
          this[`exec_${kind}`](eventType, phxEvent, view, sourceEl, el, args);
        });
      });
    },
    isVisible(el) {
      return !!(el.offsetWidth || el.offsetHeight || el.getClientRects().length > 0);
    },
    exec_dispatch(eventType, phxEvent, view, sourceEl, el, { to, event, detail, bubbles }) {
      detail = detail || {};
      detail.dispatcher = sourceEl;
      dom_default.dispatchEvent(el, event, { detail, bubbles });
    },
    exec_push(eventType, phxEvent, view, sourceEl, el, args) {
      if (!view.isConnected()) {
        return;
      }
      let { event, data: data2, target, page_loading, loading, value, dispatcher } = args;
      let pushOpts = { loading, value, target, page_loading: !!page_loading };
      let targetSrc = eventType === "change" && dispatcher ? dispatcher : sourceEl;
      let phxTarget = target || targetSrc.getAttribute(view.binding("target")) || targetSrc;
      view.withinTargets(phxTarget, (targetView, targetCtx) => {
        if (eventType === "change") {
          let { newCid, _target, callback } = args;
          _target = _target || (sourceEl instanceof HTMLInputElement ? sourceEl.name : void 0);
          if (_target) {
            pushOpts._target = _target;
          }
          targetView.pushInput(sourceEl, targetCtx, newCid, event || phxEvent, pushOpts, callback);
        } else if (eventType === "submit") {
          targetView.submitForm(sourceEl, targetCtx, event || phxEvent, pushOpts);
        } else {
          targetView.pushEvent(eventType, sourceEl, targetCtx, event || phxEvent, data2, pushOpts);
        }
      });
    },
    exec_add_class(eventType, phxEvent, view, sourceEl, el, { names, transition: transition2, time }) {
      this.addOrRemoveClasses(el, names, [], transition2, time, view);
    },
    exec_remove_class(eventType, phxEvent, view, sourceEl, el, { names, transition: transition2, time }) {
      this.addOrRemoveClasses(el, [], names, transition2, time, view);
    },
    exec_transition(eventType, phxEvent, view, sourceEl, el, { time, transition: transition2 }) {
      let [transition_start, running, transition_end] = transition2;
      let onStart = () => this.addOrRemoveClasses(el, transition_start.concat(running), []);
      let onDone = () => this.addOrRemoveClasses(el, transition_end, transition_start.concat(running));
      view.transition(time, onStart, onDone);
    },
    exec_toggle(eventType, phxEvent, view, sourceEl, el, { display, ins, outs, time }) {
      this.toggle(eventType, view, el, display, ins, outs, time);
    },
    exec_show(eventType, phxEvent, view, sourceEl, el, { display, transition: transition2, time }) {
      this.show(eventType, view, el, display, transition2, time);
    },
    exec_hide(eventType, phxEvent, view, sourceEl, el, { display, transition: transition2, time }) {
      this.hide(eventType, view, el, display, transition2, time);
    },
    exec_set_attr(eventType, phxEvent, view, sourceEl, el, { attr: [attr, val] }) {
      this.setOrRemoveAttrs(el, [[attr, val]], []);
    },
    exec_remove_attr(eventType, phxEvent, view, sourceEl, el, { attr }) {
      this.setOrRemoveAttrs(el, [], [attr]);
    },
    show(eventType, view, el, display, transition2, time) {
      if (!this.isVisible(el)) {
        this.toggle(eventType, view, el, display, transition2, null, time);
      }
    },
    hide(eventType, view, el, display, transition2, time) {
      if (this.isVisible(el)) {
        this.toggle(eventType, view, el, display, null, transition2, time);
      }
    },
    toggle(eventType, view, el, display, ins, outs, time) {
      let [inClasses, inStartClasses, inEndClasses] = ins || [[], [], []];
      let [outClasses, outStartClasses, outEndClasses] = outs || [[], [], []];
      if (inClasses.length > 0 || outClasses.length > 0) {
        if (this.isVisible(el)) {
          let onStart = () => {
            this.addOrRemoveClasses(el, outStartClasses, inClasses.concat(inStartClasses).concat(inEndClasses));
            window.requestAnimationFrame(() => {
              this.addOrRemoveClasses(el, outClasses, []);
              window.requestAnimationFrame(() => this.addOrRemoveClasses(el, outEndClasses, outStartClasses));
            });
          };
          el.dispatchEvent(new Event("phx:hide-start"));
          view.transition(time, onStart, () => {
            this.addOrRemoveClasses(el, [], outClasses.concat(outEndClasses));
            dom_default.putSticky(el, "toggle", (currentEl) => currentEl.style.display = "none");
            el.dispatchEvent(new Event("phx:hide-end"));
          });
        } else {
          if (eventType === "remove") {
            return;
          }
          let onStart = () => {
            this.addOrRemoveClasses(el, inStartClasses, outClasses.concat(outStartClasses).concat(outEndClasses));
            dom_default.putSticky(el, "toggle", (currentEl) => currentEl.style.display = display || "block");
            window.requestAnimationFrame(() => {
              this.addOrRemoveClasses(el, inClasses, []);
              window.requestAnimationFrame(() => this.addOrRemoveClasses(el, inEndClasses, inStartClasses));
            });
          };
          el.dispatchEvent(new Event("phx:show-start"));
          view.transition(time, onStart, () => {
            this.addOrRemoveClasses(el, [], inClasses.concat(inEndClasses));
            el.dispatchEvent(new Event("phx:show-end"));
          });
        }
      } else {
        if (this.isVisible(el)) {
          window.requestAnimationFrame(() => {
            el.dispatchEvent(new Event("phx:hide-start"));
            dom_default.putSticky(el, "toggle", (currentEl) => currentEl.style.display = "none");
            el.dispatchEvent(new Event("phx:hide-end"));
          });
        } else {
          window.requestAnimationFrame(() => {
            el.dispatchEvent(new Event("phx:show-start"));
            dom_default.putSticky(el, "toggle", (currentEl) => currentEl.style.display = display || "block");
            el.dispatchEvent(new Event("phx:show-end"));
          });
        }
      }
    },
    addOrRemoveClasses(el, adds, removes, transition2, time, view) {
      let [transition_run, transition_start, transition_end] = transition2 || [[], [], []];
      if (transition_run.length > 0) {
        let onStart = () => this.addOrRemoveClasses(el, transition_start.concat(transition_run), []);
        let onDone = () => this.addOrRemoveClasses(el, adds.concat(transition_end), removes.concat(transition_run).concat(transition_start));
        return view.transition(time, onStart, onDone);
      }
      window.requestAnimationFrame(() => {
        let [prevAdds, prevRemoves] = dom_default.getSticky(el, "classes", [[], []]);
        let keepAdds = adds.filter((name) => prevAdds.indexOf(name) < 0 && !el.classList.contains(name));
        let keepRemoves = removes.filter((name) => prevRemoves.indexOf(name) < 0 && el.classList.contains(name));
        let newAdds = prevAdds.filter((name) => removes.indexOf(name) < 0).concat(keepAdds);
        let newRemoves = prevRemoves.filter((name) => adds.indexOf(name) < 0).concat(keepRemoves);
        dom_default.putSticky(el, "classes", (currentEl) => {
          currentEl.classList.remove(...newRemoves);
          currentEl.classList.add(...newAdds);
          return [newAdds, newRemoves];
        });
      });
    },
    setOrRemoveAttrs(el, sets, removes) {
      let [prevSets, prevRemoves] = dom_default.getSticky(el, "attrs", [[], []]);
      let alteredAttrs = sets.map(([attr, _val]) => attr).concat(removes);
      let newSets = prevSets.filter(([attr, _val]) => !alteredAttrs.includes(attr)).concat(sets);
      let newRemoves = prevRemoves.filter((attr) => !alteredAttrs.includes(attr)).concat(removes);
      dom_default.putSticky(el, "attrs", (currentEl) => {
        newRemoves.forEach((attr) => currentEl.removeAttribute(attr));
        newSets.forEach(([attr, val]) => currentEl.setAttribute(attr, val));
        return [newSets, newRemoves];
      });
    },
    hasAllClasses(el, classes) {
      return classes.every((name) => el.classList.contains(name));
    },
    isToggledOut(el, outClasses) {
      return !this.isVisible(el) || this.hasAllClasses(el, outClasses);
    },
    filterToEls(sourceEl, { to }) {
      return to ? dom_default.all(document, to) : [sourceEl];
    }
  };
  var js_default = JS;
  var serializeForm = (form, meta, onlyNames = []) => {
    let formData = new FormData(form);
    let toRemove = [];
    formData.forEach((val, key, _index) => {
      if (val instanceof File) {
        toRemove.push(key);
      }
    });
    toRemove.forEach((key) => formData.delete(key));
    let params = new URLSearchParams();
    for (let [key, val] of formData.entries()) {
      if (onlyNames.length === 0 || onlyNames.indexOf(key) >= 0) {
        params.append(key, val);
      }
    }
    for (let metaKey in meta) {
      params.append(metaKey, meta[metaKey]);
    }
    return params.toString();
  };
  var View = class {
    constructor(el, liveSocket2, parentView, flash) {
      this.liveSocket = liveSocket2;
      this.flash = flash;
      this.parent = parentView;
      this.root = parentView ? parentView.root : this;
      this.el = el;
      this.id = this.el.id;
      this.ref = 0;
      this.childJoins = 0;
      this.loaderTimer = null;
      this.pendingDiffs = [];
      this.pruningCIDs = [];
      this.redirect = false;
      this.href = null;
      this.joinCount = this.parent ? this.parent.joinCount - 1 : 0;
      this.joinPending = true;
      this.destroyed = false;
      this.joinCallback = function(onDone) {
        onDone && onDone();
      };
      this.stopCallback = function() {
      };
      this.pendingJoinOps = this.parent ? null : [];
      this.viewHooks = {};
      this.uploaders = {};
      this.formSubmits = [];
      this.children = this.parent ? null : {};
      this.root.children[this.id] = {};
      this.channel = this.liveSocket.channel(`lv:${this.id}`, () => {
        return {
          redirect: this.redirect ? this.href : void 0,
          url: this.redirect ? void 0 : this.href || void 0,
          params: this.connectParams(),
          session: this.getSession(),
          static: this.getStatic(),
          flash: this.flash
        };
      });
      this.showLoader(this.liveSocket.loaderTimeout);
      this.bindChannel();
    }
    setHref(href) {
      this.href = href;
    }
    setRedirect(href) {
      this.redirect = true;
      this.href = href;
    }
    isMain() {
      return this.el.getAttribute(PHX_MAIN) !== null;
    }
    connectParams() {
      let params = this.liveSocket.params(this.el);
      let manifest = dom_default.all(document, `[${this.binding(PHX_TRACK_STATIC)}]`).map((node) => node.src || node.href).filter((url) => typeof url === "string");
      if (manifest.length > 0) {
        params["_track_static"] = manifest;
      }
      params["_mounts"] = this.joinCount;
      return params;
    }
    isConnected() {
      return this.channel.canPush();
    }
    getSession() {
      return this.el.getAttribute(PHX_SESSION);
    }
    getStatic() {
      let val = this.el.getAttribute(PHX_STATIC);
      return val === "" ? null : val;
    }
    destroy(callback = function() {
    }) {
      this.destroyAllChildren();
      this.destroyed = true;
      delete this.root.children[this.id];
      if (this.parent) {
        delete this.root.children[this.parent.id][this.id];
      }
      clearTimeout(this.loaderTimer);
      let onFinished = () => {
        callback();
        for (let id in this.viewHooks) {
          this.destroyHook(this.viewHooks[id]);
        }
      };
      dom_default.markPhxChildDestroyed(this.el);
      this.log("destroyed", () => ["the child has been removed from the parent"]);
      this.channel.leave().receive("ok", onFinished).receive("error", onFinished).receive("timeout", onFinished);
    }
    setContainerClasses(...classes) {
      this.el.classList.remove(PHX_CONNECTED_CLASS, PHX_DISCONNECTED_CLASS, PHX_ERROR_CLASS);
      this.el.classList.add(...classes);
    }
    showLoader(timeout) {
      clearTimeout(this.loaderTimer);
      if (timeout) {
        this.loaderTimer = setTimeout(() => this.showLoader(), timeout);
      } else {
        for (let id in this.viewHooks) {
          this.viewHooks[id].__disconnected();
        }
        this.setContainerClasses(PHX_DISCONNECTED_CLASS);
      }
    }
    hideLoader() {
      clearTimeout(this.loaderTimer);
      this.setContainerClasses(PHX_CONNECTED_CLASS);
    }
    triggerReconnected() {
      for (let id in this.viewHooks) {
        this.viewHooks[id].__reconnected();
      }
    }
    log(kind, msgCallback) {
      this.liveSocket.log(this, kind, msgCallback);
    }
    transition(time, onStart, onDone = function() {
    }) {
      this.liveSocket.transition(time, onStart, onDone);
    }
    withinTargets(phxTarget, callback) {
      if (phxTarget instanceof HTMLElement || phxTarget instanceof SVGElement) {
        return this.liveSocket.owner(phxTarget, (view) => callback(view, phxTarget));
      }
      if (isCid(phxTarget)) {
        let targets = dom_default.findComponentNodeList(this.el, phxTarget);
        if (targets.length === 0) {
          logError(`no component found matching phx-target of ${phxTarget}`);
        } else {
          callback(this, parseInt(phxTarget));
        }
      } else {
        let targets = Array.from(document.querySelectorAll(phxTarget));
        if (targets.length === 0) {
          logError(`nothing found matching the phx-target selector "${phxTarget}"`);
        }
        targets.forEach((target) => this.liveSocket.owner(target, (view) => callback(view, target)));
      }
    }
    applyDiff(type, rawDiff, callback) {
      this.log(type, () => ["", clone(rawDiff)]);
      let { diff, reply, events, title } = Rendered.extract(rawDiff);
      if (title) {
        dom_default.putTitle(title);
      }
      callback({ diff, reply, events });
      return reply;
    }
    onJoin(resp) {
      let { rendered, container } = resp;
      if (container) {
        let [tag, attrs] = container;
        this.el = dom_default.replaceRootContainer(this.el, tag, attrs);
      }
      this.childJoins = 0;
      this.joinPending = true;
      this.flash = null;
      browser_default.dropLocal(this.liveSocket.localStorage, window.location.pathname, CONSECUTIVE_RELOADS);
      this.applyDiff("mount", rendered, ({ diff, events }) => {
        this.rendered = new Rendered(this.id, diff);
        let html = this.renderContainer(null, "join");
        this.dropPendingRefs();
        let forms = this.formsForRecovery(html);
        this.joinCount++;
        if (forms.length > 0) {
          forms.forEach(([form, newForm, newCid], i) => {
            this.pushFormRecovery(form, newCid, (resp2) => {
              if (i === forms.length - 1) {
                this.onJoinComplete(resp2, html, events);
              }
            });
          });
        } else {
          this.onJoinComplete(resp, html, events);
        }
      });
    }
    dropPendingRefs() {
      dom_default.all(document, `[${PHX_REF_SRC}="${this.id}"][${PHX_REF}]`, (el) => {
        el.removeAttribute(PHX_REF);
        el.removeAttribute(PHX_REF_SRC);
      });
    }
    onJoinComplete({ live_patch }, html, events) {
      if (this.joinCount > 1 || this.parent && !this.parent.isJoinPending()) {
        return this.applyJoinPatch(live_patch, html, events);
      }
      let newChildren = dom_default.findPhxChildrenInFragment(html, this.id).filter((toEl) => {
        let fromEl = toEl.id && this.el.querySelector(`[id="${toEl.id}"]`);
        let phxStatic = fromEl && fromEl.getAttribute(PHX_STATIC);
        if (phxStatic) {
          toEl.setAttribute(PHX_STATIC, phxStatic);
        }
        return this.joinChild(toEl);
      });
      if (newChildren.length === 0) {
        if (this.parent) {
          this.root.pendingJoinOps.push([this, () => this.applyJoinPatch(live_patch, html, events)]);
          this.parent.ackJoin(this);
        } else {
          this.onAllChildJoinsComplete();
          this.applyJoinPatch(live_patch, html, events);
        }
      } else {
        this.root.pendingJoinOps.push([this, () => this.applyJoinPatch(live_patch, html, events)]);
      }
    }
    attachTrueDocEl() {
      this.el = dom_default.byId(this.id);
      this.el.setAttribute(PHX_ROOT_ID, this.root.id);
    }
    applyJoinPatch(live_patch, html, events) {
      this.attachTrueDocEl();
      let patch = new DOMPatch(this, this.el, this.id, html, null);
      patch.markPrunableContentForRemoval();
      this.performPatch(patch, false);
      this.joinNewChildren();
      dom_default.all(this.el, `[${this.binding(PHX_HOOK)}], [data-phx-${PHX_HOOK}]`, (hookEl) => {
        let hook = this.addHook(hookEl);
        if (hook) {
          hook.__mounted();
        }
      });
      this.joinPending = false;
      this.liveSocket.dispatchEvents(events);
      this.applyPendingUpdates();
      if (live_patch) {
        let { kind, to } = live_patch;
        this.liveSocket.historyPatch(to, kind);
      }
      this.hideLoader();
      if (this.joinCount > 1) {
        this.triggerReconnected();
      }
      this.stopCallback();
    }
    triggerBeforeUpdateHook(fromEl, toEl) {
      this.liveSocket.triggerDOM("onBeforeElUpdated", [fromEl, toEl]);
      let hook = this.getHook(fromEl);
      let isIgnored = hook && dom_default.isIgnored(fromEl, this.binding(PHX_UPDATE));
      if (hook && !fromEl.isEqualNode(toEl) && !(isIgnored && isEqualObj(fromEl.dataset, toEl.dataset))) {
        hook.__beforeUpdate();
        return hook;
      }
    }
    performPatch(patch, pruneCids) {
      let removedEls = [];
      let phxChildrenAdded = false;
      let updatedHookIds = /* @__PURE__ */ new Set();
      patch.after("added", (el) => {
        this.liveSocket.triggerDOM("onNodeAdded", [el]);
        let newHook = this.addHook(el);
        if (newHook) {
          newHook.__mounted();
        }
      });
      patch.after("phxChildAdded", (el) => {
        if (dom_default.isPhxSticky(el)) {
          this.liveSocket.joinRootViews();
        } else {
          phxChildrenAdded = true;
        }
      });
      patch.before("updated", (fromEl, toEl) => {
        let hook = this.triggerBeforeUpdateHook(fromEl, toEl);
        if (hook) {
          updatedHookIds.add(fromEl.id);
        }
      });
      patch.after("updated", (el) => {
        if (updatedHookIds.has(el.id)) {
          this.getHook(el).__updated();
        }
      });
      patch.after("discarded", (el) => {
        if (el.nodeType === Node.ELEMENT_NODE) {
          removedEls.push(el);
        }
      });
      patch.after("transitionsDiscarded", (els) => this.afterElementsRemoved(els, pruneCids));
      patch.perform();
      this.afterElementsRemoved(removedEls, pruneCids);
      return phxChildrenAdded;
    }
    afterElementsRemoved(elements, pruneCids) {
      let destroyedCIDs = [];
      elements.forEach((parent) => {
        let components = dom_default.all(parent, `[${PHX_COMPONENT}]`);
        let hooks = dom_default.all(parent, `[${this.binding(PHX_HOOK)}]`);
        components.concat(parent).forEach((el) => {
          let cid = this.componentID(el);
          if (isCid(cid) && destroyedCIDs.indexOf(cid) === -1) {
            destroyedCIDs.push(cid);
          }
        });
        hooks.concat(parent).forEach((hookEl) => {
          let hook = this.getHook(hookEl);
          hook && this.destroyHook(hook);
        });
      });
      if (pruneCids) {
        this.maybePushComponentsDestroyed(destroyedCIDs);
      }
    }
    joinNewChildren() {
      dom_default.findPhxChildren(this.el, this.id).forEach((el) => this.joinChild(el));
    }
    getChildById(id) {
      return this.root.children[this.id][id];
    }
    getDescendentByEl(el) {
      if (el.id === this.id) {
        return this;
      } else {
        return this.children[el.getAttribute(PHX_PARENT_ID)][el.id];
      }
    }
    destroyDescendent(id) {
      for (let parentId in this.root.children) {
        for (let childId in this.root.children[parentId]) {
          if (childId === id) {
            return this.root.children[parentId][childId].destroy();
          }
        }
      }
    }
    joinChild(el) {
      let child = this.getChildById(el.id);
      if (!child) {
        let view = new View(el, this.liveSocket, this);
        this.root.children[this.id][view.id] = view;
        view.join();
        this.childJoins++;
        return true;
      }
    }
    isJoinPending() {
      return this.joinPending;
    }
    ackJoin(_child) {
      this.childJoins--;
      if (this.childJoins === 0) {
        if (this.parent) {
          this.parent.ackJoin(this);
        } else {
          this.onAllChildJoinsComplete();
        }
      }
    }
    onAllChildJoinsComplete() {
      this.joinCallback(() => {
        this.pendingJoinOps.forEach(([view, op]) => {
          if (!view.isDestroyed()) {
            op();
          }
        });
        this.pendingJoinOps = [];
      });
    }
    update(diff, events) {
      if (this.isJoinPending() || this.liveSocket.hasPendingLink() && !dom_default.isPhxSticky(this.el)) {
        return this.pendingDiffs.push({ diff, events });
      }
      this.rendered.mergeDiff(diff);
      let phxChildrenAdded = false;
      if (this.rendered.isComponentOnlyDiff(diff)) {
        this.liveSocket.time("component patch complete", () => {
          let parentCids = dom_default.findParentCIDs(this.el, this.rendered.componentCIDs(diff));
          parentCids.forEach((parentCID) => {
            if (this.componentPatch(this.rendered.getComponent(diff, parentCID), parentCID)) {
              phxChildrenAdded = true;
            }
          });
        });
      } else if (!isEmpty(diff)) {
        this.liveSocket.time("full patch complete", () => {
          let html = this.renderContainer(diff, "update");
          let patch = new DOMPatch(this, this.el, this.id, html, null);
          phxChildrenAdded = this.performPatch(patch, true);
        });
      }
      this.liveSocket.dispatchEvents(events);
      if (phxChildrenAdded) {
        this.joinNewChildren();
      }
    }
    renderContainer(diff, kind) {
      return this.liveSocket.time(`toString diff (${kind})`, () => {
        let tag = this.el.tagName;
        let cids = diff ? this.rendered.componentCIDs(diff).concat(this.pruningCIDs) : null;
        let html = this.rendered.toString(cids);
        return `<${tag}>${html}</${tag}>`;
      });
    }
    componentPatch(diff, cid) {
      if (isEmpty(diff))
        return false;
      let html = this.rendered.componentToString(cid);
      let patch = new DOMPatch(this, this.el, this.id, html, cid);
      let childrenAdded = this.performPatch(patch, true);
      return childrenAdded;
    }
    getHook(el) {
      return this.viewHooks[ViewHook.elementID(el)];
    }
    addHook(el) {
      if (ViewHook.elementID(el) || !el.getAttribute) {
        return;
      }
      let hookName = el.getAttribute(`data-phx-${PHX_HOOK}`) || el.getAttribute(this.binding(PHX_HOOK));
      if (hookName && !this.ownsElement(el)) {
        return;
      }
      let callbacks = this.liveSocket.getHookCallbacks(hookName);
      if (callbacks) {
        if (!el.id) {
          logError(`no DOM ID for hook "${hookName}". Hooks require a unique ID on each element.`, el);
        }
        let hook = new ViewHook(this, el, callbacks);
        this.viewHooks[ViewHook.elementID(hook.el)] = hook;
        return hook;
      } else if (hookName !== null) {
        logError(`unknown hook found for "${hookName}"`, el);
      }
    }
    destroyHook(hook) {
      hook.__destroyed();
      hook.__cleanup__();
      delete this.viewHooks[ViewHook.elementID(hook.el)];
    }
    applyPendingUpdates() {
      this.pendingDiffs.forEach(({ diff, events }) => this.update(diff, events));
      this.pendingDiffs = [];
    }
    onChannel(event, cb) {
      this.liveSocket.onChannel(this.channel, event, (resp) => {
        if (this.isJoinPending()) {
          this.root.pendingJoinOps.push([this, () => cb(resp)]);
        } else {
          this.liveSocket.requestDOMUpdate(() => cb(resp));
        }
      });
    }
    bindChannel() {
      this.liveSocket.onChannel(this.channel, "diff", (rawDiff) => {
        this.liveSocket.requestDOMUpdate(() => {
          this.applyDiff("update", rawDiff, ({ diff, events }) => this.update(diff, events));
        });
      });
      this.onChannel("redirect", ({ to, flash }) => this.onRedirect({ to, flash }));
      this.onChannel("live_patch", (redir) => this.onLivePatch(redir));
      this.onChannel("live_redirect", (redir) => this.onLiveRedirect(redir));
      this.channel.onError((reason) => this.onError(reason));
      this.channel.onClose((reason) => this.onClose(reason));
    }
    destroyAllChildren() {
      for (let id in this.root.children[this.id]) {
        this.getChildById(id).destroy();
      }
    }
    onLiveRedirect(redir) {
      let { to, kind, flash } = redir;
      let url = this.expandURL(to);
      this.liveSocket.historyRedirect(url, kind, flash);
    }
    onLivePatch(redir) {
      let { to, kind } = redir;
      this.href = this.expandURL(to);
      this.liveSocket.historyPatch(to, kind);
    }
    expandURL(to) {
      return to.startsWith("/") ? `${window.location.protocol}//${window.location.host}${to}` : to;
    }
    onRedirect({ to, flash }) {
      this.liveSocket.redirect(to, flash);
    }
    isDestroyed() {
      return this.destroyed;
    }
    join(callback) {
      if (this.isMain()) {
        this.stopCallback = this.liveSocket.withPageLoading({ to: this.href, kind: "initial" });
      }
      this.joinCallback = (onDone) => {
        onDone = onDone || function() {
        };
        callback ? callback(this.joinCount, onDone) : onDone();
      };
      this.liveSocket.wrapPush(this, { timeout: false }, () => {
        return this.channel.join().receive("ok", (data2) => {
          if (!this.isDestroyed()) {
            this.liveSocket.requestDOMUpdate(() => this.onJoin(data2));
          }
        }).receive("error", (resp) => !this.isDestroyed() && this.onJoinError(resp)).receive("timeout", () => !this.isDestroyed() && this.onJoinError({ reason: "timeout" }));
      });
    }
    onJoinError(resp) {
      if (resp.reason === "unauthorized" || resp.reason === "stale") {
        this.log("error", () => ["unauthorized live_redirect. Falling back to page request", resp]);
        return this.onRedirect({ to: this.href });
      }
      if (resp.redirect || resp.live_redirect) {
        this.joinPending = false;
        this.channel.leave();
      }
      if (resp.redirect) {
        return this.onRedirect(resp.redirect);
      }
      if (resp.live_redirect) {
        return this.onLiveRedirect(resp.live_redirect);
      }
      this.log("error", () => ["unable to join", resp]);
      return this.liveSocket.reloadWithJitter(this);
    }
    onClose(reason) {
      if (this.isDestroyed()) {
        return;
      }
      if (this.isJoinPending() && document.visibilityState !== "hidden" || this.liveSocket.hasPendingLink() && reason !== "leave") {
        return this.liveSocket.reloadWithJitter(this);
      }
      this.destroyAllChildren();
      this.liveSocket.dropActiveElement(this);
      if (document.activeElement) {
        document.activeElement.blur();
      }
      if (this.liveSocket.isUnloaded()) {
        this.showLoader(BEFORE_UNLOAD_LOADER_TIMEOUT);
      }
    }
    onError(reason) {
      this.onClose(reason);
      this.log("error", () => ["view crashed", reason]);
      if (!this.liveSocket.isUnloaded()) {
        this.displayError();
      }
    }
    displayError() {
      if (this.isMain()) {
        dom_default.dispatchEvent(window, "phx:page-loading-start", { detail: { to: this.href, kind: "error" } });
      }
      this.showLoader();
      this.setContainerClasses(PHX_DISCONNECTED_CLASS, PHX_ERROR_CLASS);
    }
    pushWithReply(refGenerator, event, payload, onReply = function() {
    }) {
      if (!this.isConnected()) {
        return;
      }
      let [ref, [el], opts] = refGenerator ? refGenerator() : [null, [], {}];
      let onLoadingDone = function() {
      };
      if (opts.page_loading || el && el.getAttribute(this.binding(PHX_PAGE_LOADING)) !== null) {
        onLoadingDone = this.liveSocket.withPageLoading({ kind: "element", target: el });
      }
      if (typeof payload.cid !== "number") {
        delete payload.cid;
      }
      return this.liveSocket.wrapPush(this, { timeout: true }, () => {
        return this.channel.push(event, payload, PUSH_TIMEOUT).receive("ok", (resp) => {
          if (ref !== null) {
            this.undoRefs(ref);
          }
          let finish = (hookReply) => {
            if (resp.redirect) {
              this.onRedirect(resp.redirect);
            }
            if (resp.live_patch) {
              this.onLivePatch(resp.live_patch);
            }
            if (resp.live_redirect) {
              this.onLiveRedirect(resp.live_redirect);
            }
            onLoadingDone();
            onReply(resp, hookReply);
          };
          if (resp.diff) {
            this.liveSocket.requestDOMUpdate(() => {
              let hookReply = this.applyDiff("update", resp.diff, ({ diff, events }) => {
                this.update(diff, events);
              });
              finish(hookReply);
            });
          } else {
            finish(null);
          }
        });
      });
    }
    undoRefs(ref) {
      dom_default.all(document, `[${PHX_REF_SRC}="${this.id}"][${PHX_REF}="${ref}"]`, (el) => {
        let disabledVal = el.getAttribute(PHX_DISABLED);
        el.removeAttribute(PHX_REF);
        el.removeAttribute(PHX_REF_SRC);
        if (el.getAttribute(PHX_READONLY) !== null) {
          el.readOnly = false;
          el.removeAttribute(PHX_READONLY);
        }
        if (disabledVal !== null) {
          el.disabled = disabledVal === "true" ? true : false;
          el.removeAttribute(PHX_DISABLED);
        }
        PHX_EVENT_CLASSES.forEach((className) => dom_default.removeClass(el, className));
        let disableRestore = el.getAttribute(PHX_DISABLE_WITH_RESTORE);
        if (disableRestore !== null) {
          el.innerText = disableRestore;
          el.removeAttribute(PHX_DISABLE_WITH_RESTORE);
        }
        let toEl = dom_default.private(el, PHX_REF);
        if (toEl) {
          let hook = this.triggerBeforeUpdateHook(el, toEl);
          DOMPatch.patchEl(el, toEl, this.liveSocket.getActiveElement());
          if (hook) {
            hook.__updated();
          }
          dom_default.deletePrivate(el, PHX_REF);
        }
      });
    }
    putRef(elements, event, opts = {}) {
      let newRef = this.ref++;
      let disableWith = this.binding(PHX_DISABLE_WITH);
      if (opts.loading) {
        elements = elements.concat(dom_default.all(document, opts.loading));
      }
      elements.forEach((el) => {
        el.classList.add(`phx-${event}-loading`);
        el.setAttribute(PHX_REF, newRef);
        el.setAttribute(PHX_REF_SRC, this.el.id);
        let disableText = el.getAttribute(disableWith);
        if (disableText !== null) {
          if (!el.getAttribute(PHX_DISABLE_WITH_RESTORE)) {
            el.setAttribute(PHX_DISABLE_WITH_RESTORE, el.innerText);
          }
          if (disableText !== "") {
            el.innerText = disableText;
          }
          el.setAttribute("disabled", "");
        }
      });
      return [newRef, elements, opts];
    }
    componentID(el) {
      let cid = el.getAttribute && el.getAttribute(PHX_COMPONENT);
      return cid ? parseInt(cid) : null;
    }
    targetComponentID(target, targetCtx, opts = {}) {
      if (isCid(targetCtx)) {
        return targetCtx;
      }
      let cidOrSelector = target.getAttribute(this.binding("target"));
      if (isCid(cidOrSelector)) {
        return parseInt(cidOrSelector);
      } else if (targetCtx && (cidOrSelector !== null || opts.target)) {
        return this.closestComponentID(targetCtx);
      } else {
        return null;
      }
    }
    closestComponentID(targetCtx) {
      if (isCid(targetCtx)) {
        return targetCtx;
      } else if (targetCtx) {
        return maybe(targetCtx.closest(`[${PHX_COMPONENT}]`), (el) => this.ownsElement(el) && this.componentID(el));
      } else {
        return null;
      }
    }
    pushHookEvent(targetCtx, event, payload, onReply) {
      if (!this.isConnected()) {
        this.log("hook", () => ["unable to push hook event. LiveView not connected", event, payload]);
        return false;
      }
      let [ref, els, opts] = this.putRef([], "hook");
      this.pushWithReply(() => [ref, els, opts], "event", {
        type: "hook",
        event,
        value: payload,
        cid: this.closestComponentID(targetCtx)
      }, (resp, reply) => onReply(reply, ref));
      return ref;
    }
    extractMeta(el, meta, value) {
      let prefix2 = this.binding("value-");
      for (let i = 0; i < el.attributes.length; i++) {
        if (!meta) {
          meta = {};
        }
        let name = el.attributes[i].name;
        if (name.startsWith(prefix2)) {
          meta[name.replace(prefix2, "")] = el.getAttribute(name);
        }
      }
      if (el.value !== void 0) {
        if (!meta) {
          meta = {};
        }
        meta.value = el.value;
        if (el.tagName === "INPUT" && CHECKABLE_INPUTS.indexOf(el.type) >= 0 && !el.checked) {
          delete meta.value;
        }
      }
      if (value) {
        if (!meta) {
          meta = {};
        }
        for (let key in value) {
          meta[key] = value[key];
        }
      }
      return meta;
    }
    pushEvent(type, el, targetCtx, phxEvent, meta, opts = {}) {
      this.pushWithReply(() => this.putRef([el], type, opts), "event", {
        type,
        event: phxEvent,
        value: this.extractMeta(el, meta, opts.value),
        cid: this.targetComponentID(el, targetCtx, opts)
      });
    }
    pushFileProgress(fileEl, entryRef, progress, onReply = function() {
    }) {
      this.liveSocket.withinOwners(fileEl.form, (view, targetCtx) => {
        view.pushWithReply(null, "progress", {
          event: fileEl.getAttribute(view.binding(PHX_PROGRESS)),
          ref: fileEl.getAttribute(PHX_UPLOAD_REF),
          entry_ref: entryRef,
          progress,
          cid: view.targetComponentID(fileEl.form, targetCtx)
        }, onReply);
      });
    }
    pushInput(inputEl, targetCtx, forceCid, phxEvent, opts, callback) {
      let uploads;
      let cid = isCid(forceCid) ? forceCid : this.targetComponentID(inputEl.form, targetCtx);
      let refGenerator = () => this.putRef([inputEl, inputEl.form], "change", opts);
      let formData;
      if (inputEl.getAttribute(this.binding("change"))) {
        formData = serializeForm(inputEl.form, { _target: opts._target }, [inputEl.name]);
      } else {
        formData = serializeForm(inputEl.form, { _target: opts._target });
      }
      if (dom_default.isUploadInput(inputEl) && inputEl.files && inputEl.files.length > 0) {
        LiveUploader.trackFiles(inputEl, Array.from(inputEl.files));
      }
      uploads = LiveUploader.serializeUploads(inputEl);
      let event = {
        type: "form",
        event: phxEvent,
        value: formData,
        uploads,
        cid
      };
      this.pushWithReply(refGenerator, "event", event, (resp) => {
        dom_default.showError(inputEl, this.liveSocket.binding(PHX_FEEDBACK_FOR));
        if (dom_default.isUploadInput(inputEl) && inputEl.getAttribute("data-phx-auto-upload") !== null) {
          if (LiveUploader.filesAwaitingPreflight(inputEl).length > 0) {
            let [ref, _els] = refGenerator();
            this.uploadFiles(inputEl.form, targetCtx, ref, cid, (_uploads) => {
              callback && callback(resp);
              this.triggerAwaitingSubmit(inputEl.form);
            });
          }
        } else {
          callback && callback(resp);
        }
      });
    }
    triggerAwaitingSubmit(formEl) {
      let awaitingSubmit = this.getScheduledSubmit(formEl);
      if (awaitingSubmit) {
        let [_el, _ref, _opts, callback] = awaitingSubmit;
        this.cancelSubmit(formEl);
        callback();
      }
    }
    getScheduledSubmit(formEl) {
      return this.formSubmits.find(([el, _ref, _opts, _callback]) => el.isSameNode(formEl));
    }
    scheduleSubmit(formEl, ref, opts, callback) {
      if (this.getScheduledSubmit(formEl)) {
        return true;
      }
      this.formSubmits.push([formEl, ref, opts, callback]);
    }
    cancelSubmit(formEl) {
      this.formSubmits = this.formSubmits.filter(([el, ref, _callback]) => {
        if (el.isSameNode(formEl)) {
          this.undoRefs(ref);
          return false;
        } else {
          return true;
        }
      });
    }
    pushFormSubmit(formEl, targetCtx, phxEvent, opts, onReply) {
      let filterIgnored = (el) => {
        let userIgnored = closestPhxBinding(el, `${this.binding(PHX_UPDATE)}=ignore`, el.form);
        return !(userIgnored || closestPhxBinding(el, "data-phx-update=ignore", el.form));
      };
      let filterDisables = (el) => {
        return el.hasAttribute(this.binding(PHX_DISABLE_WITH));
      };
      let filterButton = (el) => el.tagName == "BUTTON";
      let filterInput = (el) => ["INPUT", "TEXTAREA", "SELECT"].includes(el.tagName);
      let refGenerator = () => {
        let formElements = Array.from(formEl.elements);
        let disables = formElements.filter(filterDisables);
        let buttons = formElements.filter(filterButton).filter(filterIgnored);
        let inputs = formElements.filter(filterInput).filter(filterIgnored);
        buttons.forEach((button) => {
          button.setAttribute(PHX_DISABLED, button.disabled);
          button.disabled = true;
        });
        inputs.forEach((input) => {
          input.setAttribute(PHX_READONLY, input.readOnly);
          input.readOnly = true;
          if (input.files) {
            input.setAttribute(PHX_DISABLED, input.disabled);
            input.disabled = true;
          }
        });
        formEl.setAttribute(this.binding(PHX_PAGE_LOADING), "");
        return this.putRef([formEl].concat(disables).concat(buttons).concat(inputs), "submit", opts);
      };
      let cid = this.targetComponentID(formEl, targetCtx);
      if (LiveUploader.hasUploadsInProgress(formEl)) {
        let [ref, _els] = refGenerator();
        let push = () => this.pushFormSubmit(formEl, targetCtx, phxEvent, opts, onReply);
        return this.scheduleSubmit(formEl, ref, opts, push);
      } else if (LiveUploader.inputsAwaitingPreflight(formEl).length > 0) {
        let [ref, els] = refGenerator();
        let proxyRefGen = () => [ref, els, opts];
        this.uploadFiles(formEl, targetCtx, ref, cid, (_uploads) => {
          let formData = serializeForm(formEl, {});
          this.pushWithReply(proxyRefGen, "event", {
            type: "form",
            event: phxEvent,
            value: formData,
            cid
          }, onReply);
        });
      } else {
        let formData = serializeForm(formEl, {});
        this.pushWithReply(refGenerator, "event", {
          type: "form",
          event: phxEvent,
          value: formData,
          cid
        }, onReply);
      }
    }
    uploadFiles(formEl, targetCtx, ref, cid, onComplete) {
      let joinCountAtUpload = this.joinCount;
      let inputEls = LiveUploader.activeFileInputs(formEl);
      let numFileInputsInProgress = inputEls.length;
      inputEls.forEach((inputEl) => {
        let uploader = new LiveUploader(inputEl, this, () => {
          numFileInputsInProgress--;
          if (numFileInputsInProgress === 0) {
            onComplete();
          }
        });
        this.uploaders[inputEl] = uploader;
        let entries = uploader.entries().map((entry) => entry.toPreflightPayload());
        let payload = {
          ref: inputEl.getAttribute(PHX_UPLOAD_REF),
          entries,
          cid: this.targetComponentID(inputEl.form, targetCtx)
        };
        this.log("upload", () => ["sending preflight request", payload]);
        this.pushWithReply(null, "allow_upload", payload, (resp) => {
          this.log("upload", () => ["got preflight response", resp]);
          if (resp.error) {
            this.undoRefs(ref);
            let [entry_ref, reason] = resp.error;
            this.log("upload", () => [`error for entry ${entry_ref}`, reason]);
          } else {
            let onError = (callback) => {
              this.channel.onError(() => {
                if (this.joinCount === joinCountAtUpload) {
                  callback();
                }
              });
            };
            uploader.initAdapterUpload(resp, onError, this.liveSocket);
          }
        });
      });
    }
    dispatchUploads(name, filesOrBlobs) {
      let inputs = dom_default.findUploadInputs(this.el).filter((el) => el.name === name);
      if (inputs.length === 0) {
        logError(`no live file inputs found matching the name "${name}"`);
      } else if (inputs.length > 1) {
        logError(`duplicate live file inputs found matching the name "${name}"`);
      } else {
        dom_default.dispatchEvent(inputs[0], PHX_TRACK_UPLOADS, { detail: { files: filesOrBlobs } });
      }
    }
    pushFormRecovery(form, newCid, callback) {
      this.liveSocket.withinOwners(form, (view, targetCtx) => {
        let input = form.elements[0];
        let phxEvent = form.getAttribute(this.binding(PHX_AUTO_RECOVER)) || form.getAttribute(this.binding("change"));
        js_default.exec("change", phxEvent, view, input, ["push", { _target: input.name, newCid, callback }]);
      });
    }
    pushLinkPatch(href, targetEl, callback) {
      let linkRef = this.liveSocket.setPendingLink(href);
      let refGen = targetEl ? () => this.putRef([targetEl], "click") : null;
      let fallback = () => this.liveSocket.redirect(window.location.href);
      let push = this.pushWithReply(refGen, "live_patch", { url: href }, (resp) => {
        this.liveSocket.requestDOMUpdate(() => {
          if (resp.link_redirect) {
            this.liveSocket.replaceMain(href, null, callback, linkRef);
          } else {
            if (this.liveSocket.commitPendingLink(linkRef)) {
              this.href = href;
            }
            this.applyPendingUpdates();
            callback && callback(linkRef);
          }
        });
      });
      if (push) {
        push.receive("timeout", fallback);
      } else {
        fallback();
      }
    }
    formsForRecovery(html) {
      if (this.joinCount === 0) {
        return [];
      }
      let phxChange = this.binding("change");
      let template = document.createElement("template");
      template.innerHTML = html;
      return dom_default.all(this.el, `form[${phxChange}]`).filter((form) => form.id && this.ownsElement(form)).filter((form) => form.elements.length > 0).filter((form) => form.getAttribute(this.binding(PHX_AUTO_RECOVER)) !== "ignore").map((form) => {
        let newForm = template.content.querySelector(`form[id="${form.id}"][${phxChange}="${form.getAttribute(phxChange)}"]`);
        if (newForm) {
          return [form, newForm, this.targetComponentID(newForm)];
        } else {
          return [form, null, null];
        }
      }).filter(([form, newForm, newCid]) => newForm);
    }
    maybePushComponentsDestroyed(destroyedCIDs) {
      let willDestroyCIDs = destroyedCIDs.filter((cid) => {
        return dom_default.findComponentNodeList(this.el, cid).length === 0;
      });
      if (willDestroyCIDs.length > 0) {
        this.pruningCIDs.push(...willDestroyCIDs);
        this.pushWithReply(null, "cids_will_destroy", { cids: willDestroyCIDs }, () => {
          this.pruningCIDs = this.pruningCIDs.filter((cid) => willDestroyCIDs.indexOf(cid) !== -1);
          let completelyDestroyCIDs = willDestroyCIDs.filter((cid) => {
            return dom_default.findComponentNodeList(this.el, cid).length === 0;
          });
          if (completelyDestroyCIDs.length > 0) {
            this.pushWithReply(null, "cids_destroyed", { cids: completelyDestroyCIDs }, (resp) => {
              this.rendered.pruneCIDs(resp.cids);
            });
          }
        });
      }
    }
    ownsElement(el) {
      return el.getAttribute(PHX_PARENT_ID) === this.id || maybe(el.closest(PHX_VIEW_SELECTOR), (node) => node.id) === this.id;
    }
    submitForm(form, targetCtx, phxEvent, opts = {}) {
      dom_default.putPrivate(form, PHX_HAS_SUBMITTED, true);
      let phxFeedback = this.liveSocket.binding(PHX_FEEDBACK_FOR);
      let inputs = Array.from(form.elements);
      this.liveSocket.blurActiveElement(this);
      this.pushFormSubmit(form, targetCtx, phxEvent, opts, () => {
        inputs.forEach((input) => dom_default.showError(input, phxFeedback));
        this.liveSocket.restorePreviouslyActiveFocus();
      });
    }
    binding(kind) {
      return this.liveSocket.binding(kind);
    }
  };
  var LiveSocket = class {
    constructor(url, phxSocket, opts = {}) {
      this.unloaded = false;
      if (!phxSocket || phxSocket.constructor.name === "Object") {
        throw new Error(`
      a phoenix Socket must be provided as the second argument to the LiveSocket constructor. For example:

          import {Socket} from "phoenix"
          import {LiveSocket} from "phoenix_live_view"
          let liveSocket = new LiveSocket("/live", Socket, {...})
      `);
      }
      this.socket = new phxSocket(url, opts);
      this.bindingPrefix = opts.bindingPrefix || BINDING_PREFIX;
      this.opts = opts;
      this.params = closure2(opts.params || {});
      this.viewLogger = opts.viewLogger;
      this.metadataCallbacks = opts.metadata || {};
      this.defaults = Object.assign(clone(DEFAULTS), opts.defaults || {});
      this.activeElement = null;
      this.prevActive = null;
      this.silenced = false;
      this.main = null;
      this.outgoingMainEl = null;
      this.clickStartedAtTarget = null;
      this.linkRef = 1;
      this.roots = {};
      this.href = window.location.href;
      this.pendingLink = null;
      this.currentLocation = clone(window.location);
      this.hooks = opts.hooks || {};
      this.uploaders = opts.uploaders || {};
      this.loaderTimeout = opts.loaderTimeout || LOADER_TIMEOUT;
      this.maxReloads = opts.maxReloads || MAX_RELOADS;
      this.reloadJitterMin = opts.reloadJitterMin || RELOAD_JITTER_MIN;
      this.reloadJitterMax = opts.reloadJitterMax || RELOAD_JITTER_MAX;
      this.failsafeJitter = opts.failsafeJitter || FAILSAFE_JITTER;
      this.localStorage = opts.localStorage || window.localStorage;
      this.sessionStorage = opts.sessionStorage || window.sessionStorage;
      this.boundTopLevelEvents = false;
      this.domCallbacks = Object.assign({ onNodeAdded: closure2(), onBeforeElUpdated: closure2() }, opts.dom || {});
      this.transitions = new TransitionSet();
      window.addEventListener("pagehide", (_e) => {
        this.unloaded = true;
      });
      this.socket.onOpen(() => {
        if (this.isUnloaded()) {
          window.location.reload();
        }
      });
    }
    isProfileEnabled() {
      return this.sessionStorage.getItem(PHX_LV_PROFILE) === "true";
    }
    isDebugEnabled() {
      return this.sessionStorage.getItem(PHX_LV_DEBUG) === "true";
    }
    isDebugDisabled() {
      return this.sessionStorage.getItem(PHX_LV_DEBUG) === "false";
    }
    enableDebug() {
      this.sessionStorage.setItem(PHX_LV_DEBUG, "true");
    }
    enableProfiling() {
      this.sessionStorage.setItem(PHX_LV_PROFILE, "true");
    }
    disableDebug() {
      this.sessionStorage.setItem(PHX_LV_DEBUG, "false");
    }
    disableProfiling() {
      this.sessionStorage.removeItem(PHX_LV_PROFILE);
    }
    enableLatencySim(upperBoundMs) {
      this.enableDebug();
      console.log("latency simulator enabled for the duration of this browser session. Call disableLatencySim() to disable");
      this.sessionStorage.setItem(PHX_LV_LATENCY_SIM, upperBoundMs);
    }
    disableLatencySim() {
      this.sessionStorage.removeItem(PHX_LV_LATENCY_SIM);
    }
    getLatencySim() {
      let str = this.sessionStorage.getItem(PHX_LV_LATENCY_SIM);
      return str ? parseInt(str) : null;
    }
    getSocket() {
      return this.socket;
    }
    connect() {
      if (window.location.hostname === "localhost" && !this.isDebugDisabled()) {
        this.enableDebug();
      }
      let doConnect = () => {
        if (this.joinRootViews()) {
          this.bindTopLevelEvents();
          this.socket.connect();
        }
      };
      if (["complete", "loaded", "interactive"].indexOf(document.readyState) >= 0) {
        doConnect();
      } else {
        document.addEventListener("DOMContentLoaded", () => doConnect());
      }
    }
    disconnect(callback) {
      this.socket.disconnect(callback);
    }
    execJS(el, encodedJS, eventType = null) {
      this.owner(el, (view) => js_default.exec(eventType, encodedJS, view, el));
    }
    triggerDOM(kind, args) {
      this.domCallbacks[kind](...args);
    }
    time(name, func) {
      if (!this.isProfileEnabled() || !console.time) {
        return func();
      }
      console.time(name);
      let result = func();
      console.timeEnd(name);
      return result;
    }
    log(view, kind, msgCallback) {
      if (this.viewLogger) {
        let [msg, obj] = msgCallback();
        this.viewLogger(view, kind, msg, obj);
      } else if (this.isDebugEnabled()) {
        let [msg, obj] = msgCallback();
        debug(view, kind, msg, obj);
      }
    }
    requestDOMUpdate(callback) {
      this.transitions.after(callback);
    }
    transition(time, onStart, onDone = function() {
    }) {
      this.transitions.addTransition(time, onStart, onDone);
    }
    onChannel(channel, event, cb) {
      channel.on(event, (data2) => {
        let latency = this.getLatencySim();
        if (!latency) {
          cb(data2);
        } else {
          console.log(`simulating ${latency}ms of latency from server to client`);
          setTimeout(() => cb(data2), latency);
        }
      });
    }
    wrapPush(view, opts, push) {
      let latency = this.getLatencySim();
      let oldJoinCount = view.joinCount;
      if (!latency) {
        if (this.isConnected() && opts.timeout) {
          return push().receive("timeout", () => {
            if (view.joinCount === oldJoinCount && !view.isDestroyed()) {
              this.reloadWithJitter(view, () => {
                this.log(view, "timeout", () => ["received timeout while communicating with server. Falling back to hard refresh for recovery"]);
              });
            }
          });
        } else {
          return push();
        }
      }
      console.log(`simulating ${latency}ms of latency from client to server`);
      let fakePush = {
        receives: [],
        receive(kind, cb) {
          this.receives.push([kind, cb]);
        }
      };
      setTimeout(() => {
        if (view.isDestroyed()) {
          return;
        }
        fakePush.receives.reduce((acc, [kind, cb]) => acc.receive(kind, cb), push());
      }, latency);
      return fakePush;
    }
    reloadWithJitter(view, log) {
      view.destroy();
      this.disconnect();
      let minMs = this.reloadJitterMin;
      let maxMs = this.reloadJitterMax;
      let afterMs = Math.floor(Math.random() * (maxMs - minMs + 1)) + minMs;
      let tries = browser_default.updateLocal(this.localStorage, window.location.pathname, CONSECUTIVE_RELOADS, 0, (count) => count + 1);
      log ? log() : this.log(view, "join", () => [`encountered ${tries} consecutive reloads`]);
      if (tries > this.maxReloads) {
        this.log(view, "join", () => [`exceeded ${this.maxReloads} consecutive reloads. Entering failsafe mode`]);
        afterMs = this.failsafeJitter;
      }
      setTimeout(() => {
        if (this.hasPendingLink()) {
          window.location = this.pendingLink;
        } else {
          window.location.reload();
        }
      }, afterMs);
    }
    getHookCallbacks(name) {
      return name && name.startsWith("Phoenix.") ? hooks_default[name.split(".")[1]] : this.hooks[name];
    }
    isUnloaded() {
      return this.unloaded;
    }
    isConnected() {
      return this.socket.isConnected();
    }
    getBindingPrefix() {
      return this.bindingPrefix;
    }
    binding(kind) {
      return `${this.getBindingPrefix()}${kind}`;
    }
    channel(topic, params) {
      return this.socket.channel(topic, params);
    }
    joinRootViews() {
      let rootsFound = false;
      dom_default.all(document, `${PHX_VIEW_SELECTOR}:not([${PHX_PARENT_ID}])`, (rootEl) => {
        if (!this.getRootById(rootEl.id)) {
          let view = this.newRootView(rootEl);
          view.setHref(this.getHref());
          view.join();
          if (rootEl.getAttribute(PHX_MAIN)) {
            this.main = view;
          }
        }
        rootsFound = true;
      });
      return rootsFound;
    }
    redirect(to, flash) {
      this.disconnect();
      browser_default.redirect(to, flash);
    }
    replaceMain(href, flash, callback = null, linkRef = this.setPendingLink(href)) {
      this.outgoingMainEl = this.outgoingMainEl || this.main.el;
      let newMainEl = dom_default.cloneNode(this.outgoingMainEl, "");
      this.main.showLoader(this.loaderTimeout);
      this.main.destroy();
      this.main = this.newRootView(newMainEl, flash);
      this.main.setRedirect(href);
      this.transitionRemoves();
      this.main.join((joinCount, onDone) => {
        if (joinCount === 1 && this.commitPendingLink(linkRef)) {
          this.requestDOMUpdate(() => {
            dom_default.findPhxSticky(document).forEach((el) => newMainEl.appendChild(el));
            this.outgoingMainEl.replaceWith(newMainEl);
            this.outgoingMainEl = null;
            callback && callback();
            onDone();
          });
        }
      });
    }
    transitionRemoves(elements) {
      let removeAttr = this.binding("remove");
      elements = elements || dom_default.all(document, `[${removeAttr}]`);
      elements.forEach((el) => {
        if (document.body.contains(el)) {
          this.execJS(el, el.getAttribute(removeAttr), "remove");
        }
      });
    }
    isPhxView(el) {
      return el.getAttribute && el.getAttribute(PHX_SESSION) !== null;
    }
    newRootView(el, flash) {
      let view = new View(el, this, null, flash);
      this.roots[view.id] = view;
      return view;
    }
    owner(childEl, callback) {
      let view = maybe(childEl.closest(PHX_VIEW_SELECTOR), (el) => this.getViewByEl(el)) || this.main;
      if (view) {
        callback(view);
      }
    }
    withinOwners(childEl, callback) {
      this.owner(childEl, (view) => callback(view, childEl));
    }
    getViewByEl(el) {
      let rootId = el.getAttribute(PHX_ROOT_ID);
      return maybe(this.getRootById(rootId), (root) => root.getDescendentByEl(el));
    }
    getRootById(id) {
      return this.roots[id];
    }
    destroyAllViews() {
      for (let id in this.roots) {
        this.roots[id].destroy();
        delete this.roots[id];
      }
    }
    destroyViewByEl(el) {
      let root = this.getRootById(el.getAttribute(PHX_ROOT_ID));
      if (root && root.id === el.id) {
        root.destroy();
        delete this.roots[root.id];
      } else if (root) {
        root.destroyDescendent(el.id);
      }
    }
    setActiveElement(target) {
      if (this.activeElement === target) {
        return;
      }
      this.activeElement = target;
      let cancel = () => {
        if (target === this.activeElement) {
          this.activeElement = null;
        }
        target.removeEventListener("mouseup", this);
        target.removeEventListener("touchend", this);
      };
      target.addEventListener("mouseup", cancel);
      target.addEventListener("touchend", cancel);
    }
    getActiveElement() {
      if (document.activeElement === document.body) {
        return this.activeElement || document.activeElement;
      } else {
        return document.activeElement || document.body;
      }
    }
    dropActiveElement(view) {
      if (this.prevActive && view.ownsElement(this.prevActive)) {
        this.prevActive = null;
      }
    }
    restorePreviouslyActiveFocus() {
      if (this.prevActive && this.prevActive !== document.body) {
        this.prevActive.focus();
      }
    }
    blurActiveElement() {
      this.prevActive = this.getActiveElement();
      if (this.prevActive !== document.body) {
        this.prevActive.blur();
      }
    }
    bindTopLevelEvents() {
      if (this.boundTopLevelEvents) {
        return;
      }
      this.boundTopLevelEvents = true;
      this.socket.onClose((event) => {
        if (event && event.code === 1e3 && this.main) {
          this.reloadWithJitter(this.main);
        }
      });
      document.body.addEventListener("click", function() {
      });
      window.addEventListener("pageshow", (e) => {
        if (e.persisted) {
          this.getSocket().disconnect();
          this.withPageLoading({ to: window.location.href, kind: "redirect" });
          window.location.reload();
        }
      }, true);
      this.bindNav();
      this.bindClicks();
      this.bindForms();
      this.bind({ keyup: "keyup", keydown: "keydown" }, (e, type, view, targetEl, phxEvent, eventTarget) => {
        let matchKey = targetEl.getAttribute(this.binding(PHX_KEY));
        let pressedKey = e.key && e.key.toLowerCase();
        if (matchKey && matchKey.toLowerCase() !== pressedKey) {
          return;
        }
        let data2 = __spreadValues({ key: e.key }, this.eventMeta(type, e, targetEl));
        js_default.exec(type, phxEvent, view, targetEl, ["push", { data: data2 }]);
      });
      this.bind({ blur: "focusout", focus: "focusin" }, (e, type, view, targetEl, phxEvent, eventTarget) => {
        if (!eventTarget) {
          let data2 = __spreadValues({ key: e.key }, this.eventMeta(type, e, targetEl));
          js_default.exec(type, phxEvent, view, targetEl, ["push", { data: data2 }]);
        }
      });
      this.bind({ blur: "blur", focus: "focus" }, (e, type, view, targetEl, targetCtx, phxEvent, phxTarget) => {
        if (phxTarget === "window") {
          let data2 = this.eventMeta(type, e, targetEl);
          js_default.exec(type, phxEvent, view, targetEl, ["push", { data: data2 }]);
        }
      });
      window.addEventListener("dragover", (e) => e.preventDefault());
      window.addEventListener("drop", (e) => {
        e.preventDefault();
        let dropTargetId = maybe(closestPhxBinding(e.target, this.binding(PHX_DROP_TARGET)), (trueTarget) => {
          return trueTarget.getAttribute(this.binding(PHX_DROP_TARGET));
        });
        let dropTarget = dropTargetId && document.getElementById(dropTargetId);
        let files = Array.from(e.dataTransfer.files || []);
        if (!dropTarget || dropTarget.disabled || files.length === 0 || !(dropTarget.files instanceof FileList)) {
          return;
        }
        LiveUploader.trackFiles(dropTarget, files);
        dropTarget.dispatchEvent(new Event("input", { bubbles: true }));
      });
      this.on(PHX_TRACK_UPLOADS, (e) => {
        let uploadTarget = e.target;
        if (!dom_default.isUploadInput(uploadTarget)) {
          return;
        }
        let files = Array.from(e.detail.files || []).filter((f) => f instanceof File || f instanceof Blob);
        LiveUploader.trackFiles(uploadTarget, files);
        uploadTarget.dispatchEvent(new Event("input", { bubbles: true }));
      });
    }
    eventMeta(eventName, e, targetEl) {
      let callback = this.metadataCallbacks[eventName];
      return callback ? callback(e, targetEl) : {};
    }
    setPendingLink(href) {
      this.linkRef++;
      this.pendingLink = href;
      return this.linkRef;
    }
    commitPendingLink(linkRef) {
      if (this.linkRef !== linkRef) {
        return false;
      } else {
        this.href = this.pendingLink;
        this.pendingLink = null;
        return true;
      }
    }
    getHref() {
      return this.href;
    }
    hasPendingLink() {
      return !!this.pendingLink;
    }
    bind(events, callback) {
      for (let event in events) {
        let browserEventName = events[event];
        this.on(browserEventName, (e) => {
          let binding = this.binding(event);
          let windowBinding = this.binding(`window-${event}`);
          let targetPhxEvent = e.target.getAttribute && e.target.getAttribute(binding);
          if (targetPhxEvent) {
            this.debounce(e.target, e, () => {
              this.withinOwners(e.target, (view) => {
                callback(e, event, view, e.target, targetPhxEvent, null);
              });
            });
          } else {
            dom_default.all(document, `[${windowBinding}]`, (el) => {
              let phxEvent = el.getAttribute(windowBinding);
              this.debounce(el, e, () => {
                this.withinOwners(el, (view) => {
                  callback(e, event, view, el, phxEvent, "window");
                });
              });
            });
          }
        });
      }
    }
    bindClicks() {
      window.addEventListener("mousedown", (e) => this.clickStartedAtTarget = e.target);
      this.bindClick("click", "click", false);
      this.bindClick("mousedown", "capture-click", true);
    }
    bindClick(eventName, bindingName, capture) {
      let click = this.binding(bindingName);
      window.addEventListener(eventName, (e) => {
        let target = null;
        if (capture) {
          target = e.target.matches(`[${click}]`) ? e.target : e.target.querySelector(`[${click}]`);
        } else {
          let clickStartedAtTarget = this.clickStartedAtTarget || e.target;
          target = closestPhxBinding(clickStartedAtTarget, click);
          this.dispatchClickAway(e, clickStartedAtTarget);
          this.clickStartedAtTarget = null;
        }
        let phxEvent = target && target.getAttribute(click);
        if (!phxEvent) {
          return;
        }
        if (target.getAttribute("href") === "#") {
          e.preventDefault();
        }
        this.debounce(target, e, () => {
          this.withinOwners(target, (view) => {
            js_default.exec("click", phxEvent, view, target, ["push", { data: this.eventMeta("click", e, target) }]);
          });
        });
      }, capture);
    }
    dispatchClickAway(e, clickStartedAt) {
      let phxClickAway = this.binding("click-away");
      dom_default.all(document, `[${phxClickAway}]`, (el) => {
        if (!(el.isSameNode(clickStartedAt) || el.contains(clickStartedAt))) {
          this.withinOwners(e.target, (view) => {
            let phxEvent = el.getAttribute(phxClickAway);
            if (js_default.isVisible(el)) {
              js_default.exec("click", phxEvent, view, el, ["push", { data: this.eventMeta("click", e, e.target) }]);
            }
          });
        }
      });
    }
    bindNav() {
      if (!browser_default.canPushState()) {
        return;
      }
      if (history.scrollRestoration) {
        history.scrollRestoration = "manual";
      }
      let scrollTimer = null;
      window.addEventListener("scroll", (_e) => {
        clearTimeout(scrollTimer);
        scrollTimer = setTimeout(() => {
          browser_default.updateCurrentState((state) => Object.assign(state, { scroll: window.scrollY }));
        }, 100);
      });
      window.addEventListener("popstate", (event) => {
        if (!this.registerNewLocation(window.location)) {
          return;
        }
        let { type, id, root, scroll } = event.state || {};
        let href = window.location.href;
        this.requestDOMUpdate(() => {
          if (this.main.isConnected() && (type === "patch" && id === this.main.id)) {
            this.main.pushLinkPatch(href, null);
          } else {
            this.replaceMain(href, null, () => {
              if (root) {
                this.replaceRootHistory();
              }
              if (typeof scroll === "number") {
                setTimeout(() => {
                  window.scrollTo(0, scroll);
                }, 0);
              }
            });
          }
        });
      }, false);
      window.addEventListener("click", (e) => {
        let target = closestPhxBinding(e.target, PHX_LIVE_LINK);
        let type = target && target.getAttribute(PHX_LIVE_LINK);
        let wantsNewTab = e.metaKey || e.ctrlKey || e.button === 1;
        if (!type || !this.isConnected() || !this.main || wantsNewTab) {
          return;
        }
        let href = target.href;
        let linkState = target.getAttribute(PHX_LINK_STATE);
        e.preventDefault();
        e.stopImmediatePropagation();
        if (this.pendingLink === href) {
          return;
        }
        this.requestDOMUpdate(() => {
          if (type === "patch") {
            this.pushHistoryPatch(href, linkState, target);
          } else if (type === "redirect") {
            this.historyRedirect(href, linkState);
          } else {
            throw new Error(`expected ${PHX_LIVE_LINK} to be "patch" or "redirect", got: ${type}`);
          }
        });
      }, false);
    }
    dispatchEvent(event, payload = {}) {
      dom_default.dispatchEvent(window, `phx:${event}`, { detail: payload });
    }
    dispatchEvents(events) {
      events.forEach(([event, payload]) => this.dispatchEvent(event, payload));
    }
    withPageLoading(info, callback) {
      dom_default.dispatchEvent(window, "phx:page-loading-start", { detail: info });
      let done = () => dom_default.dispatchEvent(window, "phx:page-loading-stop", { detail: info });
      return callback ? callback(done) : done;
    }
    pushHistoryPatch(href, linkState, targetEl) {
      this.withPageLoading({ to: href, kind: "patch" }, (done) => {
        this.main.pushLinkPatch(href, targetEl, (linkRef) => {
          this.historyPatch(href, linkState, linkRef);
          done();
        });
      });
    }
    historyPatch(href, linkState, linkRef = this.setPendingLink(href)) {
      if (!this.commitPendingLink(linkRef)) {
        return;
      }
      browser_default.pushState(linkState, { type: "patch", id: this.main.id }, href);
      this.registerNewLocation(window.location);
    }
    historyRedirect(href, linkState, flash) {
      let scroll = window.scrollY;
      this.withPageLoading({ to: href, kind: "redirect" }, (done) => {
        this.replaceMain(href, flash, () => {
          browser_default.pushState(linkState, { type: "redirect", id: this.main.id, scroll }, href);
          this.registerNewLocation(window.location);
          done();
        });
      });
    }
    replaceRootHistory() {
      browser_default.pushState("replace", { root: true, type: "patch", id: this.main.id });
    }
    registerNewLocation(newLocation) {
      let { pathname, search } = this.currentLocation;
      if (pathname + search === newLocation.pathname + newLocation.search) {
        return false;
      } else {
        this.currentLocation = clone(newLocation);
        return true;
      }
    }
    bindForms() {
      let iterations = 0;
      this.on("submit", (e) => {
        let phxEvent = e.target.getAttribute(this.binding("submit"));
        if (!phxEvent) {
          return;
        }
        e.preventDefault();
        e.target.disabled = true;
        this.withinOwners(e.target, (view) => {
          js_default.exec("submit", phxEvent, view, e.target, ["push", {}]);
        });
      }, false);
      for (let type of ["change", "input"]) {
        this.on(type, (e) => {
          let phxChange = this.binding("change");
          let input = e.target;
          let inputEvent = input.getAttribute(phxChange);
          let formEvent = input.form && input.form.getAttribute(phxChange);
          let phxEvent = inputEvent || formEvent;
          if (!phxEvent) {
            return;
          }
          if (input.type === "number" && input.validity && input.validity.badInput) {
            return;
          }
          let dispatcher = inputEvent ? input : input.form;
          let currentIterations = iterations;
          iterations++;
          let { at, type: lastType } = dom_default.private(input, "prev-iteration") || {};
          if (at === currentIterations - 1 && type !== lastType) {
            return;
          }
          dom_default.putPrivate(input, "prev-iteration", { at: currentIterations, type });
          this.debounce(input, e, () => {
            this.withinOwners(dispatcher, (view) => {
              dom_default.putPrivate(input, PHX_HAS_FOCUSED, true);
              if (!dom_default.isTextualInput(input)) {
                this.setActiveElement(input);
              }
              js_default.exec("change", phxEvent, view, input, ["push", { _target: e.target.name, dispatcher }]);
            });
          });
        }, false);
      }
    }
    debounce(el, event, callback) {
      let phxDebounce = this.binding(PHX_DEBOUNCE);
      let phxThrottle = this.binding(PHX_THROTTLE);
      let defaultDebounce = this.defaults.debounce.toString();
      let defaultThrottle = this.defaults.throttle.toString();
      dom_default.debounce(el, event, phxDebounce, defaultDebounce, phxThrottle, defaultThrottle, callback);
    }
    silenceEvents(callback) {
      this.silenced = true;
      callback();
      this.silenced = false;
    }
    on(event, callback) {
      window.addEventListener(event, (e) => {
        if (!this.silenced) {
          callback(e);
        }
      });
    }
  };
  var TransitionSet = class {
    constructor() {
      this.transitions = /* @__PURE__ */ new Set();
      this.pendingOps = [];
      this.reset();
    }
    reset() {
      this.transitions.forEach((timer) => {
        cancelTimeout(timer);
        this.transitions.delete(timer);
      });
      this.flushPendingOps();
    }
    after(callback) {
      if (this.size() === 0) {
        callback();
      } else {
        this.pushPendingOp(callback);
      }
    }
    addTransition(time, onStart, onDone) {
      onStart();
      let timer = setTimeout(() => {
        this.transitions.delete(timer);
        onDone();
        if (this.size() === 0) {
          this.flushPendingOps();
        }
      }, time);
      this.transitions.add(timer);
    }
    pushPendingOp(op) {
      this.pendingOps.push(op);
    }
    size() {
      return this.transitions.size;
    }
    flushPendingOps() {
      this.pendingOps.forEach((op) => op());
      this.pendingOps = [];
    }
  };

  // js/app.js
  var import_topbar = __toModule(require_topbar());

  // js/template.js
  function init_templet() {
    if (localStorage.getItem("color-theme") === "dark" || !("color-theme" in localStorage) && window.matchMedia("(prefers-color-scheme: dark)").matches) {
      document.documentElement.classList.add("dark");
    } else {
      document.documentElement.classList.remove("dark");
    }
    var themeToggleDarkIcon = document.getElementById("theme-toggle-dark-icon");
    var themeToggleLightIcon = document.getElementById("theme-toggle-light-icon");
    if (themeToggleDarkIcon != void 0 && themeToggleLightIcon != void 0) {
      if (localStorage.getItem("color-theme") === "dark" || !("color-theme" in localStorage) && window.matchMedia("(prefers-color-scheme: dark)").matches) {
        themeToggleLightIcon.classList.remove("hidden");
      } else {
        themeToggleDarkIcon.classList.remove("hidden");
      }
      var themeToggleBtn = document.getElementById("theme-toggle");
      themeToggleBtn.addEventListener("click", function() {
        themeToggleDarkIcon.classList.toggle("hidden");
        themeToggleLightIcon.classList.toggle("hidden");
        if (localStorage.getItem("color-theme")) {
          if (localStorage.getItem("color-theme") === "light") {
            document.documentElement.classList.add("dark");
            localStorage.setItem("color-theme", "dark");
          } else {
            document.documentElement.classList.remove("dark");
            localStorage.setItem("color-theme", "light");
          }
        } else {
          if (document.documentElement.classList.contains("dark")) {
            document.documentElement.classList.remove("dark");
            localStorage.setItem("color-theme", "light");
          } else {
            document.documentElement.classList.add("dark");
            localStorage.setItem("color-theme", "dark");
          }
        }
      });
    }
  }

  // node_modules/alpinejs/dist/module.esm.js
  var flushPending = false;
  var flushing = false;
  var queue = [];
  function scheduler(callback) {
    queueJob(callback);
  }
  function queueJob(job) {
    if (!queue.includes(job))
      queue.push(job);
    queueFlush();
  }
  function dequeueJob(job) {
    let index = queue.indexOf(job);
    if (index !== -1)
      queue.splice(index, 1);
  }
  function queueFlush() {
    if (!flushing && !flushPending) {
      flushPending = true;
      queueMicrotask(flushJobs);
    }
  }
  function flushJobs() {
    flushPending = false;
    flushing = true;
    for (let i = 0; i < queue.length; i++) {
      queue[i]();
    }
    queue.length = 0;
    flushing = false;
  }
  var reactive;
  var effect;
  var release;
  var raw;
  var shouldSchedule = true;
  function disableEffectScheduling(callback) {
    shouldSchedule = false;
    callback();
    shouldSchedule = true;
  }
  function setReactivityEngine(engine) {
    reactive = engine.reactive;
    release = engine.release;
    effect = (callback) => engine.effect(callback, { scheduler: (task) => {
      if (shouldSchedule) {
        scheduler(task);
      } else {
        task();
      }
    } });
    raw = engine.raw;
  }
  function overrideEffect(override) {
    effect = override;
  }
  function elementBoundEffect(el) {
    let cleanup2 = () => {
    };
    let wrappedEffect = (callback) => {
      let effectReference = effect(callback);
      if (!el._x_effects) {
        el._x_effects = /* @__PURE__ */ new Set();
        el._x_runEffects = () => {
          el._x_effects.forEach((i) => i());
        };
      }
      el._x_effects.add(effectReference);
      cleanup2 = () => {
        if (effectReference === void 0)
          return;
        el._x_effects.delete(effectReference);
        release(effectReference);
      };
      return effectReference;
    };
    return [wrappedEffect, () => {
      cleanup2();
    }];
  }
  var onAttributeAddeds = [];
  var onElRemoveds = [];
  var onElAddeds = [];
  function onElAdded(callback) {
    onElAddeds.push(callback);
  }
  function onElRemoved(el, callback) {
    if (typeof callback === "function") {
      if (!el._x_cleanups)
        el._x_cleanups = [];
      el._x_cleanups.push(callback);
    } else {
      callback = el;
      onElRemoveds.push(callback);
    }
  }
  function onAttributesAdded(callback) {
    onAttributeAddeds.push(callback);
  }
  function onAttributeRemoved(el, name, callback) {
    if (!el._x_attributeCleanups)
      el._x_attributeCleanups = {};
    if (!el._x_attributeCleanups[name])
      el._x_attributeCleanups[name] = [];
    el._x_attributeCleanups[name].push(callback);
  }
  function cleanupAttributes(el, names) {
    if (!el._x_attributeCleanups)
      return;
    Object.entries(el._x_attributeCleanups).forEach(([name, value]) => {
      if (names === void 0 || names.includes(name)) {
        value.forEach((i) => i());
        delete el._x_attributeCleanups[name];
      }
    });
  }
  var observer = new MutationObserver(onMutate);
  var currentlyObserving = false;
  function startObservingMutations() {
    observer.observe(document, { subtree: true, childList: true, attributes: true, attributeOldValue: true });
    currentlyObserving = true;
  }
  function stopObservingMutations() {
    flushObserver();
    observer.disconnect();
    currentlyObserving = false;
  }
  var recordQueue = [];
  var willProcessRecordQueue = false;
  function flushObserver() {
    recordQueue = recordQueue.concat(observer.takeRecords());
    if (recordQueue.length && !willProcessRecordQueue) {
      willProcessRecordQueue = true;
      queueMicrotask(() => {
        processRecordQueue();
        willProcessRecordQueue = false;
      });
    }
  }
  function processRecordQueue() {
    onMutate(recordQueue);
    recordQueue.length = 0;
  }
  function mutateDom(callback) {
    if (!currentlyObserving)
      return callback();
    stopObservingMutations();
    let result = callback();
    startObservingMutations();
    return result;
  }
  var isCollecting = false;
  var deferredMutations = [];
  function deferMutations() {
    isCollecting = true;
  }
  function flushAndStopDeferringMutations() {
    isCollecting = false;
    onMutate(deferredMutations);
    deferredMutations = [];
  }
  function onMutate(mutations) {
    if (isCollecting) {
      deferredMutations = deferredMutations.concat(mutations);
      return;
    }
    let addedNodes = [];
    let removedNodes = [];
    let addedAttributes = /* @__PURE__ */ new Map();
    let removedAttributes = /* @__PURE__ */ new Map();
    for (let i = 0; i < mutations.length; i++) {
      if (mutations[i].target._x_ignoreMutationObserver)
        continue;
      if (mutations[i].type === "childList") {
        mutations[i].addedNodes.forEach((node) => node.nodeType === 1 && addedNodes.push(node));
        mutations[i].removedNodes.forEach((node) => node.nodeType === 1 && removedNodes.push(node));
      }
      if (mutations[i].type === "attributes") {
        let el = mutations[i].target;
        let name = mutations[i].attributeName;
        let oldValue = mutations[i].oldValue;
        let add2 = () => {
          if (!addedAttributes.has(el))
            addedAttributes.set(el, []);
          addedAttributes.get(el).push({ name, value: el.getAttribute(name) });
        };
        let remove = () => {
          if (!removedAttributes.has(el))
            removedAttributes.set(el, []);
          removedAttributes.get(el).push(name);
        };
        if (el.hasAttribute(name) && oldValue === null) {
          add2();
        } else if (el.hasAttribute(name)) {
          remove();
          add2();
        } else {
          remove();
        }
      }
    }
    removedAttributes.forEach((attrs, el) => {
      cleanupAttributes(el, attrs);
    });
    addedAttributes.forEach((attrs, el) => {
      onAttributeAddeds.forEach((i) => i(el, attrs));
    });
    for (let node of removedNodes) {
      if (addedNodes.includes(node))
        continue;
      onElRemoveds.forEach((i) => i(node));
      if (node._x_cleanups) {
        while (node._x_cleanups.length)
          node._x_cleanups.pop()();
      }
    }
    addedNodes.forEach((node) => {
      node._x_ignoreSelf = true;
      node._x_ignore = true;
    });
    for (let node of addedNodes) {
      if (removedNodes.includes(node))
        continue;
      if (!node.isConnected)
        continue;
      delete node._x_ignoreSelf;
      delete node._x_ignore;
      onElAddeds.forEach((i) => i(node));
      node._x_ignore = true;
      node._x_ignoreSelf = true;
    }
    addedNodes.forEach((node) => {
      delete node._x_ignoreSelf;
      delete node._x_ignore;
    });
    addedNodes = null;
    removedNodes = null;
    addedAttributes = null;
    removedAttributes = null;
  }
  function scope(node) {
    return mergeProxies(closestDataStack(node));
  }
  function addScopeToNode(node, data2, referenceNode) {
    node._x_dataStack = [data2, ...closestDataStack(referenceNode || node)];
    return () => {
      node._x_dataStack = node._x_dataStack.filter((i) => i !== data2);
    };
  }
  function refreshScope(element, scope2) {
    let existingScope = element._x_dataStack[0];
    Object.entries(scope2).forEach(([key, value]) => {
      existingScope[key] = value;
    });
  }
  function closestDataStack(node) {
    if (node._x_dataStack)
      return node._x_dataStack;
    if (typeof ShadowRoot === "function" && node instanceof ShadowRoot) {
      return closestDataStack(node.host);
    }
    if (!node.parentNode) {
      return [];
    }
    return closestDataStack(node.parentNode);
  }
  function mergeProxies(objects) {
    let thisProxy = new Proxy({}, {
      ownKeys: () => {
        return Array.from(new Set(objects.flatMap((i) => Object.keys(i))));
      },
      has: (target, name) => {
        return objects.some((obj) => obj.hasOwnProperty(name));
      },
      get: (target, name) => {
        return (objects.find((obj) => {
          if (obj.hasOwnProperty(name)) {
            let descriptor = Object.getOwnPropertyDescriptor(obj, name);
            if (descriptor.get && descriptor.get._x_alreadyBound || descriptor.set && descriptor.set._x_alreadyBound) {
              return true;
            }
            if ((descriptor.get || descriptor.set) && descriptor.enumerable) {
              let getter = descriptor.get;
              let setter = descriptor.set;
              let property = descriptor;
              getter = getter && getter.bind(thisProxy);
              setter = setter && setter.bind(thisProxy);
              if (getter)
                getter._x_alreadyBound = true;
              if (setter)
                setter._x_alreadyBound = true;
              Object.defineProperty(obj, name, __spreadProps(__spreadValues({}, property), {
                get: getter,
                set: setter
              }));
            }
            return true;
          }
          return false;
        }) || {})[name];
      },
      set: (target, name, value) => {
        let closestObjectWithKey = objects.find((obj) => obj.hasOwnProperty(name));
        if (closestObjectWithKey) {
          closestObjectWithKey[name] = value;
        } else {
          objects[objects.length - 1][name] = value;
        }
        return true;
      }
    });
    return thisProxy;
  }
  function initInterceptors(data2) {
    let isObject22 = (val) => typeof val === "object" && !Array.isArray(val) && val !== null;
    let recurse = (obj, basePath = "") => {
      Object.entries(Object.getOwnPropertyDescriptors(obj)).forEach(([key, { value, enumerable }]) => {
        if (enumerable === false || value === void 0)
          return;
        let path = basePath === "" ? key : `${basePath}.${key}`;
        if (typeof value === "object" && value !== null && value._x_interceptor) {
          obj[key] = value.initialize(data2, path, key);
        } else {
          if (isObject22(value) && value !== obj && !(value instanceof Element)) {
            recurse(value, path);
          }
        }
      });
    };
    return recurse(data2);
  }
  function interceptor(callback, mutateObj = () => {
  }) {
    let obj = {
      initialValue: void 0,
      _x_interceptor: true,
      initialize(data2, path, key) {
        return callback(this.initialValue, () => get(data2, path), (value) => set(data2, path, value), path, key);
      }
    };
    mutateObj(obj);
    return (initialValue) => {
      if (typeof initialValue === "object" && initialValue !== null && initialValue._x_interceptor) {
        let initialize = obj.initialize.bind(obj);
        obj.initialize = (data2, path, key) => {
          let innerValue = initialValue.initialize(data2, path, key);
          obj.initialValue = innerValue;
          return initialize(data2, path, key);
        };
      } else {
        obj.initialValue = initialValue;
      }
      return obj;
    };
  }
  function get(obj, path) {
    return path.split(".").reduce((carry, segment) => carry[segment], obj);
  }
  function set(obj, path, value) {
    if (typeof path === "string")
      path = path.split(".");
    if (path.length === 1)
      obj[path[0]] = value;
    else if (path.length === 0)
      throw error;
    else {
      if (obj[path[0]])
        return set(obj[path[0]], path.slice(1), value);
      else {
        obj[path[0]] = {};
        return set(obj[path[0]], path.slice(1), value);
      }
    }
  }
  var magics = {};
  function magic(name, callback) {
    magics[name] = callback;
  }
  function injectMagics(obj, el) {
    Object.entries(magics).forEach(([name, callback]) => {
      Object.defineProperty(obj, `$${name}`, {
        get() {
          let [utilities, cleanup2] = getElementBoundUtilities(el);
          utilities = __spreadValues({ interceptor }, utilities);
          onElRemoved(el, cleanup2);
          return callback(el, utilities);
        },
        enumerable: false
      });
    });
    return obj;
  }
  function tryCatch(el, expression, callback, ...args) {
    try {
      return callback(...args);
    } catch (e) {
      handleError(e, el, expression);
    }
  }
  function handleError(error2, el, expression = void 0) {
    Object.assign(error2, { el, expression });
    console.warn(`Alpine Expression Error: ${error2.message}

${expression ? 'Expression: "' + expression + '"\n\n' : ""}`, el);
    setTimeout(() => {
      throw error2;
    }, 0);
  }
  var shouldAutoEvaluateFunctions = true;
  function dontAutoEvaluateFunctions(callback) {
    let cache = shouldAutoEvaluateFunctions;
    shouldAutoEvaluateFunctions = false;
    callback();
    shouldAutoEvaluateFunctions = cache;
  }
  function evaluate(el, expression, extras = {}) {
    let result;
    evaluateLater(el, expression)((value) => result = value, extras);
    return result;
  }
  function evaluateLater(...args) {
    return theEvaluatorFunction(...args);
  }
  var theEvaluatorFunction = normalEvaluator;
  function setEvaluator(newEvaluator) {
    theEvaluatorFunction = newEvaluator;
  }
  function normalEvaluator(el, expression) {
    let overriddenMagics = {};
    injectMagics(overriddenMagics, el);
    let dataStack = [overriddenMagics, ...closestDataStack(el)];
    if (typeof expression === "function") {
      return generateEvaluatorFromFunction(dataStack, expression);
    }
    let evaluator = generateEvaluatorFromString(dataStack, expression, el);
    return tryCatch.bind(null, el, expression, evaluator);
  }
  function generateEvaluatorFromFunction(dataStack, func) {
    return (receiver = () => {
    }, { scope: scope2 = {}, params = [] } = {}) => {
      let result = func.apply(mergeProxies([scope2, ...dataStack]), params);
      runIfTypeOfFunction(receiver, result);
    };
  }
  var evaluatorMemo = {};
  function generateFunctionFromString(expression, el) {
    if (evaluatorMemo[expression]) {
      return evaluatorMemo[expression];
    }
    let AsyncFunction = Object.getPrototypeOf(async function() {
    }).constructor;
    let rightSideSafeExpression = /^[\n\s]*if.*\(.*\)/.test(expression) || /^(let|const)\s/.test(expression) ? `(() => { ${expression} })()` : expression;
    const safeAsyncFunction = () => {
      try {
        return new AsyncFunction(["__self", "scope"], `with (scope) { __self.result = ${rightSideSafeExpression} }; __self.finished = true; return __self.result;`);
      } catch (error2) {
        handleError(error2, el, expression);
        return Promise.resolve();
      }
    };
    let func = safeAsyncFunction();
    evaluatorMemo[expression] = func;
    return func;
  }
  function generateEvaluatorFromString(dataStack, expression, el) {
    let func = generateFunctionFromString(expression, el);
    return (receiver = () => {
    }, { scope: scope2 = {}, params = [] } = {}) => {
      func.result = void 0;
      func.finished = false;
      let completeScope = mergeProxies([scope2, ...dataStack]);
      if (typeof func === "function") {
        let promise = func(func, completeScope).catch((error2) => handleError(error2, el, expression));
        if (func.finished) {
          runIfTypeOfFunction(receiver, func.result, completeScope, params, el);
          func.result = void 0;
        } else {
          promise.then((result) => {
            runIfTypeOfFunction(receiver, result, completeScope, params, el);
          }).catch((error2) => handleError(error2, el, expression)).finally(() => func.result = void 0);
        }
      }
    };
  }
  function runIfTypeOfFunction(receiver, value, scope2, params, el) {
    if (shouldAutoEvaluateFunctions && typeof value === "function") {
      let result = value.apply(scope2, params);
      if (result instanceof Promise) {
        result.then((i) => runIfTypeOfFunction(receiver, i, scope2, params)).catch((error2) => handleError(error2, el, value));
      } else {
        receiver(result);
      }
    } else {
      receiver(value);
    }
  }
  var prefixAsString = "x-";
  function prefix(subject = "") {
    return prefixAsString + subject;
  }
  function setPrefix(newPrefix) {
    prefixAsString = newPrefix;
  }
  var directiveHandlers = {};
  function directive(name, callback) {
    directiveHandlers[name] = callback;
  }
  function directives(el, attributes, originalAttributeOverride) {
    let transformedAttributeMap = {};
    let directives2 = Array.from(attributes).map(toTransformedAttributes((newName, oldName) => transformedAttributeMap[newName] = oldName)).filter(outNonAlpineAttributes).map(toParsedDirectives(transformedAttributeMap, originalAttributeOverride)).sort(byPriority);
    return directives2.map((directive2) => {
      return getDirectiveHandler(el, directive2);
    });
  }
  function attributesOnly(attributes) {
    return Array.from(attributes).map(toTransformedAttributes()).filter((attr) => !outNonAlpineAttributes(attr));
  }
  var isDeferringHandlers = false;
  var directiveHandlerStacks = /* @__PURE__ */ new Map();
  var currentHandlerStackKey = Symbol();
  function deferHandlingDirectives(callback) {
    isDeferringHandlers = true;
    let key = Symbol();
    currentHandlerStackKey = key;
    directiveHandlerStacks.set(key, []);
    let flushHandlers = () => {
      while (directiveHandlerStacks.get(key).length)
        directiveHandlerStacks.get(key).shift()();
      directiveHandlerStacks.delete(key);
    };
    let stopDeferring = () => {
      isDeferringHandlers = false;
      flushHandlers();
    };
    callback(flushHandlers);
    stopDeferring();
  }
  function getElementBoundUtilities(el) {
    let cleanups = [];
    let cleanup2 = (callback) => cleanups.push(callback);
    let [effect3, cleanupEffect] = elementBoundEffect(el);
    cleanups.push(cleanupEffect);
    let utilities = {
      Alpine: alpine_default,
      effect: effect3,
      cleanup: cleanup2,
      evaluateLater: evaluateLater.bind(evaluateLater, el),
      evaluate: evaluate.bind(evaluate, el)
    };
    let doCleanup = () => cleanups.forEach((i) => i());
    return [utilities, doCleanup];
  }
  function getDirectiveHandler(el, directive2) {
    let noop2 = () => {
    };
    let handler3 = directiveHandlers[directive2.type] || noop2;
    let [utilities, cleanup2] = getElementBoundUtilities(el);
    onAttributeRemoved(el, directive2.original, cleanup2);
    let fullHandler = () => {
      if (el._x_ignore || el._x_ignoreSelf)
        return;
      handler3.inline && handler3.inline(el, directive2, utilities);
      handler3 = handler3.bind(handler3, el, directive2, utilities);
      isDeferringHandlers ? directiveHandlerStacks.get(currentHandlerStackKey).push(handler3) : handler3();
    };
    fullHandler.runCleanups = cleanup2;
    return fullHandler;
  }
  var startingWith = (subject, replacement) => ({ name, value }) => {
    if (name.startsWith(subject))
      name = name.replace(subject, replacement);
    return { name, value };
  };
  var into = (i) => i;
  function toTransformedAttributes(callback = () => {
  }) {
    return ({ name, value }) => {
      let { name: newName, value: newValue } = attributeTransformers.reduce((carry, transform) => {
        return transform(carry);
      }, { name, value });
      if (newName !== name)
        callback(newName, name);
      return { name: newName, value: newValue };
    };
  }
  var attributeTransformers = [];
  function mapAttributes(callback) {
    attributeTransformers.push(callback);
  }
  function outNonAlpineAttributes({ name }) {
    return alpineAttributeRegex().test(name);
  }
  var alpineAttributeRegex = () => new RegExp(`^${prefixAsString}([^:^.]+)\\b`);
  function toParsedDirectives(transformedAttributeMap, originalAttributeOverride) {
    return ({ name, value }) => {
      let typeMatch = name.match(alpineAttributeRegex());
      let valueMatch = name.match(/:([a-zA-Z0-9\-:]+)/);
      let modifiers = name.match(/\.[^.\]]+(?=[^\]]*$)/g) || [];
      let original = originalAttributeOverride || transformedAttributeMap[name] || name;
      return {
        type: typeMatch ? typeMatch[1] : null,
        value: valueMatch ? valueMatch[1] : null,
        modifiers: modifiers.map((i) => i.replace(".", "")),
        expression: value,
        original
      };
    };
  }
  var DEFAULT = "DEFAULT";
  var directiveOrder = [
    "ignore",
    "ref",
    "data",
    "id",
    "bind",
    "init",
    "for",
    "mask",
    "model",
    "modelable",
    "transition",
    "show",
    "if",
    DEFAULT,
    "teleport",
    "element"
  ];
  function byPriority(a, b) {
    let typeA = directiveOrder.indexOf(a.type) === -1 ? DEFAULT : a.type;
    let typeB = directiveOrder.indexOf(b.type) === -1 ? DEFAULT : b.type;
    return directiveOrder.indexOf(typeA) - directiveOrder.indexOf(typeB);
  }
  function dispatch(el, name, detail = {}) {
    el.dispatchEvent(new CustomEvent(name, {
      detail,
      bubbles: true,
      composed: true,
      cancelable: true
    }));
  }
  var tickStack = [];
  var isHolding = false;
  function nextTick(callback = () => {
  }) {
    queueMicrotask(() => {
      isHolding || setTimeout(() => {
        releaseNextTicks();
      });
    });
    return new Promise((res) => {
      tickStack.push(() => {
        callback();
        res();
      });
    });
  }
  function releaseNextTicks() {
    isHolding = false;
    while (tickStack.length)
      tickStack.shift()();
  }
  function holdNextTicks() {
    isHolding = true;
  }
  function walk(el, callback) {
    if (typeof ShadowRoot === "function" && el instanceof ShadowRoot) {
      Array.from(el.children).forEach((el2) => walk(el2, callback));
      return;
    }
    let skip = false;
    callback(el, () => skip = true);
    if (skip)
      return;
    let node = el.firstElementChild;
    while (node) {
      walk(node, callback, false);
      node = node.nextElementSibling;
    }
  }
  function warn(message, ...args) {
    console.warn(`Alpine Warning: ${message}`, ...args);
  }
  function start() {
    if (!document.body)
      warn("Unable to initialize. Trying to load Alpine before `<body>` is available. Did you forget to add `defer` in Alpine's `<script>` tag?");
    dispatch(document, "alpine:init");
    dispatch(document, "alpine:initializing");
    startObservingMutations();
    onElAdded((el) => initTree(el, walk));
    onElRemoved((el) => destroyTree(el));
    onAttributesAdded((el, attrs) => {
      directives(el, attrs).forEach((handle) => handle());
    });
    let outNestedComponents = (el) => !closestRoot(el.parentElement, true);
    Array.from(document.querySelectorAll(allSelectors())).filter(outNestedComponents).forEach((el) => {
      initTree(el);
    });
    dispatch(document, "alpine:initialized");
  }
  var rootSelectorCallbacks = [];
  var initSelectorCallbacks = [];
  function rootSelectors() {
    return rootSelectorCallbacks.map((fn) => fn());
  }
  function allSelectors() {
    return rootSelectorCallbacks.concat(initSelectorCallbacks).map((fn) => fn());
  }
  function addRootSelector(selectorCallback) {
    rootSelectorCallbacks.push(selectorCallback);
  }
  function addInitSelector(selectorCallback) {
    initSelectorCallbacks.push(selectorCallback);
  }
  function closestRoot(el, includeInitSelectors = false) {
    return findClosest(el, (element) => {
      const selectors = includeInitSelectors ? allSelectors() : rootSelectors();
      if (selectors.some((selector) => element.matches(selector)))
        return true;
    });
  }
  function findClosest(el, callback) {
    if (!el)
      return;
    if (callback(el))
      return el;
    if (el._x_teleportBack)
      el = el._x_teleportBack;
    if (!el.parentElement)
      return;
    return findClosest(el.parentElement, callback);
  }
  function isRoot(el) {
    return rootSelectors().some((selector) => el.matches(selector));
  }
  function initTree(el, walker = walk) {
    deferHandlingDirectives(() => {
      walker(el, (el2, skip) => {
        directives(el2, el2.attributes).forEach((handle) => handle());
        el2._x_ignore && skip();
      });
    });
  }
  function destroyTree(root) {
    walk(root, (el) => cleanupAttributes(el));
  }
  function setClasses(el, value) {
    if (Array.isArray(value)) {
      return setClassesFromString(el, value.join(" "));
    } else if (typeof value === "object" && value !== null) {
      return setClassesFromObject(el, value);
    } else if (typeof value === "function") {
      return setClasses(el, value());
    }
    return setClassesFromString(el, value);
  }
  function setClassesFromString(el, classString) {
    let split = (classString2) => classString2.split(" ").filter(Boolean);
    let missingClasses = (classString2) => classString2.split(" ").filter((i) => !el.classList.contains(i)).filter(Boolean);
    let addClassesAndReturnUndo = (classes) => {
      el.classList.add(...classes);
      return () => {
        el.classList.remove(...classes);
      };
    };
    classString = classString === true ? classString = "" : classString || "";
    return addClassesAndReturnUndo(missingClasses(classString));
  }
  function setClassesFromObject(el, classObject) {
    let split = (classString) => classString.split(" ").filter(Boolean);
    let forAdd = Object.entries(classObject).flatMap(([classString, bool]) => bool ? split(classString) : false).filter(Boolean);
    let forRemove = Object.entries(classObject).flatMap(([classString, bool]) => !bool ? split(classString) : false).filter(Boolean);
    let added = [];
    let removed = [];
    forRemove.forEach((i) => {
      if (el.classList.contains(i)) {
        el.classList.remove(i);
        removed.push(i);
      }
    });
    forAdd.forEach((i) => {
      if (!el.classList.contains(i)) {
        el.classList.add(i);
        added.push(i);
      }
    });
    return () => {
      removed.forEach((i) => el.classList.add(i));
      added.forEach((i) => el.classList.remove(i));
    };
  }
  function setStyles(el, value) {
    if (typeof value === "object" && value !== null) {
      return setStylesFromObject(el, value);
    }
    return setStylesFromString(el, value);
  }
  function setStylesFromObject(el, value) {
    let previousStyles = {};
    Object.entries(value).forEach(([key, value2]) => {
      previousStyles[key] = el.style[key];
      if (!key.startsWith("--")) {
        key = kebabCase(key);
      }
      el.style.setProperty(key, value2);
    });
    setTimeout(() => {
      if (el.style.length === 0) {
        el.removeAttribute("style");
      }
    });
    return () => {
      setStyles(el, previousStyles);
    };
  }
  function setStylesFromString(el, value) {
    let cache = el.getAttribute("style", value);
    el.setAttribute("style", value);
    return () => {
      el.setAttribute("style", cache || "");
    };
  }
  function kebabCase(subject) {
    return subject.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
  }
  function once(callback, fallback = () => {
  }) {
    let called = false;
    return function() {
      if (!called) {
        called = true;
        callback.apply(this, arguments);
      } else {
        fallback.apply(this, arguments);
      }
    };
  }
  directive("transition", (el, { value, modifiers, expression }, { evaluate: evaluate2 }) => {
    if (typeof expression === "function")
      expression = evaluate2(expression);
    if (!expression) {
      registerTransitionsFromHelper(el, modifiers, value);
    } else {
      registerTransitionsFromClassString(el, expression, value);
    }
  });
  function registerTransitionsFromClassString(el, classString, stage) {
    registerTransitionObject(el, setClasses, "");
    let directiveStorageMap = {
      enter: (classes) => {
        el._x_transition.enter.during = classes;
      },
      "enter-start": (classes) => {
        el._x_transition.enter.start = classes;
      },
      "enter-end": (classes) => {
        el._x_transition.enter.end = classes;
      },
      leave: (classes) => {
        el._x_transition.leave.during = classes;
      },
      "leave-start": (classes) => {
        el._x_transition.leave.start = classes;
      },
      "leave-end": (classes) => {
        el._x_transition.leave.end = classes;
      }
    };
    directiveStorageMap[stage](classString);
  }
  function registerTransitionsFromHelper(el, modifiers, stage) {
    registerTransitionObject(el, setStyles);
    let doesntSpecify = !modifiers.includes("in") && !modifiers.includes("out") && !stage;
    let transitioningIn = doesntSpecify || modifiers.includes("in") || ["enter"].includes(stage);
    let transitioningOut = doesntSpecify || modifiers.includes("out") || ["leave"].includes(stage);
    if (modifiers.includes("in") && !doesntSpecify) {
      modifiers = modifiers.filter((i, index) => index < modifiers.indexOf("out"));
    }
    if (modifiers.includes("out") && !doesntSpecify) {
      modifiers = modifiers.filter((i, index) => index > modifiers.indexOf("out"));
    }
    let wantsAll = !modifiers.includes("opacity") && !modifiers.includes("scale");
    let wantsOpacity = wantsAll || modifiers.includes("opacity");
    let wantsScale = wantsAll || modifiers.includes("scale");
    let opacityValue = wantsOpacity ? 0 : 1;
    let scaleValue = wantsScale ? modifierValue(modifiers, "scale", 95) / 100 : 1;
    let delay = modifierValue(modifiers, "delay", 0);
    let origin = modifierValue(modifiers, "origin", "center");
    let property = "opacity, transform";
    let durationIn = modifierValue(modifiers, "duration", 150) / 1e3;
    let durationOut = modifierValue(modifiers, "duration", 75) / 1e3;
    let easing = `cubic-bezier(0.4, 0.0, 0.2, 1)`;
    if (transitioningIn) {
      el._x_transition.enter.during = {
        transformOrigin: origin,
        transitionDelay: delay,
        transitionProperty: property,
        transitionDuration: `${durationIn}s`,
        transitionTimingFunction: easing
      };
      el._x_transition.enter.start = {
        opacity: opacityValue,
        transform: `scale(${scaleValue})`
      };
      el._x_transition.enter.end = {
        opacity: 1,
        transform: `scale(1)`
      };
    }
    if (transitioningOut) {
      el._x_transition.leave.during = {
        transformOrigin: origin,
        transitionDelay: delay,
        transitionProperty: property,
        transitionDuration: `${durationOut}s`,
        transitionTimingFunction: easing
      };
      el._x_transition.leave.start = {
        opacity: 1,
        transform: `scale(1)`
      };
      el._x_transition.leave.end = {
        opacity: opacityValue,
        transform: `scale(${scaleValue})`
      };
    }
  }
  function registerTransitionObject(el, setFunction, defaultValue = {}) {
    if (!el._x_transition)
      el._x_transition = {
        enter: { during: defaultValue, start: defaultValue, end: defaultValue },
        leave: { during: defaultValue, start: defaultValue, end: defaultValue },
        in(before = () => {
        }, after = () => {
        }) {
          transition(el, setFunction, {
            during: this.enter.during,
            start: this.enter.start,
            end: this.enter.end
          }, before, after);
        },
        out(before = () => {
        }, after = () => {
        }) {
          transition(el, setFunction, {
            during: this.leave.during,
            start: this.leave.start,
            end: this.leave.end
          }, before, after);
        }
      };
  }
  window.Element.prototype._x_toggleAndCascadeWithTransitions = function(el, value, show, hide) {
    let clickAwayCompatibleShow = () => {
      document.visibilityState === "visible" ? requestAnimationFrame(show) : setTimeout(show);
    };
    if (value) {
      if (el._x_transition && (el._x_transition.enter || el._x_transition.leave)) {
        el._x_transition.enter && (Object.entries(el._x_transition.enter.during).length || Object.entries(el._x_transition.enter.start).length || Object.entries(el._x_transition.enter.end).length) ? el._x_transition.in(show) : clickAwayCompatibleShow();
      } else {
        el._x_transition ? el._x_transition.in(show) : clickAwayCompatibleShow();
      }
      return;
    }
    el._x_hidePromise = el._x_transition ? new Promise((resolve, reject) => {
      el._x_transition.out(() => {
      }, () => resolve(hide));
      el._x_transitioning.beforeCancel(() => reject({ isFromCancelledTransition: true }));
    }) : Promise.resolve(hide);
    queueMicrotask(() => {
      let closest = closestHide(el);
      if (closest) {
        if (!closest._x_hideChildren)
          closest._x_hideChildren = [];
        closest._x_hideChildren.push(el);
      } else {
        queueMicrotask(() => {
          let hideAfterChildren = (el2) => {
            let carry = Promise.all([
              el2._x_hidePromise,
              ...(el2._x_hideChildren || []).map(hideAfterChildren)
            ]).then(([i]) => i());
            delete el2._x_hidePromise;
            delete el2._x_hideChildren;
            return carry;
          };
          hideAfterChildren(el).catch((e) => {
            if (!e.isFromCancelledTransition)
              throw e;
          });
        });
      }
    });
  };
  function closestHide(el) {
    let parent = el.parentNode;
    if (!parent)
      return;
    return parent._x_hidePromise ? parent : closestHide(parent);
  }
  function transition(el, setFunction, { during, start: start2, end } = {}, before = () => {
  }, after = () => {
  }) {
    if (el._x_transitioning)
      el._x_transitioning.cancel();
    if (Object.keys(during).length === 0 && Object.keys(start2).length === 0 && Object.keys(end).length === 0) {
      before();
      after();
      return;
    }
    let undoStart, undoDuring, undoEnd;
    performTransition(el, {
      start() {
        undoStart = setFunction(el, start2);
      },
      during() {
        undoDuring = setFunction(el, during);
      },
      before,
      end() {
        undoStart();
        undoEnd = setFunction(el, end);
      },
      after,
      cleanup() {
        undoDuring();
        undoEnd();
      }
    });
  }
  function performTransition(el, stages) {
    let interrupted, reachedBefore, reachedEnd;
    let finish = once(() => {
      mutateDom(() => {
        interrupted = true;
        if (!reachedBefore)
          stages.before();
        if (!reachedEnd) {
          stages.end();
          releaseNextTicks();
        }
        stages.after();
        if (el.isConnected)
          stages.cleanup();
        delete el._x_transitioning;
      });
    });
    el._x_transitioning = {
      beforeCancels: [],
      beforeCancel(callback) {
        this.beforeCancels.push(callback);
      },
      cancel: once(function() {
        while (this.beforeCancels.length) {
          this.beforeCancels.shift()();
        }
        ;
        finish();
      }),
      finish
    };
    mutateDom(() => {
      stages.start();
      stages.during();
    });
    holdNextTicks();
    requestAnimationFrame(() => {
      if (interrupted)
        return;
      let duration = Number(getComputedStyle(el).transitionDuration.replace(/,.*/, "").replace("s", "")) * 1e3;
      let delay = Number(getComputedStyle(el).transitionDelay.replace(/,.*/, "").replace("s", "")) * 1e3;
      if (duration === 0)
        duration = Number(getComputedStyle(el).animationDuration.replace("s", "")) * 1e3;
      mutateDom(() => {
        stages.before();
      });
      reachedBefore = true;
      requestAnimationFrame(() => {
        if (interrupted)
          return;
        mutateDom(() => {
          stages.end();
        });
        releaseNextTicks();
        setTimeout(el._x_transitioning.finish, duration + delay);
        reachedEnd = true;
      });
    });
  }
  function modifierValue(modifiers, key, fallback) {
    if (modifiers.indexOf(key) === -1)
      return fallback;
    const rawValue = modifiers[modifiers.indexOf(key) + 1];
    if (!rawValue)
      return fallback;
    if (key === "scale") {
      if (isNaN(rawValue))
        return fallback;
    }
    if (key === "duration") {
      let match3 = rawValue.match(/([0-9]+)ms/);
      if (match3)
        return match3[1];
    }
    if (key === "origin") {
      if (["top", "right", "left", "center", "bottom"].includes(modifiers[modifiers.indexOf(key) + 2])) {
        return [rawValue, modifiers[modifiers.indexOf(key) + 2]].join(" ");
      }
    }
    return rawValue;
  }
  var isCloning = false;
  function skipDuringClone(callback, fallback = () => {
  }) {
    return (...args) => isCloning ? fallback(...args) : callback(...args);
  }
  function clone2(oldEl, newEl) {
    if (!newEl._x_dataStack)
      newEl._x_dataStack = oldEl._x_dataStack;
    isCloning = true;
    dontRegisterReactiveSideEffects(() => {
      cloneTree(newEl);
    });
    isCloning = false;
  }
  function cloneTree(el) {
    let hasRunThroughFirstEl = false;
    let shallowWalker = (el2, callback) => {
      walk(el2, (el3, skip) => {
        if (hasRunThroughFirstEl && isRoot(el3))
          return skip();
        hasRunThroughFirstEl = true;
        callback(el3, skip);
      });
    };
    initTree(el, shallowWalker);
  }
  function dontRegisterReactiveSideEffects(callback) {
    let cache = effect;
    overrideEffect((callback2, el) => {
      let storedEffect = cache(callback2);
      release(storedEffect);
      return () => {
      };
    });
    callback();
    overrideEffect(cache);
  }
  function bind(el, name, value, modifiers = []) {
    if (!el._x_bindings)
      el._x_bindings = reactive({});
    el._x_bindings[name] = value;
    name = modifiers.includes("camel") ? camelCase(name) : name;
    switch (name) {
      case "value":
        bindInputValue(el, value);
        break;
      case "style":
        bindStyles(el, value);
        break;
      case "class":
        bindClasses(el, value);
        break;
      default:
        bindAttribute(el, name, value);
        break;
    }
  }
  function bindInputValue(el, value) {
    if (el.type === "radio") {
      if (el.attributes.value === void 0) {
        el.value = value;
      }
      if (window.fromModel) {
        el.checked = checkedAttrLooseCompare(el.value, value);
      }
    } else if (el.type === "checkbox") {
      if (Number.isInteger(value)) {
        el.value = value;
      } else if (!Number.isInteger(value) && !Array.isArray(value) && typeof value !== "boolean" && ![null, void 0].includes(value)) {
        el.value = String(value);
      } else {
        if (Array.isArray(value)) {
          el.checked = value.some((val) => checkedAttrLooseCompare(val, el.value));
        } else {
          el.checked = !!value;
        }
      }
    } else if (el.tagName === "SELECT") {
      updateSelect(el, value);
    } else {
      if (el.value === value)
        return;
      el.value = value;
    }
  }
  function bindClasses(el, value) {
    if (el._x_undoAddedClasses)
      el._x_undoAddedClasses();
    el._x_undoAddedClasses = setClasses(el, value);
  }
  function bindStyles(el, value) {
    if (el._x_undoAddedStyles)
      el._x_undoAddedStyles();
    el._x_undoAddedStyles = setStyles(el, value);
  }
  function bindAttribute(el, name, value) {
    if ([null, void 0, false].includes(value) && attributeShouldntBePreservedIfFalsy(name)) {
      el.removeAttribute(name);
    } else {
      if (isBooleanAttr(name))
        value = name;
      setIfChanged(el, name, value);
    }
  }
  function setIfChanged(el, attrName, value) {
    if (el.getAttribute(attrName) != value) {
      el.setAttribute(attrName, value);
    }
  }
  function updateSelect(el, value) {
    const arrayWrappedValue = [].concat(value).map((value2) => {
      return value2 + "";
    });
    Array.from(el.options).forEach((option) => {
      option.selected = arrayWrappedValue.includes(option.value);
    });
  }
  function camelCase(subject) {
    return subject.toLowerCase().replace(/-(\w)/g, (match3, char) => char.toUpperCase());
  }
  function checkedAttrLooseCompare(valueA, valueB) {
    return valueA == valueB;
  }
  function isBooleanAttr(attrName) {
    const booleanAttributes = [
      "disabled",
      "checked",
      "required",
      "readonly",
      "hidden",
      "open",
      "selected",
      "autofocus",
      "itemscope",
      "multiple",
      "novalidate",
      "allowfullscreen",
      "allowpaymentrequest",
      "formnovalidate",
      "autoplay",
      "controls",
      "loop",
      "muted",
      "playsinline",
      "default",
      "ismap",
      "reversed",
      "async",
      "defer",
      "nomodule"
    ];
    return booleanAttributes.includes(attrName);
  }
  function attributeShouldntBePreservedIfFalsy(name) {
    return !["aria-pressed", "aria-checked", "aria-expanded", "aria-selected"].includes(name);
  }
  function getBinding(el, name, fallback) {
    if (el._x_bindings && el._x_bindings[name] !== void 0)
      return el._x_bindings[name];
    let attr = el.getAttribute(name);
    if (attr === null)
      return typeof fallback === "function" ? fallback() : fallback;
    if (isBooleanAttr(name)) {
      return !![name, "true"].includes(attr);
    }
    if (attr === "")
      return true;
    return attr;
  }
  function debounce(func, wait) {
    var timeout;
    return function() {
      var context = this, args = arguments;
      var later = function() {
        timeout = null;
        func.apply(context, args);
      };
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
    };
  }
  function throttle(func, limit) {
    let inThrottle;
    return function() {
      let context = this, args = arguments;
      if (!inThrottle) {
        func.apply(context, args);
        inThrottle = true;
        setTimeout(() => inThrottle = false, limit);
      }
    };
  }
  function plugin(callback) {
    callback(alpine_default);
  }
  var stores = {};
  var isReactive = false;
  function store(name, value) {
    if (!isReactive) {
      stores = reactive(stores);
      isReactive = true;
    }
    if (value === void 0) {
      return stores[name];
    }
    stores[name] = value;
    if (typeof value === "object" && value !== null && value.hasOwnProperty("init") && typeof value.init === "function") {
      stores[name].init();
    }
    initInterceptors(stores[name]);
  }
  function getStores() {
    return stores;
  }
  var binds = {};
  function bind2(name, object) {
    binds[name] = typeof object !== "function" ? () => object : object;
  }
  function injectBindingProviders(obj) {
    Object.entries(binds).forEach(([name, callback]) => {
      Object.defineProperty(obj, name, {
        get() {
          return (...args) => {
            return callback(...args);
          };
        }
      });
    });
    return obj;
  }
  var datas = {};
  function data(name, callback) {
    datas[name] = callback;
  }
  function injectDataProviders(obj, context) {
    Object.entries(datas).forEach(([name, callback]) => {
      Object.defineProperty(obj, name, {
        get() {
          return (...args) => {
            return callback.bind(context)(...args);
          };
        },
        enumerable: false
      });
    });
    return obj;
  }
  var Alpine = {
    get reactive() {
      return reactive;
    },
    get release() {
      return release;
    },
    get effect() {
      return effect;
    },
    get raw() {
      return raw;
    },
    version: "3.10.0",
    flushAndStopDeferringMutations,
    dontAutoEvaluateFunctions,
    disableEffectScheduling,
    setReactivityEngine,
    closestDataStack,
    skipDuringClone,
    addRootSelector,
    addInitSelector,
    addScopeToNode,
    deferMutations,
    mapAttributes,
    evaluateLater,
    setEvaluator,
    mergeProxies,
    findClosest,
    closestRoot,
    interceptor,
    transition,
    setStyles,
    mutateDom,
    directive,
    throttle,
    debounce,
    evaluate,
    initTree,
    nextTick,
    prefixed: prefix,
    prefix: setPrefix,
    plugin,
    magic,
    store,
    start,
    clone: clone2,
    bound: getBinding,
    $data: scope,
    data,
    bind: bind2
  };
  var alpine_default = Alpine;
  function makeMap(str, expectsLowerCase) {
    const map = Object.create(null);
    const list = str.split(",");
    for (let i = 0; i < list.length; i++) {
      map[list[i]] = true;
    }
    return expectsLowerCase ? (val) => !!map[val.toLowerCase()] : (val) => !!map[val];
  }
  var PatchFlagNames = {
    [1]: `TEXT`,
    [2]: `CLASS`,
    [4]: `STYLE`,
    [8]: `PROPS`,
    [16]: `FULL_PROPS`,
    [32]: `HYDRATE_EVENTS`,
    [64]: `STABLE_FRAGMENT`,
    [128]: `KEYED_FRAGMENT`,
    [256]: `UNKEYED_FRAGMENT`,
    [512]: `NEED_PATCH`,
    [1024]: `DYNAMIC_SLOTS`,
    [2048]: `DEV_ROOT_FRAGMENT`,
    [-1]: `HOISTED`,
    [-2]: `BAIL`
  };
  var slotFlagsText = {
    [1]: "STABLE",
    [2]: "DYNAMIC",
    [3]: "FORWARDED"
  };
  var specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
  var isBooleanAttr2 = /* @__PURE__ */ makeMap(specialBooleanAttrs + `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,loop,open,required,reversed,scoped,seamless,checked,muted,multiple,selected`);
  var EMPTY_OBJ = false ? Object.freeze({}) : {};
  var EMPTY_ARR = false ? Object.freeze([]) : [];
  var extend = Object.assign;
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var hasOwn = (val, key) => hasOwnProperty.call(val, key);
  var isArray = Array.isArray;
  var isMap = (val) => toTypeString(val) === "[object Map]";
  var isString = (val) => typeof val === "string";
  var isSymbol = (val) => typeof val === "symbol";
  var isObject2 = (val) => val !== null && typeof val === "object";
  var objectToString = Object.prototype.toString;
  var toTypeString = (value) => objectToString.call(value);
  var toRawType = (value) => {
    return toTypeString(value).slice(8, -1);
  };
  var isIntegerKey = (key) => isString(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
  var cacheStringFunction = (fn) => {
    const cache = Object.create(null);
    return (str) => {
      const hit = cache[str];
      return hit || (cache[str] = fn(str));
    };
  };
  var camelizeRE = /-(\w)/g;
  var camelize = cacheStringFunction((str) => {
    return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : "");
  });
  var hyphenateRE = /\B([A-Z])/g;
  var hyphenate = cacheStringFunction((str) => str.replace(hyphenateRE, "-$1").toLowerCase());
  var capitalize = cacheStringFunction((str) => str.charAt(0).toUpperCase() + str.slice(1));
  var toHandlerKey = cacheStringFunction((str) => str ? `on${capitalize(str)}` : ``);
  var hasChanged = (value, oldValue) => value !== oldValue && (value === value || oldValue === oldValue);
  var targetMap = new WeakMap();
  var effectStack = [];
  var activeEffect;
  var ITERATE_KEY = Symbol(false ? "iterate" : "");
  var MAP_KEY_ITERATE_KEY = Symbol(false ? "Map key iterate" : "");
  function isEffect(fn) {
    return fn && fn._isEffect === true;
  }
  function effect2(fn, options = EMPTY_OBJ) {
    if (isEffect(fn)) {
      fn = fn.raw;
    }
    const effect3 = createReactiveEffect(fn, options);
    if (!options.lazy) {
      effect3();
    }
    return effect3;
  }
  function stop(effect3) {
    if (effect3.active) {
      cleanup(effect3);
      if (effect3.options.onStop) {
        effect3.options.onStop();
      }
      effect3.active = false;
    }
  }
  var uid = 0;
  function createReactiveEffect(fn, options) {
    const effect3 = function reactiveEffect() {
      if (!effect3.active) {
        return fn();
      }
      if (!effectStack.includes(effect3)) {
        cleanup(effect3);
        try {
          enableTracking();
          effectStack.push(effect3);
          activeEffect = effect3;
          return fn();
        } finally {
          effectStack.pop();
          resetTracking();
          activeEffect = effectStack[effectStack.length - 1];
        }
      }
    };
    effect3.id = uid++;
    effect3.allowRecurse = !!options.allowRecurse;
    effect3._isEffect = true;
    effect3.active = true;
    effect3.raw = fn;
    effect3.deps = [];
    effect3.options = options;
    return effect3;
  }
  function cleanup(effect3) {
    const { deps } = effect3;
    if (deps.length) {
      for (let i = 0; i < deps.length; i++) {
        deps[i].delete(effect3);
      }
      deps.length = 0;
    }
  }
  var shouldTrack = true;
  var trackStack = [];
  function pauseTracking() {
    trackStack.push(shouldTrack);
    shouldTrack = false;
  }
  function enableTracking() {
    trackStack.push(shouldTrack);
    shouldTrack = true;
  }
  function resetTracking() {
    const last = trackStack.pop();
    shouldTrack = last === void 0 ? true : last;
  }
  function track(target, type, key) {
    if (!shouldTrack || activeEffect === void 0) {
      return;
    }
    let depsMap = targetMap.get(target);
    if (!depsMap) {
      targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
    }
    let dep = depsMap.get(key);
    if (!dep) {
      depsMap.set(key, dep = /* @__PURE__ */ new Set());
    }
    if (!dep.has(activeEffect)) {
      dep.add(activeEffect);
      activeEffect.deps.push(dep);
      if (false) {
        activeEffect.options.onTrack({
          effect: activeEffect,
          target,
          type,
          key
        });
      }
    }
  }
  function trigger(target, type, key, newValue, oldValue, oldTarget) {
    const depsMap = targetMap.get(target);
    if (!depsMap) {
      return;
    }
    const effects = /* @__PURE__ */ new Set();
    const add2 = (effectsToAdd) => {
      if (effectsToAdd) {
        effectsToAdd.forEach((effect3) => {
          if (effect3 !== activeEffect || effect3.allowRecurse) {
            effects.add(effect3);
          }
        });
      }
    };
    if (type === "clear") {
      depsMap.forEach(add2);
    } else if (key === "length" && isArray(target)) {
      depsMap.forEach((dep, key2) => {
        if (key2 === "length" || key2 >= newValue) {
          add2(dep);
        }
      });
    } else {
      if (key !== void 0) {
        add2(depsMap.get(key));
      }
      switch (type) {
        case "add":
          if (!isArray(target)) {
            add2(depsMap.get(ITERATE_KEY));
            if (isMap(target)) {
              add2(depsMap.get(MAP_KEY_ITERATE_KEY));
            }
          } else if (isIntegerKey(key)) {
            add2(depsMap.get("length"));
          }
          break;
        case "delete":
          if (!isArray(target)) {
            add2(depsMap.get(ITERATE_KEY));
            if (isMap(target)) {
              add2(depsMap.get(MAP_KEY_ITERATE_KEY));
            }
          }
          break;
        case "set":
          if (isMap(target)) {
            add2(depsMap.get(ITERATE_KEY));
          }
          break;
      }
    }
    const run = (effect3) => {
      if (false) {
        effect3.options.onTrigger({
          effect: effect3,
          target,
          key,
          type,
          newValue,
          oldValue,
          oldTarget
        });
      }
      if (effect3.options.scheduler) {
        effect3.options.scheduler(effect3);
      } else {
        effect3();
      }
    };
    effects.forEach(run);
  }
  var isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
  var builtInSymbols = new Set(Object.getOwnPropertyNames(Symbol).map((key) => Symbol[key]).filter(isSymbol));
  var get2 = /* @__PURE__ */ createGetter();
  var shallowGet = /* @__PURE__ */ createGetter(false, true);
  var readonlyGet = /* @__PURE__ */ createGetter(true);
  var shallowReadonlyGet = /* @__PURE__ */ createGetter(true, true);
  var arrayInstrumentations = {};
  ["includes", "indexOf", "lastIndexOf"].forEach((key) => {
    const method = Array.prototype[key];
    arrayInstrumentations[key] = function(...args) {
      const arr = toRaw(this);
      for (let i = 0, l = this.length; i < l; i++) {
        track(arr, "get", i + "");
      }
      const res = method.apply(arr, args);
      if (res === -1 || res === false) {
        return method.apply(arr, args.map(toRaw));
      } else {
        return res;
      }
    };
  });
  ["push", "pop", "shift", "unshift", "splice"].forEach((key) => {
    const method = Array.prototype[key];
    arrayInstrumentations[key] = function(...args) {
      pauseTracking();
      const res = method.apply(this, args);
      resetTracking();
      return res;
    };
  });
  function createGetter(isReadonly = false, shallow = false) {
    return function get3(target, key, receiver) {
      if (key === "__v_isReactive") {
        return !isReadonly;
      } else if (key === "__v_isReadonly") {
        return isReadonly;
      } else if (key === "__v_raw" && receiver === (isReadonly ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap).get(target)) {
        return target;
      }
      const targetIsArray = isArray(target);
      if (!isReadonly && targetIsArray && hasOwn(arrayInstrumentations, key)) {
        return Reflect.get(arrayInstrumentations, key, receiver);
      }
      const res = Reflect.get(target, key, receiver);
      if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
        return res;
      }
      if (!isReadonly) {
        track(target, "get", key);
      }
      if (shallow) {
        return res;
      }
      if (isRef(res)) {
        const shouldUnwrap = !targetIsArray || !isIntegerKey(key);
        return shouldUnwrap ? res.value : res;
      }
      if (isObject2(res)) {
        return isReadonly ? readonly(res) : reactive2(res);
      }
      return res;
    };
  }
  var set2 = /* @__PURE__ */ createSetter();
  var shallowSet = /* @__PURE__ */ createSetter(true);
  function createSetter(shallow = false) {
    return function set3(target, key, value, receiver) {
      let oldValue = target[key];
      if (!shallow) {
        value = toRaw(value);
        oldValue = toRaw(oldValue);
        if (!isArray(target) && isRef(oldValue) && !isRef(value)) {
          oldValue.value = value;
          return true;
        }
      }
      const hadKey = isArray(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);
      const result = Reflect.set(target, key, value, receiver);
      if (target === toRaw(receiver)) {
        if (!hadKey) {
          trigger(target, "add", key, value);
        } else if (hasChanged(value, oldValue)) {
          trigger(target, "set", key, value, oldValue);
        }
      }
      return result;
    };
  }
  function deleteProperty(target, key) {
    const hadKey = hasOwn(target, key);
    const oldValue = target[key];
    const result = Reflect.deleteProperty(target, key);
    if (result && hadKey) {
      trigger(target, "delete", key, void 0, oldValue);
    }
    return result;
  }
  function has(target, key) {
    const result = Reflect.has(target, key);
    if (!isSymbol(key) || !builtInSymbols.has(key)) {
      track(target, "has", key);
    }
    return result;
  }
  function ownKeys(target) {
    track(target, "iterate", isArray(target) ? "length" : ITERATE_KEY);
    return Reflect.ownKeys(target);
  }
  var mutableHandlers = {
    get: get2,
    set: set2,
    deleteProperty,
    has,
    ownKeys
  };
  var readonlyHandlers = {
    get: readonlyGet,
    set(target, key) {
      if (false) {
        console.warn(`Set operation on key "${String(key)}" failed: target is readonly.`, target);
      }
      return true;
    },
    deleteProperty(target, key) {
      if (false) {
        console.warn(`Delete operation on key "${String(key)}" failed: target is readonly.`, target);
      }
      return true;
    }
  };
  var shallowReactiveHandlers = extend({}, mutableHandlers, {
    get: shallowGet,
    set: shallowSet
  });
  var shallowReadonlyHandlers = extend({}, readonlyHandlers, {
    get: shallowReadonlyGet
  });
  var toReactive = (value) => isObject2(value) ? reactive2(value) : value;
  var toReadonly = (value) => isObject2(value) ? readonly(value) : value;
  var toShallow = (value) => value;
  var getProto = (v) => Reflect.getPrototypeOf(v);
  function get$1(target, key, isReadonly = false, isShallow = false) {
    target = target["__v_raw"];
    const rawTarget = toRaw(target);
    const rawKey = toRaw(key);
    if (key !== rawKey) {
      !isReadonly && track(rawTarget, "get", key);
    }
    !isReadonly && track(rawTarget, "get", rawKey);
    const { has: has2 } = getProto(rawTarget);
    const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;
    if (has2.call(rawTarget, key)) {
      return wrap(target.get(key));
    } else if (has2.call(rawTarget, rawKey)) {
      return wrap(target.get(rawKey));
    } else if (target !== rawTarget) {
      target.get(key);
    }
  }
  function has$1(key, isReadonly = false) {
    const target = this["__v_raw"];
    const rawTarget = toRaw(target);
    const rawKey = toRaw(key);
    if (key !== rawKey) {
      !isReadonly && track(rawTarget, "has", key);
    }
    !isReadonly && track(rawTarget, "has", rawKey);
    return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
  }
  function size(target, isReadonly = false) {
    target = target["__v_raw"];
    !isReadonly && track(toRaw(target), "iterate", ITERATE_KEY);
    return Reflect.get(target, "size", target);
  }
  function add(value) {
    value = toRaw(value);
    const target = toRaw(this);
    const proto = getProto(target);
    const hadKey = proto.has.call(target, value);
    if (!hadKey) {
      target.add(value);
      trigger(target, "add", value, value);
    }
    return this;
  }
  function set$1(key, value) {
    value = toRaw(value);
    const target = toRaw(this);
    const { has: has2, get: get3 } = getProto(target);
    let hadKey = has2.call(target, key);
    if (!hadKey) {
      key = toRaw(key);
      hadKey = has2.call(target, key);
    } else if (false) {
      checkIdentityKeys(target, has2, key);
    }
    const oldValue = get3.call(target, key);
    target.set(key, value);
    if (!hadKey) {
      trigger(target, "add", key, value);
    } else if (hasChanged(value, oldValue)) {
      trigger(target, "set", key, value, oldValue);
    }
    return this;
  }
  function deleteEntry(key) {
    const target = toRaw(this);
    const { has: has2, get: get3 } = getProto(target);
    let hadKey = has2.call(target, key);
    if (!hadKey) {
      key = toRaw(key);
      hadKey = has2.call(target, key);
    } else if (false) {
      checkIdentityKeys(target, has2, key);
    }
    const oldValue = get3 ? get3.call(target, key) : void 0;
    const result = target.delete(key);
    if (hadKey) {
      trigger(target, "delete", key, void 0, oldValue);
    }
    return result;
  }
  function clear() {
    const target = toRaw(this);
    const hadItems = target.size !== 0;
    const oldTarget = false ? isMap(target) ? new Map(target) : new Set(target) : void 0;
    const result = target.clear();
    if (hadItems) {
      trigger(target, "clear", void 0, void 0, oldTarget);
    }
    return result;
  }
  function createForEach(isReadonly, isShallow) {
    return function forEach(callback, thisArg) {
      const observed = this;
      const target = observed["__v_raw"];
      const rawTarget = toRaw(target);
      const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;
      !isReadonly && track(rawTarget, "iterate", ITERATE_KEY);
      return target.forEach((value, key) => {
        return callback.call(thisArg, wrap(value), wrap(key), observed);
      });
    };
  }
  function createIterableMethod(method, isReadonly, isShallow) {
    return function(...args) {
      const target = this["__v_raw"];
      const rawTarget = toRaw(target);
      const targetIsMap = isMap(rawTarget);
      const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
      const isKeyOnly = method === "keys" && targetIsMap;
      const innerIterator = target[method](...args);
      const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;
      !isReadonly && track(rawTarget, "iterate", isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);
      return {
        next() {
          const { value, done } = innerIterator.next();
          return done ? { value, done } : {
            value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
            done
          };
        },
        [Symbol.iterator]() {
          return this;
        }
      };
    };
  }
  function createReadonlyMethod(type) {
    return function(...args) {
      if (false) {
        const key = args[0] ? `on key "${args[0]}" ` : ``;
        console.warn(`${capitalize(type)} operation ${key}failed: target is readonly.`, toRaw(this));
      }
      return type === "delete" ? false : this;
    };
  }
  var mutableInstrumentations = {
    get(key) {
      return get$1(this, key);
    },
    get size() {
      return size(this);
    },
    has: has$1,
    add,
    set: set$1,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, false)
  };
  var shallowInstrumentations = {
    get(key) {
      return get$1(this, key, false, true);
    },
    get size() {
      return size(this);
    },
    has: has$1,
    add,
    set: set$1,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, true)
  };
  var readonlyInstrumentations = {
    get(key) {
      return get$1(this, key, true);
    },
    get size() {
      return size(this, true);
    },
    has(key) {
      return has$1.call(this, key, true);
    },
    add: createReadonlyMethod("add"),
    set: createReadonlyMethod("set"),
    delete: createReadonlyMethod("delete"),
    clear: createReadonlyMethod("clear"),
    forEach: createForEach(true, false)
  };
  var shallowReadonlyInstrumentations = {
    get(key) {
      return get$1(this, key, true, true);
    },
    get size() {
      return size(this, true);
    },
    has(key) {
      return has$1.call(this, key, true);
    },
    add: createReadonlyMethod("add"),
    set: createReadonlyMethod("set"),
    delete: createReadonlyMethod("delete"),
    clear: createReadonlyMethod("clear"),
    forEach: createForEach(true, true)
  };
  var iteratorMethods = ["keys", "values", "entries", Symbol.iterator];
  iteratorMethods.forEach((method) => {
    mutableInstrumentations[method] = createIterableMethod(method, false, false);
    readonlyInstrumentations[method] = createIterableMethod(method, true, false);
    shallowInstrumentations[method] = createIterableMethod(method, false, true);
    shallowReadonlyInstrumentations[method] = createIterableMethod(method, true, true);
  });
  function createInstrumentationGetter(isReadonly, shallow) {
    const instrumentations = shallow ? isReadonly ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly ? readonlyInstrumentations : mutableInstrumentations;
    return (target, key, receiver) => {
      if (key === "__v_isReactive") {
        return !isReadonly;
      } else if (key === "__v_isReadonly") {
        return isReadonly;
      } else if (key === "__v_raw") {
        return target;
      }
      return Reflect.get(hasOwn(instrumentations, key) && key in target ? instrumentations : target, key, receiver);
    };
  }
  var mutableCollectionHandlers = {
    get: createInstrumentationGetter(false, false)
  };
  var shallowCollectionHandlers = {
    get: createInstrumentationGetter(false, true)
  };
  var readonlyCollectionHandlers = {
    get: createInstrumentationGetter(true, false)
  };
  var shallowReadonlyCollectionHandlers = {
    get: createInstrumentationGetter(true, true)
  };
  var reactiveMap = new WeakMap();
  var shallowReactiveMap = new WeakMap();
  var readonlyMap = new WeakMap();
  var shallowReadonlyMap = new WeakMap();
  function targetTypeMap(rawType) {
    switch (rawType) {
      case "Object":
      case "Array":
        return 1;
      case "Map":
      case "Set":
      case "WeakMap":
      case "WeakSet":
        return 2;
      default:
        return 0;
    }
  }
  function getTargetType(value) {
    return value["__v_skip"] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
  }
  function reactive2(target) {
    if (target && target["__v_isReadonly"]) {
      return target;
    }
    return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);
  }
  function readonly(target) {
    return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);
  }
  function createReactiveObject(target, isReadonly, baseHandlers, collectionHandlers, proxyMap) {
    if (!isObject2(target)) {
      if (false) {
        console.warn(`value cannot be made reactive: ${String(target)}`);
      }
      return target;
    }
    if (target["__v_raw"] && !(isReadonly && target["__v_isReactive"])) {
      return target;
    }
    const existingProxy = proxyMap.get(target);
    if (existingProxy) {
      return existingProxy;
    }
    const targetType = getTargetType(target);
    if (targetType === 0) {
      return target;
    }
    const proxy = new Proxy(target, targetType === 2 ? collectionHandlers : baseHandlers);
    proxyMap.set(target, proxy);
    return proxy;
  }
  function toRaw(observed) {
    return observed && toRaw(observed["__v_raw"]) || observed;
  }
  function isRef(r) {
    return Boolean(r && r.__v_isRef === true);
  }
  magic("nextTick", () => nextTick);
  magic("dispatch", (el) => dispatch.bind(dispatch, el));
  magic("watch", (el, { evaluateLater: evaluateLater2, effect: effect3 }) => (key, callback) => {
    let evaluate2 = evaluateLater2(key);
    let firstTime = true;
    let oldValue;
    let effectReference = effect3(() => evaluate2((value) => {
      JSON.stringify(value);
      if (!firstTime) {
        queueMicrotask(() => {
          callback(value, oldValue);
          oldValue = value;
        });
      } else {
        oldValue = value;
      }
      firstTime = false;
    }));
    el._x_effects.delete(effectReference);
  });
  magic("store", getStores);
  magic("data", (el) => scope(el));
  magic("root", (el) => closestRoot(el));
  magic("refs", (el) => {
    if (el._x_refs_proxy)
      return el._x_refs_proxy;
    el._x_refs_proxy = mergeProxies(getArrayOfRefObject(el));
    return el._x_refs_proxy;
  });
  function getArrayOfRefObject(el) {
    let refObjects = [];
    let currentEl = el;
    while (currentEl) {
      if (currentEl._x_refs)
        refObjects.push(currentEl._x_refs);
      currentEl = currentEl.parentNode;
    }
    return refObjects;
  }
  var globalIdMemo = {};
  function findAndIncrementId(name) {
    if (!globalIdMemo[name])
      globalIdMemo[name] = 0;
    return ++globalIdMemo[name];
  }
  function closestIdRoot(el, name) {
    return findClosest(el, (element) => {
      if (element._x_ids && element._x_ids[name])
        return true;
    });
  }
  function setIdRoot(el, name) {
    if (!el._x_ids)
      el._x_ids = {};
    if (!el._x_ids[name])
      el._x_ids[name] = findAndIncrementId(name);
  }
  magic("id", (el) => (name, key = null) => {
    let root = closestIdRoot(el, name);
    let id = root ? root._x_ids[name] : findAndIncrementId(name);
    return key ? `${name}-${id}-${key}` : `${name}-${id}`;
  });
  magic("el", (el) => el);
  warnMissingPluginMagic("Focus", "focus", "focus");
  warnMissingPluginMagic("Persist", "persist", "persist");
  function warnMissingPluginMagic(name, magicName, slug) {
    magic(magicName, (el) => warn(`You can't use [$${directiveName}] without first installing the "${name}" plugin here: https://alpinejs.dev/plugins/${slug}`, el));
  }
  directive("modelable", (el, { expression }, { effect: effect3, evaluateLater: evaluateLater2 }) => {
    let func = evaluateLater2(expression);
    let innerGet = () => {
      let result;
      func((i) => result = i);
      return result;
    };
    let evaluateInnerSet = evaluateLater2(`${expression} = __placeholder`);
    let innerSet = (val) => evaluateInnerSet(() => {
    }, { scope: { __placeholder: val } });
    let initialValue = innerGet();
    innerSet(initialValue);
    queueMicrotask(() => {
      if (!el._x_model)
        return;
      el._x_removeModelListeners["default"]();
      let outerGet = el._x_model.get;
      let outerSet = el._x_model.set;
      effect3(() => innerSet(outerGet()));
      effect3(() => outerSet(innerGet()));
    });
  });
  directive("teleport", (el, { expression }, { cleanup: cleanup2 }) => {
    if (el.tagName.toLowerCase() !== "template")
      warn("x-teleport can only be used on a <template> tag", el);
    let target = document.querySelector(expression);
    if (!target)
      warn(`Cannot find x-teleport element for selector: "${expression}"`);
    let clone22 = el.content.cloneNode(true).firstElementChild;
    el._x_teleport = clone22;
    clone22._x_teleportBack = el;
    if (el._x_forwardEvents) {
      el._x_forwardEvents.forEach((eventName) => {
        clone22.addEventListener(eventName, (e) => {
          e.stopPropagation();
          el.dispatchEvent(new e.constructor(e.type, e));
        });
      });
    }
    addScopeToNode(clone22, {}, el);
    mutateDom(() => {
      target.appendChild(clone22);
      initTree(clone22);
      clone22._x_ignore = true;
    });
    cleanup2(() => clone22.remove());
  });
  var handler = () => {
  };
  handler.inline = (el, { modifiers }, { cleanup: cleanup2 }) => {
    modifiers.includes("self") ? el._x_ignoreSelf = true : el._x_ignore = true;
    cleanup2(() => {
      modifiers.includes("self") ? delete el._x_ignoreSelf : delete el._x_ignore;
    });
  };
  directive("ignore", handler);
  directive("effect", (el, { expression }, { effect: effect3 }) => effect3(evaluateLater(el, expression)));
  function on(el, event, modifiers, callback) {
    let listenerTarget = el;
    let handler3 = (e) => callback(e);
    let options = {};
    let wrapHandler = (callback2, wrapper) => (e) => wrapper(callback2, e);
    if (modifiers.includes("dot"))
      event = dotSyntax(event);
    if (modifiers.includes("camel"))
      event = camelCase2(event);
    if (modifiers.includes("passive"))
      options.passive = true;
    if (modifiers.includes("capture"))
      options.capture = true;
    if (modifiers.includes("window"))
      listenerTarget = window;
    if (modifiers.includes("document"))
      listenerTarget = document;
    if (modifiers.includes("prevent"))
      handler3 = wrapHandler(handler3, (next, e) => {
        e.preventDefault();
        next(e);
      });
    if (modifiers.includes("stop"))
      handler3 = wrapHandler(handler3, (next, e) => {
        e.stopPropagation();
        next(e);
      });
    if (modifiers.includes("self"))
      handler3 = wrapHandler(handler3, (next, e) => {
        e.target === el && next(e);
      });
    if (modifiers.includes("away") || modifiers.includes("outside")) {
      listenerTarget = document;
      handler3 = wrapHandler(handler3, (next, e) => {
        if (el.contains(e.target))
          return;
        if (e.target.isConnected === false)
          return;
        if (el.offsetWidth < 1 && el.offsetHeight < 1)
          return;
        if (el._x_isShown === false)
          return;
        next(e);
      });
    }
    if (modifiers.includes("once")) {
      handler3 = wrapHandler(handler3, (next, e) => {
        next(e);
        listenerTarget.removeEventListener(event, handler3, options);
      });
    }
    handler3 = wrapHandler(handler3, (next, e) => {
      if (isKeyEvent(event)) {
        if (isListeningForASpecificKeyThatHasntBeenPressed(e, modifiers)) {
          return;
        }
      }
      next(e);
    });
    if (modifiers.includes("debounce")) {
      let nextModifier = modifiers[modifiers.indexOf("debounce") + 1] || "invalid-wait";
      let wait = isNumeric(nextModifier.split("ms")[0]) ? Number(nextModifier.split("ms")[0]) : 250;
      handler3 = debounce(handler3, wait);
    }
    if (modifiers.includes("throttle")) {
      let nextModifier = modifiers[modifiers.indexOf("throttle") + 1] || "invalid-wait";
      let wait = isNumeric(nextModifier.split("ms")[0]) ? Number(nextModifier.split("ms")[0]) : 250;
      handler3 = throttle(handler3, wait);
    }
    listenerTarget.addEventListener(event, handler3, options);
    return () => {
      listenerTarget.removeEventListener(event, handler3, options);
    };
  }
  function dotSyntax(subject) {
    return subject.replace(/-/g, ".");
  }
  function camelCase2(subject) {
    return subject.toLowerCase().replace(/-(\w)/g, (match3, char) => char.toUpperCase());
  }
  function isNumeric(subject) {
    return !Array.isArray(subject) && !isNaN(subject);
  }
  function kebabCase2(subject) {
    return subject.replace(/([a-z])([A-Z])/g, "$1-$2").replace(/[_\s]/, "-").toLowerCase();
  }
  function isKeyEvent(event) {
    return ["keydown", "keyup"].includes(event);
  }
  function isListeningForASpecificKeyThatHasntBeenPressed(e, modifiers) {
    let keyModifiers = modifiers.filter((i) => {
      return !["window", "document", "prevent", "stop", "once"].includes(i);
    });
    if (keyModifiers.includes("debounce")) {
      let debounceIndex = keyModifiers.indexOf("debounce");
      keyModifiers.splice(debounceIndex, isNumeric((keyModifiers[debounceIndex + 1] || "invalid-wait").split("ms")[0]) ? 2 : 1);
    }
    if (keyModifiers.length === 0)
      return false;
    if (keyModifiers.length === 1 && keyToModifiers(e.key).includes(keyModifiers[0]))
      return false;
    const systemKeyModifiers = ["ctrl", "shift", "alt", "meta", "cmd", "super"];
    const selectedSystemKeyModifiers = systemKeyModifiers.filter((modifier) => keyModifiers.includes(modifier));
    keyModifiers = keyModifiers.filter((i) => !selectedSystemKeyModifiers.includes(i));
    if (selectedSystemKeyModifiers.length > 0) {
      const activelyPressedKeyModifiers = selectedSystemKeyModifiers.filter((modifier) => {
        if (modifier === "cmd" || modifier === "super")
          modifier = "meta";
        return e[`${modifier}Key`];
      });
      if (activelyPressedKeyModifiers.length === selectedSystemKeyModifiers.length) {
        if (keyToModifiers(e.key).includes(keyModifiers[0]))
          return false;
      }
    }
    return true;
  }
  function keyToModifiers(key) {
    if (!key)
      return [];
    key = kebabCase2(key);
    let modifierToKeyMap = {
      ctrl: "control",
      slash: "/",
      space: "-",
      spacebar: "-",
      cmd: "meta",
      esc: "escape",
      up: "arrow-up",
      down: "arrow-down",
      left: "arrow-left",
      right: "arrow-right",
      period: ".",
      equal: "="
    };
    modifierToKeyMap[key] = key;
    return Object.keys(modifierToKeyMap).map((modifier) => {
      if (modifierToKeyMap[modifier] === key)
        return modifier;
    }).filter((modifier) => modifier);
  }
  directive("model", (el, { modifiers, expression }, { effect: effect3, cleanup: cleanup2 }) => {
    let evaluate2 = evaluateLater(el, expression);
    let assignmentExpression = `${expression} = rightSideOfExpression($event, ${expression})`;
    let evaluateAssignment = evaluateLater(el, assignmentExpression);
    var event = el.tagName.toLowerCase() === "select" || ["checkbox", "radio"].includes(el.type) || modifiers.includes("lazy") ? "change" : "input";
    let assigmentFunction = generateAssignmentFunction(el, modifiers, expression);
    let removeListener = on(el, event, modifiers, (e) => {
      evaluateAssignment(() => {
      }, { scope: {
        $event: e,
        rightSideOfExpression: assigmentFunction
      } });
    });
    if (!el._x_removeModelListeners)
      el._x_removeModelListeners = {};
    el._x_removeModelListeners["default"] = removeListener;
    cleanup2(() => el._x_removeModelListeners["default"]());
    let evaluateSetModel = evaluateLater(el, `${expression} = __placeholder`);
    el._x_model = {
      get() {
        let result;
        evaluate2((value) => result = value);
        return result;
      },
      set(value) {
        evaluateSetModel(() => {
        }, { scope: { __placeholder: value } });
      }
    };
    el._x_forceModelUpdate = () => {
      evaluate2((value) => {
        if (value === void 0 && expression.match(/\./))
          value = "";
        window.fromModel = true;
        mutateDom(() => bind(el, "value", value));
        delete window.fromModel;
      });
    };
    effect3(() => {
      if (modifiers.includes("unintrusive") && document.activeElement.isSameNode(el))
        return;
      el._x_forceModelUpdate();
    });
  });
  function generateAssignmentFunction(el, modifiers, expression) {
    if (el.type === "radio") {
      mutateDom(() => {
        if (!el.hasAttribute("name"))
          el.setAttribute("name", expression);
      });
    }
    return (event, currentValue) => {
      return mutateDom(() => {
        if (event instanceof CustomEvent && event.detail !== void 0) {
          return event.detail || event.target.value;
        } else if (el.type === "checkbox") {
          if (Array.isArray(currentValue)) {
            let newValue = modifiers.includes("number") ? safeParseNumber(event.target.value) : event.target.value;
            return event.target.checked ? currentValue.concat([newValue]) : currentValue.filter((el2) => !checkedAttrLooseCompare2(el2, newValue));
          } else {
            return event.target.checked;
          }
        } else if (el.tagName.toLowerCase() === "select" && el.multiple) {
          return modifiers.includes("number") ? Array.from(event.target.selectedOptions).map((option) => {
            let rawValue = option.value || option.text;
            return safeParseNumber(rawValue);
          }) : Array.from(event.target.selectedOptions).map((option) => {
            return option.value || option.text;
          });
        } else {
          let rawValue = event.target.value;
          return modifiers.includes("number") ? safeParseNumber(rawValue) : modifiers.includes("trim") ? rawValue.trim() : rawValue;
        }
      });
    };
  }
  function safeParseNumber(rawValue) {
    let number = rawValue ? parseFloat(rawValue) : null;
    return isNumeric2(number) ? number : rawValue;
  }
  function checkedAttrLooseCompare2(valueA, valueB) {
    return valueA == valueB;
  }
  function isNumeric2(subject) {
    return !Array.isArray(subject) && !isNaN(subject);
  }
  directive("cloak", (el) => queueMicrotask(() => mutateDom(() => el.removeAttribute(prefix("cloak")))));
  addInitSelector(() => `[${prefix("init")}]`);
  directive("init", skipDuringClone((el, { expression }, { evaluate: evaluate2 }) => {
    if (typeof expression === "string") {
      return !!expression.trim() && evaluate2(expression, {}, false);
    }
    return evaluate2(expression, {}, false);
  }));
  directive("text", (el, { expression }, { effect: effect3, evaluateLater: evaluateLater2 }) => {
    let evaluate2 = evaluateLater2(expression);
    effect3(() => {
      evaluate2((value) => {
        mutateDom(() => {
          el.textContent = value;
        });
      });
    });
  });
  directive("html", (el, { expression }, { effect: effect3, evaluateLater: evaluateLater2 }) => {
    let evaluate2 = evaluateLater2(expression);
    effect3(() => {
      evaluate2((value) => {
        mutateDom(() => {
          el.innerHTML = value;
          el._x_ignoreSelf = true;
          initTree(el);
          delete el._x_ignoreSelf;
        });
      });
    });
  });
  mapAttributes(startingWith(":", into(prefix("bind:"))));
  directive("bind", (el, { value, modifiers, expression, original }, { effect: effect3 }) => {
    if (!value) {
      return applyBindingsObject(el, expression, original, effect3);
    }
    if (value === "key")
      return storeKeyForXFor(el, expression);
    let evaluate2 = evaluateLater(el, expression);
    effect3(() => evaluate2((result) => {
      if (result === void 0 && expression.match(/\./))
        result = "";
      mutateDom(() => bind(el, value, result, modifiers));
    }));
  });
  function applyBindingsObject(el, expression, original, effect3) {
    let bindingProviders = {};
    injectBindingProviders(bindingProviders);
    let getBindings = evaluateLater(el, expression);
    let cleanupRunners = [];
    while (cleanupRunners.length)
      cleanupRunners.pop()();
    getBindings((bindings) => {
      let attributes = Object.entries(bindings).map(([name, value]) => ({ name, value }));
      let staticAttributes = attributesOnly(attributes);
      attributes = attributes.map((attribute) => {
        if (staticAttributes.find((attr) => attr.name === attribute.name)) {
          return {
            name: `x-bind:${attribute.name}`,
            value: `"${attribute.value}"`
          };
        }
        return attribute;
      });
      directives(el, attributes, original).map((handle) => {
        cleanupRunners.push(handle.runCleanups);
        handle();
      });
    }, { scope: bindingProviders });
  }
  function storeKeyForXFor(el, expression) {
    el._x_keyExpression = expression;
  }
  addRootSelector(() => `[${prefix("data")}]`);
  directive("data", skipDuringClone((el, { expression }, { cleanup: cleanup2 }) => {
    expression = expression === "" ? "{}" : expression;
    let magicContext = {};
    injectMagics(magicContext, el);
    let dataProviderContext = {};
    injectDataProviders(dataProviderContext, magicContext);
    let data2 = evaluate(el, expression, { scope: dataProviderContext });
    if (data2 === void 0)
      data2 = {};
    injectMagics(data2, el);
    let reactiveData = reactive(data2);
    initInterceptors(reactiveData);
    let undo = addScopeToNode(el, reactiveData);
    reactiveData["init"] && evaluate(el, reactiveData["init"]);
    cleanup2(() => {
      reactiveData["destroy"] && evaluate(el, reactiveData["destroy"]);
      undo();
    });
  }));
  directive("show", (el, { modifiers, expression }, { effect: effect3 }) => {
    let evaluate2 = evaluateLater(el, expression);
    if (!el._x_doHide)
      el._x_doHide = () => {
        mutateDom(() => el.style.display = "none");
      };
    if (!el._x_doShow)
      el._x_doShow = () => {
        mutateDom(() => {
          if (el.style.length === 1 && el.style.display === "none") {
            el.removeAttribute("style");
          } else {
            el.style.removeProperty("display");
          }
        });
      };
    let hide = () => {
      el._x_doHide();
      el._x_isShown = false;
    };
    let show = () => {
      el._x_doShow();
      el._x_isShown = true;
    };
    let clickAwayCompatibleShow = () => setTimeout(show);
    let toggle = once((value) => value ? show() : hide(), (value) => {
      if (typeof el._x_toggleAndCascadeWithTransitions === "function") {
        el._x_toggleAndCascadeWithTransitions(el, value, show, hide);
      } else {
        value ? clickAwayCompatibleShow() : hide();
      }
    });
    let oldValue;
    let firstTime = true;
    effect3(() => evaluate2((value) => {
      if (!firstTime && value === oldValue)
        return;
      if (modifiers.includes("immediate"))
        value ? clickAwayCompatibleShow() : hide();
      toggle(value);
      oldValue = value;
      firstTime = false;
    }));
  });
  directive("for", (el, { expression }, { effect: effect3, cleanup: cleanup2 }) => {
    let iteratorNames = parseForExpression(expression);
    let evaluateItems = evaluateLater(el, iteratorNames.items);
    let evaluateKey = evaluateLater(el, el._x_keyExpression || "index");
    el._x_prevKeys = [];
    el._x_lookup = {};
    effect3(() => loop(el, iteratorNames, evaluateItems, evaluateKey));
    cleanup2(() => {
      Object.values(el._x_lookup).forEach((el2) => el2.remove());
      delete el._x_prevKeys;
      delete el._x_lookup;
    });
  });
  function loop(el, iteratorNames, evaluateItems, evaluateKey) {
    let isObject22 = (i) => typeof i === "object" && !Array.isArray(i);
    let templateEl = el;
    evaluateItems((items) => {
      if (isNumeric3(items) && items >= 0) {
        items = Array.from(Array(items).keys(), (i) => i + 1);
      }
      if (items === void 0)
        items = [];
      let lookup = el._x_lookup;
      let prevKeys = el._x_prevKeys;
      let scopes = [];
      let keys = [];
      if (isObject22(items)) {
        items = Object.entries(items).map(([key, value]) => {
          let scope2 = getIterationScopeVariables(iteratorNames, value, key, items);
          evaluateKey((value2) => keys.push(value2), { scope: __spreadValues({ index: key }, scope2) });
          scopes.push(scope2);
        });
      } else {
        for (let i = 0; i < items.length; i++) {
          let scope2 = getIterationScopeVariables(iteratorNames, items[i], i, items);
          evaluateKey((value) => keys.push(value), { scope: __spreadValues({ index: i }, scope2) });
          scopes.push(scope2);
        }
      }
      let adds = [];
      let moves = [];
      let removes = [];
      let sames = [];
      for (let i = 0; i < prevKeys.length; i++) {
        let key = prevKeys[i];
        if (keys.indexOf(key) === -1)
          removes.push(key);
      }
      prevKeys = prevKeys.filter((key) => !removes.includes(key));
      let lastKey = "template";
      for (let i = 0; i < keys.length; i++) {
        let key = keys[i];
        let prevIndex = prevKeys.indexOf(key);
        if (prevIndex === -1) {
          prevKeys.splice(i, 0, key);
          adds.push([lastKey, i]);
        } else if (prevIndex !== i) {
          let keyInSpot = prevKeys.splice(i, 1)[0];
          let keyForSpot = prevKeys.splice(prevIndex - 1, 1)[0];
          prevKeys.splice(i, 0, keyForSpot);
          prevKeys.splice(prevIndex, 0, keyInSpot);
          moves.push([keyInSpot, keyForSpot]);
        } else {
          sames.push(key);
        }
        lastKey = key;
      }
      for (let i = 0; i < removes.length; i++) {
        let key = removes[i];
        if (!!lookup[key]._x_effects) {
          lookup[key]._x_effects.forEach(dequeueJob);
        }
        lookup[key].remove();
        lookup[key] = null;
        delete lookup[key];
      }
      for (let i = 0; i < moves.length; i++) {
        let [keyInSpot, keyForSpot] = moves[i];
        let elInSpot = lookup[keyInSpot];
        let elForSpot = lookup[keyForSpot];
        let marker = document.createElement("div");
        mutateDom(() => {
          elForSpot.after(marker);
          elInSpot.after(elForSpot);
          elForSpot._x_currentIfEl && elForSpot.after(elForSpot._x_currentIfEl);
          marker.before(elInSpot);
          elInSpot._x_currentIfEl && elInSpot.after(elInSpot._x_currentIfEl);
          marker.remove();
        });
        refreshScope(elForSpot, scopes[keys.indexOf(keyForSpot)]);
      }
      for (let i = 0; i < adds.length; i++) {
        let [lastKey2, index] = adds[i];
        let lastEl = lastKey2 === "template" ? templateEl : lookup[lastKey2];
        if (lastEl._x_currentIfEl)
          lastEl = lastEl._x_currentIfEl;
        let scope2 = scopes[index];
        let key = keys[index];
        let clone22 = document.importNode(templateEl.content, true).firstElementChild;
        addScopeToNode(clone22, reactive(scope2), templateEl);
        mutateDom(() => {
          lastEl.after(clone22);
          initTree(clone22);
        });
        if (typeof key === "object") {
          warn("x-for key cannot be an object, it must be a string or an integer", templateEl);
        }
        lookup[key] = clone22;
      }
      for (let i = 0; i < sames.length; i++) {
        refreshScope(lookup[sames[i]], scopes[keys.indexOf(sames[i])]);
      }
      templateEl._x_prevKeys = keys;
    });
  }
  function parseForExpression(expression) {
    let forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/;
    let stripParensRE = /^\s*\(|\)\s*$/g;
    let forAliasRE = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/;
    let inMatch = expression.match(forAliasRE);
    if (!inMatch)
      return;
    let res = {};
    res.items = inMatch[2].trim();
    let item = inMatch[1].replace(stripParensRE, "").trim();
    let iteratorMatch = item.match(forIteratorRE);
    if (iteratorMatch) {
      res.item = item.replace(forIteratorRE, "").trim();
      res.index = iteratorMatch[1].trim();
      if (iteratorMatch[2]) {
        res.collection = iteratorMatch[2].trim();
      }
    } else {
      res.item = item;
    }
    return res;
  }
  function getIterationScopeVariables(iteratorNames, item, index, items) {
    let scopeVariables = {};
    if (/^\[.*\]$/.test(iteratorNames.item) && Array.isArray(item)) {
      let names = iteratorNames.item.replace("[", "").replace("]", "").split(",").map((i) => i.trim());
      names.forEach((name, i) => {
        scopeVariables[name] = item[i];
      });
    } else if (/^\{.*\}$/.test(iteratorNames.item) && !Array.isArray(item) && typeof item === "object") {
      let names = iteratorNames.item.replace("{", "").replace("}", "").split(",").map((i) => i.trim());
      names.forEach((name) => {
        scopeVariables[name] = item[name];
      });
    } else {
      scopeVariables[iteratorNames.item] = item;
    }
    if (iteratorNames.index)
      scopeVariables[iteratorNames.index] = index;
    if (iteratorNames.collection)
      scopeVariables[iteratorNames.collection] = items;
    return scopeVariables;
  }
  function isNumeric3(subject) {
    return !Array.isArray(subject) && !isNaN(subject);
  }
  function handler2() {
  }
  handler2.inline = (el, { expression }, { cleanup: cleanup2 }) => {
    let root = closestRoot(el);
    if (!root._x_refs)
      root._x_refs = {};
    root._x_refs[expression] = el;
    cleanup2(() => delete root._x_refs[expression]);
  };
  directive("ref", handler2);
  directive("if", (el, { expression }, { effect: effect3, cleanup: cleanup2 }) => {
    let evaluate2 = evaluateLater(el, expression);
    let show = () => {
      if (el._x_currentIfEl)
        return el._x_currentIfEl;
      let clone22 = el.content.cloneNode(true).firstElementChild;
      addScopeToNode(clone22, {}, el);
      mutateDom(() => {
        el.after(clone22);
        initTree(clone22);
      });
      el._x_currentIfEl = clone22;
      el._x_undoIf = () => {
        walk(clone22, (node) => {
          if (!!node._x_effects) {
            node._x_effects.forEach(dequeueJob);
          }
        });
        clone22.remove();
        delete el._x_currentIfEl;
      };
      return clone22;
    };
    let hide = () => {
      if (!el._x_undoIf)
        return;
      el._x_undoIf();
      delete el._x_undoIf;
    };
    effect3(() => evaluate2((value) => {
      value ? show() : hide();
    }));
    cleanup2(() => el._x_undoIf && el._x_undoIf());
  });
  directive("id", (el, { expression }, { evaluate: evaluate2 }) => {
    let names = evaluate2(expression);
    names.forEach((name) => setIdRoot(el, name));
  });
  mapAttributes(startingWith("@", into(prefix("on:"))));
  directive("on", skipDuringClone((el, { value, modifiers, expression }, { cleanup: cleanup2 }) => {
    let evaluate2 = expression ? evaluateLater(el, expression) : () => {
    };
    if (el.tagName.toLowerCase() === "template") {
      if (!el._x_forwardEvents)
        el._x_forwardEvents = [];
      if (!el._x_forwardEvents.includes(value))
        el._x_forwardEvents.push(value);
    }
    let removeListener = on(el, value, modifiers, (e) => {
      evaluate2(() => {
      }, { scope: { $event: e }, params: [e] });
    });
    cleanup2(() => removeListener());
  }));
  warnMissingPluginDirective("Collapse", "collapse", "collapse");
  warnMissingPluginDirective("Intersect", "intersect", "intersect");
  warnMissingPluginDirective("Focus", "trap", "focus");
  warnMissingPluginDirective("Mask", "mask", "mask");
  function warnMissingPluginDirective(name, directiveName2, slug) {
    directive(directiveName2, (el) => warn(`You can't use [x-${directiveName2}] without first installing the "${name}" plugin here: https://alpinejs.dev/plugins/${slug}`, el));
  }
  alpine_default.setEvaluator(normalEvaluator);
  alpine_default.setReactivityEngine({ reactive: reactive2, effect: effect2, release: stop, raw: toRaw });
  var src_default = alpine_default;
  var module_default = src_default;

  // node_modules/@alpinejs/persist/dist/module.esm.js
  function src_default2(Alpine2) {
    let persist = () => {
      let alias;
      let storage = localStorage;
      return Alpine2.interceptor((initialValue, getter, setter, path, key) => {
        let lookup = alias || `_x_${path}`;
        let initial = storageHas(lookup, storage) ? storageGet(lookup, storage) : initialValue;
        setter(initial);
        Alpine2.effect(() => {
          let value = getter();
          storageSet(lookup, value, storage);
          setter(value);
        });
        return initial;
      }, (func) => {
        func.as = (key) => {
          alias = key;
          return func;
        }, func.using = (target) => {
          storage = target;
          return func;
        };
      });
    };
    Object.defineProperty(Alpine2, "$persist", { get: () => persist() });
    Alpine2.magic("persist", persist);
  }
  function storageHas(key, storage) {
    return storage.getItem(key) !== null;
  }
  function storageGet(key, storage) {
    return JSON.parse(storage.getItem(key, storage));
  }
  function storageSet(key, value, storage) {
    storage.setItem(key, JSON.stringify(value));
  }
  var module_default2 = src_default2;

  // node_modules/date-fns/esm/_lib/toInteger/index.js
  function toInteger(dirtyNumber) {
    if (dirtyNumber === null || dirtyNumber === true || dirtyNumber === false) {
      return NaN;
    }
    var number = Number(dirtyNumber);
    if (isNaN(number)) {
      return number;
    }
    return number < 0 ? Math.ceil(number) : Math.floor(number);
  }

  // node_modules/date-fns/esm/_lib/requiredArgs/index.js
  function requiredArgs(required, args) {
    if (args.length < required) {
      throw new TypeError(required + " argument" + (required > 1 ? "s" : "") + " required, but only " + args.length + " present");
    }
  }

  // node_modules/date-fns/esm/toDate/index.js
  function toDate(argument) {
    requiredArgs(1, arguments);
    var argStr = Object.prototype.toString.call(argument);
    if (argument instanceof Date || typeof argument === "object" && argStr === "[object Date]") {
      return new Date(argument.getTime());
    } else if (typeof argument === "number" || argStr === "[object Number]") {
      return new Date(argument);
    } else {
      if ((typeof argument === "string" || argStr === "[object String]") && typeof console !== "undefined") {
        console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as date arguments. Please use `parseISO` to parse strings. See: https://git.io/fjule");
        console.warn(new Error().stack);
      }
      return new Date(NaN);
    }
  }

  // node_modules/date-fns/esm/_lib/getTimezoneOffsetInMilliseconds/index.js
  function getTimezoneOffsetInMilliseconds(date) {
    var utcDate = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()));
    utcDate.setUTCFullYear(date.getFullYear());
    return date.getTime() - utcDate.getTime();
  }

  // node_modules/date-fns/esm/compareAsc/index.js
  function compareAsc(dirtyDateLeft, dirtyDateRight) {
    requiredArgs(2, arguments);
    var dateLeft = toDate(dirtyDateLeft);
    var dateRight = toDate(dirtyDateRight);
    var diff = dateLeft.getTime() - dateRight.getTime();
    if (diff < 0) {
      return -1;
    } else if (diff > 0) {
      return 1;
    } else {
      return diff;
    }
  }

  // node_modules/date-fns/esm/constants/index.js
  var maxTime = Math.pow(10, 8) * 24 * 60 * 60 * 1e3;
  var millisecondsInMinute = 6e4;
  var millisecondsInHour = 36e5;
  var minTime = -maxTime;

  // node_modules/date-fns/esm/differenceInCalendarMonths/index.js
  function differenceInCalendarMonths(dirtyDateLeft, dirtyDateRight) {
    requiredArgs(2, arguments);
    var dateLeft = toDate(dirtyDateLeft);
    var dateRight = toDate(dirtyDateRight);
    var yearDiff = dateLeft.getFullYear() - dateRight.getFullYear();
    var monthDiff = dateLeft.getMonth() - dateRight.getMonth();
    return yearDiff * 12 + monthDiff;
  }

  // node_modules/date-fns/esm/differenceInMilliseconds/index.js
  function differenceInMilliseconds(dateLeft, dateRight) {
    requiredArgs(2, arguments);
    return toDate(dateLeft).getTime() - toDate(dateRight).getTime();
  }

  // node_modules/date-fns/esm/_lib/roundingMethods/index.js
  var roundingMap = {
    ceil: Math.ceil,
    round: Math.round,
    floor: Math.floor,
    trunc: function(value) {
      return value < 0 ? Math.ceil(value) : Math.floor(value);
    }
  };
  var defaultRoundingMethod = "trunc";
  function getRoundingMethod(method) {
    return method ? roundingMap[method] : roundingMap[defaultRoundingMethod];
  }

  // node_modules/date-fns/esm/endOfDay/index.js
  function endOfDay(dirtyDate) {
    requiredArgs(1, arguments);
    var date = toDate(dirtyDate);
    date.setHours(23, 59, 59, 999);
    return date;
  }

  // node_modules/date-fns/esm/endOfMonth/index.js
  function endOfMonth(dirtyDate) {
    requiredArgs(1, arguments);
    var date = toDate(dirtyDate);
    var month = date.getMonth();
    date.setFullYear(date.getFullYear(), month + 1, 0);
    date.setHours(23, 59, 59, 999);
    return date;
  }

  // node_modules/date-fns/esm/isLastDayOfMonth/index.js
  function isLastDayOfMonth(dirtyDate) {
    requiredArgs(1, arguments);
    var date = toDate(dirtyDate);
    return endOfDay(date).getTime() === endOfMonth(date).getTime();
  }

  // node_modules/date-fns/esm/differenceInMonths/index.js
  function differenceInMonths(dirtyDateLeft, dirtyDateRight) {
    requiredArgs(2, arguments);
    var dateLeft = toDate(dirtyDateLeft);
    var dateRight = toDate(dirtyDateRight);
    var sign = compareAsc(dateLeft, dateRight);
    var difference = Math.abs(differenceInCalendarMonths(dateLeft, dateRight));
    var result;
    if (difference < 1) {
      result = 0;
    } else {
      if (dateLeft.getMonth() === 1 && dateLeft.getDate() > 27) {
        dateLeft.setDate(30);
      }
      dateLeft.setMonth(dateLeft.getMonth() - sign * difference);
      var isLastMonthNotFull = compareAsc(dateLeft, dateRight) === -sign;
      if (isLastDayOfMonth(toDate(dirtyDateLeft)) && difference === 1 && compareAsc(dirtyDateLeft, dateRight) === 1) {
        isLastMonthNotFull = false;
      }
      result = sign * (difference - Number(isLastMonthNotFull));
    }
    return result === 0 ? 0 : result;
  }

  // node_modules/date-fns/esm/differenceInSeconds/index.js
  function differenceInSeconds(dateLeft, dateRight, options) {
    requiredArgs(2, arguments);
    var diff = differenceInMilliseconds(dateLeft, dateRight) / 1e3;
    return getRoundingMethod(options === null || options === void 0 ? void 0 : options.roundingMethod)(diff);
  }

  // node_modules/date-fns/esm/locale/en-US/_lib/formatDistance/index.js
  var formatDistanceLocale = {
    lessThanXSeconds: {
      one: "less than a second",
      other: "less than {{count}} seconds"
    },
    xSeconds: {
      one: "1 second",
      other: "{{count}} seconds"
    },
    halfAMinute: "half a minute",
    lessThanXMinutes: {
      one: "less than a minute",
      other: "less than {{count}} minutes"
    },
    xMinutes: {
      one: "1 minute",
      other: "{{count}} minutes"
    },
    aboutXHours: {
      one: "about 1 hour",
      other: "about {{count}} hours"
    },
    xHours: {
      one: "1 hour",
      other: "{{count}} hours"
    },
    xDays: {
      one: "1 day",
      other: "{{count}} days"
    },
    aboutXWeeks: {
      one: "about 1 week",
      other: "about {{count}} weeks"
    },
    xWeeks: {
      one: "1 week",
      other: "{{count}} weeks"
    },
    aboutXMonths: {
      one: "about 1 month",
      other: "about {{count}} months"
    },
    xMonths: {
      one: "1 month",
      other: "{{count}} months"
    },
    aboutXYears: {
      one: "about 1 year",
      other: "about {{count}} years"
    },
    xYears: {
      one: "1 year",
      other: "{{count}} years"
    },
    overXYears: {
      one: "over 1 year",
      other: "over {{count}} years"
    },
    almostXYears: {
      one: "almost 1 year",
      other: "almost {{count}} years"
    }
  };
  var formatDistance = function(token, count, options) {
    var result;
    var tokenValue = formatDistanceLocale[token];
    if (typeof tokenValue === "string") {
      result = tokenValue;
    } else if (count === 1) {
      result = tokenValue.one;
    } else {
      result = tokenValue.other.replace("{{count}}", count.toString());
    }
    if (options !== null && options !== void 0 && options.addSuffix) {
      if (options.comparison && options.comparison > 0) {
        return "in " + result;
      } else {
        return result + " ago";
      }
    }
    return result;
  };
  var formatDistance_default = formatDistance;

  // node_modules/date-fns/esm/locale/_lib/buildFormatLongFn/index.js
  function buildFormatLongFn(args) {
    return function() {
      var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var width = options.width ? String(options.width) : args.defaultWidth;
      var format = args.formats[width] || args.formats[args.defaultWidth];
      return format;
    };
  }

  // node_modules/date-fns/esm/locale/en-US/_lib/formatLong/index.js
  var dateFormats = {
    full: "EEEE, MMMM do, y",
    long: "MMMM do, y",
    medium: "MMM d, y",
    short: "MM/dd/yyyy"
  };
  var timeFormats = {
    full: "h:mm:ss a zzzz",
    long: "h:mm:ss a z",
    medium: "h:mm:ss a",
    short: "h:mm a"
  };
  var dateTimeFormats = {
    full: "{{date}} 'at' {{time}}",
    long: "{{date}} 'at' {{time}}",
    medium: "{{date}}, {{time}}",
    short: "{{date}}, {{time}}"
  };
  var formatLong = {
    date: buildFormatLongFn({
      formats: dateFormats,
      defaultWidth: "full"
    }),
    time: buildFormatLongFn({
      formats: timeFormats,
      defaultWidth: "full"
    }),
    dateTime: buildFormatLongFn({
      formats: dateTimeFormats,
      defaultWidth: "full"
    })
  };
  var formatLong_default = formatLong;

  // node_modules/date-fns/esm/locale/en-US/_lib/formatRelative/index.js
  var formatRelativeLocale = {
    lastWeek: "'last' eeee 'at' p",
    yesterday: "'yesterday at' p",
    today: "'today at' p",
    tomorrow: "'tomorrow at' p",
    nextWeek: "eeee 'at' p",
    other: "P"
  };
  var formatRelative = function(token, _date, _baseDate, _options) {
    return formatRelativeLocale[token];
  };
  var formatRelative_default = formatRelative;

  // node_modules/date-fns/esm/locale/_lib/buildLocalizeFn/index.js
  function buildLocalizeFn(args) {
    return function(dirtyIndex, dirtyOptions) {
      var options = dirtyOptions || {};
      var context = options.context ? String(options.context) : "standalone";
      var valuesArray;
      if (context === "formatting" && args.formattingValues) {
        var defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
        var width = options.width ? String(options.width) : defaultWidth;
        valuesArray = args.formattingValues[width] || args.formattingValues[defaultWidth];
      } else {
        var _defaultWidth = args.defaultWidth;
        var _width = options.width ? String(options.width) : args.defaultWidth;
        valuesArray = args.values[_width] || args.values[_defaultWidth];
      }
      var index = args.argumentCallback ? args.argumentCallback(dirtyIndex) : dirtyIndex;
      return valuesArray[index];
    };
  }

  // node_modules/date-fns/esm/locale/en-US/_lib/localize/index.js
  var eraValues = {
    narrow: ["B", "A"],
    abbreviated: ["BC", "AD"],
    wide: ["Before Christ", "Anno Domini"]
  };
  var quarterValues = {
    narrow: ["1", "2", "3", "4"],
    abbreviated: ["Q1", "Q2", "Q3", "Q4"],
    wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
  };
  var monthValues = {
    narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
    abbreviated: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
    wide: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
  };
  var dayValues = {
    narrow: ["S", "M", "T", "W", "T", "F", "S"],
    short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
    abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    wide: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
  };
  var dayPeriodValues = {
    narrow: {
      am: "a",
      pm: "p",
      midnight: "mi",
      noon: "n",
      morning: "morning",
      afternoon: "afternoon",
      evening: "evening",
      night: "night"
    },
    abbreviated: {
      am: "AM",
      pm: "PM",
      midnight: "midnight",
      noon: "noon",
      morning: "morning",
      afternoon: "afternoon",
      evening: "evening",
      night: "night"
    },
    wide: {
      am: "a.m.",
      pm: "p.m.",
      midnight: "midnight",
      noon: "noon",
      morning: "morning",
      afternoon: "afternoon",
      evening: "evening",
      night: "night"
    }
  };
  var formattingDayPeriodValues = {
    narrow: {
      am: "a",
      pm: "p",
      midnight: "mi",
      noon: "n",
      morning: "in the morning",
      afternoon: "in the afternoon",
      evening: "in the evening",
      night: "at night"
    },
    abbreviated: {
      am: "AM",
      pm: "PM",
      midnight: "midnight",
      noon: "noon",
      morning: "in the morning",
      afternoon: "in the afternoon",
      evening: "in the evening",
      night: "at night"
    },
    wide: {
      am: "a.m.",
      pm: "p.m.",
      midnight: "midnight",
      noon: "noon",
      morning: "in the morning",
      afternoon: "in the afternoon",
      evening: "in the evening",
      night: "at night"
    }
  };
  var ordinalNumber = function(dirtyNumber, _options) {
    var number = Number(dirtyNumber);
    var rem100 = number % 100;
    if (rem100 > 20 || rem100 < 10) {
      switch (rem100 % 10) {
        case 1:
          return number + "st";
        case 2:
          return number + "nd";
        case 3:
          return number + "rd";
      }
    }
    return number + "th";
  };
  var localize = {
    ordinalNumber,
    era: buildLocalizeFn({
      values: eraValues,
      defaultWidth: "wide"
    }),
    quarter: buildLocalizeFn({
      values: quarterValues,
      defaultWidth: "wide",
      argumentCallback: function(quarter) {
        return quarter - 1;
      }
    }),
    month: buildLocalizeFn({
      values: monthValues,
      defaultWidth: "wide"
    }),
    day: buildLocalizeFn({
      values: dayValues,
      defaultWidth: "wide"
    }),
    dayPeriod: buildLocalizeFn({
      values: dayPeriodValues,
      defaultWidth: "wide",
      formattingValues: formattingDayPeriodValues,
      defaultFormattingWidth: "wide"
    })
  };
  var localize_default = localize;

  // node_modules/date-fns/esm/locale/_lib/buildMatchFn/index.js
  function buildMatchFn(args) {
    return function(string) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var width = options.width;
      var matchPattern = width && args.matchPatterns[width] || args.matchPatterns[args.defaultMatchWidth];
      var matchResult = string.match(matchPattern);
      if (!matchResult) {
        return null;
      }
      var matchedString = matchResult[0];
      var parsePatterns = width && args.parsePatterns[width] || args.parsePatterns[args.defaultParseWidth];
      var key = Array.isArray(parsePatterns) ? findIndex(parsePatterns, function(pattern) {
        return pattern.test(matchedString);
      }) : findKey(parsePatterns, function(pattern) {
        return pattern.test(matchedString);
      });
      var value;
      value = args.valueCallback ? args.valueCallback(key) : key;
      value = options.valueCallback ? options.valueCallback(value) : value;
      var rest = string.slice(matchedString.length);
      return {
        value,
        rest
      };
    };
  }
  function findKey(object, predicate) {
    for (var key in object) {
      if (object.hasOwnProperty(key) && predicate(object[key])) {
        return key;
      }
    }
    return void 0;
  }
  function findIndex(array, predicate) {
    for (var key = 0; key < array.length; key++) {
      if (predicate(array[key])) {
        return key;
      }
    }
    return void 0;
  }

  // node_modules/date-fns/esm/locale/_lib/buildMatchPatternFn/index.js
  function buildMatchPatternFn(args) {
    return function(string) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var matchResult = string.match(args.matchPattern);
      if (!matchResult)
        return null;
      var matchedString = matchResult[0];
      var parseResult = string.match(args.parsePattern);
      if (!parseResult)
        return null;
      var value = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
      value = options.valueCallback ? options.valueCallback(value) : value;
      var rest = string.slice(matchedString.length);
      return {
        value,
        rest
      };
    };
  }

  // node_modules/date-fns/esm/locale/en-US/_lib/match/index.js
  var matchOrdinalNumberPattern = /^(\d+)(th|st|nd|rd)?/i;
  var parseOrdinalNumberPattern = /\d+/i;
  var matchEraPatterns = {
    narrow: /^(b|a)/i,
    abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
    wide: /^(before christ|before common era|anno domini|common era)/i
  };
  var parseEraPatterns = {
    any: [/^b/i, /^(a|c)/i]
  };
  var matchQuarterPatterns = {
    narrow: /^[1234]/i,
    abbreviated: /^q[1234]/i,
    wide: /^[1234](th|st|nd|rd)? quarter/i
  };
  var parseQuarterPatterns = {
    any: [/1/i, /2/i, /3/i, /4/i]
  };
  var matchMonthPatterns = {
    narrow: /^[jfmasond]/i,
    abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
    wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
  };
  var parseMonthPatterns = {
    narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
    any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i]
  };
  var matchDayPatterns = {
    narrow: /^[smtwf]/i,
    short: /^(su|mo|tu|we|th|fr|sa)/i,
    abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
    wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
  };
  var parseDayPatterns = {
    narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
    any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
  };
  var matchDayPeriodPatterns = {
    narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
    any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
  };
  var parseDayPeriodPatterns = {
    any: {
      am: /^a/i,
      pm: /^p/i,
      midnight: /^mi/i,
      noon: /^no/i,
      morning: /morning/i,
      afternoon: /afternoon/i,
      evening: /evening/i,
      night: /night/i
    }
  };
  var match = {
    ordinalNumber: buildMatchPatternFn({
      matchPattern: matchOrdinalNumberPattern,
      parsePattern: parseOrdinalNumberPattern,
      valueCallback: function(value) {
        return parseInt(value, 10);
      }
    }),
    era: buildMatchFn({
      matchPatterns: matchEraPatterns,
      defaultMatchWidth: "wide",
      parsePatterns: parseEraPatterns,
      defaultParseWidth: "any"
    }),
    quarter: buildMatchFn({
      matchPatterns: matchQuarterPatterns,
      defaultMatchWidth: "wide",
      parsePatterns: parseQuarterPatterns,
      defaultParseWidth: "any",
      valueCallback: function(index) {
        return index + 1;
      }
    }),
    month: buildMatchFn({
      matchPatterns: matchMonthPatterns,
      defaultMatchWidth: "wide",
      parsePatterns: parseMonthPatterns,
      defaultParseWidth: "any"
    }),
    day: buildMatchFn({
      matchPatterns: matchDayPatterns,
      defaultMatchWidth: "wide",
      parsePatterns: parseDayPatterns,
      defaultParseWidth: "any"
    }),
    dayPeriod: buildMatchFn({
      matchPatterns: matchDayPeriodPatterns,
      defaultMatchWidth: "any",
      parsePatterns: parseDayPeriodPatterns,
      defaultParseWidth: "any"
    })
  };
  var match_default = match;

  // node_modules/date-fns/esm/locale/en-US/index.js
  var locale = {
    code: "en-US",
    formatDistance: formatDistance_default,
    formatLong: formatLong_default,
    formatRelative: formatRelative_default,
    localize: localize_default,
    match: match_default,
    options: {
      weekStartsOn: 0,
      firstWeekContainsDate: 1
    }
  };
  var en_US_default = locale;

  // node_modules/date-fns/esm/_lib/assign/index.js
  function assign(target, dirtyObject) {
    if (target == null) {
      throw new TypeError("assign requires that input parameter not be null or undefined");
    }
    dirtyObject = dirtyObject || {};
    for (var property in dirtyObject) {
      if (Object.prototype.hasOwnProperty.call(dirtyObject, property)) {
        target[property] = dirtyObject[property];
      }
    }
    return target;
  }

  // node_modules/date-fns/esm/_lib/cloneObject/index.js
  function cloneObject(dirtyObject) {
    return assign({}, dirtyObject);
  }

  // node_modules/date-fns/esm/formatDistance/index.js
  var MINUTES_IN_DAY = 1440;
  var MINUTES_IN_ALMOST_TWO_DAYS = 2520;
  var MINUTES_IN_MONTH = 43200;
  var MINUTES_IN_TWO_MONTHS = 86400;
  function formatDistance2(dirtyDate, dirtyBaseDate) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    requiredArgs(2, arguments);
    var locale4 = options.locale || en_US_default;
    if (!locale4.formatDistance) {
      throw new RangeError("locale must contain formatDistance property");
    }
    var comparison = compareAsc(dirtyDate, dirtyBaseDate);
    if (isNaN(comparison)) {
      throw new RangeError("Invalid time value");
    }
    var localizeOptions = cloneObject(options);
    localizeOptions.addSuffix = Boolean(options.addSuffix);
    localizeOptions.comparison = comparison;
    var dateLeft;
    var dateRight;
    if (comparison > 0) {
      dateLeft = toDate(dirtyBaseDate);
      dateRight = toDate(dirtyDate);
    } else {
      dateLeft = toDate(dirtyDate);
      dateRight = toDate(dirtyBaseDate);
    }
    var seconds = differenceInSeconds(dateRight, dateLeft);
    var offsetInSeconds = (getTimezoneOffsetInMilliseconds(dateRight) - getTimezoneOffsetInMilliseconds(dateLeft)) / 1e3;
    var minutes = Math.round((seconds - offsetInSeconds) / 60);
    var months;
    if (minutes < 2) {
      if (options.includeSeconds) {
        if (seconds < 5) {
          return locale4.formatDistance("lessThanXSeconds", 5, localizeOptions);
        } else if (seconds < 10) {
          return locale4.formatDistance("lessThanXSeconds", 10, localizeOptions);
        } else if (seconds < 20) {
          return locale4.formatDistance("lessThanXSeconds", 20, localizeOptions);
        } else if (seconds < 40) {
          return locale4.formatDistance("halfAMinute", null, localizeOptions);
        } else if (seconds < 60) {
          return locale4.formatDistance("lessThanXMinutes", 1, localizeOptions);
        } else {
          return locale4.formatDistance("xMinutes", 1, localizeOptions);
        }
      } else {
        if (minutes === 0) {
          return locale4.formatDistance("lessThanXMinutes", 1, localizeOptions);
        } else {
          return locale4.formatDistance("xMinutes", minutes, localizeOptions);
        }
      }
    } else if (minutes < 45) {
      return locale4.formatDistance("xMinutes", minutes, localizeOptions);
    } else if (minutes < 90) {
      return locale4.formatDistance("aboutXHours", 1, localizeOptions);
    } else if (minutes < MINUTES_IN_DAY) {
      var hours = Math.round(minutes / 60);
      return locale4.formatDistance("aboutXHours", hours, localizeOptions);
    } else if (minutes < MINUTES_IN_ALMOST_TWO_DAYS) {
      return locale4.formatDistance("xDays", 1, localizeOptions);
    } else if (minutes < MINUTES_IN_MONTH) {
      var days = Math.round(minutes / MINUTES_IN_DAY);
      return locale4.formatDistance("xDays", days, localizeOptions);
    } else if (minutes < MINUTES_IN_TWO_MONTHS) {
      months = Math.round(minutes / MINUTES_IN_MONTH);
      return locale4.formatDistance("aboutXMonths", months, localizeOptions);
    }
    months = differenceInMonths(dateRight, dateLeft);
    if (months < 12) {
      var nearestMonth = Math.round(minutes / MINUTES_IN_MONTH);
      return locale4.formatDistance("xMonths", nearestMonth, localizeOptions);
    } else {
      var monthsSinceStartOfYear = months % 12;
      var years = Math.floor(months / 12);
      if (monthsSinceStartOfYear < 3) {
        return locale4.formatDistance("aboutXYears", years, localizeOptions);
      } else if (monthsSinceStartOfYear < 9) {
        return locale4.formatDistance("overXYears", years, localizeOptions);
      } else {
        return locale4.formatDistance("almostXYears", years + 1, localizeOptions);
      }
    }
  }

  // node_modules/date-fns/esm/formatDistanceToNow/index.js
  function formatDistanceToNow(dirtyDate, dirtyOptions) {
    requiredArgs(1, arguments);
    return formatDistance2(dirtyDate, Date.now(), dirtyOptions);
  }

  // node_modules/date-fns/esm/parseISO/index.js
  function parseISO(argument, dirtyOptions) {
    requiredArgs(1, arguments);
    var options = dirtyOptions || {};
    var additionalDigits = options.additionalDigits == null ? 2 : toInteger(options.additionalDigits);
    if (additionalDigits !== 2 && additionalDigits !== 1 && additionalDigits !== 0) {
      throw new RangeError("additionalDigits must be 0, 1 or 2");
    }
    if (!(typeof argument === "string" || Object.prototype.toString.call(argument) === "[object String]")) {
      return new Date(NaN);
    }
    var dateStrings = splitDateString(argument);
    var date;
    if (dateStrings.date) {
      var parseYearResult = parseYear(dateStrings.date, additionalDigits);
      date = parseDate(parseYearResult.restDateString, parseYearResult.year);
    }
    if (!date || isNaN(date.getTime())) {
      return new Date(NaN);
    }
    var timestamp = date.getTime();
    var time = 0;
    var offset;
    if (dateStrings.time) {
      time = parseTime(dateStrings.time);
      if (isNaN(time)) {
        return new Date(NaN);
      }
    }
    if (dateStrings.timezone) {
      offset = parseTimezone(dateStrings.timezone);
      if (isNaN(offset)) {
        return new Date(NaN);
      }
    } else {
      var dirtyDate = new Date(timestamp + time);
      var result = new Date(0);
      result.setFullYear(dirtyDate.getUTCFullYear(), dirtyDate.getUTCMonth(), dirtyDate.getUTCDate());
      result.setHours(dirtyDate.getUTCHours(), dirtyDate.getUTCMinutes(), dirtyDate.getUTCSeconds(), dirtyDate.getUTCMilliseconds());
      return result;
    }
    return new Date(timestamp + time + offset);
  }
  var patterns = {
    dateTimeDelimiter: /[T ]/,
    timeZoneDelimiter: /[Z ]/i,
    timezone: /([Z+-].*)$/
  };
  var dateRegex = /^-?(?:(\d{3})|(\d{2})(?:-?(\d{2}))?|W(\d{2})(?:-?(\d{1}))?|)$/;
  var timeRegex = /^(\d{2}(?:[.,]\d*)?)(?::?(\d{2}(?:[.,]\d*)?))?(?::?(\d{2}(?:[.,]\d*)?))?$/;
  var timezoneRegex = /^([+-])(\d{2})(?::?(\d{2}))?$/;
  function splitDateString(dateString) {
    var dateStrings = {};
    var array = dateString.split(patterns.dateTimeDelimiter);
    var timeString;
    if (array.length > 2) {
      return dateStrings;
    }
    if (/:/.test(array[0])) {
      timeString = array[0];
    } else {
      dateStrings.date = array[0];
      timeString = array[1];
      if (patterns.timeZoneDelimiter.test(dateStrings.date)) {
        dateStrings.date = dateString.split(patterns.timeZoneDelimiter)[0];
        timeString = dateString.substr(dateStrings.date.length, dateString.length);
      }
    }
    if (timeString) {
      var token = patterns.timezone.exec(timeString);
      if (token) {
        dateStrings.time = timeString.replace(token[1], "");
        dateStrings.timezone = token[1];
      } else {
        dateStrings.time = timeString;
      }
    }
    return dateStrings;
  }
  function parseYear(dateString, additionalDigits) {
    var regex = new RegExp("^(?:(\\d{4}|[+-]\\d{" + (4 + additionalDigits) + "})|(\\d{2}|[+-]\\d{" + (2 + additionalDigits) + "})$)");
    var captures = dateString.match(regex);
    if (!captures)
      return {
        year: NaN,
        restDateString: ""
      };
    var year = captures[1] ? parseInt(captures[1]) : null;
    var century = captures[2] ? parseInt(captures[2]) : null;
    return {
      year: century === null ? year : century * 100,
      restDateString: dateString.slice((captures[1] || captures[2]).length)
    };
  }
  function parseDate(dateString, year) {
    if (year === null)
      return new Date(NaN);
    var captures = dateString.match(dateRegex);
    if (!captures)
      return new Date(NaN);
    var isWeekDate = !!captures[4];
    var dayOfYear = parseDateUnit(captures[1]);
    var month = parseDateUnit(captures[2]) - 1;
    var day = parseDateUnit(captures[3]);
    var week = parseDateUnit(captures[4]);
    var dayOfWeek = parseDateUnit(captures[5]) - 1;
    if (isWeekDate) {
      if (!validateWeekDate(year, week, dayOfWeek)) {
        return new Date(NaN);
      }
      return dayOfISOWeekYear(year, week, dayOfWeek);
    } else {
      var date = new Date(0);
      if (!validateDate(year, month, day) || !validateDayOfYearDate(year, dayOfYear)) {
        return new Date(NaN);
      }
      date.setUTCFullYear(year, month, Math.max(dayOfYear, day));
      return date;
    }
  }
  function parseDateUnit(value) {
    return value ? parseInt(value) : 1;
  }
  function parseTime(timeString) {
    var captures = timeString.match(timeRegex);
    if (!captures)
      return NaN;
    var hours = parseTimeUnit(captures[1]);
    var minutes = parseTimeUnit(captures[2]);
    var seconds = parseTimeUnit(captures[3]);
    if (!validateTime(hours, minutes, seconds)) {
      return NaN;
    }
    return hours * millisecondsInHour + minutes * millisecondsInMinute + seconds * 1e3;
  }
  function parseTimeUnit(value) {
    return value && parseFloat(value.replace(",", ".")) || 0;
  }
  function parseTimezone(timezoneString) {
    if (timezoneString === "Z")
      return 0;
    var captures = timezoneString.match(timezoneRegex);
    if (!captures)
      return 0;
    var sign = captures[1] === "+" ? -1 : 1;
    var hours = parseInt(captures[2]);
    var minutes = captures[3] && parseInt(captures[3]) || 0;
    if (!validateTimezone(hours, minutes)) {
      return NaN;
    }
    return sign * (hours * millisecondsInHour + minutes * millisecondsInMinute);
  }
  function dayOfISOWeekYear(isoWeekYear, week, day) {
    var date = new Date(0);
    date.setUTCFullYear(isoWeekYear, 0, 4);
    var fourthOfJanuaryDay = date.getUTCDay() || 7;
    var diff = (week - 1) * 7 + day + 1 - fourthOfJanuaryDay;
    date.setUTCDate(date.getUTCDate() + diff);
    return date;
  }
  var daysInMonths = [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  function isLeapYearIndex(year) {
    return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
  }
  function validateDate(year, month, date) {
    return month >= 0 && month <= 11 && date >= 1 && date <= (daysInMonths[month] || (isLeapYearIndex(year) ? 29 : 28));
  }
  function validateDayOfYearDate(year, dayOfYear) {
    return dayOfYear >= 1 && dayOfYear <= (isLeapYearIndex(year) ? 366 : 365);
  }
  function validateWeekDate(_year, week, day) {
    return week >= 1 && week <= 53 && day >= 0 && day <= 6;
  }
  function validateTime(hours, minutes, seconds) {
    if (hours === 24) {
      return minutes === 0 && seconds === 0;
    }
    return seconds >= 0 && seconds < 60 && minutes >= 0 && minutes < 60 && hours >= 0 && hours < 25;
  }
  function validateTimezone(_hours, minutes) {
    return minutes >= 0 && minutes <= 59;
  }

  // js/timeago.js
  var locale2 = null;
  function TimeAgo(Alpine2) {
    Alpine2.directive("timeago", (el, { expression, modifiers }, { evaluateLater: evaluateLater2, effect: effect3, cleanup: cleanup2 }) => {
      let evaluateDate = evaluateLater2(expression);
      const render = (date) => {
        try {
          if (typeof date === "string") {
            date = parseISO(date);
          }
          el.textContent = formatDistanceToNow(date, {
            addSuffix: !modifiers.includes("pure"),
            locale: locale2
          });
        } catch (e) {
          console.error(e);
        }
      };
      let interval;
      effect3(() => {
        evaluateDate((date) => {
          if (interval) {
            clearInterval(interval);
          }
          render(date);
          interval = setInterval(() => {
            render(date);
          }, 3e4);
        });
      });
      cleanup2(() => clearInterval(interval));
    });
  }
  TimeAgo.configure = (config) => {
    if (config.hasOwnProperty("locale") && typeof config.locale === "object") {
      if (config.locale.hasOwnProperty("formatDistance")) {
        locale2 = config.locale;
      }
    }
    return TimeAgo;
  };
  var timeago_default = TimeAgo;

  // node_modules/date-fns/esm/locale/es/_lib/formatDistance/index.js
  var formatDistanceLocale2 = {
    lessThanXSeconds: {
      one: "menos de un segundo",
      other: "menos de {{count}} segundos"
    },
    xSeconds: {
      one: "1 segundo",
      other: "{{count}} segundos"
    },
    halfAMinute: "medio minuto",
    lessThanXMinutes: {
      one: "menos de un minuto",
      other: "menos de {{count}} minutos"
    },
    xMinutes: {
      one: "1 minuto",
      other: "{{count}} minutos"
    },
    aboutXHours: {
      one: "alrededor de 1 hora",
      other: "alrededor de {{count}} horas"
    },
    xHours: {
      one: "1 hora",
      other: "{{count}} horas"
    },
    xDays: {
      one: "1 d\xEDa",
      other: "{{count}} d\xEDas"
    },
    aboutXWeeks: {
      one: "alrededor de 1 semana",
      other: "alrededor de {{count}} semanas"
    },
    xWeeks: {
      one: "1 semana",
      other: "{{count}} semanas"
    },
    aboutXMonths: {
      one: "alrededor de 1 mes",
      other: "alrededor de {{count}} meses"
    },
    xMonths: {
      one: "1 mes",
      other: "{{count}} meses"
    },
    aboutXYears: {
      one: "alrededor de 1 a\xF1o",
      other: "alrededor de {{count}} a\xF1os"
    },
    xYears: {
      one: "1 a\xF1o",
      other: "{{count}} a\xF1os"
    },
    overXYears: {
      one: "m\xE1s de 1 a\xF1o",
      other: "m\xE1s de {{count}} a\xF1os"
    },
    almostXYears: {
      one: "casi 1 a\xF1o",
      other: "casi {{count}} a\xF1os"
    }
  };
  var formatDistance3 = function(token, count, options) {
    var result;
    var tokenValue = formatDistanceLocale2[token];
    if (typeof tokenValue === "string") {
      result = tokenValue;
    } else if (count === 1) {
      result = tokenValue.one;
    } else {
      result = tokenValue.other.replace("{{count}}", count.toString());
    }
    if (options !== null && options !== void 0 && options.addSuffix) {
      if (options.comparison && options.comparison > 0) {
        return "en " + result;
      } else {
        return "hace " + result;
      }
    }
    return result;
  };
  var formatDistance_default2 = formatDistance3;

  // node_modules/date-fns/esm/locale/es/_lib/formatLong/index.js
  var dateFormats2 = {
    full: "EEEE, d 'de' MMMM 'de' y",
    long: "d 'de' MMMM 'de' y",
    medium: "d MMM y",
    short: "dd/MM/y"
  };
  var timeFormats2 = {
    full: "HH:mm:ss zzzz",
    long: "HH:mm:ss z",
    medium: "HH:mm:ss",
    short: "HH:mm"
  };
  var dateTimeFormats2 = {
    full: "{{date}} 'a las' {{time}}",
    long: "{{date}} 'a las' {{time}}",
    medium: "{{date}}, {{time}}",
    short: "{{date}}, {{time}}"
  };
  var formatLong2 = {
    date: buildFormatLongFn({
      formats: dateFormats2,
      defaultWidth: "full"
    }),
    time: buildFormatLongFn({
      formats: timeFormats2,
      defaultWidth: "full"
    }),
    dateTime: buildFormatLongFn({
      formats: dateTimeFormats2,
      defaultWidth: "full"
    })
  };
  var formatLong_default2 = formatLong2;

  // node_modules/date-fns/esm/locale/es/_lib/formatRelative/index.js
  var formatRelativeLocale2 = {
    lastWeek: "'el' eeee 'pasado a la' p",
    yesterday: "'ayer a la' p",
    today: "'hoy a la' p",
    tomorrow: "'ma\xF1ana a la' p",
    nextWeek: "eeee 'a la' p",
    other: "P"
  };
  var formatRelativeLocalePlural = {
    lastWeek: "'el' eeee 'pasado a las' p",
    yesterday: "'ayer a las' p",
    today: "'hoy a las' p",
    tomorrow: "'ma\xF1ana a las' p",
    nextWeek: "eeee 'a las' p",
    other: "P"
  };
  var formatRelative2 = function(token, date, _baseDate, _options) {
    if (date.getUTCHours() !== 1) {
      return formatRelativeLocalePlural[token];
    } else {
      return formatRelativeLocale2[token];
    }
  };
  var formatRelative_default2 = formatRelative2;

  // node_modules/date-fns/esm/locale/es/_lib/localize/index.js
  var eraValues2 = {
    narrow: ["AC", "DC"],
    abbreviated: ["AC", "DC"],
    wide: ["antes de cristo", "despu\xE9s de cristo"]
  };
  var quarterValues2 = {
    narrow: ["1", "2", "3", "4"],
    abbreviated: ["T1", "T2", "T3", "T4"],
    wide: ["1\xBA trimestre", "2\xBA trimestre", "3\xBA trimestre", "4\xBA trimestre"]
  };
  var monthValues2 = {
    narrow: ["e", "f", "m", "a", "m", "j", "j", "a", "s", "o", "n", "d"],
    abbreviated: ["ene", "feb", "mar", "abr", "may", "jun", "jul", "ago", "sep", "oct", "nov", "dic"],
    wide: ["enero", "febrero", "marzo", "abril", "mayo", "junio", "julio", "agosto", "septiembre", "octubre", "noviembre", "diciembre"]
  };
  var dayValues2 = {
    narrow: ["d", "l", "m", "m", "j", "v", "s"],
    short: ["do", "lu", "ma", "mi", "ju", "vi", "s\xE1"],
    abbreviated: ["dom", "lun", "mar", "mi\xE9", "jue", "vie", "s\xE1b"],
    wide: ["domingo", "lunes", "martes", "mi\xE9rcoles", "jueves", "viernes", "s\xE1bado"]
  };
  var dayPeriodValues2 = {
    narrow: {
      am: "a",
      pm: "p",
      midnight: "mn",
      noon: "md",
      morning: "ma\xF1ana",
      afternoon: "tarde",
      evening: "tarde",
      night: "noche"
    },
    abbreviated: {
      am: "AM",
      pm: "PM",
      midnight: "medianoche",
      noon: "mediodia",
      morning: "ma\xF1ana",
      afternoon: "tarde",
      evening: "tarde",
      night: "noche"
    },
    wide: {
      am: "a.m.",
      pm: "p.m.",
      midnight: "medianoche",
      noon: "mediodia",
      morning: "ma\xF1ana",
      afternoon: "tarde",
      evening: "tarde",
      night: "noche"
    }
  };
  var formattingDayPeriodValues2 = {
    narrow: {
      am: "a",
      pm: "p",
      midnight: "mn",
      noon: "md",
      morning: "de la ma\xF1ana",
      afternoon: "de la tarde",
      evening: "de la tarde",
      night: "de la noche"
    },
    abbreviated: {
      am: "AM",
      pm: "PM",
      midnight: "medianoche",
      noon: "mediodia",
      morning: "de la ma\xF1ana",
      afternoon: "de la tarde",
      evening: "de la tarde",
      night: "de la noche"
    },
    wide: {
      am: "a.m.",
      pm: "p.m.",
      midnight: "medianoche",
      noon: "mediodia",
      morning: "de la ma\xF1ana",
      afternoon: "de la tarde",
      evening: "de la tarde",
      night: "de la noche"
    }
  };
  var ordinalNumber2 = function(dirtyNumber, _options) {
    var number = Number(dirtyNumber);
    return number + "\xBA";
  };
  var localize2 = {
    ordinalNumber: ordinalNumber2,
    era: buildLocalizeFn({
      values: eraValues2,
      defaultWidth: "wide"
    }),
    quarter: buildLocalizeFn({
      values: quarterValues2,
      defaultWidth: "wide",
      argumentCallback: function(quarter) {
        return Number(quarter) - 1;
      }
    }),
    month: buildLocalizeFn({
      values: monthValues2,
      defaultWidth: "wide"
    }),
    day: buildLocalizeFn({
      values: dayValues2,
      defaultWidth: "wide"
    }),
    dayPeriod: buildLocalizeFn({
      values: dayPeriodValues2,
      defaultWidth: "wide",
      formattingValues: formattingDayPeriodValues2,
      defaultFormattingWidth: "wide"
    })
  };
  var localize_default2 = localize2;

  // node_modules/date-fns/esm/locale/es/_lib/match/index.js
  var matchOrdinalNumberPattern2 = /^(\d+)()?/i;
  var parseOrdinalNumberPattern2 = /\d+/i;
  var matchEraPatterns2 = {
    narrow: /^(ac|dc|a|d)/i,
    abbreviated: /^(a\.?\s?c\.?|a\.?\s?e\.?\s?c\.?|d\.?\s?c\.?|e\.?\s?c\.?)/i,
    wide: /^(antes de cristo|antes de la era com[u]n|despu[e]s de cristo|era com[u]n)/i
  };
  var parseEraPatterns2 = {
    any: [/^ac/i, /^dc/i],
    wide: [/^(antes de cristo|antes de la era com[u]n)/i, /^(despu[e]s de cristo|era com[u]n)/i]
  };
  var matchQuarterPatterns2 = {
    narrow: /^[1234]/i,
    abbreviated: /^T[1234]/i,
    wide: /^[1234]()? trimestre/i
  };
  var parseQuarterPatterns2 = {
    any: [/1/i, /2/i, /3/i, /4/i]
  };
  var matchMonthPatterns2 = {
    narrow: /^[efmajsond]/i,
    abbreviated: /^(ene|feb|mar|abr|may|jun|jul|ago|sep|oct|nov|dic)/i,
    wide: /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i
  };
  var parseMonthPatterns2 = {
    narrow: [/^e/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
    any: [/^en/i, /^feb/i, /^mar/i, /^abr/i, /^may/i, /^jun/i, /^jul/i, /^ago/i, /^sep/i, /^oct/i, /^nov/i, /^dic/i]
  };
  var matchDayPatterns2 = {
    narrow: /^[dlmjvs]/i,
    short: /^(do|lu|ma|mi|ju|vi|s[a])/i,
    abbreviated: /^(dom|lun|mar|mi[e]|jue|vie|s[a]b)/i,
    wide: /^(domingo|lunes|martes|mi[e]rcoles|jueves|viernes|s[a]bado)/i
  };
  var parseDayPatterns2 = {
    narrow: [/^d/i, /^l/i, /^m/i, /^m/i, /^j/i, /^v/i, /^s/i],
    any: [/^do/i, /^lu/i, /^ma/i, /^mi/i, /^ju/i, /^vi/i, /^sa/i]
  };
  var matchDayPeriodPatterns2 = {
    narrow: /^(a|p|mn|md|(de la|a las) (maana|tarde|noche))/i,
    any: /^([ap]\.?\s?m\.?|medianoche|mediodia|(de la|a las) (maana|tarde|noche))/i
  };
  var parseDayPeriodPatterns2 = {
    any: {
      am: /^a/i,
      pm: /^p/i,
      midnight: /^mn/i,
      noon: /^md/i,
      morning: /maana/i,
      afternoon: /tarde/i,
      evening: /tarde/i,
      night: /noche/i
    }
  };
  var match2 = {
    ordinalNumber: buildMatchPatternFn({
      matchPattern: matchOrdinalNumberPattern2,
      parsePattern: parseOrdinalNumberPattern2,
      valueCallback: function(value) {
        return parseInt(value, 10);
      }
    }),
    era: buildMatchFn({
      matchPatterns: matchEraPatterns2,
      defaultMatchWidth: "wide",
      parsePatterns: parseEraPatterns2,
      defaultParseWidth: "any"
    }),
    quarter: buildMatchFn({
      matchPatterns: matchQuarterPatterns2,
      defaultMatchWidth: "wide",
      parsePatterns: parseQuarterPatterns2,
      defaultParseWidth: "any",
      valueCallback: function(index) {
        return index + 1;
      }
    }),
    month: buildMatchFn({
      matchPatterns: matchMonthPatterns2,
      defaultMatchWidth: "wide",
      parsePatterns: parseMonthPatterns2,
      defaultParseWidth: "any"
    }),
    day: buildMatchFn({
      matchPatterns: matchDayPatterns2,
      defaultMatchWidth: "wide",
      parsePatterns: parseDayPatterns2,
      defaultParseWidth: "any"
    }),
    dayPeriod: buildMatchFn({
      matchPatterns: matchDayPeriodPatterns2,
      defaultMatchWidth: "any",
      parsePatterns: parseDayPeriodPatterns2,
      defaultParseWidth: "any"
    })
  };
  var match_default2 = match2;

  // node_modules/date-fns/esm/locale/es/index.js
  var locale3 = {
    code: "es",
    formatDistance: formatDistance_default2,
    formatLong: formatLong_default2,
    formatRelative: formatRelative_default2,
    localize: localize_default2,
    match: match_default2,
    options: {
      weekStartsOn: 1,
      firstWeekContainsDate: 1
    }
  };
  var es_default = locale3;

  // node_modules/html5-qrcode/esm/core.js
  var Html5QrcodeSupportedFormats;
  (function(Html5QrcodeSupportedFormats2) {
    Html5QrcodeSupportedFormats2[Html5QrcodeSupportedFormats2["QR_CODE"] = 0] = "QR_CODE";
    Html5QrcodeSupportedFormats2[Html5QrcodeSupportedFormats2["AZTEC"] = 1] = "AZTEC";
    Html5QrcodeSupportedFormats2[Html5QrcodeSupportedFormats2["CODABAR"] = 2] = "CODABAR";
    Html5QrcodeSupportedFormats2[Html5QrcodeSupportedFormats2["CODE_39"] = 3] = "CODE_39";
    Html5QrcodeSupportedFormats2[Html5QrcodeSupportedFormats2["CODE_93"] = 4] = "CODE_93";
    Html5QrcodeSupportedFormats2[Html5QrcodeSupportedFormats2["CODE_128"] = 5] = "CODE_128";
    Html5QrcodeSupportedFormats2[Html5QrcodeSupportedFormats2["DATA_MATRIX"] = 6] = "DATA_MATRIX";
    Html5QrcodeSupportedFormats2[Html5QrcodeSupportedFormats2["MAXICODE"] = 7] = "MAXICODE";
    Html5QrcodeSupportedFormats2[Html5QrcodeSupportedFormats2["ITF"] = 8] = "ITF";
    Html5QrcodeSupportedFormats2[Html5QrcodeSupportedFormats2["EAN_13"] = 9] = "EAN_13";
    Html5QrcodeSupportedFormats2[Html5QrcodeSupportedFormats2["EAN_8"] = 10] = "EAN_8";
    Html5QrcodeSupportedFormats2[Html5QrcodeSupportedFormats2["PDF_417"] = 11] = "PDF_417";
    Html5QrcodeSupportedFormats2[Html5QrcodeSupportedFormats2["RSS_14"] = 12] = "RSS_14";
    Html5QrcodeSupportedFormats2[Html5QrcodeSupportedFormats2["RSS_EXPANDED"] = 13] = "RSS_EXPANDED";
    Html5QrcodeSupportedFormats2[Html5QrcodeSupportedFormats2["UPC_A"] = 14] = "UPC_A";
    Html5QrcodeSupportedFormats2[Html5QrcodeSupportedFormats2["UPC_E"] = 15] = "UPC_E";
    Html5QrcodeSupportedFormats2[Html5QrcodeSupportedFormats2["UPC_EAN_EXTENSION"] = 16] = "UPC_EAN_EXTENSION";
  })(Html5QrcodeSupportedFormats || (Html5QrcodeSupportedFormats = {}));
  var html5QrcodeSupportedFormatsTextMap = /* @__PURE__ */ new Map([
    [Html5QrcodeSupportedFormats.QR_CODE, "QR_CODE"],
    [Html5QrcodeSupportedFormats.AZTEC, "AZTEC"],
    [Html5QrcodeSupportedFormats.CODABAR, "CODABAR"],
    [Html5QrcodeSupportedFormats.CODE_39, "CODE_39"],
    [Html5QrcodeSupportedFormats.CODE_93, "CODE_93"],
    [Html5QrcodeSupportedFormats.CODE_128, "CODE_128"],
    [Html5QrcodeSupportedFormats.DATA_MATRIX, "DATA_MATRIX"],
    [Html5QrcodeSupportedFormats.MAXICODE, "MAXICODE"],
    [Html5QrcodeSupportedFormats.ITF, "ITF"],
    [Html5QrcodeSupportedFormats.EAN_13, "EAN_13"],
    [Html5QrcodeSupportedFormats.EAN_8, "EAN_8"],
    [Html5QrcodeSupportedFormats.PDF_417, "PDF_417"],
    [Html5QrcodeSupportedFormats.RSS_14, "RSS_14"],
    [Html5QrcodeSupportedFormats.RSS_EXPANDED, "RSS_EXPANDED"],
    [Html5QrcodeSupportedFormats.UPC_A, "UPC_A"],
    [Html5QrcodeSupportedFormats.UPC_E, "UPC_E"],
    [Html5QrcodeSupportedFormats.UPC_EAN_EXTENSION, "UPC_EAN_EXTENSION"]
  ]);
  var DecodedTextType;
  (function(DecodedTextType2) {
    DecodedTextType2[DecodedTextType2["UNKNOWN"] = 0] = "UNKNOWN";
    DecodedTextType2[DecodedTextType2["URL"] = 1] = "URL";
  })(DecodedTextType || (DecodedTextType = {}));
  function isValidHtml5QrcodeSupportedFormats(format) {
    return Object.values(Html5QrcodeSupportedFormats).includes(format);
  }
  var Html5QrcodeScanType;
  (function(Html5QrcodeScanType2) {
    Html5QrcodeScanType2[Html5QrcodeScanType2["SCAN_TYPE_CAMERA"] = 0] = "SCAN_TYPE_CAMERA";
    Html5QrcodeScanType2[Html5QrcodeScanType2["SCAN_TYPE_FILE"] = 1] = "SCAN_TYPE_FILE";
  })(Html5QrcodeScanType || (Html5QrcodeScanType = {}));
  var Html5QrcodeConstants = function() {
    function Html5QrcodeConstants2() {
    }
    Html5QrcodeConstants2.GITHUB_PROJECT_URL = "https://github.com/mebjas/html5-qrcode";
    Html5QrcodeConstants2.SCAN_DEFAULT_FPS = 2;
    Html5QrcodeConstants2.DEFAULT_DISABLE_FLIP = false;
    Html5QrcodeConstants2.DEFAULT_REMEMBER_LAST_CAMERA_USED = true;
    Html5QrcodeConstants2.DEFAULT_SUPPORTED_SCAN_TYPE = [
      Html5QrcodeScanType.SCAN_TYPE_CAMERA,
      Html5QrcodeScanType.SCAN_TYPE_FILE
    ];
    return Html5QrcodeConstants2;
  }();
  var QrcodeResultFormat = function() {
    function QrcodeResultFormat2(format, formatName) {
      this.format = format;
      this.formatName = formatName;
    }
    QrcodeResultFormat2.prototype.toString = function() {
      return this.formatName;
    };
    QrcodeResultFormat2.create = function(format) {
      if (!html5QrcodeSupportedFormatsTextMap.has(format)) {
        throw "".concat(format, " not in html5QrcodeSupportedFormatsTextMap");
      }
      return new QrcodeResultFormat2(format, html5QrcodeSupportedFormatsTextMap.get(format));
    };
    return QrcodeResultFormat2;
  }();
  var Html5QrcodeResultFactory = function() {
    function Html5QrcodeResultFactory2() {
    }
    Html5QrcodeResultFactory2.createFromText = function(decodedText) {
      var qrcodeResult = {
        text: decodedText
      };
      return {
        decodedText,
        result: qrcodeResult
      };
    };
    Html5QrcodeResultFactory2.createFromQrcodeResult = function(qrcodeResult) {
      return {
        decodedText: qrcodeResult.text,
        result: qrcodeResult
      };
    };
    return Html5QrcodeResultFactory2;
  }();
  var Html5QrcodeErrorTypes;
  (function(Html5QrcodeErrorTypes2) {
    Html5QrcodeErrorTypes2[Html5QrcodeErrorTypes2["UNKWOWN_ERROR"] = 0] = "UNKWOWN_ERROR";
    Html5QrcodeErrorTypes2[Html5QrcodeErrorTypes2["IMPLEMENTATION_ERROR"] = 1] = "IMPLEMENTATION_ERROR";
    Html5QrcodeErrorTypes2[Html5QrcodeErrorTypes2["NO_CODE_FOUND_ERROR"] = 2] = "NO_CODE_FOUND_ERROR";
  })(Html5QrcodeErrorTypes || (Html5QrcodeErrorTypes = {}));
  var Html5QrcodeErrorFactory = function() {
    function Html5QrcodeErrorFactory2() {
    }
    Html5QrcodeErrorFactory2.createFrom = function(error2) {
      return {
        errorMessage: error2,
        type: Html5QrcodeErrorTypes.UNKWOWN_ERROR
      };
    };
    return Html5QrcodeErrorFactory2;
  }();
  var BaseLoggger = function() {
    function BaseLoggger2(verbose) {
      this.verbose = verbose;
    }
    BaseLoggger2.prototype.log = function(message) {
      if (this.verbose) {
        console.log(message);
      }
    };
    BaseLoggger2.prototype.warn = function(message) {
      if (this.verbose) {
        console.warn(message);
      }
    };
    BaseLoggger2.prototype.logError = function(message, isExperimental) {
      if (this.verbose || isExperimental === true) {
        console.error(message);
      }
    };
    BaseLoggger2.prototype.logErrors = function(errors) {
      if (errors.length === 0) {
        throw "Logger#logError called without arguments";
      }
      if (this.verbose) {
        console.error(errors);
      }
    };
    return BaseLoggger2;
  }();
  function isNullOrUndefined(obj) {
    return typeof obj === "undefined" || obj === null;
  }
  function clip(value, minValue, maxValue) {
    if (value > maxValue) {
      return maxValue;
    }
    if (value < minValue) {
      return minValue;
    }
    return value;
  }

  // node_modules/html5-qrcode/esm/strings.js
  var Html5QrcodeStrings = function() {
    function Html5QrcodeStrings2() {
    }
    Html5QrcodeStrings2.codeParseError = function(exception) {
      return "QR code parse error, error = ".concat(exception);
    };
    Html5QrcodeStrings2.errorGettingUserMedia = function(error2) {
      return "Error getting userMedia, error = ".concat(error2);
    };
    Html5QrcodeStrings2.onlyDeviceSupportedError = function() {
      return "The device doesn't support navigator.mediaDevices , only supported cameraIdOrConfig in this case is deviceId parameter (string).";
    };
    Html5QrcodeStrings2.cameraStreamingNotSupported = function() {
      return "Camera streaming not supported by the browser.";
    };
    Html5QrcodeStrings2.unableToQuerySupportedDevices = function() {
      return "Unable to query supported devices, unknown error.";
    };
    Html5QrcodeStrings2.insecureContextCameraQueryError = function() {
      return "Camera access is only supported in secure context like https or localhost.";
    };
    Html5QrcodeStrings2.scannerPaused = function() {
      return "Scanner paused";
    };
    return Html5QrcodeStrings2;
  }();
  var Html5QrcodeScannerStrings = function() {
    function Html5QrcodeScannerStrings2() {
    }
    Html5QrcodeScannerStrings2.scanningStatus = function() {
      return "Scanning";
    };
    Html5QrcodeScannerStrings2.idleStatus = function() {
      return "Idle";
    };
    Html5QrcodeScannerStrings2.errorStatus = function() {
      return "Error";
    };
    Html5QrcodeScannerStrings2.permissionStatus = function() {
      return "Permission";
    };
    Html5QrcodeScannerStrings2.noCameraFoundErrorStatus = function() {
      return "No Cameras";
    };
    Html5QrcodeScannerStrings2.lastMatch = function(decodedText) {
      return "Last Match: ".concat(decodedText);
    };
    Html5QrcodeScannerStrings2.codeScannerTitle = function() {
      return "Code Scanner";
    };
    Html5QrcodeScannerStrings2.cameraPermissionTitle = function() {
      return "Request Camera Permissions";
    };
    Html5QrcodeScannerStrings2.cameraPermissionRequesting = function() {
      return "Requesting camera permissions...";
    };
    Html5QrcodeScannerStrings2.noCameraFound = function() {
      return "No camera found";
    };
    Html5QrcodeScannerStrings2.scanButtonStopScanningText = function() {
      return "Stop Scanning";
    };
    Html5QrcodeScannerStrings2.scanButtonStartScanningText = function() {
      return "Start Scanning";
    };
    Html5QrcodeScannerStrings2.torchOnButton = function() {
      return "Switch On Torch";
    };
    Html5QrcodeScannerStrings2.torchOffButton = function() {
      return "Switch Off Torch";
    };
    Html5QrcodeScannerStrings2.torchOnFailedMessage = function() {
      return "Failed to turn on torch";
    };
    Html5QrcodeScannerStrings2.torchOffFailedMessage = function() {
      return "Failed to turn off torch";
    };
    Html5QrcodeScannerStrings2.scanButtonScanningStarting = function() {
      return "Launching Camera...";
    };
    Html5QrcodeScannerStrings2.textIfCameraScanSelected = function() {
      return "Scan an Image File";
    };
    Html5QrcodeScannerStrings2.textIfFileScanSelected = function() {
      return "Scan using camera directly";
    };
    Html5QrcodeScannerStrings2.selectCamera = function() {
      return "Select Camera";
    };
    Html5QrcodeScannerStrings2.fileSelectionChooseImage = function() {
      return "Choose Image";
    };
    Html5QrcodeScannerStrings2.fileSelectionChooseAnother = function() {
      return "Choose Another";
    };
    Html5QrcodeScannerStrings2.fileSelectionNoImageSelected = function() {
      return "No image choosen";
    };
    Html5QrcodeScannerStrings2.anonymousCameraPrefix = function() {
      return "Anonymous Camera";
    };
    Html5QrcodeScannerStrings2.dragAndDropMessage = function() {
      return "Or drop an image to scan";
    };
    Html5QrcodeScannerStrings2.dragAndDropMessageOnlyImages = function() {
      return "Or drop an image to scan (other files not supported)";
    };
    Html5QrcodeScannerStrings2.zoom = function() {
      return "zoom";
    };
    Html5QrcodeScannerStrings2.loadingImage = function() {
      return "Loading image...";
    };
    Html5QrcodeScannerStrings2.cameraScanAltText = function() {
      return "Camera based scan";
    };
    Html5QrcodeScannerStrings2.fileScanAltText = function() {
      return "Fule based scan";
    };
    return Html5QrcodeScannerStrings2;
  }();
  var LibraryInfoStrings = function() {
    function LibraryInfoStrings2() {
    }
    LibraryInfoStrings2.poweredBy = function() {
      return "Powered by ";
    };
    LibraryInfoStrings2.reportIssues = function() {
      return "Report issues";
    };
    return LibraryInfoStrings2;
  }();

  // node_modules/html5-qrcode/esm/utils.js
  var VideoConstraintsUtil = function() {
    function VideoConstraintsUtil2() {
    }
    VideoConstraintsUtil2.isMediaStreamConstraintsValid = function(videoConstraints, logger) {
      if (typeof videoConstraints !== "object") {
        var typeofVideoConstraints = typeof videoConstraints;
        logger.logError("videoConstraints should be of type object, the " + "object passed is of type ".concat(typeofVideoConstraints, "."), true);
        return false;
      }
      var bannedKeys = [
        "autoGainControl",
        "channelCount",
        "echoCancellation",
        "latency",
        "noiseSuppression",
        "sampleRate",
        "sampleSize",
        "volume"
      ];
      var bannedkeysSet = new Set(bannedKeys);
      var keysInVideoConstraints = Object.keys(videoConstraints);
      for (var _i = 0, keysInVideoConstraints_1 = keysInVideoConstraints; _i < keysInVideoConstraints_1.length; _i++) {
        var key = keysInVideoConstraints_1[_i];
        if (bannedkeysSet.has(key)) {
          logger.logError("".concat(key, " is not supported videoConstaints."), true);
          return false;
        }
      }
      return true;
    };
    return VideoConstraintsUtil2;
  }();

  // node_modules/html5-qrcode/esm/zxing-html5-qrcode-decoder.js
  var ZXing = __toModule(require_zxing_js_umd());
  var ZXingHtml5QrcodeDecoder = function() {
    function ZXingHtml5QrcodeDecoder2(requestedFormats, verbose, logger) {
      this.formatMap = /* @__PURE__ */ new Map([
        [Html5QrcodeSupportedFormats.QR_CODE, ZXing.BarcodeFormat.QR_CODE],
        [Html5QrcodeSupportedFormats.AZTEC, ZXing.BarcodeFormat.AZTEC],
        [Html5QrcodeSupportedFormats.CODABAR, ZXing.BarcodeFormat.CODABAR],
        [Html5QrcodeSupportedFormats.CODE_39, ZXing.BarcodeFormat.CODE_39],
        [Html5QrcodeSupportedFormats.CODE_93, ZXing.BarcodeFormat.CODE_93],
        [
          Html5QrcodeSupportedFormats.CODE_128,
          ZXing.BarcodeFormat.CODE_128
        ],
        [
          Html5QrcodeSupportedFormats.DATA_MATRIX,
          ZXing.BarcodeFormat.DATA_MATRIX
        ],
        [
          Html5QrcodeSupportedFormats.MAXICODE,
          ZXing.BarcodeFormat.MAXICODE
        ],
        [Html5QrcodeSupportedFormats.ITF, ZXing.BarcodeFormat.ITF],
        [Html5QrcodeSupportedFormats.EAN_13, ZXing.BarcodeFormat.EAN_13],
        [Html5QrcodeSupportedFormats.EAN_8, ZXing.BarcodeFormat.EAN_8],
        [Html5QrcodeSupportedFormats.PDF_417, ZXing.BarcodeFormat.PDF_417],
        [Html5QrcodeSupportedFormats.RSS_14, ZXing.BarcodeFormat.RSS_14],
        [
          Html5QrcodeSupportedFormats.RSS_EXPANDED,
          ZXing.BarcodeFormat.RSS_EXPANDED
        ],
        [Html5QrcodeSupportedFormats.UPC_A, ZXing.BarcodeFormat.UPC_A],
        [Html5QrcodeSupportedFormats.UPC_E, ZXing.BarcodeFormat.UPC_E],
        [
          Html5QrcodeSupportedFormats.UPC_EAN_EXTENSION,
          ZXing.BarcodeFormat.UPC_EAN_EXTENSION
        ]
      ]);
      this.reverseFormatMap = this.createReverseFormatMap();
      if (!ZXing) {
        throw "Use html5qrcode.min.js without edit, ZXing not found.";
      }
      this.verbose = verbose;
      this.logger = logger;
      var formats = this.createZXingFormats(requestedFormats);
      var hints = /* @__PURE__ */ new Map();
      hints.set(ZXing.DecodeHintType.POSSIBLE_FORMATS, formats);
      hints.set(ZXing.DecodeHintType.TRY_HARDER, false);
      this.hints = hints;
    }
    ZXingHtml5QrcodeDecoder2.prototype.decodeAsync = function(canvas) {
      var _this = this;
      return new Promise(function(resolve, reject) {
        try {
          resolve(_this.decode(canvas));
        } catch (error2) {
          reject(error2);
        }
      });
    };
    ZXingHtml5QrcodeDecoder2.prototype.decode = function(canvas) {
      var zxingDecoder = new ZXing.MultiFormatReader(this.verbose, this.hints);
      var luminanceSource = new ZXing.HTMLCanvasElementLuminanceSource(canvas);
      var binaryBitmap = new ZXing.BinaryBitmap(new ZXing.HybridBinarizer(luminanceSource));
      var result = zxingDecoder.decode(binaryBitmap);
      return {
        text: result.text,
        format: QrcodeResultFormat.create(this.toHtml5QrcodeSupportedFormats(result.format)),
        debugData: this.createDebugData()
      };
    };
    ZXingHtml5QrcodeDecoder2.prototype.createReverseFormatMap = function() {
      var result = /* @__PURE__ */ new Map();
      this.formatMap.forEach(function(value, key, _) {
        result.set(value, key);
      });
      return result;
    };
    ZXingHtml5QrcodeDecoder2.prototype.toHtml5QrcodeSupportedFormats = function(zxingFormat) {
      if (!this.reverseFormatMap.has(zxingFormat)) {
        throw "reverseFormatMap doesn't have ".concat(zxingFormat);
      }
      return this.reverseFormatMap.get(zxingFormat);
    };
    ZXingHtml5QrcodeDecoder2.prototype.createZXingFormats = function(requestedFormats) {
      var zxingFormats = [];
      for (var _i = 0, requestedFormats_1 = requestedFormats; _i < requestedFormats_1.length; _i++) {
        var requestedFormat = requestedFormats_1[_i];
        if (this.formatMap.has(requestedFormat)) {
          zxingFormats.push(this.formatMap.get(requestedFormat));
        } else {
          this.logger.logError("".concat(requestedFormat, " is not supported by") + "ZXingHtml5QrcodeShim");
        }
      }
      return zxingFormats;
    };
    ZXingHtml5QrcodeDecoder2.prototype.createDebugData = function() {
      return { decoderName: "zxing-js" };
    };
    return ZXingHtml5QrcodeDecoder2;
  }();

  // node_modules/html5-qrcode/esm/native-bar-code-detector.js
  var __awaiter = function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __generator = function(thisArg, body) {
    var _ = { label: 0, sent: function() {
      if (t[0] & 1)
        throw t[1];
      return t[1];
    }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
      return this;
    }), g;
    function verb(n) {
      return function(v) {
        return step([n, v]);
      };
    }
    function step(op) {
      if (f)
        throw new TypeError("Generator is already executing.");
      while (g && (g = 0, op[0] && (_ = 0)), _)
        try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
            return t;
          if (y = 0, t)
            op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _.label++;
              return { value: op[1], done: false };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }
              if (t && _.label < t[2]) {
                _.label = t[2];
                _.ops.push(op);
                break;
              }
              if (t[2])
                _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
      if (op[0] & 5)
        throw op[1];
      return { value: op[0] ? op[1] : void 0, done: true };
    }
  };
  var BarcodeDetectorDelegate = function() {
    function BarcodeDetectorDelegate2(requestedFormats, verbose, logger) {
      this.formatMap = /* @__PURE__ */ new Map([
        [Html5QrcodeSupportedFormats.QR_CODE, "qr_code"],
        [Html5QrcodeSupportedFormats.AZTEC, "aztec"],
        [Html5QrcodeSupportedFormats.CODABAR, "codabar"],
        [Html5QrcodeSupportedFormats.CODE_39, "code_39"],
        [Html5QrcodeSupportedFormats.CODE_93, "code_93"],
        [Html5QrcodeSupportedFormats.CODE_128, "code_128"],
        [Html5QrcodeSupportedFormats.DATA_MATRIX, "data_matrix"],
        [Html5QrcodeSupportedFormats.ITF, "itf"],
        [Html5QrcodeSupportedFormats.EAN_13, "ean_13"],
        [Html5QrcodeSupportedFormats.EAN_8, "ean_8"],
        [Html5QrcodeSupportedFormats.PDF_417, "pdf417"],
        [Html5QrcodeSupportedFormats.UPC_A, "upc_a"],
        [Html5QrcodeSupportedFormats.UPC_E, "upc_e"]
      ]);
      this.reverseFormatMap = this.createReverseFormatMap();
      if (!BarcodeDetectorDelegate2.isSupported()) {
        throw "Use html5qrcode.min.js without edit, Use BarcodeDetectorDelegate only if it isSupported();";
      }
      this.verbose = verbose;
      this.logger = logger;
      var formats = this.createBarcodeDetectorFormats(requestedFormats);
      this.detector = new BarcodeDetector(formats);
      if (!this.detector) {
        throw "BarcodeDetector detector not supported";
      }
    }
    BarcodeDetectorDelegate2.isSupported = function() {
      if (!("BarcodeDetector" in window)) {
        return false;
      }
      var dummyDetector = new BarcodeDetector({ formats: ["qr_code"] });
      return typeof dummyDetector !== "undefined";
    };
    BarcodeDetectorDelegate2.prototype.decodeAsync = function(canvas) {
      return __awaiter(this, void 0, void 0, function() {
        var barcodes, largestBarcode;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              return [4, this.detector.detect(canvas)];
            case 1:
              barcodes = _a.sent();
              if (!barcodes || barcodes.length === 0) {
                throw "No barcode or QR code detected.";
              }
              largestBarcode = this.selectLargestBarcode(barcodes);
              return [2, {
                text: largestBarcode.rawValue,
                format: QrcodeResultFormat.create(this.toHtml5QrcodeSupportedFormats(largestBarcode.format)),
                debugData: this.createDebugData()
              }];
          }
        });
      });
    };
    BarcodeDetectorDelegate2.prototype.selectLargestBarcode = function(barcodes) {
      var largestBarcode = null;
      var maxArea = 0;
      for (var _i = 0, barcodes_1 = barcodes; _i < barcodes_1.length; _i++) {
        var barcode = barcodes_1[_i];
        var area = barcode.boundingBox.width * barcode.boundingBox.height;
        if (area > maxArea) {
          maxArea = area;
          largestBarcode = barcode;
        }
      }
      if (!largestBarcode) {
        throw "No largest barcode found";
      }
      return largestBarcode;
    };
    BarcodeDetectorDelegate2.prototype.createBarcodeDetectorFormats = function(requestedFormats) {
      var formats = [];
      for (var _i = 0, requestedFormats_1 = requestedFormats; _i < requestedFormats_1.length; _i++) {
        var requestedFormat = requestedFormats_1[_i];
        if (this.formatMap.has(requestedFormat)) {
          formats.push(this.formatMap.get(requestedFormat));
        } else {
          this.logger.warn("".concat(requestedFormat, " is not supported by") + "BarcodeDetectorDelegate");
        }
      }
      return { formats };
    };
    BarcodeDetectorDelegate2.prototype.toHtml5QrcodeSupportedFormats = function(barcodeDetectorFormat) {
      if (!this.reverseFormatMap.has(barcodeDetectorFormat)) {
        throw "reverseFormatMap doesn't have ".concat(barcodeDetectorFormat);
      }
      return this.reverseFormatMap.get(barcodeDetectorFormat);
    };
    BarcodeDetectorDelegate2.prototype.createReverseFormatMap = function() {
      var result = /* @__PURE__ */ new Map();
      this.formatMap.forEach(function(value, key, _) {
        result.set(value, key);
      });
      return result;
    };
    BarcodeDetectorDelegate2.prototype.createDebugData = function() {
      return { decoderName: "BarcodeDetector" };
    };
    return BarcodeDetectorDelegate2;
  }();

  // node_modules/html5-qrcode/esm/code-decoder.js
  var __awaiter2 = function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __generator2 = function(thisArg, body) {
    var _ = { label: 0, sent: function() {
      if (t[0] & 1)
        throw t[1];
      return t[1];
    }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
      return this;
    }), g;
    function verb(n) {
      return function(v) {
        return step([n, v]);
      };
    }
    function step(op) {
      if (f)
        throw new TypeError("Generator is already executing.");
      while (g && (g = 0, op[0] && (_ = 0)), _)
        try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
            return t;
          if (y = 0, t)
            op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _.label++;
              return { value: op[1], done: false };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }
              if (t && _.label < t[2]) {
                _.label = t[2];
                _.ops.push(op);
                break;
              }
              if (t[2])
                _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
      if (op[0] & 5)
        throw op[1];
      return { value: op[0] ? op[1] : void 0, done: true };
    }
  };
  var Html5QrcodeShim = function() {
    function Html5QrcodeShim2(requestedFormats, useBarCodeDetectorIfSupported, verbose, logger) {
      this.EXECUTIONS_TO_REPORT_PERFORMANCE = 100;
      this.executions = 0;
      this.executionResults = [];
      this.wasPrimaryDecoderUsedInLastDecode = false;
      this.verbose = verbose;
      if (useBarCodeDetectorIfSupported && BarcodeDetectorDelegate.isSupported()) {
        this.primaryDecoder = new BarcodeDetectorDelegate(requestedFormats, verbose, logger);
        this.secondaryDecoder = new ZXingHtml5QrcodeDecoder(requestedFormats, verbose, logger);
      } else {
        this.primaryDecoder = new ZXingHtml5QrcodeDecoder(requestedFormats, verbose, logger);
      }
    }
    Html5QrcodeShim2.prototype.decodeAsync = function(canvas) {
      return __awaiter2(this, void 0, void 0, function() {
        var startTime;
        return __generator2(this, function(_a) {
          switch (_a.label) {
            case 0:
              startTime = performance.now();
              _a.label = 1;
            case 1:
              _a.trys.push([1, , 3, 4]);
              return [4, this.getDecoder().decodeAsync(canvas)];
            case 2:
              return [2, _a.sent()];
            case 3:
              this.possiblyLogPerformance(startTime);
              return [7];
            case 4:
              return [2];
          }
        });
      });
    };
    Html5QrcodeShim2.prototype.decodeRobustlyAsync = function(canvas) {
      return __awaiter2(this, void 0, void 0, function() {
        var startTime, error_1;
        return __generator2(this, function(_a) {
          switch (_a.label) {
            case 0:
              startTime = performance.now();
              _a.label = 1;
            case 1:
              _a.trys.push([1, 3, 4, 5]);
              return [4, this.primaryDecoder.decodeAsync(canvas)];
            case 2:
              return [2, _a.sent()];
            case 3:
              error_1 = _a.sent();
              if (this.secondaryDecoder) {
                return [2, this.secondaryDecoder.decodeAsync(canvas)];
              }
              throw error_1;
            case 4:
              this.possiblyLogPerformance(startTime);
              return [7];
            case 5:
              return [2];
          }
        });
      });
    };
    Html5QrcodeShim2.prototype.getDecoder = function() {
      if (!this.secondaryDecoder) {
        return this.primaryDecoder;
      }
      if (this.wasPrimaryDecoderUsedInLastDecode === false) {
        this.wasPrimaryDecoderUsedInLastDecode = true;
        return this.primaryDecoder;
      }
      this.wasPrimaryDecoderUsedInLastDecode = false;
      return this.secondaryDecoder;
    };
    Html5QrcodeShim2.prototype.possiblyLogPerformance = function(startTime) {
      if (!this.verbose) {
        return;
      }
      var executionTime = performance.now() - startTime;
      this.executionResults.push(executionTime);
      this.executions++;
      this.possiblyFlushPerformanceReport();
    };
    Html5QrcodeShim2.prototype.possiblyFlushPerformanceReport = function() {
      if (this.executions < this.EXECUTIONS_TO_REPORT_PERFORMANCE) {
        return;
      }
      var sum = 0;
      for (var _i = 0, _a = this.executionResults; _i < _a.length; _i++) {
        var executionTime = _a[_i];
        sum += executionTime;
      }
      var mean = sum / this.executionResults.length;
      console.log("".concat(mean, " ms for ").concat(this.executionResults.length, " last runs."));
      this.executions = 0;
      this.executionResults = [];
    };
    return Html5QrcodeShim2;
  }();

  // node_modules/html5-qrcode/esm/camera/core-impl.js
  var __extends = function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  var __awaiter3 = function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __generator3 = function(thisArg, body) {
    var _ = { label: 0, sent: function() {
      if (t[0] & 1)
        throw t[1];
      return t[1];
    }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
      return this;
    }), g;
    function verb(n) {
      return function(v) {
        return step([n, v]);
      };
    }
    function step(op) {
      if (f)
        throw new TypeError("Generator is already executing.");
      while (g && (g = 0, op[0] && (_ = 0)), _)
        try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
            return t;
          if (y = 0, t)
            op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _.label++;
              return { value: op[1], done: false };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }
              if (t && _.label < t[2]) {
                _.label = t[2];
                _.ops.push(op);
                break;
              }
              if (t[2])
                _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
      if (op[0] & 5)
        throw op[1];
      return { value: op[0] ? op[1] : void 0, done: true };
    }
  };
  var AbstractCameraCapability = function() {
    function AbstractCameraCapability2(name, track2) {
      this.name = name;
      this.track = track2;
    }
    AbstractCameraCapability2.prototype.isSupported = function() {
      if (!this.track.getCapabilities) {
        return false;
      }
      return this.name in this.track.getCapabilities();
    };
    AbstractCameraCapability2.prototype.apply = function(value) {
      var constraint = {};
      constraint[this.name] = value;
      var constraints = { advanced: [constraint] };
      return this.track.applyConstraints(constraints);
    };
    AbstractCameraCapability2.prototype.value = function() {
      var settings = this.track.getSettings();
      if (this.name in settings) {
        var settingValue = settings[this.name];
        return settingValue;
      }
      return null;
    };
    return AbstractCameraCapability2;
  }();
  var AbstractRangeCameraCapability = function(_super) {
    __extends(AbstractRangeCameraCapability2, _super);
    function AbstractRangeCameraCapability2(name, track2) {
      return _super.call(this, name, track2) || this;
    }
    AbstractRangeCameraCapability2.prototype.min = function() {
      return this.getCapabilities().min;
    };
    AbstractRangeCameraCapability2.prototype.max = function() {
      return this.getCapabilities().max;
    };
    AbstractRangeCameraCapability2.prototype.step = function() {
      return this.getCapabilities().step;
    };
    AbstractRangeCameraCapability2.prototype.apply = function(value) {
      var constraint = {};
      constraint[this.name] = value;
      var constraints = { advanced: [constraint] };
      return this.track.applyConstraints(constraints);
    };
    AbstractRangeCameraCapability2.prototype.getCapabilities = function() {
      this.failIfNotSupported();
      var capabilities = this.track.getCapabilities();
      var capability = capabilities[this.name];
      return {
        min: capability.min,
        max: capability.max,
        step: capability.step
      };
    };
    AbstractRangeCameraCapability2.prototype.failIfNotSupported = function() {
      if (!this.isSupported()) {
        throw new Error("".concat(this.name, " capability not supported"));
      }
    };
    return AbstractRangeCameraCapability2;
  }(AbstractCameraCapability);
  var ZoomFeatureImpl = function(_super) {
    __extends(ZoomFeatureImpl2, _super);
    function ZoomFeatureImpl2(track2) {
      return _super.call(this, "zoom", track2) || this;
    }
    return ZoomFeatureImpl2;
  }(AbstractRangeCameraCapability);
  var TorchFeatureImpl = function(_super) {
    __extends(TorchFeatureImpl2, _super);
    function TorchFeatureImpl2(track2) {
      return _super.call(this, "torch", track2) || this;
    }
    return TorchFeatureImpl2;
  }(AbstractCameraCapability);
  var CameraCapabilitiesImpl = function() {
    function CameraCapabilitiesImpl2(track2) {
      this.track = track2;
    }
    CameraCapabilitiesImpl2.prototype.zoomFeature = function() {
      return new ZoomFeatureImpl(this.track);
    };
    CameraCapabilitiesImpl2.prototype.torchFeature = function() {
      return new TorchFeatureImpl(this.track);
    };
    return CameraCapabilitiesImpl2;
  }();
  var RenderedCameraImpl = function() {
    function RenderedCameraImpl2(parentElement, mediaStream, callbacks) {
      this.isClosed = false;
      this.parentElement = parentElement;
      this.mediaStream = mediaStream;
      this.callbacks = callbacks;
      this.surface = this.createVideoElement(this.parentElement.clientWidth);
      parentElement.append(this.surface);
    }
    RenderedCameraImpl2.prototype.createVideoElement = function(width) {
      var videoElement = document.createElement("video");
      videoElement.style.width = "".concat(width, "px");
      videoElement.style.display = "block";
      videoElement.muted = true;
      videoElement.setAttribute("muted", "true");
      videoElement.playsInline = true;
      return videoElement;
    };
    RenderedCameraImpl2.prototype.setupSurface = function() {
      var _this = this;
      this.surface.onabort = function() {
        throw "RenderedCameraImpl video surface onabort() called";
      };
      this.surface.onerror = function() {
        throw "RenderedCameraImpl video surface onerror() called";
      };
      var onVideoStart = function() {
        var videoWidth = _this.surface.clientWidth;
        var videoHeight = _this.surface.clientHeight;
        _this.callbacks.onRenderSurfaceReady(videoWidth, videoHeight);
        _this.surface.removeEventListener("playing", onVideoStart);
      };
      this.surface.addEventListener("playing", onVideoStart);
      this.surface.srcObject = this.mediaStream;
      this.surface.play();
    };
    RenderedCameraImpl2.create = function(parentElement, mediaStream, options, callbacks) {
      return __awaiter3(this, void 0, void 0, function() {
        var renderedCamera, aspectRatioConstraint;
        return __generator3(this, function(_a) {
          switch (_a.label) {
            case 0:
              renderedCamera = new RenderedCameraImpl2(parentElement, mediaStream, callbacks);
              if (!options.aspectRatio)
                return [3, 2];
              aspectRatioConstraint = {
                aspectRatio: options.aspectRatio
              };
              return [4, renderedCamera.getFirstTrackOrFail().applyConstraints(aspectRatioConstraint)];
            case 1:
              _a.sent();
              _a.label = 2;
            case 2:
              renderedCamera.setupSurface();
              return [2, renderedCamera];
          }
        });
      });
    };
    RenderedCameraImpl2.prototype.failIfClosed = function() {
      if (this.isClosed) {
        throw "The RenderedCamera has already been closed.";
      }
    };
    RenderedCameraImpl2.prototype.getFirstTrackOrFail = function() {
      this.failIfClosed();
      if (this.mediaStream.getVideoTracks().length === 0) {
        throw "No video tracks found";
      }
      return this.mediaStream.getVideoTracks()[0];
    };
    RenderedCameraImpl2.prototype.pause = function() {
      this.failIfClosed();
      this.surface.pause();
    };
    RenderedCameraImpl2.prototype.resume = function(onResumeCallback) {
      this.failIfClosed();
      var $this = this;
      var onVideoResume = function() {
        setTimeout(onResumeCallback, 200);
        $this.surface.removeEventListener("playing", onVideoResume);
      };
      this.surface.addEventListener("playing", onVideoResume);
      this.surface.play();
    };
    RenderedCameraImpl2.prototype.isPaused = function() {
      this.failIfClosed();
      return this.surface.paused;
    };
    RenderedCameraImpl2.prototype.getSurface = function() {
      this.failIfClosed();
      return this.surface;
    };
    RenderedCameraImpl2.prototype.getRunningTrackCapabilities = function() {
      return this.getFirstTrackOrFail().getCapabilities();
    };
    RenderedCameraImpl2.prototype.getRunningTrackSettings = function() {
      return this.getFirstTrackOrFail().getSettings();
    };
    RenderedCameraImpl2.prototype.applyVideoConstraints = function(constraints) {
      return __awaiter3(this, void 0, void 0, function() {
        return __generator3(this, function(_a) {
          if ("aspectRatio" in constraints) {
            throw "Changing 'aspectRatio' in run-time is not yet supported.";
          }
          return [2, this.getFirstTrackOrFail().applyConstraints(constraints)];
        });
      });
    };
    RenderedCameraImpl2.prototype.close = function() {
      if (this.isClosed) {
        return Promise.resolve();
      }
      var $this = this;
      return new Promise(function(resolve, _) {
        var tracks = $this.mediaStream.getVideoTracks();
        var tracksToClose = tracks.length;
        var tracksClosed = 0;
        $this.mediaStream.getVideoTracks().forEach(function(videoTrack) {
          $this.mediaStream.removeTrack(videoTrack);
          videoTrack.stop();
          ++tracksClosed;
          if (tracksClosed >= tracksToClose) {
            $this.isClosed = true;
            $this.parentElement.removeChild($this.surface);
            resolve();
          }
        });
      });
    };
    RenderedCameraImpl2.prototype.getCapabilities = function() {
      return new CameraCapabilitiesImpl(this.getFirstTrackOrFail());
    };
    return RenderedCameraImpl2;
  }();
  var CameraImpl = function() {
    function CameraImpl2(mediaStream) {
      this.mediaStream = mediaStream;
    }
    CameraImpl2.prototype.render = function(parentElement, options, callbacks) {
      return __awaiter3(this, void 0, void 0, function() {
        return __generator3(this, function(_a) {
          return [2, RenderedCameraImpl.create(parentElement, this.mediaStream, options, callbacks)];
        });
      });
    };
    CameraImpl2.create = function(videoConstraints) {
      return __awaiter3(this, void 0, void 0, function() {
        var constraints, mediaStream;
        return __generator3(this, function(_a) {
          switch (_a.label) {
            case 0:
              if (!navigator.mediaDevices) {
                throw "navigator.mediaDevices not supported";
              }
              constraints = {
                audio: false,
                video: videoConstraints
              };
              return [4, navigator.mediaDevices.getUserMedia(constraints)];
            case 1:
              mediaStream = _a.sent();
              return [2, new CameraImpl2(mediaStream)];
          }
        });
      });
    };
    return CameraImpl2;
  }();

  // node_modules/html5-qrcode/esm/camera/factories.js
  var __awaiter4 = function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __generator4 = function(thisArg, body) {
    var _ = { label: 0, sent: function() {
      if (t[0] & 1)
        throw t[1];
      return t[1];
    }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
      return this;
    }), g;
    function verb(n) {
      return function(v) {
        return step([n, v]);
      };
    }
    function step(op) {
      if (f)
        throw new TypeError("Generator is already executing.");
      while (g && (g = 0, op[0] && (_ = 0)), _)
        try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
            return t;
          if (y = 0, t)
            op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _.label++;
              return { value: op[1], done: false };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }
              if (t && _.label < t[2]) {
                _.label = t[2];
                _.ops.push(op);
                break;
              }
              if (t[2])
                _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
      if (op[0] & 5)
        throw op[1];
      return { value: op[0] ? op[1] : void 0, done: true };
    }
  };
  var CameraFactory = function() {
    function CameraFactory2() {
    }
    CameraFactory2.failIfNotSupported = function() {
      return __awaiter4(this, void 0, void 0, function() {
        return __generator4(this, function(_a) {
          if (!navigator.mediaDevices) {
            throw "navigator.mediaDevices not supported";
          }
          return [2, new CameraFactory2()];
        });
      });
    };
    CameraFactory2.prototype.create = function(videoConstraints) {
      return __awaiter4(this, void 0, void 0, function() {
        return __generator4(this, function(_a) {
          return [2, CameraImpl.create(videoConstraints)];
        });
      });
    };
    return CameraFactory2;
  }();

  // node_modules/html5-qrcode/esm/camera/retriever.js
  var __awaiter5 = function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __generator5 = function(thisArg, body) {
    var _ = { label: 0, sent: function() {
      if (t[0] & 1)
        throw t[1];
      return t[1];
    }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
      return this;
    }), g;
    function verb(n) {
      return function(v) {
        return step([n, v]);
      };
    }
    function step(op) {
      if (f)
        throw new TypeError("Generator is already executing.");
      while (g && (g = 0, op[0] && (_ = 0)), _)
        try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
            return t;
          if (y = 0, t)
            op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _.label++;
              return { value: op[1], done: false };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }
              if (t && _.label < t[2]) {
                _.label = t[2];
                _.ops.push(op);
                break;
              }
              if (t[2])
                _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
      if (op[0] & 5)
        throw op[1];
      return { value: op[0] ? op[1] : void 0, done: true };
    }
  };
  var CameraRetriever = function() {
    function CameraRetriever2() {
    }
    CameraRetriever2.retrieve = function() {
      if (navigator.mediaDevices) {
        return CameraRetriever2.getCamerasFromMediaDevices();
      }
      var mst = MediaStreamTrack;
      if (MediaStreamTrack && mst.getSources) {
        return CameraRetriever2.getCamerasFromMediaStreamTrack();
      }
      return CameraRetriever2.rejectWithError();
    };
    CameraRetriever2.rejectWithError = function() {
      var errorMessage = Html5QrcodeStrings.unableToQuerySupportedDevices();
      if (!CameraRetriever2.isHttpsOrLocalhost()) {
        errorMessage = Html5QrcodeStrings.insecureContextCameraQueryError();
      }
      return Promise.reject(errorMessage);
    };
    CameraRetriever2.isHttpsOrLocalhost = function() {
      if (location.protocol === "https:") {
        return true;
      }
      var host = location.host.split(":")[0];
      return host === "127.0.0.1" || host === "localhost";
    };
    CameraRetriever2.getCamerasFromMediaDevices = function() {
      return __awaiter5(this, void 0, void 0, function() {
        var closeActiveStreams, mediaStream, devices, results, _i, devices_1, device;
        return __generator5(this, function(_a) {
          switch (_a.label) {
            case 0:
              closeActiveStreams = function(stream) {
                var tracks = stream.getVideoTracks();
                for (var _i2 = 0, tracks_1 = tracks; _i2 < tracks_1.length; _i2++) {
                  var track2 = tracks_1[_i2];
                  track2.enabled = false;
                  track2.stop();
                  stream.removeTrack(track2);
                }
              };
              return [4, navigator.mediaDevices.getUserMedia({ audio: false, video: true })];
            case 1:
              mediaStream = _a.sent();
              return [4, navigator.mediaDevices.enumerateDevices()];
            case 2:
              devices = _a.sent();
              results = [];
              for (_i = 0, devices_1 = devices; _i < devices_1.length; _i++) {
                device = devices_1[_i];
                if (device.kind === "videoinput") {
                  results.push({
                    id: device.deviceId,
                    label: device.label
                  });
                }
              }
              closeActiveStreams(mediaStream);
              return [2, results];
          }
        });
      });
    };
    CameraRetriever2.getCamerasFromMediaStreamTrack = function() {
      return new Promise(function(resolve, _) {
        var callback = function(sourceInfos) {
          var results = [];
          for (var _i = 0, sourceInfos_1 = sourceInfos; _i < sourceInfos_1.length; _i++) {
            var sourceInfo = sourceInfos_1[_i];
            if (sourceInfo.kind === "video") {
              results.push({
                id: sourceInfo.id,
                label: sourceInfo.label
              });
            }
          }
          resolve(results);
        };
        var mst = MediaStreamTrack;
        mst.getSources(callback);
      });
    };
    return CameraRetriever2;
  }();

  // node_modules/html5-qrcode/esm/state-manager.js
  var Html5QrcodeScannerState;
  (function(Html5QrcodeScannerState2) {
    Html5QrcodeScannerState2[Html5QrcodeScannerState2["UNKNOWN"] = 0] = "UNKNOWN";
    Html5QrcodeScannerState2[Html5QrcodeScannerState2["NOT_STARTED"] = 1] = "NOT_STARTED";
    Html5QrcodeScannerState2[Html5QrcodeScannerState2["SCANNING"] = 2] = "SCANNING";
    Html5QrcodeScannerState2[Html5QrcodeScannerState2["PAUSED"] = 3] = "PAUSED";
  })(Html5QrcodeScannerState || (Html5QrcodeScannerState = {}));
  var StateManagerImpl = function() {
    function StateManagerImpl2() {
      this.state = Html5QrcodeScannerState.NOT_STARTED;
      this.onGoingTransactionNewState = Html5QrcodeScannerState.UNKNOWN;
    }
    StateManagerImpl2.prototype.directTransition = function(newState) {
      this.failIfTransitionOngoing();
      this.validateTransition(newState);
      this.state = newState;
    };
    StateManagerImpl2.prototype.startTransition = function(newState) {
      this.failIfTransitionOngoing();
      this.validateTransition(newState);
      this.onGoingTransactionNewState = newState;
      return this;
    };
    StateManagerImpl2.prototype.execute = function() {
      if (this.onGoingTransactionNewState === Html5QrcodeScannerState.UNKNOWN) {
        throw "Transaction is already cancelled, cannot execute().";
      }
      var tempNewState = this.onGoingTransactionNewState;
      this.onGoingTransactionNewState = Html5QrcodeScannerState.UNKNOWN;
      this.directTransition(tempNewState);
    };
    StateManagerImpl2.prototype.cancel = function() {
      if (this.onGoingTransactionNewState === Html5QrcodeScannerState.UNKNOWN) {
        throw "Transaction is already cancelled, cannot cancel().";
      }
      this.onGoingTransactionNewState = Html5QrcodeScannerState.UNKNOWN;
    };
    StateManagerImpl2.prototype.getState = function() {
      return this.state;
    };
    StateManagerImpl2.prototype.failIfTransitionOngoing = function() {
      if (this.onGoingTransactionNewState !== Html5QrcodeScannerState.UNKNOWN) {
        throw "Cannot transition to a new state, already under transition";
      }
    };
    StateManagerImpl2.prototype.validateTransition = function(newState) {
      switch (this.state) {
        case Html5QrcodeScannerState.UNKNOWN:
          throw "Transition from unknown is not allowed";
        case Html5QrcodeScannerState.NOT_STARTED:
          this.failIfNewStateIs(newState, [Html5QrcodeScannerState.PAUSED]);
          break;
        case Html5QrcodeScannerState.SCANNING:
          break;
        case Html5QrcodeScannerState.PAUSED:
          break;
      }
    };
    StateManagerImpl2.prototype.failIfNewStateIs = function(newState, disallowedStatesToTransition) {
      for (var _i = 0, disallowedStatesToTransition_1 = disallowedStatesToTransition; _i < disallowedStatesToTransition_1.length; _i++) {
        var disallowedState = disallowedStatesToTransition_1[_i];
        if (newState === disallowedState) {
          throw "Cannot transition from ".concat(this.state, " to ").concat(newState);
        }
      }
    };
    return StateManagerImpl2;
  }();
  var StateManagerProxy = function() {
    function StateManagerProxy2(stateManager) {
      this.stateManager = stateManager;
    }
    StateManagerProxy2.prototype.startTransition = function(newState) {
      return this.stateManager.startTransition(newState);
    };
    StateManagerProxy2.prototype.directTransition = function(newState) {
      this.stateManager.directTransition(newState);
    };
    StateManagerProxy2.prototype.getState = function() {
      return this.stateManager.getState();
    };
    StateManagerProxy2.prototype.canScanFile = function() {
      return this.stateManager.getState() === Html5QrcodeScannerState.NOT_STARTED;
    };
    StateManagerProxy2.prototype.isScanning = function() {
      return this.stateManager.getState() !== Html5QrcodeScannerState.NOT_STARTED;
    };
    StateManagerProxy2.prototype.isStrictlyScanning = function() {
      return this.stateManager.getState() === Html5QrcodeScannerState.SCANNING;
    };
    StateManagerProxy2.prototype.isPaused = function() {
      return this.stateManager.getState() === Html5QrcodeScannerState.PAUSED;
    };
    return StateManagerProxy2;
  }();
  var StateManagerFactory = function() {
    function StateManagerFactory2() {
    }
    StateManagerFactory2.create = function() {
      return new StateManagerProxy(new StateManagerImpl());
    };
    return StateManagerFactory2;
  }();

  // node_modules/html5-qrcode/esm/html5-qrcode.js
  var __extends2 = function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  var Constants = function(_super) {
    __extends2(Constants2, _super);
    function Constants2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Constants2.DEFAULT_WIDTH = 300;
    Constants2.DEFAULT_WIDTH_OFFSET = 2;
    Constants2.FILE_SCAN_MIN_HEIGHT = 300;
    Constants2.FILE_SCAN_HIDDEN_CANVAS_PADDING = 100;
    Constants2.MIN_QR_BOX_SIZE = 50;
    Constants2.SHADED_LEFT = 1;
    Constants2.SHADED_RIGHT = 2;
    Constants2.SHADED_TOP = 3;
    Constants2.SHADED_BOTTOM = 4;
    Constants2.SHADED_REGION_ELEMENT_ID = "qr-shaded-region";
    Constants2.VERBOSE = false;
    Constants2.BORDER_SHADER_DEFAULT_COLOR = "#ffffff";
    Constants2.BORDER_SHADER_MATCH_COLOR = "rgb(90, 193, 56)";
    return Constants2;
  }(Html5QrcodeConstants);
  var InternalHtml5QrcodeConfig = function() {
    function InternalHtml5QrcodeConfig2(config, logger) {
      this.logger = logger;
      this.fps = Constants.SCAN_DEFAULT_FPS;
      if (!config) {
        this.disableFlip = Constants.DEFAULT_DISABLE_FLIP;
      } else {
        if (config.fps) {
          this.fps = config.fps;
        }
        this.disableFlip = config.disableFlip === true;
        this.qrbox = config.qrbox;
        this.aspectRatio = config.aspectRatio;
        this.videoConstraints = config.videoConstraints;
      }
    }
    InternalHtml5QrcodeConfig2.prototype.isMediaStreamConstraintsValid = function() {
      if (!this.videoConstraints) {
        this.logger.logError("Empty videoConstraints", true);
        return false;
      }
      return VideoConstraintsUtil.isMediaStreamConstraintsValid(this.videoConstraints, this.logger);
    };
    InternalHtml5QrcodeConfig2.prototype.isShadedBoxEnabled = function() {
      return !isNullOrUndefined(this.qrbox);
    };
    InternalHtml5QrcodeConfig2.create = function(config, logger) {
      return new InternalHtml5QrcodeConfig2(config, logger);
    };
    return InternalHtml5QrcodeConfig2;
  }();
  var Html5Qrcode = function() {
    function Html5Qrcode2(elementId, configOrVerbosityFlag) {
      this.element = null;
      this.canvasElement = null;
      this.scannerPausedUiElement = null;
      this.hasBorderShaders = null;
      this.borderShaders = null;
      this.qrMatch = null;
      this.renderedCamera = null;
      this.qrRegion = null;
      this.context = null;
      this.lastScanImageFile = null;
      this.isScanning = false;
      if (!document.getElementById(elementId)) {
        throw "HTML Element with id=".concat(elementId, " not found");
      }
      this.elementId = elementId;
      this.verbose = false;
      var experimentalFeatureConfig;
      var configObject;
      if (typeof configOrVerbosityFlag == "boolean") {
        this.verbose = configOrVerbosityFlag === true;
      } else if (configOrVerbosityFlag) {
        configObject = configOrVerbosityFlag;
        this.verbose = configObject.verbose === true;
        experimentalFeatureConfig = configObject.experimentalFeatures;
      }
      this.logger = new BaseLoggger(this.verbose);
      this.qrcode = new Html5QrcodeShim(this.getSupportedFormats(configOrVerbosityFlag), this.getUseBarCodeDetectorIfSupported(configObject), this.verbose, this.logger);
      this.foreverScanTimeout;
      this.shouldScan = true;
      this.stateManagerProxy = StateManagerFactory.create();
    }
    Html5Qrcode2.prototype.start = function(cameraIdOrConfig, configuration, qrCodeSuccessCallback, qrCodeErrorCallback) {
      var _this = this;
      if (!cameraIdOrConfig) {
        throw "cameraIdOrConfig is required";
      }
      if (!qrCodeSuccessCallback || typeof qrCodeSuccessCallback != "function") {
        throw "qrCodeSuccessCallback is required and should be a function.";
      }
      var qrCodeErrorCallbackInternal;
      if (qrCodeErrorCallback) {
        qrCodeErrorCallbackInternal = qrCodeErrorCallback;
      } else {
        qrCodeErrorCallbackInternal = this.verbose ? this.logger.log : function() {
        };
      }
      var internalConfig = InternalHtml5QrcodeConfig.create(configuration, this.logger);
      this.clearElement();
      var videoConstraintsAvailableAndValid = false;
      if (internalConfig.videoConstraints) {
        if (!internalConfig.isMediaStreamConstraintsValid()) {
          this.logger.logError("'videoConstraints' is not valid 'MediaStreamConstraints, it will be ignored.'", true);
        } else {
          videoConstraintsAvailableAndValid = true;
        }
      }
      var areVideoConstraintsEnabled = videoConstraintsAvailableAndValid;
      var element = document.getElementById(this.elementId);
      var rootElementWidth = element.clientWidth ? element.clientWidth : Constants.DEFAULT_WIDTH;
      element.style.position = "relative";
      this.shouldScan = true;
      this.element = element;
      var $this = this;
      var toScanningStateChangeTransaction = this.stateManagerProxy.startTransition(Html5QrcodeScannerState.SCANNING);
      return new Promise(function(resolve, reject) {
        var videoConstraints = areVideoConstraintsEnabled ? internalConfig.videoConstraints : $this.createVideoConstraints(cameraIdOrConfig);
        if (!videoConstraints) {
          toScanningStateChangeTransaction.cancel();
          reject("videoConstraints should be defined");
          return;
        }
        var cameraRenderingOptions = {};
        if (!areVideoConstraintsEnabled || internalConfig.aspectRatio) {
          cameraRenderingOptions.aspectRatio = internalConfig.aspectRatio;
        }
        var renderingCallbacks = {
          onRenderSurfaceReady: function(viewfinderWidth, viewfinderHeight) {
            $this.setupUi(viewfinderWidth, viewfinderHeight, internalConfig);
            $this.isScanning = true;
            $this.foreverScan(internalConfig, qrCodeSuccessCallback, qrCodeErrorCallbackInternal);
          }
        };
        CameraFactory.failIfNotSupported().then(function(factory) {
          factory.create(videoConstraints).then(function(camera) {
            return camera.render(_this.element, cameraRenderingOptions, renderingCallbacks).then(function(renderedCamera) {
              $this.renderedCamera = renderedCamera;
              toScanningStateChangeTransaction.execute();
              resolve(null);
            }).catch(function(error2) {
              toScanningStateChangeTransaction.cancel();
              reject(error2);
            });
          }).catch(function(error2) {
            toScanningStateChangeTransaction.cancel();
            reject(Html5QrcodeStrings.errorGettingUserMedia(error2));
          });
        }).catch(function(_) {
          toScanningStateChangeTransaction.cancel();
          reject(Html5QrcodeStrings.cameraStreamingNotSupported());
        });
      });
    };
    Html5Qrcode2.prototype.pause = function(shouldPauseVideo) {
      if (!this.stateManagerProxy.isStrictlyScanning()) {
        throw "Cannot pause, scanner is not scanning.";
      }
      this.stateManagerProxy.directTransition(Html5QrcodeScannerState.PAUSED);
      this.showPausedState();
      if (isNullOrUndefined(shouldPauseVideo) || shouldPauseVideo !== true) {
        shouldPauseVideo = false;
      }
      if (shouldPauseVideo && this.renderedCamera) {
        this.renderedCamera.pause();
      }
    };
    Html5Qrcode2.prototype.resume = function() {
      if (!this.stateManagerProxy.isPaused()) {
        throw "Cannot result, scanner is not paused.";
      }
      if (!this.renderedCamera) {
        throw "renderedCamera doesn't exist while trying resume()";
      }
      var $this = this;
      var transitionToScanning = function() {
        $this.stateManagerProxy.directTransition(Html5QrcodeScannerState.SCANNING);
        $this.hidePausedState();
      };
      if (!this.renderedCamera.isPaused()) {
        transitionToScanning();
        return;
      }
      this.renderedCamera.resume(function() {
        transitionToScanning();
      });
    };
    Html5Qrcode2.prototype.getState = function() {
      return this.stateManagerProxy.getState();
    };
    Html5Qrcode2.prototype.stop = function() {
      var _this = this;
      if (!this.stateManagerProxy.isScanning()) {
        throw "Cannot stop, scanner is not running or paused.";
      }
      var toStoppedStateTransaction = this.stateManagerProxy.startTransition(Html5QrcodeScannerState.NOT_STARTED);
      this.shouldScan = false;
      if (this.foreverScanTimeout) {
        clearTimeout(this.foreverScanTimeout);
      }
      var removeQrRegion = function() {
        if (!_this.element) {
          return;
        }
        var childElement = document.getElementById(Constants.SHADED_REGION_ELEMENT_ID);
        if (childElement) {
          _this.element.removeChild(childElement);
        }
      };
      var $this = this;
      return this.renderedCamera.close().then(function() {
        $this.renderedCamera = null;
        if ($this.element) {
          $this.element.removeChild($this.canvasElement);
          $this.canvasElement = null;
        }
        removeQrRegion();
        if ($this.qrRegion) {
          $this.qrRegion = null;
        }
        if ($this.context) {
          $this.context = null;
        }
        toStoppedStateTransaction.execute();
        $this.hidePausedState();
        $this.isScanning = false;
        return Promise.resolve();
      });
    };
    Html5Qrcode2.prototype.scanFile = function(imageFile, showImage) {
      return this.scanFileV2(imageFile, showImage).then(function(html5qrcodeResult) {
        return html5qrcodeResult.decodedText;
      });
    };
    Html5Qrcode2.prototype.scanFileV2 = function(imageFile, showImage) {
      var _this = this;
      if (!imageFile || !(imageFile instanceof File)) {
        throw "imageFile argument is mandatory and should be instance of File. Use 'event.target.files[0]'.";
      }
      if (isNullOrUndefined(showImage)) {
        showImage = true;
      }
      if (!this.stateManagerProxy.canScanFile()) {
        throw "Cannot start file scan - ongoing camera scan";
      }
      return new Promise(function(resolve, reject) {
        _this.possiblyCloseLastScanImageFile();
        _this.clearElement();
        _this.lastScanImageFile = URL.createObjectURL(imageFile);
        var inputImage = new Image();
        inputImage.onload = function() {
          var imageWidth = inputImage.width;
          var imageHeight = inputImage.height;
          var element = document.getElementById(_this.elementId);
          var containerWidth = element.clientWidth ? element.clientWidth : Constants.DEFAULT_WIDTH;
          var containerHeight = Math.max(element.clientHeight ? element.clientHeight : imageHeight, Constants.FILE_SCAN_MIN_HEIGHT);
          var config = _this.computeCanvasDrawConfig(imageWidth, imageHeight, containerWidth, containerHeight);
          if (showImage) {
            var visibleCanvas = _this.createCanvasElement(containerWidth, containerHeight, "qr-canvas-visible");
            visibleCanvas.style.display = "inline-block";
            element.appendChild(visibleCanvas);
            var context_1 = visibleCanvas.getContext("2d");
            if (!context_1) {
              throw "Unable to get 2d context from canvas";
            }
            context_1.canvas.width = containerWidth;
            context_1.canvas.height = containerHeight;
            context_1.drawImage(inputImage, 0, 0, imageWidth, imageHeight, config.x, config.y, config.width, config.height);
          }
          var padding = Constants.FILE_SCAN_HIDDEN_CANVAS_PADDING;
          var hiddenImageWidth = Math.max(inputImage.width, config.width);
          var hiddenImageHeight = Math.max(inputImage.height, config.height);
          var hiddenCanvasWidth = hiddenImageWidth + 2 * padding;
          var hiddenCanvasHeight = hiddenImageHeight + 2 * padding;
          var hiddenCanvas = _this.createCanvasElement(hiddenCanvasWidth, hiddenCanvasHeight);
          element.appendChild(hiddenCanvas);
          var context = hiddenCanvas.getContext("2d");
          if (!context) {
            throw "Unable to get 2d context from canvas";
          }
          context.canvas.width = hiddenCanvasWidth;
          context.canvas.height = hiddenCanvasHeight;
          context.drawImage(inputImage, 0, 0, imageWidth, imageHeight, padding, padding, hiddenImageWidth, hiddenImageHeight);
          try {
            _this.qrcode.decodeRobustlyAsync(hiddenCanvas).then(function(result) {
              resolve(Html5QrcodeResultFactory.createFromQrcodeResult(result));
            }).catch(reject);
          } catch (exception) {
            reject("QR code parse error, error = ".concat(exception));
          }
        };
        inputImage.onerror = reject;
        inputImage.onabort = reject;
        inputImage.onstalled = reject;
        inputImage.onsuspend = reject;
        inputImage.src = URL.createObjectURL(imageFile);
      });
    };
    Html5Qrcode2.prototype.clear = function() {
      this.clearElement();
    };
    Html5Qrcode2.getCameras = function() {
      return CameraRetriever.retrieve();
    };
    Html5Qrcode2.prototype.getRunningTrackCapabilities = function() {
      return this.getRenderedCameraOrFail().getRunningTrackCapabilities();
    };
    Html5Qrcode2.prototype.getRunningTrackSettings = function() {
      return this.getRenderedCameraOrFail().getRunningTrackSettings();
    };
    Html5Qrcode2.prototype.getRunningTrackCameraCapabilities = function() {
      return this.getRenderedCameraOrFail().getCapabilities();
    };
    Html5Qrcode2.prototype.applyVideoConstraints = function(videoConstaints) {
      if (!videoConstaints) {
        throw "videoConstaints is required argument.";
      } else if (!VideoConstraintsUtil.isMediaStreamConstraintsValid(videoConstaints, this.logger)) {
        throw "invalid videoConstaints passed, check logs for more details";
      }
      return this.getRenderedCameraOrFail().applyVideoConstraints(videoConstaints);
    };
    Html5Qrcode2.prototype.getRenderedCameraOrFail = function() {
      if (this.renderedCamera == null) {
        throw "Scanning is not in running state, call this API only when QR code scanning using camera is in running state.";
      }
      return this.renderedCamera;
    };
    Html5Qrcode2.prototype.getSupportedFormats = function(configOrVerbosityFlag) {
      var allFormats = [
        Html5QrcodeSupportedFormats.QR_CODE,
        Html5QrcodeSupportedFormats.AZTEC,
        Html5QrcodeSupportedFormats.CODABAR,
        Html5QrcodeSupportedFormats.CODE_39,
        Html5QrcodeSupportedFormats.CODE_93,
        Html5QrcodeSupportedFormats.CODE_128,
        Html5QrcodeSupportedFormats.DATA_MATRIX,
        Html5QrcodeSupportedFormats.MAXICODE,
        Html5QrcodeSupportedFormats.ITF,
        Html5QrcodeSupportedFormats.EAN_13,
        Html5QrcodeSupportedFormats.EAN_8,
        Html5QrcodeSupportedFormats.PDF_417,
        Html5QrcodeSupportedFormats.RSS_14,
        Html5QrcodeSupportedFormats.RSS_EXPANDED,
        Html5QrcodeSupportedFormats.UPC_A,
        Html5QrcodeSupportedFormats.UPC_E,
        Html5QrcodeSupportedFormats.UPC_EAN_EXTENSION
      ];
      if (!configOrVerbosityFlag || typeof configOrVerbosityFlag == "boolean") {
        return allFormats;
      }
      if (!configOrVerbosityFlag.formatsToSupport) {
        return allFormats;
      }
      if (!Array.isArray(configOrVerbosityFlag.formatsToSupport)) {
        throw "configOrVerbosityFlag.formatsToSupport should be undefined or an array.";
      }
      if (configOrVerbosityFlag.formatsToSupport.length === 0) {
        throw "Atleast 1 formatsToSupport is needed.";
      }
      var supportedFormats = [];
      for (var _i = 0, _a = configOrVerbosityFlag.formatsToSupport; _i < _a.length; _i++) {
        var format = _a[_i];
        if (isValidHtml5QrcodeSupportedFormats(format)) {
          supportedFormats.push(format);
        } else {
          this.logger.warn("Invalid format: ".concat(format, " passed in config, ignoring."));
        }
      }
      if (supportedFormats.length === 0) {
        throw "None of formatsToSupport match supported values.";
      }
      return supportedFormats;
    };
    Html5Qrcode2.prototype.getUseBarCodeDetectorIfSupported = function(config) {
      if (isNullOrUndefined(config)) {
        return true;
      }
      if (!isNullOrUndefined(config.useBarCodeDetectorIfSupported)) {
        return config.useBarCodeDetectorIfSupported !== false;
      }
      if (isNullOrUndefined(config.experimentalFeatures)) {
        return true;
      }
      var experimentalFeatures = config.experimentalFeatures;
      if (isNullOrUndefined(experimentalFeatures.useBarCodeDetectorIfSupported)) {
        return true;
      }
      return experimentalFeatures.useBarCodeDetectorIfSupported !== false;
    };
    Html5Qrcode2.prototype.validateQrboxSize = function(viewfinderWidth, viewfinderHeight, internalConfig) {
      var _this = this;
      var qrboxSize = internalConfig.qrbox;
      this.validateQrboxConfig(qrboxSize);
      var qrDimensions = this.toQrdimensions(viewfinderWidth, viewfinderHeight, qrboxSize);
      var validateMinSize = function(size2) {
        if (size2 < Constants.MIN_QR_BOX_SIZE) {
          throw "minimum size of 'config.qrbox' dimension value is" + " ".concat(Constants.MIN_QR_BOX_SIZE, "px.");
        }
      };
      var correctWidthBasedOnRootElementSize = function(configWidth) {
        if (configWidth > viewfinderWidth) {
          _this.logger.warn("`qrbox.width` or `qrbox` is larger than the width of the root element. The width will be truncated to the width of root element.");
          configWidth = viewfinderWidth;
        }
        return configWidth;
      };
      validateMinSize(qrDimensions.width);
      validateMinSize(qrDimensions.height);
      qrDimensions.width = correctWidthBasedOnRootElementSize(qrDimensions.width);
    };
    Html5Qrcode2.prototype.validateQrboxConfig = function(qrboxSize) {
      if (typeof qrboxSize === "number") {
        return;
      }
      if (typeof qrboxSize === "function") {
        return;
      }
      if (qrboxSize.width === void 0 || qrboxSize.height === void 0) {
        throw "Invalid instance of QrDimensions passed for 'config.qrbox'. Both 'width' and 'height' should be set.";
      }
    };
    Html5Qrcode2.prototype.toQrdimensions = function(viewfinderWidth, viewfinderHeight, qrboxSize) {
      if (typeof qrboxSize === "number") {
        return { width: qrboxSize, height: qrboxSize };
      } else if (typeof qrboxSize === "function") {
        try {
          return qrboxSize(viewfinderWidth, viewfinderHeight);
        } catch (error2) {
          throw new Error("qrbox config was passed as a function but it failed with unknown error" + error2);
        }
      }
      return qrboxSize;
    };
    Html5Qrcode2.prototype.setupUi = function(viewfinderWidth, viewfinderHeight, internalConfig) {
      if (internalConfig.isShadedBoxEnabled()) {
        this.validateQrboxSize(viewfinderWidth, viewfinderHeight, internalConfig);
      }
      var qrboxSize = isNullOrUndefined(internalConfig.qrbox) ? { width: viewfinderWidth, height: viewfinderHeight } : internalConfig.qrbox;
      this.validateQrboxConfig(qrboxSize);
      var qrDimensions = this.toQrdimensions(viewfinderWidth, viewfinderHeight, qrboxSize);
      if (qrDimensions.height > viewfinderHeight) {
        this.logger.warn("[Html5Qrcode] config.qrbox has height that isgreater than the height of the video stream. Shading will be ignored");
      }
      var shouldShadingBeApplied = internalConfig.isShadedBoxEnabled() && qrDimensions.height <= viewfinderHeight;
      var defaultQrRegion = {
        x: 0,
        y: 0,
        width: viewfinderWidth,
        height: viewfinderHeight
      };
      var qrRegion = shouldShadingBeApplied ? this.getShadedRegionBounds(viewfinderWidth, viewfinderHeight, qrDimensions) : defaultQrRegion;
      var canvasElement = this.createCanvasElement(qrRegion.width, qrRegion.height);
      var contextAttributes = { willReadFrequently: true };
      var context = canvasElement.getContext("2d", contextAttributes);
      context.canvas.width = qrRegion.width;
      context.canvas.height = qrRegion.height;
      this.element.append(canvasElement);
      if (shouldShadingBeApplied) {
        this.possiblyInsertShadingElement(this.element, viewfinderWidth, viewfinderHeight, qrDimensions);
      }
      this.createScannerPausedUiElement(this.element);
      this.qrRegion = qrRegion;
      this.context = context;
      this.canvasElement = canvasElement;
    };
    Html5Qrcode2.prototype.createScannerPausedUiElement = function(rootElement) {
      var scannerPausedUiElement = document.createElement("div");
      scannerPausedUiElement.innerText = Html5QrcodeStrings.scannerPaused();
      scannerPausedUiElement.style.display = "none";
      scannerPausedUiElement.style.position = "absolute";
      scannerPausedUiElement.style.top = "0px";
      scannerPausedUiElement.style.zIndex = "1";
      scannerPausedUiElement.style.background = "rgba(9, 9, 9, 0.46)";
      scannerPausedUiElement.style.color = "#FFECEC";
      scannerPausedUiElement.style.textAlign = "center";
      scannerPausedUiElement.style.width = "100%";
      rootElement.appendChild(scannerPausedUiElement);
      this.scannerPausedUiElement = scannerPausedUiElement;
    };
    Html5Qrcode2.prototype.scanContext = function(qrCodeSuccessCallback, qrCodeErrorCallback) {
      var _this = this;
      if (this.stateManagerProxy.isPaused()) {
        return Promise.resolve(false);
      }
      return this.qrcode.decodeAsync(this.canvasElement).then(function(result) {
        qrCodeSuccessCallback(result.text, Html5QrcodeResultFactory.createFromQrcodeResult(result));
        _this.possiblyUpdateShaders(true);
        return true;
      }).catch(function(error2) {
        _this.possiblyUpdateShaders(false);
        var errorMessage = Html5QrcodeStrings.codeParseError(error2);
        qrCodeErrorCallback(errorMessage, Html5QrcodeErrorFactory.createFrom(errorMessage));
        return false;
      });
    };
    Html5Qrcode2.prototype.foreverScan = function(internalConfig, qrCodeSuccessCallback, qrCodeErrorCallback) {
      var _this = this;
      if (!this.shouldScan) {
        return;
      }
      if (!this.renderedCamera) {
        return;
      }
      var videoElement = this.renderedCamera.getSurface();
      var widthRatio = videoElement.videoWidth / videoElement.clientWidth;
      var heightRatio = videoElement.videoHeight / videoElement.clientHeight;
      if (!this.qrRegion) {
        throw "qrRegion undefined when localMediaStream is ready.";
      }
      var sWidthOffset = this.qrRegion.width * widthRatio;
      var sHeightOffset = this.qrRegion.height * heightRatio;
      var sxOffset = this.qrRegion.x * widthRatio;
      var syOffset = this.qrRegion.y * heightRatio;
      this.context.drawImage(videoElement, sxOffset, syOffset, sWidthOffset, sHeightOffset, 0, 0, this.qrRegion.width, this.qrRegion.height);
      var triggerNextScan = function() {
        _this.foreverScanTimeout = setTimeout(function() {
          _this.foreverScan(internalConfig, qrCodeSuccessCallback, qrCodeErrorCallback);
        }, _this.getTimeoutFps(internalConfig.fps));
      };
      this.scanContext(qrCodeSuccessCallback, qrCodeErrorCallback).then(function(isSuccessfull) {
        if (!isSuccessfull && internalConfig.disableFlip !== true) {
          _this.context.translate(_this.context.canvas.width, 0);
          _this.context.scale(-1, 1);
          _this.scanContext(qrCodeSuccessCallback, qrCodeErrorCallback).finally(function() {
            triggerNextScan();
          });
        } else {
          triggerNextScan();
        }
      }).catch(function(error2) {
        _this.logger.logError("Error happend while scanning context", error2);
        triggerNextScan();
      });
    };
    Html5Qrcode2.prototype.createVideoConstraints = function(cameraIdOrConfig) {
      if (typeof cameraIdOrConfig == "string") {
        return { deviceId: { exact: cameraIdOrConfig } };
      } else if (typeof cameraIdOrConfig == "object") {
        var facingModeKey = "facingMode";
        var deviceIdKey = "deviceId";
        var allowedFacingModeValues_1 = { "user": true, "environment": true };
        var exactKey = "exact";
        var isValidFacingModeValue = function(value) {
          if (value in allowedFacingModeValues_1) {
            return true;
          } else {
            throw "config has invalid 'facingMode' value = " + "'".concat(value, "'");
          }
        };
        var keys = Object.keys(cameraIdOrConfig);
        if (keys.length !== 1) {
          throw "'cameraIdOrConfig' object should have exactly 1 key," + " if passed as an object, found ".concat(keys.length, " keys");
        }
        var key = Object.keys(cameraIdOrConfig)[0];
        if (key !== facingModeKey && key !== deviceIdKey) {
          throw "Only '".concat(facingModeKey, "' and '").concat(deviceIdKey, "' ") + " are supported for 'cameraIdOrConfig'";
        }
        if (key === facingModeKey) {
          var facingMode = cameraIdOrConfig.facingMode;
          if (typeof facingMode == "string") {
            if (isValidFacingModeValue(facingMode)) {
              return { facingMode };
            }
          } else if (typeof facingMode == "object") {
            if (exactKey in facingMode) {
              if (isValidFacingModeValue(facingMode["".concat(exactKey)])) {
                return {
                  facingMode: {
                    exact: facingMode["".concat(exactKey)]
                  }
                };
              }
            } else {
              throw "'facingMode' should be string or object with" + " ".concat(exactKey, " as key.");
            }
          } else {
            var type_1 = typeof facingMode;
            throw "Invalid type of 'facingMode' = ".concat(type_1);
          }
        } else {
          var deviceId = cameraIdOrConfig.deviceId;
          if (typeof deviceId == "string") {
            return { deviceId };
          } else if (typeof deviceId == "object") {
            if (exactKey in deviceId) {
              return {
                deviceId: { exact: deviceId["".concat(exactKey)] }
              };
            } else {
              throw "'deviceId' should be string or object with" + " ".concat(exactKey, " as key.");
            }
          } else {
            var type_2 = typeof deviceId;
            throw "Invalid type of 'deviceId' = ".concat(type_2);
          }
        }
      }
      var type = typeof cameraIdOrConfig;
      throw "Invalid type of 'cameraIdOrConfig' = ".concat(type);
    };
    Html5Qrcode2.prototype.computeCanvasDrawConfig = function(imageWidth, imageHeight, containerWidth, containerHeight) {
      if (imageWidth <= containerWidth && imageHeight <= containerHeight) {
        var xoffset = (containerWidth - imageWidth) / 2;
        var yoffset = (containerHeight - imageHeight) / 2;
        return {
          x: xoffset,
          y: yoffset,
          width: imageWidth,
          height: imageHeight
        };
      } else {
        var formerImageWidth = imageWidth;
        var formerImageHeight = imageHeight;
        if (imageWidth > containerWidth) {
          imageHeight = containerWidth / imageWidth * imageHeight;
          imageWidth = containerWidth;
        }
        if (imageHeight > containerHeight) {
          imageWidth = containerHeight / imageHeight * imageWidth;
          imageHeight = containerHeight;
        }
        this.logger.log("Image downsampled from " + "".concat(formerImageWidth, "X").concat(formerImageHeight) + " to ".concat(imageWidth, "X").concat(imageHeight, "."));
        return this.computeCanvasDrawConfig(imageWidth, imageHeight, containerWidth, containerHeight);
      }
    };
    Html5Qrcode2.prototype.clearElement = function() {
      if (this.stateManagerProxy.isScanning()) {
        throw "Cannot clear while scan is ongoing, close it first.";
      }
      var element = document.getElementById(this.elementId);
      if (element) {
        element.innerHTML = "";
      }
    };
    Html5Qrcode2.prototype.possiblyUpdateShaders = function(qrMatch) {
      if (this.qrMatch === qrMatch) {
        return;
      }
      if (this.hasBorderShaders && this.borderShaders && this.borderShaders.length) {
        this.borderShaders.forEach(function(shader) {
          shader.style.backgroundColor = qrMatch ? Constants.BORDER_SHADER_MATCH_COLOR : Constants.BORDER_SHADER_DEFAULT_COLOR;
        });
      }
      this.qrMatch = qrMatch;
    };
    Html5Qrcode2.prototype.possiblyCloseLastScanImageFile = function() {
      if (this.lastScanImageFile) {
        URL.revokeObjectURL(this.lastScanImageFile);
        this.lastScanImageFile = null;
      }
    };
    Html5Qrcode2.prototype.createCanvasElement = function(width, height, customId) {
      var canvasWidth = width;
      var canvasHeight = height;
      var canvasElement = document.createElement("canvas");
      canvasElement.style.width = "".concat(canvasWidth, "px");
      canvasElement.style.height = "".concat(canvasHeight, "px");
      canvasElement.style.display = "none";
      canvasElement.id = isNullOrUndefined(customId) ? "qr-canvas" : customId;
      return canvasElement;
    };
    Html5Qrcode2.prototype.getShadedRegionBounds = function(width, height, qrboxSize) {
      if (qrboxSize.width > width || qrboxSize.height > height) {
        throw "'config.qrbox' dimensions should not be greater than the dimensions of the root HTML element.";
      }
      return {
        x: (width - qrboxSize.width) / 2,
        y: (height - qrboxSize.height) / 2,
        width: qrboxSize.width,
        height: qrboxSize.height
      };
    };
    Html5Qrcode2.prototype.possiblyInsertShadingElement = function(element, width, height, qrboxSize) {
      if (width - qrboxSize.width < 1 || height - qrboxSize.height < 1) {
        return;
      }
      var shadingElement = document.createElement("div");
      shadingElement.style.position = "absolute";
      var rightLeftBorderSize = (width - qrboxSize.width) / 2;
      var topBottomBorderSize = (height - qrboxSize.height) / 2;
      shadingElement.style.borderLeft = "".concat(rightLeftBorderSize, "px solid rgba(0, 0, 0, 0.48)");
      shadingElement.style.borderRight = "".concat(rightLeftBorderSize, "px solid rgba(0, 0, 0, 0.48)");
      shadingElement.style.borderTop = "".concat(topBottomBorderSize, "px solid rgba(0, 0, 0, 0.48)");
      shadingElement.style.borderBottom = "".concat(topBottomBorderSize, "px solid rgba(0, 0, 0, 0.48)");
      shadingElement.style.boxSizing = "border-box";
      shadingElement.style.top = "0px";
      shadingElement.style.bottom = "0px";
      shadingElement.style.left = "0px";
      shadingElement.style.right = "0px";
      shadingElement.id = "".concat(Constants.SHADED_REGION_ELEMENT_ID);
      if (width - qrboxSize.width < 11 || height - qrboxSize.height < 11) {
        this.hasBorderShaders = false;
      } else {
        var smallSize = 5;
        var largeSize = 40;
        this.insertShaderBorders(shadingElement, largeSize, smallSize, -smallSize, null, 0, true);
        this.insertShaderBorders(shadingElement, largeSize, smallSize, -smallSize, null, 0, false);
        this.insertShaderBorders(shadingElement, largeSize, smallSize, null, -smallSize, 0, true);
        this.insertShaderBorders(shadingElement, largeSize, smallSize, null, -smallSize, 0, false);
        this.insertShaderBorders(shadingElement, smallSize, largeSize + smallSize, -smallSize, null, -smallSize, true);
        this.insertShaderBorders(shadingElement, smallSize, largeSize + smallSize, null, -smallSize, -smallSize, true);
        this.insertShaderBorders(shadingElement, smallSize, largeSize + smallSize, -smallSize, null, -smallSize, false);
        this.insertShaderBorders(shadingElement, smallSize, largeSize + smallSize, null, -smallSize, -smallSize, false);
        this.hasBorderShaders = true;
      }
      element.append(shadingElement);
    };
    Html5Qrcode2.prototype.insertShaderBorders = function(shaderElem, width, height, top, bottom, side, isLeft) {
      var elem = document.createElement("div");
      elem.style.position = "absolute";
      elem.style.backgroundColor = Constants.BORDER_SHADER_DEFAULT_COLOR;
      elem.style.width = "".concat(width, "px");
      elem.style.height = "".concat(height, "px");
      if (top !== null) {
        elem.style.top = "".concat(top, "px");
      }
      if (bottom !== null) {
        elem.style.bottom = "".concat(bottom, "px");
      }
      if (isLeft) {
        elem.style.left = "".concat(side, "px");
      } else {
        elem.style.right = "".concat(side, "px");
      }
      if (!this.borderShaders) {
        this.borderShaders = [];
      }
      this.borderShaders.push(elem);
      shaderElem.appendChild(elem);
    };
    Html5Qrcode2.prototype.showPausedState = function() {
      if (!this.scannerPausedUiElement) {
        throw "[internal error] scanner paused UI element not found";
      }
      this.scannerPausedUiElement.style.display = "block";
    };
    Html5Qrcode2.prototype.hidePausedState = function() {
      if (!this.scannerPausedUiElement) {
        throw "[internal error] scanner paused UI element not found";
      }
      this.scannerPausedUiElement.style.display = "none";
    };
    Html5Qrcode2.prototype.getTimeoutFps = function(fps) {
      return 1e3 / fps;
    };
    return Html5Qrcode2;
  }();

  // node_modules/html5-qrcode/esm/image-assets.js
  var SVG_XML_PREFIX = "data:image/svg+xml;base64,";
  var ASSET_CAMERA_SCAN = SVG_XML_PREFIX + "PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAzNzEuNjQzIDM3MS42NDMiIHN0eWxlPSJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDM3MS42NDMgMzcxLjY0MyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+PHBhdGggZD0iTTEwNS4wODQgMzguMjcxaDE2My43Njh2MjBIMTA1LjA4NHoiLz48cGF0aCBkPSJNMzExLjU5NiAxOTAuMTg5Yy03LjQ0MS05LjM0Ny0xOC40MDMtMTYuMjA2LTMyLjc0My0yMC41MjJWMzBjMC0xNi41NDItMTMuNDU4LTMwLTMwLTMwSDEyNS4wODRjLTE2LjU0MiAwLTMwIDEzLjQ1OC0zMCAzMHYxMjAuMTQzaC04LjI5NmMtMTYuNTQyIDAtMzAgMTMuNDU4LTMwIDMwdjEuMzMzYTI5LjgwNCAyOS44MDQgMCAwIDAgNC42MDMgMTUuOTM5Yy03LjM0IDUuNDc0LTEyLjEwMyAxNC4yMjEtMTIuMTAzIDI0LjA2MXYxLjMzM2MwIDkuODQgNC43NjMgMTguNTg3IDEyLjEwMyAyNC4wNjJhMjkuODEgMjkuODEgMCAwIDAtNC42MDMgMTUuOTM4djEuMzMzYzAgMTYuNTQyIDEzLjQ1OCAzMCAzMCAzMGg4LjMyNGMuNDI3IDExLjYzMSA3LjUwMyAyMS41ODcgMTcuNTM0IDI2LjE3Ny45MzEgMTAuNTAzIDQuMDg0IDMwLjE4NyAxNC43NjggNDUuNTM3YTkuOTg4IDkuOTg4IDAgMCAwIDguMjE2IDQuMjg4IDkuOTU4IDkuOTU4IDAgMCAwIDUuNzA0LTEuNzkzYzQuNTMzLTMuMTU1IDUuNjUtOS4zODggMi40OTUtMTMuOTIxLTYuNzk4LTkuNzY3LTkuNjAyLTIyLjYwOC0xMC43Ni0zMS40aDgyLjY4NWMuMjcyLjQxNC41NDUuODE4LjgxNSAxLjIxIDMuMTQyIDQuNTQxIDkuMzcyIDUuNjc5IDEzLjkxMyAyLjUzNCA0LjU0Mi0zLjE0MiA1LjY3Ny05LjM3MSAyLjUzNS0xMy45MTMtMTEuOTE5LTE3LjIyOS04Ljc4Ny0zNS44ODQgOS41ODEtNTcuMDEyIDMuMDY3LTIuNjUyIDEyLjMwNy0xMS43MzIgMTEuMjE3LTI0LjAzMy0uODI4LTkuMzQzLTcuMTA5LTE3LjE5NC0xOC42NjktMjMuMzM3YTkuODU3IDkuODU3IDAgMCAwLTEuMDYxLS40ODZjLS40NjYtLjE4Mi0xMS40MDMtNC41NzktOS43NDEtMTUuNzA2IDEuMDA3LTYuNzM3IDE0Ljc2OC04LjI3MyAyMy43NjYtNy42NjYgMjMuMTU2IDEuNTY5IDM5LjY5OCA3LjgwMyA0Ny44MzYgMTguMDI2IDUuNzUyIDcuMjI1IDcuNjA3IDE2LjYyMyA1LjY3MyAyOC43MzMtLjQxMyAyLjU4NS0uODI0IDUuMjQxLTEuMjQ1IDcuOTU5LTUuNzU2IDM3LjE5NC0xMi45MTkgODMuNDgzLTQ5Ljg3IDExNC42NjEtNC4yMjEgMy41NjEtNC43NTYgOS44Ny0xLjE5NCAxNC4wOTJhOS45OCA5Ljk4IDAgMCAwIDcuNjQ4IDMuNTUxIDkuOTU1IDkuOTU1IDAgMCAwIDYuNDQ0LTIuMzU4YzQyLjY3Mi0zNi4wMDUgNTAuODAyLTg4LjUzMyA1Ni43MzctMTI2Ljg4OC40MTUtMi42ODQuODIxLTUuMzA5IDEuMjI5LTcuODYzIDIuODM0LTE3LjcyMS0uNDU1LTMyLjY0MS05Ljc3Mi00NC4zNDV6bS0yMzIuMzA4IDQyLjYyYy01LjUxNCAwLTEwLTQuNDg2LTEwLTEwdi0xLjMzM2MwLTUuNTE0IDQuNDg2LTEwIDEwLTEwaDE1djIxLjMzM2gtMTV6bS0yLjUtNTIuNjY2YzAtNS41MTQgNC40ODYtMTAgMTAtMTBoNy41djIxLjMzM2gtNy41Yy01LjUxNCAwLTEwLTQuNDg2LTEwLTEwdi0xLjMzM3ptMTcuNSA5My45OTloLTcuNWMtNS41MTQgMC0xMC00LjQ4Ni0xMC0xMHYtMS4zMzNjMC01LjUxNCA0LjQ4Ni0xMCAxMC0xMGg3LjV2MjEuMzMzem0zMC43OTYgMjguODg3Yy01LjUxNCAwLTEwLTQuNDg2LTEwLTEwdi04LjI3MWg5MS40NTdjLS44NTEgNi42NjgtLjQzNyAxMi43ODcuNzMxIDE4LjI3MWgtODIuMTg4em03OS40ODItMTEzLjY5OGMtMy4xMjQgMjAuOTA2IDEyLjQyNyAzMy4xODQgMjEuNjI1IDM3LjA0IDUuNDQxIDIuOTY4IDcuNTUxIDUuNjQ3IDcuNzAxIDcuMTg4LjIxIDIuMTUtMi41NTMgNS42ODQtNC40NzcgNy4yNTEtLjQ4Mi4zNzgtLjkyOS44LTEuMzM1IDEuMjYxLTYuOTg3IDcuOTM2LTExLjk4MiAxNS41Mi0xNS40MzIgMjIuNjg4aC05Ny41NjRWMzBjMC01LjUxNCA0LjQ4Ni0xMCAxMC0xMGgxMjMuNzY5YzUuNTE0IDAgMTAgNC40ODYgMTAgMTB2MTM1LjU3OWMtMy4wMzItLjM4MS02LjE1LS42OTQtOS4zODktLjkxNC0yNS4xNTktMS42OTQtNDIuMzcgNy43NDgtNDQuODk4IDI0LjY2NnoiLz48cGF0aCBkPSJNMTc5LjEyOSA4My4xNjdoLTI0LjA2YTUgNSAwIDAgMC01IDV2MjQuMDYxYTUgNSAwIDAgMCA1IDVoMjQuMDZhNSA1IDAgMCAwIDUtNVY4OC4xNjdhNSA1IDAgMCAwLTUtNXpNMTcyLjYyOSAxNDIuODZoLTEyLjU2VjEzMC44YTUgNSAwIDEgMC0xMCAwdjE3LjA2MWE1IDUgMCAwIDAgNSA1aDE3LjU2YTUgNSAwIDEgMCAwLTEwLjAwMXpNMjE2LjU2OCA4My4xNjdoLTI0LjA2YTUgNSAwIDAgMC01IDV2MjQuMDYxYTUgNSAwIDAgMCA1IDVoMjQuMDZhNSA1IDAgMCAwIDUtNVY4OC4xNjdhNSA1IDAgMCAwLTUtNXptLTUgMjQuMDYxaC0xNC4wNlY5My4xNjdoMTQuMDZ2MTQuMDYxek0yMTEuNjY5IDEyNS45MzZIMTk3LjQxYTUgNSAwIDAgMC01IDV2MTQuMjU3YTUgNSAwIDAgMCA1IDVoMTQuMjU5YTUgNSAwIDAgMCA1LTV2LTE0LjI1N2E1IDUgMCAwIDAtNS01eiIvPjwvc3ZnPg==";
  var ASSET_FILE_SCAN = SVG_XML_PREFIX + "PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1OS4wMTggNTkuMDE4IiBzdHlsZT0iZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCA1OS4wMTggNTkuMDE4IiB4bWw6c3BhY2U9InByZXNlcnZlIj48cGF0aCBkPSJtNTguNzQxIDU0LjgwOS01Ljk2OS02LjI0NGExMC43NCAxMC43NCAwIDAgMCAyLjgyLTcuMjVjMC01Ljk1My00Ljg0My0xMC43OTYtMTAuNzk2LTEwLjc5NlMzNCAzNS4zNjEgMzQgNDEuMzE0IDM4Ljg0MyA1Mi4xMSA0NC43OTYgNTIuMTFjMi40NDEgMCA0LjY4OC0uODI0IDYuNDk5LTIuMTk2bDYuMDAxIDYuMjc3YS45OTguOTk4IDAgMCAwIDEuNDE0LjAzMiAxIDEgMCAwIDAgLjAzMS0xLjQxNHpNMzYgNDEuMzE0YzAtNC44NSAzLjk0Ni04Ljc5NiA4Ljc5Ni04Ljc5NnM4Ljc5NiAzLjk0NiA4Ljc5NiA4Ljc5Ni0zLjk0NiA4Ljc5Ni04Ljc5NiA4Ljc5NlMzNiA0Ni4xNjQgMzYgNDEuMzE0ek0xMC40MzEgMTYuMDg4YzAgMy4wNyAyLjQ5OCA1LjU2OCA1LjU2OSA1LjU2OHM1LjU2OS0yLjQ5OCA1LjU2OS01LjU2OGMwLTMuMDcxLTIuNDk4LTUuNTY5LTUuNTY5LTUuNTY5cy01LjU2OSAyLjQ5OC01LjU2OSA1LjU2OXptOS4xMzggMGMwIDEuOTY4LTEuNjAyIDMuNTY4LTMuNTY5IDMuNTY4cy0zLjU2OS0xLjYwMS0zLjU2OS0zLjU2OCAxLjYwMi0zLjU2OSAzLjU2OS0zLjU2OSAzLjU2OSAxLjYwMSAzLjU2OSAzLjU2OXoiLz48cGF0aCBkPSJtMzAuODgyIDI4Ljk4NyA5LjE4LTEwLjA1NCAxMS4yNjIgMTAuMzIzYTEgMSAwIDAgMCAxLjM1MS0xLjQ3NWwtMTItMTFhMSAxIDAgMCAwLTEuNDE0LjA2M2wtOS43OTQgMTAuNzI3LTQuNzQzLTQuNzQzYTEuMDAzIDEuMDAzIDAgMCAwLTEuMzY4LS4wNDRMNi4zMzkgMzcuNzY4YTEgMSAwIDEgMCAxLjMyMiAxLjUwMWwxNi4zMTMtMTQuMzYyIDcuMzE5IDcuMzE4YS45OTkuOTk5IDAgMSAwIDEuNDE0LTEuNDE0bC0xLjgyNS0xLjgyNHoiLz48cGF0aCBkPSJNMzAgNDYuNTE4SDJ2LTQyaDU0djI4YTEgMSAwIDEgMCAyIDB2LTI5YTEgMSAwIDAgMC0xLTFIMWExIDEgMCAwIDAtMSAxdjQ0YTEgMSAwIDAgMCAxIDFoMjlhMSAxIDAgMSAwIDAtMnoiLz48L3N2Zz4=";
  var ASSET_INFO_ICON_16PX = SVG_XML_PREFIX + "PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA0NjAgNDYwIiBzdHlsZT0iZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCA0NjAgNDYwIiB4bWw6c3BhY2U9InByZXNlcnZlIj48cGF0aCBkPSJNMjMwIDBDMTAyLjk3NSAwIDAgMTAyLjk3NSAwIDIzMHMxMDIuOTc1IDIzMCAyMzAgMjMwIDIzMC0xMDIuOTc0IDIzMC0yMzBTMzU3LjAyNSAwIDIzMCAwem0zOC4zMzMgMzc3LjM2YzAgOC42NzYtNy4wMzQgMTUuNzEtMTUuNzEgMTUuNzFoLTQzLjEwMWMtOC42NzYgMC0xNS43MS03LjAzNC0xNS43MS0xNS43MVYyMDIuNDc3YzAtOC42NzYgNy4wMzMtMTUuNzEgMTUuNzEtMTUuNzFoNDMuMTAxYzguNjc2IDAgMTUuNzEgNy4wMzMgMTUuNzEgMTUuNzFWMzc3LjM2ek0yMzAgMTU3Yy0yMS41MzkgMC0zOS0xNy40NjEtMzktMzlzMTcuNDYxLTM5IDM5LTM5IDM5IDE3LjQ2MSAzOSAzOS0xNy40NjEgMzktMzkgMzl6Ii8+PC9zdmc+";
  var ASSET_CLOSE_ICON_16PX = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAAQgAAAEIBarqQRAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAE1SURBVDiNfdI7S0NBEAXgLya1otFgpbYSbISAgpXYi6CmiH9KCAiChaVga6OiWPgfRDQ+0itaGVNosXtluWwcuMzePfM4M3sq8lbHBubwg1dc4m1E/J/N4ghDPOIsfk/4xiEao5KX0McFljN4C9d4QTPXuY99jP3DsIoDPGM6BY5i5yI5R7O4q+ImFkJY2DCh3cAH2klyB+9J1xUMMAG7eCh1a+Mr+k48b5diXrFVwwLuS+BJ9MfR7+G0FHOHhTHhnXNWS87VDF4pcnfQK4Ep7XScNLmPTZgURNKKYENYWDpzW1BhscS1WHS8CDgURFJQrWcoF3c13KKbgg1BYQfy8xZWEzTTw1QZbAoKu8FqJnktdu5hcVSHmchiILzzuaDQvjBzV2m8yohCE1jHfPx/xhU+y4G/D75ELlRJsSYAAAAASUVORK5CYII=";

  // node_modules/html5-qrcode/esm/storage.js
  var PersistedDataFactory = function() {
    function PersistedDataFactory2() {
    }
    PersistedDataFactory2.createDefault = function() {
      return {
        hasPermission: false,
        lastUsedCameraId: null
      };
    };
    return PersistedDataFactory2;
  }();
  var PersistedDataManager = function() {
    function PersistedDataManager2() {
      this.data = PersistedDataFactory.createDefault();
      var data2 = localStorage.getItem(PersistedDataManager2.LOCAL_STORAGE_KEY);
      if (!data2) {
        this.reset();
      } else {
        this.data = JSON.parse(data2);
      }
    }
    PersistedDataManager2.prototype.hasCameraPermissions = function() {
      return this.data.hasPermission;
    };
    PersistedDataManager2.prototype.getLastUsedCameraId = function() {
      return this.data.lastUsedCameraId;
    };
    PersistedDataManager2.prototype.setHasPermission = function(hasPermission) {
      this.data.hasPermission = hasPermission;
      this.flush();
    };
    PersistedDataManager2.prototype.setLastUsedCameraId = function(lastUsedCameraId) {
      this.data.lastUsedCameraId = lastUsedCameraId;
      this.flush();
    };
    PersistedDataManager2.prototype.resetLastUsedCameraId = function() {
      this.data.lastUsedCameraId = null;
      this.flush();
    };
    PersistedDataManager2.prototype.reset = function() {
      this.data = PersistedDataFactory.createDefault();
      this.flush();
    };
    PersistedDataManager2.prototype.flush = function() {
      localStorage.setItem(PersistedDataManager2.LOCAL_STORAGE_KEY, JSON.stringify(this.data));
    };
    PersistedDataManager2.LOCAL_STORAGE_KEY = "HTML5_QRCODE_DATA";
    return PersistedDataManager2;
  }();

  // node_modules/html5-qrcode/esm/ui.js
  var LibraryInfoDiv = function() {
    function LibraryInfoDiv2() {
      this.infoDiv = document.createElement("div");
    }
    LibraryInfoDiv2.prototype.renderInto = function(parent) {
      this.infoDiv.style.position = "absolute";
      this.infoDiv.style.top = "10px";
      this.infoDiv.style.right = "10px";
      this.infoDiv.style.zIndex = "2";
      this.infoDiv.style.display = "none";
      this.infoDiv.style.padding = "5pt";
      this.infoDiv.style.border = "1px solid #171717";
      this.infoDiv.style.fontSize = "10pt";
      this.infoDiv.style.background = "rgb(0 0 0 / 69%)";
      this.infoDiv.style.borderRadius = "5px";
      this.infoDiv.style.textAlign = "center";
      this.infoDiv.style.fontWeight = "400";
      this.infoDiv.style.color = "white";
      this.infoDiv.innerText = LibraryInfoStrings.poweredBy();
      var projectLink = document.createElement("a");
      projectLink.innerText = "ScanApp";
      projectLink.href = "https://scanapp.org";
      projectLink.target = "new";
      projectLink.style.color = "white";
      this.infoDiv.appendChild(projectLink);
      var breakElemFirst = document.createElement("br");
      var breakElemSecond = document.createElement("br");
      this.infoDiv.appendChild(breakElemFirst);
      this.infoDiv.appendChild(breakElemSecond);
      var reportIssueLink = document.createElement("a");
      reportIssueLink.innerText = LibraryInfoStrings.reportIssues();
      reportIssueLink.href = "https://github.com/mebjas/html5-qrcode/issues";
      reportIssueLink.target = "new";
      reportIssueLink.style.color = "white";
      this.infoDiv.appendChild(reportIssueLink);
      parent.appendChild(this.infoDiv);
    };
    LibraryInfoDiv2.prototype.show = function() {
      this.infoDiv.style.display = "block";
    };
    LibraryInfoDiv2.prototype.hide = function() {
      this.infoDiv.style.display = "none";
    };
    return LibraryInfoDiv2;
  }();
  var LibraryInfoIcon = function() {
    function LibraryInfoIcon2(onTapIn, onTapOut) {
      this.isShowingInfoIcon = true;
      this.onTapIn = onTapIn;
      this.onTapOut = onTapOut;
      this.infoIcon = document.createElement("img");
    }
    LibraryInfoIcon2.prototype.renderInto = function(parent) {
      var _this = this;
      this.infoIcon.alt = "Info icon";
      this.infoIcon.src = ASSET_INFO_ICON_16PX;
      this.infoIcon.style.position = "absolute";
      this.infoIcon.style.top = "4px";
      this.infoIcon.style.right = "4px";
      this.infoIcon.style.opacity = "0.6";
      this.infoIcon.style.cursor = "pointer";
      this.infoIcon.style.zIndex = "2";
      this.infoIcon.style.width = "16px";
      this.infoIcon.style.height = "16px";
      this.infoIcon.onmouseover = function(_) {
        return _this.onHoverIn();
      };
      this.infoIcon.onmouseout = function(_) {
        return _this.onHoverOut();
      };
      this.infoIcon.onclick = function(_) {
        return _this.onClick();
      };
      parent.appendChild(this.infoIcon);
    };
    LibraryInfoIcon2.prototype.onHoverIn = function() {
      if (this.isShowingInfoIcon) {
        this.infoIcon.style.opacity = "1";
      }
    };
    LibraryInfoIcon2.prototype.onHoverOut = function() {
      if (this.isShowingInfoIcon) {
        this.infoIcon.style.opacity = "0.6";
      }
    };
    LibraryInfoIcon2.prototype.onClick = function() {
      if (this.isShowingInfoIcon) {
        this.isShowingInfoIcon = false;
        this.onTapIn();
        this.infoIcon.src = ASSET_CLOSE_ICON_16PX;
        this.infoIcon.style.opacity = "1";
      } else {
        this.isShowingInfoIcon = true;
        this.onTapOut();
        this.infoIcon.src = ASSET_INFO_ICON_16PX;
        this.infoIcon.style.opacity = "0.6";
      }
    };
    return LibraryInfoIcon2;
  }();
  var LibraryInfoContainer = function() {
    function LibraryInfoContainer2() {
      var _this = this;
      this.infoDiv = new LibraryInfoDiv();
      this.infoIcon = new LibraryInfoIcon(function() {
        _this.infoDiv.show();
      }, function() {
        _this.infoDiv.hide();
      });
    }
    LibraryInfoContainer2.prototype.renderInto = function(parent) {
      this.infoDiv.renderInto(parent);
      this.infoIcon.renderInto(parent);
    };
    return LibraryInfoContainer2;
  }();

  // node_modules/html5-qrcode/esm/camera/permissions.js
  var __awaiter6 = function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __generator6 = function(thisArg, body) {
    var _ = { label: 0, sent: function() {
      if (t[0] & 1)
        throw t[1];
      return t[1];
    }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
      return this;
    }), g;
    function verb(n) {
      return function(v) {
        return step([n, v]);
      };
    }
    function step(op) {
      if (f)
        throw new TypeError("Generator is already executing.");
      while (g && (g = 0, op[0] && (_ = 0)), _)
        try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
            return t;
          if (y = 0, t)
            op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _.label++;
              return { value: op[1], done: false };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }
              if (t && _.label < t[2]) {
                _.label = t[2];
                _.ops.push(op);
                break;
              }
              if (t[2])
                _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
      if (op[0] & 5)
        throw op[1];
      return { value: op[0] ? op[1] : void 0, done: true };
    }
  };
  var CameraPermissions = function() {
    function CameraPermissions2() {
    }
    CameraPermissions2.hasPermissions = function() {
      return __awaiter6(this, void 0, void 0, function() {
        var devices, _i, devices_1, device;
        return __generator6(this, function(_a) {
          switch (_a.label) {
            case 0:
              return [4, navigator.mediaDevices.enumerateDevices()];
            case 1:
              devices = _a.sent();
              for (_i = 0, devices_1 = devices; _i < devices_1.length; _i++) {
                device = devices_1[_i];
                if (device.kind === "videoinput" && device.label) {
                  return [2, true];
                }
              }
              return [2, false];
          }
        });
      });
    };
    return CameraPermissions2;
  }();

  // node_modules/html5-qrcode/esm/ui/scanner/scan-type-selector.js
  var ScanTypeSelector = function() {
    function ScanTypeSelector2(supportedScanTypes) {
      this.supportedScanTypes = this.validateAndReturnScanTypes(supportedScanTypes);
    }
    ScanTypeSelector2.prototype.getDefaultScanType = function() {
      return this.supportedScanTypes[0];
    };
    ScanTypeSelector2.prototype.hasMoreThanOneScanType = function() {
      return this.supportedScanTypes.length > 1;
    };
    ScanTypeSelector2.prototype.isCameraScanRequired = function() {
      for (var _i = 0, _a = this.supportedScanTypes; _i < _a.length; _i++) {
        var scanType = _a[_i];
        if (ScanTypeSelector2.isCameraScanType(scanType)) {
          return true;
        }
      }
      return false;
    };
    ScanTypeSelector2.isCameraScanType = function(scanType) {
      return scanType === Html5QrcodeScanType.SCAN_TYPE_CAMERA;
    };
    ScanTypeSelector2.isFileScanType = function(scanType) {
      return scanType === Html5QrcodeScanType.SCAN_TYPE_FILE;
    };
    ScanTypeSelector2.prototype.validateAndReturnScanTypes = function(supportedScanTypes) {
      if (!supportedScanTypes || supportedScanTypes.length === 0) {
        return Html5QrcodeConstants.DEFAULT_SUPPORTED_SCAN_TYPE;
      }
      var maxExpectedValues = Html5QrcodeConstants.DEFAULT_SUPPORTED_SCAN_TYPE.length;
      if (supportedScanTypes.length > maxExpectedValues) {
        throw "Max ".concat(maxExpectedValues, " values expected for ") + "supportedScanTypes";
      }
      for (var _i = 0, supportedScanTypes_1 = supportedScanTypes; _i < supportedScanTypes_1.length; _i++) {
        var scanType = supportedScanTypes_1[_i];
        if (!Html5QrcodeConstants.DEFAULT_SUPPORTED_SCAN_TYPE.includes(scanType)) {
          throw "Unsupported scan type ".concat(scanType);
        }
      }
      return supportedScanTypes;
    };
    return ScanTypeSelector2;
  }();

  // node_modules/html5-qrcode/esm/ui/scanner/base.js
  var PublicUiElementIdAndClasses = function() {
    function PublicUiElementIdAndClasses2() {
    }
    PublicUiElementIdAndClasses2.ALL_ELEMENT_CLASS = "html5-qrcode-element";
    PublicUiElementIdAndClasses2.CAMERA_PERMISSION_BUTTON_ID = "html5-qrcode-button-camera-permission";
    PublicUiElementIdAndClasses2.CAMERA_START_BUTTON_ID = "html5-qrcode-button-camera-start";
    PublicUiElementIdAndClasses2.CAMERA_STOP_BUTTON_ID = "html5-qrcode-button-camera-stop";
    PublicUiElementIdAndClasses2.TORCH_BUTTON_ID = "html5-qrcode-button-torch";
    PublicUiElementIdAndClasses2.CAMERA_SELECTION_SELECT_ID = "html5-qrcode-select-camera";
    PublicUiElementIdAndClasses2.FILE_SELECTION_BUTTON_ID = "html5-qrcode-button-file-selection";
    PublicUiElementIdAndClasses2.ZOOM_SLIDER_ID = "html5-qrcode-input-range-zoom";
    PublicUiElementIdAndClasses2.SCAN_TYPE_CHANGE_ANCHOR_ID = "html5-qrcode-anchor-scan-type-change";
    PublicUiElementIdAndClasses2.TORCH_BUTTON_CLASS_TORCH_ON = "html5-qrcode-button-torch-on";
    PublicUiElementIdAndClasses2.TORCH_BUTTON_CLASS_TORCH_OFF = "html5-qrcode-button-torch-off";
    return PublicUiElementIdAndClasses2;
  }();
  var BaseUiElementFactory = function() {
    function BaseUiElementFactory2() {
    }
    BaseUiElementFactory2.createElement = function(elementType, elementId) {
      var element = document.createElement(elementType);
      element.id = elementId;
      element.classList.add(PublicUiElementIdAndClasses.ALL_ELEMENT_CLASS);
      if (elementType === "button") {
        element.setAttribute("type", "button");
      }
      return element;
    };
    return BaseUiElementFactory2;
  }();

  // node_modules/html5-qrcode/esm/ui/scanner/torch-button.js
  var __awaiter7 = function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __generator7 = function(thisArg, body) {
    var _ = { label: 0, sent: function() {
      if (t[0] & 1)
        throw t[1];
      return t[1];
    }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
      return this;
    }), g;
    function verb(n) {
      return function(v) {
        return step([n, v]);
      };
    }
    function step(op) {
      if (f)
        throw new TypeError("Generator is already executing.");
      while (g && (g = 0, op[0] && (_ = 0)), _)
        try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
            return t;
          if (y = 0, t)
            op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _.label++;
              return { value: op[1], done: false };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }
              if (t && _.label < t[2]) {
                _.label = t[2];
                _.ops.push(op);
                break;
              }
              if (t[2])
                _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
      if (op[0] & 5)
        throw op[1];
      return { value: op[0] ? op[1] : void 0, done: true };
    }
  };
  var TorchController = function() {
    function TorchController2(torchCapability, buttonController, onTorchActionFailureCallback) {
      this.isTorchOn = false;
      this.torchCapability = torchCapability;
      this.buttonController = buttonController;
      this.onTorchActionFailureCallback = onTorchActionFailureCallback;
    }
    TorchController2.prototype.isTorchEnabled = function() {
      return this.isTorchOn;
    };
    TorchController2.prototype.flipState = function() {
      return __awaiter7(this, void 0, void 0, function() {
        var isTorchOnExpected, error_1;
        return __generator7(this, function(_a) {
          switch (_a.label) {
            case 0:
              this.buttonController.disable();
              isTorchOnExpected = !this.isTorchOn;
              _a.label = 1;
            case 1:
              _a.trys.push([1, 3, , 4]);
              return [4, this.torchCapability.apply(isTorchOnExpected)];
            case 2:
              _a.sent();
              this.updateUiBasedOnLatestSettings(this.torchCapability.value(), isTorchOnExpected);
              return [3, 4];
            case 3:
              error_1 = _a.sent();
              this.propagateFailure(isTorchOnExpected, error_1);
              this.buttonController.enable();
              return [3, 4];
            case 4:
              return [2];
          }
        });
      });
    };
    TorchController2.prototype.updateUiBasedOnLatestSettings = function(isTorchOn, isTorchOnExpected) {
      if (isTorchOn === isTorchOnExpected) {
        this.buttonController.setText(isTorchOnExpected ? Html5QrcodeScannerStrings.torchOffButton() : Html5QrcodeScannerStrings.torchOnButton());
        this.isTorchOn = isTorchOnExpected;
      } else {
        this.propagateFailure(isTorchOnExpected);
      }
      this.buttonController.enable();
    };
    TorchController2.prototype.propagateFailure = function(isTorchOnExpected, error2) {
      var errorMessage = isTorchOnExpected ? Html5QrcodeScannerStrings.torchOnFailedMessage() : Html5QrcodeScannerStrings.torchOffFailedMessage();
      if (error2) {
        errorMessage += "; Error = " + error2;
      }
      this.onTorchActionFailureCallback(errorMessage);
    };
    TorchController2.prototype.reset = function() {
      this.isTorchOn = false;
    };
    return TorchController2;
  }();
  var TorchButton = function() {
    function TorchButton2(torchCapability, onTorchActionFailureCallback) {
      this.onTorchActionFailureCallback = onTorchActionFailureCallback;
      this.torchButton = BaseUiElementFactory.createElement("button", PublicUiElementIdAndClasses.TORCH_BUTTON_ID);
      this.torchController = new TorchController(torchCapability, this, onTorchActionFailureCallback);
    }
    TorchButton2.prototype.render = function(parentElement, torchButtonOptions) {
      var _this = this;
      this.torchButton.innerText = Html5QrcodeScannerStrings.torchOnButton();
      this.torchButton.style.display = torchButtonOptions.display;
      this.torchButton.style.marginLeft = torchButtonOptions.marginLeft;
      var $this = this;
      this.torchButton.addEventListener("click", function(_) {
        return __awaiter7(_this, void 0, void 0, function() {
          return __generator7(this, function(_a) {
            switch (_a.label) {
              case 0:
                return [4, $this.torchController.flipState()];
              case 1:
                _a.sent();
                if ($this.torchController.isTorchEnabled()) {
                  $this.torchButton.classList.remove(PublicUiElementIdAndClasses.TORCH_BUTTON_CLASS_TORCH_OFF);
                  $this.torchButton.classList.add(PublicUiElementIdAndClasses.TORCH_BUTTON_CLASS_TORCH_ON);
                } else {
                  $this.torchButton.classList.remove(PublicUiElementIdAndClasses.TORCH_BUTTON_CLASS_TORCH_ON);
                  $this.torchButton.classList.add(PublicUiElementIdAndClasses.TORCH_BUTTON_CLASS_TORCH_OFF);
                }
                return [2];
            }
          });
        });
      });
      parentElement.appendChild(this.torchButton);
    };
    TorchButton2.prototype.updateTorchCapability = function(torchCapability) {
      this.torchController = new TorchController(torchCapability, this, this.onTorchActionFailureCallback);
    };
    TorchButton2.prototype.getTorchButton = function() {
      return this.torchButton;
    };
    TorchButton2.prototype.hide = function() {
      this.torchButton.style.display = "none";
    };
    TorchButton2.prototype.show = function() {
      this.torchButton.style.display = "inline-block";
    };
    TorchButton2.prototype.disable = function() {
      this.torchButton.disabled = true;
    };
    TorchButton2.prototype.enable = function() {
      this.torchButton.disabled = false;
    };
    TorchButton2.prototype.setText = function(text) {
      this.torchButton.innerText = text;
    };
    TorchButton2.prototype.reset = function() {
      this.torchButton.innerText = Html5QrcodeScannerStrings.torchOnButton();
      this.torchController.reset();
    };
    TorchButton2.create = function(parentElement, torchCapability, torchButtonOptions, onTorchActionFailureCallback) {
      var button = new TorchButton2(torchCapability, onTorchActionFailureCallback);
      button.render(parentElement, torchButtonOptions);
      return button;
    };
    return TorchButton2;
  }();

  // node_modules/html5-qrcode/esm/ui/scanner/file-selection-ui.js
  var FileSelectionUi = function() {
    function FileSelectionUi2(parentElement, showOnRender, onFileSelected) {
      this.fileBasedScanRegion = this.createFileBasedScanRegion();
      this.fileBasedScanRegion.style.display = showOnRender ? "block" : "none";
      parentElement.appendChild(this.fileBasedScanRegion);
      var fileScanLabel = document.createElement("label");
      fileScanLabel.setAttribute("for", this.getFileScanInputId());
      fileScanLabel.style.display = "inline-block";
      this.fileBasedScanRegion.appendChild(fileScanLabel);
      this.fileSelectionButton = BaseUiElementFactory.createElement("button", PublicUiElementIdAndClasses.FILE_SELECTION_BUTTON_ID);
      this.setInitialValueToButton();
      this.fileSelectionButton.addEventListener("click", function(_) {
        fileScanLabel.click();
      });
      fileScanLabel.append(this.fileSelectionButton);
      this.fileScanInput = BaseUiElementFactory.createElement("input", this.getFileScanInputId());
      this.fileScanInput.type = "file";
      this.fileScanInput.accept = "image/*";
      this.fileScanInput.style.display = "none";
      fileScanLabel.appendChild(this.fileScanInput);
      var $this = this;
      this.fileScanInput.addEventListener("change", function(e) {
        if (e == null || e.target == null) {
          return;
        }
        var target = e.target;
        if (target.files && target.files.length === 0) {
          return;
        }
        var fileList = target.files;
        var file = fileList[0];
        var fileName = file.name;
        $this.setImageNameToButton(fileName);
        onFileSelected(file);
      });
      var dragAndDropMessage = this.createDragAndDropMessage();
      this.fileBasedScanRegion.appendChild(dragAndDropMessage);
      this.fileBasedScanRegion.addEventListener("dragenter", function(event) {
        $this.fileBasedScanRegion.style.border = $this.fileBasedScanRegionActiveBorder();
        event.stopPropagation();
        event.preventDefault();
      });
      this.fileBasedScanRegion.addEventListener("dragleave", function(event) {
        $this.fileBasedScanRegion.style.border = $this.fileBasedScanRegionDefaultBorder();
        event.stopPropagation();
        event.preventDefault();
      });
      this.fileBasedScanRegion.addEventListener("dragover", function(event) {
        $this.fileBasedScanRegion.style.border = $this.fileBasedScanRegionActiveBorder();
        event.stopPropagation();
        event.preventDefault();
      });
      this.fileBasedScanRegion.addEventListener("drop", function(event) {
        event.stopPropagation();
        event.preventDefault();
        $this.fileBasedScanRegion.style.border = $this.fileBasedScanRegionDefaultBorder();
        var dataTransfer = event.dataTransfer;
        if (dataTransfer) {
          var files = dataTransfer.files;
          if (!files || files.length === 0) {
            return;
          }
          var isAnyFileImage = false;
          for (var i = 0; i < files.length; ++i) {
            var file = files.item(i);
            if (!file) {
              continue;
            }
            var imageType = /image.*/;
            if (!file.type.match(imageType)) {
              continue;
            }
            isAnyFileImage = true;
            var fileName = file.name;
            $this.setImageNameToButton(fileName);
            onFileSelected(file);
            dragAndDropMessage.innerText = Html5QrcodeScannerStrings.dragAndDropMessage();
            break;
          }
          if (!isAnyFileImage) {
            dragAndDropMessage.innerText = Html5QrcodeScannerStrings.dragAndDropMessageOnlyImages();
          }
        }
      });
    }
    FileSelectionUi2.prototype.hide = function() {
      this.fileBasedScanRegion.style.display = "none";
      this.fileScanInput.disabled = true;
    };
    FileSelectionUi2.prototype.show = function() {
      this.fileBasedScanRegion.style.display = "block";
      this.fileScanInput.disabled = false;
    };
    FileSelectionUi2.prototype.isShowing = function() {
      return this.fileBasedScanRegion.style.display === "block";
    };
    FileSelectionUi2.prototype.resetValue = function() {
      this.fileScanInput.value = "";
      this.setInitialValueToButton();
    };
    FileSelectionUi2.prototype.createFileBasedScanRegion = function() {
      var fileBasedScanRegion = document.createElement("div");
      fileBasedScanRegion.style.textAlign = "center";
      fileBasedScanRegion.style.margin = "auto";
      fileBasedScanRegion.style.width = "80%";
      fileBasedScanRegion.style.maxWidth = "600px";
      fileBasedScanRegion.style.border = this.fileBasedScanRegionDefaultBorder();
      fileBasedScanRegion.style.padding = "10px";
      fileBasedScanRegion.style.marginBottom = "10px";
      return fileBasedScanRegion;
    };
    FileSelectionUi2.prototype.fileBasedScanRegionDefaultBorder = function() {
      return "6px dashed #ebebeb";
    };
    FileSelectionUi2.prototype.fileBasedScanRegionActiveBorder = function() {
      return "6px dashed rgb(153 151 151)";
    };
    FileSelectionUi2.prototype.createDragAndDropMessage = function() {
      var dragAndDropMessage = document.createElement("div");
      dragAndDropMessage.innerText = Html5QrcodeScannerStrings.dragAndDropMessage();
      dragAndDropMessage.style.fontWeight = "400";
      return dragAndDropMessage;
    };
    FileSelectionUi2.prototype.setImageNameToButton = function(imageFileName) {
      var MAX_CHARS = 20;
      if (imageFileName.length > MAX_CHARS) {
        var start8Chars = imageFileName.substring(0, 8);
        var length_1 = imageFileName.length;
        var last8Chars = imageFileName.substring(length_1 - 8, length_1);
        imageFileName = "".concat(start8Chars, "....").concat(last8Chars);
      }
      var newText = Html5QrcodeScannerStrings.fileSelectionChooseAnother() + " - " + imageFileName;
      this.fileSelectionButton.innerText = newText;
    };
    FileSelectionUi2.prototype.setInitialValueToButton = function() {
      var initialText = Html5QrcodeScannerStrings.fileSelectionChooseImage() + " - " + Html5QrcodeScannerStrings.fileSelectionNoImageSelected();
      this.fileSelectionButton.innerText = initialText;
    };
    FileSelectionUi2.prototype.getFileScanInputId = function() {
      return "html5-qrcode-private-filescan-input";
    };
    FileSelectionUi2.create = function(parentElement, showOnRender, onFileSelected) {
      var button = new FileSelectionUi2(parentElement, showOnRender, onFileSelected);
      return button;
    };
    return FileSelectionUi2;
  }();

  // node_modules/html5-qrcode/esm/ui/scanner/camera-selection-ui.js
  var CameraSelectionUi = function() {
    function CameraSelectionUi2(cameras) {
      this.selectElement = BaseUiElementFactory.createElement("select", PublicUiElementIdAndClasses.CAMERA_SELECTION_SELECT_ID);
      this.cameras = cameras;
      this.options = [];
    }
    CameraSelectionUi2.prototype.render = function(parentElement) {
      var cameraSelectionContainer = document.createElement("span");
      cameraSelectionContainer.style.marginRight = "10px";
      var numCameras = this.cameras.length;
      if (numCameras === 0) {
        throw new Error("No cameras found");
      }
      if (numCameras === 1) {
        cameraSelectionContainer.style.display = "none";
      } else {
        var selectCameraString = Html5QrcodeScannerStrings.selectCamera();
        cameraSelectionContainer.innerText = "".concat(selectCameraString, " (").concat(this.cameras.length, ")  ");
      }
      var anonymousCameraId = 1;
      for (var _i = 0, _a = this.cameras; _i < _a.length; _i++) {
        var camera = _a[_i];
        var value = camera.id;
        var name_1 = camera.label == null ? value : camera.label;
        if (!name_1 || name_1 === "") {
          name_1 = [
            Html5QrcodeScannerStrings.anonymousCameraPrefix(),
            anonymousCameraId++
          ].join(" ");
        }
        var option = document.createElement("option");
        option.value = value;
        option.innerText = name_1;
        this.options.push(option);
        this.selectElement.appendChild(option);
      }
      cameraSelectionContainer.appendChild(this.selectElement);
      parentElement.appendChild(cameraSelectionContainer);
    };
    CameraSelectionUi2.prototype.disable = function() {
      this.selectElement.disabled = true;
    };
    CameraSelectionUi2.prototype.isDisabled = function() {
      return this.selectElement.disabled === true;
    };
    CameraSelectionUi2.prototype.enable = function() {
      this.selectElement.disabled = false;
    };
    CameraSelectionUi2.prototype.getValue = function() {
      return this.selectElement.value;
    };
    CameraSelectionUi2.prototype.hasValue = function(value) {
      for (var _i = 0, _a = this.options; _i < _a.length; _i++) {
        var option = _a[_i];
        if (option.value === value) {
          return true;
        }
      }
      return false;
    };
    CameraSelectionUi2.prototype.setValue = function(value) {
      if (!this.hasValue(value)) {
        throw new Error("".concat(value, " is not present in the camera list."));
      }
      this.selectElement.value = value;
    };
    CameraSelectionUi2.prototype.hasSingleItem = function() {
      return this.cameras.length === 1;
    };
    CameraSelectionUi2.prototype.numCameras = function() {
      return this.cameras.length;
    };
    CameraSelectionUi2.create = function(parentElement, cameras) {
      var cameraSelectUi = new CameraSelectionUi2(cameras);
      cameraSelectUi.render(parentElement);
      return cameraSelectUi;
    };
    return CameraSelectionUi2;
  }();

  // node_modules/html5-qrcode/esm/ui/scanner/camera-zoom-ui.js
  var CameraZoomUi = function() {
    function CameraZoomUi2() {
      this.onChangeCallback = null;
      this.zoomElementContainer = document.createElement("div");
      this.rangeInput = BaseUiElementFactory.createElement("input", PublicUiElementIdAndClasses.ZOOM_SLIDER_ID);
      this.rangeInput.type = "range";
      this.rangeText = document.createElement("span");
      this.rangeInput.min = "1";
      this.rangeInput.max = "5";
      this.rangeInput.value = "1";
      this.rangeInput.step = "0.1";
    }
    CameraZoomUi2.prototype.render = function(parentElement, renderOnCreate) {
      this.zoomElementContainer.style.display = renderOnCreate ? "block" : "none";
      this.zoomElementContainer.style.padding = "5px 10px";
      this.zoomElementContainer.style.textAlign = "center";
      parentElement.appendChild(this.zoomElementContainer);
      this.rangeInput.style.display = "inline-block";
      this.rangeInput.style.width = "50%";
      this.rangeInput.style.height = "5px";
      this.rangeInput.style.background = "#d3d3d3";
      this.rangeInput.style.outline = "none";
      this.rangeInput.style.opacity = "0.7";
      var zoomString = Html5QrcodeScannerStrings.zoom();
      this.rangeText.innerText = "".concat(this.rangeInput.value, "x ").concat(zoomString);
      this.rangeText.style.marginRight = "10px";
      var $this = this;
      this.rangeInput.addEventListener("input", function() {
        return $this.onValueChange();
      });
      this.rangeInput.addEventListener("change", function() {
        return $this.onValueChange();
      });
      this.zoomElementContainer.appendChild(this.rangeInput);
      this.zoomElementContainer.appendChild(this.rangeText);
    };
    CameraZoomUi2.prototype.onValueChange = function() {
      var zoomString = Html5QrcodeScannerStrings.zoom();
      this.rangeText.innerText = "".concat(this.rangeInput.value, "x ").concat(zoomString);
      if (this.onChangeCallback) {
        this.onChangeCallback(parseFloat(this.rangeInput.value));
      }
    };
    CameraZoomUi2.prototype.setValues = function(minValue, maxValue, defaultValue, step) {
      this.rangeInput.min = minValue.toString();
      this.rangeInput.max = maxValue.toString();
      this.rangeInput.step = step.toString();
      this.rangeInput.value = defaultValue.toString();
      this.onValueChange();
    };
    CameraZoomUi2.prototype.show = function() {
      this.zoomElementContainer.style.display = "block";
    };
    CameraZoomUi2.prototype.hide = function() {
      this.zoomElementContainer.style.display = "none";
    };
    CameraZoomUi2.prototype.setOnCameraZoomValueChangeCallback = function(onChangeCallback) {
      this.onChangeCallback = onChangeCallback;
    };
    CameraZoomUi2.prototype.removeOnCameraZoomValueChangeCallback = function() {
      this.onChangeCallback = null;
    };
    CameraZoomUi2.create = function(parentElement, renderOnCreate) {
      var cameraZoomUi = new CameraZoomUi2();
      cameraZoomUi.render(parentElement, renderOnCreate);
      return cameraZoomUi;
    };
    return CameraZoomUi2;
  }();

  // node_modules/html5-qrcode/esm/html5-qrcode-scanner.js
  var Html5QrcodeScannerStatus;
  (function(Html5QrcodeScannerStatus2) {
    Html5QrcodeScannerStatus2[Html5QrcodeScannerStatus2["STATUS_DEFAULT"] = 0] = "STATUS_DEFAULT";
    Html5QrcodeScannerStatus2[Html5QrcodeScannerStatus2["STATUS_SUCCESS"] = 1] = "STATUS_SUCCESS";
    Html5QrcodeScannerStatus2[Html5QrcodeScannerStatus2["STATUS_WARNING"] = 2] = "STATUS_WARNING";
    Html5QrcodeScannerStatus2[Html5QrcodeScannerStatus2["STATUS_REQUESTING_PERMISSION"] = 3] = "STATUS_REQUESTING_PERMISSION";
  })(Html5QrcodeScannerStatus || (Html5QrcodeScannerStatus = {}));
  function toHtml5QrcodeCameraScanConfig(config) {
    return {
      fps: config.fps,
      qrbox: config.qrbox,
      aspectRatio: config.aspectRatio,
      disableFlip: config.disableFlip,
      videoConstraints: config.videoConstraints
    };
  }
  function toHtml5QrcodeFullConfig(config, verbose) {
    return {
      formatsToSupport: config.formatsToSupport,
      useBarCodeDetectorIfSupported: config.useBarCodeDetectorIfSupported,
      experimentalFeatures: config.experimentalFeatures,
      verbose
    };
  }
  var Html5QrcodeScanner = function() {
    function Html5QrcodeScanner2(elementId, config, verbose) {
      this.lastMatchFound = null;
      this.cameraScanImage = null;
      this.fileScanImage = null;
      this.fileSelectionUi = null;
      this.elementId = elementId;
      this.config = this.createConfig(config);
      this.verbose = verbose === true;
      if (!document.getElementById(elementId)) {
        throw "HTML Element with id=".concat(elementId, " not found");
      }
      this.scanTypeSelector = new ScanTypeSelector(this.config.supportedScanTypes);
      this.currentScanType = this.scanTypeSelector.getDefaultScanType();
      this.sectionSwapAllowed = true;
      this.logger = new BaseLoggger(this.verbose);
      this.persistedDataManager = new PersistedDataManager();
      if (config.rememberLastUsedCamera !== true) {
        this.persistedDataManager.reset();
      }
    }
    Html5QrcodeScanner2.prototype.render = function(qrCodeSuccessCallback, qrCodeErrorCallback) {
      var _this = this;
      this.lastMatchFound = null;
      this.qrCodeSuccessCallback = function(decodedText, result) {
        if (qrCodeSuccessCallback) {
          qrCodeSuccessCallback(decodedText, result);
        } else {
          if (_this.lastMatchFound === decodedText) {
            return;
          }
          _this.lastMatchFound = decodedText;
          _this.setHeaderMessage(Html5QrcodeScannerStrings.lastMatch(decodedText), Html5QrcodeScannerStatus.STATUS_SUCCESS);
        }
      };
      this.qrCodeErrorCallback = function(errorMessage, error2) {
        if (qrCodeErrorCallback) {
          qrCodeErrorCallback(errorMessage, error2);
        }
      };
      var container = document.getElementById(this.elementId);
      if (!container) {
        throw "HTML Element with id=".concat(this.elementId, " not found");
      }
      container.innerHTML = "";
      this.createBasicLayout(container);
      this.html5Qrcode = new Html5Qrcode(this.getScanRegionId(), toHtml5QrcodeFullConfig(this.config, this.verbose));
    };
    Html5QrcodeScanner2.prototype.pause = function(shouldPauseVideo) {
      if (isNullOrUndefined(shouldPauseVideo) || shouldPauseVideo !== true) {
        shouldPauseVideo = false;
      }
      this.getHtml5QrcodeOrFail().pause(shouldPauseVideo);
    };
    Html5QrcodeScanner2.prototype.resume = function() {
      this.getHtml5QrcodeOrFail().resume();
    };
    Html5QrcodeScanner2.prototype.getState = function() {
      return this.getHtml5QrcodeOrFail().getState();
    };
    Html5QrcodeScanner2.prototype.clear = function() {
      var _this = this;
      var emptyHtmlContainer = function() {
        var mainContainer = document.getElementById(_this.elementId);
        if (mainContainer) {
          mainContainer.innerHTML = "";
          _this.resetBasicLayout(mainContainer);
        }
      };
      if (this.html5Qrcode) {
        return new Promise(function(resolve, reject) {
          if (!_this.html5Qrcode) {
            resolve();
            return;
          }
          if (_this.html5Qrcode.isScanning) {
            _this.html5Qrcode.stop().then(function(_) {
              if (!_this.html5Qrcode) {
                resolve();
                return;
              }
              _this.html5Qrcode.clear();
              emptyHtmlContainer();
              resolve();
            }).catch(function(error2) {
              if (_this.verbose) {
                _this.logger.logError("Unable to stop qrcode scanner", error2);
              }
              reject(error2);
            });
          } else {
            _this.html5Qrcode.clear();
            emptyHtmlContainer();
            resolve();
          }
        });
      }
      return Promise.resolve();
    };
    Html5QrcodeScanner2.prototype.getRunningTrackCapabilities = function() {
      return this.getHtml5QrcodeOrFail().getRunningTrackCapabilities();
    };
    Html5QrcodeScanner2.prototype.getRunningTrackSettings = function() {
      return this.getHtml5QrcodeOrFail().getRunningTrackSettings();
    };
    Html5QrcodeScanner2.prototype.applyVideoConstraints = function(videoConstaints) {
      return this.getHtml5QrcodeOrFail().applyVideoConstraints(videoConstaints);
    };
    Html5QrcodeScanner2.prototype.getHtml5QrcodeOrFail = function() {
      if (!this.html5Qrcode) {
        throw "Code scanner not initialized.";
      }
      return this.html5Qrcode;
    };
    Html5QrcodeScanner2.prototype.createConfig = function(config) {
      if (config) {
        if (!config.fps) {
          config.fps = Html5QrcodeConstants.SCAN_DEFAULT_FPS;
        }
        if (config.rememberLastUsedCamera !== !Html5QrcodeConstants.DEFAULT_REMEMBER_LAST_CAMERA_USED) {
          config.rememberLastUsedCamera = Html5QrcodeConstants.DEFAULT_REMEMBER_LAST_CAMERA_USED;
        }
        if (!config.supportedScanTypes) {
          config.supportedScanTypes = Html5QrcodeConstants.DEFAULT_SUPPORTED_SCAN_TYPE;
        }
        return config;
      }
      return {
        fps: Html5QrcodeConstants.SCAN_DEFAULT_FPS,
        rememberLastUsedCamera: Html5QrcodeConstants.DEFAULT_REMEMBER_LAST_CAMERA_USED,
        supportedScanTypes: Html5QrcodeConstants.DEFAULT_SUPPORTED_SCAN_TYPE
      };
    };
    Html5QrcodeScanner2.prototype.createBasicLayout = function(parent) {
      parent.style.position = "relative";
      parent.style.padding = "0px";
      parent.style.border = "1px solid silver";
      this.createHeader(parent);
      var qrCodeScanRegion = document.createElement("div");
      var scanRegionId = this.getScanRegionId();
      qrCodeScanRegion.id = scanRegionId;
      qrCodeScanRegion.style.width = "100%";
      qrCodeScanRegion.style.minHeight = "100px";
      qrCodeScanRegion.style.textAlign = "center";
      parent.appendChild(qrCodeScanRegion);
      if (ScanTypeSelector.isCameraScanType(this.currentScanType)) {
        this.insertCameraScanImageToScanRegion();
      } else {
        this.insertFileScanImageToScanRegion();
      }
      var qrCodeDashboard = document.createElement("div");
      var dashboardId = this.getDashboardId();
      qrCodeDashboard.id = dashboardId;
      qrCodeDashboard.style.width = "100%";
      parent.appendChild(qrCodeDashboard);
      this.setupInitialDashboard(qrCodeDashboard);
    };
    Html5QrcodeScanner2.prototype.resetBasicLayout = function(mainContainer) {
      mainContainer.style.border = "none";
    };
    Html5QrcodeScanner2.prototype.setupInitialDashboard = function(dashboard) {
      this.createSection(dashboard);
      this.createSectionControlPanel();
      if (this.scanTypeSelector.hasMoreThanOneScanType()) {
        this.createSectionSwap();
      }
    };
    Html5QrcodeScanner2.prototype.createHeader = function(dashboard) {
      var header = document.createElement("div");
      header.style.textAlign = "left";
      header.style.margin = "0px";
      dashboard.appendChild(header);
      var libraryInfo = new LibraryInfoContainer();
      libraryInfo.renderInto(header);
      var headerMessageContainer = document.createElement("div");
      headerMessageContainer.id = this.getHeaderMessageContainerId();
      headerMessageContainer.style.display = "none";
      headerMessageContainer.style.textAlign = "center";
      headerMessageContainer.style.fontSize = "14px";
      headerMessageContainer.style.padding = "2px 10px";
      headerMessageContainer.style.margin = "4px";
      headerMessageContainer.style.borderTop = "1px solid #f6f6f6";
      header.appendChild(headerMessageContainer);
    };
    Html5QrcodeScanner2.prototype.createSection = function(dashboard) {
      var section = document.createElement("div");
      section.id = this.getDashboardSectionId();
      section.style.width = "100%";
      section.style.padding = "10px 0px 10px 0px";
      section.style.textAlign = "left";
      dashboard.appendChild(section);
    };
    Html5QrcodeScanner2.prototype.createCameraListUi = function(scpCameraScanRegion, requestPermissionContainer, requestPermissionButton) {
      var $this = this;
      $this.showHideScanTypeSwapLink(false);
      $this.setHeaderMessage(Html5QrcodeScannerStrings.cameraPermissionRequesting());
      var createPermissionButtonIfNotExists = function() {
        if (!requestPermissionButton) {
          $this.createPermissionButton(scpCameraScanRegion, requestPermissionContainer);
        }
      };
      Html5Qrcode.getCameras().then(function(cameras) {
        $this.persistedDataManager.setHasPermission(true);
        $this.showHideScanTypeSwapLink(true);
        $this.resetHeaderMessage();
        if (cameras && cameras.length > 0) {
          scpCameraScanRegion.removeChild(requestPermissionContainer);
          $this.renderCameraSelection(cameras);
        } else {
          $this.setHeaderMessage(Html5QrcodeScannerStrings.noCameraFound(), Html5QrcodeScannerStatus.STATUS_WARNING);
          createPermissionButtonIfNotExists();
        }
      }).catch(function(error2) {
        $this.persistedDataManager.setHasPermission(false);
        if (requestPermissionButton) {
          requestPermissionButton.disabled = false;
        } else {
          createPermissionButtonIfNotExists();
        }
        $this.setHeaderMessage(error2, Html5QrcodeScannerStatus.STATUS_WARNING);
        $this.showHideScanTypeSwapLink(true);
      });
    };
    Html5QrcodeScanner2.prototype.createPermissionButton = function(scpCameraScanRegion, requestPermissionContainer) {
      var $this = this;
      var requestPermissionButton = BaseUiElementFactory.createElement("button", this.getCameraPermissionButtonId());
      requestPermissionButton.innerText = Html5QrcodeScannerStrings.cameraPermissionTitle();
      requestPermissionButton.addEventListener("click", function() {
        requestPermissionButton.disabled = true;
        $this.createCameraListUi(scpCameraScanRegion, requestPermissionContainer, requestPermissionButton);
      });
      requestPermissionContainer.appendChild(requestPermissionButton);
    };
    Html5QrcodeScanner2.prototype.createPermissionsUi = function(scpCameraScanRegion, requestPermissionContainer) {
      var $this = this;
      if (ScanTypeSelector.isCameraScanType(this.currentScanType) && this.persistedDataManager.hasCameraPermissions()) {
        CameraPermissions.hasPermissions().then(function(hasPermissions) {
          if (hasPermissions) {
            $this.createCameraListUi(scpCameraScanRegion, requestPermissionContainer);
          } else {
            $this.persistedDataManager.setHasPermission(false);
            $this.createPermissionButton(scpCameraScanRegion, requestPermissionContainer);
          }
        }).catch(function(_) {
          $this.persistedDataManager.setHasPermission(false);
          $this.createPermissionButton(scpCameraScanRegion, requestPermissionContainer);
        });
        return;
      }
      this.createPermissionButton(scpCameraScanRegion, requestPermissionContainer);
    };
    Html5QrcodeScanner2.prototype.createSectionControlPanel = function() {
      var section = document.getElementById(this.getDashboardSectionId());
      var sectionControlPanel = document.createElement("div");
      section.appendChild(sectionControlPanel);
      var scpCameraScanRegion = document.createElement("div");
      scpCameraScanRegion.id = this.getDashboardSectionCameraScanRegionId();
      scpCameraScanRegion.style.display = ScanTypeSelector.isCameraScanType(this.currentScanType) ? "block" : "none";
      sectionControlPanel.appendChild(scpCameraScanRegion);
      var requestPermissionContainer = document.createElement("div");
      requestPermissionContainer.style.textAlign = "center";
      scpCameraScanRegion.appendChild(requestPermissionContainer);
      if (this.scanTypeSelector.isCameraScanRequired()) {
        this.createPermissionsUi(scpCameraScanRegion, requestPermissionContainer);
      }
      this.renderFileScanUi(sectionControlPanel);
    };
    Html5QrcodeScanner2.prototype.renderFileScanUi = function(parent) {
      var showOnRender = ScanTypeSelector.isFileScanType(this.currentScanType);
      var $this = this;
      var onFileSelected = function(file) {
        if (!$this.html5Qrcode) {
          throw "html5Qrcode not defined";
        }
        if (!ScanTypeSelector.isFileScanType($this.currentScanType)) {
          return;
        }
        $this.setHeaderMessage(Html5QrcodeScannerStrings.loadingImage());
        $this.html5Qrcode.scanFileV2(file, true).then(function(html5qrcodeResult) {
          $this.resetHeaderMessage();
          $this.qrCodeSuccessCallback(html5qrcodeResult.decodedText, html5qrcodeResult);
        }).catch(function(error2) {
          $this.setHeaderMessage(error2, Html5QrcodeScannerStatus.STATUS_WARNING);
          $this.qrCodeErrorCallback(error2, Html5QrcodeErrorFactory.createFrom(error2));
        });
      };
      this.fileSelectionUi = FileSelectionUi.create(parent, showOnRender, onFileSelected);
    };
    Html5QrcodeScanner2.prototype.renderCameraSelection = function(cameras) {
      var _this = this;
      var $this = this;
      var scpCameraScanRegion = document.getElementById(this.getDashboardSectionCameraScanRegionId());
      scpCameraScanRegion.style.textAlign = "center";
      var cameraZoomUi = CameraZoomUi.create(scpCameraScanRegion, false);
      var renderCameraZoomUiIfSupported = function(cameraCapabilities) {
        var zoomCapability = cameraCapabilities.zoomFeature();
        if (!zoomCapability.isSupported()) {
          return;
        }
        cameraZoomUi.setOnCameraZoomValueChangeCallback(function(zoomValue) {
          zoomCapability.apply(zoomValue);
        });
        var defaultZoom = 1;
        if (_this.config.defaultZoomValueIfSupported) {
          defaultZoom = _this.config.defaultZoomValueIfSupported;
        }
        defaultZoom = clip(defaultZoom, zoomCapability.min(), zoomCapability.max());
        cameraZoomUi.setValues(zoomCapability.min(), zoomCapability.max(), defaultZoom, zoomCapability.step());
        cameraZoomUi.show();
      };
      var cameraSelectUi = CameraSelectionUi.create(scpCameraScanRegion, cameras);
      var cameraActionContainer = document.createElement("span");
      var cameraActionStartButton = BaseUiElementFactory.createElement("button", PublicUiElementIdAndClasses.CAMERA_START_BUTTON_ID);
      cameraActionStartButton.innerText = Html5QrcodeScannerStrings.scanButtonStartScanningText();
      cameraActionContainer.appendChild(cameraActionStartButton);
      var cameraActionStopButton = BaseUiElementFactory.createElement("button", PublicUiElementIdAndClasses.CAMERA_STOP_BUTTON_ID);
      cameraActionStopButton.innerText = Html5QrcodeScannerStrings.scanButtonStopScanningText();
      cameraActionStopButton.style.display = "none";
      cameraActionStopButton.disabled = true;
      cameraActionContainer.appendChild(cameraActionStopButton);
      var torchButton;
      var createAndShowTorchButtonIfSupported = function(cameraCapabilities) {
        if (!cameraCapabilities.torchFeature().isSupported()) {
          if (torchButton) {
            torchButton.hide();
          }
          return;
        }
        if (!torchButton) {
          torchButton = TorchButton.create(cameraActionContainer, cameraCapabilities.torchFeature(), { display: "none", marginLeft: "5px" }, function(errorMessage) {
            $this.setHeaderMessage(errorMessage, Html5QrcodeScannerStatus.STATUS_WARNING);
          });
        } else {
          torchButton.updateTorchCapability(cameraCapabilities.torchFeature());
        }
        torchButton.show();
      };
      scpCameraScanRegion.appendChild(cameraActionContainer);
      var resetCameraActionStartButton = function(shouldShow) {
        if (!shouldShow) {
          cameraActionStartButton.style.display = "none";
        }
        cameraActionStartButton.innerText = Html5QrcodeScannerStrings.scanButtonStartScanningText();
        cameraActionStartButton.style.opacity = "1";
        cameraActionStartButton.disabled = false;
        if (shouldShow) {
          cameraActionStartButton.style.display = "inline-block";
        }
      };
      cameraActionStartButton.addEventListener("click", function(_) {
        cameraActionStartButton.innerText = Html5QrcodeScannerStrings.scanButtonScanningStarting();
        cameraSelectUi.disable();
        cameraActionStartButton.disabled = true;
        cameraActionStartButton.style.opacity = "0.5";
        if (_this.scanTypeSelector.hasMoreThanOneScanType()) {
          $this.showHideScanTypeSwapLink(false);
        }
        $this.resetHeaderMessage();
        var cameraId2 = cameraSelectUi.getValue();
        $this.persistedDataManager.setLastUsedCameraId(cameraId2);
        $this.html5Qrcode.start(cameraId2, toHtml5QrcodeCameraScanConfig($this.config), $this.qrCodeSuccessCallback, $this.qrCodeErrorCallback).then(function(_2) {
          cameraActionStopButton.disabled = false;
          cameraActionStopButton.style.display = "inline-block";
          resetCameraActionStartButton(false);
          var cameraCapabilities = $this.html5Qrcode.getRunningTrackCameraCapabilities();
          if (_this.config.showTorchButtonIfSupported === true) {
            createAndShowTorchButtonIfSupported(cameraCapabilities);
          }
          if (_this.config.showZoomSliderIfSupported === true) {
            renderCameraZoomUiIfSupported(cameraCapabilities);
          }
        }).catch(function(error2) {
          $this.showHideScanTypeSwapLink(true);
          cameraSelectUi.enable();
          resetCameraActionStartButton(true);
          $this.setHeaderMessage(error2, Html5QrcodeScannerStatus.STATUS_WARNING);
        });
      });
      if (cameraSelectUi.hasSingleItem()) {
        cameraActionStartButton.click();
      }
      cameraActionStopButton.addEventListener("click", function(_) {
        if (!$this.html5Qrcode) {
          throw "html5Qrcode not defined";
        }
        cameraActionStopButton.disabled = true;
        $this.html5Qrcode.stop().then(function(_2) {
          if (_this.scanTypeSelector.hasMoreThanOneScanType()) {
            $this.showHideScanTypeSwapLink(true);
          }
          cameraSelectUi.enable();
          cameraActionStartButton.disabled = false;
          cameraActionStopButton.style.display = "none";
          cameraActionStartButton.style.display = "inline-block";
          if (torchButton) {
            torchButton.reset();
            torchButton.hide();
          }
          cameraZoomUi.removeOnCameraZoomValueChangeCallback();
          cameraZoomUi.hide();
          $this.insertCameraScanImageToScanRegion();
        }).catch(function(error2) {
          cameraActionStopButton.disabled = false;
          $this.setHeaderMessage(error2, Html5QrcodeScannerStatus.STATUS_WARNING);
        });
      });
      if ($this.persistedDataManager.getLastUsedCameraId()) {
        var cameraId = $this.persistedDataManager.getLastUsedCameraId();
        if (cameraSelectUi.hasValue(cameraId)) {
          cameraSelectUi.setValue(cameraId);
          cameraActionStartButton.click();
        } else {
          $this.persistedDataManager.resetLastUsedCameraId();
        }
      }
    };
    Html5QrcodeScanner2.prototype.createSectionSwap = function() {
      var $this = this;
      var TEXT_IF_CAMERA_SCAN_SELECTED = Html5QrcodeScannerStrings.textIfCameraScanSelected();
      var TEXT_IF_FILE_SCAN_SELECTED = Html5QrcodeScannerStrings.textIfFileScanSelected();
      var section = document.getElementById(this.getDashboardSectionId());
      var switchContainer = document.createElement("div");
      switchContainer.style.textAlign = "center";
      var switchScanTypeLink = BaseUiElementFactory.createElement("span", this.getDashboardSectionSwapLinkId());
      switchScanTypeLink.style.textDecoration = "underline";
      switchScanTypeLink.style.cursor = "pointer";
      switchScanTypeLink.innerText = ScanTypeSelector.isCameraScanType(this.currentScanType) ? TEXT_IF_CAMERA_SCAN_SELECTED : TEXT_IF_FILE_SCAN_SELECTED;
      switchScanTypeLink.addEventListener("click", function() {
        if (!$this.sectionSwapAllowed) {
          if ($this.verbose) {
            $this.logger.logError("Section swap called when not allowed");
          }
          return;
        }
        $this.resetHeaderMessage();
        $this.fileSelectionUi.resetValue();
        $this.sectionSwapAllowed = false;
        if (ScanTypeSelector.isCameraScanType($this.currentScanType)) {
          $this.clearScanRegion();
          $this.getCameraScanRegion().style.display = "none";
          $this.fileSelectionUi.show();
          switchScanTypeLink.innerText = TEXT_IF_FILE_SCAN_SELECTED;
          $this.currentScanType = Html5QrcodeScanType.SCAN_TYPE_FILE;
          $this.insertFileScanImageToScanRegion();
        } else {
          $this.clearScanRegion();
          $this.getCameraScanRegion().style.display = "block";
          $this.fileSelectionUi.hide();
          switchScanTypeLink.innerText = TEXT_IF_CAMERA_SCAN_SELECTED;
          $this.currentScanType = Html5QrcodeScanType.SCAN_TYPE_CAMERA;
          $this.insertCameraScanImageToScanRegion();
          $this.startCameraScanIfPermissionExistsOnSwap();
        }
        $this.sectionSwapAllowed = true;
      });
      switchContainer.appendChild(switchScanTypeLink);
      section.appendChild(switchContainer);
    };
    Html5QrcodeScanner2.prototype.startCameraScanIfPermissionExistsOnSwap = function() {
      var _this = this;
      var $this = this;
      if (this.persistedDataManager.hasCameraPermissions()) {
        CameraPermissions.hasPermissions().then(function(hasPermissions) {
          if (hasPermissions) {
            var permissionButton = document.getElementById($this.getCameraPermissionButtonId());
            if (!permissionButton) {
              _this.logger.logError("Permission button not found, fail;");
              throw "Permission button not found";
            }
            permissionButton.click();
          } else {
            $this.persistedDataManager.setHasPermission(false);
          }
        }).catch(function(_) {
          $this.persistedDataManager.setHasPermission(false);
        });
        return;
      }
    };
    Html5QrcodeScanner2.prototype.resetHeaderMessage = function() {
      var messageDiv = document.getElementById(this.getHeaderMessageContainerId());
      messageDiv.style.display = "none";
    };
    Html5QrcodeScanner2.prototype.setHeaderMessage = function(messageText, scannerStatus) {
      if (!scannerStatus) {
        scannerStatus = Html5QrcodeScannerStatus.STATUS_DEFAULT;
      }
      var messageDiv = this.getHeaderMessageDiv();
      messageDiv.innerText = messageText;
      messageDiv.style.display = "block";
      switch (scannerStatus) {
        case Html5QrcodeScannerStatus.STATUS_SUCCESS:
          messageDiv.style.background = "rgba(106, 175, 80, 0.26)";
          messageDiv.style.color = "#477735";
          break;
        case Html5QrcodeScannerStatus.STATUS_WARNING:
          messageDiv.style.background = "rgba(203, 36, 49, 0.14)";
          messageDiv.style.color = "#cb2431";
          break;
        case Html5QrcodeScannerStatus.STATUS_DEFAULT:
        default:
          messageDiv.style.background = "rgba(0, 0, 0, 0)";
          messageDiv.style.color = "rgb(17, 17, 17)";
          break;
      }
    };
    Html5QrcodeScanner2.prototype.showHideScanTypeSwapLink = function(shouldDisplay) {
      if (this.scanTypeSelector.hasMoreThanOneScanType()) {
        if (shouldDisplay !== true) {
          shouldDisplay = false;
        }
        this.sectionSwapAllowed = shouldDisplay;
        this.getDashboardSectionSwapLink().style.display = shouldDisplay ? "inline-block" : "none";
      }
    };
    Html5QrcodeScanner2.prototype.insertCameraScanImageToScanRegion = function() {
      var $this = this;
      var qrCodeScanRegion = document.getElementById(this.getScanRegionId());
      if (this.cameraScanImage) {
        qrCodeScanRegion.innerHTML = "<br>";
        qrCodeScanRegion.appendChild(this.cameraScanImage);
        return;
      }
      this.cameraScanImage = new Image();
      this.cameraScanImage.onload = function(_) {
        qrCodeScanRegion.innerHTML = "<br>";
        qrCodeScanRegion.appendChild($this.cameraScanImage);
      };
      this.cameraScanImage.width = 64;
      this.cameraScanImage.style.opacity = "0.8";
      this.cameraScanImage.src = ASSET_CAMERA_SCAN;
      this.cameraScanImage.alt = Html5QrcodeScannerStrings.cameraScanAltText();
    };
    Html5QrcodeScanner2.prototype.insertFileScanImageToScanRegion = function() {
      var $this = this;
      var qrCodeScanRegion = document.getElementById(this.getScanRegionId());
      if (this.fileScanImage) {
        qrCodeScanRegion.innerHTML = "<br>";
        qrCodeScanRegion.appendChild(this.fileScanImage);
        return;
      }
      this.fileScanImage = new Image();
      this.fileScanImage.onload = function(_) {
        qrCodeScanRegion.innerHTML = "<br>";
        qrCodeScanRegion.appendChild($this.fileScanImage);
      };
      this.fileScanImage.width = 64;
      this.fileScanImage.style.opacity = "0.8";
      this.fileScanImage.src = ASSET_FILE_SCAN;
      this.fileScanImage.alt = Html5QrcodeScannerStrings.fileScanAltText();
    };
    Html5QrcodeScanner2.prototype.clearScanRegion = function() {
      var qrCodeScanRegion = document.getElementById(this.getScanRegionId());
      qrCodeScanRegion.innerHTML = "";
    };
    Html5QrcodeScanner2.prototype.getDashboardSectionId = function() {
      return "".concat(this.elementId, "__dashboard_section");
    };
    Html5QrcodeScanner2.prototype.getDashboardSectionCameraScanRegionId = function() {
      return "".concat(this.elementId, "__dashboard_section_csr");
    };
    Html5QrcodeScanner2.prototype.getDashboardSectionSwapLinkId = function() {
      return PublicUiElementIdAndClasses.SCAN_TYPE_CHANGE_ANCHOR_ID;
    };
    Html5QrcodeScanner2.prototype.getScanRegionId = function() {
      return "".concat(this.elementId, "__scan_region");
    };
    Html5QrcodeScanner2.prototype.getDashboardId = function() {
      return "".concat(this.elementId, "__dashboard");
    };
    Html5QrcodeScanner2.prototype.getHeaderMessageContainerId = function() {
      return "".concat(this.elementId, "__header_message");
    };
    Html5QrcodeScanner2.prototype.getCameraPermissionButtonId = function() {
      return PublicUiElementIdAndClasses.CAMERA_PERMISSION_BUTTON_ID;
    };
    Html5QrcodeScanner2.prototype.getCameraScanRegion = function() {
      return document.getElementById(this.getDashboardSectionCameraScanRegionId());
    };
    Html5QrcodeScanner2.prototype.getDashboardSectionSwapLink = function() {
      return document.getElementById(this.getDashboardSectionSwapLinkId());
    };
    Html5QrcodeScanner2.prototype.getHeaderMessageDiv = function() {
      return document.getElementById(this.getHeaderMessageContainerId());
    };
    return Html5QrcodeScanner2;
  }();

  // js/app.js
  window.Alpine = module_default;
  module_default.plugin(module_default2);
  module_default.plugin(timeago_default.configure({
    locale: es_default
  }));
  module_default.start();
  console.log("Alpine");
  console.log("Out Hooks", window.outHooks);
  var Hooks2 = window.outHooks ? window.outHooks : {};
  Hooks2.PhoneNumber = {
    mounted() {
      this.el.addEventListener("input", (e) => {
        this.el.value = this.el.value.replace(/[^\d]+/g, "");
        let match3 = this.el.value.replace(/\D/g, "").match(/^(\d{3})(\d{3})(\d{4})$/);
        if (match3) {
          this.el.value = `${match3[1]}-${match3[2]}-${match3[3]}`;
        }
      });
    }
  };
  Hooks2.ScrollBottom = {
    mounted() {
      console.log(this.el.id);
      const element = document.getElementById(this.el.id);
      element.scrollTop = element.scrollHeight;
    },
    updated() {
      console.log(this.el.id);
      const element = document.getElementById(this.el.id);
      element.scrollTop = element.scrollHeight;
    }
  };
  Hooks2.InfiniteScroll = {
    page() {
      return this.el.dataset.page;
    },
    mounted() {
      this.pending = this.page();
      window.addEventListener("scroll", (e) => {
        if (this.pending == this.page() && scrollAt() > 90) {
          this.pending = this.page() + 1;
          this.pushEvent("load-more", {});
        }
      });
    },
    updated() {
      this.pending = this.page();
    }
  };
  Hooks2.ScanQr = {
    mounted() {
      const _this = this;
      function onScanSuccess(decodedText, decodedResult) {
        _this.pushEvent("readqr", { decodedText, decodedResult }, (reply, ref) => console.log(reply));
      }
      var html5QrcodeScanner = new Html5QrcodeScanner(this.el.id, { fps: 20, qrbox: parseInt(this.el.dataset.width || 400), showTorchButtonIfSupported: true, showZoomSliderIfSupported: true, defaultZoomValueIfSupported: true });
      html5QrcodeScanner.render(onScanSuccess);
    },
    updated() {
      console.log(this.el.id);
    }
  };
  var csrfToken = document.querySelector("meta[name='csrf-token']").getAttribute("content");
  var liveSocket = new LiveSocket("/live", Socket, {
    params: { _csrf_token: csrfToken },
    hooks: Hooks2,
    dom: {
      onBeforeElUpdated(from, to) {
        if (from._x_dataStack) {
          window.Alpine.clone(from, to);
        }
      }
    }
  });
  import_topbar.default.config({ barColors: { 0: "#29d" }, shadowColor: "rgba(0, 0, 0, .3)" });
  window.pageState = {
    start: false,
    start_one: false,
    stop: false,
    stop_one: false
  };
  function change_ps_class(name, value) {
    let e = window.document.getElementsByClassName(name);
    for (let i = 0; i < e.length; i++) {
      const el = e[i];
      if (!value) {
        window.document.getElementById(el.id).classList.remove("opacity-0", "h-0", "w-0", "hidden");
        window.document.getElementById(el.id).classList.add("opacity-100", "h-screen", "w-screen", "inline");
      } else {
        window.document.getElementById(el.id).classList.remove("opacity-100", "h-screen", "w-screen", "inline");
        window.document.getElementById(el.id).classList.add("opacity-0", "h-0", "w-0", "hidden");
      }
    }
  }
  function change_ps(state, value) {
    if (["start_one", "stop_one"].includes(state)) {
      if (window.pageState[state] == false) {
        window.pageState[state] = value;
        change_ps_class("change_ps_class_" + state, value);
      }
    } else {
      window.pageState[state] = value;
      change_ps_class("change_ps_class_" + state, value);
    }
  }
  window.topbarFn = {
    start: (info) => {
      change_ps("start", true);
      change_ps("start_one", true);
      change_ps("stop", false);
      change_ps("stop_one", false);
      import_topbar.default.show();
    },
    stop: (info) => {
      change_ps("start", false);
      change_ps("start_one", false);
      change_ps("stop", true);
      change_ps("stop_one", true);
      import_topbar.default.hide();
    }
  };
  window.addEventListener("phx:page-loading-start", (info) => window.topbarFn.start(info));
  window.addEventListener("phx:page-loading-stop", (info) => window.topbarFn.stop(info));
  liveSocket.connect();
  window.liveSocket = liveSocket;
  window.topbar = import_topbar.default;
  window.change_ps = change_ps;
  init_templet();
  console.log("hi! :D");
})();
/**
 * @license MIT
 * topbar 1.0.0, 2021-01-06
 * https://buunguyen.github.io/topbar
 * Copyright (c) 2021 Buu Nguyen
 */
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vLi4vLi4vLi4vYXNzZXRzL3ZlbmRvci90b3BiYXIuanMiLCAiLi4vLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9odG1sNS1xcmNvZGUvdGhpcmRfcGFydHkvenhpbmctanMudW1kLmpzIiwgIi4uLy4uLy4uLy4uL2RlcHMvcGhvZW5peF9odG1sL3ByaXYvc3RhdGljL3Bob2VuaXhfaHRtbC5qcyIsICIuLi8uLi8uLi8uLi9kZXBzL3Bob2VuaXgvYXNzZXRzL2pzL3Bob2VuaXgvdXRpbHMuanMiLCAiLi4vLi4vLi4vLi4vZGVwcy9waG9lbml4L2Fzc2V0cy9qcy9waG9lbml4L2NvbnN0YW50cy5qcyIsICIuLi8uLi8uLi8uLi9kZXBzL3Bob2VuaXgvYXNzZXRzL2pzL3Bob2VuaXgvcHVzaC5qcyIsICIuLi8uLi8uLi8uLi9kZXBzL3Bob2VuaXgvYXNzZXRzL2pzL3Bob2VuaXgvdGltZXIuanMiLCAiLi4vLi4vLi4vLi4vZGVwcy9waG9lbml4L2Fzc2V0cy9qcy9waG9lbml4L2NoYW5uZWwuanMiLCAiLi4vLi4vLi4vLi4vZGVwcy9waG9lbml4L2Fzc2V0cy9qcy9waG9lbml4L2FqYXguanMiLCAiLi4vLi4vLi4vLi4vZGVwcy9waG9lbml4L2Fzc2V0cy9qcy9waG9lbml4L2xvbmdwb2xsLmpzIiwgIi4uLy4uLy4uLy4uL2RlcHMvcGhvZW5peC9hc3NldHMvanMvcGhvZW5peC9wcmVzZW5jZS5qcyIsICIuLi8uLi8uLi8uLi9kZXBzL3Bob2VuaXgvYXNzZXRzL2pzL3Bob2VuaXgvc2VyaWFsaXplci5qcyIsICIuLi8uLi8uLi8uLi9kZXBzL3Bob2VuaXgvYXNzZXRzL2pzL3Bob2VuaXgvc29ja2V0LmpzIiwgIi4uLy4uLy4uLy4uL2RlcHMvcGhvZW5peF9saXZlX3ZpZXcvYXNzZXRzL2pzL3Bob2VuaXhfbGl2ZV92aWV3L2NvbnN0YW50cy5qcyIsICIuLi8uLi8uLi8uLi9kZXBzL3Bob2VuaXhfbGl2ZV92aWV3L2Fzc2V0cy9qcy9waG9lbml4X2xpdmVfdmlldy9lbnRyeV91cGxvYWRlci5qcyIsICIuLi8uLi8uLi8uLi9kZXBzL3Bob2VuaXhfbGl2ZV92aWV3L2Fzc2V0cy9qcy9waG9lbml4X2xpdmVfdmlldy91dGlscy5qcyIsICIuLi8uLi8uLi8uLi9kZXBzL3Bob2VuaXhfbGl2ZV92aWV3L2Fzc2V0cy9qcy9waG9lbml4X2xpdmVfdmlldy9icm93c2VyLmpzIiwgIi4uLy4uLy4uLy4uL2RlcHMvcGhvZW5peF9saXZlX3ZpZXcvYXNzZXRzL2pzL3Bob2VuaXhfbGl2ZV92aWV3L2RvbS5qcyIsICIuLi8uLi8uLi8uLi9kZXBzL3Bob2VuaXhfbGl2ZV92aWV3L2Fzc2V0cy9qcy9waG9lbml4X2xpdmVfdmlldy91cGxvYWRfZW50cnkuanMiLCAiLi4vLi4vLi4vLi4vZGVwcy9waG9lbml4X2xpdmVfdmlldy9hc3NldHMvanMvcGhvZW5peF9saXZlX3ZpZXcvbGl2ZV91cGxvYWRlci5qcyIsICIuLi8uLi8uLi8uLi9kZXBzL3Bob2VuaXhfbGl2ZV92aWV3L2Fzc2V0cy9qcy9waG9lbml4X2xpdmVfdmlldy9ob29rcy5qcyIsICIuLi8uLi8uLi8uLi9kZXBzL3Bob2VuaXhfbGl2ZV92aWV3L2Fzc2V0cy9qcy9waG9lbml4X2xpdmVfdmlldy9kb21fcG9zdF9tb3JwaF9yZXN0b3Jlci5qcyIsICIuLi8uLi8uLi8uLi9kZXBzL3Bob2VuaXhfbGl2ZV92aWV3L2Fzc2V0cy9ub2RlX21vZHVsZXMvbW9ycGhkb20vZGlzdC9tb3JwaGRvbS1lc20uanMiLCAiLi4vLi4vLi4vLi4vZGVwcy9waG9lbml4X2xpdmVfdmlldy9hc3NldHMvanMvcGhvZW5peF9saXZlX3ZpZXcvZG9tX3BhdGNoLmpzIiwgIi4uLy4uLy4uLy4uL2RlcHMvcGhvZW5peF9saXZlX3ZpZXcvYXNzZXRzL2pzL3Bob2VuaXhfbGl2ZV92aWV3L3JlbmRlcmVkLmpzIiwgIi4uLy4uLy4uLy4uL2RlcHMvcGhvZW5peF9saXZlX3ZpZXcvYXNzZXRzL2pzL3Bob2VuaXhfbGl2ZV92aWV3L3ZpZXdfaG9vay5qcyIsICIuLi8uLi8uLi8uLi9kZXBzL3Bob2VuaXhfbGl2ZV92aWV3L2Fzc2V0cy9qcy9waG9lbml4X2xpdmVfdmlldy9qcy5qcyIsICIuLi8uLi8uLi8uLi9kZXBzL3Bob2VuaXhfbGl2ZV92aWV3L2Fzc2V0cy9qcy9waG9lbml4X2xpdmVfdmlldy92aWV3LmpzIiwgIi4uLy4uLy4uLy4uL2RlcHMvcGhvZW5peF9saXZlX3ZpZXcvYXNzZXRzL2pzL3Bob2VuaXhfbGl2ZV92aWV3L2xpdmVfc29ja2V0LmpzIiwgIi4uLy4uLy4uLy4uL2Fzc2V0cy9qcy9hcHAuanMiLCAiLi4vLi4vLi4vLi4vYXNzZXRzL2pzL3RlbXBsYXRlLmpzIiwgIi4uLy4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvYWxwaW5lanMvZGlzdC9tb2R1bGUuZXNtLmpzIiwgIi4uLy4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvQGFscGluZWpzL3BlcnNpc3QvZGlzdC9tb2R1bGUuZXNtLmpzIiwgIi4uLy4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvZXNtL19saWIvdG9JbnRlZ2VyL2luZGV4LmpzIiwgIi4uLy4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvZXNtL19saWIvcmVxdWlyZWRBcmdzL2luZGV4LmpzIiwgIi4uLy4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvZXNtL3RvRGF0ZS9pbmRleC5qcyIsICIuLi8uLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2VzbS9fbGliL2dldFRpbWV6b25lT2Zmc2V0SW5NaWxsaXNlY29uZHMvaW5kZXguanMiLCAiLi4vLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9kYXRlLWZucy9lc20vY29tcGFyZUFzYy9pbmRleC5qcyIsICIuLi8uLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2VzbS9jb25zdGFudHMvaW5kZXguanMiLCAiLi4vLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9kYXRlLWZucy9lc20vZGlmZmVyZW5jZUluQ2FsZW5kYXJNb250aHMvaW5kZXguanMiLCAiLi4vLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9kYXRlLWZucy9lc20vZGlmZmVyZW5jZUluTWlsbGlzZWNvbmRzL2luZGV4LmpzIiwgIi4uLy4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvZXNtL19saWIvcm91bmRpbmdNZXRob2RzL2luZGV4LmpzIiwgIi4uLy4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvZXNtL2VuZE9mRGF5L2luZGV4LmpzIiwgIi4uLy4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvZXNtL2VuZE9mTW9udGgvaW5kZXguanMiLCAiLi4vLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9kYXRlLWZucy9lc20vaXNMYXN0RGF5T2ZNb250aC9pbmRleC5qcyIsICIuLi8uLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2VzbS9kaWZmZXJlbmNlSW5Nb250aHMvaW5kZXguanMiLCAiLi4vLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9kYXRlLWZucy9lc20vZGlmZmVyZW5jZUluU2Vjb25kcy9pbmRleC5qcyIsICIuLi8uLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2VzbS9sb2NhbGUvZW4tVVMvX2xpYi9mb3JtYXREaXN0YW5jZS9pbmRleC5qcyIsICIuLi8uLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2VzbS9sb2NhbGUvX2xpYi9idWlsZEZvcm1hdExvbmdGbi9pbmRleC5qcyIsICIuLi8uLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2VzbS9sb2NhbGUvZW4tVVMvX2xpYi9mb3JtYXRMb25nL2luZGV4LmpzIiwgIi4uLy4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvZXNtL2xvY2FsZS9lbi1VUy9fbGliL2Zvcm1hdFJlbGF0aXZlL2luZGV4LmpzIiwgIi4uLy4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvZXNtL2xvY2FsZS9fbGliL2J1aWxkTG9jYWxpemVGbi9pbmRleC5qcyIsICIuLi8uLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2VzbS9sb2NhbGUvZW4tVVMvX2xpYi9sb2NhbGl6ZS9pbmRleC5qcyIsICIuLi8uLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2VzbS9sb2NhbGUvX2xpYi9idWlsZE1hdGNoRm4vaW5kZXguanMiLCAiLi4vLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9kYXRlLWZucy9lc20vbG9jYWxlL19saWIvYnVpbGRNYXRjaFBhdHRlcm5Gbi9pbmRleC5qcyIsICIuLi8uLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2VzbS9sb2NhbGUvZW4tVVMvX2xpYi9tYXRjaC9pbmRleC5qcyIsICIuLi8uLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2VzbS9sb2NhbGUvZW4tVVMvaW5kZXguanMiLCAiLi4vLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9kYXRlLWZucy9lc20vX2xpYi9hc3NpZ24vaW5kZXguanMiLCAiLi4vLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9kYXRlLWZucy9lc20vX2xpYi9jbG9uZU9iamVjdC9pbmRleC5qcyIsICIuLi8uLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2VzbS9mb3JtYXREaXN0YW5jZS9pbmRleC5qcyIsICIuLi8uLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2VzbS9mb3JtYXREaXN0YW5jZVRvTm93L2luZGV4LmpzIiwgIi4uLy4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvZXNtL3BhcnNlSVNPL2luZGV4LmpzIiwgIi4uLy4uLy4uLy4uL2Fzc2V0cy9qcy90aW1lYWdvLmpzIiwgIi4uLy4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvZXNtL2xvY2FsZS9lcy9fbGliL2Zvcm1hdERpc3RhbmNlL2luZGV4LmpzIiwgIi4uLy4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvZXNtL2xvY2FsZS9lcy9fbGliL2Zvcm1hdExvbmcvaW5kZXguanMiLCAiLi4vLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9kYXRlLWZucy9lc20vbG9jYWxlL2VzL19saWIvZm9ybWF0UmVsYXRpdmUvaW5kZXguanMiLCAiLi4vLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9kYXRlLWZucy9lc20vbG9jYWxlL2VzL19saWIvbG9jYWxpemUvaW5kZXguanMiLCAiLi4vLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9kYXRlLWZucy9lc20vbG9jYWxlL2VzL19saWIvbWF0Y2gvaW5kZXguanMiLCAiLi4vLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9kYXRlLWZucy9lc20vbG9jYWxlL2VzL2luZGV4LmpzIiwgIi4uLy4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvc3JjL2NvcmUudHMiLCAiLi4vLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9zcmMvc3RyaW5ncy50cyIsICIuLi8uLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL3NyYy91dGlscy50cyIsICIuLi8uLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL3NyYy96eGluZy1odG1sNS1xcmNvZGUtZGVjb2Rlci50cyIsICIuLi8uLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL3NyYy9uYXRpdmUtYmFyLWNvZGUtZGV0ZWN0b3IudHMiLCAiLi4vLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9zcmMvY29kZS1kZWNvZGVyLnRzIiwgIi4uLy4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvc3JjL2NhbWVyYS9jb3JlLWltcGwudHMiLCAiLi4vLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9zcmMvY2FtZXJhL2ZhY3Rvcmllcy50cyIsICIuLi8uLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL3NyYy9jYW1lcmEvcmV0cmlldmVyLnRzIiwgIi4uLy4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvc3JjL3N0YXRlLW1hbmFnZXIudHMiLCAiLi4vLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9zcmMvaHRtbDUtcXJjb2RlLnRzIiwgIi4uLy4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvc3JjL2ltYWdlLWFzc2V0cy50cyIsICIuLi8uLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL3NyYy9zdG9yYWdlLnRzIiwgIi4uLy4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvc3JjL3VpLnRzIiwgIi4uLy4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvc3JjL2NhbWVyYS9wZXJtaXNzaW9ucy50cyIsICIuLi8uLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL3NyYy91aS9zY2FubmVyL3NjYW4tdHlwZS1zZWxlY3Rvci50cyIsICIuLi8uLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL3NyYy91aS9zY2FubmVyL2Jhc2UudHMiLCAiLi4vLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9zcmMvdWkvc2Nhbm5lci90b3JjaC1idXR0b24udHMiLCAiLi4vLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9zcmMvdWkvc2Nhbm5lci9maWxlLXNlbGVjdGlvbi11aS50cyIsICIuLi8uLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL3NyYy91aS9zY2FubmVyL2NhbWVyYS1zZWxlY3Rpb24tdWkudHMiLCAiLi4vLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9zcmMvdWkvc2Nhbm5lci9jYW1lcmEtem9vbS11aS50cyIsICIuLi8uLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL3NyYy9odG1sNS1xcmNvZGUtc2Nhbm5lci50cyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiLyoqXG4gKiBAbGljZW5zZSBNSVRcbiAqIHRvcGJhciAxLjAuMCwgMjAyMS0wMS0wNlxuICogaHR0cHM6Ly9idXVuZ3V5ZW4uZ2l0aHViLmlvL3RvcGJhclxuICogQ29weXJpZ2h0IChjKSAyMDIxIEJ1dSBOZ3V5ZW5cbiAqL1xuKGZ1bmN0aW9uICh3aW5kb3csIGRvY3VtZW50KSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIC8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL3BhdWxpcmlzaC8xNTc5NjcxXG4gIChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGxhc3RUaW1lID0gMDtcbiAgICB2YXIgdmVuZG9ycyA9IFtcIm1zXCIsIFwibW96XCIsIFwid2Via2l0XCIsIFwib1wiXTtcbiAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHZlbmRvcnMubGVuZ3RoICYmICF3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lOyArK3gpIHtcbiAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPVxuICAgICAgICB3aW5kb3dbdmVuZG9yc1t4XSArIFwiUmVxdWVzdEFuaW1hdGlvbkZyYW1lXCJdO1xuICAgICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lID1cbiAgICAgICAgd2luZG93W3ZlbmRvcnNbeF0gKyBcIkNhbmNlbEFuaW1hdGlvbkZyYW1lXCJdIHx8XG4gICAgICAgIHdpbmRvd1t2ZW5kb3JzW3hdICsgXCJDYW5jZWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWVcIl07XG4gICAgfVxuICAgIGlmICghd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSlcbiAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIGVsZW1lbnQpIHtcbiAgICAgICAgdmFyIGN1cnJUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgIHZhciB0aW1lVG9DYWxsID0gTWF0aC5tYXgoMCwgMTYgLSAoY3VyclRpbWUgLSBsYXN0VGltZSkpO1xuICAgICAgICB2YXIgaWQgPSB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgY2FsbGJhY2soY3VyclRpbWUgKyB0aW1lVG9DYWxsKTtcbiAgICAgICAgfSwgdGltZVRvQ2FsbCk7XG4gICAgICAgIGxhc3RUaW1lID0gY3VyclRpbWUgKyB0aW1lVG9DYWxsO1xuICAgICAgICByZXR1cm4gaWQ7XG4gICAgICB9O1xuICAgIGlmICghd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKVxuICAgICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIGNsZWFyVGltZW91dChpZCk7XG4gICAgICB9O1xuICB9KSgpO1xuXG4gIHZhciBjYW52YXMsXG4gICAgcHJvZ3Jlc3NUaW1lcklkLFxuICAgIGZhZGVUaW1lcklkLFxuICAgIGN1cnJlbnRQcm9ncmVzcyxcbiAgICBzaG93aW5nLFxuICAgIGFkZEV2ZW50ID0gZnVuY3Rpb24gKGVsZW0sIHR5cGUsIGhhbmRsZXIpIHtcbiAgICAgIGlmIChlbGVtLmFkZEV2ZW50TGlzdGVuZXIpIGVsZW0uYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyLCBmYWxzZSk7XG4gICAgICBlbHNlIGlmIChlbGVtLmF0dGFjaEV2ZW50KSBlbGVtLmF0dGFjaEV2ZW50KFwib25cIiArIHR5cGUsIGhhbmRsZXIpO1xuICAgICAgZWxzZSBlbGVtW1wib25cIiArIHR5cGVdID0gaGFuZGxlcjtcbiAgICB9LFxuICAgIG9wdGlvbnMgPSB7XG4gICAgICBhdXRvUnVuOiB0cnVlLFxuICAgICAgYmFyVGhpY2tuZXNzOiAzLFxuICAgICAgYmFyQ29sb3JzOiB7XG4gICAgICAgIDA6IFwicmdiYSgyNiwgIDE4OCwgMTU2LCAuOSlcIixcbiAgICAgICAgXCIuMjVcIjogXCJyZ2JhKDUyLCAgMTUyLCAyMTksIC45KVwiLFxuICAgICAgICBcIi41MFwiOiBcInJnYmEoMjQxLCAxOTYsIDE1LCAgLjkpXCIsXG4gICAgICAgIFwiLjc1XCI6IFwicmdiYSgyMzAsIDEyNiwgMzQsICAuOSlcIixcbiAgICAgICAgXCIxLjBcIjogXCJyZ2JhKDIxMSwgODQsICAwLCAgIC45KVwiLFxuICAgICAgfSxcbiAgICAgIHNoYWRvd0JsdXI6IDEwLFxuICAgICAgc2hhZG93Q29sb3I6IFwicmdiYSgwLCAgIDAsICAgMCwgICAuNilcIixcbiAgICAgIGNsYXNzTmFtZTogbnVsbCxcbiAgICB9LFxuICAgIHJlcGFpbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBjYW52YXMud2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICAgIGNhbnZhcy5oZWlnaHQgPSBvcHRpb25zLmJhclRoaWNrbmVzcyAqIDU7IC8vIG5lZWQgc3BhY2UgZm9yIHNoYWRvd1xuXG4gICAgICB2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgIGN0eC5zaGFkb3dCbHVyID0gb3B0aW9ucy5zaGFkb3dCbHVyO1xuICAgICAgY3R4LnNoYWRvd0NvbG9yID0gb3B0aW9ucy5zaGFkb3dDb2xvcjtcblxuICAgICAgdmFyIGxpbmVHcmFkaWVudCA9IGN0eC5jcmVhdGVMaW5lYXJHcmFkaWVudCgwLCAwLCBjYW52YXMud2lkdGgsIDApO1xuICAgICAgZm9yICh2YXIgc3RvcCBpbiBvcHRpb25zLmJhckNvbG9ycylcbiAgICAgICAgbGluZUdyYWRpZW50LmFkZENvbG9yU3RvcChzdG9wLCBvcHRpb25zLmJhckNvbG9yc1tzdG9wXSk7XG4gICAgICBjdHgubGluZVdpZHRoID0gb3B0aW9ucy5iYXJUaGlja25lc3M7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHgubW92ZVRvKDAsIG9wdGlvbnMuYmFyVGhpY2tuZXNzIC8gMik7XG4gICAgICBjdHgubGluZVRvKFxuICAgICAgICBNYXRoLmNlaWwoY3VycmVudFByb2dyZXNzICogY2FudmFzLndpZHRoKSxcbiAgICAgICAgb3B0aW9ucy5iYXJUaGlja25lc3MgLyAyXG4gICAgICApO1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gbGluZUdyYWRpZW50O1xuICAgICAgY3R4LnN0cm9rZSgpO1xuICAgIH0sXG4gICAgY3JlYXRlQ2FudmFzID0gZnVuY3Rpb24gKCkge1xuICAgICAgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICAgIHZhciBzdHlsZSA9IGNhbnZhcy5zdHlsZTtcbiAgICAgIHN0eWxlLnBvc2l0aW9uID0gXCJmaXhlZFwiO1xuICAgICAgc3R5bGUudG9wID0gc3R5bGUubGVmdCA9IHN0eWxlLnJpZ2h0ID0gc3R5bGUubWFyZ2luID0gc3R5bGUucGFkZGluZyA9IDA7XG4gICAgICBzdHlsZS56SW5kZXggPSAxMDAwMDE7XG4gICAgICBzdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgICBpZiAob3B0aW9ucy5jbGFzc05hbWUpIGNhbnZhcy5jbGFzc0xpc3QuYWRkKG9wdGlvbnMuY2xhc3NOYW1lKTtcbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoY2FudmFzKTtcbiAgICAgIGFkZEV2ZW50KHdpbmRvdywgXCJyZXNpemVcIiwgcmVwYWludCk7XG4gICAgfSxcbiAgICB0b3BiYXIgPSB7XG4gICAgICBjb25maWc6IGZ1bmN0aW9uIChvcHRzKSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvcHRzKVxuICAgICAgICAgIGlmIChvcHRpb25zLmhhc093blByb3BlcnR5KGtleSkpIG9wdGlvbnNba2V5XSA9IG9wdHNba2V5XTtcbiAgICAgIH0sXG4gICAgICBzaG93OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChzaG93aW5nKSByZXR1cm47XG4gICAgICAgIHNob3dpbmcgPSB0cnVlO1xuICAgICAgICBpZiAoZmFkZVRpbWVySWQgIT09IG51bGwpIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZShmYWRlVGltZXJJZCk7XG4gICAgICAgIGlmICghY2FudmFzKSBjcmVhdGVDYW52YXMoKTtcbiAgICAgICAgY2FudmFzLnN0eWxlLm9wYWNpdHkgPSAxO1xuICAgICAgICBjYW52YXMuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICAgICAgdG9wYmFyLnByb2dyZXNzKDApO1xuICAgICAgICBpZiAob3B0aW9ucy5hdXRvUnVuKSB7XG4gICAgICAgICAgKGZ1bmN0aW9uIGxvb3AoKSB7XG4gICAgICAgICAgICBwcm9ncmVzc1RpbWVySWQgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGxvb3ApO1xuICAgICAgICAgICAgdG9wYmFyLnByb2dyZXNzKFxuICAgICAgICAgICAgICBcIitcIiArIDAuMDUgKiBNYXRoLnBvdygxIC0gTWF0aC5zcXJ0KGN1cnJlbnRQcm9ncmVzcyksIDIpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0pKCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBwcm9ncmVzczogZnVuY3Rpb24gKHRvKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdG8gPT09IFwidW5kZWZpbmVkXCIpIHJldHVybiBjdXJyZW50UHJvZ3Jlc3M7XG4gICAgICAgIGlmICh0eXBlb2YgdG8gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICB0byA9XG4gICAgICAgICAgICAodG8uaW5kZXhPZihcIitcIikgPj0gMCB8fCB0by5pbmRleE9mKFwiLVwiKSA+PSAwXG4gICAgICAgICAgICAgID8gY3VycmVudFByb2dyZXNzXG4gICAgICAgICAgICAgIDogMCkgKyBwYXJzZUZsb2F0KHRvKTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50UHJvZ3Jlc3MgPSB0byA+IDEgPyAxIDogdG87XG4gICAgICAgIHJlcGFpbnQoKTtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRQcm9ncmVzcztcbiAgICAgIH0sXG4gICAgICBoaWRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghc2hvd2luZykgcmV0dXJuO1xuICAgICAgICBzaG93aW5nID0gZmFsc2U7XG4gICAgICAgIGlmIChwcm9ncmVzc1RpbWVySWQgIT0gbnVsbCkge1xuICAgICAgICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZShwcm9ncmVzc1RpbWVySWQpO1xuICAgICAgICAgIHByb2dyZXNzVGltZXJJZCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgKGZ1bmN0aW9uIGxvb3AoKSB7XG4gICAgICAgICAgaWYgKHRvcGJhci5wcm9ncmVzcyhcIisuMVwiKSA+PSAxKSB7XG4gICAgICAgICAgICBjYW52YXMuc3R5bGUub3BhY2l0eSAtPSAwLjA1O1xuICAgICAgICAgICAgaWYgKGNhbnZhcy5zdHlsZS5vcGFjaXR5IDw9IDAuMDUpIHtcbiAgICAgICAgICAgICAgY2FudmFzLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgICAgICAgICAgZmFkZVRpbWVySWQgPSBudWxsO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGZhZGVUaW1lcklkID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShsb29wKTtcbiAgICAgICAgfSkoKTtcbiAgICAgIH0sXG4gICAgfTtcblxuICBpZiAodHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHRvcGJhcjtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZShmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdG9wYmFyO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHRoaXMudG9wYmFyID0gdG9wYmFyO1xuICB9XG59LmNhbGwodGhpcywgd2luZG93LCBkb2N1bWVudCkpO1xuIiwgIihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzKSA6XG4gICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KSA6XG4gICAgKGdsb2JhbCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFRoaXMgOiBnbG9iYWwgfHwgc2VsZiwgZmFjdG9yeShnbG9iYWwuWlhpbmcgPSB7fSkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gICAgZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmogPT09IG51bGwgfHwgb2JqID09PSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBDb3B5cmlnaHQgMjAwOCBaWGluZyBhdXRob3JzXG4gICAgICpcbiAgICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgICAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgICAgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgICAgKlxuICAgICAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gICAgICpcbiAgICAgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICAgICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgICAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICAgICAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgICAgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAgICAgKi9cbiAgICAvKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSAqL1xuXG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcblxuICAgIGZ1bmN0aW9uIF9fZXh0ZW5kcyhkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZml4UHJvdG8odGFyZ2V0LCBwcm90b3R5cGUpIHtcbiAgICAgICAgdmFyIHNldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mO1xuICAgICAgICBzZXRQcm90b3R5cGVPZiA/IHNldFByb3RvdHlwZU9mKHRhcmdldCwgcHJvdG90eXBlKSA6ICh0YXJnZXQuX19wcm90b19fID0gcHJvdG90eXBlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmaXhTdGFjayh0YXJnZXQsIGZuKSB7XG4gICAgICAgIGlmIChmbiA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBmbiA9IHRhcmdldC5jb25zdHJ1Y3RvcjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2FwdHVyZVN0YWNrVHJhY2UgPSBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZTtcbiAgICAgICAgY2FwdHVyZVN0YWNrVHJhY2UgJiYgY2FwdHVyZVN0YWNrVHJhY2UodGFyZ2V0LCBmbik7XG4gICAgfVxuXG4gICAgdmFyIEN1c3RvbUVycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKEN1c3RvbUVycm9yLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBDdXN0b21FcnJvcihtZXNzYWdlKSB7XG4gICAgICAgICAgICB2YXIgX25ld1RhcmdldCA9IHRoaXMuY29uc3RydWN0b3I7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBtZXNzYWdlKSB8fCB0aGlzO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF90aGlzLCAnbmFtZScsIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogX25ld1RhcmdldC5uYW1lLFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGZpeFByb3RvKF90aGlzLCBfbmV3VGFyZ2V0LnByb3RvdHlwZSk7XG4gICAgICAgICAgICBmaXhTdGFjayhfdGhpcyk7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiBDdXN0b21FcnJvcjtcbiAgICB9KShFcnJvcik7XG5cbiAgICAvKipcbiAgICAgKiBDdXN0b20gRXJyb3IgY2xhc3Mgb2YgdHlwZSBFeGNlcHRpb24uXG4gICAgICovXG4gICAgY2xhc3MgRXhjZXB0aW9uIGV4dGVuZHMgQ3VzdG9tRXJyb3Ige1xuICAgICAgICAvKipcbiAgICAgICAgICogQWxsb3dzIEV4Y2VwdGlvbiB0byBiZSBjb25zdHJ1Y3RlZCBkaXJlY3RseVxuICAgICAgICAgKiB3aXRoIHNvbWUgbWVzc2FnZSBhbmQgcHJvdG90eXBlIGRlZmluaXRpb24uXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdHJ1Y3RvcihtZXNzYWdlID0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0S2luZCgpIHtcbiAgICAgICAgICAgIGNvbnN0IGV4ID0gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgIHJldHVybiBleC5raW5kO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEl0J3MgdHlwZWQgYXMgc3RyaW5nIHNvIGl0IGNhbiBiZSBleHRlbmRlZCBhbmQgb3ZlcnJpZGVuLlxuICAgICAqL1xuICAgIEV4Y2VwdGlvbi5raW5kID0gJ0V4Y2VwdGlvbic7XG5cbiAgICAvKipcbiAgICAgKiBDdXN0b20gRXJyb3IgY2xhc3Mgb2YgdHlwZSBFeGNlcHRpb24uXG4gICAgICovXG4gICAgY2xhc3MgQXJndW1lbnRFeGNlcHRpb24gZXh0ZW5kcyBFeGNlcHRpb24ge1xuICAgIH1cbiAgICBBcmd1bWVudEV4Y2VwdGlvbi5raW5kID0gJ0FyZ3VtZW50RXhjZXB0aW9uJztcblxuICAgIC8qKlxuICAgICAqIEN1c3RvbSBFcnJvciBjbGFzcyBvZiB0eXBlIEV4Y2VwdGlvbi5cbiAgICAgKi9cbiAgICBjbGFzcyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24gZXh0ZW5kcyBFeGNlcHRpb24ge1xuICAgIH1cbiAgICBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24ua2luZCA9ICdJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24nO1xuXG4gICAgLypcbiAgICAgKiBDb3B5cmlnaHQgMjAwOSBaWGluZyBhdXRob3JzXG4gICAgICpcbiAgICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgICAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgICAgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgICAgKlxuICAgICAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gICAgICpcbiAgICAgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICAgICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgICAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICAgICAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgICAgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAgICAgKi9cbiAgICBjbGFzcyBCaW5hcnlCaXRtYXAge1xuICAgICAgICBjb25zdHJ1Y3RvcihiaW5hcml6ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuYmluYXJpemVyID0gYmluYXJpemVyO1xuICAgICAgICAgICAgaWYgKGJpbmFyaXplciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oJ0JpbmFyaXplciBtdXN0IGJlIG5vbi1udWxsLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIFRoZSB3aWR0aCBvZiB0aGUgYml0bWFwLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0V2lkdGgoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5iaW5hcml6ZXIuZ2V0V2lkdGgoKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiBUaGUgaGVpZ2h0IG9mIHRoZSBiaXRtYXAuXG4gICAgICAgICAqL1xuICAgICAgICBnZXRIZWlnaHQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5iaW5hcml6ZXIuZ2V0SGVpZ2h0KCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnZlcnRzIG9uZSByb3cgb2YgbHVtaW5hbmNlIGRhdGEgdG8gMSBiaXQgZGF0YS4gTWF5IGFjdHVhbGx5IGRvIHRoZSBjb252ZXJzaW9uLCBvciByZXR1cm5cbiAgICAgICAgICogY2FjaGVkIGRhdGEuIENhbGxlcnMgc2hvdWxkIGFzc3VtZSB0aGlzIG1ldGhvZCBpcyBleHBlbnNpdmUgYW5kIGNhbGwgaXQgYXMgc2VsZG9tIGFzIHBvc3NpYmxlLlxuICAgICAgICAgKiBUaGlzIG1ldGhvZCBpcyBpbnRlbmRlZCBmb3IgZGVjb2RpbmcgMUQgYmFyY29kZXMgYW5kIG1heSBjaG9vc2UgdG8gYXBwbHkgc2hhcnBlbmluZy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHkgVGhlIHJvdyB0byBmZXRjaCwgd2hpY2ggbXVzdCBiZSBpbiBbMCwgYml0bWFwIGhlaWdodClcbiAgICAgICAgICogQHBhcmFtIHJvdyBBbiBvcHRpb25hbCBwcmVhbGxvY2F0ZWQgYXJyYXkuIElmIG51bGwgb3IgdG9vIHNtYWxsLCBpdCB3aWxsIGJlIGlnbm9yZWQuXG4gICAgICAgICAqICAgICAgICAgICAgSWYgdXNlZCwgdGhlIEJpbmFyaXplciB3aWxsIGNhbGwgQml0QXJyYXkuY2xlYXIoKS4gQWx3YXlzIHVzZSB0aGUgcmV0dXJuZWQgb2JqZWN0LlxuICAgICAgICAgKiBAcmV0dXJuIFRoZSBhcnJheSBvZiBiaXRzIGZvciB0aGlzIHJvdyAodHJ1ZSBtZWFucyBibGFjaykuXG4gICAgICAgICAqIEB0aHJvd3MgTm90Rm91bmRFeGNlcHRpb24gaWYgcm93IGNhbid0IGJlIGJpbmFyaXplZFxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0QmxhY2tSb3coeSAvKmludCovLCByb3cpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJpbmFyaXplci5nZXRCbGFja1Jvdyh5LCByb3cpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb252ZXJ0cyBhIDJEIGFycmF5IG9mIGx1bWluYW5jZSBkYXRhIHRvIDEgYml0LiBBcyBhYm92ZSwgYXNzdW1lIHRoaXMgbWV0aG9kIGlzIGV4cGVuc2l2ZVxuICAgICAgICAgKiBhbmQgZG8gbm90IGNhbGwgaXQgcmVwZWF0ZWRseS4gVGhpcyBtZXRob2QgaXMgaW50ZW5kZWQgZm9yIGRlY29kaW5nIDJEIGJhcmNvZGVzIGFuZCBtYXkgb3JcbiAgICAgICAgICogbWF5IG5vdCBhcHBseSBzaGFycGVuaW5nLiBUaGVyZWZvcmUsIGEgcm93IGZyb20gdGhpcyBtYXRyaXggbWF5IG5vdCBiZSBpZGVudGljYWwgdG8gb25lXG4gICAgICAgICAqIGZldGNoZWQgdXNpbmcgZ2V0QmxhY2tSb3coKSwgc28gZG9uJ3QgbWl4IGFuZCBtYXRjaCBiZXR3ZWVuIHRoZW0uXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4gVGhlIDJEIGFycmF5IG9mIGJpdHMgZm9yIHRoZSBpbWFnZSAodHJ1ZSBtZWFucyBibGFjaykuXG4gICAgICAgICAqIEB0aHJvd3MgTm90Rm91bmRFeGNlcHRpb24gaWYgaW1hZ2UgY2FuJ3QgYmUgYmluYXJpemVkIHRvIG1ha2UgYSBtYXRyaXhcbiAgICAgICAgICovXG4gICAgICAgIGdldEJsYWNrTWF0cml4KCkge1xuICAgICAgICAgICAgLy8gVGhlIG1hdHJpeCBpcyBjcmVhdGVkIG9uIGRlbWFuZCB0aGUgZmlyc3QgdGltZSBpdCBpcyByZXF1ZXN0ZWQsIHRoZW4gY2FjaGVkLiBUaGVyZSBhcmUgdHdvXG4gICAgICAgICAgICAvLyByZWFzb25zIGZvciB0aGlzOlxuICAgICAgICAgICAgLy8gMS4gVGhpcyB3b3JrIHdpbGwgbmV2ZXIgYmUgZG9uZSBpZiB0aGUgY2FsbGVyIG9ubHkgaW5zdGFsbHMgMUQgUmVhZGVyIG9iamVjdHMsIG9yIGlmIGFcbiAgICAgICAgICAgIC8vICAgIDFEIFJlYWRlciBmaW5kcyBhIGJhcmNvZGUgYmVmb3JlIHRoZSAyRCBSZWFkZXJzIHJ1bi5cbiAgICAgICAgICAgIC8vIDIuIFRoaXMgd29yayB3aWxsIG9ubHkgYmUgZG9uZSBvbmNlIGV2ZW4gaWYgdGhlIGNhbGxlciBpbnN0YWxscyBtdWx0aXBsZSAyRCBSZWFkZXJzLlxuICAgICAgICAgICAgaWYgKHRoaXMubWF0cml4ID09PSBudWxsIHx8IHRoaXMubWF0cml4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1hdHJpeCA9IHRoaXMuYmluYXJpemVyLmdldEJsYWNrTWF0cml4KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYXRyaXg7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gV2hldGhlciB0aGlzIGJpdG1hcCBjYW4gYmUgY3JvcHBlZC5cbiAgICAgICAgICovXG4gICAgICAgIGlzQ3JvcFN1cHBvcnRlZCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJpbmFyaXplci5nZXRMdW1pbmFuY2VTb3VyY2UoKS5pc0Nyb3BTdXBwb3J0ZWQoKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBhIG5ldyBvYmplY3Qgd2l0aCBjcm9wcGVkIGltYWdlIGRhdGEuIEltcGxlbWVudGF0aW9ucyBtYXkga2VlcCBhIHJlZmVyZW5jZSB0byB0aGVcbiAgICAgICAgICogb3JpZ2luYWwgZGF0YSByYXRoZXIgdGhhbiBhIGNvcHkuIE9ubHkgY2FsbGFibGUgaWYgaXNDcm9wU3VwcG9ydGVkKCkgaXMgdHJ1ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGxlZnQgVGhlIGxlZnQgY29vcmRpbmF0ZSwgd2hpY2ggbXVzdCBiZSBpbiBbMCxnZXRXaWR0aCgpKVxuICAgICAgICAgKiBAcGFyYW0gdG9wIFRoZSB0b3AgY29vcmRpbmF0ZSwgd2hpY2ggbXVzdCBiZSBpbiBbMCxnZXRIZWlnaHQoKSlcbiAgICAgICAgICogQHBhcmFtIHdpZHRoIFRoZSB3aWR0aCBvZiB0aGUgcmVjdGFuZ2xlIHRvIGNyb3AuXG4gICAgICAgICAqIEBwYXJhbSBoZWlnaHQgVGhlIGhlaWdodCBvZiB0aGUgcmVjdGFuZ2xlIHRvIGNyb3AuXG4gICAgICAgICAqIEByZXR1cm4gQSBjcm9wcGVkIHZlcnNpb24gb2YgdGhpcyBvYmplY3QuXG4gICAgICAgICAqL1xuICAgICAgICBjcm9wKGxlZnQgLyppbnQqLywgdG9wIC8qaW50Ki8sIHdpZHRoIC8qaW50Ki8sIGhlaWdodCAvKmludCovKSB7XG4gICAgICAgICAgICBjb25zdCBuZXdTb3VyY2UgPSB0aGlzLmJpbmFyaXplci5nZXRMdW1pbmFuY2VTb3VyY2UoKS5jcm9wKGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJpbmFyeUJpdG1hcCh0aGlzLmJpbmFyaXplci5jcmVhdGVCaW5hcml6ZXIobmV3U291cmNlKSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gV2hldGhlciB0aGlzIGJpdG1hcCBzdXBwb3J0cyBjb3VudGVyLWNsb2Nrd2lzZSByb3RhdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIGlzUm90YXRlU3VwcG9ydGVkKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmluYXJpemVyLmdldEx1bWluYW5jZVNvdXJjZSgpLmlzUm90YXRlU3VwcG9ydGVkKCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgYSBuZXcgb2JqZWN0IHdpdGggcm90YXRlZCBpbWFnZSBkYXRhIGJ5IDkwIGRlZ3JlZXMgY291bnRlcmNsb2Nrd2lzZS5cbiAgICAgICAgICogT25seSBjYWxsYWJsZSBpZiB7QGxpbmsgI2lzUm90YXRlU3VwcG9ydGVkKCl9IGlzIHRydWUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4gQSByb3RhdGVkIHZlcnNpb24gb2YgdGhpcyBvYmplY3QuXG4gICAgICAgICAqL1xuICAgICAgICByb3RhdGVDb3VudGVyQ2xvY2t3aXNlKCkge1xuICAgICAgICAgICAgY29uc3QgbmV3U291cmNlID0gdGhpcy5iaW5hcml6ZXIuZ2V0THVtaW5hbmNlU291cmNlKCkucm90YXRlQ291bnRlckNsb2Nrd2lzZSgpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBCaW5hcnlCaXRtYXAodGhpcy5iaW5hcml6ZXIuY3JlYXRlQmluYXJpemVyKG5ld1NvdXJjZSkpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGEgbmV3IG9iamVjdCB3aXRoIHJvdGF0ZWQgaW1hZ2UgZGF0YSBieSA0NSBkZWdyZWVzIGNvdW50ZXJjbG9ja3dpc2UuXG4gICAgICAgICAqIE9ubHkgY2FsbGFibGUgaWYge0BsaW5rICNpc1JvdGF0ZVN1cHBvcnRlZCgpfSBpcyB0cnVlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIEEgcm90YXRlZCB2ZXJzaW9uIG9mIHRoaXMgb2JqZWN0LlxuICAgICAgICAgKi9cbiAgICAgICAgcm90YXRlQ291bnRlckNsb2Nrd2lzZTQ1KCkge1xuICAgICAgICAgICAgY29uc3QgbmV3U291cmNlID0gdGhpcy5iaW5hcml6ZXIuZ2V0THVtaW5hbmNlU291cmNlKCkucm90YXRlQ291bnRlckNsb2Nrd2lzZTQ1KCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJpbmFyeUJpdG1hcCh0aGlzLmJpbmFyaXplci5jcmVhdGVCaW5hcml6ZXIobmV3U291cmNlKSk7XG4gICAgICAgIH1cbiAgICAgICAgLypAT3ZlcnJpZGUqL1xuICAgICAgICB0b1N0cmluZygpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QmxhY2tNYXRyaXgoKS50b1N0cmluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUgLyo6IE5vdEZvdW5kRXhjZXB0aW9uKi8pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDdXN0b20gRXJyb3IgY2xhc3Mgb2YgdHlwZSBFeGNlcHRpb24uXG4gICAgICovXG4gICAgY2xhc3MgQ2hlY2tzdW1FeGNlcHRpb24gZXh0ZW5kcyBFeGNlcHRpb24ge1xuICAgICAgICBzdGF0aWMgZ2V0Q2hlY2tzdW1JbnN0YW5jZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ2hlY2tzdW1FeGNlcHRpb24oKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBDaGVja3N1bUV4Y2VwdGlvbi5raW5kID0gJ0NoZWNrc3VtRXhjZXB0aW9uJztcblxuICAgIC8qXG4gICAgICogQ29weXJpZ2h0IDIwMDkgWlhpbmcgYXV0aG9yc1xuICAgICAqXG4gICAgICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgICAgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICAgICpcbiAgICAgKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICAgICAqXG4gICAgICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICAgICAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgICAgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgICAgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gICAgICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gICAgICovXG4gICAgLyoqXG4gICAgICogVGhpcyBjbGFzcyBoaWVyYXJjaHkgcHJvdmlkZXMgYSBzZXQgb2YgbWV0aG9kcyB0byBjb252ZXJ0IGx1bWluYW5jZSBkYXRhIHRvIDEgYml0IGRhdGEuXG4gICAgICogSXQgYWxsb3dzIHRoZSBhbGdvcml0aG0gdG8gdmFyeSBwb2x5bW9ycGhpY2FsbHksIGZvciBleGFtcGxlIGFsbG93aW5nIGEgdmVyeSBleHBlbnNpdmVcbiAgICAgKiB0aHJlc2hvbGRpbmcgdGVjaG5pcXVlIGZvciBzZXJ2ZXJzIGFuZCBhIGZhc3Qgb25lIGZvciBtb2JpbGUuIEl0IGFsc28gcGVybWl0cyB0aGUgaW1wbGVtZW50YXRpb25cbiAgICAgKiB0byB2YXJ5LCBlLmcuIGEgSk5JIHZlcnNpb24gZm9yIEFuZHJvaWQgYW5kIGEgSmF2YSBmYWxsYmFjayB2ZXJzaW9uIGZvciBvdGhlciBwbGF0Zm9ybXMuXG4gICAgICpcbiAgICAgKiBAYXV0aG9yIGRzd2l0a2luQGdvb2dsZS5jb20gKERhbmllbCBTd2l0a2luKVxuICAgICAqL1xuICAgIGNsYXNzIEJpbmFyaXplciB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHNvdXJjZSkge1xuICAgICAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0THVtaW5hbmNlU291cmNlKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlO1xuICAgICAgICB9XG4gICAgICAgIGdldFdpZHRoKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlLmdldFdpZHRoKCk7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0SGVpZ2h0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlLmdldEhlaWdodCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY2xhc3MgU3lzdGVtIHtcbiAgICAgICAgLy8gcHVibGljIHN0YXRpYyB2b2lkIGFycmF5Y29weShPYmplY3Qgc3JjLCBpbnQgc3JjUG9zLCBPYmplY3QgZGVzdCwgaW50IGRlc3RQb3MsIGludCBsZW5ndGgpXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYWtlcyBhIGNvcHkgb2YgYSBhcnJheS5cbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBhcnJheWNvcHkoc3JjLCBzcmNQb3MsIGRlc3QsIGRlc3RQb3MsIGxlbmd0aCkge1xuICAgICAgICAgICAgLy8gVE9ETzogYmV0dGVyIHVzZSBzcGxpdCBvciBzZXQ/XG4gICAgICAgICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgICAgICAgICBkZXN0W2Rlc3RQb3MrK10gPSBzcmNbc3JjUG9zKytdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHRpbWUgaW4gbWlsbGlzZWNvbmRzLlxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGN1cnJlbnRUaW1lTWlsbGlzKCkge1xuICAgICAgICAgICAgcmV0dXJuIERhdGUubm93KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDdXN0b20gRXJyb3IgY2xhc3Mgb2YgdHlwZSBFeGNlcHRpb24uXG4gICAgICovXG4gICAgY2xhc3MgSW5kZXhPdXRPZkJvdW5kc0V4Y2VwdGlvbiBleHRlbmRzIEV4Y2VwdGlvbiB7XG4gICAgfVxuICAgIEluZGV4T3V0T2ZCb3VuZHNFeGNlcHRpb24ua2luZCA9ICdJbmRleE91dE9mQm91bmRzRXhjZXB0aW9uJztcblxuICAgIC8qKlxuICAgICAqIEN1c3RvbSBFcnJvciBjbGFzcyBvZiB0eXBlIEV4Y2VwdGlvbi5cbiAgICAgKi9cbiAgICBjbGFzcyBBcnJheUluZGV4T3V0T2ZCb3VuZHNFeGNlcHRpb24gZXh0ZW5kcyBJbmRleE91dE9mQm91bmRzRXhjZXB0aW9uIHtcbiAgICAgICAgY29uc3RydWN0b3IoaW5kZXggPSB1bmRlZmluZWQsIG1lc3NhZ2UgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBBcnJheUluZGV4T3V0T2ZCb3VuZHNFeGNlcHRpb24ua2luZCA9ICdBcnJheUluZGV4T3V0T2ZCb3VuZHNFeGNlcHRpb24nO1xuXG4gICAgY2xhc3MgQXJyYXlzIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFzc2lnbnMgdGhlIHNwZWNpZmllZCBpbnQgdmFsdWUgdG8gZWFjaCBlbGVtZW50IG9mIHRoZSBzcGVjaWZpZWQgYXJyYXlcbiAgICAgICAgICogb2YgaW50cy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGEgdGhlIGFycmF5IHRvIGJlIGZpbGxlZFxuICAgICAgICAgKiBAcGFyYW0gdmFsIHRoZSB2YWx1ZSB0byBiZSBzdG9yZWQgaW4gYWxsIGVsZW1lbnRzIG9mIHRoZSBhcnJheVxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGZpbGwoYSwgdmFsKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gYS5sZW5ndGg7IGkgPCBsZW47IGkrKylcbiAgICAgICAgICAgICAgICBhW2ldID0gdmFsO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBc3NpZ25zIHRoZSBzcGVjaWZpZWQgaW50IHZhbHVlIHRvIGVhY2ggZWxlbWVudCBvZiB0aGUgc3BlY2lmaWVkXG4gICAgICAgICAqIHJhbmdlIG9mIHRoZSBzcGVjaWZpZWQgYXJyYXkgb2YgaW50cy4gIFRoZSByYW5nZSB0byBiZSBmaWxsZWRcbiAgICAgICAgICogZXh0ZW5kcyBmcm9tIGluZGV4IHtAY29kZSBmcm9tSW5kZXh9LCBpbmNsdXNpdmUsIHRvIGluZGV4XG4gICAgICAgICAqIHtAY29kZSB0b0luZGV4fSwgZXhjbHVzaXZlLiAgKElmIHtAY29kZSBmcm9tSW5kZXg9PXRvSW5kZXh9LCB0aGVcbiAgICAgICAgICogcmFuZ2UgdG8gYmUgZmlsbGVkIGlzIGVtcHR5LilcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGEgdGhlIGFycmF5IHRvIGJlIGZpbGxlZFxuICAgICAgICAgKiBAcGFyYW0gZnJvbUluZGV4IHRoZSBpbmRleCBvZiB0aGUgZmlyc3QgZWxlbWVudCAoaW5jbHVzaXZlKSB0byBiZVxuICAgICAgICAgKiAgICAgICAgZmlsbGVkIHdpdGggdGhlIHNwZWNpZmllZCB2YWx1ZVxuICAgICAgICAgKiBAcGFyYW0gdG9JbmRleCB0aGUgaW5kZXggb2YgdGhlIGxhc3QgZWxlbWVudCAoZXhjbHVzaXZlKSB0byBiZVxuICAgICAgICAgKiAgICAgICAgZmlsbGVkIHdpdGggdGhlIHNwZWNpZmllZCB2YWx1ZVxuICAgICAgICAgKiBAcGFyYW0gdmFsIHRoZSB2YWx1ZSB0byBiZSBzdG9yZWQgaW4gYWxsIGVsZW1lbnRzIG9mIHRoZSBhcnJheVxuICAgICAgICAgKiBAdGhyb3dzIElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbiBpZiB7QGNvZGUgZnJvbUluZGV4ID4gdG9JbmRleH1cbiAgICAgICAgICogQHRocm93cyBBcnJheUluZGV4T3V0T2ZCb3VuZHNFeGNlcHRpb24gaWYge0Bjb2RlIGZyb21JbmRleCA8IDB9IG9yXG4gICAgICAgICAqICAgICAgICAge0Bjb2RlIHRvSW5kZXggPiBhLmxlbmd0aH1cbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBmaWxsV2l0aGluKGEsIGZyb21JbmRleCwgdG9JbmRleCwgdmFsKSB7XG4gICAgICAgICAgICBBcnJheXMucmFuZ2VDaGVjayhhLmxlbmd0aCwgZnJvbUluZGV4LCB0b0luZGV4KTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBmcm9tSW5kZXg7IGkgPCB0b0luZGV4OyBpKyspXG4gICAgICAgICAgICAgICAgYVtpXSA9IHZhbDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ2hlY2tzIHRoYXQge0Bjb2RlIGZyb21JbmRleH0gYW5kIHtAY29kZSB0b0luZGV4fSBhcmUgaW5cbiAgICAgICAgICogdGhlIHJhbmdlIGFuZCB0aHJvd3MgYW4gZXhjZXB0aW9uIGlmIHRoZXkgYXJlbid0LlxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIHJhbmdlQ2hlY2soYXJyYXlMZW5ndGgsIGZyb21JbmRleCwgdG9JbmRleCkge1xuICAgICAgICAgICAgaWYgKGZyb21JbmRleCA+IHRvSW5kZXgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCdmcm9tSW5kZXgoJyArIGZyb21JbmRleCArICcpID4gdG9JbmRleCgnICsgdG9JbmRleCArICcpJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZnJvbUluZGV4IDwgMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcnJheUluZGV4T3V0T2ZCb3VuZHNFeGNlcHRpb24oZnJvbUluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0b0luZGV4ID4gYXJyYXlMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJyYXlJbmRleE91dE9mQm91bmRzRXhjZXB0aW9uKHRvSW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBhc0xpc3QoLi4uYXJncykge1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3M7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGNyZWF0ZShyb3dzLCBjb2xzLCB2YWx1ZSkge1xuICAgICAgICAgICAgbGV0IGFyciA9IEFycmF5LmZyb20oeyBsZW5ndGg6IHJvd3MgfSk7XG4gICAgICAgICAgICByZXR1cm4gYXJyLm1hcCh4ID0+IEFycmF5LmZyb20oeyBsZW5ndGg6IGNvbHMgfSkuZmlsbCh2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBjcmVhdGVJbnQzMkFycmF5KHJvd3MsIGNvbHMsIHZhbHVlKSB7XG4gICAgICAgICAgICBsZXQgYXJyID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogcm93cyB9KTtcbiAgICAgICAgICAgIHJldHVybiBhcnIubWFwKHggPT4gSW50MzJBcnJheS5mcm9tKHsgbGVuZ3RoOiBjb2xzIH0pLmZpbGwodmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgZXF1YWxzKGZpcnN0LCBzZWNvbmQpIHtcbiAgICAgICAgICAgIGlmICghZmlyc3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXNlY29uZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZmlyc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFzZWNvbmQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZpcnN0Lmxlbmd0aCAhPT0gc2Vjb25kLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW5ndGggPSBmaXJzdC5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChmaXJzdFtpXSAhPT0gc2Vjb25kW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgaGFzaENvZGUoYSkge1xuICAgICAgICAgICAgaWYgKGEgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCByZXN1bHQgPSAxO1xuICAgICAgICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGEpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSAzMSAqIHJlc3VsdCArIGVsZW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBmaWxsVWludDhBcnJheShhLCB2YWx1ZSkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgIT09IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBhW2ldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGNvcHlPZihvcmlnaW5hbCwgbmV3TGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gb3JpZ2luYWwuc2xpY2UoMCwgbmV3TGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgY29weU9mVWludDhBcnJheShvcmlnaW5hbCwgbmV3TGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAob3JpZ2luYWwubGVuZ3RoIDw9IG5ld0xlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0FycmF5ID0gbmV3IFVpbnQ4QXJyYXkobmV3TGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBuZXdBcnJheS5zZXQob3JpZ2luYWwpO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXdBcnJheTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbC5zbGljZSgwLCBuZXdMZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBjb3B5T2ZSYW5nZShvcmlnaW5hbCwgZnJvbSwgdG8pIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld0xlbmd0aCA9IHRvIC0gZnJvbTtcbiAgICAgICAgICAgIGNvbnN0IGNvcHkgPSBuZXcgSW50MzJBcnJheShuZXdMZW5ndGgpO1xuICAgICAgICAgICAgU3lzdGVtLmFycmF5Y29weShvcmlnaW5hbCwgZnJvbSwgY29weSwgMCwgbmV3TGVuZ3RoKTtcbiAgICAgICAgICAgIHJldHVybiBjb3B5O1xuICAgICAgICB9XG4gICAgICAgIC8qXG4gICAgICAgICogUmV0dXJucyB0aGUgaW5kZXggb2Ygb2YgdGhlIGVsZW1lbnQgaW4gYSBzb3J0ZWQgYXJyYXkgb3IgKC1uLTEpIHdoZXJlIG4gaXMgdGhlIGluc2VydGlvbiBwb2ludFxuICAgICAgICAqIGZvciB0aGUgbmV3IGVsZW1lbnQuXG4gICAgICAgICogUGFyYW1ldGVyczpcbiAgICAgICAgKiAgICAgYXIgLSBBIHNvcnRlZCBhcnJheVxuICAgICAgICAqICAgICBlbCAtIEFuIGVsZW1lbnQgdG8gc2VhcmNoIGZvclxuICAgICAgICAqICAgICBjb21wYXJhdG9yIC0gQSBjb21wYXJhdG9yIGZ1bmN0aW9uLiBUaGUgZnVuY3Rpb24gdGFrZXMgdHdvIGFyZ3VtZW50czogKGEsIGIpIGFuZCByZXR1cm5zOlxuICAgICAgICAqICAgICAgICBhIG5lZ2F0aXZlIG51bWJlciAgaWYgYSBpcyBsZXNzIHRoYW4gYjtcbiAgICAgICAgKiAgICAgICAgMCBpZiBhIGlzIGVxdWFsIHRvIGI7XG4gICAgICAgICogICAgICAgIGEgcG9zaXRpdmUgbnVtYmVyIG9mIGEgaXMgZ3JlYXRlciB0aGFuIGIuXG4gICAgICAgICogVGhlIGFycmF5IG1heSBjb250YWluIGR1cGxpY2F0ZSBlbGVtZW50cy4gSWYgdGhlcmUgYXJlIG1vcmUgdGhhbiBvbmUgZXF1YWwgZWxlbWVudHMgaW4gdGhlIGFycmF5LFxuICAgICAgICAqIHRoZSByZXR1cm5lZCB2YWx1ZSBjYW4gYmUgdGhlIGluZGV4IG9mIGFueSBvbmUgb2YgdGhlIGVxdWFsIGVsZW1lbnRzLlxuICAgICAgICAqXG4gICAgICAgICogaHR0cDovL2pzZmlkZGxlLm5ldC9hcnl6aG92L3BrZnN0NTUwL1xuICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgYmluYXJ5U2VhcmNoKGFyLCBlbCwgY29tcGFyYXRvcikge1xuICAgICAgICAgICAgaWYgKHVuZGVmaW5lZCA9PT0gY29tcGFyYXRvcikge1xuICAgICAgICAgICAgICAgIGNvbXBhcmF0b3IgPSBBcnJheXMubnVtYmVyQ29tcGFyYXRvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBtID0gMDtcbiAgICAgICAgICAgIGxldCBuID0gYXIubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIHdoaWxlIChtIDw9IG4pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBrID0gKG4gKyBtKSA+PiAxO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNtcCA9IGNvbXBhcmF0b3IoZWwsIGFyW2tdKTtcbiAgICAgICAgICAgICAgICBpZiAoY21wID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBtID0gayArIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNtcCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbiA9IGsgLSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIC1tIC0gMTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgbnVtYmVyQ29tcGFyYXRvcihhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYSAtIGI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQb255ZmlsbCBmb3IgSmF2YSdzIEludGVnZXIgY2xhc3MuXG4gICAgICovXG4gICAgY2xhc3MgSW50ZWdlciB7XG4gICAgICAgIHN0YXRpYyBudW1iZXJPZlRyYWlsaW5nWmVyb3MoaSkge1xuICAgICAgICAgICAgbGV0IHk7XG4gICAgICAgICAgICBpZiAoaSA9PT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gMzI7XG4gICAgICAgICAgICBsZXQgbiA9IDMxO1xuICAgICAgICAgICAgeSA9IGkgPDwgMTY7XG4gICAgICAgICAgICBpZiAoeSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIG4gLT0gMTY7XG4gICAgICAgICAgICAgICAgaSA9IHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB5ID0gaSA8PCA4O1xuICAgICAgICAgICAgaWYgKHkgIT09IDApIHtcbiAgICAgICAgICAgICAgICBuIC09IDg7XG4gICAgICAgICAgICAgICAgaSA9IHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB5ID0gaSA8PCA0O1xuICAgICAgICAgICAgaWYgKHkgIT09IDApIHtcbiAgICAgICAgICAgICAgICBuIC09IDQ7XG4gICAgICAgICAgICAgICAgaSA9IHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB5ID0gaSA8PCAyO1xuICAgICAgICAgICAgaWYgKHkgIT09IDApIHtcbiAgICAgICAgICAgICAgICBuIC09IDI7XG4gICAgICAgICAgICAgICAgaSA9IHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbiAtICgoaSA8PCAxKSA+Pj4gMzEpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBudW1iZXJPZkxlYWRpbmdaZXJvcyhpKSB7XG4gICAgICAgICAgICAvLyBIRCwgRmlndXJlIDUtNlxuICAgICAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMzI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgbiA9IDE7XG4gICAgICAgICAgICBpZiAoaSA+Pj4gMTYgPT09IDApIHtcbiAgICAgICAgICAgICAgICBuICs9IDE2O1xuICAgICAgICAgICAgICAgIGkgPDw9IDE2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGkgPj4+IDI0ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgbiArPSA4O1xuICAgICAgICAgICAgICAgIGkgPDw9IDg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaSA+Pj4gMjggPT09IDApIHtcbiAgICAgICAgICAgICAgICBuICs9IDQ7XG4gICAgICAgICAgICAgICAgaSA8PD0gNDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpID4+PiAzMCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIG4gKz0gMjtcbiAgICAgICAgICAgICAgICBpIDw8PSAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbiAtPSBpID4+PiAzMTtcbiAgICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyB0b0hleFN0cmluZyhpKSB7XG4gICAgICAgICAgICByZXR1cm4gaS50b1N0cmluZygxNik7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIHRvQmluYXJ5U3RyaW5nKGludE51bWJlcikge1xuICAgICAgICAgICAgcmV0dXJuIFN0cmluZyhwYXJzZUludChTdHJpbmcoaW50TnVtYmVyKSwgMikpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJldHVybnMgdGhlIG51bWJlciBvZiBvbmUtYml0cyBpbiB0aGUgdHdvJ3MgY29tcGxlbWVudCBiaW5hcnkgcmVwcmVzZW50YXRpb24gb2YgdGhlIHNwZWNpZmllZCBpbnQgdmFsdWUuIFRoaXMgZnVuY3Rpb24gaXMgc29tZXRpbWVzIHJlZmVycmVkIHRvIGFzIHRoZSBwb3B1bGF0aW9uIGNvdW50LlxuICAgICAgICAvLyBSZXR1cm5zOlxuICAgICAgICAvLyB0aGUgbnVtYmVyIG9mIG9uZS1iaXRzIGluIHRoZSB0d28ncyBjb21wbGVtZW50IGJpbmFyeSByZXByZXNlbnRhdGlvbiBvZiB0aGUgc3BlY2lmaWVkIGludCB2YWx1ZS5cbiAgICAgICAgc3RhdGljIGJpdENvdW50KGkpIHtcbiAgICAgICAgICAgIC8vIEhELCBGaWd1cmUgNS0yXG4gICAgICAgICAgICBpID0gaSAtICgoaSA+Pj4gMSkgJiAweDU1NTU1NTU1KTtcbiAgICAgICAgICAgIGkgPSAoaSAmIDB4MzMzMzMzMzMpICsgKChpID4+PiAyKSAmIDB4MzMzMzMzMzMpO1xuICAgICAgICAgICAgaSA9IChpICsgKGkgPj4+IDQpKSAmIDB4MGYwZjBmMGY7XG4gICAgICAgICAgICBpID0gaSArIChpID4+PiA4KTtcbiAgICAgICAgICAgIGkgPSBpICsgKGkgPj4+IDE2KTtcbiAgICAgICAgICAgIHJldHVybiBpICYgMHgzZjtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgdHJ1bmNEaXZpc2lvbihkaXZpZGVuZCwgZGl2aXNvcikge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgudHJ1bmMoZGl2aWRlbmQgLyBkaXZpc29yKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ29udmVydHMgQSBzdHJpbmcgdG8gYW4gaW50ZWdlci5cbiAgICAgICAgICogQHBhcmFtIHMgQSBzdHJpbmcgdG8gY29udmVydCBpbnRvIGEgbnVtYmVyLlxuICAgICAgICAgKiBAcGFyYW0gcmFkaXggQSB2YWx1ZSBiZXR3ZWVuIDIgYW5kIDM2IHRoYXQgc3BlY2lmaWVzIHRoZSBiYXNlIG9mIHRoZSBudW1iZXIgaW4gbnVtU3RyaW5nLiBJZiB0aGlzIGFyZ3VtZW50IGlzIG5vdCBzdXBwbGllZCwgc3RyaW5ncyB3aXRoIGEgcHJlZml4IG9mICcweCcgYXJlIGNvbnNpZGVyZWQgaGV4YWRlY2ltYWwuIEFsbCBvdGhlciBzdHJpbmdzIGFyZSBjb25zaWRlcmVkIGRlY2ltYWwuXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgcGFyc2VJbnQobnVtLCByYWRpeCA9IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KG51bSwgcmFkaXgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIEludGVnZXIuTUlOX1ZBTFVFXzMyX0JJVFMgPSAtMjE0NzQ4MzY0ODtcbiAgICBJbnRlZ2VyLk1BWF9WQUxVRSA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSO1xuXG4gICAgLyoqXG4gICAgICogPHA+QSBzaW1wbGUsIGZhc3QgYXJyYXkgb2YgYml0cywgcmVwcmVzZW50ZWQgY29tcGFjdGx5IGJ5IGFuIGFycmF5IG9mIGludHMgaW50ZXJuYWxseS48L3A+XG4gICAgICpcbiAgICAgKiBAYXV0aG9yIFNlYW4gT3dlblxuICAgICAqL1xuICAgIGNsYXNzIEJpdEFycmF5IC8qaW1wbGVtZW50cyBDbG9uZWFibGUqLyB7XG4gICAgICAgIC8vIEZvciB0ZXN0aW5nIG9ubHlcbiAgICAgICAgY29uc3RydWN0b3Ioc2l6ZSAvKmludCovLCBiaXRzKSB7XG4gICAgICAgICAgICBpZiAodW5kZWZpbmVkID09PSBzaXplKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zaXplID0gMDtcbiAgICAgICAgICAgICAgICB0aGlzLmJpdHMgPSBuZXcgSW50MzJBcnJheSgxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc2l6ZSA9IHNpemU7XG4gICAgICAgICAgICAgICAgaWYgKHVuZGVmaW5lZCA9PT0gYml0cyB8fCBudWxsID09PSBiaXRzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYml0cyA9IEJpdEFycmF5Lm1ha2VBcnJheShzaXplKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYml0cyA9IGJpdHM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGdldFNpemUoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zaXplO1xuICAgICAgICB9XG4gICAgICAgIGdldFNpemVJbkJ5dGVzKCkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoKHRoaXMuc2l6ZSArIDcpIC8gOCk7XG4gICAgICAgIH1cbiAgICAgICAgZW5zdXJlQ2FwYWNpdHkoc2l6ZSAvKmludCovKSB7XG4gICAgICAgICAgICBpZiAoc2l6ZSA+IHRoaXMuYml0cy5sZW5ndGggKiAzMikge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0JpdHMgPSBCaXRBcnJheS5tYWtlQXJyYXkoc2l6ZSk7XG4gICAgICAgICAgICAgICAgU3lzdGVtLmFycmF5Y29weSh0aGlzLmJpdHMsIDAsIG5ld0JpdHMsIDAsIHRoaXMuYml0cy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHRoaXMuYml0cyA9IG5ld0JpdHM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSBpIGJpdCB0byBnZXRcbiAgICAgICAgICogQHJldHVybiB0cnVlIGlmZiBiaXQgaSBpcyBzZXRcbiAgICAgICAgICovXG4gICAgICAgIGdldChpIC8qaW50Ki8pIHtcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5iaXRzW01hdGguZmxvb3IoaSAvIDMyKV0gJiAoMSA8PCAoaSAmIDB4MUYpKSkgIT09IDA7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgYml0IGkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBpIGJpdCB0byBzZXRcbiAgICAgICAgICovXG4gICAgICAgIHNldChpIC8qaW50Ki8pIHtcbiAgICAgICAgICAgIHRoaXMuYml0c1tNYXRoLmZsb29yKGkgLyAzMildIHw9IDEgPDwgKGkgJiAweDFGKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogRmxpcHMgYml0IGkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBpIGJpdCB0byBzZXRcbiAgICAgICAgICovXG4gICAgICAgIGZsaXAoaSAvKmludCovKSB7XG4gICAgICAgICAgICB0aGlzLmJpdHNbTWF0aC5mbG9vcihpIC8gMzIpXSBePSAxIDw8IChpICYgMHgxRik7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSBmcm9tIGZpcnN0IGJpdCB0byBjaGVja1xuICAgICAgICAgKiBAcmV0dXJuIGluZGV4IG9mIGZpcnN0IGJpdCB0aGF0IGlzIHNldCwgc3RhcnRpbmcgZnJvbSB0aGUgZ2l2ZW4gaW5kZXgsIG9yIHNpemUgaWYgbm9uZSBhcmUgc2V0XG4gICAgICAgICAqICBhdCBvciBiZXlvbmQgdGhpcyBnaXZlbiBpbmRleFxuICAgICAgICAgKiBAc2VlICNnZXROZXh0VW5zZXQoaW50KVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0TmV4dFNldChmcm9tIC8qaW50Ki8pIHtcbiAgICAgICAgICAgIGNvbnN0IHNpemUgPSB0aGlzLnNpemU7XG4gICAgICAgICAgICBpZiAoZnJvbSA+PSBzaXplKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBiaXRzID0gdGhpcy5iaXRzO1xuICAgICAgICAgICAgbGV0IGJpdHNPZmZzZXQgPSBNYXRoLmZsb29yKGZyb20gLyAzMik7XG4gICAgICAgICAgICBsZXQgY3VycmVudEJpdHMgPSBiaXRzW2JpdHNPZmZzZXRdO1xuICAgICAgICAgICAgLy8gbWFzayBvZmYgbGVzc2VyIGJpdHMgZmlyc3RcbiAgICAgICAgICAgIGN1cnJlbnRCaXRzICY9IH4oKDEgPDwgKGZyb20gJiAweDFGKSkgLSAxKTtcbiAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IGJpdHMubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKGN1cnJlbnRCaXRzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKCsrYml0c09mZnNldCA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzaXplO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdXJyZW50Qml0cyA9IGJpdHNbYml0c09mZnNldF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSAoYml0c09mZnNldCAqIDMyKSArIEludGVnZXIubnVtYmVyT2ZUcmFpbGluZ1plcm9zKGN1cnJlbnRCaXRzKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQgPiBzaXplID8gc2l6ZSA6IHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIGZyb20gaW5kZXggdG8gc3RhcnQgbG9va2luZyBmb3IgdW5zZXQgYml0XG4gICAgICAgICAqIEByZXR1cm4gaW5kZXggb2YgbmV4dCB1bnNldCBiaXQsIG9yIHtAY29kZSBzaXplfSBpZiBub25lIGFyZSB1bnNldCB1bnRpbCB0aGUgZW5kXG4gICAgICAgICAqIEBzZWUgI2dldE5leHRTZXQoaW50KVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0TmV4dFVuc2V0KGZyb20gLyppbnQqLykge1xuICAgICAgICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMuc2l6ZTtcbiAgICAgICAgICAgIGlmIChmcm9tID49IHNpemUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGJpdHMgPSB0aGlzLmJpdHM7XG4gICAgICAgICAgICBsZXQgYml0c09mZnNldCA9IE1hdGguZmxvb3IoZnJvbSAvIDMyKTtcbiAgICAgICAgICAgIGxldCBjdXJyZW50Qml0cyA9IH5iaXRzW2JpdHNPZmZzZXRdO1xuICAgICAgICAgICAgLy8gbWFzayBvZmYgbGVzc2VyIGJpdHMgZmlyc3RcbiAgICAgICAgICAgIGN1cnJlbnRCaXRzICY9IH4oKDEgPDwgKGZyb20gJiAweDFGKSkgLSAxKTtcbiAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IGJpdHMubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKGN1cnJlbnRCaXRzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKCsrYml0c09mZnNldCA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzaXplO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdXJyZW50Qml0cyA9IH5iaXRzW2JpdHNPZmZzZXRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gKGJpdHNPZmZzZXQgKiAzMikgKyBJbnRlZ2VyLm51bWJlck9mVHJhaWxpbmdaZXJvcyhjdXJyZW50Qml0cyk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0ID4gc2l6ZSA/IHNpemUgOiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgYSBibG9jayBvZiAzMiBiaXRzLCBzdGFydGluZyBhdCBiaXQgaS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGkgZmlyc3QgYml0IHRvIHNldFxuICAgICAgICAgKiBAcGFyYW0gbmV3Qml0cyB0aGUgbmV3IHZhbHVlIG9mIHRoZSBuZXh0IDMyIGJpdHMuIE5vdGUgYWdhaW4gdGhhdCB0aGUgbGVhc3Qtc2lnbmlmaWNhbnQgYml0XG4gICAgICAgICAqIGNvcnJlc3BvbmRzIHRvIGJpdCBpLCB0aGUgbmV4dC1sZWFzdC1zaWduaWZpY2FudCB0byBpKzEsIGFuZCBzbyBvbi5cbiAgICAgICAgICovXG4gICAgICAgIHNldEJ1bGsoaSAvKmludCovLCBuZXdCaXRzIC8qaW50Ki8pIHtcbiAgICAgICAgICAgIHRoaXMuYml0c1tNYXRoLmZsb29yKGkgLyAzMildID0gbmV3Qml0cztcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyBhIHJhbmdlIG9mIGJpdHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBzdGFydCBzdGFydCBvZiByYW5nZSwgaW5jbHVzaXZlLlxuICAgICAgICAgKiBAcGFyYW0gZW5kIGVuZCBvZiByYW5nZSwgZXhjbHVzaXZlXG4gICAgICAgICAqL1xuICAgICAgICBzZXRSYW5nZShzdGFydCAvKmludCovLCBlbmQgLyppbnQqLykge1xuICAgICAgICAgICAgaWYgKGVuZCA8IHN0YXJ0IHx8IHN0YXJ0IDwgMCB8fCBlbmQgPiB0aGlzLnNpemUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZW5kID09PSBzdGFydCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVuZC0tOyAvLyB3aWxsIGJlIGVhc2llciB0byB0cmVhdCB0aGlzIGFzIHRoZSBsYXN0IGFjdHVhbGx5IHNldCBiaXQgLS0gaW5jbHVzaXZlXG4gICAgICAgICAgICBjb25zdCBmaXJzdEludCA9IE1hdGguZmxvb3Ioc3RhcnQgLyAzMik7XG4gICAgICAgICAgICBjb25zdCBsYXN0SW50ID0gTWF0aC5mbG9vcihlbmQgLyAzMik7XG4gICAgICAgICAgICBjb25zdCBiaXRzID0gdGhpcy5iaXRzO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IGZpcnN0SW50OyBpIDw9IGxhc3RJbnQ7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpcnN0Qml0ID0gaSA+IGZpcnN0SW50ID8gMCA6IHN0YXJ0ICYgMHgxRjtcbiAgICAgICAgICAgICAgICBjb25zdCBsYXN0Qml0ID0gaSA8IGxhc3RJbnQgPyAzMSA6IGVuZCAmIDB4MUY7XG4gICAgICAgICAgICAgICAgLy8gT25lcyBmcm9tIGZpcnN0Qml0IHRvIGxhc3RCaXQsIGluY2x1c2l2ZVxuICAgICAgICAgICAgICAgIGNvbnN0IG1hc2sgPSAoMiA8PCBsYXN0Qml0KSAtICgxIDw8IGZpcnN0Qml0KTtcbiAgICAgICAgICAgICAgICBiaXRzW2ldIHw9IG1hc2s7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENsZWFycyBhbGwgYml0cyAoc2V0cyB0byBmYWxzZSkuXG4gICAgICAgICAqL1xuICAgICAgICBjbGVhcigpIHtcbiAgICAgICAgICAgIGNvbnN0IG1heCA9IHRoaXMuYml0cy5sZW5ndGg7XG4gICAgICAgICAgICBjb25zdCBiaXRzID0gdGhpcy5iaXRzO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXg7IGkrKykge1xuICAgICAgICAgICAgICAgIGJpdHNbaV0gPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFZmZpY2llbnQgbWV0aG9kIHRvIGNoZWNrIGlmIGEgcmFuZ2Ugb2YgYml0cyBpcyBzZXQsIG9yIG5vdCBzZXQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBzdGFydCBzdGFydCBvZiByYW5nZSwgaW5jbHVzaXZlLlxuICAgICAgICAgKiBAcGFyYW0gZW5kIGVuZCBvZiByYW5nZSwgZXhjbHVzaXZlXG4gICAgICAgICAqIEBwYXJhbSB2YWx1ZSBpZiB0cnVlLCBjaGVja3MgdGhhdCBiaXRzIGluIHJhbmdlIGFyZSBzZXQsIG90aGVyd2lzZSBjaGVja3MgdGhhdCB0aGV5IGFyZSBub3Qgc2V0XG4gICAgICAgICAqIFxuICAgICAgICAgKiBAcmV0dXJuIHRydWUgaWZmIGFsbCBiaXRzIGFyZSBzZXQgb3Igbm90IHNldCBpbiByYW5nZSwgYWNjb3JkaW5nIHRvIHZhbHVlIGFyZ3VtZW50XG4gICAgICAgICAqIEB0aHJvd3MgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uIGlmIGVuZCBpcyBsZXNzIHRoYW4gc3RhcnQgb3IgdGhlIHJhbmdlIGlzIG5vdCBjb250YWluZWQgaW4gdGhlIGFycmF5XG4gICAgICAgICAqL1xuICAgICAgICBpc1JhbmdlKHN0YXJ0IC8qaW50Ki8sIGVuZCAvKmludCovLCB2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKGVuZCA8IHN0YXJ0IHx8IHN0YXJ0IDwgMCB8fCBlbmQgPiB0aGlzLnNpemUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZW5kID09PSBzdGFydCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlOyAvLyBlbXB0eSByYW5nZSBtYXRjaGVzXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbmQtLTsgLy8gd2lsbCBiZSBlYXNpZXIgdG8gdHJlYXQgdGhpcyBhcyB0aGUgbGFzdCBhY3R1YWxseSBzZXQgYml0IC0tIGluY2x1c2l2ZVxuICAgICAgICAgICAgY29uc3QgZmlyc3RJbnQgPSBNYXRoLmZsb29yKHN0YXJ0IC8gMzIpO1xuICAgICAgICAgICAgY29uc3QgbGFzdEludCA9IE1hdGguZmxvb3IoZW5kIC8gMzIpO1xuICAgICAgICAgICAgY29uc3QgYml0cyA9IHRoaXMuYml0cztcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBmaXJzdEludDsgaSA8PSBsYXN0SW50OyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmaXJzdEJpdCA9IGkgPiBmaXJzdEludCA/IDAgOiBzdGFydCAmIDB4MUY7XG4gICAgICAgICAgICAgICAgY29uc3QgbGFzdEJpdCA9IGkgPCBsYXN0SW50ID8gMzEgOiBlbmQgJiAweDFGO1xuICAgICAgICAgICAgICAgIC8vIE9uZXMgZnJvbSBmaXJzdEJpdCB0byBsYXN0Qml0LCBpbmNsdXNpdmVcbiAgICAgICAgICAgICAgICBjb25zdCBtYXNrID0gKDIgPDwgbGFzdEJpdCkgLSAoMSA8PCBmaXJzdEJpdCkgJiAweEZGRkZGRkZGO1xuICAgICAgICAgICAgICAgIC8vIFRZUEVTQ1JJUFRQT1JUOiAmIDB4RkZGRkZGRkYgYWRkZWQgdG8gZGlzY2FyZCBhbnl0aGluZyBhZnRlciAzMiBiaXRzLCBhcyBFUyBoYXMgNTMgYml0c1xuICAgICAgICAgICAgICAgIC8vIFJldHVybiBmYWxzZSBpZiB3ZSdyZSBsb29raW5nIGZvciAxcyBhbmQgdGhlIG1hc2tlZCBiaXRzW2ldIGlzbid0IGFsbCAxcyAoaXM6IHRoYXQsXG4gICAgICAgICAgICAgICAgLy8gZXF1YWxzIHRoZSBtYXNrLCBvciB3ZSdyZSBsb29raW5nIGZvciAwcyBhbmQgdGhlIG1hc2tlZCBwb3J0aW9uIGlzIG5vdCBhbGwgMHNcbiAgICAgICAgICAgICAgICBpZiAoKGJpdHNbaV0gJiBtYXNrKSAhPT0gKHZhbHVlID8gbWFzayA6IDApKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBhcHBlbmRCaXQoYml0KSB7XG4gICAgICAgICAgICB0aGlzLmVuc3VyZUNhcGFjaXR5KHRoaXMuc2l6ZSArIDEpO1xuICAgICAgICAgICAgaWYgKGJpdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYml0c1tNYXRoLmZsb29yKHRoaXMuc2l6ZSAvIDMyKV0gfD0gMSA8PCAodGhpcy5zaXplICYgMHgxRik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNpemUrKztcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQXBwZW5kcyB0aGUgbGVhc3Qtc2lnbmlmaWNhbnQgYml0cywgZnJvbSB2YWx1ZSwgaW4gb3JkZXIgZnJvbSBtb3N0LXNpZ25pZmljYW50IHRvXG4gICAgICAgICAqIGxlYXN0LXNpZ25pZmljYW50LiBGb3IgZXhhbXBsZSwgYXBwZW5kaW5nIDYgYml0cyBmcm9tIDB4MDAwMDAxRSB3aWxsIGFwcGVuZCB0aGUgYml0c1xuICAgICAgICAgKiAwLCAxLCAxLCAxLCAxLCAwIGluIHRoYXQgb3JkZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB2YWx1ZSB7QGNvZGUgaW50fSBjb250YWluaW5nIGJpdHMgdG8gYXBwZW5kXG4gICAgICAgICAqIEBwYXJhbSBudW1CaXRzIGJpdHMgZnJvbSB2YWx1ZSB0byBhcHBlbmRcbiAgICAgICAgICovXG4gICAgICAgIGFwcGVuZEJpdHModmFsdWUgLyppbnQqLywgbnVtQml0cyAvKmludCovKSB7XG4gICAgICAgICAgICBpZiAobnVtQml0cyA8IDAgfHwgbnVtQml0cyA+IDMyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignTnVtIGJpdHMgbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDMyJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmVuc3VyZUNhcGFjaXR5KHRoaXMuc2l6ZSArIG51bUJpdHMpO1xuICAgICAgICAgICAgLy8gY29uc3QgYXBwZW5kQml0ID0gdGhpcy5hcHBlbmRCaXQ7XG4gICAgICAgICAgICBmb3IgKGxldCBudW1CaXRzTGVmdCA9IG51bUJpdHM7IG51bUJpdHNMZWZ0ID4gMDsgbnVtQml0c0xlZnQtLSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYXBwZW5kQml0KCgodmFsdWUgPj4gKG51bUJpdHNMZWZ0IC0gMSkpICYgMHgwMSkgPT09IDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFwcGVuZEJpdEFycmF5KG90aGVyKSB7XG4gICAgICAgICAgICBjb25zdCBvdGhlclNpemUgPSBvdGhlci5zaXplO1xuICAgICAgICAgICAgdGhpcy5lbnN1cmVDYXBhY2l0eSh0aGlzLnNpemUgKyBvdGhlclNpemUpO1xuICAgICAgICAgICAgLy8gY29uc3QgYXBwZW5kQml0ID0gdGhpcy5hcHBlbmRCaXQ7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG90aGVyU2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hcHBlbmRCaXQob3RoZXIuZ2V0KGkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB4b3Iob3RoZXIpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNpemUgIT09IG90aGVyLnNpemUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCdTaXplcyBkb25cXCd0IG1hdGNoJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBiaXRzID0gdGhpcy5iaXRzO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbmd0aCA9IGJpdHMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgbGFzdCBpbnQgY291bGQgYmUgaW5jb21wbGV0ZSAoaS5lLiBub3QgaGF2ZSAzMiBiaXRzIGluXG4gICAgICAgICAgICAgICAgLy8gaXQpIGJ1dCB0aGVyZSBpcyBubyBwcm9ibGVtIHNpbmNlIDAgWE9SIDAgPT0gMC5cbiAgICAgICAgICAgICAgICBiaXRzW2ldIF49IG90aGVyLmJpdHNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBiaXRPZmZzZXQgZmlyc3QgYml0IHRvIHN0YXJ0IHdyaXRpbmdcbiAgICAgICAgICogQHBhcmFtIGFycmF5IGFycmF5IHRvIHdyaXRlIGludG8uIEJ5dGVzIGFyZSB3cml0dGVuIG1vc3Qtc2lnbmlmaWNhbnQgYnl0ZSBmaXJzdC4gVGhpcyBpcyB0aGUgb3Bwb3NpdGVcbiAgICAgICAgICogIG9mIHRoZSBpbnRlcm5hbCByZXByZXNlbnRhdGlvbiwgd2hpY2ggaXMgZXhwb3NlZCBieSB7QGxpbmsgI2dldEJpdEFycmF5KCl9XG4gICAgICAgICAqIEBwYXJhbSBvZmZzZXQgcG9zaXRpb24gaW4gYXJyYXkgdG8gc3RhcnQgd3JpdGluZ1xuICAgICAgICAgKiBAcGFyYW0gbnVtQnl0ZXMgaG93IG1hbnkgYnl0ZXMgdG8gd3JpdGVcbiAgICAgICAgICovXG4gICAgICAgIHRvQnl0ZXMoYml0T2Zmc2V0IC8qaW50Ki8sIGFycmF5LCBvZmZzZXQgLyppbnQqLywgbnVtQnl0ZXMgLyppbnQqLykge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1CeXRlczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHRoZUJ5dGUgPSAwO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgODsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmdldChiaXRPZmZzZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGVCeXRlIHw9IDEgPDwgKDcgLSBqKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBiaXRPZmZzZXQrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXJyYXlbb2Zmc2V0ICsgaV0gPSAvKihieXRlKSovIHRoZUJ5dGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gdW5kZXJseWluZyBhcnJheSBvZiBpbnRzLiBUaGUgZmlyc3QgZWxlbWVudCBob2xkcyB0aGUgZmlyc3QgMzIgYml0cywgYW5kIHRoZSBsZWFzdFxuICAgICAgICAgKiAgICAgICAgIHNpZ25pZmljYW50IGJpdCBpcyBiaXQgMC5cbiAgICAgICAgICovXG4gICAgICAgIGdldEJpdEFycmF5KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYml0cztcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUmV2ZXJzZXMgYWxsIGJpdHMgaW4gdGhlIGFycmF5LlxuICAgICAgICAgKi9cbiAgICAgICAgcmV2ZXJzZSgpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld0JpdHMgPSBuZXcgSW50MzJBcnJheSh0aGlzLmJpdHMubGVuZ3RoKTtcbiAgICAgICAgICAgIC8vIHJldmVyc2UgYWxsIGludCdzIGZpcnN0XG4gICAgICAgICAgICBjb25zdCBsZW4gPSBNYXRoLmZsb29yKCh0aGlzLnNpemUgLSAxKSAvIDMyKTtcbiAgICAgICAgICAgIGNvbnN0IG9sZEJpdHNMZW4gPSBsZW4gKyAxO1xuICAgICAgICAgICAgY29uc3QgYml0cyA9IHRoaXMuYml0cztcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb2xkQml0c0xlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHggPSBiaXRzW2ldO1xuICAgICAgICAgICAgICAgIHggPSAoKHggPj4gMSkgJiAweDU1NTU1NTU1KSB8ICgoeCAmIDB4NTU1NTU1NTUpIDw8IDEpO1xuICAgICAgICAgICAgICAgIHggPSAoKHggPj4gMikgJiAweDMzMzMzMzMzKSB8ICgoeCAmIDB4MzMzMzMzMzMpIDw8IDIpO1xuICAgICAgICAgICAgICAgIHggPSAoKHggPj4gNCkgJiAweDBmMGYwZjBmKSB8ICgoeCAmIDB4MGYwZjBmMGYpIDw8IDQpO1xuICAgICAgICAgICAgICAgIHggPSAoKHggPj4gOCkgJiAweDAwZmYwMGZmKSB8ICgoeCAmIDB4MDBmZjAwZmYpIDw8IDgpO1xuICAgICAgICAgICAgICAgIHggPSAoKHggPj4gMTYpICYgMHgwMDAwZmZmZikgfCAoKHggJiAweDAwMDBmZmZmKSA8PCAxNik7XG4gICAgICAgICAgICAgICAgbmV3Qml0c1tsZW4gLSBpXSA9IC8qKGludCkqLyB4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gbm93IGNvcnJlY3QgdGhlIGludCdzIGlmIHRoZSBiaXQgc2l6ZSBpc24ndCBhIG11bHRpcGxlIG9mIDMyXG4gICAgICAgICAgICBpZiAodGhpcy5zaXplICE9PSBvbGRCaXRzTGVuICogMzIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsZWZ0T2Zmc2V0ID0gb2xkQml0c0xlbiAqIDMyIC0gdGhpcy5zaXplO1xuICAgICAgICAgICAgICAgIGxldCBjdXJyZW50SW50ID0gbmV3Qml0c1swXSA+Pj4gbGVmdE9mZnNldDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IG9sZEJpdHNMZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0SW50ID0gbmV3Qml0c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudEludCB8PSBuZXh0SW50IDw8ICgzMiAtIGxlZnRPZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICBuZXdCaXRzW2kgLSAxXSA9IGN1cnJlbnRJbnQ7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRJbnQgPSBuZXh0SW50ID4+PiBsZWZ0T2Zmc2V0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuZXdCaXRzW29sZEJpdHNMZW4gLSAxXSA9IGN1cnJlbnRJbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmJpdHMgPSBuZXdCaXRzO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBtYWtlQXJyYXkoc2l6ZSAvKmludCovKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEludDMyQXJyYXkoTWF0aC5mbG9vcigoc2l6ZSArIDMxKSAvIDMyKSk7XG4gICAgICAgIH1cbiAgICAgICAgLypAT3ZlcnJpZGUqL1xuICAgICAgICBlcXVhbHMobykge1xuICAgICAgICAgICAgaWYgKCEobyBpbnN0YW5jZW9mIEJpdEFycmF5KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG90aGVyID0gbztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNpemUgPT09IG90aGVyLnNpemUgJiYgQXJyYXlzLmVxdWFscyh0aGlzLmJpdHMsIG90aGVyLmJpdHMpO1xuICAgICAgICB9XG4gICAgICAgIC8qQE92ZXJyaWRlKi9cbiAgICAgICAgaGFzaENvZGUoKSB7XG4gICAgICAgICAgICByZXR1cm4gMzEgKiB0aGlzLnNpemUgKyBBcnJheXMuaGFzaENvZGUodGhpcy5iaXRzKTtcbiAgICAgICAgfVxuICAgICAgICAvKkBPdmVycmlkZSovXG4gICAgICAgIHRvU3RyaW5nKCkge1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9ICcnO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIHNpemUgPSB0aGlzLnNpemU7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoKGkgJiAweDA3KSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gJyAnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gdGhpcy5nZXQoaSkgPyAnWCcgOiAnLic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIC8qQE92ZXJyaWRlKi9cbiAgICAgICAgY2xvbmUoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJpdEFycmF5KHRoaXMuc2l6ZSwgdGhpcy5iaXRzLnNsaWNlKCkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBDb3B5cmlnaHQgMjAwOSBaWGluZyBhdXRob3JzXG4gICAgICpcbiAgICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgICAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgICAgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgICAgKlxuICAgICAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gICAgICpcbiAgICAgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICAgICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgICAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICAgICAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgICAgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAgICAgKi9cbiAgICAvKm5hbWVzcGFjZSBjb20uZ29vZ2xlLnp4aW5nIHsqL1xuICAgIC8qKlxuICAgICAqIEVuY2Fwc3VsYXRlcyBhIHR5cGUgb2YgaGludCB0aGF0IGEgY2FsbGVyIG1heSBwYXNzIHRvIGEgYmFyY29kZSByZWFkZXIgdG8gaGVscCBpdFxuICAgICAqIG1vcmUgcXVpY2tseSBvciBhY2N1cmF0ZWx5IGRlY29kZSBpdC4gSXQgaXMgdXAgdG8gaW1wbGVtZW50YXRpb25zIHRvIGRlY2lkZSB3aGF0LFxuICAgICAqIGlmIGFueXRoaW5nLCB0byBkbyB3aXRoIHRoZSBpbmZvcm1hdGlvbiB0aGF0IGlzIHN1cHBsaWVkLlxuICAgICAqXG4gICAgICogQGF1dGhvciBTZWFuIE93ZW5cbiAgICAgKiBAYXV0aG9yIGRzd2l0a2luQGdvb2dsZS5jb20gKERhbmllbCBTd2l0a2luKVxuICAgICAqIEBzZWUgUmVhZGVyI2RlY29kZShCaW5hcnlCaXRtYXAsamF2YS51dGlsLk1hcClcbiAgICAgKi9cbiAgICB2YXIgRGVjb2RlSGludFR5cGU7XG4gICAgKGZ1bmN0aW9uIChEZWNvZGVIaW50VHlwZSkge1xuICAgICAgICAvKipcbiAgICAgICAgICogVW5zcGVjaWZpZWQsIGFwcGxpY2F0aW9uLXNwZWNpZmljIGhpbnQuIE1hcHMgdG8gYW4gdW5zcGVjaWZpZWQge0BsaW5rIE9iamVjdH0uXG4gICAgICAgICAqL1xuICAgICAgICBEZWNvZGVIaW50VHlwZVtEZWNvZGVIaW50VHlwZVtcIk9USEVSXCJdID0gMF0gPSBcIk9USEVSXCI7IC8qKE9iamVjdC5jbGFzcykqL1xuICAgICAgICAvKipcbiAgICAgICAgICogSW1hZ2UgaXMgYSBwdXJlIG1vbm9jaHJvbWUgaW1hZ2Ugb2YgYSBiYXJjb2RlLiBEb2Vzbid0IG1hdHRlciB3aGF0IGl0IG1hcHMgdG87XG4gICAgICAgICAqIHVzZSB7QGxpbmsgQm9vbGVhbiNUUlVFfS5cbiAgICAgICAgICovXG4gICAgICAgIERlY29kZUhpbnRUeXBlW0RlY29kZUhpbnRUeXBlW1wiUFVSRV9CQVJDT0RFXCJdID0gMV0gPSBcIlBVUkVfQkFSQ09ERVwiOyAvKihWb2lkLmNsYXNzKSovXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbWFnZSBpcyBrbm93biB0byBiZSBvZiBvbmUgb2YgYSBmZXcgcG9zc2libGUgZm9ybWF0cy5cbiAgICAgICAgICogTWFwcyB0byBhIHtAbGluayBMaXN0fSBvZiB7QGxpbmsgQmFyY29kZUZvcm1hdH1zLlxuICAgICAgICAgKi9cbiAgICAgICAgRGVjb2RlSGludFR5cGVbRGVjb2RlSGludFR5cGVbXCJQT1NTSUJMRV9GT1JNQVRTXCJdID0gMl0gPSBcIlBPU1NJQkxFX0ZPUk1BVFNcIjsgLyooTGlzdC5jbGFzcykqL1xuICAgICAgICAvKipcbiAgICAgICAgICogU3BlbmQgbW9yZSB0aW1lIHRvIHRyeSB0byBmaW5kIGEgYmFyY29kZTsgb3B0aW1pemUgZm9yIGFjY3VyYWN5LCBub3Qgc3BlZWQuXG4gICAgICAgICAqIERvZXNuJ3QgbWF0dGVyIHdoYXQgaXQgbWFwcyB0bzsgdXNlIHtAbGluayBCb29sZWFuI1RSVUV9LlxuICAgICAgICAgKi9cbiAgICAgICAgRGVjb2RlSGludFR5cGVbRGVjb2RlSGludFR5cGVbXCJUUllfSEFSREVSXCJdID0gM10gPSBcIlRSWV9IQVJERVJcIjsgLyooVm9pZC5jbGFzcykqL1xuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmaWVzIHdoYXQgY2hhcmFjdGVyIGVuY29kaW5nIHRvIHVzZSB3aGVuIGRlY29kaW5nLCB3aGVyZSBhcHBsaWNhYmxlICh0eXBlIFN0cmluZylcbiAgICAgICAgICovXG4gICAgICAgIERlY29kZUhpbnRUeXBlW0RlY29kZUhpbnRUeXBlW1wiQ0hBUkFDVEVSX1NFVFwiXSA9IDRdID0gXCJDSEFSQUNURVJfU0VUXCI7IC8qKFN0cmluZy5jbGFzcykqL1xuICAgICAgICAvKipcbiAgICAgICAgICogQWxsb3dlZCBsZW5ndGhzIG9mIGVuY29kZWQgZGF0YSAtLSByZWplY3QgYW55dGhpbmcgZWxzZS4gTWFwcyB0byBhbiB7QGNvZGUgSW50MzJBcnJheX0uXG4gICAgICAgICAqL1xuICAgICAgICBEZWNvZGVIaW50VHlwZVtEZWNvZGVIaW50VHlwZVtcIkFMTE9XRURfTEVOR1RIU1wiXSA9IDVdID0gXCJBTExPV0VEX0xFTkdUSFNcIjsgLyooSW50MzJBcnJheS5jbGFzcykqL1xuICAgICAgICAvKipcbiAgICAgICAgICogQXNzdW1lIENvZGUgMzkgY29kZXMgZW1wbG95IGEgY2hlY2sgZGlnaXQuIERvZXNuJ3QgbWF0dGVyIHdoYXQgaXQgbWFwcyB0bztcbiAgICAgICAgICogdXNlIHtAbGluayBCb29sZWFuI1RSVUV9LlxuICAgICAgICAgKi9cbiAgICAgICAgRGVjb2RlSGludFR5cGVbRGVjb2RlSGludFR5cGVbXCJBU1NVTUVfQ09ERV8zOV9DSEVDS19ESUdJVFwiXSA9IDZdID0gXCJBU1NVTUVfQ09ERV8zOV9DSEVDS19ESUdJVFwiOyAvKihWb2lkLmNsYXNzKSovXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBc3N1bWUgdGhlIGJhcmNvZGUgaXMgYmVpbmcgcHJvY2Vzc2VkIGFzIGEgR1MxIGJhcmNvZGUsIGFuZCBtb2RpZnkgYmVoYXZpb3IgYXMgbmVlZGVkLlxuICAgICAgICAgKiBGb3IgZXhhbXBsZSB0aGlzIGFmZmVjdHMgRk5DMSBoYW5kbGluZyBmb3IgQ29kZSAxMjggKGFrYSBHUzEtMTI4KS4gRG9lc24ndCBtYXR0ZXIgd2hhdCBpdCBtYXBzIHRvO1xuICAgICAgICAgKiB1c2Uge0BsaW5rIEJvb2xlYW4jVFJVRX0uXG4gICAgICAgICAqL1xuICAgICAgICBEZWNvZGVIaW50VHlwZVtEZWNvZGVIaW50VHlwZVtcIkFTU1VNRV9HUzFcIl0gPSA3XSA9IFwiQVNTVU1FX0dTMVwiOyAvKihWb2lkLmNsYXNzKSovXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB0cnVlLCByZXR1cm4gdGhlIHN0YXJ0IGFuZCBlbmQgZGlnaXRzIGluIGEgQ29kYWJhciBiYXJjb2RlIGluc3RlYWQgb2Ygc3RyaXBwaW5nIHRoZW0uIFRoZXlcbiAgICAgICAgICogYXJlIGFscGhhLCB3aGVyZWFzIHRoZSByZXN0IGFyZSBudW1lcmljLiBCeSBkZWZhdWx0LCB0aGV5IGFyZSBzdHJpcHBlZCwgYnV0IHRoaXMgY2F1c2VzIHRoZW1cbiAgICAgICAgICogdG8gbm90IGJlLiBEb2Vzbid0IG1hdHRlciB3aGF0IGl0IG1hcHMgdG87IHVzZSB7QGxpbmsgQm9vbGVhbiNUUlVFfS5cbiAgICAgICAgICovXG4gICAgICAgIERlY29kZUhpbnRUeXBlW0RlY29kZUhpbnRUeXBlW1wiUkVUVVJOX0NPREFCQVJfU1RBUlRfRU5EXCJdID0gOF0gPSBcIlJFVFVSTl9DT0RBQkFSX1NUQVJUX0VORFwiOyAvKihWb2lkLmNsYXNzKSovXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY2FsbGVyIG5lZWRzIHRvIGJlIG5vdGlmaWVkIHZpYSBjYWxsYmFjayB3aGVuIGEgcG9zc2libGUge0BsaW5rIFJlc3VsdFBvaW50fVxuICAgICAgICAgKiBpcyBmb3VuZC4gTWFwcyB0byBhIHtAbGluayBSZXN1bHRQb2ludENhbGxiYWNrfS5cbiAgICAgICAgICovXG4gICAgICAgIERlY29kZUhpbnRUeXBlW0RlY29kZUhpbnRUeXBlW1wiTkVFRF9SRVNVTFRfUE9JTlRfQ0FMTEJBQ0tcIl0gPSA5XSA9IFwiTkVFRF9SRVNVTFRfUE9JTlRfQ0FMTEJBQ0tcIjsgLyooUmVzdWx0UG9pbnRDYWxsYmFjay5jbGFzcykqL1xuICAgICAgICAvKipcbiAgICAgICAgICogQWxsb3dlZCBleHRlbnNpb24gbGVuZ3RocyBmb3IgRUFOIG9yIFVQQyBiYXJjb2Rlcy4gT3RoZXIgZm9ybWF0cyB3aWxsIGlnbm9yZSB0aGlzLlxuICAgICAgICAgKiBNYXBzIHRvIGFuIHtAY29kZSBJbnQzMkFycmF5fSBvZiB0aGUgYWxsb3dlZCBleHRlbnNpb24gbGVuZ3RocywgZm9yIGV4YW1wbGUgWzJdLCBbNV0sIG9yIFsyLCA1XS5cbiAgICAgICAgICogSWYgaXQgaXMgb3B0aW9uYWwgdG8gaGF2ZSBhbiBleHRlbnNpb24sIGRvIG5vdCBzZXQgdGhpcyBoaW50LiBJZiB0aGlzIGlzIHNldCxcbiAgICAgICAgICogYW5kIGEgVVBDIG9yIEVBTiBiYXJjb2RlIGlzIGZvdW5kIGJ1dCBhbiBleHRlbnNpb24gaXMgbm90LCB0aGVuIG5vIHJlc3VsdCB3aWxsIGJlIHJldHVybmVkXG4gICAgICAgICAqIGF0IGFsbC5cbiAgICAgICAgICovXG4gICAgICAgIERlY29kZUhpbnRUeXBlW0RlY29kZUhpbnRUeXBlW1wiQUxMT1dFRF9FQU5fRVhURU5TSU9OU1wiXSA9IDEwXSA9IFwiQUxMT1dFRF9FQU5fRVhURU5TSU9OU1wiOyAvKihJbnQzMkFycmF5LmNsYXNzKSovXG4gICAgICAgIC8vIEVuZCBvZiBlbnVtZXJhdGlvbiB2YWx1ZXMuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEYXRhIHR5cGUgdGhlIGhpbnQgaXMgZXhwZWN0aW5nLlxuICAgICAgICAgKiBBbW9uZyB0aGUgcG9zc2libGUgdmFsdWVzIHRoZSB7QGxpbmsgVm9pZH0gc3RhbmRzIG91dCBhcyBiZWluZyB1c2VkIGZvclxuICAgICAgICAgKiBoaW50cyB0aGF0IGRvIG5vdCBleHBlY3QgYSB2YWx1ZSB0byBiZSBzdXBwbGllZCAoZmxhZyBoaW50cykuIFN1Y2ggaGludHNcbiAgICAgICAgICogd2lsbCBwb3NzaWJseSBoYXZlIHRoZWlyIHZhbHVlIGlnbm9yZWQsIG9yIHJlcGxhY2VkIGJ5IGFcbiAgICAgICAgICoge0BsaW5rIEJvb2xlYW4jVFJVRX0uIEhpbnQgc3VwcGxpZXJzIHNob3VsZCBwcm9iYWJseSB1c2VcbiAgICAgICAgICoge0BsaW5rIEJvb2xlYW4jVFJVRX0gYXMgZGlyZWN0ZWQgYnkgdGhlIGFjdHVhbCBoaW50IGRvY3VtZW50YXRpb24uXG4gICAgICAgICAqL1xuICAgICAgICAvLyBwcml2YXRlIHZhbHVlVHlwZTogQ2xhc3M8Pz5cbiAgICAgICAgLy8gRGVjb2RlSGludFR5cGUodmFsdWVUeXBlOiBDbGFzczw/Pikge1xuICAgICAgICAvLyAgIHRoaXMudmFsdWVUeXBlID0gdmFsdWVUeXBlXG4gICAgICAgIC8vIH1cbiAgICAgICAgLy8gcHVibGljIGdldFZhbHVlVHlwZSgpOiBDbGFzczw/PiB7XG4gICAgICAgIC8vICAgcmV0dXJuIHZhbHVlVHlwZVxuICAgICAgICAvLyB9XG4gICAgfSkoRGVjb2RlSGludFR5cGUgfHwgKERlY29kZUhpbnRUeXBlID0ge30pKTtcbiAgICB2YXIgRGVjb2RlSGludFR5cGUkMSA9IERlY29kZUhpbnRUeXBlO1xuXG4gICAgLyoqXG4gICAgICogQ3VzdG9tIEVycm9yIGNsYXNzIG9mIHR5cGUgRXhjZXB0aW9uLlxuICAgICAqL1xuICAgIGNsYXNzIEZvcm1hdEV4Y2VwdGlvbiBleHRlbmRzIEV4Y2VwdGlvbiB7XG4gICAgICAgIHN0YXRpYyBnZXRGb3JtYXRJbnN0YW5jZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRm9ybWF0RXhjZXB0aW9uKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgRm9ybWF0RXhjZXB0aW9uLmtpbmQgPSAnRm9ybWF0RXhjZXB0aW9uJztcblxuICAgIC8qaW1wb3J0IGphdmEudXRpbC5IYXNoTWFwOyovXG4gICAgLyppbXBvcnQgamF2YS51dGlsLk1hcDsqL1xuICAgIHZhciBDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzO1xuICAgIChmdW5jdGlvbiAoQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVycykge1xuICAgICAgICBDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW0NoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnNbXCJDcDQzN1wiXSA9IDBdID0gXCJDcDQzN1wiO1xuICAgICAgICBDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW0NoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnNbXCJJU084ODU5XzFcIl0gPSAxXSA9IFwiSVNPODg1OV8xXCI7XG4gICAgICAgIENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnNbQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tcIklTTzg4NTlfMlwiXSA9IDJdID0gXCJJU084ODU5XzJcIjtcbiAgICAgICAgQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW1wiSVNPODg1OV8zXCJdID0gM10gPSBcIklTTzg4NTlfM1wiO1xuICAgICAgICBDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW0NoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnNbXCJJU084ODU5XzRcIl0gPSA0XSA9IFwiSVNPODg1OV80XCI7XG4gICAgICAgIENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnNbQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tcIklTTzg4NTlfNVwiXSA9IDVdID0gXCJJU084ODU5XzVcIjtcbiAgICAgICAgQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW1wiSVNPODg1OV82XCJdID0gNl0gPSBcIklTTzg4NTlfNlwiO1xuICAgICAgICBDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW0NoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnNbXCJJU084ODU5XzdcIl0gPSA3XSA9IFwiSVNPODg1OV83XCI7XG4gICAgICAgIENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnNbQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tcIklTTzg4NTlfOFwiXSA9IDhdID0gXCJJU084ODU5XzhcIjtcbiAgICAgICAgQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW1wiSVNPODg1OV85XCJdID0gOV0gPSBcIklTTzg4NTlfOVwiO1xuICAgICAgICBDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW0NoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnNbXCJJU084ODU5XzEwXCJdID0gMTBdID0gXCJJU084ODU5XzEwXCI7XG4gICAgICAgIENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnNbQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tcIklTTzg4NTlfMTFcIl0gPSAxMV0gPSBcIklTTzg4NTlfMTFcIjtcbiAgICAgICAgQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW1wiSVNPODg1OV8xM1wiXSA9IDEyXSA9IFwiSVNPODg1OV8xM1wiO1xuICAgICAgICBDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW0NoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnNbXCJJU084ODU5XzE0XCJdID0gMTNdID0gXCJJU084ODU5XzE0XCI7XG4gICAgICAgIENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnNbQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tcIklTTzg4NTlfMTVcIl0gPSAxNF0gPSBcIklTTzg4NTlfMTVcIjtcbiAgICAgICAgQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW1wiSVNPODg1OV8xNlwiXSA9IDE1XSA9IFwiSVNPODg1OV8xNlwiO1xuICAgICAgICBDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW0NoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnNbXCJTSklTXCJdID0gMTZdID0gXCJTSklTXCI7XG4gICAgICAgIENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnNbQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tcIkNwMTI1MFwiXSA9IDE3XSA9IFwiQ3AxMjUwXCI7XG4gICAgICAgIENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnNbQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tcIkNwMTI1MVwiXSA9IDE4XSA9IFwiQ3AxMjUxXCI7XG4gICAgICAgIENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnNbQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tcIkNwMTI1MlwiXSA9IDE5XSA9IFwiQ3AxMjUyXCI7XG4gICAgICAgIENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnNbQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tcIkNwMTI1NlwiXSA9IDIwXSA9IFwiQ3AxMjU2XCI7XG4gICAgICAgIENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnNbQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tcIlVuaWNvZGVCaWdVbm1hcmtlZFwiXSA9IDIxXSA9IFwiVW5pY29kZUJpZ1VubWFya2VkXCI7XG4gICAgICAgIENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnNbQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tcIlVURjhcIl0gPSAyMl0gPSBcIlVURjhcIjtcbiAgICAgICAgQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW1wiQVNDSUlcIl0gPSAyM10gPSBcIkFTQ0lJXCI7XG4gICAgICAgIENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnNbQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tcIkJpZzVcIl0gPSAyNF0gPSBcIkJpZzVcIjtcbiAgICAgICAgQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW1wiR0IxODAzMFwiXSA9IDI1XSA9IFwiR0IxODAzMFwiO1xuICAgICAgICBDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW0NoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnNbXCJFVUNfS1JcIl0gPSAyNl0gPSBcIkVVQ19LUlwiO1xuICAgIH0pKENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnMgfHwgKENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnMgPSB7fSkpO1xuICAgIC8qKlxuICAgICAqIEVuY2Fwc3VsYXRlcyBhIENoYXJhY3RlciBTZXQgRUNJLCBhY2NvcmRpbmcgdG8gXCJFeHRlbmRlZCBDaGFubmVsIEludGVycHJldGF0aW9uc1wiIDUuMy4xLjFcbiAgICAgKiBvZiBJU08gMTgwMDQuXG4gICAgICpcbiAgICAgKiBAYXV0aG9yIFNlYW4gT3dlblxuICAgICAqL1xuICAgIGNsYXNzIENoYXJhY3RlclNldEVDSSB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHZhbHVlSWRlbnRpZmllciwgdmFsdWVzUGFyYW0sIG5hbWUsIC4uLm90aGVyRW5jb2RpbmdOYW1lcykge1xuICAgICAgICAgICAgdGhpcy52YWx1ZUlkZW50aWZpZXIgPSB2YWx1ZUlkZW50aWZpZXI7XG4gICAgICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZXNQYXJhbSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlcyA9IEludDMyQXJyYXkuZnJvbShbdmFsdWVzUGFyYW1dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWVzID0gdmFsdWVzUGFyYW07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm90aGVyRW5jb2RpbmdOYW1lcyA9IG90aGVyRW5jb2RpbmdOYW1lcztcbiAgICAgICAgICAgIENoYXJhY3RlclNldEVDSS5WQUxVRV9JREVOVElGSUVSX1RPX0VDSS5zZXQodmFsdWVJZGVudGlmaWVyLCB0aGlzKTtcbiAgICAgICAgICAgIENoYXJhY3RlclNldEVDSS5OQU1FX1RPX0VDSS5zZXQobmFtZSwgdGhpcyk7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZXMgPSB0aGlzLnZhbHVlcztcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW5ndGggPSB2YWx1ZXMubGVuZ3RoOyBpICE9PSBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHYgPSB2YWx1ZXNbaV07XG4gICAgICAgICAgICAgICAgQ2hhcmFjdGVyU2V0RUNJLlZBTFVFU19UT19FQ0kuc2V0KHYsIHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCBvdGhlck5hbWUgb2Ygb3RoZXJFbmNvZGluZ05hbWVzKSB7XG4gICAgICAgICAgICAgICAgQ2hhcmFjdGVyU2V0RUNJLk5BTUVfVE9fRUNJLnNldChvdGhlck5hbWUsIHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIENoYXJhY3RlclNldEVDSSh2YWx1ZTogbnVtYmVyIC8qaW50Ki8pIHtcbiAgICAgICAgLy8gICB0aGlzKG5ldyBJbnQzMkFycmF5IHt2YWx1ZX0pXG4gICAgICAgIC8vIH1cbiAgICAgICAgLy8gQ2hhcmFjdGVyU2V0RUNJKHZhbHVlOiBudW1iZXIgLyppbnQqLywgU3RyaW5nLi4uIG90aGVyRW5jb2RpbmdOYW1lcykge1xuICAgICAgICAvLyAgIHRoaXMudmFsdWVzID0gbmV3IEludDMyQXJyYXkge3ZhbHVlfVxuICAgICAgICAvLyAgIHRoaXMub3RoZXJFbmNvZGluZ05hbWVzID0gb3RoZXJFbmNvZGluZ05hbWVzXG4gICAgICAgIC8vIH1cbiAgICAgICAgLy8gQ2hhcmFjdGVyU2V0RUNJKHZhbHVlczogSW50MzJBcnJheSwgU3RyaW5nLi4uIG90aGVyRW5jb2RpbmdOYW1lcykge1xuICAgICAgICAvLyAgIHRoaXMudmFsdWVzID0gdmFsdWVzXG4gICAgICAgIC8vICAgdGhpcy5vdGhlckVuY29kaW5nTmFtZXMgPSBvdGhlckVuY29kaW5nTmFtZXNcbiAgICAgICAgLy8gfVxuICAgICAgICBnZXRWYWx1ZUlkZW50aWZpZXIoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZUlkZW50aWZpZXI7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0TmFtZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0VmFsdWUoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZXNbMF07XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB2YWx1ZSBjaGFyYWN0ZXIgc2V0IEVDSSB2YWx1ZVxuICAgICAgICAgKiBAcmV0dXJuIHtAY29kZSBDaGFyYWN0ZXJTZXRFQ0l9IHJlcHJlc2VudGluZyBFQ0kgb2YgZ2l2ZW4gdmFsdWUsIG9yIG51bGwgaWYgaXQgaXMgbGVnYWwgYnV0XG4gICAgICAgICAqICAgdW5zdXBwb3J0ZWRcbiAgICAgICAgICogQHRocm93cyBGb3JtYXRFeGNlcHRpb24gaWYgRUNJIHZhbHVlIGlzIGludmFsaWRcbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBnZXRDaGFyYWN0ZXJTZXRFQ0lCeVZhbHVlKHZhbHVlIC8qaW50Ki8pIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA8IDAgfHwgdmFsdWUgPj0gOTAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbignaW5jb3JlY3QgdmFsdWUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNoYXJhY3RlclNldCA9IENoYXJhY3RlclNldEVDSS5WQUxVRVNfVE9fRUNJLmdldCh2YWx1ZSk7XG4gICAgICAgICAgICBpZiAodW5kZWZpbmVkID09PSBjaGFyYWN0ZXJTZXQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uKCdpbmNvcmVjdCB2YWx1ZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNoYXJhY3RlclNldDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIG5hbWUgY2hhcmFjdGVyIHNldCBFQ0kgZW5jb2RpbmcgbmFtZVxuICAgICAgICAgKiBAcmV0dXJuIENoYXJhY3RlclNldEVDSSByZXByZXNlbnRpbmcgRUNJIGZvciBjaGFyYWN0ZXIgZW5jb2RpbmcsIG9yIG51bGwgaWYgaXQgaXMgbGVnYWxcbiAgICAgICAgICogICBidXQgdW5zdXBwb3J0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBnZXRDaGFyYWN0ZXJTZXRFQ0lCeU5hbWUobmFtZSkge1xuICAgICAgICAgICAgY29uc3QgY2hhcmFjdGVyU2V0ID0gQ2hhcmFjdGVyU2V0RUNJLk5BTUVfVE9fRUNJLmdldChuYW1lKTtcbiAgICAgICAgICAgIGlmICh1bmRlZmluZWQgPT09IGNoYXJhY3RlclNldCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb24oJ2luY29yZWN0IHZhbHVlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY2hhcmFjdGVyU2V0O1xuICAgICAgICB9XG4gICAgICAgIGVxdWFscyhvKSB7XG4gICAgICAgICAgICBpZiAoIShvIGluc3RhbmNlb2YgQ2hhcmFjdGVyU2V0RUNJKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG90aGVyID0gbztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldE5hbWUoKSA9PT0gb3RoZXIuZ2V0TmFtZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIENoYXJhY3RlclNldEVDSS5WQUxVRV9JREVOVElGSUVSX1RPX0VDSSA9IG5ldyBNYXAoKTtcbiAgICBDaGFyYWN0ZXJTZXRFQ0kuVkFMVUVTX1RPX0VDSSA9IG5ldyBNYXAoKTtcbiAgICBDaGFyYWN0ZXJTZXRFQ0kuTkFNRV9UT19FQ0kgPSBuZXcgTWFwKCk7XG4gICAgLy8gRW51bSBuYW1lIGlzIGEgSmF2YSBlbmNvZGluZyB2YWxpZCBmb3IgamF2YS5sYW5nIGFuZCBqYXZhLmlvXG4gICAgLy8gVFlQRVNDUklQVFBPUlQ6IGNoYW5nZWQgdGhlIG1haW4gbGFiZWwgZm9yIElTTyBhcyB0aGUgVGV4dEVuY29kZXIgZGlkIG5vdCByZWNvZ25pemVkIHRoZW0gaW4gdGhlIGZvcm0gZnJvbSBqYXZhXG4gICAgLy8gKGVnIElTTzg4NTlfMSBtdXN0IGJlIElTTzg4NTkxIG9yIElTTzg4NTktMSBvciBJU08tODg1OS0xKVxuICAgIC8vIGxhdGVyIG9uOiB3ZWxsLCBleGNlcHQgMTYgd2ljaCBkb2VzIG5vdCB3b3JrIHdpdGggSVNPODg1OTE2IHNvIHVzZWQgSVNPLTg4NTktMSBmb3JtIGZvciBkZWZhdWx0XG4gICAgQ2hhcmFjdGVyU2V0RUNJLkNwNDM3ID0gbmV3IENoYXJhY3RlclNldEVDSShDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzLkNwNDM3LCBJbnQzMkFycmF5LmZyb20oWzAsIDJdKSwgJ0NwNDM3Jyk7XG4gICAgQ2hhcmFjdGVyU2V0RUNJLklTTzg4NTlfMSA9IG5ldyBDaGFyYWN0ZXJTZXRFQ0koQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVycy5JU084ODU5XzEsIEludDMyQXJyYXkuZnJvbShbMSwgM10pLCAnSVNPLTg4NTktMScsICdJU084ODU5MScsICdJU084ODU5XzEnKTtcbiAgICBDaGFyYWN0ZXJTZXRFQ0kuSVNPODg1OV8yID0gbmV3IENoYXJhY3RlclNldEVDSShDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzLklTTzg4NTlfMiwgNCwgJ0lTTy04ODU5LTInLCAnSVNPODg1OTInLCAnSVNPODg1OV8yJyk7XG4gICAgQ2hhcmFjdGVyU2V0RUNJLklTTzg4NTlfMyA9IG5ldyBDaGFyYWN0ZXJTZXRFQ0koQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVycy5JU084ODU5XzMsIDUsICdJU08tODg1OS0zJywgJ0lTTzg4NTkzJywgJ0lTTzg4NTlfMycpO1xuICAgIENoYXJhY3RlclNldEVDSS5JU084ODU5XzQgPSBuZXcgQ2hhcmFjdGVyU2V0RUNJKENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnMuSVNPODg1OV80LCA2LCAnSVNPLTg4NTktNCcsICdJU084ODU5NCcsICdJU084ODU5XzQnKTtcbiAgICBDaGFyYWN0ZXJTZXRFQ0kuSVNPODg1OV81ID0gbmV3IENoYXJhY3RlclNldEVDSShDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzLklTTzg4NTlfNSwgNywgJ0lTTy04ODU5LTUnLCAnSVNPODg1OTUnLCAnSVNPODg1OV81Jyk7XG4gICAgQ2hhcmFjdGVyU2V0RUNJLklTTzg4NTlfNiA9IG5ldyBDaGFyYWN0ZXJTZXRFQ0koQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVycy5JU084ODU5XzYsIDgsICdJU08tODg1OS02JywgJ0lTTzg4NTk2JywgJ0lTTzg4NTlfNicpO1xuICAgIENoYXJhY3RlclNldEVDSS5JU084ODU5XzcgPSBuZXcgQ2hhcmFjdGVyU2V0RUNJKENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnMuSVNPODg1OV83LCA5LCAnSVNPLTg4NTktNycsICdJU084ODU5NycsICdJU084ODU5XzcnKTtcbiAgICBDaGFyYWN0ZXJTZXRFQ0kuSVNPODg1OV84ID0gbmV3IENoYXJhY3RlclNldEVDSShDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzLklTTzg4NTlfOCwgMTAsICdJU08tODg1OS04JywgJ0lTTzg4NTk4JywgJ0lTTzg4NTlfOCcpO1xuICAgIENoYXJhY3RlclNldEVDSS5JU084ODU5XzkgPSBuZXcgQ2hhcmFjdGVyU2V0RUNJKENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnMuSVNPODg1OV85LCAxMSwgJ0lTTy04ODU5LTknLCAnSVNPODg1OTknLCAnSVNPODg1OV85Jyk7XG4gICAgQ2hhcmFjdGVyU2V0RUNJLklTTzg4NTlfMTAgPSBuZXcgQ2hhcmFjdGVyU2V0RUNJKENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnMuSVNPODg1OV8xMCwgMTIsICdJU08tODg1OS0xMCcsICdJU084ODU5MTAnLCAnSVNPODg1OV8xMCcpO1xuICAgIENoYXJhY3RlclNldEVDSS5JU084ODU5XzExID0gbmV3IENoYXJhY3RlclNldEVDSShDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzLklTTzg4NTlfMTEsIDEzLCAnSVNPLTg4NTktMTEnLCAnSVNPODg1OTExJywgJ0lTTzg4NTlfMTEnKTtcbiAgICBDaGFyYWN0ZXJTZXRFQ0kuSVNPODg1OV8xMyA9IG5ldyBDaGFyYWN0ZXJTZXRFQ0koQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVycy5JU084ODU5XzEzLCAxNSwgJ0lTTy04ODU5LTEzJywgJ0lTTzg4NTkxMycsICdJU084ODU5XzEzJyk7XG4gICAgQ2hhcmFjdGVyU2V0RUNJLklTTzg4NTlfMTQgPSBuZXcgQ2hhcmFjdGVyU2V0RUNJKENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnMuSVNPODg1OV8xNCwgMTYsICdJU08tODg1OS0xNCcsICdJU084ODU5MTQnLCAnSVNPODg1OV8xNCcpO1xuICAgIENoYXJhY3RlclNldEVDSS5JU084ODU5XzE1ID0gbmV3IENoYXJhY3RlclNldEVDSShDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzLklTTzg4NTlfMTUsIDE3LCAnSVNPLTg4NTktMTUnLCAnSVNPODg1OTE1JywgJ0lTTzg4NTlfMTUnKTtcbiAgICBDaGFyYWN0ZXJTZXRFQ0kuSVNPODg1OV8xNiA9IG5ldyBDaGFyYWN0ZXJTZXRFQ0koQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVycy5JU084ODU5XzE2LCAxOCwgJ0lTTy04ODU5LTE2JywgJ0lTTzg4NTkxNicsICdJU084ODU5XzE2Jyk7XG4gICAgQ2hhcmFjdGVyU2V0RUNJLlNKSVMgPSBuZXcgQ2hhcmFjdGVyU2V0RUNJKENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnMuU0pJUywgMjAsICdTSklTJywgJ1NoaWZ0X0pJUycpO1xuICAgIENoYXJhY3RlclNldEVDSS5DcDEyNTAgPSBuZXcgQ2hhcmFjdGVyU2V0RUNJKENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnMuQ3AxMjUwLCAyMSwgJ0NwMTI1MCcsICd3aW5kb3dzLTEyNTAnKTtcbiAgICBDaGFyYWN0ZXJTZXRFQ0kuQ3AxMjUxID0gbmV3IENoYXJhY3RlclNldEVDSShDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzLkNwMTI1MSwgMjIsICdDcDEyNTEnLCAnd2luZG93cy0xMjUxJyk7XG4gICAgQ2hhcmFjdGVyU2V0RUNJLkNwMTI1MiA9IG5ldyBDaGFyYWN0ZXJTZXRFQ0koQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVycy5DcDEyNTIsIDIzLCAnQ3AxMjUyJywgJ3dpbmRvd3MtMTI1MicpO1xuICAgIENoYXJhY3RlclNldEVDSS5DcDEyNTYgPSBuZXcgQ2hhcmFjdGVyU2V0RUNJKENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnMuQ3AxMjU2LCAyNCwgJ0NwMTI1NicsICd3aW5kb3dzLTEyNTYnKTtcbiAgICBDaGFyYWN0ZXJTZXRFQ0kuVW5pY29kZUJpZ1VubWFya2VkID0gbmV3IENoYXJhY3RlclNldEVDSShDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzLlVuaWNvZGVCaWdVbm1hcmtlZCwgMjUsICdVbmljb2RlQmlnVW5tYXJrZWQnLCAnVVRGLTE2QkUnLCAnVW5pY29kZUJpZycpO1xuICAgIENoYXJhY3RlclNldEVDSS5VVEY4ID0gbmV3IENoYXJhY3RlclNldEVDSShDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzLlVURjgsIDI2LCAnVVRGOCcsICdVVEYtOCcpO1xuICAgIENoYXJhY3RlclNldEVDSS5BU0NJSSA9IG5ldyBDaGFyYWN0ZXJTZXRFQ0koQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVycy5BU0NJSSwgSW50MzJBcnJheS5mcm9tKFsyNywgMTcwXSksICdBU0NJSScsICdVUy1BU0NJSScpO1xuICAgIENoYXJhY3RlclNldEVDSS5CaWc1ID0gbmV3IENoYXJhY3RlclNldEVDSShDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzLkJpZzUsIDI4LCAnQmlnNScpO1xuICAgIENoYXJhY3RlclNldEVDSS5HQjE4MDMwID0gbmV3IENoYXJhY3RlclNldEVDSShDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzLkdCMTgwMzAsIDI5LCAnR0IxODAzMCcsICdHQjIzMTInLCAnRVVDX0NOJywgJ0dCSycpO1xuICAgIENoYXJhY3RlclNldEVDSS5FVUNfS1IgPSBuZXcgQ2hhcmFjdGVyU2V0RUNJKENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnMuRVVDX0tSLCAzMCwgJ0VVQ19LUicsICdFVUMtS1InKTtcblxuICAgIC8qKlxuICAgICAqIEN1c3RvbSBFcnJvciBjbGFzcyBvZiB0eXBlIEV4Y2VwdGlvbi5cbiAgICAgKi9cbiAgICBjbGFzcyBVbnN1cHBvcnRlZE9wZXJhdGlvbkV4Y2VwdGlvbiBleHRlbmRzIEV4Y2VwdGlvbiB7XG4gICAgfVxuICAgIFVuc3VwcG9ydGVkT3BlcmF0aW9uRXhjZXB0aW9uLmtpbmQgPSAnVW5zdXBwb3J0ZWRPcGVyYXRpb25FeGNlcHRpb24nO1xuXG4gICAgLyoqXG4gICAgICogUmVzcG9uc2libGUgZm9yIGVuL2RlY29kaW5nIHN0cmluZ3MuXG4gICAgICovXG4gICAgY2xhc3MgU3RyaW5nRW5jb2Rpbmcge1xuICAgICAgICAvKipcbiAgICAgICAgICogRGVjb2RlcyBzb21lIFVpbnQ4QXJyYXkgdG8gYSBzdHJpbmcgZm9ybWF0LlxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGRlY29kZShieXRlcywgZW5jb2RpbmcpIHtcbiAgICAgICAgICAgIGNvbnN0IGVuY29kaW5nTmFtZSA9IHRoaXMuZW5jb2RpbmdOYW1lKGVuY29kaW5nKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmN1c3RvbURlY29kZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jdXN0b21EZWNvZGVyKGJ5dGVzLCBlbmNvZGluZ05hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSW5jcmVhc2VzIGJyb3dzZXIgc3VwcG9ydC5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgVGV4dERlY29kZXIgPT09ICd1bmRlZmluZWQnIHx8IHRoaXMuc2hvdWxkRGVjb2RlT25GYWxsYmFjayhlbmNvZGluZ05hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlRmFsbGJhY2soYnl0ZXMsIGVuY29kaW5nTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IFRleHREZWNvZGVyKGVuY29kaW5nTmFtZSkuZGVjb2RlKGJ5dGVzKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ2hlY2tzIGlmIHRoZSBkZWNvZGluZyBtZXRob2Qgc2hvdWxkIHVzZSB0aGUgZmFsbGJhY2sgZm9yIGRlY29kaW5nXG4gICAgICAgICAqIG9uY2UgTm9kZSBUZXh0RGVjb2RlciBkb2Vzbid0IHN1cHBvcnQgYWxsIGVuY29kaW5nIGZvcm1hdHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBlbmNvZGluZ05hbWVcbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBzaG91bGREZWNvZGVPbkZhbGxiYWNrKGVuY29kaW5nTmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuICFTdHJpbmdFbmNvZGluZy5pc0Jyb3dzZXIoKSAmJiBlbmNvZGluZ05hbWUgPT09ICdJU08tODg1OS0xJztcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogRW5jb2RlcyBzb21lIHN0cmluZyBpbnRvIGEgVWludDhBcnJheS5cbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBlbmNvZGUocywgZW5jb2RpbmcpIHtcbiAgICAgICAgICAgIGNvbnN0IGVuY29kaW5nTmFtZSA9IHRoaXMuZW5jb2RpbmdOYW1lKGVuY29kaW5nKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmN1c3RvbUVuY29kZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jdXN0b21FbmNvZGVyKHMsIGVuY29kaW5nTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJbmNyZWFzZXMgYnJvd3NlciBzdXBwb3J0LlxuICAgICAgICAgICAgaWYgKHR5cGVvZiBUZXh0RW5jb2RlciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGVGYWxsYmFjayhzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRleHRFbmNvZGVyIG9ubHkgZW5jb2RlcyB0byBVVEY4IGJ5IGRlZmF1bHQgYXMgc3BlY2lmaWVkIGJ5IGVuY29kaW5nLnNwZWMud2hhdHdnLm9yZ1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShzKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgaXNCcm93c2VyKCkge1xuICAgICAgICAgICAgcmV0dXJuICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB7fS50b1N0cmluZy5jYWxsKHdpbmRvdykgPT09ICdbb2JqZWN0IFdpbmRvd10nKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgc3RyaW5nIHZhbHVlIGZyb20gc29tZSBlbmNvZGluZyBjaGFyYWN0ZXIgc2V0LlxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGVuY29kaW5nTmFtZShlbmNvZGluZykge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgICAgICA/IGVuY29kaW5nXG4gICAgICAgICAgICAgICAgOiBlbmNvZGluZy5nZXROYW1lKCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgY2hhcmFjdGVyIHNldCBmcm9tIHNvbWUgZW5jb2RpbmcgY2hhcmFjdGVyIHNldC5cbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBlbmNvZGluZ0NoYXJhY3RlclNldChlbmNvZGluZykge1xuICAgICAgICAgICAgaWYgKGVuY29kaW5nIGluc3RhbmNlb2YgQ2hhcmFjdGVyU2V0RUNJKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVuY29kaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIENoYXJhY3RlclNldEVDSS5nZXRDaGFyYWN0ZXJTZXRFQ0lCeU5hbWUoZW5jb2RpbmcpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSdW5zIGEgZmFsbGJhY2sgZm9yIHRoZSBuYXRpdmUgZGVjb2RpbmcgZnVuY2lvbi5cbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBkZWNvZGVGYWxsYmFjayhieXRlcywgZW5jb2RpbmcpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYXJhY3RlclNldCA9IHRoaXMuZW5jb2RpbmdDaGFyYWN0ZXJTZXQoZW5jb2RpbmcpO1xuICAgICAgICAgICAgaWYgKFN0cmluZ0VuY29kaW5nLmlzRGVjb2RlRmFsbGJhY2tTdXBwb3J0ZWQoY2hhcmFjdGVyU2V0KSkge1xuICAgICAgICAgICAgICAgIGxldCBzID0gJyc7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbmd0aCA9IGJ5dGVzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBoID0gYnl0ZXNbaV0udG9TdHJpbmcoMTYpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaC5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoID0gJzAnICsgaDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzICs9ICclJyArIGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQocyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2hhcmFjdGVyU2V0LmVxdWFscyhDaGFyYWN0ZXJTZXRFQ0kuVW5pY29kZUJpZ1VubWFya2VkKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIG5ldyBVaW50MTZBcnJheShieXRlcy5idWZmZXIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZE9wZXJhdGlvbkV4Y2VwdGlvbihgRW5jb2RpbmcgJHt0aGlzLmVuY29kaW5nTmFtZShlbmNvZGluZyl9IG5vdCBzdXBwb3J0ZWQgYnkgZmFsbGJhY2suYCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGlzRGVjb2RlRmFsbGJhY2tTdXBwb3J0ZWQoY2hhcmFjdGVyU2V0KSB7XG4gICAgICAgICAgICByZXR1cm4gY2hhcmFjdGVyU2V0LmVxdWFscyhDaGFyYWN0ZXJTZXRFQ0kuVVRGOCkgfHxcbiAgICAgICAgICAgICAgICBjaGFyYWN0ZXJTZXQuZXF1YWxzKENoYXJhY3RlclNldEVDSS5JU084ODU5XzEpIHx8XG4gICAgICAgICAgICAgICAgY2hhcmFjdGVyU2V0LmVxdWFscyhDaGFyYWN0ZXJTZXRFQ0kuQVNDSUkpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSdW5zIGEgZmFsbGJhY2sgZm9yIHRoZSBuYXRpdmUgZW5jb2RpbmcgZnVuY2lvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTcxOTI4NDUvNDM2NzY4M1xuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGVuY29kZUZhbGxiYWNrKHMpIHtcbiAgICAgICAgICAgIGNvbnN0IGVuY29kZWRVUklzdHJpbmcgPSBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChzKSkpO1xuICAgICAgICAgICAgY29uc3QgY2hhckxpc3QgPSBlbmNvZGVkVVJJc3RyaW5nLnNwbGl0KCcnKTtcbiAgICAgICAgICAgIGNvbnN0IHVpbnRBcnJheSA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGFyTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHVpbnRBcnJheS5wdXNoKGNoYXJMaXN0W2ldLmNoYXJDb2RlQXQoMCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHVpbnRBcnJheSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKlxuICAgICAqIENvcHlyaWdodCAoQykgMjAxMCBaWGluZyBhdXRob3JzXG4gICAgICpcbiAgICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgICAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgICAgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgICAgKlxuICAgICAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gICAgICpcbiAgICAgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICAgICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgICAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICAgICAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgICAgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBDb21tb24gc3RyaW5nLXJlbGF0ZWQgZnVuY3Rpb25zLlxuICAgICAqXG4gICAgICogQGF1dGhvciBTZWFuIE93ZW5cbiAgICAgKiBAYXV0aG9yIEFsZXggRHVwcmVcbiAgICAgKi9cbiAgICBjbGFzcyBTdHJpbmdVdGlscyB7XG4gICAgICAgIC8vIFNISUZUX0pJUy5lcXVhbHNJZ25vcmVDYXNlKFBMQVRGT1JNX0RFRkFVTFRfRU5DT0RJTkcpIHx8XG4gICAgICAgIC8vIEVVQ19KUC5lcXVhbHNJZ25vcmVDYXNlKFBMQVRGT1JNX0RFRkFVTFRfRU5DT0RJTkcpO1xuICAgICAgICBzdGF0aWMgY2FzdEFzTm9uVXRmOENoYXIoY29kZSwgZW5jb2RpbmcgPSBudWxsKSB7XG4gICAgICAgICAgICAvLyBJU08gODg1OS0xIGlzIHRoZSBKYXZhIGRlZmF1bHQgYXMgVVRGLTggaXMgSmF2YVNjcmlwdHNcbiAgICAgICAgICAgIC8vIHlvdSBjYW4gc2VlIHRoaXMgbWV0aG9kIGFzIGEgSmF2YSB2ZXJzaW9uIG9mIFN0cmluZy5mcm9tQ2hhckNvZGVcbiAgICAgICAgICAgIGNvbnN0IGUgPSBlbmNvZGluZyA/IGVuY29kaW5nLmdldE5hbWUoKSA6IHRoaXMuSVNPODg1OTE7XG4gICAgICAgICAgICAvLyB1c2UgcGFzc2VkIGZvcm1hdCAoZnJvbUNoYXJDb2RlIHdpbGwgcmV0dXJuIFVURjggZW5jb2RpbmcpXG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nRW5jb2RpbmcuZGVjb2RlKG5ldyBVaW50OEFycmF5KFtjb2RlXSksIGUpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gYnl0ZXMgYnl0ZXMgZW5jb2RpbmcgYSBzdHJpbmcsIHdob3NlIGVuY29kaW5nIHNob3VsZCBiZSBndWVzc2VkXG4gICAgICAgICAqIEBwYXJhbSBoaW50cyBkZWNvZGUgaGludHMgaWYgYXBwbGljYWJsZVxuICAgICAgICAgKiBAcmV0dXJuIG5hbWUgb2YgZ3Vlc3NlZCBlbmNvZGluZzsgYXQgdGhlIG1vbWVudCB3aWxsIG9ubHkgZ3Vlc3Mgb25lIG9mOlxuICAgICAgICAgKiAge0BsaW5rICNTSElGVF9KSVN9LCB7QGxpbmsgI1VURjh9LCB7QGxpbmsgI0lTTzg4NTkxfSwgb3IgdGhlIHBsYXRmb3JtXG4gICAgICAgICAqICBkZWZhdWx0IGVuY29kaW5nIGlmIG5vbmUgb2YgdGhlc2UgY2FuIHBvc3NpYmx5IGJlIGNvcnJlY3RcbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBndWVzc0VuY29kaW5nKGJ5dGVzLCBoaW50cykge1xuICAgICAgICAgICAgaWYgKGhpbnRzICE9PSBudWxsICYmIGhpbnRzICE9PSB1bmRlZmluZWQgJiYgdW5kZWZpbmVkICE9PSBoaW50cy5nZXQoRGVjb2RlSGludFR5cGUkMS5DSEFSQUNURVJfU0VUKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBoaW50cy5nZXQoRGVjb2RlSGludFR5cGUkMS5DSEFSQUNURVJfU0VUKS50b1N0cmluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRm9yIG5vdywgbWVyZWx5IHRyaWVzIHRvIGRpc3Rpbmd1aXNoIElTTy04ODU5LTEsIFVURi04IGFuZCBTaGlmdF9KSVMsXG4gICAgICAgICAgICAvLyB3aGljaCBzaG91bGQgYmUgYnkgZmFyIHRoZSBtb3N0IGNvbW1vbiBlbmNvZGluZ3MuXG4gICAgICAgICAgICBjb25zdCBsZW5ndGggPSBieXRlcy5sZW5ndGg7XG4gICAgICAgICAgICBsZXQgY2FuQmVJU084ODU5MSA9IHRydWU7XG4gICAgICAgICAgICBsZXQgY2FuQmVTaGlmdEpJUyA9IHRydWU7XG4gICAgICAgICAgICBsZXQgY2FuQmVVVEY4ID0gdHJ1ZTtcbiAgICAgICAgICAgIGxldCB1dGY4Qnl0ZXNMZWZ0ID0gMDtcbiAgICAgICAgICAgIC8vIGludCB1dGY4TG93Q2hhcnMgPSAwXG4gICAgICAgICAgICBsZXQgdXRmMkJ5dGVzQ2hhcnMgPSAwO1xuICAgICAgICAgICAgbGV0IHV0ZjNCeXRlc0NoYXJzID0gMDtcbiAgICAgICAgICAgIGxldCB1dGY0Qnl0ZXNDaGFycyA9IDA7XG4gICAgICAgICAgICBsZXQgc2ppc0J5dGVzTGVmdCA9IDA7XG4gICAgICAgICAgICAvLyBpbnQgc2ppc0xvd0NoYXJzID0gMFxuICAgICAgICAgICAgbGV0IHNqaXNLYXRha2FuYUNoYXJzID0gMDtcbiAgICAgICAgICAgIC8vIGludCBzamlzRG91YmxlQnl0ZXNDaGFycyA9IDBcbiAgICAgICAgICAgIGxldCBzamlzQ3VyS2F0YWthbmFXb3JkTGVuZ3RoID0gMDtcbiAgICAgICAgICAgIGxldCBzamlzQ3VyRG91YmxlQnl0ZXNXb3JkTGVuZ3RoID0gMDtcbiAgICAgICAgICAgIGxldCBzamlzTWF4S2F0YWthbmFXb3JkTGVuZ3RoID0gMDtcbiAgICAgICAgICAgIGxldCBzamlzTWF4RG91YmxlQnl0ZXNXb3JkTGVuZ3RoID0gMDtcbiAgICAgICAgICAgIC8vIGludCBpc29Mb3dDaGFycyA9IDBcbiAgICAgICAgICAgIC8vIGludCBpc29IaWdoQ2hhcnMgPSAwXG4gICAgICAgICAgICBsZXQgaXNvSGlnaE90aGVyID0gMDtcbiAgICAgICAgICAgIGNvbnN0IHV0Zjhib20gPSBieXRlcy5sZW5ndGggPiAzICYmXG4gICAgICAgICAgICAgICAgYnl0ZXNbMF0gPT09IC8qKGJ5dGUpICovIDB4RUYgJiZcbiAgICAgICAgICAgICAgICBieXRlc1sxXSA9PT0gLyooYnl0ZSkgKi8gMHhCQiAmJlxuICAgICAgICAgICAgICAgIGJ5dGVzWzJdID09PSAvKihieXRlKSAqLyAweEJGO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGggJiYgKGNhbkJlSVNPODg1OTEgfHwgY2FuQmVTaGlmdEpJUyB8fCBjYW5CZVVURjgpOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGJ5dGVzW2ldICYgMHhGRjtcbiAgICAgICAgICAgICAgICAvLyBVVEYtOCBzdHVmZlxuICAgICAgICAgICAgICAgIGlmIChjYW5CZVVURjgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHV0ZjhCeXRlc0xlZnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHZhbHVlICYgMHg4MCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5CZVVURjggPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHV0ZjhCeXRlc0xlZnQtLTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICgodmFsdWUgJiAweDgwKSAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCh2YWx1ZSAmIDB4NDApID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FuQmVVVEY4ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1dGY4Qnl0ZXNMZWZ0Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCh2YWx1ZSAmIDB4MjApID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHV0ZjJCeXRlc0NoYXJzKys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1dGY4Qnl0ZXNMZWZ0Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgodmFsdWUgJiAweDEwKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXRmM0J5dGVzQ2hhcnMrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHV0ZjhCeXRlc0xlZnQrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgodmFsdWUgJiAweDA4KSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHV0ZjRCeXRlc0NoYXJzKys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5CZVVURjggPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSAvLyBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdXRmOExvd0NoYXJzKytcbiAgICAgICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBJU08tODg1OS0xIHN0dWZmXG4gICAgICAgICAgICAgICAgaWYgKGNhbkJlSVNPODg1OTEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID4gMHg3RiAmJiB2YWx1ZSA8IDB4QTApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbkJlSVNPODg1OTEgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSA+IDB4OUYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA8IDB4QzAgfHwgdmFsdWUgPT09IDB4RDcgfHwgdmFsdWUgPT09IDB4RjcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc29IaWdoT3RoZXIrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gLy8gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpc29IaWdoQ2hhcnMrK1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgICAgICAgICB9IC8vIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBpc29Mb3dDaGFycysrXG4gICAgICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gU2hpZnRfSklTIHN0dWZmXG4gICAgICAgICAgICAgICAgaWYgKGNhbkJlU2hpZnRKSVMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNqaXNCeXRlc0xlZnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPCAweDQwIHx8IHZhbHVlID09PSAweDdGIHx8IHZhbHVlID4gMHhGQykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbkJlU2hpZnRKSVMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNqaXNCeXRlc0xlZnQtLTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSA9PT0gMHg4MCB8fCB2YWx1ZSA9PT0gMHhBMCB8fCB2YWx1ZSA+IDB4RUYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbkJlU2hpZnRKSVMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSA+IDB4QTAgJiYgdmFsdWUgPCAweEUwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzamlzS2F0YWthbmFDaGFycysrO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2ppc0N1ckRvdWJsZUJ5dGVzV29yZExlbmd0aCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBzamlzQ3VyS2F0YWthbmFXb3JkTGVuZ3RoKys7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2ppc0N1ckthdGFrYW5hV29yZExlbmd0aCA+IHNqaXNNYXhLYXRha2FuYVdvcmRMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzamlzTWF4S2F0YWthbmFXb3JkTGVuZ3RoID0gc2ppc0N1ckthdGFrYW5hV29yZExlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSA+IDB4N0YpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNqaXNCeXRlc0xlZnQrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNqaXNEb3VibGVCeXRlc0NoYXJzKytcbiAgICAgICAgICAgICAgICAgICAgICAgIHNqaXNDdXJLYXRha2FuYVdvcmRMZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2ppc0N1ckRvdWJsZUJ5dGVzV29yZExlbmd0aCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNqaXNDdXJEb3VibGVCeXRlc1dvcmRMZW5ndGggPiBzamlzTWF4RG91YmxlQnl0ZXNXb3JkTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2ppc01heERvdWJsZUJ5dGVzV29yZExlbmd0aCA9IHNqaXNDdXJEb3VibGVCeXRlc1dvcmRMZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzamlzTG93Q2hhcnMrK1xuICAgICAgICAgICAgICAgICAgICAgICAgc2ppc0N1ckthdGFrYW5hV29yZExlbmd0aCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBzamlzQ3VyRG91YmxlQnl0ZXNXb3JkTGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjYW5CZVVURjggJiYgdXRmOEJ5dGVzTGVmdCA+IDApIHtcbiAgICAgICAgICAgICAgICBjYW5CZVVURjggPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjYW5CZVNoaWZ0SklTICYmIHNqaXNCeXRlc0xlZnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgY2FuQmVTaGlmdEpJUyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRWFzeSAtLSBpZiB0aGVyZSBpcyBCT00gb3IgYXQgbGVhc3QgMSB2YWxpZCBub3Qtc2luZ2xlIGJ5dGUgY2hhcmFjdGVyIChhbmQgbm8gZXZpZGVuY2UgaXQgY2FuJ3QgYmUgVVRGLTgpLCBkb25lXG4gICAgICAgICAgICBpZiAoY2FuQmVVVEY4ICYmICh1dGY4Ym9tIHx8IHV0ZjJCeXRlc0NoYXJzICsgdXRmM0J5dGVzQ2hhcnMgKyB1dGY0Qnl0ZXNDaGFycyA+IDApKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFN0cmluZ1V0aWxzLlVURjg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBFYXN5IC0tIGlmIGFzc3VtaW5nIFNoaWZ0X0pJUyBvciBhdCBsZWFzdCAzIHZhbGlkIGNvbnNlY3V0aXZlIG5vdC1hc2NpaSBjaGFyYWN0ZXJzIChhbmQgbm8gZXZpZGVuY2UgaXQgY2FuJ3QgYmUpLCBkb25lXG4gICAgICAgICAgICBpZiAoY2FuQmVTaGlmdEpJUyAmJiAoU3RyaW5nVXRpbHMuQVNTVU1FX1NISUZUX0pJUyB8fCBzamlzTWF4S2F0YWthbmFXb3JkTGVuZ3RoID49IDMgfHwgc2ppc01heERvdWJsZUJ5dGVzV29yZExlbmd0aCA+PSAzKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBTdHJpbmdVdGlscy5TSElGVF9KSVM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBEaXN0aW5ndWlzaGluZyBTaGlmdF9KSVMgYW5kIElTTy04ODU5LTEgY2FuIGJlIGEgbGl0dGxlIHRvdWdoIGZvciBzaG9ydCB3b3Jkcy4gVGhlIGNydWRlIGhldXJpc3RpYyBpczpcbiAgICAgICAgICAgIC8vIC0gSWYgd2Ugc2F3XG4gICAgICAgICAgICAvLyAgIC0gb25seSB0d28gY29uc2VjdXRpdmUga2F0YWthbmEgY2hhcnMgaW4gdGhlIHdob2xlIHRleHQsIG9yXG4gICAgICAgICAgICAvLyAgIC0gYXQgbGVhc3QgMTAlIG9mIGJ5dGVzIHRoYXQgY291bGQgYmUgXCJ1cHBlclwiIG5vdC1hbHBoYW51bWVyaWMgTGF0aW4xLFxuICAgICAgICAgICAgLy8gLSB0aGVuIHdlIGNvbmNsdWRlIFNoaWZ0X0pJUywgZWxzZSBJU08tODg1OS0xXG4gICAgICAgICAgICBpZiAoY2FuQmVJU084ODU5MSAmJiBjYW5CZVNoaWZ0SklTKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChzamlzTWF4S2F0YWthbmFXb3JkTGVuZ3RoID09PSAyICYmIHNqaXNLYXRha2FuYUNoYXJzID09PSAyKSB8fCBpc29IaWdoT3RoZXIgKiAxMCA+PSBsZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgPyBTdHJpbmdVdGlscy5TSElGVF9KSVMgOiBTdHJpbmdVdGlscy5JU084ODU5MTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgdHJ5IGluIG9yZGVyIElTTy04ODU5LTEsIFNoaWZ0IEpJUywgVVRGLTggYW5kIGZhbGwgYmFjayB0byBkZWZhdWx0IHBsYXRmb3JtIGVuY29kaW5nXG4gICAgICAgICAgICBpZiAoY2FuQmVJU084ODU5MSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBTdHJpbmdVdGlscy5JU084ODU5MTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjYW5CZVNoaWZ0SklTKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFN0cmluZ1V0aWxzLlNISUZUX0pJUztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjYW5CZVVURjgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gU3RyaW5nVXRpbHMuVVRGODtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgd2UgdGFrZSBhIHdpbGQgZ3Vlc3Mgd2l0aCBwbGF0Zm9ybSBlbmNvZGluZ1xuICAgICAgICAgICAgcmV0dXJuIFN0cmluZ1V0aWxzLlBMQVRGT1JNX0RFRkFVTFRfRU5DT0RJTkc7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqIEBzZWUgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzEzNDM5NzExLzQzNjc2ODNcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGFwcGVuZCBUaGUgbmV3IHN0cmluZyB0byBhcHBlbmQuXG4gICAgICAgICAqIEBwYXJhbSBhcmdzIEFyZ3VtZXRzIHZhbHVlcyB0byBiZSBmb3JtYXRlZC5cbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBmb3JtYXQoYXBwZW5kLCAuLi5hcmdzKSB7XG4gICAgICAgICAgICBsZXQgaSA9IC0xO1xuICAgICAgICAgICAgZnVuY3Rpb24gY2FsbGJhY2soZXhwLCBwMCwgcDEsIHAyLCBwMywgcDQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXhwID09PSAnJSUnKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyUnO1xuICAgICAgICAgICAgICAgIGlmIChhcmdzWysraV0gPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBleHAgPSBwMiA/IHBhcnNlSW50KHAyLnN1YnN0cigxKSkgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgbGV0IGJhc2UgPSBwMyA/IHBhcnNlSW50KHAzLnN1YnN0cigxKSkgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgbGV0IHZhbDtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHA0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3MnOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gYXJnc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdjJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IGFyZ3NbaV1bMF07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZic6XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSBwYXJzZUZsb2F0KGFyZ3NbaV0pLnRvRml4ZWQoZXhwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdwJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IHBhcnNlRmxvYXQoYXJnc1tpXSkudG9QcmVjaXNpb24oZXhwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IHBhcnNlRmxvYXQoYXJnc1tpXSkudG9FeHBvbmVudGlhbChleHApO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3gnOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gcGFyc2VJbnQoYXJnc1tpXSkudG9TdHJpbmcoYmFzZSA/IGJhc2UgOiAxNik7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZCc6XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSBwYXJzZUZsb2F0KHBhcnNlSW50KGFyZ3NbaV0sIGJhc2UgPyBiYXNlIDogMTApLnRvUHJlY2lzaW9uKGV4cCkpLnRvRml4ZWQoMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFsID0gdHlwZW9mIHZhbCA9PT0gJ29iamVjdCcgPyBKU09OLnN0cmluZ2lmeSh2YWwpIDogKCt2YWwpLnRvU3RyaW5nKGJhc2UpO1xuICAgICAgICAgICAgICAgIGxldCBzaXplID0gcGFyc2VJbnQocDEpOyAvKiBwYWRkaW5nIHNpemUgKi9cbiAgICAgICAgICAgICAgICBsZXQgY2ggPSBwMSAmJiAocDFbMF0gKyAnJykgPT09ICcwJyA/ICcwJyA6ICcgJzsgLyogaXNudWxsPyAqL1xuICAgICAgICAgICAgICAgIHdoaWxlICh2YWwubGVuZ3RoIDwgc2l6ZSlcbiAgICAgICAgICAgICAgICAgICAgdmFsID0gcDAgIT09IHVuZGVmaW5lZCA/IHZhbCArIGNoIDogY2ggKyB2YWw7IC8qIGlzbWludXM/ICovXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCByZWdleCA9IC8lKC0pPygwP1swLTldKyk/KFsuXVswLTldKyk/KFsjXVswLTldKyk/KFtzY2ZwZXhkJV0pL2c7XG4gICAgICAgICAgICByZXR1cm4gYXBwZW5kLnJlcGxhY2UocmVnZXgsIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBnZXRCeXRlcyhzdHIsIGVuY29kaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nRW5jb2RpbmcuZW5jb2RlKHN0ciwgZW5jb2RpbmcpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBjaGFyY29kZSBhdCB0aGUgc3BlY2lmaWVkIGluZGV4IG9yIGF0IGluZGV4IHplcm8uXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgZ2V0Q2hhckNvZGUoc3RyLCBpbmRleCA9IDApIHtcbiAgICAgICAgICAgIHJldHVybiBzdHIuY2hhckNvZGVBdChpbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgY2hhciBmb3IgZ2l2ZW4gY2hhcmNvZGVcbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBnZXRDaGFyQXQoY2hhckNvZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoYXJDb2RlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBTdHJpbmdVdGlscy5TSElGVF9KSVMgPSBDaGFyYWN0ZXJTZXRFQ0kuU0pJUy5nZXROYW1lKCk7IC8vIFwiU0pJU1wiXG4gICAgU3RyaW5nVXRpbHMuR0IyMzEyID0gJ0dCMjMxMic7XG4gICAgU3RyaW5nVXRpbHMuSVNPODg1OTEgPSBDaGFyYWN0ZXJTZXRFQ0kuSVNPODg1OV8xLmdldE5hbWUoKTsgLy8gXCJJU084ODU5XzFcIlxuICAgIFN0cmluZ1V0aWxzLkVVQ19KUCA9ICdFVUNfSlAnO1xuICAgIFN0cmluZ1V0aWxzLlVURjggPSBDaGFyYWN0ZXJTZXRFQ0kuVVRGOC5nZXROYW1lKCk7IC8vIFwiVVRGOFwiXG4gICAgU3RyaW5nVXRpbHMuUExBVEZPUk1fREVGQVVMVF9FTkNPRElORyA9IFN0cmluZ1V0aWxzLlVURjg7IC8vIFwiVVRGOFwiLy9DaGFyc2V0LmRlZmF1bHRDaGFyc2V0KCkubmFtZSgpXG4gICAgU3RyaW5nVXRpbHMuQVNTVU1FX1NISUZUX0pJUyA9IGZhbHNlO1xuXG4gICAgY2xhc3MgU3RyaW5nQnVpbGRlciB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHZhbHVlID0gJycpIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbmFibGVEZWNvZGluZyhlbmNvZGluZykge1xuICAgICAgICAgICAgdGhpcy5lbmNvZGluZyA9IGVuY29kaW5nO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgYXBwZW5kKHMpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlICs9IHMudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuZW5jb2RpbmcpIHtcbiAgICAgICAgICAgICAgICAvLyB1c2UgcGFzc2VkIGZvcm1hdCAoZnJvbUNoYXJDb2RlIHdpbGwgcmV0dXJuIFVURjggZW5jb2RpbmcpXG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZSArPSBTdHJpbmdVdGlscy5jYXN0QXNOb25VdGY4Q2hhcihzLCB0aGlzLmVuY29kaW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGNvcnJlY3RseSBjb252ZXJ0cyBmcm9tIFVURi04LCBidXQgbm90IG90aGVyIGVuY29kaW5nc1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGFwcGVuZENoYXJzKHN0ciwgb2Zmc2V0LCBsZW4pIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBvZmZzZXQ7IG9mZnNldCA8IG9mZnNldCArIGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hcHBlbmQoc3RyW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGxlbmd0aCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBjaGFyQXQobikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUuY2hhckF0KG4pO1xuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZUNoYXJBdChuKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy52YWx1ZS5zdWJzdHIoMCwgbikgKyB0aGlzLnZhbHVlLnN1YnN0cmluZyhuICsgMSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0Q2hhckF0KG4sIGMpIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLnZhbHVlLnN1YnN0cigwLCBuKSArIGMgKyB0aGlzLnZhbHVlLnN1YnN0cihuICsgMSk7XG4gICAgICAgIH1cbiAgICAgICAgc3Vic3RyaW5nKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlLnN1YnN0cmluZyhzdGFydCwgZW5kKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQG5vdGUgaGVscGVyIG1ldGhvZCBmb3IgUlNTIEV4cGFuZGVkXG4gICAgICAgICAqL1xuICAgICAgICBzZXRMZW5ndGhUb1plcm8oKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gJyc7XG4gICAgICAgIH1cbiAgICAgICAgdG9TdHJpbmcoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpbnNlcnQobiwgYykge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMudmFsdWUuc3Vic3RyKDAsIG4pICsgYyArIHRoaXMudmFsdWUuc3Vic3RyKG4gKyBjLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKlxuICAgICAqIENvcHlyaWdodCAyMDA3IFpYaW5nIGF1dGhvcnNcbiAgICAgKlxuICAgICAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gICAgICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgICAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgICAqXG4gICAgICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAgICAgKlxuICAgICAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgICAgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICAgICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gICAgICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICAgICAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIDxwPlJlcHJlc2VudHMgYSAyRCBtYXRyaXggb2YgYml0cy4gSW4gZnVuY3Rpb24gYXJndW1lbnRzIGJlbG93LCBhbmQgdGhyb3VnaG91dCB0aGUgY29tbW9uXG4gICAgICogbW9kdWxlLCB4IGlzIHRoZSBjb2x1bW4gcG9zaXRpb24sIGFuZCB5IGlzIHRoZSByb3cgcG9zaXRpb24uIFRoZSBvcmRlcmluZyBpcyBhbHdheXMgeCwgeS5cbiAgICAgKiBUaGUgb3JpZ2luIGlzIGF0IHRoZSB0b3AtbGVmdC48L3A+XG4gICAgICpcbiAgICAgKiA8cD5JbnRlcm5hbGx5IHRoZSBiaXRzIGFyZSByZXByZXNlbnRlZCBpbiBhIDEtRCBhcnJheSBvZiAzMi1iaXQgaW50cy4gSG93ZXZlciwgZWFjaCByb3cgYmVnaW5zXG4gICAgICogd2l0aCBhIG5ldyBpbnQuIFRoaXMgaXMgZG9uZSBpbnRlbnRpb25hbGx5IHNvIHRoYXQgd2UgY2FuIGNvcHkgb3V0IGEgcm93IGludG8gYSBCaXRBcnJheSB2ZXJ5XG4gICAgICogZWZmaWNpZW50bHkuPC9wPlxuICAgICAqXG4gICAgICogPHA+VGhlIG9yZGVyaW5nIG9mIGJpdHMgaXMgcm93LW1ham9yLiBXaXRoaW4gZWFjaCBpbnQsIHRoZSBsZWFzdCBzaWduaWZpY2FudCBiaXRzIGFyZSB1c2VkIGZpcnN0LFxuICAgICAqIG1lYW5pbmcgdGhleSByZXByZXNlbnQgbG93ZXIgeCB2YWx1ZXMuIFRoaXMgaXMgY29tcGF0aWJsZSB3aXRoIEJpdEFycmF5J3MgaW1wbGVtZW50YXRpb24uPC9wPlxuICAgICAqXG4gICAgICogQGF1dGhvciBTZWFuIE93ZW5cbiAgICAgKiBAYXV0aG9yIGRzd2l0a2luQGdvb2dsZS5jb20gKERhbmllbCBTd2l0a2luKVxuICAgICAqL1xuICAgIGNsYXNzIEJpdE1hdHJpeCAvKmltcGxlbWVudHMgQ2xvbmVhYmxlKi8ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhbiBlbXB0eSBzcXVhcmUge0BsaW5rIEJpdE1hdHJpeH0uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBkaW1lbnNpb24gaGVpZ2h0IGFuZCB3aWR0aFxuICAgICAgICAgKi9cbiAgICAgICAgLy8gcHVibGljIGNvbnN0cnVjdG9yKGRpbWVuc2lvbjogbnVtYmVyIC8qaW50Ki8pIHtcbiAgICAgICAgLy8gICB0aGlzKGRpbWVuc2lvbiwgZGltZW5zaW9uKVxuICAgICAgICAvLyB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGFuIGVtcHR5IHtAbGluayBCaXRNYXRyaXh9LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gd2lkdGggYml0IG1hdHJpeCB3aWR0aFxuICAgICAgICAgKiBAcGFyYW0gaGVpZ2h0IGJpdCBtYXRyaXggaGVpZ2h0XG4gICAgICAgICAqL1xuICAgICAgICAvLyBwdWJsaWMgY29uc3RydWN0b3Iod2lkdGg6IG51bWJlciAvKmludCovLCBoZWlnaHQ6IG51bWJlciAvKmludCovKSB7XG4gICAgICAgIC8vICAgaWYgKHdpZHRoIDwgMSB8fCBoZWlnaHQgPCAxKSB7XG4gICAgICAgIC8vICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKFwiQm90aCBkaW1lbnNpb25zIG11c3QgYmUgZ3JlYXRlciB0aGFuIDBcIilcbiAgICAgICAgLy8gICB9XG4gICAgICAgIC8vICAgdGhpcy53aWR0aCA9IHdpZHRoXG4gICAgICAgIC8vICAgdGhpcy5oZWlnaHQgPSBoZWlnaHRcbiAgICAgICAgLy8gICB0aGlzLnJvd1NpemUgPSAod2lkdGggKyAzMSkgLyAzMlxuICAgICAgICAvLyAgIGJpdHMgPSBuZXcgaW50W3Jvd1NpemUgKiBoZWlnaHRdO1xuICAgICAgICAvLyB9XG4gICAgICAgIGNvbnN0cnVjdG9yKHdpZHRoIC8qaW50Ki8sIGhlaWdodCAvKmludCovLCByb3dTaXplIC8qaW50Ki8sIGJpdHMpIHtcbiAgICAgICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICAgICAgdGhpcy5yb3dTaXplID0gcm93U2l6ZTtcbiAgICAgICAgICAgIHRoaXMuYml0cyA9IGJpdHM7XG4gICAgICAgICAgICBpZiAodW5kZWZpbmVkID09PSBoZWlnaHQgfHwgbnVsbCA9PT0gaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gd2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgICAgIGlmICh3aWR0aCA8IDEgfHwgaGVpZ2h0IDwgMSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oJ0JvdGggZGltZW5zaW9ucyBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodW5kZWZpbmVkID09PSByb3dTaXplIHx8IG51bGwgPT09IHJvd1NpemUpIHtcbiAgICAgICAgICAgICAgICByb3dTaXplID0gTWF0aC5mbG9vcigod2lkdGggKyAzMSkgLyAzMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJvd1NpemUgPSByb3dTaXplO1xuICAgICAgICAgICAgaWYgKHVuZGVmaW5lZCA9PT0gYml0cyB8fCBudWxsID09PSBiaXRzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5iaXRzID0gbmV3IEludDMyQXJyYXkodGhpcy5yb3dTaXplICogdGhpcy5oZWlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnRlcnByZXRzIGEgMkQgYXJyYXkgb2YgYm9vbGVhbnMgYXMgYSB7QGxpbmsgQml0TWF0cml4fSwgd2hlcmUgXCJ0cnVlXCIgbWVhbnMgYW4gXCJvblwiIGJpdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQGZ1bmN0aW9uIHBhcnNlXG4gICAgICAgICAqIEBwYXJhbSBpbWFnZSBiaXRzIG9mIHRoZSBpbWFnZSwgYXMgYSByb3ctbWFqb3IgMkQgYXJyYXkuIEVsZW1lbnRzIGFyZSBhcnJheXMgcmVwcmVzZW50aW5nIHJvd3NcbiAgICAgICAgICogQHJldHVybiB7QGxpbmsgQml0TWF0cml4fSByZXByZXNlbnRhdGlvbiBvZiBpbWFnZVxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIHBhcnNlRnJvbUJvb2xlYW5BcnJheShpbWFnZSkge1xuICAgICAgICAgICAgY29uc3QgaGVpZ2h0ID0gaW1hZ2UubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3Qgd2lkdGggPSBpbWFnZVswXS5sZW5ndGg7XG4gICAgICAgICAgICBjb25zdCBiaXRzID0gbmV3IEJpdE1hdHJpeCh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaGVpZ2h0OyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbWFnZUkgPSBpbWFnZVtpXTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHdpZHRoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGltYWdlSVtqXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYml0cy5zZXQoaiwgaSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYml0cztcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogQGZ1bmN0aW9uIHBhcnNlXG4gICAgICAgICAqIEBwYXJhbSBzdHJpbmdSZXByZXNlbnRhdGlvblxuICAgICAgICAgKiBAcGFyYW0gc2V0U3RyaW5nXG4gICAgICAgICAqIEBwYXJhbSB1bnNldFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIHBhcnNlRnJvbVN0cmluZyhzdHJpbmdSZXByZXNlbnRhdGlvbiwgc2V0U3RyaW5nLCB1bnNldFN0cmluZykge1xuICAgICAgICAgICAgaWYgKHN0cmluZ1JlcHJlc2VudGF0aW9uID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignc3RyaW5nUmVwcmVzZW50YXRpb24gY2Fubm90IGJlIG51bGwnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGJpdHMgPSBuZXcgQXJyYXkoc3RyaW5nUmVwcmVzZW50YXRpb24ubGVuZ3RoKTtcbiAgICAgICAgICAgIGxldCBiaXRzUG9zID0gMDtcbiAgICAgICAgICAgIGxldCByb3dTdGFydFBvcyA9IDA7XG4gICAgICAgICAgICBsZXQgcm93TGVuZ3RoID0gLTE7XG4gICAgICAgICAgICBsZXQgblJvd3MgPSAwO1xuICAgICAgICAgICAgbGV0IHBvcyA9IDA7XG4gICAgICAgICAgICB3aGlsZSAocG9zIDwgc3RyaW5nUmVwcmVzZW50YXRpb24ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0cmluZ1JlcHJlc2VudGF0aW9uLmNoYXJBdChwb3MpID09PSAnXFxuJyB8fFxuICAgICAgICAgICAgICAgICAgICBzdHJpbmdSZXByZXNlbnRhdGlvbi5jaGFyQXQocG9zKSA9PT0gJ1xccicpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJpdHNQb3MgPiByb3dTdGFydFBvcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJvd0xlbmd0aCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3dMZW5ndGggPSBiaXRzUG9zIC0gcm93U3RhcnRQb3M7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChiaXRzUG9zIC0gcm93U3RhcnRQb3MgIT09IHJvd0xlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oJ3JvdyBsZW5ndGhzIGRvIG5vdCBtYXRjaCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcm93U3RhcnRQb3MgPSBiaXRzUG9zO1xuICAgICAgICAgICAgICAgICAgICAgICAgblJvd3MrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc3RyaW5nUmVwcmVzZW50YXRpb24uc3Vic3RyaW5nKHBvcywgcG9zICsgc2V0U3RyaW5nLmxlbmd0aCkgPT09IHNldFN0cmluZykge1xuICAgICAgICAgICAgICAgICAgICBwb3MgKz0gc2V0U3RyaW5nLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgYml0c1tiaXRzUG9zXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJpdHNQb3MrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc3RyaW5nUmVwcmVzZW50YXRpb24uc3Vic3RyaW5nKHBvcywgcG9zICsgdW5zZXRTdHJpbmcubGVuZ3RoKSA9PT0gdW5zZXRTdHJpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zICs9IHVuc2V0U3RyaW5nLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgYml0c1tiaXRzUG9zXSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBiaXRzUG9zKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCdpbGxlZ2FsIGNoYXJhY3RlciBlbmNvdW50ZXJlZDogJyArIHN0cmluZ1JlcHJlc2VudGF0aW9uLnN1YnN0cmluZyhwb3MpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBubyBFT0wgYXQgZW5kP1xuICAgICAgICAgICAgaWYgKGJpdHNQb3MgPiByb3dTdGFydFBvcykge1xuICAgICAgICAgICAgICAgIGlmIChyb3dMZW5ndGggPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvd0xlbmd0aCA9IGJpdHNQb3MgLSByb3dTdGFydFBvcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYml0c1BvcyAtIHJvd1N0YXJ0UG9zICE9PSByb3dMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbigncm93IGxlbmd0aHMgZG8gbm90IG1hdGNoJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5Sb3dzKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBtYXRyaXggPSBuZXcgQml0TWF0cml4KHJvd0xlbmd0aCwgblJvd3MpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiaXRzUG9zOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoYml0c1tpXSkge1xuICAgICAgICAgICAgICAgICAgICBtYXRyaXguc2V0KE1hdGguZmxvb3IoaSAlIHJvd0xlbmd0aCksIE1hdGguZmxvb3IoaSAvIHJvd0xlbmd0aCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtYXRyaXg7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIDxwPkdldHMgdGhlIHJlcXVlc3RlZCBiaXQsIHdoZXJlIHRydWUgbWVhbnMgYmxhY2suPC9wPlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0geCBUaGUgaG9yaXpvbnRhbCBjb21wb25lbnQgKGkuZS4gd2hpY2ggY29sdW1uKVxuICAgICAgICAgKiBAcGFyYW0geSBUaGUgdmVydGljYWwgY29tcG9uZW50IChpLmUuIHdoaWNoIHJvdylcbiAgICAgICAgICogQHJldHVybiB2YWx1ZSBvZiBnaXZlbiBiaXQgaW4gbWF0cml4XG4gICAgICAgICAqL1xuICAgICAgICBnZXQoeCAvKmludCovLCB5IC8qaW50Ki8pIHtcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IHkgKiB0aGlzLnJvd1NpemUgKyBNYXRoLmZsb29yKHggLyAzMik7XG4gICAgICAgICAgICByZXR1cm4gKCh0aGlzLmJpdHNbb2Zmc2V0XSA+Pj4gKHggJiAweDFmKSkgJiAxKSAhPT0gMDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogPHA+U2V0cyB0aGUgZ2l2ZW4gYml0IHRvIHRydWUuPC9wPlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0geCBUaGUgaG9yaXpvbnRhbCBjb21wb25lbnQgKGkuZS4gd2hpY2ggY29sdW1uKVxuICAgICAgICAgKiBAcGFyYW0geSBUaGUgdmVydGljYWwgY29tcG9uZW50IChpLmUuIHdoaWNoIHJvdylcbiAgICAgICAgICovXG4gICAgICAgIHNldCh4IC8qaW50Ki8sIHkgLyppbnQqLykge1xuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0geSAqIHRoaXMucm93U2l6ZSArIE1hdGguZmxvb3IoeCAvIDMyKTtcbiAgICAgICAgICAgIHRoaXMuYml0c1tvZmZzZXRdIHw9ICgxIDw8ICh4ICYgMHgxZikpICYgMHhGRkZGRkZGRjtcbiAgICAgICAgfVxuICAgICAgICB1bnNldCh4IC8qaW50Ki8sIHkgLyppbnQqLykge1xuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0geSAqIHRoaXMucm93U2l6ZSArIE1hdGguZmxvb3IoeCAvIDMyKTtcbiAgICAgICAgICAgIHRoaXMuYml0c1tvZmZzZXRdICY9IH4oKDEgPDwgKHggJiAweDFmKSkgJiAweEZGRkZGRkZGKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogPHA+RmxpcHMgdGhlIGdpdmVuIGJpdC48L3A+XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB4IFRoZSBob3Jpem9udGFsIGNvbXBvbmVudCAoaS5lLiB3aGljaCBjb2x1bW4pXG4gICAgICAgICAqIEBwYXJhbSB5IFRoZSB2ZXJ0aWNhbCBjb21wb25lbnQgKGkuZS4gd2hpY2ggcm93KVxuICAgICAgICAgKi9cbiAgICAgICAgZmxpcCh4IC8qaW50Ki8sIHkgLyppbnQqLykge1xuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0geSAqIHRoaXMucm93U2l6ZSArIE1hdGguZmxvb3IoeCAvIDMyKTtcbiAgICAgICAgICAgIHRoaXMuYml0c1tvZmZzZXRdIF49ICgoMSA8PCAoeCAmIDB4MWYpKSAmIDB4RkZGRkZGRkYpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFeGNsdXNpdmUtb3IgKFhPUik6IEZsaXAgdGhlIGJpdCBpbiB0aGlzIHtAY29kZSBCaXRNYXRyaXh9IGlmIHRoZSBjb3JyZXNwb25kaW5nXG4gICAgICAgICAqIG1hc2sgYml0IGlzIHNldC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIG1hc2sgWE9SIG1hc2tcbiAgICAgICAgICovXG4gICAgICAgIHhvcihtYXNrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy53aWR0aCAhPT0gbWFzay5nZXRXaWR0aCgpIHx8IHRoaXMuaGVpZ2h0ICE9PSBtYXNrLmdldEhlaWdodCgpXG4gICAgICAgICAgICAgICAgfHwgdGhpcy5yb3dTaXplICE9PSBtYXNrLmdldFJvd1NpemUoKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oJ2lucHV0IG1hdHJpeCBkaW1lbnNpb25zIGRvIG5vdCBtYXRjaCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgcm93QXJyYXkgPSBuZXcgQml0QXJyYXkoTWF0aC5mbG9vcih0aGlzLndpZHRoIC8gMzIpICsgMSk7XG4gICAgICAgICAgICBjb25zdCByb3dTaXplID0gdGhpcy5yb3dTaXplO1xuICAgICAgICAgICAgY29uc3QgYml0cyA9IHRoaXMuYml0cztcbiAgICAgICAgICAgIGZvciAobGV0IHkgPSAwLCBoZWlnaHQgPSB0aGlzLmhlaWdodDsgeSA8IGhlaWdodDsgeSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0geSAqIHJvd1NpemU7XG4gICAgICAgICAgICAgICAgY29uc3Qgcm93ID0gbWFzay5nZXRSb3coeSwgcm93QXJyYXkpLmdldEJpdEFycmF5KCk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCByb3dTaXplOyB4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgYml0c1tvZmZzZXQgKyB4XSBePSByb3dbeF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDbGVhcnMgYWxsIGJpdHMgKHNldHMgdG8gZmFsc2UpLlxuICAgICAgICAgKi9cbiAgICAgICAgY2xlYXIoKSB7XG4gICAgICAgICAgICBjb25zdCBiaXRzID0gdGhpcy5iaXRzO1xuICAgICAgICAgICAgY29uc3QgbWF4ID0gYml0cy5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1heDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYml0c1tpXSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIDxwPlNldHMgYSBzcXVhcmUgcmVnaW9uIG9mIHRoZSBiaXQgbWF0cml4IHRvIHRydWUuPC9wPlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gbGVmdCBUaGUgaG9yaXpvbnRhbCBwb3NpdGlvbiB0byBiZWdpbiBhdCAoaW5jbHVzaXZlKVxuICAgICAgICAgKiBAcGFyYW0gdG9wIFRoZSB2ZXJ0aWNhbCBwb3NpdGlvbiB0byBiZWdpbiBhdCAoaW5jbHVzaXZlKVxuICAgICAgICAgKiBAcGFyYW0gd2lkdGggVGhlIHdpZHRoIG9mIHRoZSByZWdpb25cbiAgICAgICAgICogQHBhcmFtIGhlaWdodCBUaGUgaGVpZ2h0IG9mIHRoZSByZWdpb25cbiAgICAgICAgICovXG4gICAgICAgIHNldFJlZ2lvbihsZWZ0IC8qaW50Ki8sIHRvcCAvKmludCovLCB3aWR0aCAvKmludCovLCBoZWlnaHQgLyppbnQqLykge1xuICAgICAgICAgICAgaWYgKHRvcCA8IDAgfHwgbGVmdCA8IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCdMZWZ0IGFuZCB0b3AgbXVzdCBiZSBub25uZWdhdGl2ZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGhlaWdodCA8IDEgfHwgd2lkdGggPCAxKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignSGVpZ2h0IGFuZCB3aWR0aCBtdXN0IGJlIGF0IGxlYXN0IDEnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJpZ2h0ID0gbGVmdCArIHdpZHRoO1xuICAgICAgICAgICAgY29uc3QgYm90dG9tID0gdG9wICsgaGVpZ2h0O1xuICAgICAgICAgICAgaWYgKGJvdHRvbSA+IHRoaXMuaGVpZ2h0IHx8IHJpZ2h0ID4gdGhpcy53aWR0aCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oJ1RoZSByZWdpb24gbXVzdCBmaXQgaW5zaWRlIHRoZSBtYXRyaXgnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJvd1NpemUgPSB0aGlzLnJvd1NpemU7XG4gICAgICAgICAgICBjb25zdCBiaXRzID0gdGhpcy5iaXRzO1xuICAgICAgICAgICAgZm9yIChsZXQgeSA9IHRvcDsgeSA8IGJvdHRvbTsgeSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0geSAqIHJvd1NpemU7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgeCA9IGxlZnQ7IHggPCByaWdodDsgeCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGJpdHNbb2Zmc2V0ICsgTWF0aC5mbG9vcih4IC8gMzIpXSB8PSAoKDEgPDwgKHggJiAweDFmKSkgJiAweEZGRkZGRkZGKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgZmFzdCBtZXRob2QgdG8gcmV0cmlldmUgb25lIHJvdyBvZiBkYXRhIGZyb20gdGhlIG1hdHJpeCBhcyBhIEJpdEFycmF5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0geSBUaGUgcm93IHRvIHJldHJpZXZlXG4gICAgICAgICAqIEBwYXJhbSByb3cgQW4gb3B0aW9uYWwgY2FsbGVyLWFsbG9jYXRlZCBCaXRBcnJheSwgd2lsbCBiZSBhbGxvY2F0ZWQgaWYgbnVsbCBvciB0b28gc21hbGxcbiAgICAgICAgICogQHJldHVybiBUaGUgcmVzdWx0aW5nIEJpdEFycmF5IC0gdGhpcyByZWZlcmVuY2Ugc2hvdWxkIGFsd2F5cyBiZSB1c2VkIGV2ZW4gd2hlbiBwYXNzaW5nXG4gICAgICAgICAqICAgICAgICAgeW91ciBvd24gcm93XG4gICAgICAgICAqL1xuICAgICAgICBnZXRSb3coeSAvKmludCovLCByb3cpIHtcbiAgICAgICAgICAgIGlmIChyb3cgPT09IG51bGwgfHwgcm93ID09PSB1bmRlZmluZWQgfHwgcm93LmdldFNpemUoKSA8IHRoaXMud2lkdGgpIHtcbiAgICAgICAgICAgICAgICByb3cgPSBuZXcgQml0QXJyYXkodGhpcy53aWR0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByb3cuY2xlYXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJvd1NpemUgPSB0aGlzLnJvd1NpemU7XG4gICAgICAgICAgICBjb25zdCBiaXRzID0gdGhpcy5iaXRzO1xuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0geSAqIHJvd1NpemU7XG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHJvd1NpemU7IHgrKykge1xuICAgICAgICAgICAgICAgIHJvdy5zZXRCdWxrKHggKiAzMiwgYml0c1tvZmZzZXQgKyB4XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcm93O1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0geSByb3cgdG8gc2V0XG4gICAgICAgICAqIEBwYXJhbSByb3cge0BsaW5rIEJpdEFycmF5fSB0byBjb3B5IGZyb21cbiAgICAgICAgICovXG4gICAgICAgIHNldFJvdyh5IC8qaW50Ki8sIHJvdykge1xuICAgICAgICAgICAgU3lzdGVtLmFycmF5Y29weShyb3cuZ2V0Qml0QXJyYXkoKSwgMCwgdGhpcy5iaXRzLCB5ICogdGhpcy5yb3dTaXplLCB0aGlzLnJvd1NpemUpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNb2RpZmllcyB0aGlzIHtAY29kZSBCaXRNYXRyaXh9IHRvIHJlcHJlc2VudCB0aGUgc2FtZSBidXQgcm90YXRlZCAxODAgZGVncmVlc1xuICAgICAgICAgKi9cbiAgICAgICAgcm90YXRlMTgwKCkge1xuICAgICAgICAgICAgY29uc3Qgd2lkdGggPSB0aGlzLmdldFdpZHRoKCk7XG4gICAgICAgICAgICBjb25zdCBoZWlnaHQgPSB0aGlzLmdldEhlaWdodCgpO1xuICAgICAgICAgICAgbGV0IHRvcFJvdyA9IG5ldyBCaXRBcnJheSh3aWR0aCk7XG4gICAgICAgICAgICBsZXQgYm90dG9tUm93ID0gbmV3IEJpdEFycmF5KHdpZHRoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW5ndGggPSBNYXRoLmZsb29yKChoZWlnaHQgKyAxKSAvIDIpOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0b3BSb3cgPSB0aGlzLmdldFJvdyhpLCB0b3BSb3cpO1xuICAgICAgICAgICAgICAgIGJvdHRvbVJvdyA9IHRoaXMuZ2V0Um93KGhlaWdodCAtIDEgLSBpLCBib3R0b21Sb3cpO1xuICAgICAgICAgICAgICAgIHRvcFJvdy5yZXZlcnNlKCk7XG4gICAgICAgICAgICAgICAgYm90dG9tUm93LnJldmVyc2UoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFJvdyhpLCBib3R0b21Sb3cpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0Um93KGhlaWdodCAtIDEgLSBpLCB0b3BSb3cpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGlzIHVzZWZ1bCBpbiBkZXRlY3RpbmcgdGhlIGVuY2xvc2luZyByZWN0YW5nbGUgb2YgYSAncHVyZScgYmFyY29kZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7QGNvZGUgbGVmdCx0b3Asd2lkdGgsaGVpZ2h0fSBlbmNsb3NpbmcgcmVjdGFuZ2xlIG9mIGFsbCAxIGJpdHMsIG9yIG51bGwgaWYgaXQgaXMgYWxsIHdoaXRlXG4gICAgICAgICAqL1xuICAgICAgICBnZXRFbmNsb3NpbmdSZWN0YW5nbGUoKSB7XG4gICAgICAgICAgICBjb25zdCB3aWR0aCA9IHRoaXMud2lkdGg7XG4gICAgICAgICAgICBjb25zdCBoZWlnaHQgPSB0aGlzLmhlaWdodDtcbiAgICAgICAgICAgIGNvbnN0IHJvd1NpemUgPSB0aGlzLnJvd1NpemU7XG4gICAgICAgICAgICBjb25zdCBiaXRzID0gdGhpcy5iaXRzO1xuICAgICAgICAgICAgbGV0IGxlZnQgPSB3aWR0aDtcbiAgICAgICAgICAgIGxldCB0b3AgPSBoZWlnaHQ7XG4gICAgICAgICAgICBsZXQgcmlnaHQgPSAtMTtcbiAgICAgICAgICAgIGxldCBib3R0b20gPSAtMTtcbiAgICAgICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgaGVpZ2h0OyB5KyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCB4MzIgPSAwOyB4MzIgPCByb3dTaXplOyB4MzIrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0aGVCaXRzID0gYml0c1t5ICogcm93U2l6ZSArIHgzMl07XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGVCaXRzICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoeSA8IHRvcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcCA9IHk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoeSA+IGJvdHRvbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvdHRvbSA9IHk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoeDMyICogMzIgPCBsZWZ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGJpdCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCgodGhlQml0cyA8PCAoMzEgLSBiaXQpKSAmIDB4RkZGRkZGRkYpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJpdCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHgzMiAqIDMyICsgYml0KSA8IGxlZnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IHgzMiAqIDMyICsgYml0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh4MzIgKiAzMiArIDMxID4gcmlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgYml0ID0gMzE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCh0aGVCaXRzID4+PiBiaXQpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJpdC0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHgzMiAqIDMyICsgYml0KSA+IHJpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0geDMyICogMzIgKyBiaXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJpZ2h0IDwgbGVmdCB8fCBib3R0b20gPCB0b3ApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBJbnQzMkFycmF5LmZyb20oW2xlZnQsIHRvcCwgcmlnaHQgLSBsZWZ0ICsgMSwgYm90dG9tIC0gdG9wICsgMV0pO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGlzIHVzZWZ1bCBpbiBkZXRlY3RpbmcgYSBjb3JuZXIgb2YgYSAncHVyZScgYmFyY29kZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7QGNvZGUgeCx5fSBjb29yZGluYXRlIG9mIHRvcC1sZWZ0LW1vc3QgMSBiaXQsIG9yIG51bGwgaWYgaXQgaXMgYWxsIHdoaXRlXG4gICAgICAgICAqL1xuICAgICAgICBnZXRUb3BMZWZ0T25CaXQoKSB7XG4gICAgICAgICAgICBjb25zdCByb3dTaXplID0gdGhpcy5yb3dTaXplO1xuICAgICAgICAgICAgY29uc3QgYml0cyA9IHRoaXMuYml0cztcbiAgICAgICAgICAgIGxldCBiaXRzT2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIHdoaWxlIChiaXRzT2Zmc2V0IDwgYml0cy5sZW5ndGggJiYgYml0c1tiaXRzT2Zmc2V0XSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGJpdHNPZmZzZXQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChiaXRzT2Zmc2V0ID09PSBiaXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeSA9IGJpdHNPZmZzZXQgLyByb3dTaXplO1xuICAgICAgICAgICAgbGV0IHggPSAoYml0c09mZnNldCAlIHJvd1NpemUpICogMzI7XG4gICAgICAgICAgICBjb25zdCB0aGVCaXRzID0gYml0c1tiaXRzT2Zmc2V0XTtcbiAgICAgICAgICAgIGxldCBiaXQgPSAwO1xuICAgICAgICAgICAgd2hpbGUgKCgodGhlQml0cyA8PCAoMzEgLSBiaXQpKSAmIDB4RkZGRkZGRkYpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgYml0Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB4ICs9IGJpdDtcbiAgICAgICAgICAgIHJldHVybiBJbnQzMkFycmF5LmZyb20oW3gsIHldKTtcbiAgICAgICAgfVxuICAgICAgICBnZXRCb3R0b21SaWdodE9uQml0KCkge1xuICAgICAgICAgICAgY29uc3Qgcm93U2l6ZSA9IHRoaXMucm93U2l6ZTtcbiAgICAgICAgICAgIGNvbnN0IGJpdHMgPSB0aGlzLmJpdHM7XG4gICAgICAgICAgICBsZXQgYml0c09mZnNldCA9IGJpdHMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIHdoaWxlIChiaXRzT2Zmc2V0ID49IDAgJiYgYml0c1tiaXRzT2Zmc2V0XSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGJpdHNPZmZzZXQtLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChiaXRzT2Zmc2V0IDwgMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeSA9IE1hdGguZmxvb3IoYml0c09mZnNldCAvIHJvd1NpemUpO1xuICAgICAgICAgICAgbGV0IHggPSBNYXRoLmZsb29yKGJpdHNPZmZzZXQgJSByb3dTaXplKSAqIDMyO1xuICAgICAgICAgICAgY29uc3QgdGhlQml0cyA9IGJpdHNbYml0c09mZnNldF07XG4gICAgICAgICAgICBsZXQgYml0ID0gMzE7XG4gICAgICAgICAgICB3aGlsZSAoKHRoZUJpdHMgPj4+IGJpdCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBiaXQtLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHggKz0gYml0O1xuICAgICAgICAgICAgcmV0dXJuIEludDMyQXJyYXkuZnJvbShbeCwgeV0pO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIFRoZSB3aWR0aCBvZiB0aGUgbWF0cml4XG4gICAgICAgICAqL1xuICAgICAgICBnZXRXaWR0aCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndpZHRoO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIFRoZSBoZWlnaHQgb2YgdGhlIG1hdHJpeFxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0SGVpZ2h0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIFRoZSByb3cgc2l6ZSBvZiB0aGUgbWF0cml4XG4gICAgICAgICAqL1xuICAgICAgICBnZXRSb3dTaXplKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucm93U2l6ZTtcbiAgICAgICAgfVxuICAgICAgICAvKkBPdmVycmlkZSovXG4gICAgICAgIGVxdWFscyhvKSB7XG4gICAgICAgICAgICBpZiAoIShvIGluc3RhbmNlb2YgQml0TWF0cml4KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG90aGVyID0gbztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndpZHRoID09PSBvdGhlci53aWR0aCAmJiB0aGlzLmhlaWdodCA9PT0gb3RoZXIuaGVpZ2h0ICYmIHRoaXMucm93U2l6ZSA9PT0gb3RoZXIucm93U2l6ZSAmJlxuICAgICAgICAgICAgICAgIEFycmF5cy5lcXVhbHModGhpcy5iaXRzLCBvdGhlci5iaXRzKTtcbiAgICAgICAgfVxuICAgICAgICAvKkBPdmVycmlkZSovXG4gICAgICAgIGhhc2hDb2RlKCkge1xuICAgICAgICAgICAgbGV0IGhhc2ggPSB0aGlzLndpZHRoO1xuICAgICAgICAgICAgaGFzaCA9IDMxICogaGFzaCArIHRoaXMud2lkdGg7XG4gICAgICAgICAgICBoYXNoID0gMzEgKiBoYXNoICsgdGhpcy5oZWlnaHQ7XG4gICAgICAgICAgICBoYXNoID0gMzEgKiBoYXNoICsgdGhpcy5yb3dTaXplO1xuICAgICAgICAgICAgaGFzaCA9IDMxICogaGFzaCArIEFycmF5cy5oYXNoQ29kZSh0aGlzLmJpdHMpO1xuICAgICAgICAgICAgcmV0dXJuIGhhc2g7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gc3RyaW5nIHJlcHJlc2VudGF0aW9uIHVzaW5nIFwiWFwiIGZvciBzZXQgYW5kIFwiIFwiIGZvciB1bnNldCBiaXRzXG4gICAgICAgICAqL1xuICAgICAgICAvKkBPdmVycmlkZSovXG4gICAgICAgIC8vIHB1YmxpYyB0b1N0cmluZygpOiBzdHJpbmcge1xuICAgICAgICAvLyAgIHJldHVybiB0b1N0cmluZyhcIjogXCJYLCBcIiAgXCIpXG4gICAgICAgIC8vIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSBzZXRTdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBzZXQgYml0XG4gICAgICAgICAqIEBwYXJhbSB1bnNldFN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhbiB1bnNldCBiaXRcbiAgICAgICAgICogQHJldHVybiBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgZW50aXJlIG1hdHJpeCB1dGlsaXppbmcgZ2l2ZW4gc3RyaW5nc1xuICAgICAgICAgKi9cbiAgICAgICAgLy8gcHVibGljIHRvU3RyaW5nKHNldFN0cmluZzogc3RyaW5nID0gXCJYIFwiLCB1bnNldFN0cmluZzogc3RyaW5nID0gXCIgIFwiKTogc3RyaW5nIHtcbiAgICAgICAgLy8gICByZXR1cm4gdGhpcy5idWlsZFRvU3RyaW5nKHNldFN0cmluZywgdW5zZXRTdHJpbmcsIFwiXFxuXCIpXG4gICAgICAgIC8vIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSBzZXRTdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBzZXQgYml0XG4gICAgICAgICAqIEBwYXJhbSB1bnNldFN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhbiB1bnNldCBiaXRcbiAgICAgICAgICogQHBhcmFtIGxpbmVTZXBhcmF0b3IgbmV3bGluZSBjaGFyYWN0ZXIgaW4gc3RyaW5nIHJlcHJlc2VudGF0aW9uXG4gICAgICAgICAqIEByZXR1cm4gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGVudGlyZSBtYXRyaXggdXRpbGl6aW5nIGdpdmVuIHN0cmluZ3MgYW5kIGxpbmUgc2VwYXJhdG9yXG4gICAgICAgICAqIEBkZXByZWNhdGVkIGNhbGwge0BsaW5rICN0b1N0cmluZyhTdHJpbmcsU3RyaW5nKX0gb25seSwgd2hpY2ggdXNlcyBcXG4gbGluZSBzZXBhcmF0b3IgYWx3YXlzXG4gICAgICAgICAqL1xuICAgICAgICAvLyBARGVwcmVjYXRlZFxuICAgICAgICB0b1N0cmluZyhzZXRTdHJpbmcgPSAnWCAnLCB1bnNldFN0cmluZyA9ICcgICcsIGxpbmVTZXBhcmF0b3IgPSAnXFxuJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYnVpbGRUb1N0cmluZyhzZXRTdHJpbmcsIHVuc2V0U3RyaW5nLCBsaW5lU2VwYXJhdG9yKTtcbiAgICAgICAgfVxuICAgICAgICBidWlsZFRvU3RyaW5nKHNldFN0cmluZywgdW5zZXRTdHJpbmcsIGxpbmVTZXBhcmF0b3IpIHtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBuZXcgU3RyaW5nQnVpbGRlcigpO1xuICAgICAgICAgICAgLy8gcmVzdWx0LmFwcGVuZChsaW5lU2VwYXJhdG9yKTtcbiAgICAgICAgICAgIGZvciAobGV0IHkgPSAwLCBoZWlnaHQgPSB0aGlzLmhlaWdodDsgeSA8IGhlaWdodDsgeSsrKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgeCA9IDAsIHdpZHRoID0gdGhpcy53aWR0aDsgeCA8IHdpZHRoOyB4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZCh0aGlzLmdldCh4LCB5KSA/IHNldFN0cmluZyA6IHVuc2V0U3RyaW5nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZChsaW5lU2VwYXJhdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICAvKkBPdmVycmlkZSovXG4gICAgICAgIGNsb25lKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBCaXRNYXRyaXgodGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIHRoaXMucm93U2l6ZSwgdGhpcy5iaXRzLnNsaWNlKCkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3VzdG9tIEVycm9yIGNsYXNzIG9mIHR5cGUgRXhjZXB0aW9uLlxuICAgICAqL1xuICAgIGNsYXNzIE5vdEZvdW5kRXhjZXB0aW9uIGV4dGVuZHMgRXhjZXB0aW9uIHtcbiAgICAgICAgc3RhdGljIGdldE5vdEZvdW5kSW5zdGFuY2UoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgTm90Rm91bmRFeGNlcHRpb24ua2luZCA9ICdOb3RGb3VuZEV4Y2VwdGlvbic7XG5cbiAgICAvKlxuICAgICAqIENvcHlyaWdodCAyMDA5IFpYaW5nIGF1dGhvcnNcbiAgICAgKlxuICAgICAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gICAgICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgICAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgICAqXG4gICAgICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAgICAgKlxuICAgICAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgICAgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICAgICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gICAgICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICAgICAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIFRoaXMgQmluYXJpemVyIGltcGxlbWVudGF0aW9uIHVzZXMgdGhlIG9sZCBaWGluZyBnbG9iYWwgaGlzdG9ncmFtIGFwcHJvYWNoLiBJdCBpcyBzdWl0YWJsZVxuICAgICAqIGZvciBsb3ctZW5kIG1vYmlsZSBkZXZpY2VzIHdoaWNoIGRvbid0IGhhdmUgZW5vdWdoIENQVSBvciBtZW1vcnkgdG8gdXNlIGEgbG9jYWwgdGhyZXNob2xkaW5nXG4gICAgICogYWxnb3JpdGhtLiBIb3dldmVyLCBiZWNhdXNlIGl0IHBpY2tzIGEgZ2xvYmFsIGJsYWNrIHBvaW50LCBpdCBjYW5ub3QgaGFuZGxlIGRpZmZpY3VsdCBzaGFkb3dzXG4gICAgICogYW5kIGdyYWRpZW50cy5cbiAgICAgKlxuICAgICAqIEZhc3RlciBtb2JpbGUgZGV2aWNlcyBhbmQgYWxsIGRlc2t0b3AgYXBwbGljYXRpb25zIHNob3VsZCBwcm9iYWJseSB1c2UgSHlicmlkQmluYXJpemVyIGluc3RlYWQuXG4gICAgICpcbiAgICAgKiBAYXV0aG9yIGRzd2l0a2luQGdvb2dsZS5jb20gKERhbmllbCBTd2l0a2luKVxuICAgICAqIEBhdXRob3IgU2VhbiBPd2VuXG4gICAgICovXG4gICAgY2xhc3MgR2xvYmFsSGlzdG9ncmFtQmluYXJpemVyIGV4dGVuZHMgQmluYXJpemVyIHtcbiAgICAgICAgY29uc3RydWN0b3Ioc291cmNlKSB7XG4gICAgICAgICAgICBzdXBlcihzb3VyY2UpO1xuICAgICAgICAgICAgdGhpcy5sdW1pbmFuY2VzID0gR2xvYmFsSGlzdG9ncmFtQmluYXJpemVyLkVNUFRZO1xuICAgICAgICAgICAgdGhpcy5idWNrZXRzID0gbmV3IEludDMyQXJyYXkoR2xvYmFsSGlzdG9ncmFtQmluYXJpemVyLkxVTUlOQU5DRV9CVUNLRVRTKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBcHBsaWVzIHNpbXBsZSBzaGFycGVuaW5nIHRvIHRoZSByb3cgZGF0YSB0byBpbXByb3ZlIHBlcmZvcm1hbmNlIG9mIHRoZSAxRCBSZWFkZXJzLlxuICAgICAgICAvKkBPdmVycmlkZSovXG4gICAgICAgIGdldEJsYWNrUm93KHkgLyppbnQqLywgcm93KSB7XG4gICAgICAgICAgICBjb25zdCBzb3VyY2UgPSB0aGlzLmdldEx1bWluYW5jZVNvdXJjZSgpO1xuICAgICAgICAgICAgY29uc3Qgd2lkdGggPSBzb3VyY2UuZ2V0V2lkdGgoKTtcbiAgICAgICAgICAgIGlmIChyb3cgPT09IHVuZGVmaW5lZCB8fCByb3cgPT09IG51bGwgfHwgcm93LmdldFNpemUoKSA8IHdpZHRoKSB7XG4gICAgICAgICAgICAgICAgcm93ID0gbmV3IEJpdEFycmF5KHdpZHRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJvdy5jbGVhcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5pbml0QXJyYXlzKHdpZHRoKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsTHVtaW5hbmNlcyA9IHNvdXJjZS5nZXRSb3coeSwgdGhpcy5sdW1pbmFuY2VzKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsQnVja2V0cyA9IHRoaXMuYnVja2V0cztcbiAgICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgd2lkdGg7IHgrKykge1xuICAgICAgICAgICAgICAgIGxvY2FsQnVja2V0c1sobG9jYWxMdW1pbmFuY2VzW3hdICYgMHhmZikgPj4gR2xvYmFsSGlzdG9ncmFtQmluYXJpemVyLkxVTUlOQU5DRV9TSElGVF0rKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGJsYWNrUG9pbnQgPSBHbG9iYWxIaXN0b2dyYW1CaW5hcml6ZXIuZXN0aW1hdGVCbGFja1BvaW50KGxvY2FsQnVja2V0cyk7XG4gICAgICAgICAgICBpZiAod2lkdGggPCAzKSB7XG4gICAgICAgICAgICAgICAgLy8gU3BlY2lhbCBjYXNlIGZvciB2ZXJ5IHNtYWxsIGltYWdlc1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgd2lkdGg7IHgrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoKGxvY2FsTHVtaW5hbmNlc1t4XSAmIDB4ZmYpIDwgYmxhY2tQb2ludCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcm93LnNldCh4KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBsZWZ0ID0gbG9jYWxMdW1pbmFuY2VzWzBdICYgMHhmZjtcbiAgICAgICAgICAgICAgICBsZXQgY2VudGVyID0gbG9jYWxMdW1pbmFuY2VzWzFdICYgMHhmZjtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCB4ID0gMTsgeCA8IHdpZHRoIC0gMTsgeCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJpZ2h0ID0gbG9jYWxMdW1pbmFuY2VzW3ggKyAxXSAmIDB4ZmY7XG4gICAgICAgICAgICAgICAgICAgIC8vIEEgc2ltcGxlIC0xIDQgLTEgYm94IGZpbHRlciB3aXRoIGEgd2VpZ2h0IG9mIDIuXG4gICAgICAgICAgICAgICAgICAgIGlmICgoKGNlbnRlciAqIDQpIC0gbGVmdCAtIHJpZ2h0KSAvIDIgPCBibGFja1BvaW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByb3cuc2V0KHgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxlZnQgPSBjZW50ZXI7XG4gICAgICAgICAgICAgICAgICAgIGNlbnRlciA9IHJpZ2h0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByb3c7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRG9lcyBub3Qgc2hhcnBlbiB0aGUgZGF0YSwgYXMgdGhpcyBjYWxsIGlzIGludGVuZGVkIHRvIG9ubHkgYmUgdXNlZCBieSAyRCBSZWFkZXJzLlxuICAgICAgICAvKkBPdmVycmlkZSovXG4gICAgICAgIGdldEJsYWNrTWF0cml4KCkge1xuICAgICAgICAgICAgY29uc3Qgc291cmNlID0gdGhpcy5nZXRMdW1pbmFuY2VTb3VyY2UoKTtcbiAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gc291cmNlLmdldFdpZHRoKCk7XG4gICAgICAgICAgICBjb25zdCBoZWlnaHQgPSBzb3VyY2UuZ2V0SGVpZ2h0KCk7XG4gICAgICAgICAgICBjb25zdCBtYXRyaXggPSBuZXcgQml0TWF0cml4KHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgLy8gUXVpY2tseSBjYWxjdWxhdGVzIHRoZSBoaXN0b2dyYW0gYnkgc2FtcGxpbmcgZm91ciByb3dzIGZyb20gdGhlIGltYWdlLiBUaGlzIHByb3ZlZCB0byBiZVxuICAgICAgICAgICAgLy8gbW9yZSByb2J1c3Qgb24gdGhlIGJsYWNrYm94IHRlc3RzIHRoYW4gc2FtcGxpbmcgYSBkaWFnb25hbCBhcyB3ZSB1c2VkIHRvIGRvLlxuICAgICAgICAgICAgdGhpcy5pbml0QXJyYXlzKHdpZHRoKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsQnVja2V0cyA9IHRoaXMuYnVja2V0cztcbiAgICAgICAgICAgIGZvciAobGV0IHkgPSAxOyB5IDwgNTsgeSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgcm93ID0gTWF0aC5mbG9vcigoaGVpZ2h0ICogeSkgLyA1KTtcbiAgICAgICAgICAgICAgICBjb25zdCBsb2NhbEx1bWluYW5jZXMgPSBzb3VyY2UuZ2V0Um93KHJvdywgdGhpcy5sdW1pbmFuY2VzKTtcbiAgICAgICAgICAgICAgICBjb25zdCByaWdodCA9IE1hdGguZmxvb3IoKHdpZHRoICogNCkgLyA1KTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCB4ID0gTWF0aC5mbG9vcih3aWR0aCAvIDUpOyB4IDwgcmlnaHQ7IHgrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwaXhlbCA9IGxvY2FsTHVtaW5hbmNlc1t4XSAmIDB4ZmY7XG4gICAgICAgICAgICAgICAgICAgIGxvY2FsQnVja2V0c1twaXhlbCA+PiBHbG9iYWxIaXN0b2dyYW1CaW5hcml6ZXIuTFVNSU5BTkNFX1NISUZUXSsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGJsYWNrUG9pbnQgPSBHbG9iYWxIaXN0b2dyYW1CaW5hcml6ZXIuZXN0aW1hdGVCbGFja1BvaW50KGxvY2FsQnVja2V0cyk7XG4gICAgICAgICAgICAvLyBXZSBkZWxheSByZWFkaW5nIHRoZSBlbnRpcmUgaW1hZ2UgbHVtaW5hbmNlIHVudGlsIHRoZSBibGFjayBwb2ludCBlc3RpbWF0aW9uIHN1Y2NlZWRzLlxuICAgICAgICAgICAgLy8gQWx0aG91Z2ggd2UgZW5kIHVwIHJlYWRpbmcgZm91ciByb3dzIHR3aWNlLCBpdCBpcyBjb25zaXN0ZW50IHdpdGggb3VyIG1vdHRvIG9mXG4gICAgICAgICAgICAvLyBcImZhaWwgcXVpY2tseVwiIHdoaWNoIGlzIG5lY2Vzc2FyeSBmb3IgY29udGludW91cyBzY2FubmluZy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsTHVtaW5hbmNlcyA9IHNvdXJjZS5nZXRNYXRyaXgoKTtcbiAgICAgICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgaGVpZ2h0OyB5KyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXQgPSB5ICogd2lkdGg7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCB3aWR0aDsgeCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBpeGVsID0gbG9jYWxMdW1pbmFuY2VzW29mZnNldCArIHhdICYgMHhmZjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBpeGVsIDwgYmxhY2tQb2ludCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0cml4LnNldCh4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtYXRyaXg7XG4gICAgICAgIH1cbiAgICAgICAgLypAT3ZlcnJpZGUqL1xuICAgICAgICBjcmVhdGVCaW5hcml6ZXIoc291cmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEdsb2JhbEhpc3RvZ3JhbUJpbmFyaXplcihzb3VyY2UpO1xuICAgICAgICB9XG4gICAgICAgIGluaXRBcnJheXMobHVtaW5hbmNlU2l6ZSAvKmludCovKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5sdW1pbmFuY2VzLmxlbmd0aCA8IGx1bWluYW5jZVNpemUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmx1bWluYW5jZXMgPSBuZXcgVWludDhDbGFtcGVkQXJyYXkobHVtaW5hbmNlU2l6ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBidWNrZXRzID0gdGhpcy5idWNrZXRzO1xuICAgICAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCBHbG9iYWxIaXN0b2dyYW1CaW5hcml6ZXIuTFVNSU5BTkNFX0JVQ0tFVFM7IHgrKykge1xuICAgICAgICAgICAgICAgIGJ1Y2tldHNbeF0gPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBlc3RpbWF0ZUJsYWNrUG9pbnQoYnVja2V0cykge1xuICAgICAgICAgICAgLy8gRmluZCB0aGUgdGFsbGVzdCBwZWFrIGluIHRoZSBoaXN0b2dyYW0uXG4gICAgICAgICAgICBjb25zdCBudW1CdWNrZXRzID0gYnVja2V0cy5sZW5ndGg7XG4gICAgICAgICAgICBsZXQgbWF4QnVja2V0Q291bnQgPSAwO1xuICAgICAgICAgICAgbGV0IGZpcnN0UGVhayA9IDA7XG4gICAgICAgICAgICBsZXQgZmlyc3RQZWFrU2l6ZSA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IG51bUJ1Y2tldHM7IHgrKykge1xuICAgICAgICAgICAgICAgIGlmIChidWNrZXRzW3hdID4gZmlyc3RQZWFrU2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICBmaXJzdFBlYWsgPSB4O1xuICAgICAgICAgICAgICAgICAgICBmaXJzdFBlYWtTaXplID0gYnVja2V0c1t4XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGJ1Y2tldHNbeF0gPiBtYXhCdWNrZXRDb3VudCkge1xuICAgICAgICAgICAgICAgICAgICBtYXhCdWNrZXRDb3VudCA9IGJ1Y2tldHNbeF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRmluZCB0aGUgc2Vjb25kLXRhbGxlc3QgcGVhayB3aGljaCBpcyBzb21ld2hhdCBmYXIgZnJvbSB0aGUgdGFsbGVzdCBwZWFrLlxuICAgICAgICAgICAgbGV0IHNlY29uZFBlYWsgPSAwO1xuICAgICAgICAgICAgbGV0IHNlY29uZFBlYWtTY29yZSA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IG51bUJ1Y2tldHM7IHgrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRpc3RhbmNlVG9CaWdnZXN0ID0geCAtIGZpcnN0UGVhaztcbiAgICAgICAgICAgICAgICAvLyBFbmNvdXJhZ2UgbW9yZSBkaXN0YW50IHNlY29uZCBwZWFrcyBieSBtdWx0aXBseWluZyBieSBzcXVhcmUgb2YgZGlzdGFuY2UuXG4gICAgICAgICAgICAgICAgY29uc3Qgc2NvcmUgPSBidWNrZXRzW3hdICogZGlzdGFuY2VUb0JpZ2dlc3QgKiBkaXN0YW5jZVRvQmlnZ2VzdDtcbiAgICAgICAgICAgICAgICBpZiAoc2NvcmUgPiBzZWNvbmRQZWFrU2NvcmUpIHtcbiAgICAgICAgICAgICAgICAgICAgc2Vjb25kUGVhayA9IHg7XG4gICAgICAgICAgICAgICAgICAgIHNlY29uZFBlYWtTY29yZSA9IHNjb3JlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSBmaXJzdFBlYWsgY29ycmVzcG9uZHMgdG8gdGhlIGJsYWNrIHBlYWsuXG4gICAgICAgICAgICBpZiAoZmlyc3RQZWFrID4gc2Vjb25kUGVhaykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRlbXAgPSBmaXJzdFBlYWs7XG4gICAgICAgICAgICAgICAgZmlyc3RQZWFrID0gc2Vjb25kUGVhaztcbiAgICAgICAgICAgICAgICBzZWNvbmRQZWFrID0gdGVtcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIHRvbyBsaXR0bGUgY29udHJhc3QgaW4gdGhlIGltYWdlIHRvIHBpY2sgYSBtZWFuaW5nZnVsIGJsYWNrIHBvaW50LCB0aHJvdyByYXRoZXJcbiAgICAgICAgICAgIC8vIHRoYW4gd2FzdGUgdGltZSB0cnlpbmcgdG8gZGVjb2RlIHRoZSBpbWFnZSwgYW5kIHJpc2sgZmFsc2UgcG9zaXRpdmVzLlxuICAgICAgICAgICAgaWYgKHNlY29uZFBlYWsgLSBmaXJzdFBlYWsgPD0gbnVtQnVja2V0cyAvIDE2KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBGaW5kIGEgdmFsbGV5IGJldHdlZW4gdGhlbSB0aGF0IGlzIGxvdyBhbmQgY2xvc2VyIHRvIHRoZSB3aGl0ZSBwZWFrLlxuICAgICAgICAgICAgbGV0IGJlc3RWYWxsZXkgPSBzZWNvbmRQZWFrIC0gMTtcbiAgICAgICAgICAgIGxldCBiZXN0VmFsbGV5U2NvcmUgPSAtMTtcbiAgICAgICAgICAgIGZvciAobGV0IHggPSBzZWNvbmRQZWFrIC0gMTsgeCA+IGZpcnN0UGVhazsgeC0tKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZnJvbUZpcnN0ID0geCAtIGZpcnN0UGVhaztcbiAgICAgICAgICAgICAgICBjb25zdCBzY29yZSA9IGZyb21GaXJzdCAqIGZyb21GaXJzdCAqIChzZWNvbmRQZWFrIC0geCkgKiAobWF4QnVja2V0Q291bnQgLSBidWNrZXRzW3hdKTtcbiAgICAgICAgICAgICAgICBpZiAoc2NvcmUgPiBiZXN0VmFsbGV5U2NvcmUpIHtcbiAgICAgICAgICAgICAgICAgICAgYmVzdFZhbGxleSA9IHg7XG4gICAgICAgICAgICAgICAgICAgIGJlc3RWYWxsZXlTY29yZSA9IHNjb3JlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBiZXN0VmFsbGV5IDw8IEdsb2JhbEhpc3RvZ3JhbUJpbmFyaXplci5MVU1JTkFOQ0VfU0hJRlQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgR2xvYmFsSGlzdG9ncmFtQmluYXJpemVyLkxVTUlOQU5DRV9CSVRTID0gNTtcbiAgICBHbG9iYWxIaXN0b2dyYW1CaW5hcml6ZXIuTFVNSU5BTkNFX1NISUZUID0gOCAtIEdsb2JhbEhpc3RvZ3JhbUJpbmFyaXplci5MVU1JTkFOQ0VfQklUUztcbiAgICBHbG9iYWxIaXN0b2dyYW1CaW5hcml6ZXIuTFVNSU5BTkNFX0JVQ0tFVFMgPSAxIDw8IEdsb2JhbEhpc3RvZ3JhbUJpbmFyaXplci5MVU1JTkFOQ0VfQklUUztcbiAgICBHbG9iYWxIaXN0b2dyYW1CaW5hcml6ZXIuRU1QVFkgPSBVaW50OENsYW1wZWRBcnJheS5mcm9tKFswXSk7XG5cbiAgICAvKlxuICAgICAqIENvcHlyaWdodCAyMDA5IFpYaW5nIGF1dGhvcnNcbiAgICAgKlxuICAgICAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gICAgICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgICAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgICAqXG4gICAgICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAgICAgKlxuICAgICAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgICAgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICAgICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gICAgICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICAgICAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIFRoaXMgY2xhc3MgaW1wbGVtZW50cyBhIGxvY2FsIHRocmVzaG9sZGluZyBhbGdvcml0aG0sIHdoaWNoIHdoaWxlIHNsb3dlciB0aGFuIHRoZVxuICAgICAqIEdsb2JhbEhpc3RvZ3JhbUJpbmFyaXplciwgaXMgZmFpcmx5IGVmZmljaWVudCBmb3Igd2hhdCBpdCBkb2VzLiBJdCBpcyBkZXNpZ25lZCBmb3JcbiAgICAgKiBoaWdoIGZyZXF1ZW5jeSBpbWFnZXMgb2YgYmFyY29kZXMgd2l0aCBibGFjayBkYXRhIG9uIHdoaXRlIGJhY2tncm91bmRzLiBGb3IgdGhpcyBhcHBsaWNhdGlvbixcbiAgICAgKiBpdCBkb2VzIGEgbXVjaCBiZXR0ZXIgam9iIHRoYW4gYSBnbG9iYWwgYmxhY2twb2ludCB3aXRoIHNldmVyZSBzaGFkb3dzIGFuZCBncmFkaWVudHMuXG4gICAgICogSG93ZXZlciBpdCB0ZW5kcyB0byBwcm9kdWNlIGFydGlmYWN0cyBvbiBsb3dlciBmcmVxdWVuY3kgaW1hZ2VzIGFuZCBpcyB0aGVyZWZvcmUgbm90XG4gICAgICogYSBnb29kIGdlbmVyYWwgcHVycG9zZSBiaW5hcml6ZXIgZm9yIHVzZXMgb3V0c2lkZSBaWGluZy5cbiAgICAgKlxuICAgICAqIFRoaXMgY2xhc3MgZXh0ZW5kcyBHbG9iYWxIaXN0b2dyYW1CaW5hcml6ZXIsIHVzaW5nIHRoZSBvbGRlciBoaXN0b2dyYW0gYXBwcm9hY2ggZm9yIDFEIHJlYWRlcnMsXG4gICAgICogYW5kIHRoZSBuZXdlciBsb2NhbCBhcHByb2FjaCBmb3IgMkQgcmVhZGVycy4gMUQgZGVjb2RpbmcgdXNpbmcgYSBwZXItcm93IGhpc3RvZ3JhbSBpcyBhbHJlYWR5XG4gICAgICogaW5oZXJlbnRseSBsb2NhbCwgYW5kIG9ubHkgZmFpbHMgZm9yIGhvcml6b250YWwgZ3JhZGllbnRzLiBXZSBjYW4gcmV2aXNpdCB0aGF0IHByb2JsZW0gbGF0ZXIsXG4gICAgICogYnV0IGZvciBub3cgaXQgd2FzIG5vdCBhIHdpbiB0byB1c2UgbG9jYWwgYmxvY2tzIGZvciAxRC5cbiAgICAgKlxuICAgICAqIFRoaXMgQmluYXJpemVyIGlzIHRoZSBkZWZhdWx0IGZvciB0aGUgdW5pdCB0ZXN0cyBhbmQgdGhlIHJlY29tbWVuZGVkIGNsYXNzIGZvciBsaWJyYXJ5IHVzZXJzLlxuICAgICAqXG4gICAgICogQGF1dGhvciBkc3dpdGtpbkBnb29nbGUuY29tIChEYW5pZWwgU3dpdGtpbilcbiAgICAgKi9cbiAgICBjbGFzcyBIeWJyaWRCaW5hcml6ZXIgZXh0ZW5kcyBHbG9iYWxIaXN0b2dyYW1CaW5hcml6ZXIge1xuICAgICAgICBjb25zdHJ1Y3Rvcihzb3VyY2UpIHtcbiAgICAgICAgICAgIHN1cGVyKHNvdXJjZSk7XG4gICAgICAgICAgICB0aGlzLm1hdHJpeCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGN1bGF0ZXMgdGhlIGZpbmFsIEJpdE1hdHJpeCBvbmNlIGZvciBhbGwgcmVxdWVzdHMuIFRoaXMgY291bGQgYmUgY2FsbGVkIG9uY2UgZnJvbSB0aGVcbiAgICAgICAgICogY29uc3RydWN0b3IgaW5zdGVhZCwgYnV0IHRoZXJlIGFyZSBzb21lIGFkdmFudGFnZXMgdG8gZG9pbmcgaXQgbGF6aWx5LCBzdWNoIGFzIG1ha2luZ1xuICAgICAgICAgKiBwcm9maWxpbmcgZWFzaWVyLCBhbmQgbm90IGRvaW5nIGhlYXZ5IGxpZnRpbmcgd2hlbiBjYWxsZXJzIGRvbid0IGV4cGVjdCBpdC5cbiAgICAgICAgICovXG4gICAgICAgIC8qQE92ZXJyaWRlKi9cbiAgICAgICAgZ2V0QmxhY2tNYXRyaXgoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5tYXRyaXggIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5tYXRyaXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzb3VyY2UgPSB0aGlzLmdldEx1bWluYW5jZVNvdXJjZSgpO1xuICAgICAgICAgICAgY29uc3Qgd2lkdGggPSBzb3VyY2UuZ2V0V2lkdGgoKTtcbiAgICAgICAgICAgIGNvbnN0IGhlaWdodCA9IHNvdXJjZS5nZXRIZWlnaHQoKTtcbiAgICAgICAgICAgIGlmICh3aWR0aCA+PSBIeWJyaWRCaW5hcml6ZXIuTUlOSU1VTV9ESU1FTlNJT04gJiYgaGVpZ2h0ID49IEh5YnJpZEJpbmFyaXplci5NSU5JTVVNX0RJTUVOU0lPTikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGx1bWluYW5jZXMgPSBzb3VyY2UuZ2V0TWF0cml4KCk7XG4gICAgICAgICAgICAgICAgbGV0IHN1YldpZHRoID0gd2lkdGggPj4gSHlicmlkQmluYXJpemVyLkJMT0NLX1NJWkVfUE9XRVI7XG4gICAgICAgICAgICAgICAgaWYgKCh3aWR0aCAmIEh5YnJpZEJpbmFyaXplci5CTE9DS19TSVpFX01BU0spICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1YldpZHRoKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBzdWJIZWlnaHQgPSBoZWlnaHQgPj4gSHlicmlkQmluYXJpemVyLkJMT0NLX1NJWkVfUE9XRVI7XG4gICAgICAgICAgICAgICAgaWYgKChoZWlnaHQgJiBIeWJyaWRCaW5hcml6ZXIuQkxPQ0tfU0laRV9NQVNLKSAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBzdWJIZWlnaHQrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgYmxhY2tQb2ludHMgPSBIeWJyaWRCaW5hcml6ZXIuY2FsY3VsYXRlQmxhY2tQb2ludHMobHVtaW5hbmNlcywgc3ViV2lkdGgsIHN1YkhlaWdodCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3TWF0cml4ID0gbmV3IEJpdE1hdHJpeCh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBIeWJyaWRCaW5hcml6ZXIuY2FsY3VsYXRlVGhyZXNob2xkRm9yQmxvY2sobHVtaW5hbmNlcywgc3ViV2lkdGgsIHN1YkhlaWdodCwgd2lkdGgsIGhlaWdodCwgYmxhY2tQb2ludHMsIG5ld01hdHJpeCk7XG4gICAgICAgICAgICAgICAgdGhpcy5tYXRyaXggPSBuZXdNYXRyaXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgaW1hZ2UgaXMgdG9vIHNtYWxsLCBmYWxsIGJhY2sgdG8gdGhlIGdsb2JhbCBoaXN0b2dyYW0gYXBwcm9hY2guXG4gICAgICAgICAgICAgICAgdGhpcy5tYXRyaXggPSBzdXBlci5nZXRCbGFja01hdHJpeCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWF0cml4O1xuICAgICAgICB9XG4gICAgICAgIC8qQE92ZXJyaWRlKi9cbiAgICAgICAgY3JlYXRlQmluYXJpemVyKHNvdXJjZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBIeWJyaWRCaW5hcml6ZXIoc291cmNlKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogRm9yIGVhY2ggYmxvY2sgaW4gdGhlIGltYWdlLCBjYWxjdWxhdGUgdGhlIGF2ZXJhZ2UgYmxhY2sgcG9pbnQgdXNpbmcgYSA1eDUgZ3JpZFxuICAgICAgICAgKiBvZiB0aGUgYmxvY2tzIGFyb3VuZCBpdC4gQWxzbyBoYW5kbGVzIHRoZSBjb3JuZXIgY2FzZXMgKGZyYWN0aW9uYWwgYmxvY2tzIGFyZSBjb21wdXRlZCBiYXNlZFxuICAgICAgICAgKiBvbiB0aGUgbGFzdCBwaXhlbHMgaW4gdGhlIHJvdy9jb2x1bW4gd2hpY2ggYXJlIGFsc28gdXNlZCBpbiB0aGUgcHJldmlvdXMgYmxvY2spLlxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGNhbGN1bGF0ZVRocmVzaG9sZEZvckJsb2NrKGx1bWluYW5jZXMsIHN1YldpZHRoIC8qaW50Ki8sIHN1YkhlaWdodCAvKmludCovLCB3aWR0aCAvKmludCovLCBoZWlnaHQgLyppbnQqLywgYmxhY2tQb2ludHMsIG1hdHJpeCkge1xuICAgICAgICAgICAgY29uc3QgbWF4WU9mZnNldCA9IGhlaWdodCAtIEh5YnJpZEJpbmFyaXplci5CTE9DS19TSVpFO1xuICAgICAgICAgICAgY29uc3QgbWF4WE9mZnNldCA9IHdpZHRoIC0gSHlicmlkQmluYXJpemVyLkJMT0NLX1NJWkU7XG4gICAgICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IHN1YkhlaWdodDsgeSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHlvZmZzZXQgPSB5IDw8IEh5YnJpZEJpbmFyaXplci5CTE9DS19TSVpFX1BPV0VSO1xuICAgICAgICAgICAgICAgIGlmICh5b2Zmc2V0ID4gbWF4WU9mZnNldCkge1xuICAgICAgICAgICAgICAgICAgICB5b2Zmc2V0ID0gbWF4WU9mZnNldDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgdG9wID0gSHlicmlkQmluYXJpemVyLmNhcCh5LCAyLCBzdWJIZWlnaHQgLSAzKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHN1YldpZHRoOyB4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHhvZmZzZXQgPSB4IDw8IEh5YnJpZEJpbmFyaXplci5CTE9DS19TSVpFX1BPV0VSO1xuICAgICAgICAgICAgICAgICAgICBpZiAoeG9mZnNldCA+IG1heFhPZmZzZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHhvZmZzZXQgPSBtYXhYT2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxlZnQgPSBIeWJyaWRCaW5hcml6ZXIuY2FwKHgsIDIsIHN1YldpZHRoIC0gMyk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzdW0gPSAwO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCB6ID0gLTI7IHogPD0gMjsgeisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBibGFja1JvdyA9IGJsYWNrUG9pbnRzW3RvcCArIHpdO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3VtICs9IGJsYWNrUm93W2xlZnQgLSAyXSArIGJsYWNrUm93W2xlZnQgLSAxXSArIGJsYWNrUm93W2xlZnRdICsgYmxhY2tSb3dbbGVmdCArIDFdICsgYmxhY2tSb3dbbGVmdCArIDJdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGF2ZXJhZ2UgPSBzdW0gLyAyNTtcbiAgICAgICAgICAgICAgICAgICAgSHlicmlkQmluYXJpemVyLnRocmVzaG9sZEJsb2NrKGx1bWluYW5jZXMsIHhvZmZzZXQsIHlvZmZzZXQsIGF2ZXJhZ2UsIHdpZHRoLCBtYXRyaXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgY2FwKHZhbHVlIC8qaW50Ki8sIG1pbiAvKmludCovLCBtYXggLyppbnQqLykge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlIDwgbWluID8gbWluIDogdmFsdWUgPiBtYXggPyBtYXggOiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQXBwbGllcyBhIHNpbmdsZSB0aHJlc2hvbGQgdG8gYSBibG9jayBvZiBwaXhlbHMuXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgdGhyZXNob2xkQmxvY2sobHVtaW5hbmNlcywgeG9mZnNldCAvKmludCovLCB5b2Zmc2V0IC8qaW50Ki8sIHRocmVzaG9sZCAvKmludCovLCBzdHJpZGUgLyppbnQqLywgbWF0cml4KSB7XG4gICAgICAgICAgICBmb3IgKGxldCB5ID0gMCwgb2Zmc2V0ID0geW9mZnNldCAqIHN0cmlkZSArIHhvZmZzZXQ7IHkgPCBIeWJyaWRCaW5hcml6ZXIuQkxPQ0tfU0laRTsgeSsrLCBvZmZzZXQgKz0gc3RyaWRlKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCBIeWJyaWRCaW5hcml6ZXIuQkxPQ0tfU0laRTsgeCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENvbXBhcmlzb24gbmVlZHMgdG8gYmUgPD0gc28gdGhhdCBibGFjayA9PSAwIHBpeGVscyBhcmUgYmxhY2sgZXZlbiBpZiB0aGUgdGhyZXNob2xkIGlzIDAuXG4gICAgICAgICAgICAgICAgICAgIGlmICgobHVtaW5hbmNlc1tvZmZzZXQgKyB4XSAmIDB4RkYpIDw9IHRocmVzaG9sZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0cml4LnNldCh4b2Zmc2V0ICsgeCwgeW9mZnNldCArIHkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWxjdWxhdGVzIGEgc2luZ2xlIGJsYWNrIHBvaW50IGZvciBlYWNoIGJsb2NrIG9mIHBpeGVscyBhbmQgc2F2ZXMgaXQgYXdheS5cbiAgICAgICAgICogU2VlIHRoZSBmb2xsb3dpbmcgdGhyZWFkIGZvciBhIGRpc2N1c3Npb24gb2YgdGhpcyBhbGdvcml0aG06XG4gICAgICAgICAqICBodHRwOi8vZ3JvdXBzLmdvb2dsZS5jb20vZ3JvdXAvenhpbmcvYnJvd3NlX3RocmVhZC90aHJlYWQvZDA2ZWZhMmMzNWE3ZGRjMFxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGNhbGN1bGF0ZUJsYWNrUG9pbnRzKGx1bWluYW5jZXMsIHN1YldpZHRoIC8qaW50Ki8sIHN1YkhlaWdodCAvKmludCovLCB3aWR0aCAvKmludCovLCBoZWlnaHQgLyppbnQqLykge1xuICAgICAgICAgICAgY29uc3QgbWF4WU9mZnNldCA9IGhlaWdodCAtIEh5YnJpZEJpbmFyaXplci5CTE9DS19TSVpFO1xuICAgICAgICAgICAgY29uc3QgbWF4WE9mZnNldCA9IHdpZHRoIC0gSHlicmlkQmluYXJpemVyLkJMT0NLX1NJWkU7XG4gICAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6d2hpdGVzcGFjZVxuICAgICAgICAgICAgY29uc3QgYmxhY2tQb2ludHMgPSBuZXcgQXJyYXkoc3ViSGVpZ2h0KTsgLy8gc3ViV2lkdGhcbiAgICAgICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgc3ViSGVpZ2h0OyB5KyspIHtcbiAgICAgICAgICAgICAgICBibGFja1BvaW50c1t5XSA9IG5ldyBJbnQzMkFycmF5KHN1YldpZHRoKTtcbiAgICAgICAgICAgICAgICBsZXQgeW9mZnNldCA9IHkgPDwgSHlicmlkQmluYXJpemVyLkJMT0NLX1NJWkVfUE9XRVI7XG4gICAgICAgICAgICAgICAgaWYgKHlvZmZzZXQgPiBtYXhZT2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHlvZmZzZXQgPSBtYXhZT2Zmc2V0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHN1YldpZHRoOyB4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHhvZmZzZXQgPSB4IDw8IEh5YnJpZEJpbmFyaXplci5CTE9DS19TSVpFX1BPV0VSO1xuICAgICAgICAgICAgICAgICAgICBpZiAoeG9mZnNldCA+IG1heFhPZmZzZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHhvZmZzZXQgPSBtYXhYT2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxldCBzdW0gPSAwO1xuICAgICAgICAgICAgICAgICAgICBsZXQgbWluID0gMHhGRjtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG1heCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHl5ID0gMCwgb2Zmc2V0ID0geW9mZnNldCAqIHdpZHRoICsgeG9mZnNldDsgeXkgPCBIeWJyaWRCaW5hcml6ZXIuQkxPQ0tfU0laRTsgeXkrKywgb2Zmc2V0ICs9IHdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCB4eCA9IDA7IHh4IDwgSHlicmlkQmluYXJpemVyLkJMT0NLX1NJWkU7IHh4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwaXhlbCA9IGx1bWluYW5jZXNbb2Zmc2V0ICsgeHhdICYgMHhGRjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdW0gKz0gcGl4ZWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3RpbGwgbG9va2luZyBmb3IgZ29vZCBjb250cmFzdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwaXhlbCA8IG1pbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW4gPSBwaXhlbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBpeGVsID4gbWF4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heCA9IHBpeGVsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNob3J0LWNpcmN1aXQgbWluL21heCB0ZXN0cyBvbmNlIGR5bmFtaWMgcmFuZ2UgaXMgbWV0XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWF4IC0gbWluID4gSHlicmlkQmluYXJpemVyLk1JTl9EWU5BTUlDX1JBTkdFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZmluaXNoIHRoZSByZXN0IG9mIHRoZSByb3dzIHF1aWNrbHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHl5KyssIG9mZnNldCArPSB3aWR0aDsgeXkgPCBIeWJyaWRCaW5hcml6ZXIuQkxPQ0tfU0laRTsgeXkrKywgb2Zmc2V0ICs9IHdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHh4ID0gMDsgeHggPCBIeWJyaWRCaW5hcml6ZXIuQkxPQ0tfU0laRTsgeHgrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VtICs9IGx1bWluYW5jZXNbb2Zmc2V0ICsgeHhdICYgMHhGRjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgZGVmYXVsdCBlc3RpbWF0ZSBpcyB0aGUgYXZlcmFnZSBvZiB0aGUgdmFsdWVzIGluIHRoZSBibG9jay5cbiAgICAgICAgICAgICAgICAgICAgbGV0IGF2ZXJhZ2UgPSBzdW0gPj4gKEh5YnJpZEJpbmFyaXplci5CTE9DS19TSVpFX1BPV0VSICogMik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXggLSBtaW4gPD0gSHlicmlkQmluYXJpemVyLk1JTl9EWU5BTUlDX1JBTkdFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB2YXJpYXRpb24gd2l0aGluIHRoZSBibG9jayBpcyBsb3csIGFzc3VtZSB0aGlzIGlzIGEgYmxvY2sgd2l0aCBvbmx5IGxpZ2h0IG9yIG9ubHlcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRhcmsgcGl4ZWxzLiBJbiB0aGF0IGNhc2Ugd2UgZG8gbm90IHdhbnQgdG8gdXNlIHRoZSBhdmVyYWdlLCBhcyBpdCB3b3VsZCBkaXZpZGUgdGhpc1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbG93IGNvbnRyYXN0IGFyZWEgaW50byBibGFjayBhbmQgd2hpdGUgcGl4ZWxzLCBlc3NlbnRpYWxseSBjcmVhdGluZyBkYXRhIG91dCBvZiBub2lzZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgZGVmYXVsdCBhc3N1bXB0aW9uIGlzIHRoYXQgdGhlIGJsb2NrIGlzIGxpZ2h0L2JhY2tncm91bmQuIFNpbmNlIG5vIGVzdGltYXRlIGZvclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGxldmVsIG9mIGRhcmsgcGl4ZWxzIGV4aXN0cyBsb2NhbGx5LCB1c2UgaGFsZiB0aGUgbWluIGZvciB0aGUgYmxvY2suXG4gICAgICAgICAgICAgICAgICAgICAgICBhdmVyYWdlID0gbWluIC8gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh5ID4gMCAmJiB4ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvcnJlY3QgdGhlIFwid2hpdGUgYmFja2dyb3VuZFwiIGFzc3VtcHRpb24gZm9yIGJsb2NrcyB0aGF0IGhhdmUgbmVpZ2hib3JzIGJ5IGNvbXBhcmluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBwaXhlbHMgaW4gdGhpcyBibG9jayB0byB0aGUgcHJldmlvdXNseSBjYWxjdWxhdGVkIGJsYWNrIHBvaW50cy4gVGhpcyBpcyBiYXNlZCBvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBmYWN0IHRoYXQgZGFyayBiYXJjb2RlIHN5bWJvbG9neSBpcyBhbHdheXMgc3Vycm91bmRlZCBieSBzb21lIGFtb3VudCBvZiBsaWdodFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJhY2tncm91bmQgZm9yIHdoaWNoIHJlYXNvbmFibGUgYmxhY2sgcG9pbnQgZXN0aW1hdGVzIHdlcmUgbWFkZS4gVGhlIGJwIGVzdGltYXRlZCBhdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBib3VuZGFyaWVzIGlzIHVzZWQgZm9yIHRoZSBpbnRlcmlvci5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgKG1pbiA8IGJwKSBpcyBhcmJpdHJhcnkgYnV0IHdvcmtzIGJldHRlciB0aGFuIG90aGVyIGhldXJpc3RpY3MgdGhhdCB3ZXJlIHRyaWVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGF2ZXJhZ2VOZWlnaGJvckJsYWNrUG9pbnQgPSAoYmxhY2tQb2ludHNbeSAtIDFdW3hdICsgKDIgKiBibGFja1BvaW50c1t5XVt4IC0gMV0pICsgYmxhY2tQb2ludHNbeSAtIDFdW3ggLSAxXSkgLyA0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtaW4gPCBhdmVyYWdlTmVpZ2hib3JCbGFja1BvaW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF2ZXJhZ2UgPSBhdmVyYWdlTmVpZ2hib3JCbGFja1BvaW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBibGFja1BvaW50c1t5XVt4XSA9IGF2ZXJhZ2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGJsYWNrUG9pbnRzO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFRoaXMgY2xhc3MgdXNlcyA1eDUgYmxvY2tzIHRvIGNvbXB1dGUgbG9jYWwgbHVtaW5hbmNlLCB3aGVyZSBlYWNoIGJsb2NrIGlzIDh4OCBwaXhlbHMuXG4gICAgLy8gU28gdGhpcyBpcyB0aGUgc21hbGxlc3QgZGltZW5zaW9uIGluIGVhY2ggYXhpcyB3ZSBjYW4gYWNjZXB0LlxuICAgIEh5YnJpZEJpbmFyaXplci5CTE9DS19TSVpFX1BPV0VSID0gMztcbiAgICBIeWJyaWRCaW5hcml6ZXIuQkxPQ0tfU0laRSA9IDEgPDwgSHlicmlkQmluYXJpemVyLkJMT0NLX1NJWkVfUE9XRVI7IC8vIC4uLjAxMDAuLi4wMFxuICAgIEh5YnJpZEJpbmFyaXplci5CTE9DS19TSVpFX01BU0sgPSBIeWJyaWRCaW5hcml6ZXIuQkxPQ0tfU0laRSAtIDE7IC8vIC4uLjAwMTEuLi4xMVxuICAgIEh5YnJpZEJpbmFyaXplci5NSU5JTVVNX0RJTUVOU0lPTiA9IEh5YnJpZEJpbmFyaXplci5CTE9DS19TSVpFICogNTtcbiAgICBIeWJyaWRCaW5hcml6ZXIuTUlOX0RZTkFNSUNfUkFOR0UgPSAyNDtcblxuICAgIC8qXG4gICAgICogQ29weXJpZ2h0IDIwMDkgWlhpbmcgYXV0aG9yc1xuICAgICAqXG4gICAgICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgICAgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICAgICpcbiAgICAgKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICAgICAqXG4gICAgICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICAgICAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgICAgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgICAgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gICAgICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gICAgICovXG4gICAgLypuYW1lc3BhY2UgY29tLmdvb2dsZS56eGluZyB7Ki9cbiAgICAvKipcbiAgICAgKiBUaGUgcHVycG9zZSBvZiB0aGlzIGNsYXNzIGhpZXJhcmNoeSBpcyB0byBhYnN0cmFjdCBkaWZmZXJlbnQgYml0bWFwIGltcGxlbWVudGF0aW9ucyBhY3Jvc3NcbiAgICAgKiBwbGF0Zm9ybXMgaW50byBhIHN0YW5kYXJkIGludGVyZmFjZSBmb3IgcmVxdWVzdGluZyBncmV5c2NhbGUgbHVtaW5hbmNlIHZhbHVlcy4gVGhlIGludGVyZmFjZVxuICAgICAqIG9ubHkgcHJvdmlkZXMgaW1tdXRhYmxlIG1ldGhvZHM7IHRoZXJlZm9yZSBjcm9wIGFuZCByb3RhdGlvbiBjcmVhdGUgY29waWVzLiBUaGlzIGlzIHRvIGVuc3VyZVxuICAgICAqIHRoYXQgb25lIFJlYWRlciBkb2VzIG5vdCBtb2RpZnkgdGhlIG9yaWdpbmFsIGx1bWluYW5jZSBzb3VyY2UgYW5kIGxlYXZlIGl0IGluIGFuIHVua25vd24gc3RhdGVcbiAgICAgKiBmb3Igb3RoZXIgUmVhZGVycyBpbiB0aGUgY2hhaW4uXG4gICAgICpcbiAgICAgKiBAYXV0aG9yIGRzd2l0a2luQGdvb2dsZS5jb20gKERhbmllbCBTd2l0a2luKVxuICAgICAqL1xuICAgIGNsYXNzIEx1bWluYW5jZVNvdXJjZSB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHdpZHRoIC8qaW50Ki8sIGhlaWdodCAvKmludCovKSB7XG4gICAgICAgICAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiBUaGUgd2lkdGggb2YgdGhlIGJpdG1hcC5cbiAgICAgICAgICovXG4gICAgICAgIGdldFdpZHRoKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gVGhlIGhlaWdodCBvZiB0aGUgYml0bWFwLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0SGVpZ2h0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIFdoZXRoZXIgdGhpcyBzdWJjbGFzcyBzdXBwb3J0cyBjcm9wcGluZy5cbiAgICAgICAgICovXG4gICAgICAgIGlzQ3JvcFN1cHBvcnRlZCgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBhIG5ldyBvYmplY3Qgd2l0aCBjcm9wcGVkIGltYWdlIGRhdGEuIEltcGxlbWVudGF0aW9ucyBtYXkga2VlcCBhIHJlZmVyZW5jZSB0byB0aGVcbiAgICAgICAgICogb3JpZ2luYWwgZGF0YSByYXRoZXIgdGhhbiBhIGNvcHkuIE9ubHkgY2FsbGFibGUgaWYgaXNDcm9wU3VwcG9ydGVkKCkgaXMgdHJ1ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGxlZnQgVGhlIGxlZnQgY29vcmRpbmF0ZSwgd2hpY2ggbXVzdCBiZSBpbiBbMCxnZXRXaWR0aCgpKVxuICAgICAgICAgKiBAcGFyYW0gdG9wIFRoZSB0b3AgY29vcmRpbmF0ZSwgd2hpY2ggbXVzdCBiZSBpbiBbMCxnZXRIZWlnaHQoKSlcbiAgICAgICAgICogQHBhcmFtIHdpZHRoIFRoZSB3aWR0aCBvZiB0aGUgcmVjdGFuZ2xlIHRvIGNyb3AuXG4gICAgICAgICAqIEBwYXJhbSBoZWlnaHQgVGhlIGhlaWdodCBvZiB0aGUgcmVjdGFuZ2xlIHRvIGNyb3AuXG4gICAgICAgICAqIEByZXR1cm4gQSBjcm9wcGVkIHZlcnNpb24gb2YgdGhpcyBvYmplY3QuXG4gICAgICAgICAqL1xuICAgICAgICBjcm9wKGxlZnQgLyppbnQqLywgdG9wIC8qaW50Ki8sIHdpZHRoIC8qaW50Ki8sIGhlaWdodCAvKmludCovKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRPcGVyYXRpb25FeGNlcHRpb24oJ1RoaXMgbHVtaW5hbmNlIHNvdXJjZSBkb2VzIG5vdCBzdXBwb3J0IGNyb3BwaW5nLicpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIFdoZXRoZXIgdGhpcyBzdWJjbGFzcyBzdXBwb3J0cyBjb3VudGVyLWNsb2Nrd2lzZSByb3RhdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIGlzUm90YXRlU3VwcG9ydGVkKCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGEgbmV3IG9iamVjdCB3aXRoIHJvdGF0ZWQgaW1hZ2UgZGF0YSBieSA5MCBkZWdyZWVzIGNvdW50ZXJjbG9ja3dpc2UuXG4gICAgICAgICAqIE9ubHkgY2FsbGFibGUgaWYge0BsaW5rICNpc1JvdGF0ZVN1cHBvcnRlZCgpfSBpcyB0cnVlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIEEgcm90YXRlZCB2ZXJzaW9uIG9mIHRoaXMgb2JqZWN0LlxuICAgICAgICAgKi9cbiAgICAgICAgcm90YXRlQ291bnRlckNsb2Nrd2lzZSgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZE9wZXJhdGlvbkV4Y2VwdGlvbignVGhpcyBsdW1pbmFuY2Ugc291cmNlIGRvZXMgbm90IHN1cHBvcnQgcm90YXRpb24gYnkgOTAgZGVncmVlcy4nKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBhIG5ldyBvYmplY3Qgd2l0aCByb3RhdGVkIGltYWdlIGRhdGEgYnkgNDUgZGVncmVlcyBjb3VudGVyY2xvY2t3aXNlLlxuICAgICAgICAgKiBPbmx5IGNhbGxhYmxlIGlmIHtAbGluayAjaXNSb3RhdGVTdXBwb3J0ZWQoKX0gaXMgdHJ1ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiBBIHJvdGF0ZWQgdmVyc2lvbiBvZiB0aGlzIG9iamVjdC5cbiAgICAgICAgICovXG4gICAgICAgIHJvdGF0ZUNvdW50ZXJDbG9ja3dpc2U0NSgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZE9wZXJhdGlvbkV4Y2VwdGlvbignVGhpcyBsdW1pbmFuY2Ugc291cmNlIGRvZXMgbm90IHN1cHBvcnQgcm90YXRpb24gYnkgNDUgZGVncmVlcy4nKTtcbiAgICAgICAgfVxuICAgICAgICAvKkBPdmVycmlkZSovXG4gICAgICAgIHRvU3RyaW5nKCkge1xuICAgICAgICAgICAgY29uc3Qgcm93ID0gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KHRoaXMud2lkdGgpO1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IG5ldyBTdHJpbmdCdWlsZGVyKCk7XG4gICAgICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IHRoaXMuaGVpZ2h0OyB5KyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzb3VyY2VSb3cgPSB0aGlzLmdldFJvdyh5LCByb3cpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgdGhpcy53aWR0aDsgeCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGx1bWluYW5jZSA9IHNvdXJjZVJvd1t4XSAmIDB4RkY7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjO1xuICAgICAgICAgICAgICAgICAgICBpZiAobHVtaW5hbmNlIDwgMHg0MCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYyA9ICcjJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChsdW1pbmFuY2UgPCAweDgwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjID0gJysnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGx1bWluYW5jZSA8IDB4QzApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMgPSAnLic7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjID0gJyAnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoYyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoJ1xcbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBDb3B5cmlnaHQgMjAwOSBaWGluZyBhdXRob3JzXG4gICAgICpcbiAgICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgICAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgICAgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgICAgKlxuICAgICAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gICAgICpcbiAgICAgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICAgICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgICAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICAgICAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgICAgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAgICAgKi9cbiAgICAvKm5hbWVzcGFjZSBjb20uZ29vZ2xlLnp4aW5nIHsqL1xuICAgIC8qKlxuICAgICAqIEEgd3JhcHBlciBpbXBsZW1lbnRhdGlvbiBvZiB7QGxpbmsgTHVtaW5hbmNlU291cmNlfSB3aGljaCBpbnZlcnRzIHRoZSBsdW1pbmFuY2VzIGl0IHJldHVybnMgLS0gYmxhY2sgYmVjb21lc1xuICAgICAqIHdoaXRlIGFuZCB2aWNlIHZlcnNhLCBhbmQgZWFjaCB2YWx1ZSBiZWNvbWVzICgyNTUtdmFsdWUpLlxuICAgICAqXG4gICAgICogQGF1dGhvciBTZWFuIE93ZW5cbiAgICAgKi9cbiAgICBjbGFzcyBJbnZlcnRlZEx1bWluYW5jZVNvdXJjZSBleHRlbmRzIEx1bWluYW5jZVNvdXJjZSB7XG4gICAgICAgIGNvbnN0cnVjdG9yKGRlbGVnYXRlKSB7XG4gICAgICAgICAgICBzdXBlcihkZWxlZ2F0ZS5nZXRXaWR0aCgpLCBkZWxlZ2F0ZS5nZXRIZWlnaHQoKSk7XG4gICAgICAgICAgICB0aGlzLmRlbGVnYXRlID0gZGVsZWdhdGU7XG4gICAgICAgIH1cbiAgICAgICAgLypAT3ZlcnJpZGUqL1xuICAgICAgICBnZXRSb3coeSAvKmludCovLCByb3cpIHtcbiAgICAgICAgICAgIGNvbnN0IHNvdXJjZVJvdyA9IHRoaXMuZGVsZWdhdGUuZ2V0Um93KHksIHJvdyk7XG4gICAgICAgICAgICBjb25zdCB3aWR0aCA9IHRoaXMuZ2V0V2lkdGgoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd2lkdGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHNvdXJjZVJvd1tpXSA9IC8qKGJ5dGUpKi8gKDI1NSAtIChzb3VyY2VSb3dbaV0gJiAweEZGKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc291cmNlUm93O1xuICAgICAgICB9XG4gICAgICAgIC8qQE92ZXJyaWRlKi9cbiAgICAgICAgZ2V0TWF0cml4KCkge1xuICAgICAgICAgICAgY29uc3QgbWF0cml4ID0gdGhpcy5kZWxlZ2F0ZS5nZXRNYXRyaXgoKTtcbiAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IHRoaXMuZ2V0V2lkdGgoKSAqIHRoaXMuZ2V0SGVpZ2h0KCk7XG4gICAgICAgICAgICBjb25zdCBpbnZlcnRlZE1hdHJpeCA9IG5ldyBVaW50OENsYW1wZWRBcnJheShsZW5ndGgpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGludmVydGVkTWF0cml4W2ldID0gLyooYnl0ZSkqLyAoMjU1IC0gKG1hdHJpeFtpXSAmIDB4RkYpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpbnZlcnRlZE1hdHJpeDtcbiAgICAgICAgfVxuICAgICAgICAvKkBPdmVycmlkZSovXG4gICAgICAgIGlzQ3JvcFN1cHBvcnRlZCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlbGVnYXRlLmlzQ3JvcFN1cHBvcnRlZCgpO1xuICAgICAgICB9XG4gICAgICAgIC8qQE92ZXJyaWRlKi9cbiAgICAgICAgY3JvcChsZWZ0IC8qaW50Ki8sIHRvcCAvKmludCovLCB3aWR0aCAvKmludCovLCBoZWlnaHQgLyppbnQqLykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnZlcnRlZEx1bWluYW5jZVNvdXJjZSh0aGlzLmRlbGVnYXRlLmNyb3AobGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0KSk7XG4gICAgICAgIH1cbiAgICAgICAgLypAT3ZlcnJpZGUqL1xuICAgICAgICBpc1JvdGF0ZVN1cHBvcnRlZCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlbGVnYXRlLmlzUm90YXRlU3VwcG9ydGVkKCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gb3JpZ2luYWwgZGVsZWdhdGUge0BsaW5rIEx1bWluYW5jZVNvdXJjZX0gc2luY2UgaW52ZXJ0IHVuZG9lcyBpdHNlbGZcbiAgICAgICAgICovXG4gICAgICAgIC8qQE92ZXJyaWRlKi9cbiAgICAgICAgaW52ZXJ0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVsZWdhdGU7XG4gICAgICAgIH1cbiAgICAgICAgLypAT3ZlcnJpZGUqL1xuICAgICAgICByb3RhdGVDb3VudGVyQ2xvY2t3aXNlKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnZlcnRlZEx1bWluYW5jZVNvdXJjZSh0aGlzLmRlbGVnYXRlLnJvdGF0ZUNvdW50ZXJDbG9ja3dpc2UoKSk7XG4gICAgICAgIH1cbiAgICAgICAgLypAT3ZlcnJpZGUqL1xuICAgICAgICByb3RhdGVDb3VudGVyQ2xvY2t3aXNlNDUoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEludmVydGVkTHVtaW5hbmNlU291cmNlKHRoaXMuZGVsZWdhdGUucm90YXRlQ291bnRlckNsb2Nrd2lzZTQ1KCkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgTW92aW5nIHRvIEB6eGluZy9icm93c2VyXG4gICAgICovXG4gICAgY2xhc3MgSFRNTENhbnZhc0VsZW1lbnRMdW1pbmFuY2VTb3VyY2UgZXh0ZW5kcyBMdW1pbmFuY2VTb3VyY2Uge1xuICAgICAgICBjb25zdHJ1Y3RvcihjYW52YXMpIHtcbiAgICAgICAgICAgIHN1cGVyKGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICAgICAgICB0aGlzLmNhbnZhcyA9IGNhbnZhcztcbiAgICAgICAgICAgIHRoaXMudGVtcENhbnZhc0VsZW1lbnQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5idWZmZXIgPSBIVE1MQ2FudmFzRWxlbWVudEx1bWluYW5jZVNvdXJjZS5tYWtlQnVmZmVyRnJvbUNhbnZhc0ltYWdlRGF0YShjYW52YXMpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBtYWtlQnVmZmVyRnJvbUNhbnZhc0ltYWdlRGF0YShjYW52YXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGltYWdlRGF0YSA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpLmdldEltYWdlRGF0YSgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgICAgICAgcmV0dXJuIEhUTUxDYW52YXNFbGVtZW50THVtaW5hbmNlU291cmNlLnRvR3JheXNjYWxlQnVmZmVyKGltYWdlRGF0YS5kYXRhLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyB0b0dyYXlzY2FsZUJ1ZmZlcihpbWFnZUJ1ZmZlciwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICAgICAgY29uc3QgZ3JheXNjYWxlQnVmZmVyID0gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KHdpZHRoICogaGVpZ2h0KTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBqID0gMCwgbGVuZ3RoID0gaW1hZ2VCdWZmZXIubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpICs9IDQsIGorKykge1xuICAgICAgICAgICAgICAgIGxldCBncmF5O1xuICAgICAgICAgICAgICAgIGNvbnN0IGFscGhhID0gaW1hZ2VCdWZmZXJbaSArIDNdO1xuICAgICAgICAgICAgICAgIC8vIFRoZSBjb2xvciBvZiBmdWxseS10cmFuc3BhcmVudCBwaXhlbHMgaXMgaXJyZWxldmFudC4gVGhleSBhcmUgb2Z0ZW4sIHRlY2huaWNhbGx5LCBmdWxseS10cmFuc3BhcmVudFxuICAgICAgICAgICAgICAgIC8vIGJsYWNrICgwIGFscGhhLCBhbmQgdGhlbiAwIFJHQikuIFRoZXkgYXJlIG9mdGVuIHVzZWQsIG9mIGNvdXJzZSBhcyB0aGUgXCJ3aGl0ZVwiIGFyZWEgaW4gYVxuICAgICAgICAgICAgICAgIC8vIGJhcmNvZGUgaW1hZ2UuIEZvcmNlIGFueSBzdWNoIHBpeGVsIHRvIGJlIHdoaXRlOlxuICAgICAgICAgICAgICAgIGlmIChhbHBoYSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBncmF5ID0gMHhGRjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBpeGVsUiA9IGltYWdlQnVmZmVyW2ldO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwaXhlbEcgPSBpbWFnZUJ1ZmZlcltpICsgMV07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBpeGVsQiA9IGltYWdlQnVmZmVyW2kgKyAyXTtcbiAgICAgICAgICAgICAgICAgICAgLy8gLjI5OVIgKyAwLjU4N0cgKyAwLjExNEIgKFlVVi9ZSVEgZm9yIFBBTCBhbmQgTlRTQyksXG4gICAgICAgICAgICAgICAgICAgIC8vICgzMDYqUikgPj4gMTAgaXMgYXBwcm94aW1hdGVseSBlcXVhbCB0byBSKjAuMjk5LCBhbmQgc28gb24uXG4gICAgICAgICAgICAgICAgICAgIC8vIDB4MjAwID4+IDEwIGlzIDAuNSwgaXQgaW1wbGVtZW50cyByb3VuZGluZy5cbiAgICAgICAgICAgICAgICAgICAgZ3JheSA9ICgzMDYgKiBwaXhlbFIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgNjAxICogcGl4ZWxHICtcbiAgICAgICAgICAgICAgICAgICAgICAgIDExNyAqIHBpeGVsQiArXG4gICAgICAgICAgICAgICAgICAgICAgICAweDIwMCkgPj4gMTA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGdyYXlzY2FsZUJ1ZmZlcltqXSA9IGdyYXk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZ3JheXNjYWxlQnVmZmVyO1xuICAgICAgICB9XG4gICAgICAgIGdldFJvdyh5IC8qaW50Ki8sIHJvdykge1xuICAgICAgICAgICAgaWYgKHkgPCAwIHx8IHkgPj0gdGhpcy5nZXRIZWlnaHQoKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oJ1JlcXVlc3RlZCByb3cgaXMgb3V0c2lkZSB0aGUgaW1hZ2U6ICcgKyB5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gdGhpcy5nZXRXaWR0aCgpO1xuICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSB5ICogd2lkdGg7XG4gICAgICAgICAgICBpZiAocm93ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcm93ID0gdGhpcy5idWZmZXIuc2xpY2Uoc3RhcnQsIHN0YXJ0ICsgd2lkdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHJvdy5sZW5ndGggPCB3aWR0aCkge1xuICAgICAgICAgICAgICAgICAgICByb3cgPSBuZXcgVWludDhDbGFtcGVkQXJyYXkod2lkdGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBUaGUgdW5kZXJseWluZyByYXN0ZXIgb2YgaW1hZ2UgY29uc2lzdHMgb2YgYnl0ZXMgd2l0aCB0aGUgbHVtaW5hbmNlIHZhbHVlc1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IGNhbiBhdm9pZCBzZXQvc2xpY2U/XG4gICAgICAgICAgICAgICAgcm93LnNldCh0aGlzLmJ1ZmZlci5zbGljZShzdGFydCwgc3RhcnQgKyB3aWR0aCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJvdztcbiAgICAgICAgfVxuICAgICAgICBnZXRNYXRyaXgoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5idWZmZXI7XG4gICAgICAgIH1cbiAgICAgICAgaXNDcm9wU3VwcG9ydGVkKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY3JvcChsZWZ0IC8qaW50Ki8sIHRvcCAvKmludCovLCB3aWR0aCAvKmludCovLCBoZWlnaHQgLyppbnQqLykge1xuICAgICAgICAgICAgc3VwZXIuY3JvcChsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgaXMgYWx3YXlzIHRydWUsIHNpbmNlIHRoZSBpbWFnZSBpcyBhIGdyYXktc2NhbGUgaW1hZ2UuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4gdHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgaXNSb3RhdGVTdXBwb3J0ZWQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByb3RhdGVDb3VudGVyQ2xvY2t3aXNlKCkge1xuICAgICAgICAgICAgdGhpcy5yb3RhdGUoLTkwKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHJvdGF0ZUNvdW50ZXJDbG9ja3dpc2U0NSgpIHtcbiAgICAgICAgICAgIHRoaXMucm90YXRlKC00NSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBnZXRUZW1wQ2FudmFzRWxlbWVudCgpIHtcbiAgICAgICAgICAgIGlmIChudWxsID09PSB0aGlzLnRlbXBDYW52YXNFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGVtcENhbnZhc0VsZW1lbnQgPSB0aGlzLmNhbnZhcy5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICAgICAgICAgIHRlbXBDYW52YXNFbGVtZW50LndpZHRoID0gdGhpcy5jYW52YXMud2lkdGg7XG4gICAgICAgICAgICAgICAgdGVtcENhbnZhc0VsZW1lbnQuaGVpZ2h0ID0gdGhpcy5jYW52YXMuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIHRoaXMudGVtcENhbnZhc0VsZW1lbnQgPSB0ZW1wQ2FudmFzRWxlbWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRlbXBDYW52YXNFbGVtZW50O1xuICAgICAgICB9XG4gICAgICAgIHJvdGF0ZShhbmdsZSkge1xuICAgICAgICAgICAgY29uc3QgdGVtcENhbnZhc0VsZW1lbnQgPSB0aGlzLmdldFRlbXBDYW52YXNFbGVtZW50KCk7XG4gICAgICAgICAgICBjb25zdCB0ZW1wQ29udGV4dCA9IHRlbXBDYW52YXNFbGVtZW50LmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgICAgICBjb25zdCBhbmdsZVJhZGlhbnMgPSBhbmdsZSAqIEhUTUxDYW52YXNFbGVtZW50THVtaW5hbmNlU291cmNlLkRFR1JFRV9UT19SQURJQU5TO1xuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIGFuZCBzZXQgbmV3IGRpbWVuc2lvbnMgZm9yIHRlbXAgY2FudmFzXG4gICAgICAgICAgICBjb25zdCB3aWR0aCA9IHRoaXMuY2FudmFzLndpZHRoO1xuICAgICAgICAgICAgY29uc3QgaGVpZ2h0ID0gdGhpcy5jYW52YXMuaGVpZ2h0O1xuICAgICAgICAgICAgY29uc3QgbmV3V2lkdGggPSBNYXRoLmNlaWwoTWF0aC5hYnMoTWF0aC5jb3MoYW5nbGVSYWRpYW5zKSkgKiB3aWR0aCArIE1hdGguYWJzKE1hdGguc2luKGFuZ2xlUmFkaWFucykpICogaGVpZ2h0KTtcbiAgICAgICAgICAgIGNvbnN0IG5ld0hlaWdodCA9IE1hdGguY2VpbChNYXRoLmFicyhNYXRoLnNpbihhbmdsZVJhZGlhbnMpKSAqIHdpZHRoICsgTWF0aC5hYnMoTWF0aC5jb3MoYW5nbGVSYWRpYW5zKSkgKiBoZWlnaHQpO1xuICAgICAgICAgICAgdGVtcENhbnZhc0VsZW1lbnQud2lkdGggPSBuZXdXaWR0aDtcbiAgICAgICAgICAgIHRlbXBDYW52YXNFbGVtZW50LmhlaWdodCA9IG5ld0hlaWdodDtcbiAgICAgICAgICAgIC8vIERyYXcgYXQgY2VudGVyIG9mIHRlbXAgY2FudmFzIHRvIHByZXZlbnQgY2xpcHBpbmcgb2YgaW1hZ2UgZGF0YVxuICAgICAgICAgICAgdGVtcENvbnRleHQudHJhbnNsYXRlKG5ld1dpZHRoIC8gMiwgbmV3SGVpZ2h0IC8gMik7XG4gICAgICAgICAgICB0ZW1wQ29udGV4dC5yb3RhdGUoYW5nbGVSYWRpYW5zKTtcbiAgICAgICAgICAgIHRlbXBDb250ZXh0LmRyYXdJbWFnZSh0aGlzLmNhbnZhcywgd2lkdGggLyAtMiwgaGVpZ2h0IC8gLTIpO1xuICAgICAgICAgICAgdGhpcy5idWZmZXIgPSBIVE1MQ2FudmFzRWxlbWVudEx1bWluYW5jZVNvdXJjZS5tYWtlQnVmZmVyRnJvbUNhbnZhc0ltYWdlRGF0YSh0ZW1wQ2FudmFzRWxlbWVudCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBpbnZlcnQoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEludmVydGVkTHVtaW5hbmNlU291cmNlKHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIEhUTUxDYW52YXNFbGVtZW50THVtaW5hbmNlU291cmNlLkRFR1JFRV9UT19SQURJQU5TID0gTWF0aC5QSSAvIDE4MDtcblxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIE1vdmluZyB0byBAenhpbmcvYnJvd3NlclxuICAgICAqXG4gICAgICogVmlkZW8gaW5wdXQgZGV2aWNlIG1ldGFkYXRhIGNvbnRhaW5pbmcgdGhlIGlkIGFuZCBsYWJlbCBvZiB0aGUgZGV2aWNlIGlmIGF2YWlsYWJsZS5cbiAgICAgKi9cbiAgICBjbGFzcyBWaWRlb0lucHV0RGV2aWNlIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgVmlkZW9JbnB1dERldmljZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGRldmljZUlkIHRoZSB2aWRlbyBpbnB1dCBkZXZpY2UgaWRcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGxhYmVsIHRoZSBsYWJlbCBvZiB0aGUgZGV2aWNlIGlmIGF2YWlsYWJsZVxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3RydWN0b3IoZGV2aWNlSWQsIGxhYmVsLCBncm91cElkKSB7XG4gICAgICAgICAgICB0aGlzLmRldmljZUlkID0gZGV2aWNlSWQ7XG4gICAgICAgICAgICB0aGlzLmxhYmVsID0gbGFiZWw7XG4gICAgICAgICAgICAvKiogQGluaGVyaXRkb2MgKi9cbiAgICAgICAgICAgIHRoaXMua2luZCA9ICd2aWRlb2lucHV0JztcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBJZCA9IGdyb3VwSWQgfHwgdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIC8qKiBAaW5oZXJpdGRvYyAqL1xuICAgICAgICB0b0pTT04oKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGtpbmQ6IHRoaXMua2luZCxcbiAgICAgICAgICAgICAgICBncm91cElkOiB0aGlzLmdyb3VwSWQsXG4gICAgICAgICAgICAgICAgZGV2aWNlSWQ6IHRoaXMuZGV2aWNlSWQsXG4gICAgICAgICAgICAgICAgbGFiZWw6IHRoaXMubGFiZWwsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIF9fYXdhaXRlciA9ICgoZ2xvYmFsVGhpcyB8fCBnbG9iYWwgfHwgc2VsZiB8fCB3aW5kb3cgfHwgdW5kZWZpbmVkKSAmJiAoZ2xvYmFsVGhpcyB8fCBnbG9iYWwgfHwgc2VsZiB8fCB3aW5kb3cgfHwgdW5kZWZpbmVkKS5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICAgICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIE1vdmluZyB0byBAenhpbmcvYnJvd3NlclxuICAgICAqXG4gICAgICogQmFzZSBjbGFzcyBmb3IgYnJvd3NlciBjb2RlIHJlYWRlci5cbiAgICAgKi9cbiAgICBjbGFzcyBCcm93c2VyQ29kZVJlYWRlciB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIEJyb3dzZXJDb2RlUmVhZGVyLlxuICAgICAgICAgKiBAcGFyYW0ge1JlYWRlcn0gcmVhZGVyIFRoZSByZWFkZXIgaW5zdGFuY2UgdG8gZGVjb2RlIHRoZSBiYXJjb2RlXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbdGltZUJldHdlZW5TY2Fuc01pbGxpcz01MDBdIHRoZSB0aW1lIGRlbGF5IGJldHdlZW4gc3Vic2VxdWVudCBzdWNjZXNzZnVsIGRlY29kZSB0cmllc1xuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyT2YgQnJvd3NlckNvZGVSZWFkZXJcbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0cnVjdG9yKHJlYWRlciwgdGltZUJldHdlZW5TY2Fuc01pbGxpcyA9IDUwMCwgX2hpbnRzKSB7XG4gICAgICAgICAgICB0aGlzLnJlYWRlciA9IHJlYWRlcjtcbiAgICAgICAgICAgIHRoaXMudGltZUJldHdlZW5TY2Fuc01pbGxpcyA9IHRpbWVCZXR3ZWVuU2NhbnNNaWxsaXM7XG4gICAgICAgICAgICB0aGlzLl9oaW50cyA9IF9oaW50cztcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhpcyB3aWxsIGJyZWFrIHRoZSBsb29wLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLl9zdG9wQ29udGludW91c0RlY29kZSA9IGZhbHNlO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGlzIHdpbGwgYnJlYWsgdGhlIGxvb3AuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuX3N0b3BBc3luY0RlY29kZSA9IGZhbHNlO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBEZWxheSB0aW1lIGJldHdlZW4gZGVjb2RlIGF0dGVtcHRzIG1hZGUgYnkgdGhlIHNjYW5uZXIuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuX3RpbWVCZXR3ZWVuRGVjb2RpbmdBdHRlbXB0cyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIG5hdmlnYXRvciBpcyBwcmVzZW50LlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0IGhhc05hdmlnYXRvcigpIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJztcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgbWVkaWFEZXZpY2VzIHVuZGVyIG5hdmlnYXRvciBpcyBzdXBwb3J0ZWQuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQgaXNNZWRpYURldmljZXNTdXBvcnRlZCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhhc05hdmlnYXRvciAmJiAhIW5hdmlnYXRvci5tZWRpYURldmljZXM7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIGVudW1lcmF0ZURldmljZXMgdW5kZXIgbmF2aWdhdG9yIGlzIHN1cHBvcnRlZC5cbiAgICAgICAgICovXG4gICAgICAgIGdldCBjYW5FbnVtZXJhdGVEZXZpY2VzKCkge1xuICAgICAgICAgICAgcmV0dXJuICEhKHRoaXMuaXNNZWRpYURldmljZXNTdXBvcnRlZCAmJiBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmVudW1lcmF0ZURldmljZXMpO1xuICAgICAgICB9XG4gICAgICAgIC8qKiBUaW1lIGJldHdlZW4gdHdvIGRlY29kaW5nIHRyaWVzIGluIG1pbGxpIHNlY29uZHMuICovXG4gICAgICAgIGdldCB0aW1lQmV0d2VlbkRlY29kaW5nQXR0ZW1wdHMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdGltZUJldHdlZW5EZWNvZGluZ0F0dGVtcHRzO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGFuZ2UgdGhlIHRpbWUgc3BhbiB0aGUgZGVjb2RlciB3YWl0cyBiZXR3ZWVuIHR3byBkZWNvZGluZyB0cmllcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IG1pbGxpcyBUaW1lIGJldHdlZW4gdHdvIGRlY29kaW5nIHRyaWVzIGluIG1pbGxpIHNlY29uZHMuXG4gICAgICAgICAqL1xuICAgICAgICBzZXQgdGltZUJldHdlZW5EZWNvZGluZ0F0dGVtcHRzKG1pbGxpcykge1xuICAgICAgICAgICAgdGhpcy5fdGltZUJldHdlZW5EZWNvZGluZ0F0dGVtcHRzID0gbWlsbGlzIDwgMCA/IDAgOiBtaWxsaXM7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIGhpbnRzLlxuICAgICAgICAgKi9cbiAgICAgICAgc2V0IGhpbnRzKGhpbnRzKSB7XG4gICAgICAgICAgICB0aGlzLl9oaW50cyA9IGhpbnRzIHx8IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIGhpbnRzLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0IGhpbnRzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hpbnRzO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMaXN0cyBhbGwgdGhlIGF2YWlsYWJsZSB2aWRlbyBpbnB1dCBkZXZpY2VzLlxuICAgICAgICAgKi9cbiAgICAgICAgbGlzdFZpZGVvSW5wdXREZXZpY2VzKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaGFzTmF2aWdhdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuXFwndCBlbnVtZXJhdGUgZGV2aWNlcywgbmF2aWdhdG9yIGlzIG5vdCBwcmVzZW50LicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuY2FuRW51bWVyYXRlRGV2aWNlcykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhblxcJ3QgZW51bWVyYXRlIGRldmljZXMsIG1ldGhvZCBub3Qgc3VwcG9ydGVkLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBkZXZpY2VzID0geWllbGQgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5lbnVtZXJhdGVEZXZpY2VzKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgdmlkZW9EZXZpY2VzID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBkZXZpY2Ugb2YgZGV2aWNlcykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBraW5kID0gZGV2aWNlLmtpbmQgPT09ICd2aWRlbycgPyAndmlkZW9pbnB1dCcgOiBkZXZpY2Uua2luZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtpbmQgIT09ICd2aWRlb2lucHV0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGV2aWNlSWQgPSBkZXZpY2UuZGV2aWNlSWQgfHwgZGV2aWNlLmlkO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsYWJlbCA9IGRldmljZS5sYWJlbCB8fCBgVmlkZW8gZGV2aWNlICR7dmlkZW9EZXZpY2VzLmxlbmd0aCArIDF9YDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZ3JvdXBJZCA9IGRldmljZS5ncm91cElkO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2aWRlb0RldmljZSA9IHsgZGV2aWNlSWQsIGxhYmVsLCBraW5kLCBncm91cElkIH07XG4gICAgICAgICAgICAgICAgICAgIHZpZGVvRGV2aWNlcy5wdXNoKHZpZGVvRGV2aWNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZpZGVvRGV2aWNlcztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPYnRhaW4gdGhlIGxpc3Qgb2YgYXZhaWxhYmxlIGRldmljZXMgd2l0aCB0eXBlICd2aWRlb2lucHV0Jy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8VmlkZW9JbnB1dERldmljZVtdPn0gYW4gYXJyYXkgb2YgYXZhaWxhYmxlIHZpZGVvIGlucHV0IGRldmljZXNcbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlck9mIEJyb3dzZXJDb2RlUmVhZGVyXG4gICAgICAgICAqXG4gICAgICAgICAqIEBkZXByZWNhdGVkIFVzZSBgbGlzdFZpZGVvSW5wdXREZXZpY2VzYCBpbnN0ZWFkLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0VmlkZW9JbnB1dERldmljZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRldmljZXMgPSB5aWVsZCB0aGlzLmxpc3RWaWRlb0lucHV0RGV2aWNlcygpO1xuICAgICAgICAgICAgICAgIHJldHVybiBkZXZpY2VzLm1hcChkID0+IG5ldyBWaWRlb0lucHV0RGV2aWNlKGQuZGV2aWNlSWQsIGQubGFiZWwpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMZXQncyB5b3UgZmluZCBhIGRldmljZSB1c2luZyBpdCdzIElkLlxuICAgICAgICAgKi9cbiAgICAgICAgZmluZERldmljZUJ5SWQoZGV2aWNlSWQpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGV2aWNlcyA9IHlpZWxkIHRoaXMubGlzdFZpZGVvSW5wdXREZXZpY2VzKCk7XG4gICAgICAgICAgICAgICAgaWYgKCFkZXZpY2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZGV2aWNlcy5maW5kKHggPT4geC5kZXZpY2VJZCA9PT0gZGV2aWNlSWQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlY29kZXMgdGhlIGJhcmNvZGUgZnJvbSB0aGUgZGV2aWNlIHNwZWNpZmllZCBieSBkZXZpY2VJZCB3aGlsZSBzaG93aW5nIHRoZSB2aWRlbyBpbiB0aGUgc3BlY2lmaWVkIHZpZGVvIGVsZW1lbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBkZXZpY2VJZCB0aGUgaWQgb2Ygb25lIG9mIHRoZSBkZXZpY2VzIG9idGFpbmVkIGFmdGVyIGNhbGxpbmcgZ2V0VmlkZW9JbnB1dERldmljZXMuIENhbiBiZSB1bmRlZmluZWQsIGluIHRoaXMgY2FzZSBpdCB3aWxsIGRlY29kZSBmcm9tIG9uZSBvZiB0aGUgYXZhaWxhYmxlIGRldmljZXMsIHByZWZmZXJpbmcgdGhlIG1haW4gY2FtZXJhIChlbnZpcm9ubWVudCBmYWNpbmcpIGlmIGF2YWlsYWJsZS5cbiAgICAgICAgICogQHBhcmFtIHZpZGVvIHRoZSB2aWRlbyBlbGVtZW50IGluIHBhZ2Ugd2hlcmUgdG8gc2hvdyB0aGUgdmlkZW8gd2hpbGUgZGVjb2RpbmcuIENhbiBiZSBlaXRoZXIgYW4gZWxlbWVudCBpZCBvciBkaXJlY3RseSBhbiBIVE1MVmlkZW9FbGVtZW50LiBDYW4gYmUgdW5kZWZpbmVkLCBpbiB3aGljaCBjYXNlIG5vIHZpZGVvIHdpbGwgYmUgc2hvd24uXG4gICAgICAgICAqIEByZXR1cm5zIFRoZSBkZWNvZGluZyByZXN1bHQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXJPZiBCcm93c2VyQ29kZVJlYWRlclxuICAgICAgICAgKlxuICAgICAgICAgKiBAZGVwcmVjYXRlZCBVc2UgYGRlY29kZU9uY2VGcm9tVmlkZW9EZXZpY2VgIGluc3RlYWQuXG4gICAgICAgICAqL1xuICAgICAgICBkZWNvZGVGcm9tSW5wdXRWaWRlb0RldmljZShkZXZpY2VJZCwgdmlkZW9Tb3VyY2UpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMuZGVjb2RlT25jZUZyb21WaWRlb0RldmljZShkZXZpY2VJZCwgdmlkZW9Tb3VyY2UpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluIG9uZSBhdHRlbXB0LCB0cmllcyB0byBkZWNvZGUgdGhlIGJhcmNvZGUgZnJvbSB0aGUgZGV2aWNlIHNwZWNpZmllZCBieSBkZXZpY2VJZCB3aGlsZSBzaG93aW5nIHRoZSB2aWRlbyBpbiB0aGUgc3BlY2lmaWVkIHZpZGVvIGVsZW1lbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBkZXZpY2VJZCB0aGUgaWQgb2Ygb25lIG9mIHRoZSBkZXZpY2VzIG9idGFpbmVkIGFmdGVyIGNhbGxpbmcgZ2V0VmlkZW9JbnB1dERldmljZXMuIENhbiBiZSB1bmRlZmluZWQsIGluIHRoaXMgY2FzZSBpdCB3aWxsIGRlY29kZSBmcm9tIG9uZSBvZiB0aGUgYXZhaWxhYmxlIGRldmljZXMsIHByZWZmZXJpbmcgdGhlIG1haW4gY2FtZXJhIChlbnZpcm9ubWVudCBmYWNpbmcpIGlmIGF2YWlsYWJsZS5cbiAgICAgICAgICogQHBhcmFtIHZpZGVvIHRoZSB2aWRlbyBlbGVtZW50IGluIHBhZ2Ugd2hlcmUgdG8gc2hvdyB0aGUgdmlkZW8gd2hpbGUgZGVjb2RpbmcuIENhbiBiZSBlaXRoZXIgYW4gZWxlbWVudCBpZCBvciBkaXJlY3RseSBhbiBIVE1MVmlkZW9FbGVtZW50LiBDYW4gYmUgdW5kZWZpbmVkLCBpbiB3aGljaCBjYXNlIG5vIHZpZGVvIHdpbGwgYmUgc2hvd24uXG4gICAgICAgICAqIEByZXR1cm5zIFRoZSBkZWNvZGluZyByZXN1bHQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXJPZiBCcm93c2VyQ29kZVJlYWRlclxuICAgICAgICAgKi9cbiAgICAgICAgZGVjb2RlT25jZUZyb21WaWRlb0RldmljZShkZXZpY2VJZCwgdmlkZW9Tb3VyY2UpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICAgICAgICAgIGxldCB2aWRlb0NvbnN0cmFpbnRzO1xuICAgICAgICAgICAgICAgIGlmICghZGV2aWNlSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmlkZW9Db25zdHJhaW50cyA9IHsgZmFjaW5nTW9kZTogJ2Vudmlyb25tZW50JyB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmlkZW9Db25zdHJhaW50cyA9IHsgZGV2aWNlSWQ6IHsgZXhhY3Q6IGRldmljZUlkIH0gfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgY29uc3RyYWludHMgPSB7IHZpZGVvOiB2aWRlb0NvbnN0cmFpbnRzIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMuZGVjb2RlT25jZUZyb21Db25zdHJhaW50cyhjb25zdHJhaW50cywgdmlkZW9Tb3VyY2UpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluIG9uZSBhdHRlbXB0LCB0cmllcyB0byBkZWNvZGUgdGhlIGJhcmNvZGUgZnJvbSBhIHN0cmVhbSBvYnRhaW5lZCBmcm9tIHRoZSBnaXZlbiBjb25zdHJhaW50cyB3aGlsZSBzaG93aW5nIHRoZSB2aWRlbyBpbiB0aGUgc3BlY2lmaWVkIHZpZGVvIGVsZW1lbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBjb25zdHJhaW50cyB0aGUgbWVkaWEgc3RyZWFtIGNvbnN0cmFpbnRzIHRvIGdldCBzIHZhbGlkIG1lZGlhIHN0cmVhbSB0byBkZWNvZGUgZnJvbVxuICAgICAgICAgKiBAcGFyYW0gdmlkZW8gdGhlIHZpZGVvIGVsZW1lbnQgaW4gcGFnZSB3aGVyZSB0byBzaG93IHRoZSB2aWRlbyB3aGlsZSBkZWNvZGluZy4gQ2FuIGJlIGVpdGhlciBhbiBlbGVtZW50IGlkIG9yIGRpcmVjdGx5IGFuIEhUTUxWaWRlb0VsZW1lbnQuIENhbiBiZSB1bmRlZmluZWQsIGluIHdoaWNoIGNhc2Ugbm8gdmlkZW8gd2lsbCBiZSBzaG93bi5cbiAgICAgICAgICogQHJldHVybnMgVGhlIGRlY29kaW5nIHJlc3VsdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlck9mIEJyb3dzZXJDb2RlUmVhZGVyXG4gICAgICAgICAqL1xuICAgICAgICBkZWNvZGVPbmNlRnJvbUNvbnN0cmFpbnRzKGNvbnN0cmFpbnRzLCB2aWRlb1NvdXJjZSkge1xuICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdHJlYW0gPSB5aWVsZCBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYShjb25zdHJhaW50cyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMuZGVjb2RlT25jZUZyb21TdHJlYW0oc3RyZWFtLCB2aWRlb1NvdXJjZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogSW4gb25lIGF0dGVtcHQsIHRyaWVzIHRvIGRlY29kZSB0aGUgYmFyY29kZSBmcm9tIGEgc3RyZWFtIG9idGFpbmVkIGZyb20gdGhlIGdpdmVuIGNvbnN0cmFpbnRzIHdoaWxlIHNob3dpbmcgdGhlIHZpZGVvIGluIHRoZSBzcGVjaWZpZWQgdmlkZW8gZWxlbWVudC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtNZWRpYVN0cmVhbX0gW2NvbnN0cmFpbnRzXSB0aGUgbWVkaWEgc3RyZWFtIGNvbnN0cmFpbnRzIHRvIGdldCBzIHZhbGlkIG1lZGlhIHN0cmVhbSB0byBkZWNvZGUgZnJvbVxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ3xIVE1MVmlkZW9FbGVtZW50fSBbdmlkZW9dIHRoZSB2aWRlbyBlbGVtZW50IGluIHBhZ2Ugd2hlcmUgdG8gc2hvdyB0aGUgdmlkZW8gd2hpbGUgZGVjb2RpbmcuIENhbiBiZSBlaXRoZXIgYW4gZWxlbWVudCBpZCBvciBkaXJlY3RseSBhbiBIVE1MVmlkZW9FbGVtZW50LiBDYW4gYmUgdW5kZWZpbmVkLCBpbiB3aGljaCBjYXNlIG5vIHZpZGVvIHdpbGwgYmUgc2hvd24uXG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFJlc3VsdD59IFRoZSBkZWNvZGluZyByZXN1bHQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXJPZiBCcm93c2VyQ29kZVJlYWRlclxuICAgICAgICAgKi9cbiAgICAgICAgZGVjb2RlT25jZUZyb21TdHJlYW0oc3RyZWFtLCB2aWRlb1NvdXJjZSkge1xuICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgICAgICAgICAgY29uc3QgdmlkZW8gPSB5aWVsZCB0aGlzLmF0dGFjaFN0cmVhbVRvVmlkZW8oc3RyZWFtLCB2aWRlb1NvdXJjZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0geWllbGQgdGhpcy5kZWNvZGVPbmNlKHZpZGVvKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnRpbnVvdXNseSBkZWNvZGVzIHRoZSBiYXJjb2RlIGZyb20gdGhlIGRldmljZSBzcGVjaWZpZWQgYnkgZGV2aWNlIHdoaWxlIHNob3dpbmcgdGhlIHZpZGVvIGluIHRoZSBzcGVjaWZpZWQgdmlkZW8gZWxlbWVudC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd8bnVsbH0gW2RldmljZUlkXSB0aGUgaWQgb2Ygb25lIG9mIHRoZSBkZXZpY2VzIG9idGFpbmVkIGFmdGVyIGNhbGxpbmcgZ2V0VmlkZW9JbnB1dERldmljZXMuIENhbiBiZSB1bmRlZmluZWQsIGluIHRoaXMgY2FzZSBpdCB3aWxsIGRlY29kZSBmcm9tIG9uZSBvZiB0aGUgYXZhaWxhYmxlIGRldmljZXMsIHByZWZmZXJpbmcgdGhlIG1haW4gY2FtZXJhIChlbnZpcm9ubWVudCBmYWNpbmcpIGlmIGF2YWlsYWJsZS5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd8SFRNTFZpZGVvRWxlbWVudHxudWxsfSBbdmlkZW9dIHRoZSB2aWRlbyBlbGVtZW50IGluIHBhZ2Ugd2hlcmUgdG8gc2hvdyB0aGUgdmlkZW8gd2hpbGUgZGVjb2RpbmcuIENhbiBiZSBlaXRoZXIgYW4gZWxlbWVudCBpZCBvciBkaXJlY3RseSBhbiBIVE1MVmlkZW9FbGVtZW50LiBDYW4gYmUgdW5kZWZpbmVkLCBpbiB3aGljaCBjYXNlIG5vIHZpZGVvIHdpbGwgYmUgc2hvd24uXG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyT2YgQnJvd3NlckNvZGVSZWFkZXJcbiAgICAgICAgICpcbiAgICAgICAgICogQGRlcHJlY2F0ZWQgVXNlIGBkZWNvZGVGcm9tVmlkZW9EZXZpY2VgIGluc3RlYWQuXG4gICAgICAgICAqL1xuICAgICAgICBkZWNvZGVGcm9tSW5wdXRWaWRlb0RldmljZUNvbnRpbnVvdXNseShkZXZpY2VJZCwgdmlkZW9Tb3VyY2UsIGNhbGxiYWNrRm4pIHtcbiAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMuZGVjb2RlRnJvbVZpZGVvRGV2aWNlKGRldmljZUlkLCB2aWRlb1NvdXJjZSwgY2FsbGJhY2tGbik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ29udGludW91c2x5IHRyaWVzIHRvIGRlY29kZSB0aGUgYmFyY29kZSBmcm9tIHRoZSBkZXZpY2Ugc3BlY2lmaWVkIGJ5IGRldmljZSB3aGlsZSBzaG93aW5nIHRoZSB2aWRlbyBpbiB0aGUgc3BlY2lmaWVkIHZpZGVvIGVsZW1lbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bGx9IFtkZXZpY2VJZF0gdGhlIGlkIG9mIG9uZSBvZiB0aGUgZGV2aWNlcyBvYnRhaW5lZCBhZnRlciBjYWxsaW5nIGdldFZpZGVvSW5wdXREZXZpY2VzLiBDYW4gYmUgdW5kZWZpbmVkLCBpbiB0aGlzIGNhc2UgaXQgd2lsbCBkZWNvZGUgZnJvbSBvbmUgb2YgdGhlIGF2YWlsYWJsZSBkZXZpY2VzLCBwcmVmZmVyaW5nIHRoZSBtYWluIGNhbWVyYSAoZW52aXJvbm1lbnQgZmFjaW5nKSBpZiBhdmFpbGFibGUuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfEhUTUxWaWRlb0VsZW1lbnR8bnVsbH0gW3ZpZGVvXSB0aGUgdmlkZW8gZWxlbWVudCBpbiBwYWdlIHdoZXJlIHRvIHNob3cgdGhlIHZpZGVvIHdoaWxlIGRlY29kaW5nLiBDYW4gYmUgZWl0aGVyIGFuIGVsZW1lbnQgaWQgb3IgZGlyZWN0bHkgYW4gSFRNTFZpZGVvRWxlbWVudC4gQ2FuIGJlIHVuZGVmaW5lZCwgaW4gd2hpY2ggY2FzZSBubyB2aWRlbyB3aWxsIGJlIHNob3duLlxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlck9mIEJyb3dzZXJDb2RlUmVhZGVyXG4gICAgICAgICAqL1xuICAgICAgICBkZWNvZGVGcm9tVmlkZW9EZXZpY2UoZGV2aWNlSWQsIHZpZGVvU291cmNlLCBjYWxsYmFja0ZuKSB7XG4gICAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIGxldCB2aWRlb0NvbnN0cmFpbnRzO1xuICAgICAgICAgICAgICAgIGlmICghZGV2aWNlSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmlkZW9Db25zdHJhaW50cyA9IHsgZmFjaW5nTW9kZTogJ2Vudmlyb25tZW50JyB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmlkZW9Db25zdHJhaW50cyA9IHsgZGV2aWNlSWQ6IHsgZXhhY3Q6IGRldmljZUlkIH0gfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgY29uc3RyYWludHMgPSB7IHZpZGVvOiB2aWRlb0NvbnN0cmFpbnRzIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMuZGVjb2RlRnJvbUNvbnN0cmFpbnRzKGNvbnN0cmFpbnRzLCB2aWRlb1NvdXJjZSwgY2FsbGJhY2tGbik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ29udGludW91c2x5IHRyaWVzIHRvIGRlY29kZSB0aGUgYmFyY29kZSBmcm9tIGEgc3RyZWFtIG9idGFpbmVkIGZyb20gdGhlIGdpdmVuIGNvbnN0cmFpbnRzIHdoaWxlIHNob3dpbmcgdGhlIHZpZGVvIGluIHRoZSBzcGVjaWZpZWQgdmlkZW8gZWxlbWVudC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtNZWRpYVN0cmVhbX0gW2NvbnN0cmFpbnRzXSB0aGUgbWVkaWEgc3RyZWFtIGNvbnN0cmFpbnRzIHRvIGdldCBzIHZhbGlkIG1lZGlhIHN0cmVhbSB0byBkZWNvZGUgZnJvbVxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ3xIVE1MVmlkZW9FbGVtZW50fSBbdmlkZW9dIHRoZSB2aWRlbyBlbGVtZW50IGluIHBhZ2Ugd2hlcmUgdG8gc2hvdyB0aGUgdmlkZW8gd2hpbGUgZGVjb2RpbmcuIENhbiBiZSBlaXRoZXIgYW4gZWxlbWVudCBpZCBvciBkaXJlY3RseSBhbiBIVE1MVmlkZW9FbGVtZW50LiBDYW4gYmUgdW5kZWZpbmVkLCBpbiB3aGljaCBjYXNlIG5vIHZpZGVvIHdpbGwgYmUgc2hvd24uXG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFJlc3VsdD59IFRoZSBkZWNvZGluZyByZXN1bHQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXJPZiBCcm93c2VyQ29kZVJlYWRlclxuICAgICAgICAgKi9cbiAgICAgICAgZGVjb2RlRnJvbUNvbnN0cmFpbnRzKGNvbnN0cmFpbnRzLCB2aWRlb1NvdXJjZSwgY2FsbGJhY2tGbikge1xuICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdHJlYW0gPSB5aWVsZCBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYShjb25zdHJhaW50cyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMuZGVjb2RlRnJvbVN0cmVhbShzdHJlYW0sIHZpZGVvU291cmNlLCBjYWxsYmFja0ZuKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbiBvbmUgYXR0ZW1wdCwgdHJpZXMgdG8gZGVjb2RlIHRoZSBiYXJjb2RlIGZyb20gYSBzdHJlYW0gb2J0YWluZWQgZnJvbSB0aGUgZ2l2ZW4gY29uc3RyYWludHMgd2hpbGUgc2hvd2luZyB0aGUgdmlkZW8gaW4gdGhlIHNwZWNpZmllZCB2aWRlbyBlbGVtZW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge01lZGlhU3RyZWFtfSBbY29uc3RyYWludHNdIHRoZSBtZWRpYSBzdHJlYW0gY29uc3RyYWludHMgdG8gZ2V0IHMgdmFsaWQgbWVkaWEgc3RyZWFtIHRvIGRlY29kZSBmcm9tXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfEhUTUxWaWRlb0VsZW1lbnR9IFt2aWRlb10gdGhlIHZpZGVvIGVsZW1lbnQgaW4gcGFnZSB3aGVyZSB0byBzaG93IHRoZSB2aWRlbyB3aGlsZSBkZWNvZGluZy4gQ2FuIGJlIGVpdGhlciBhbiBlbGVtZW50IGlkIG9yIGRpcmVjdGx5IGFuIEhUTUxWaWRlb0VsZW1lbnQuIENhbiBiZSB1bmRlZmluZWQsIGluIHdoaWNoIGNhc2Ugbm8gdmlkZW8gd2lsbCBiZSBzaG93bi5cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8UmVzdWx0Pn0gVGhlIGRlY29kaW5nIHJlc3VsdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlck9mIEJyb3dzZXJDb2RlUmVhZGVyXG4gICAgICAgICAqL1xuICAgICAgICBkZWNvZGVGcm9tU3RyZWFtKHN0cmVhbSwgdmlkZW9Tb3VyY2UsIGNhbGxiYWNrRm4pIHtcbiAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHZpZGVvID0geWllbGQgdGhpcy5hdHRhY2hTdHJlYW1Ub1ZpZGVvKHN0cmVhbSwgdmlkZW9Tb3VyY2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLmRlY29kZUNvbnRpbnVvdXNseSh2aWRlbywgY2FsbGJhY2tGbik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQnJlYWtzIHRoZSBkZWNvZGluZyBsb29wLlxuICAgICAgICAgKi9cbiAgICAgICAgc3RvcEFzeW5jRGVjb2RlKCkge1xuICAgICAgICAgICAgdGhpcy5fc3RvcEFzeW5jRGVjb2RlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQnJlYWtzIHRoZSBkZWNvZGluZyBsb29wLlxuICAgICAgICAgKi9cbiAgICAgICAgc3RvcENvbnRpbnVvdXNEZWNvZGUoKSB7XG4gICAgICAgICAgICB0aGlzLl9zdG9wQ29udGludW91c0RlY29kZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIG5ldyBzdHJlYW0gYW5kIHJlcXVlc3QgYSBuZXcgZGVjb2Rpbmctd2l0aC1kZWxheS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHN0cmVhbSBUaGUgc3RyZWFtIHRvIGJlIHNob3duIGluIHRoZSB2aWRlbyBlbGVtZW50LlxuICAgICAgICAgKiBAcGFyYW0gZGVjb2RlRm4gQSBjYWxsYmFjayBmb3IgdGhlIGRlY29kZSBtZXRob2QuXG4gICAgICAgICAqL1xuICAgICAgICBhdHRhY2hTdHJlYW1Ub1ZpZGVvKHN0cmVhbSwgdmlkZW9Tb3VyY2UpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmlkZW9FbGVtZW50ID0gdGhpcy5wcmVwYXJlVmlkZW9FbGVtZW50KHZpZGVvU291cmNlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZFZpZGVvU291cmNlKHZpZGVvRWxlbWVudCwgc3RyZWFtKTtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZGVvRWxlbWVudCA9IHZpZGVvRWxlbWVudDtcbiAgICAgICAgICAgICAgICB0aGlzLnN0cmVhbSA9IHN0cmVhbTtcbiAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLnBsYXlWaWRlb09uTG9hZEFzeW5jKHZpZGVvRWxlbWVudCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZpZGVvRWxlbWVudDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gdmlkZW9FbGVtZW50XG4gICAgICAgICAqL1xuICAgICAgICBwbGF5VmlkZW9PbkxvYWRBc3luYyh2aWRlb0VsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB0aGlzLnBsYXlWaWRlb09uTG9hZCh2aWRlb0VsZW1lbnQsICgpID0+IHJlc29sdmUoKSkpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCaW5kcyBsaXN0ZW5lcnMgYW5kIGNhbGxiYWNrcyB0byB0aGUgdmlkZW9FbGVtZW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gZWxlbWVudFxuICAgICAgICAgKiBAcGFyYW0gY2FsbGJhY2tGblxuICAgICAgICAgKi9cbiAgICAgICAgcGxheVZpZGVvT25Mb2FkKGVsZW1lbnQsIGNhbGxiYWNrRm4pIHtcbiAgICAgICAgICAgIHRoaXMudmlkZW9FbmRlZExpc3RlbmVyID0gKCkgPT4gdGhpcy5zdG9wU3RyZWFtcygpO1xuICAgICAgICAgICAgdGhpcy52aWRlb0NhblBsYXlMaXN0ZW5lciA9ICgpID0+IHRoaXMudHJ5UGxheVZpZGVvKGVsZW1lbnQpO1xuICAgICAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdlbmRlZCcsIHRoaXMudmlkZW9FbmRlZExpc3RlbmVyKTtcbiAgICAgICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2FucGxheScsIHRoaXMudmlkZW9DYW5QbGF5TGlzdGVuZXIpO1xuICAgICAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdwbGF5aW5nJywgY2FsbGJhY2tGbik7XG4gICAgICAgICAgICAvLyBpZiBjYW5wbGF5IHdhcyBhbHJlYWR5IGZpcmVkLCB3ZSB3b24ndCBrbm93IHdoZW4gdG8gcGxheSwgc28ganVzdCBnaXZlIGl0IGEgdHJ5XG4gICAgICAgICAgICB0aGlzLnRyeVBsYXlWaWRlbyhlbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ2hlY2tzIGlmIHRoZSBnaXZlbiB2aWRlbyBlbGVtZW50IGlzIGN1cnJlbnRseSBwbGF5aW5nLlxuICAgICAgICAgKi9cbiAgICAgICAgaXNWaWRlb1BsYXlpbmcodmlkZW8pIHtcbiAgICAgICAgICAgIHJldHVybiB2aWRlby5jdXJyZW50VGltZSA+IDAgJiYgIXZpZGVvLnBhdXNlZCAmJiAhdmlkZW8uZW5kZWQgJiYgdmlkZW8ucmVhZHlTdGF0ZSA+IDI7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEp1c3QgdHJpZXMgdG8gcGxheSB0aGUgdmlkZW8gYW5kIGxvZ3MgYW55IGVycm9ycy5cbiAgICAgICAgICogVGhlIHBsYXkgY2FsbCBpcyBvbmx5IG1hZGUgaXMgdGhlIHZpZGVvIGlzIG5vdCBhbHJlYWR5IHBsYXlpbmcuXG4gICAgICAgICAqL1xuICAgICAgICB0cnlQbGF5VmlkZW8odmlkZW9FbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzVmlkZW9QbGF5aW5nKHZpZGVvRWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdUcnlpbmcgdG8gcGxheSB2aWRlbyB0aGF0IGlzIGFscmVhZHkgcGxheWluZy4nKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCB2aWRlb0VsZW1lbnQucGxheSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdJdCB3YXMgbm90IHBvc3NpYmxlIHRvIHBsYXkgdGhlIHZpZGVvLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZWFyY2hlcyBhbmQgdmFsaWRhdGVzIGEgbWVkaWEgZWxlbWVudC5cbiAgICAgICAgICovXG4gICAgICAgIGdldE1lZGlhRWxlbWVudChtZWRpYUVsZW1lbnRJZCwgdHlwZSkge1xuICAgICAgICAgICAgY29uc3QgbWVkaWFFbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQobWVkaWFFbGVtZW50SWQpO1xuICAgICAgICAgICAgaWYgKCFtZWRpYUVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRFeGNlcHRpb24oYGVsZW1lbnQgd2l0aCBpZCAnJHttZWRpYUVsZW1lbnRJZH0nIG5vdCBmb3VuZGApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lZGlhRWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICE9PSB0eXBlLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRFeGNlcHRpb24oYGVsZW1lbnQgd2l0aCBpZCAnJHttZWRpYUVsZW1lbnRJZH0nIG11c3QgYmUgYW4gJHt0eXBlfSBlbGVtZW50YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWVkaWFFbGVtZW50O1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWNvZGVzIHRoZSBiYXJjb2RlIGZyb20gYW4gaW1hZ2UuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7KHN0cmluZ3xIVE1MSW1hZ2VFbGVtZW50KX0gW3NvdXJjZV0gVGhlIGltYWdlIGVsZW1lbnQgdGhhdCBjYW4gYmUgZWl0aGVyIGFuIGVsZW1lbnQgaWQgb3IgdGhlIGVsZW1lbnQgaXRzZWxmLiBDYW4gYmUgdW5kZWZpbmVkIGluIHdoaWNoIGNhc2UgdGhlIGRlY29kaW5nIHdpbGwgYmUgZG9uZSBmcm9tIHRoZSBpbWFnZVVybCBwYXJhbWV0ZXIuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbdXJsXVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxSZXN1bHQ+fSBUaGUgZGVjb2RpbmcgcmVzdWx0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyT2YgQnJvd3NlckNvZGVSZWFkZXJcbiAgICAgICAgICovXG4gICAgICAgIGRlY29kZUZyb21JbWFnZShzb3VyY2UsIHVybCkge1xuICAgICAgICAgICAgaWYgKCFzb3VyY2UgJiYgIXVybCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudEV4Y2VwdGlvbignZWl0aGVyIGltYWdlRWxlbWVudCB3aXRoIGEgc3JjIHNldCBvciBhbiB1cmwgbXVzdCBiZSBwcm92aWRlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHVybCAmJiAhc291cmNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlRnJvbUltYWdlVXJsKHVybCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGVGcm9tSW1hZ2VFbGVtZW50KHNvdXJjZSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlY29kZXMgdGhlIGJhcmNvZGUgZnJvbSBhIHZpZGVvLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0geyhzdHJpbmd8SFRNTEltYWdlRWxlbWVudCl9IFtzb3VyY2VdIFRoZSBpbWFnZSBlbGVtZW50IHRoYXQgY2FuIGJlIGVpdGhlciBhbiBlbGVtZW50IGlkIG9yIHRoZSBlbGVtZW50IGl0c2VsZi4gQ2FuIGJlIHVuZGVmaW5lZCBpbiB3aGljaCBjYXNlIHRoZSBkZWNvZGluZyB3aWxsIGJlIGRvbmUgZnJvbSB0aGUgaW1hZ2VVcmwgcGFyYW1ldGVyLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3VybF1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8UmVzdWx0Pn0gVGhlIGRlY29kaW5nIHJlc3VsdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlck9mIEJyb3dzZXJDb2RlUmVhZGVyXG4gICAgICAgICAqL1xuICAgICAgICBkZWNvZGVGcm9tVmlkZW8oc291cmNlLCB1cmwpIHtcbiAgICAgICAgICAgIGlmICghc291cmNlICYmICF1cmwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRFeGNlcHRpb24oJ0VpdGhlciBhbiBlbGVtZW50IHdpdGggYSBzcmMgc2V0IG9yIGFuIFVSTCBtdXN0IGJlIHByb3ZpZGVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodXJsICYmICFzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGVGcm9tVmlkZW9VcmwodXJsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlY29kZUZyb21WaWRlb0VsZW1lbnQoc291cmNlKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogRGVjb2RlcyBjb250aW51b3VzbHkgdGhlIGJhcmNvZGUgZnJvbSBhIHZpZGVvLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0geyhzdHJpbmd8SFRNTEltYWdlRWxlbWVudCl9IFtzb3VyY2VdIFRoZSBpbWFnZSBlbGVtZW50IHRoYXQgY2FuIGJlIGVpdGhlciBhbiBlbGVtZW50IGlkIG9yIHRoZSBlbGVtZW50IGl0c2VsZi4gQ2FuIGJlIHVuZGVmaW5lZCBpbiB3aGljaCBjYXNlIHRoZSBkZWNvZGluZyB3aWxsIGJlIGRvbmUgZnJvbSB0aGUgaW1hZ2VVcmwgcGFyYW1ldGVyLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3VybF1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8UmVzdWx0Pn0gVGhlIGRlY29kaW5nIHJlc3VsdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlck9mIEJyb3dzZXJDb2RlUmVhZGVyXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgICAgICovXG4gICAgICAgIGRlY29kZUZyb21WaWRlb0NvbnRpbnVvdXNseShzb3VyY2UsIHVybCwgY2FsbGJhY2tGbikge1xuICAgICAgICAgICAgaWYgKHVuZGVmaW5lZCA9PT0gc291cmNlICYmIHVuZGVmaW5lZCA9PT0gdXJsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50RXhjZXB0aW9uKCdFaXRoZXIgYW4gZWxlbWVudCB3aXRoIGEgc3JjIHNldCBvciBhbiBVUkwgbXVzdCBiZSBwcm92aWRlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHVybCAmJiAhc291cmNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlRnJvbVZpZGVvVXJsQ29udGludW91c2x5KHVybCwgY2FsbGJhY2tGbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGVGcm9tVmlkZW9FbGVtZW50Q29udGludW91c2x5KHNvdXJjZSwgY2FsbGJhY2tGbik7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlY29kZXMgc29tZXRoaW5nIGZyb20gYW4gaW1hZ2UgSFRNTCBlbGVtZW50LlxuICAgICAgICAgKi9cbiAgICAgICAgZGVjb2RlRnJvbUltYWdlRWxlbWVudChzb3VyY2UpIHtcbiAgICAgICAgICAgIGlmICghc291cmNlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50RXhjZXB0aW9uKCdBbiBpbWFnZSBlbGVtZW50IG11c3QgYmUgcHJvdmlkZWQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5wcmVwYXJlSW1hZ2VFbGVtZW50KHNvdXJjZSk7XG4gICAgICAgICAgICB0aGlzLmltYWdlRWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgICAgICBsZXQgdGFzaztcbiAgICAgICAgICAgIGlmICh0aGlzLmlzSW1hZ2VMb2FkZWQoZWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICB0YXNrID0gdGhpcy5kZWNvZGVPbmNlKGVsZW1lbnQsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRhc2sgPSB0aGlzLl9kZWNvZGVPbkxvYWRJbWFnZShlbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0YXNrO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWNvZGVzIHNvbWV0aGluZyBmcm9tIGFuIGltYWdlIEhUTUwgZWxlbWVudC5cbiAgICAgICAgICovXG4gICAgICAgIGRlY29kZUZyb21WaWRlb0VsZW1lbnQoc291cmNlKSB7XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5fZGVjb2RlRnJvbVZpZGVvRWxlbWVudFNldHVwKHNvdXJjZSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGVjb2RlT25Mb2FkVmlkZW8oZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlY29kZXMgc29tZXRoaW5nIGZyb20gYW4gaW1hZ2UgSFRNTCBlbGVtZW50LlxuICAgICAgICAgKi9cbiAgICAgICAgZGVjb2RlRnJvbVZpZGVvRWxlbWVudENvbnRpbnVvdXNseShzb3VyY2UsIGNhbGxiYWNrRm4pIHtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLl9kZWNvZGVGcm9tVmlkZW9FbGVtZW50U2V0dXAoc291cmNlKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZWNvZGVPbkxvYWRWaWRlb0NvbnRpbnVvdXNseShlbGVtZW50LCBjYWxsYmFja0ZuKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyB1cCB0aGUgdmlkZW8gc291cmNlIHNvIGl0IGNhbiBiZSBkZWNvZGVkIHdoZW4gbG9hZGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gc291cmNlIFRoZSB2aWRlbyBzb3VyY2UgZWxlbWVudC5cbiAgICAgICAgICovXG4gICAgICAgIF9kZWNvZGVGcm9tVmlkZW9FbGVtZW50U2V0dXAoc291cmNlKSB7XG4gICAgICAgICAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudEV4Y2VwdGlvbignQSB2aWRlbyBlbGVtZW50IG11c3QgYmUgcHJvdmlkZWQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5wcmVwYXJlVmlkZW9FbGVtZW50KHNvdXJjZSk7XG4gICAgICAgICAgICAvLyBkZWZpbmVzIHRoZSB2aWRlbyBlbGVtZW50IGJlZm9yZSBzdGFydHMgZGVjb2RpbmdcbiAgICAgICAgICAgIHRoaXMudmlkZW9FbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWNvZGVzIGFuIGltYWdlIGZyb20gYSBVUkwuXG4gICAgICAgICAqL1xuICAgICAgICBkZWNvZGVGcm9tSW1hZ2VVcmwodXJsKSB7XG4gICAgICAgICAgICBpZiAoIXVybCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudEV4Y2VwdGlvbignQW4gVVJMIG11c3QgYmUgcHJvdmlkZWQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5wcmVwYXJlSW1hZ2VFbGVtZW50KCk7XG4gICAgICAgICAgICB0aGlzLmltYWdlRWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgICAgICBjb25zdCBkZWNvZGVUYXNrID0gdGhpcy5fZGVjb2RlT25Mb2FkSW1hZ2UoZWxlbWVudCk7XG4gICAgICAgICAgICBlbGVtZW50LnNyYyA9IHVybDtcbiAgICAgICAgICAgIHJldHVybiBkZWNvZGVUYXNrO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWNvZGVzIGFuIGltYWdlIGZyb20gYSBVUkwuXG4gICAgICAgICAqL1xuICAgICAgICBkZWNvZGVGcm9tVmlkZW9VcmwodXJsKSB7XG4gICAgICAgICAgICBpZiAoIXVybCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudEV4Y2VwdGlvbignQW4gVVJMIG11c3QgYmUgcHJvdmlkZWQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgICAgICAvLyBjcmVhdGVzIGEgbmV3IGVsZW1lbnRcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLnByZXBhcmVWaWRlb0VsZW1lbnQoKTtcbiAgICAgICAgICAgIGNvbnN0IGRlY29kZVRhc2sgPSB0aGlzLmRlY29kZUZyb21WaWRlb0VsZW1lbnQoZWxlbWVudCk7XG4gICAgICAgICAgICBlbGVtZW50LnNyYyA9IHVybDtcbiAgICAgICAgICAgIHJldHVybiBkZWNvZGVUYXNrO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWNvZGVzIGFuIGltYWdlIGZyb20gYSBVUkwuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgICAgICovXG4gICAgICAgIGRlY29kZUZyb21WaWRlb1VybENvbnRpbnVvdXNseSh1cmwsIGNhbGxiYWNrRm4pIHtcbiAgICAgICAgICAgIGlmICghdXJsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50RXhjZXB0aW9uKCdBbiBVUkwgbXVzdCBiZSBwcm92aWRlZC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgICAgIC8vIGNyZWF0ZXMgYSBuZXcgZWxlbWVudFxuICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMucHJlcGFyZVZpZGVvRWxlbWVudCgpO1xuICAgICAgICAgICAgY29uc3QgZGVjb2RlVGFzayA9IHRoaXMuZGVjb2RlRnJvbVZpZGVvRWxlbWVudENvbnRpbnVvdXNseShlbGVtZW50LCBjYWxsYmFja0ZuKTtcbiAgICAgICAgICAgIGVsZW1lbnQuc3JjID0gdXJsO1xuICAgICAgICAgICAgcmV0dXJuIGRlY29kZVRhc2s7XG4gICAgICAgIH1cbiAgICAgICAgX2RlY29kZU9uTG9hZEltYWdlKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbWFnZUxvYWRlZExpc3RlbmVyID0gKCkgPT4gdGhpcy5kZWNvZGVPbmNlKGVsZW1lbnQsIGZhbHNlLCB0cnVlKS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgdGhpcy5pbWFnZUxvYWRlZExpc3RlbmVyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIF9kZWNvZGVPbkxvYWRWaWRlbyh2aWRlb0VsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgLy8gcGxheXMgdGhlIHZpZGVvXG4gICAgICAgICAgICAgICAgeWllbGQgdGhpcy5wbGF5VmlkZW9PbkxvYWRBc3luYyh2aWRlb0VsZW1lbnQpO1xuICAgICAgICAgICAgICAgIC8vIHN0YXJ0cyBkZWNvZGluZyBhZnRlciBwbGF5ZWQgdGhlIHZpZGVvXG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMuZGVjb2RlT25jZSh2aWRlb0VsZW1lbnQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgX2RlY29kZU9uTG9hZFZpZGVvQ29udGludW91c2x5KHZpZGVvRWxlbWVudCwgY2FsbGJhY2tGbikge1xuICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICAvLyBwbGF5cyB0aGUgdmlkZW9cbiAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLnBsYXlWaWRlb09uTG9hZEFzeW5jKHZpZGVvRWxlbWVudCk7XG4gICAgICAgICAgICAgICAgLy8gc3RhcnRzIGRlY29kaW5nIGFmdGVyIHBsYXllZCB0aGUgdmlkZW9cbiAgICAgICAgICAgICAgICB0aGlzLmRlY29kZUNvbnRpbnVvdXNseSh2aWRlb0VsZW1lbnQsIGNhbGxiYWNrRm4pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaXNJbWFnZUxvYWRlZChpbWcpIHtcbiAgICAgICAgICAgIC8vIER1cmluZyB0aGUgb25sb2FkIGV2ZW50LCBJRSBjb3JyZWN0bHkgaWRlbnRpZmllcyBhbnkgaW1hZ2VzIHRoYXRcbiAgICAgICAgICAgIC8vIHdlcmVuXHUyMDE5dCBkb3dubG9hZGVkIGFzIG5vdCBjb21wbGV0ZS4gT3RoZXJzIHNob3VsZCB0b28uIEdlY2tvLWJhc2VkXG4gICAgICAgICAgICAvLyBicm93c2VycyBhY3QgbGlrZSBOUzQgaW4gdGhhdCB0aGV5IHJlcG9ydCB0aGlzIGluY29ycmVjdGx5LlxuICAgICAgICAgICAgaWYgKCFpbWcuY29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBIb3dldmVyLCB0aGV5IGRvIGhhdmUgdHdvIHZlcnkgdXNlZnVsIHByb3BlcnRpZXM6IG5hdHVyYWxXaWR0aCBhbmRcbiAgICAgICAgICAgIC8vIG5hdHVyYWxIZWlnaHQuIFRoZXNlIGdpdmUgdGhlIHRydWUgc2l6ZSBvZiB0aGUgaW1hZ2UuIElmIGl0IGZhaWxlZFxuICAgICAgICAgICAgLy8gdG8gbG9hZCwgZWl0aGVyIG9mIHRoZXNlIHNob3VsZCBiZSB6ZXJvLlxuICAgICAgICAgICAgaWYgKGltZy5uYXR1cmFsV2lkdGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBObyBvdGhlciB3YXkgb2YgY2hlY2tpbmc6IGFzc3VtZSBpdFx1MjAxOXMgb2suXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBwcmVwYXJlSW1hZ2VFbGVtZW50KGltYWdlU291cmNlKSB7XG4gICAgICAgICAgICBsZXQgaW1hZ2VFbGVtZW50O1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpbWFnZVNvdXJjZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBpbWFnZUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcbiAgICAgICAgICAgICAgICBpbWFnZUVsZW1lbnQud2lkdGggPSAyMDA7XG4gICAgICAgICAgICAgICAgaW1hZ2VFbGVtZW50LmhlaWdodCA9IDIwMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW1hZ2VTb3VyY2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgaW1hZ2VFbGVtZW50ID0gdGhpcy5nZXRNZWRpYUVsZW1lbnQoaW1hZ2VTb3VyY2UsICdpbWcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpbWFnZVNvdXJjZSBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBpbWFnZUVsZW1lbnQgPSBpbWFnZVNvdXJjZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpbWFnZUVsZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgYSBIVE1MVmlkZW9FbGVtZW50IGZvciBzY2FubmluZyBvciBjcmVhdGVzIGEgbmV3IG9uZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHZpZGVvU291cmNlIFRoZSBIVE1MVmlkZW9FbGVtZW50IHRvIGJlIHNldC5cbiAgICAgICAgICovXG4gICAgICAgIHByZXBhcmVWaWRlb0VsZW1lbnQodmlkZW9Tb3VyY2UpIHtcbiAgICAgICAgICAgIGxldCB2aWRlb0VsZW1lbnQ7XG4gICAgICAgICAgICBpZiAoIXZpZGVvU291cmNlICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB2aWRlb0VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd2aWRlbycpO1xuICAgICAgICAgICAgICAgIHZpZGVvRWxlbWVudC53aWR0aCA9IDIwMDtcbiAgICAgICAgICAgICAgICB2aWRlb0VsZW1lbnQuaGVpZ2h0ID0gMjAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2aWRlb1NvdXJjZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB2aWRlb0VsZW1lbnQgPSB0aGlzLmdldE1lZGlhRWxlbWVudCh2aWRlb1NvdXJjZSwgJ3ZpZGVvJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmlkZW9Tb3VyY2UgaW5zdGFuY2VvZiBIVE1MVmlkZW9FbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgdmlkZW9FbGVtZW50ID0gdmlkZW9Tb3VyY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBOZWVkZWQgZm9yIGlPUyAxMVxuICAgICAgICAgICAgdmlkZW9FbGVtZW50LnNldEF0dHJpYnV0ZSgnYXV0b3BsYXknLCAndHJ1ZScpO1xuICAgICAgICAgICAgdmlkZW9FbGVtZW50LnNldEF0dHJpYnV0ZSgnbXV0ZWQnLCAndHJ1ZScpO1xuICAgICAgICAgICAgdmlkZW9FbGVtZW50LnNldEF0dHJpYnV0ZSgncGxheXNpbmxpbmUnLCAndHJ1ZScpO1xuICAgICAgICAgICAgcmV0dXJuIHZpZGVvRWxlbWVudDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogVHJpZXMgdG8gZGVjb2RlIGZyb20gdGhlIHZpZGVvIGlucHV0IHVudGlsIGl0IGZpbmRzIHNvbWUgdmFsdWUuXG4gICAgICAgICAqL1xuICAgICAgICBkZWNvZGVPbmNlKGVsZW1lbnQsIHJldHJ5SWZOb3RGb3VuZCA9IHRydWUsIHJldHJ5SWZDaGVja3N1bU9yRm9ybWF0RXJyb3IgPSB0cnVlKSB7XG4gICAgICAgICAgICB0aGlzLl9zdG9wQXN5bmNEZWNvZGUgPSBmYWxzZTtcbiAgICAgICAgICAgIGNvbnN0IGxvb3AgPSAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3N0b3BBc3luY0RlY29kZSkge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IE5vdEZvdW5kRXhjZXB0aW9uKCdWaWRlbyBzdHJlYW0gaGFzIGVuZGVkIGJlZm9yZSBhbnkgY29kZSBjb3VsZCBiZSBkZXRlY3RlZC4nKSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0b3BBc3luY0RlY29kZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLmRlY29kZShlbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpZk5vdEZvdW5kID0gcmV0cnlJZk5vdEZvdW5kICYmIGUgaW5zdGFuY2VvZiBOb3RGb3VuZEV4Y2VwdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNDaGVja3N1bU9yRm9ybWF0RXJyb3IgPSBlIGluc3RhbmNlb2YgQ2hlY2tzdW1FeGNlcHRpb24gfHwgZSBpbnN0YW5jZW9mIEZvcm1hdEV4Y2VwdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaWZDaGVja3N1bU9yRm9ybWF0ID0gaXNDaGVja3N1bU9yRm9ybWF0RXJyb3IgJiYgcmV0cnlJZkNoZWNrc3VtT3JGb3JtYXRFcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlmTm90Rm91bmQgfHwgaWZDaGVja3N1bU9yRm9ybWF0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0cnlpbmcgYWdhaW5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGxvb3AsIHRoaXMuX3RpbWVCZXR3ZWVuRGVjb2RpbmdBdHRlbXB0cywgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiBsb29wKHJlc29sdmUsIHJlamVjdCkpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb250aW51b3VzbHkgZGVjb2RlcyBmcm9tIHZpZGVvIGlucHV0LlxuICAgICAgICAgKi9cbiAgICAgICAgZGVjb2RlQ29udGludW91c2x5KGVsZW1lbnQsIGNhbGxiYWNrRm4pIHtcbiAgICAgICAgICAgIHRoaXMuX3N0b3BDb250aW51b3VzRGVjb2RlID0gZmFsc2U7XG4gICAgICAgICAgICBjb25zdCBsb29wID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9zdG9wQ29udGludW91c0RlY29kZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdG9wQ29udGludW91c0RlY29kZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLmRlY29kZShlbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tGbihyZXN1bHQsIG51bGwpO1xuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGxvb3AsIHRoaXMudGltZUJldHdlZW5TY2Fuc01pbGxpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrRm4obnVsbCwgZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzQ2hlY2tzdW1PckZvcm1hdEVycm9yID0gZSBpbnN0YW5jZW9mIENoZWNrc3VtRXhjZXB0aW9uIHx8IGUgaW5zdGFuY2VvZiBGb3JtYXRFeGNlcHRpb247XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzTm90Rm91bmQgPSBlIGluc3RhbmNlb2YgTm90Rm91bmRFeGNlcHRpb247XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0NoZWNrc3VtT3JGb3JtYXRFcnJvciB8fCBpc05vdEZvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0cnlpbmcgYWdhaW5cbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQobG9vcCwgdGhpcy5fdGltZUJldHdlZW5EZWNvZGluZ0F0dGVtcHRzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBsb29wKCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldHMgdGhlIEJpbmFyeUJpdG1hcCBmb3IgeWEhIChhbmQgZGVjb2RlcyBpdClcbiAgICAgICAgICovXG4gICAgICAgIGRlY29kZShlbGVtZW50KSB7XG4gICAgICAgICAgICAvLyBnZXQgYmluYXJ5IGJpdG1hcCBmb3IgZGVjb2RlIGZ1bmN0aW9uXG4gICAgICAgICAgICBjb25zdCBiaW5hcnlCaXRtYXAgPSB0aGlzLmNyZWF0ZUJpbmFyeUJpdG1hcChlbGVtZW50KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlY29kZUJpdG1hcChiaW5hcnlCaXRtYXApO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRydWUgaWYgbWVkaWEgZWxlbWVudCBpcyBpbmRlZWQgYSB7QGxpbmsgSHRtbFZpZGVvRWxlbWVudH0uXG4gICAgICAgICAqL1xuICAgICAgICBfaXNIVE1MVmlkZW9FbGVtZW50KG1lZGlhRWxlbWVudCkge1xuICAgICAgICAgICAgY29uc3QgcG90ZW50aWFsVmlkZW8gPSBtZWRpYUVsZW1lbnQ7XG4gICAgICAgICAgICByZXR1cm4gcG90ZW50aWFsVmlkZW8udmlkZW9XaWR0aCAhPT0gMDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogT3ZlcndyaXRpbmcgdGhpcyBhbGxvd3MgeW91IHRvIG1hbmlwdWxhdGUgdGhlIG5leHQgZnJhbWUgaW4gYW55d2F5XG4gICAgICAgICAqIHlvdSB3YW50IGJlZm9yZSBkZWNvZGUuXG4gICAgICAgICAqL1xuICAgICAgICBkcmF3RnJhbWVPbkNhbnZhcyhcbiAgICAgICAgICAgIHNyY0VsZW1lbnQsIGRpbWVuc2lvbnMsIGNhbnZhc0VsZW1lbnRDb250ZXh0KSB7XG4gICAgICAgICAgICBpZiAoIWRpbWVuc2lvbnMpIHtcbiAgICAgICAgICAgICAgICBkaW1lbnNpb25zID0ge1xuICAgICAgICAgICAgICAgICAgICBzeDogMCxcbiAgICAgICAgICAgICAgICAgICAgc3k6IDAsXG4gICAgICAgICAgICAgICAgICAgIHNXaWR0aDogc3JjRWxlbWVudC52aWRlb1dpZHRoLFxuICAgICAgICAgICAgICAgICAgICBzSGVpZ2h0OiBzcmNFbGVtZW50LnZpZGVvSGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICBkeDogMCxcbiAgICAgICAgICAgICAgICAgICAgZHk6IDAsXG4gICAgICAgICAgICAgICAgICAgIGRXaWR0aDogc3JjRWxlbWVudC52aWRlb1dpZHRoLFxuICAgICAgICAgICAgICAgICAgICBkSGVpZ2h0OiBzcmNFbGVtZW50LnZpZGVvSGVpZ2h0fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghY2FudmFzRWxlbWVudENvbnRleHQpIHtcbiAgICAgICAgICAgICAgICBjYW52YXNFbGVtZW50Q29udGV4dCA9IHRoaXMuY2FwdHVyZUNhbnZhc0NvbnRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYW52YXNFbGVtZW50Q29udGV4dC5kcmF3SW1hZ2UoXG4gICAgICAgICAgICAgICAgc3JjRWxlbWVudCxcbiAgICAgICAgICAgICAgICBkaW1lbnNpb25zLnN4LFxuICAgICAgICAgICAgICAgIGRpbWVuc2lvbnMuc3ksXG4gICAgICAgICAgICAgICAgZGltZW5zaW9ucy5zV2lkdGgsXG4gICAgICAgICAgICAgICAgZGltZW5zaW9ucy5zSGVpZ2h0LFxuICAgICAgICAgICAgICAgIGRpbWVuc2lvbnMuZHgsXG4gICAgICAgICAgICAgICAgZGltZW5zaW9ucy5keSxcbiAgICAgICAgICAgICAgICBkaW1lbnNpb25zLmRXaWR0aCxcbiAgICAgICAgICAgICAgICBkaW1lbnNpb25zLmRIZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPdmV3cml0aW5nIHRoaXMgYWxsb3dzIHlvdSB0byBtYW5pcHVsYXRlIHRoZSBzbmFwc2hvdCBpbWFnZSBpbiBhbnl3YXlcbiAgICAgICAgICogIHlvdSB3YW50IGJlZm9yZSBkZWNvZGUuXG4gICAgICAgICAqL1xuICAgICAgICBkcmF3SW1hZ2VPbkNhbnZhcyhcbiAgICAgICAgICAgIHNyY0VsZW1lbnQsXG4gICAgICAgICAgICBkaW1lbnNpb25zLFxuICAgICAgICAgICAgY2FudmFzRWxlbWVudENvbnRleHQgPSB0aGlzLmNhcHR1cmVDYW52YXNDb250ZXh0KSB7XG4gICAgICAgICAgICBpZiAoIWRpbWVuc2lvbnMpIHtcbiAgICAgICAgICAgICAgICBkaW1lbnNpb25zID0ge1xuICAgICAgICAgICAgICAgICAgICBzeDogMCxcbiAgICAgICAgICAgICAgICAgICAgc3k6IDAsXG4gICAgICAgICAgICAgICAgICAgIHNXaWR0aDogc3JjRWxlbWVudC5uYXR1cmFsV2lkdGgsXG4gICAgICAgICAgICAgICAgICAgIHNIZWlnaHQ6IHNyY0VsZW1lbnQubmF0dXJhbEhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgZHg6IDAsXG4gICAgICAgICAgICAgICAgICAgIGR5OiAwLFxuICAgICAgICAgICAgICAgICAgICBkV2lkdGg6IHNyY0VsZW1lbnQubmF0dXJhbFdpZHRoLFxuICAgICAgICAgICAgICAgICAgICBkSGVpZ2h0OiBzcmNFbGVtZW50Lm5hdHVyYWxIZWlnaHRcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFjYW52YXNFbGVtZW50Q29udGV4dCkge1xuICAgICAgICAgICAgICAgIGNhbnZhc0VsZW1lbnRDb250ZXh0ID0gdGhpcy5jYXB0dXJlQ2FudmFzQ29udGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhbnZhc0VsZW1lbnRDb250ZXh0LmRyYXdJbWFnZShcbiAgICAgICAgICAgICAgICBzcmNFbGVtZW50LFxuICAgICAgICAgICAgICAgIGRpbWVuc2lvbnMuc3gsXG4gICAgICAgICAgICAgICAgZGltZW5zaW9ucy5zeSxcbiAgICAgICAgICAgICAgICBkaW1lbnNpb25zLnNXaWR0aCxcbiAgICAgICAgICAgICAgICBkaW1lbnNpb25zLnNIZWlnaHQsXG4gICAgICAgICAgICAgICAgZGltZW5zaW9ucy5keCxcbiAgICAgICAgICAgICAgICBkaW1lbnNpb25zLmR5LFxuICAgICAgICAgICAgICAgIGRpbWVuc2lvbnMuZFdpZHRoLFxuICAgICAgICAgICAgICAgIGRpbWVuc2lvbnMuZEhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBiaW5hcnlCaXRtYXAgYmFzZWQgaW4gc29tZSBpbWFnZSBzb3VyY2UuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBtZWRpYUVsZW1lbnQgSFRNTCBlbGVtZW50IGNvbnRhaW5pbmcgZHJhd2FibGUgaW1hZ2Ugc291cmNlLlxuICAgICAgICAgKi9cbiAgICAgICAgY3JlYXRlQmluYXJ5Qml0bWFwKG1lZGlhRWxlbWVudCkge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5nZXRDYXB0dXJlQ2FudmFzQ29udGV4dChtZWRpYUVsZW1lbnQpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2lzSFRNTFZpZGVvRWxlbWVudChtZWRpYUVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kcmF3RnJhbWVPbkNhbnZhcyhtZWRpYUVsZW1lbnQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRyYXdJbWFnZU9uQ2FudmFzKG1lZGlhRWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjYW52YXMgPSB0aGlzLmdldENhcHR1cmVDYW52YXMobWVkaWFFbGVtZW50KTtcbiAgICAgICAgICAgIGNvbnN0IGx1bWluYW5jZVNvdXJjZSA9IG5ldyBIVE1MQ2FudmFzRWxlbWVudEx1bWluYW5jZVNvdXJjZShjYW52YXMpO1xuICAgICAgICAgICAgY29uc3QgaHlicmlkQmluYXJpemVyID0gbmV3IEh5YnJpZEJpbmFyaXplcihsdW1pbmFuY2VTb3VyY2UpO1xuXG4gICAgICAgICAgICByZXR1cm4gbmV3IEJpbmFyeUJpdG1hcChoeWJyaWRCaW5hcml6ZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgZ2V0Q2FwdHVyZUNhbnZhc0NvbnRleHQobWVkaWFFbGVtZW50KSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuY2FwdHVyZUNhbnZhc0NvbnRleHQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlbGVtID0gdGhpcy5nZXRDYXB0dXJlQ2FudmFzKG1lZGlhRWxlbWVudCk7XG4gICAgICAgICAgICAgICAgY29uc3QgY3R4ID0gZWxlbS5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2FwdHVyZUNhbnZhc0NvbnRleHQgPSBjdHg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jYXB0dXJlQ2FudmFzQ29udGV4dDtcbiAgICAgICAgfVxuICAgICAgICBnZXRDYXB0dXJlQ2FudmFzKG1lZGlhRWxlbWVudCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmNhcHR1cmVDYW52YXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlbGVtID0gdGhpcy5jcmVhdGVDYXB0dXJlQ2FudmFzKG1lZGlhRWxlbWVudCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jYXB0dXJlQ2FudmFzID0gZWxlbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNhcHR1cmVDYW52YXM7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGwgdGhlIGVuY2Fwc3VsYXRlZCByZWFkZXJzIGRlY29kZVxuICAgICAgICAgKi9cbiAgICAgICAgZGVjb2RlQml0bWFwKGJpbmFyeUJpdG1hcCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVhZGVyLmRlY29kZShiaW5hcnlCaXRtYXAsIHRoaXMuX2hpbnRzKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogXHVEODNEXHVERDhDIFByZXBhcmVzIHRoZSBjYW52YXMgZm9yIGNhcHR1cmUgYW5kIHNjYW4gZnJhbWVzLlxuICAgICAgICAgKi9cbiAgICAgICAgY3JlYXRlQ2FwdHVyZUNhbnZhcyhtZWRpYUVsZW1lbnQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGVzdHJveUNhcHR1cmVDYW52YXMoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNhbnZhc0VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgICAgIGxldCB3aWR0aDtcbiAgICAgICAgICAgIGxldCBoZWlnaHQ7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1lZGlhRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBpZiAobWVkaWFFbGVtZW50IGluc3RhbmNlb2YgSFRNTFZpZGVvRWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IG1lZGlhRWxlbWVudC52aWRlb1dpZHRoO1xuICAgICAgICAgICAgICAgICAgICBoZWlnaHQgPSBtZWRpYUVsZW1lbnQudmlkZW9IZWlnaHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1lZGlhRWxlbWVudCBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgd2lkdGggPSBtZWRpYUVsZW1lbnQubmF0dXJhbFdpZHRoIHx8IG1lZGlhRWxlbWVudC53aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0ID0gbWVkaWFFbGVtZW50Lm5hdHVyYWxIZWlnaHQgfHwgbWVkaWFFbGVtZW50LmhlaWdodDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYW52YXNFbGVtZW50LnN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xuICAgICAgICAgICAgY2FudmFzRWxlbWVudC5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xuICAgICAgICAgICAgY2FudmFzRWxlbWVudC53aWR0aCA9IHdpZHRoO1xuICAgICAgICAgICAgY2FudmFzRWxlbWVudC5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgICAgICByZXR1cm4gY2FudmFzRWxlbWVudDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogU3RvcHMgdGhlIGNvbnRpbnVvdXMgc2NhbiBhbmQgY2xlYW5zIHRoZSBzdHJlYW0uXG4gICAgICAgICAqL1xuICAgICAgICBzdG9wU3RyZWFtcygpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0cmVhbSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RyZWFtLmdldFZpZGVvVHJhY2tzKCkuZm9yRWFjaCh0ID0+IHQuc3RvcCgpKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0cmVhbSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9zdG9wQXN5bmNEZWNvZGUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdG9wQXN5bmNEZWNvZGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9zdG9wQ29udGludW91c0RlY29kZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0b3BDb250aW51b3VzRGVjb2RlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlc2V0cyB0aGUgY29kZSByZWFkZXIgdG8gdGhlIGluaXRpYWwgc3RhdGUuIENhbmNlbHMgYW55IG9uZ29pbmcgYmFyY29kZSBzY2FubmluZyBmcm9tIHZpZGVvIG9yIGNhbWVyYS5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlck9mIEJyb3dzZXJDb2RlUmVhZGVyXG4gICAgICAgICAqL1xuICAgICAgICByZXNldCgpIHtcbiAgICAgICAgICAgIC8vIHN0b3BzIHRoZSBjYW1lcmEsIHByZXZpZXcgYW5kIHNjYW4gXHVEODNEXHVERDM0XG4gICAgICAgICAgICB0aGlzLnN0b3BTdHJlYW1zKCk7XG4gICAgICAgICAgICAvLyBjbGVhbiBhbmQgZm9yZ2V0IGFib3V0IEhUTUwgZWxlbWVudHNcbiAgICAgICAgICAgIHRoaXMuX2Rlc3Ryb3lWaWRlb0VsZW1lbnQoKTtcbiAgICAgICAgICAgIHRoaXMuX2Rlc3Ryb3lJbWFnZUVsZW1lbnQoKTtcbiAgICAgICAgICAgIHRoaXMuX2Rlc3Ryb3lDYXB0dXJlQ2FudmFzKCk7XG4gICAgICAgIH1cbiAgICAgICAgX2Rlc3Ryb3lWaWRlb0VsZW1lbnQoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMudmlkZW9FbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZmlyc3QgZ2l2ZXMgZnJlZWRvbiB0byB0aGUgZWxlbWVudCBcdUQ4M0RcdURENEFcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy52aWRlb0VuZGVkTGlzdGVuZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy52aWRlb0VsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZW5kZWQnLCB0aGlzLnZpZGVvRW5kZWRMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMudmlkZW9QbGF5aW5nRXZlbnRMaXN0ZW5lciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZGVvRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdwbGF5aW5nJywgdGhpcy52aWRlb1BsYXlpbmdFdmVudExpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy52aWRlb0NhblBsYXlMaXN0ZW5lciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZGVvRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdsb2FkZWRtZXRhZGF0YScsIHRoaXMudmlkZW9DYW5QbGF5TGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdGhlbiBmb3JnZXRzIGFib3V0IHRoYXQgZWxlbWVudCBcdUQ4M0RcdURFMjJcbiAgICAgICAgICAgIHRoaXMuY2xlYW5WaWRlb1NvdXJjZSh0aGlzLnZpZGVvRWxlbWVudCk7XG4gICAgICAgICAgICB0aGlzLnZpZGVvRWxlbWVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBfZGVzdHJveUltYWdlRWxlbWVudCgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5pbWFnZUVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBmaXJzdCBnaXZlcyBmcmVlZG9uIHRvIHRoZSBlbGVtZW50IFx1RDgzRFx1REQ0QVxuICAgICAgICAgICAgaWYgKHVuZGVmaW5lZCAhPT0gdGhpcy5pbWFnZUxvYWRlZExpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbWFnZUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbG9hZCcsIHRoaXMuaW1hZ2VMb2FkZWRMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0aGVuIGZvcmdldCBhYm91dCB0aGF0IGVsZW1lbnQgXHVEODNEXHVERTIyXG4gICAgICAgICAgICB0aGlzLmltYWdlRWxlbWVudC5zcmMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLmltYWdlRWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ3NyYycpO1xuICAgICAgICAgICAgdGhpcy5pbWFnZUVsZW1lbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENsZWFucyBjYW52YXMgcmVmZXJlbmNlcyBcdUQ4M0RcdUREOENcbiAgICAgICAgICovXG4gICAgICAgIF9kZXN0cm95Q2FwdHVyZUNhbnZhcygpIHtcbiAgICAgICAgICAgIC8vIHRoZW4gZm9yZ2V0IGFib3V0IHRoYXQgZWxlbWVudCBcdUQ4M0RcdURFMjJcbiAgICAgICAgICAgIHRoaXMuY2FwdHVyZUNhbnZhc0NvbnRleHQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLmNhcHR1cmVDYW52YXMgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlZmluZXMgd2hhdCB0aGUgdmlkZW9FbGVtZW50IHNyYyB3aWxsIGJlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gdmlkZW9FbGVtZW50XG4gICAgICAgICAqIEBwYXJhbSBzdHJlYW1cbiAgICAgICAgICovXG4gICAgICAgIGFkZFZpZGVvU291cmNlKHZpZGVvRWxlbWVudCwgc3RyZWFtKSB7XG4gICAgICAgICAgICAvLyBPbGRlciBicm93c2VycyBtYXkgbm90IGhhdmUgYHNyY09iamVjdGBcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgLy8gQG5vdGUgVGhyb3dzIEV4Y2VwdGlvbiBpZiBpbnRlcnJ1cHRlZCBieSBhIG5ldyBsb2FkZWQgcmVxdWVzdFxuICAgICAgICAgICAgICAgIHZpZGVvRWxlbWVudC5zcmNPYmplY3QgPSBzdHJlYW07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgLy8gQG5vdGUgQXZvaWQgdXNpbmcgdGhpcyBpbiBuZXcgYnJvd3NlcnMsIGFzIGl0IGlzIGdvaW5nIGF3YXkuXG4gICAgICAgICAgICAgICAgdmlkZW9FbGVtZW50LnNyYyA9IFVSTC5jcmVhdGVPYmplY3RVUkwoc3RyZWFtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogVW5iaW5kcyBhIEhUTUwgdmlkZW8gc3JjIHByb3BlcnR5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gdmlkZW9FbGVtZW50XG4gICAgICAgICAqL1xuICAgICAgICBjbGVhblZpZGVvU291cmNlKHZpZGVvRWxlbWVudCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2aWRlb0VsZW1lbnQuc3JjT2JqZWN0ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICB2aWRlb0VsZW1lbnQuc3JjID0gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnZpZGVvRWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ3NyYycpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBDb3B5cmlnaHQgMjAwNyBaWGluZyBhdXRob3JzXG4gICAgICpcbiAgICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgICAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgICAgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgICAgKlxuICAgICAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gICAgICpcbiAgICAgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICAgICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgICAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICAgICAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgICAgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiA8cD5FbmNhcHN1bGF0ZXMgdGhlIHJlc3VsdCBvZiBkZWNvZGluZyBhIGJhcmNvZGUgd2l0aGluIGFuIGltYWdlLjwvcD5cbiAgICAgKlxuICAgICAqIEBhdXRob3IgU2VhbiBPd2VuXG4gICAgICovXG4gICAgY2xhc3MgUmVzdWx0IHtcbiAgICAgICAgLy8gcHVibGljIGNvbnN0cnVjdG9yKHByaXZhdGUgdGV4dDogc3RyaW5nLFxuICAgICAgICAvLyAgICAgICAgICAgICAgIFVpbnQ4QXJyYXkgcmF3Qnl0ZXMsXG4gICAgICAgIC8vICAgICAgICAgICAgICAgUmVzdWx0UG9jb25zdCByZXN1bHRQb2ludHM6IEludDMyQXJyYXksXG4gICAgICAgIC8vICAgICAgICAgICAgICAgQmFyY29kZUZvcm1hdCBmb3JtYXQpIHtcbiAgICAgICAgLy8gICB0aGlzKHRleHQsIHJhd0J5dGVzLCByZXN1bHRQb2ludHMsIGZvcm1hdCwgU3lzdGVtLmN1cnJlbnRUaW1lTWlsbGlzKCkpXG4gICAgICAgIC8vIH1cbiAgICAgICAgLy8gcHVibGljIGNvbnN0cnVjdG9yKHRleHQ6IHN0cmluZyxcbiAgICAgICAgLy8gICAgICAgICAgICAgICBVaW50OEFycmF5IHJhd0J5dGVzLFxuICAgICAgICAvLyAgICAgICAgICAgICAgIFJlc3VsdFBvY29uc3QgcmVzdWx0UG9pbnRzOiBJbnQzMkFycmF5LFxuICAgICAgICAvLyAgICAgICAgICAgICAgIEJhcmNvZGVGb3JtYXQgZm9ybWF0LFxuICAgICAgICAvLyAgICAgICAgICAgICAgIGxvbmcgdGltZXN0YW1wKSB7XG4gICAgICAgIC8vICAgdGhpcyh0ZXh0LCByYXdCeXRlcywgcmF3Qnl0ZXMgPT0gbnVsbCA/IDAgOiA4ICogcmF3Qnl0ZXMubGVuZ3RoLFxuICAgICAgICAvLyAgICAgICAgcmVzdWx0UG9pbnRzLCBmb3JtYXQsIHRpbWVzdGFtcClcbiAgICAgICAgLy8gfVxuICAgICAgICBjb25zdHJ1Y3Rvcih0ZXh0LCByYXdCeXRlcywgbnVtQml0cyA9IHJhd0J5dGVzID09IG51bGwgPyAwIDogOCAqIHJhd0J5dGVzLmxlbmd0aCwgcmVzdWx0UG9pbnRzLCBmb3JtYXQsIHRpbWVzdGFtcCA9IFN5c3RlbS5jdXJyZW50VGltZU1pbGxpcygpKSB7XG4gICAgICAgICAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICAgICAgICAgICAgdGhpcy5yYXdCeXRlcyA9IHJhd0J5dGVzO1xuICAgICAgICAgICAgdGhpcy5udW1CaXRzID0gbnVtQml0cztcbiAgICAgICAgICAgIHRoaXMucmVzdWx0UG9pbnRzID0gcmVzdWx0UG9pbnRzO1xuICAgICAgICAgICAgdGhpcy5mb3JtYXQgPSBmb3JtYXQ7XG4gICAgICAgICAgICB0aGlzLnRpbWVzdGFtcCA9IHRpbWVzdGFtcDtcbiAgICAgICAgICAgIHRoaXMudGV4dCA9IHRleHQ7XG4gICAgICAgICAgICB0aGlzLnJhd0J5dGVzID0gcmF3Qnl0ZXM7XG4gICAgICAgICAgICBpZiAodW5kZWZpbmVkID09PSBudW1CaXRzIHx8IG51bGwgPT09IG51bUJpdHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm51bUJpdHMgPSAocmF3Qnl0ZXMgPT09IG51bGwgfHwgcmF3Qnl0ZXMgPT09IHVuZGVmaW5lZCkgPyAwIDogOCAqIHJhd0J5dGVzLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubnVtQml0cyA9IG51bUJpdHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJlc3VsdFBvaW50cyA9IHJlc3VsdFBvaW50cztcbiAgICAgICAgICAgIHRoaXMuZm9ybWF0ID0gZm9ybWF0O1xuICAgICAgICAgICAgdGhpcy5yZXN1bHRNZXRhZGF0YSA9IG51bGw7XG4gICAgICAgICAgICBpZiAodW5kZWZpbmVkID09PSB0aW1lc3RhbXAgfHwgbnVsbCA9PT0gdGltZXN0YW1wKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50aW1lc3RhbXAgPSBTeXN0ZW0uY3VycmVudFRpbWVNaWxsaXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMudGltZXN0YW1wID0gdGltZXN0YW1wO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHJhdyB0ZXh0IGVuY29kZWQgYnkgdGhlIGJhcmNvZGVcbiAgICAgICAgICovXG4gICAgICAgIGdldFRleHQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50ZXh0O1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHJhdyBieXRlcyBlbmNvZGVkIGJ5IHRoZSBiYXJjb2RlLCBpZiBhcHBsaWNhYmxlLCBvdGhlcndpc2Uge0Bjb2RlIG51bGx9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRSYXdCeXRlcygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJhd0J5dGVzO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIGhvdyBtYW55IGJpdHMgb2Yge0BsaW5rICNnZXRSYXdCeXRlcygpfSBhcmUgdmFsaWQ7IHR5cGljYWxseSA4IHRpbWVzIGl0cyBsZW5ndGhcbiAgICAgICAgICogQHNpbmNlIDMuMy4wXG4gICAgICAgICAqL1xuICAgICAgICBnZXROdW1CaXRzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtQml0cztcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiBwb2ludHMgcmVsYXRlZCB0byB0aGUgYmFyY29kZSBpbiB0aGUgaW1hZ2UuIFRoZXNlIGFyZSB0eXBpY2FsbHkgcG9pbnRzXG4gICAgICAgICAqICAgICAgICAgaWRlbnRpZnlpbmcgZmluZGVyIHBhdHRlcm5zIG9yIHRoZSBjb3JuZXJzIG9mIHRoZSBiYXJjb2RlLiBUaGUgZXhhY3QgbWVhbmluZyBpc1xuICAgICAgICAgKiAgICAgICAgIHNwZWNpZmljIHRvIHRoZSB0eXBlIG9mIGJhcmNvZGUgdGhhdCB3YXMgZGVjb2RlZC5cbiAgICAgICAgICovXG4gICAgICAgIGdldFJlc3VsdFBvaW50cygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlc3VsdFBvaW50cztcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7QGxpbmsgQmFyY29kZUZvcm1hdH0gcmVwcmVzZW50aW5nIHRoZSBmb3JtYXQgb2YgdGhlIGJhcmNvZGUgdGhhdCB3YXMgZGVjb2RlZFxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0QmFyY29kZUZvcm1hdCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZvcm1hdDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7QGxpbmsgTWFwfSBtYXBwaW5nIHtAbGluayBSZXN1bHRNZXRhZGF0YVR5cGV9IGtleXMgdG8gdmFsdWVzLiBNYXkgYmVcbiAgICAgICAgICogICB7QGNvZGUgbnVsbH0uIFRoaXMgY29udGFpbnMgb3B0aW9uYWwgbWV0YWRhdGEgYWJvdXQgd2hhdCB3YXMgZGV0ZWN0ZWQgYWJvdXQgdGhlIGJhcmNvZGUsXG4gICAgICAgICAqICAgbGlrZSBvcmllbnRhdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIGdldFJlc3VsdE1ldGFkYXRhKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVzdWx0TWV0YWRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgcHV0TWV0YWRhdGEodHlwZSwgdmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlc3VsdE1ldGFkYXRhID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXN1bHRNZXRhZGF0YSA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmVzdWx0TWV0YWRhdGEuc2V0KHR5cGUsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBwdXRBbGxNZXRhZGF0YShtZXRhZGF0YSkge1xuICAgICAgICAgICAgaWYgKG1ldGFkYXRhICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucmVzdWx0TWV0YWRhdGEgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXN1bHRNZXRhZGF0YSA9IG1ldGFkYXRhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXN1bHRNZXRhZGF0YSA9IG5ldyBNYXAobWV0YWRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhZGRSZXN1bHRQb2ludHMobmV3UG9pbnRzKSB7XG4gICAgICAgICAgICBjb25zdCBvbGRQb2ludHMgPSB0aGlzLnJlc3VsdFBvaW50cztcbiAgICAgICAgICAgIGlmIChvbGRQb2ludHMgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3VsdFBvaW50cyA9IG5ld1BvaW50cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG5ld1BvaW50cyAhPT0gbnVsbCAmJiBuZXdQb2ludHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFsbFBvaW50cyA9IG5ldyBBcnJheShvbGRQb2ludHMubGVuZ3RoICsgbmV3UG9pbnRzLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgU3lzdGVtLmFycmF5Y29weShvbGRQb2ludHMsIDAsIGFsbFBvaW50cywgMCwgb2xkUG9pbnRzLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgU3lzdGVtLmFycmF5Y29weShuZXdQb2ludHMsIDAsIGFsbFBvaW50cywgb2xkUG9pbnRzLmxlbmd0aCwgbmV3UG9pbnRzLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXN1bHRQb2ludHMgPSBhbGxQb2ludHM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZ2V0VGltZXN0YW1wKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudGltZXN0YW1wO1xuICAgICAgICB9XG4gICAgICAgIC8qQE92ZXJyaWRlKi9cbiAgICAgICAgdG9TdHJpbmcoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50ZXh0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBEaXJlY3QgcG9ydCB0byBUeXBlU2NyaXB0IG9mIFpYaW5nIGJ5IEFkcmlhbiBUb1x1MDIxOWNcdTAxMDNcbiAgICAgKi9cbiAgICAvKlxuICAgICAqIENvcHlyaWdodCAyMDA5IFpYaW5nIGF1dGhvcnNcbiAgICAgKlxuICAgICAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gICAgICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgICAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgICAqXG4gICAgICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAgICAgKlxuICAgICAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgICAgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICAgICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gICAgICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICAgICAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICAgICAqL1xuICAgIC8qbmFtZXNwYWNlIGNvbS5nb29nbGUuenhpbmcgeyovXG4gICAgLyoqXG4gICAgICogRW51bWVyYXRlcyBiYXJjb2RlIGZvcm1hdHMga25vd24gdG8gdGhpcyBwYWNrYWdlLiBQbGVhc2Uga2VlcCBhbHBoYWJldGl6ZWQuXG4gICAgICpcbiAgICAgKiBAYXV0aG9yIFNlYW4gT3dlblxuICAgICAqL1xuICAgIHZhciBCYXJjb2RlRm9ybWF0O1xuICAgIChmdW5jdGlvbiAoQmFyY29kZUZvcm1hdCkge1xuICAgICAgICAvKiogQXp0ZWMgMkQgYmFyY29kZSBmb3JtYXQuICovXG4gICAgICAgIEJhcmNvZGVGb3JtYXRbQmFyY29kZUZvcm1hdFtcIkFaVEVDXCJdID0gMF0gPSBcIkFaVEVDXCI7XG4gICAgICAgIC8qKiBDT0RBQkFSIDFEIGZvcm1hdC4gKi9cbiAgICAgICAgQmFyY29kZUZvcm1hdFtCYXJjb2RlRm9ybWF0W1wiQ09EQUJBUlwiXSA9IDFdID0gXCJDT0RBQkFSXCI7XG4gICAgICAgIC8qKiBDb2RlIDM5IDFEIGZvcm1hdC4gKi9cbiAgICAgICAgQmFyY29kZUZvcm1hdFtCYXJjb2RlRm9ybWF0W1wiQ09ERV8zOVwiXSA9IDJdID0gXCJDT0RFXzM5XCI7XG4gICAgICAgIC8qKiBDb2RlIDkzIDFEIGZvcm1hdC4gKi9cbiAgICAgICAgQmFyY29kZUZvcm1hdFtCYXJjb2RlRm9ybWF0W1wiQ09ERV85M1wiXSA9IDNdID0gXCJDT0RFXzkzXCI7XG4gICAgICAgIC8qKiBDb2RlIDEyOCAxRCBmb3JtYXQuICovXG4gICAgICAgIEJhcmNvZGVGb3JtYXRbQmFyY29kZUZvcm1hdFtcIkNPREVfMTI4XCJdID0gNF0gPSBcIkNPREVfMTI4XCI7XG4gICAgICAgIC8qKiBEYXRhIE1hdHJpeCAyRCBiYXJjb2RlIGZvcm1hdC4gKi9cbiAgICAgICAgQmFyY29kZUZvcm1hdFtCYXJjb2RlRm9ybWF0W1wiREFUQV9NQVRSSVhcIl0gPSA1XSA9IFwiREFUQV9NQVRSSVhcIjtcbiAgICAgICAgLyoqIEVBTi04IDFEIGZvcm1hdC4gKi9cbiAgICAgICAgQmFyY29kZUZvcm1hdFtCYXJjb2RlRm9ybWF0W1wiRUFOXzhcIl0gPSA2XSA9IFwiRUFOXzhcIjtcbiAgICAgICAgLyoqIEVBTi0xMyAxRCBmb3JtYXQuICovXG4gICAgICAgIEJhcmNvZGVGb3JtYXRbQmFyY29kZUZvcm1hdFtcIkVBTl8xM1wiXSA9IDddID0gXCJFQU5fMTNcIjtcbiAgICAgICAgLyoqIElURiAoSW50ZXJsZWF2ZWQgVHdvIG9mIEZpdmUpIDFEIGZvcm1hdC4gKi9cbiAgICAgICAgQmFyY29kZUZvcm1hdFtCYXJjb2RlRm9ybWF0W1wiSVRGXCJdID0gOF0gPSBcIklURlwiO1xuICAgICAgICAvKiogTWF4aUNvZGUgMkQgYmFyY29kZSBmb3JtYXQuICovXG4gICAgICAgIEJhcmNvZGVGb3JtYXRbQmFyY29kZUZvcm1hdFtcIk1BWElDT0RFXCJdID0gOV0gPSBcIk1BWElDT0RFXCI7XG4gICAgICAgIC8qKiBQREY0MTcgZm9ybWF0LiAqL1xuICAgICAgICBCYXJjb2RlRm9ybWF0W0JhcmNvZGVGb3JtYXRbXCJQREZfNDE3XCJdID0gMTBdID0gXCJQREZfNDE3XCI7XG4gICAgICAgIC8qKiBRUiBDb2RlIDJEIGJhcmNvZGUgZm9ybWF0LiAqL1xuICAgICAgICBCYXJjb2RlRm9ybWF0W0JhcmNvZGVGb3JtYXRbXCJRUl9DT0RFXCJdID0gMTFdID0gXCJRUl9DT0RFXCI7XG4gICAgICAgIC8qKiBSU1MgMTQgKi9cbiAgICAgICAgQmFyY29kZUZvcm1hdFtCYXJjb2RlRm9ybWF0W1wiUlNTXzE0XCJdID0gMTJdID0gXCJSU1NfMTRcIjtcbiAgICAgICAgLyoqIFJTUyBFWFBBTkRFRCAqL1xuICAgICAgICBCYXJjb2RlRm9ybWF0W0JhcmNvZGVGb3JtYXRbXCJSU1NfRVhQQU5ERURcIl0gPSAxM10gPSBcIlJTU19FWFBBTkRFRFwiO1xuICAgICAgICAvKiogVVBDLUEgMUQgZm9ybWF0LiAqL1xuICAgICAgICBCYXJjb2RlRm9ybWF0W0JhcmNvZGVGb3JtYXRbXCJVUENfQVwiXSA9IDE0XSA9IFwiVVBDX0FcIjtcbiAgICAgICAgLyoqIFVQQy1FIDFEIGZvcm1hdC4gKi9cbiAgICAgICAgQmFyY29kZUZvcm1hdFtCYXJjb2RlRm9ybWF0W1wiVVBDX0VcIl0gPSAxNV0gPSBcIlVQQ19FXCI7XG4gICAgICAgIC8qKiBVUEMvRUFOIGV4dGVuc2lvbiBmb3JtYXQuIE5vdCBhIHN0YW5kLWFsb25lIGZvcm1hdC4gKi9cbiAgICAgICAgQmFyY29kZUZvcm1hdFtCYXJjb2RlRm9ybWF0W1wiVVBDX0VBTl9FWFRFTlNJT05cIl0gPSAxNl0gPSBcIlVQQ19FQU5fRVhURU5TSU9OXCI7XG4gICAgfSkoQmFyY29kZUZvcm1hdCB8fCAoQmFyY29kZUZvcm1hdCA9IHt9KSk7XG4gICAgdmFyIEJhcmNvZGVGb3JtYXQkMSA9IEJhcmNvZGVGb3JtYXQ7XG5cbiAgICAvKm5hbWVzcGFjZSBjb20uZ29vZ2xlLnp4aW5nIHsqL1xuICAgIC8qKlxuICAgICAqIFJlcHJlc2VudHMgc29tZSB0eXBlIG9mIG1ldGFkYXRhIGFib3V0IHRoZSByZXN1bHQgb2YgdGhlIGRlY29kaW5nIHRoYXQgdGhlIGRlY29kZXJcbiAgICAgKiB3aXNoZXMgdG8gY29tbXVuaWNhdGUgYmFjayB0byB0aGUgY2FsbGVyLlxuICAgICAqXG4gICAgICogQGF1dGhvciBTZWFuIE93ZW5cbiAgICAgKi9cbiAgICB2YXIgUmVzdWx0TWV0YWRhdGFUeXBlO1xuICAgIChmdW5jdGlvbiAoUmVzdWx0TWV0YWRhdGFUeXBlKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVbnNwZWNpZmllZCwgYXBwbGljYXRpb24tc3BlY2lmaWMgbWV0YWRhdGEuIE1hcHMgdG8gYW4gdW5zcGVjaWZpZWQge0BsaW5rIE9iamVjdH0uXG4gICAgICAgICAqL1xuICAgICAgICBSZXN1bHRNZXRhZGF0YVR5cGVbUmVzdWx0TWV0YWRhdGFUeXBlW1wiT1RIRVJcIl0gPSAwXSA9IFwiT1RIRVJcIjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlbm90ZXMgdGhlIGxpa2VseSBhcHByb3hpbWF0ZSBvcmllbnRhdGlvbiBvZiB0aGUgYmFyY29kZSBpbiB0aGUgaW1hZ2UuIFRoaXMgdmFsdWVcbiAgICAgICAgICogaXMgZ2l2ZW4gYXMgZGVncmVlcyByb3RhdGVkIGNsb2Nrd2lzZSBmcm9tIHRoZSBub3JtYWwsIHVwcmlnaHQgb3JpZW50YXRpb24uXG4gICAgICAgICAqIEZvciBleGFtcGxlIGEgMUQgYmFyY29kZSB3aGljaCB3YXMgZm91bmQgYnkgcmVhZGluZyB0b3AtdG8tYm90dG9tIHdvdWxkIGJlXG4gICAgICAgICAqIHNhaWQgdG8gaGF2ZSBvcmllbnRhdGlvbiBcIjkwXCIuIFRoaXMga2V5IG1hcHMgdG8gYW4ge0BsaW5rIEludGVnZXJ9IHdob3NlXG4gICAgICAgICAqIHZhbHVlIGlzIGluIHRoZSByYW5nZSBbMCwzNjApLlxuICAgICAgICAgKi9cbiAgICAgICAgUmVzdWx0TWV0YWRhdGFUeXBlW1Jlc3VsdE1ldGFkYXRhVHlwZVtcIk9SSUVOVEFUSU9OXCJdID0gMV0gPSBcIk9SSUVOVEFUSU9OXCI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiA8cD4yRCBiYXJjb2RlIGZvcm1hdHMgdHlwaWNhbGx5IGVuY29kZSB0ZXh0LCBidXQgYWxsb3cgZm9yIGEgc29ydCBvZiAnYnl0ZSBtb2RlJ1xuICAgICAgICAgKiB3aGljaCBpcyBzb21ldGltZXMgdXNlZCB0byBlbmNvZGUgYmluYXJ5IGRhdGEuIFdoaWxlIHtAbGluayBSZXN1bHR9IG1ha2VzIGF2YWlsYWJsZVxuICAgICAgICAgKiB0aGUgY29tcGxldGUgcmF3IGJ5dGVzIGluIHRoZSBiYXJjb2RlIGZvciB0aGVzZSBmb3JtYXRzLCBpdCBkb2VzIG5vdCBvZmZlciB0aGUgYnl0ZXNcbiAgICAgICAgICogZnJvbSB0aGUgYnl0ZSBzZWdtZW50cyBhbG9uZS48L3A+XG4gICAgICAgICAqXG4gICAgICAgICAqIDxwPlRoaXMgbWFwcyB0byBhIHtAbGluayBqYXZhLnV0aWwuTGlzdH0gb2YgYnl0ZSBhcnJheXMgY29ycmVzcG9uZGluZyB0byB0aGVcbiAgICAgICAgICogcmF3IGJ5dGVzIGluIHRoZSBieXRlIHNlZ21lbnRzIGluIHRoZSBiYXJjb2RlLCBpbiBvcmRlci48L3A+XG4gICAgICAgICAqL1xuICAgICAgICBSZXN1bHRNZXRhZGF0YVR5cGVbUmVzdWx0TWV0YWRhdGFUeXBlW1wiQllURV9TRUdNRU5UU1wiXSA9IDJdID0gXCJCWVRFX1NFR01FTlRTXCI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFcnJvciBjb3JyZWN0aW9uIGxldmVsIHVzZWQsIGlmIGFwcGxpY2FibGUuIFRoZSB2YWx1ZSB0eXBlIGRlcGVuZHMgb24gdGhlXG4gICAgICAgICAqIGZvcm1hdCwgYnV0IGlzIHR5cGljYWxseSBhIFN0cmluZy5cbiAgICAgICAgICovXG4gICAgICAgIFJlc3VsdE1ldGFkYXRhVHlwZVtSZXN1bHRNZXRhZGF0YVR5cGVbXCJFUlJPUl9DT1JSRUNUSU9OX0xFVkVMXCJdID0gM10gPSBcIkVSUk9SX0NPUlJFQ1RJT05fTEVWRUxcIjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZvciBzb21lIHBlcmlvZGljYWxzLCBpbmRpY2F0ZXMgdGhlIGlzc3VlIG51bWJlciBhcyBhbiB7QGxpbmsgSW50ZWdlcn0uXG4gICAgICAgICAqL1xuICAgICAgICBSZXN1bHRNZXRhZGF0YVR5cGVbUmVzdWx0TWV0YWRhdGFUeXBlW1wiSVNTVUVfTlVNQkVSXCJdID0gNF0gPSBcIklTU1VFX05VTUJFUlwiO1xuICAgICAgICAvKipcbiAgICAgICAgICogRm9yIHNvbWUgcHJvZHVjdHMsIGluZGljYXRlcyB0aGUgc3VnZ2VzdGVkIHJldGFpbCBwcmljZSBpbiB0aGUgYmFyY29kZSBhcyBhXG4gICAgICAgICAqIGZvcm1hdHRlZCB7QGxpbmsgU3RyaW5nfS5cbiAgICAgICAgICovXG4gICAgICAgIFJlc3VsdE1ldGFkYXRhVHlwZVtSZXN1bHRNZXRhZGF0YVR5cGVbXCJTVUdHRVNURURfUFJJQ0VcIl0gPSA1XSA9IFwiU1VHR0VTVEVEX1BSSUNFXCI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGb3Igc29tZSBwcm9kdWN0cywgdGhlIHBvc3NpYmxlIGNvdW50cnkgb2YgbWFudWZhY3R1cmUgYXMgYSB7QGxpbmsgU3RyaW5nfSBkZW5vdGluZyB0aGVcbiAgICAgICAgICogSVNPIGNvdW50cnkgY29kZS4gU29tZSBtYXAgdG8gbXVsdGlwbGUgcG9zc2libGUgY291bnRyaWVzLCBsaWtlIFwiVVMvQ0FcIi5cbiAgICAgICAgICovXG4gICAgICAgIFJlc3VsdE1ldGFkYXRhVHlwZVtSZXN1bHRNZXRhZGF0YVR5cGVbXCJQT1NTSUJMRV9DT1VOVFJZXCJdID0gNl0gPSBcIlBPU1NJQkxFX0NPVU5UUllcIjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZvciBzb21lIHByb2R1Y3RzLCB0aGUgZXh0ZW5zaW9uIHRleHRcbiAgICAgICAgICovXG4gICAgICAgIFJlc3VsdE1ldGFkYXRhVHlwZVtSZXN1bHRNZXRhZGF0YVR5cGVbXCJVUENfRUFOX0VYVEVOU0lPTlwiXSA9IDddID0gXCJVUENfRUFOX0VYVEVOU0lPTlwiO1xuICAgICAgICAvKipcbiAgICAgICAgICogUERGNDE3LXNwZWNpZmljIG1ldGFkYXRhXG4gICAgICAgICAqL1xuICAgICAgICBSZXN1bHRNZXRhZGF0YVR5cGVbUmVzdWx0TWV0YWRhdGFUeXBlW1wiUERGNDE3X0VYVFJBX01FVEFEQVRBXCJdID0gOF0gPSBcIlBERjQxN19FWFRSQV9NRVRBREFUQVwiO1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgdGhlIGNvZGUgZm9ybWF0IHN1cHBvcnRzIHN0cnVjdHVyZWQgYXBwZW5kIGFuZCB0aGUgY3VycmVudCBzY2FubmVkIGNvZGUgaXMgcGFydCBvZiBvbmUgdGhlbiB0aGVcbiAgICAgICAgICogc2VxdWVuY2UgbnVtYmVyIGlzIGdpdmVuIHdpdGggaXQuXG4gICAgICAgICAqL1xuICAgICAgICBSZXN1bHRNZXRhZGF0YVR5cGVbUmVzdWx0TWV0YWRhdGFUeXBlW1wiU1RSVUNUVVJFRF9BUFBFTkRfU0VRVUVOQ0VcIl0gPSA5XSA9IFwiU1RSVUNUVVJFRF9BUFBFTkRfU0VRVUVOQ0VcIjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHRoZSBjb2RlIGZvcm1hdCBzdXBwb3J0cyBzdHJ1Y3R1cmVkIGFwcGVuZCBhbmQgdGhlIGN1cnJlbnQgc2Nhbm5lZCBjb2RlIGlzIHBhcnQgb2Ygb25lIHRoZW4gdGhlXG4gICAgICAgICAqIHBhcml0eSBpcyBnaXZlbiB3aXRoIGl0LlxuICAgICAgICAgKi9cbiAgICAgICAgUmVzdWx0TWV0YWRhdGFUeXBlW1Jlc3VsdE1ldGFkYXRhVHlwZVtcIlNUUlVDVFVSRURfQVBQRU5EX1BBUklUWVwiXSA9IDEwXSA9IFwiU1RSVUNUVVJFRF9BUFBFTkRfUEFSSVRZXCI7XG4gICAgfSkoUmVzdWx0TWV0YWRhdGFUeXBlIHx8IChSZXN1bHRNZXRhZGF0YVR5cGUgPSB7fSkpO1xuICAgIHZhciBSZXN1bHRNZXRhZGF0YVR5cGUkMSA9IFJlc3VsdE1ldGFkYXRhVHlwZTtcblxuICAgIC8qXG4gICAgICogQ29weXJpZ2h0IDIwMDcgWlhpbmcgYXV0aG9yc1xuICAgICAqXG4gICAgICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgICAgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICAgICpcbiAgICAgKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICAgICAqXG4gICAgICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICAgICAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgICAgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgICAgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gICAgICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gICAgICovXG4gICAgLypuYW1lc3BhY2UgY29tLmdvb2dsZS56eGluZy5jb21tb24geyovXG4gICAgLyppbXBvcnQgamF2YS51dGlsLkxpc3Q7Ki9cbiAgICAvKipcbiAgICAgKiA8cD5FbmNhcHN1bGF0ZXMgdGhlIHJlc3VsdCBvZiBkZWNvZGluZyBhIG1hdHJpeCBvZiBiaXRzLiBUaGlzIHR5cGljYWxseVxuICAgICAqIGFwcGxpZXMgdG8gMkQgYmFyY29kZSBmb3JtYXRzLiBGb3Igbm93IGl0IGNvbnRhaW5zIHRoZSByYXcgYnl0ZXMgb2J0YWluZWQsXG4gICAgICogYXMgd2VsbCBhcyBhIFN0cmluZyBpbnRlcnByZXRhdGlvbiBvZiB0aG9zZSBieXRlcywgaWYgYXBwbGljYWJsZS48L3A+XG4gICAgICpcbiAgICAgKiBAYXV0aG9yIFNlYW4gT3dlblxuICAgICAqL1xuICAgIGNsYXNzIERlY29kZXJSZXN1bHQge1xuICAgICAgICAvLyBwdWJsaWMgY29uc3RydWN0b3IocmF3Qnl0ZXM6IFVpbnQ4QXJyYXksXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IHN0cmluZyxcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgTGlzdDxVaW50OEFycmF5PiBieXRlU2VnbWVudHMsXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgIFN0cmluZyBlY0xldmVsKSB7XG4gICAgICAgIC8vICAgdGhpcyhyYXdCeXRlcywgdGV4dCwgYnl0ZVNlZ21lbnRzLCBlY0xldmVsLCAtMSwgLTEpXG4gICAgICAgIC8vIH1cbiAgICAgICAgY29uc3RydWN0b3IocmF3Qnl0ZXMsIHRleHQsIGJ5dGVTZWdtZW50cywgZWNMZXZlbCwgc3RydWN0dXJlZEFwcGVuZFNlcXVlbmNlTnVtYmVyID0gLTEsIHN0cnVjdHVyZWRBcHBlbmRQYXJpdHkgPSAtMSkge1xuICAgICAgICAgICAgdGhpcy5yYXdCeXRlcyA9IHJhd0J5dGVzO1xuICAgICAgICAgICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgICAgICAgICAgIHRoaXMuYnl0ZVNlZ21lbnRzID0gYnl0ZVNlZ21lbnRzO1xuICAgICAgICAgICAgdGhpcy5lY0xldmVsID0gZWNMZXZlbDtcbiAgICAgICAgICAgIHRoaXMuc3RydWN0dXJlZEFwcGVuZFNlcXVlbmNlTnVtYmVyID0gc3RydWN0dXJlZEFwcGVuZFNlcXVlbmNlTnVtYmVyO1xuICAgICAgICAgICAgdGhpcy5zdHJ1Y3R1cmVkQXBwZW5kUGFyaXR5ID0gc3RydWN0dXJlZEFwcGVuZFBhcml0eTtcbiAgICAgICAgICAgIHRoaXMubnVtQml0cyA9IChyYXdCeXRlcyA9PT0gdW5kZWZpbmVkIHx8IHJhd0J5dGVzID09PSBudWxsKSA/IDAgOiA4ICogcmF3Qnl0ZXMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHJhdyBieXRlcyByZXByZXNlbnRpbmcgdGhlIHJlc3VsdCwgb3Ige0Bjb2RlIG51bGx9IGlmIG5vdCBhcHBsaWNhYmxlXG4gICAgICAgICAqL1xuICAgICAgICBnZXRSYXdCeXRlcygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJhd0J5dGVzO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIGhvdyBtYW55IGJpdHMgb2Yge0BsaW5rICNnZXRSYXdCeXRlcygpfSBhcmUgdmFsaWQ7IHR5cGljYWxseSA4IHRpbWVzIGl0cyBsZW5ndGhcbiAgICAgICAgICogQHNpbmNlIDMuMy4wXG4gICAgICAgICAqL1xuICAgICAgICBnZXROdW1CaXRzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtQml0cztcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIG51bUJpdHMgb3ZlcnJpZGVzIHRoZSBudW1iZXIgb2YgYml0cyB0aGF0IGFyZSB2YWxpZCBpbiB7QGxpbmsgI2dldFJhd0J5dGVzKCl9XG4gICAgICAgICAqIEBzaW5jZSAzLjMuMFxuICAgICAgICAgKi9cbiAgICAgICAgc2V0TnVtQml0cyhudW1CaXRzIC8qaW50Ki8pIHtcbiAgICAgICAgICAgIHRoaXMubnVtQml0cyA9IG51bUJpdHM7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gdGV4dCByZXByZXNlbnRhdGlvbiBvZiB0aGUgcmVzdWx0XG4gICAgICAgICAqL1xuICAgICAgICBnZXRUZXh0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudGV4dDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiBsaXN0IG9mIGJ5dGUgc2VnbWVudHMgaW4gdGhlIHJlc3VsdCwgb3Ige0Bjb2RlIG51bGx9IGlmIG5vdCBhcHBsaWNhYmxlXG4gICAgICAgICAqL1xuICAgICAgICBnZXRCeXRlU2VnbWVudHMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ieXRlU2VnbWVudHM7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gbmFtZSBvZiBlcnJvciBjb3JyZWN0aW9uIGxldmVsIHVzZWQsIG9yIHtAY29kZSBudWxsfSBpZiBub3QgYXBwbGljYWJsZVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0RUNMZXZlbCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVjTGV2ZWw7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gbnVtYmVyIG9mIGVycm9ycyBjb3JyZWN0ZWQsIG9yIHtAY29kZSBudWxsfSBpZiBub3QgYXBwbGljYWJsZVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0RXJyb3JzQ29ycmVjdGVkKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3JzQ29ycmVjdGVkO1xuICAgICAgICB9XG4gICAgICAgIHNldEVycm9yc0NvcnJlY3RlZChlcnJvcnNDb3JyZWN0ZWQgLypJbnRlZ2VyKi8pIHtcbiAgICAgICAgICAgIHRoaXMuZXJyb3JzQ29ycmVjdGVkID0gZXJyb3JzQ29ycmVjdGVkO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIG51bWJlciBvZiBlcmFzdXJlcyBjb3JyZWN0ZWQsIG9yIHtAY29kZSBudWxsfSBpZiBub3QgYXBwbGljYWJsZVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0RXJhc3VyZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lcmFzdXJlcztcbiAgICAgICAgfVxuICAgICAgICBzZXRFcmFzdXJlcyhlcmFzdXJlcyAvKkludGVnZXIqLykge1xuICAgICAgICAgICAgdGhpcy5lcmFzdXJlcyA9IGVyYXN1cmVzO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIGFyYml0cmFyeSBhZGRpdGlvbmFsIG1ldGFkYXRhXG4gICAgICAgICAqL1xuICAgICAgICBnZXRPdGhlcigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm90aGVyO1xuICAgICAgICB9XG4gICAgICAgIHNldE90aGVyKG90aGVyKSB7XG4gICAgICAgICAgICB0aGlzLm90aGVyID0gb3RoZXI7XG4gICAgICAgIH1cbiAgICAgICAgaGFzU3RydWN0dXJlZEFwcGVuZCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0cnVjdHVyZWRBcHBlbmRQYXJpdHkgPj0gMCAmJiB0aGlzLnN0cnVjdHVyZWRBcHBlbmRTZXF1ZW5jZU51bWJlciA+PSAwO1xuICAgICAgICB9XG4gICAgICAgIGdldFN0cnVjdHVyZWRBcHBlbmRQYXJpdHkoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdHJ1Y3R1cmVkQXBwZW5kUGFyaXR5O1xuICAgICAgICB9XG4gICAgICAgIGdldFN0cnVjdHVyZWRBcHBlbmRTZXF1ZW5jZU51bWJlcigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0cnVjdHVyZWRBcHBlbmRTZXF1ZW5jZU51bWJlcjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qXG4gICAgICogQ29weXJpZ2h0IDIwMDcgWlhpbmcgYXV0aG9yc1xuICAgICAqXG4gICAgICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgICAgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICAgICpcbiAgICAgKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICAgICAqXG4gICAgICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICAgICAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgICAgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgICAgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gICAgICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gICAgICovXG4gICAgLyoqXG4gICAgICogPHA+VGhpcyBjbGFzcyBjb250YWlucyB1dGlsaXR5IG1ldGhvZHMgZm9yIHBlcmZvcm1pbmcgbWF0aGVtYXRpY2FsIG9wZXJhdGlvbnMgb3ZlclxuICAgICAqIHRoZSBHYWxvaXMgRmllbGRzLiBPcGVyYXRpb25zIHVzZSBhIGdpdmVuIHByaW1pdGl2ZSBwb2x5bm9taWFsIGluIGNhbGN1bGF0aW9ucy48L3A+XG4gICAgICpcbiAgICAgKiA8cD5UaHJvdWdob3V0IHRoaXMgcGFja2FnZSwgZWxlbWVudHMgb2YgdGhlIEdGIGFyZSByZXByZXNlbnRlZCBhcyBhbiB7QGNvZGUgaW50fVxuICAgICAqIGZvciBjb252ZW5pZW5jZSBhbmQgc3BlZWQgKGJ1dCBhdCB0aGUgY29zdCBvZiBtZW1vcnkpLlxuICAgICAqIDwvcD5cbiAgICAgKlxuICAgICAqIEBhdXRob3IgU2VhbiBPd2VuXG4gICAgICogQGF1dGhvciBEYXZpZCBPbGl2aWVyXG4gICAgICovXG4gICAgY2xhc3MgQWJzdHJhY3RHZW5lcmljR0Yge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiAyIHRvIHRoZSBwb3dlciBvZiBhIGluIEdGKHNpemUpXG4gICAgICAgICAqL1xuICAgICAgICBleHAoYSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXhwVGFibGVbYV07XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gYmFzZSAyIGxvZyBvZiBhIGluIEdGKHNpemUpXG4gICAgICAgICAqL1xuICAgICAgICBsb2coYSAvKmludCovKSB7XG4gICAgICAgICAgICBpZiAoYSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvZ1RhYmxlW2FdO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbXBsZW1lbnRzIGJvdGggYWRkaXRpb24gYW5kIHN1YnRyYWN0aW9uIC0tIHRoZXkgYXJlIHRoZSBzYW1lIGluIEdGKHNpemUpLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHN1bS9kaWZmZXJlbmNlIG9mIGEgYW5kIGJcbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBhZGRPclN1YnRyYWN0KGEgLyppbnQqLywgYiAvKmludCovKSB7XG4gICAgICAgICAgICByZXR1cm4gYSBeIGI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKlxuICAgICAqIENvcHlyaWdodCAyMDA3IFpYaW5nIGF1dGhvcnNcbiAgICAgKlxuICAgICAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gICAgICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgICAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgICAqXG4gICAgICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAgICAgKlxuICAgICAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgICAgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICAgICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gICAgICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICAgICAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIDxwPlJlcHJlc2VudHMgYSBwb2x5bm9taWFsIHdob3NlIGNvZWZmaWNpZW50cyBhcmUgZWxlbWVudHMgb2YgYSBHRi5cbiAgICAgKiBJbnN0YW5jZXMgb2YgdGhpcyBjbGFzcyBhcmUgaW1tdXRhYmxlLjwvcD5cbiAgICAgKlxuICAgICAqIDxwPk11Y2ggY3JlZGl0IGlzIGR1ZSB0byBXaWxsaWFtIFJ1Y2tsaWRnZSBzaW5jZSBwb3J0aW9ucyBvZiB0aGlzIGNvZGUgYXJlIGFuIGluZGlyZWN0XG4gICAgICogcG9ydCBvZiBoaXMgQysrIFJlZWQtU29sb21vbiBpbXBsZW1lbnRhdGlvbi48L3A+XG4gICAgICpcbiAgICAgKiBAYXV0aG9yIFNlYW4gT3dlblxuICAgICAqL1xuICAgIGNsYXNzIEdlbmVyaWNHRlBvbHkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIGZpZWxkIHRoZSB7QGxpbmsgR2VuZXJpY0dGfSBpbnN0YW5jZSByZXByZXNlbnRpbmcgdGhlIGZpZWxkIHRvIHVzZVxuICAgICAgICAgKiB0byBwZXJmb3JtIGNvbXB1dGF0aW9uc1xuICAgICAgICAgKiBAcGFyYW0gY29lZmZpY2llbnRzIGNvZWZmaWNpZW50cyBhcyBpbnRzIHJlcHJlc2VudGluZyBlbGVtZW50cyBvZiBHRihzaXplKSwgYXJyYW5nZWRcbiAgICAgICAgICogZnJvbSBtb3N0IHNpZ25pZmljYW50IChoaWdoZXN0LXBvd2VyIHRlcm0pIGNvZWZmaWNpZW50IHRvIGxlYXN0IHNpZ25pZmljYW50XG4gICAgICAgICAqIEB0aHJvd3MgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uIGlmIGFyZ3VtZW50IGlzIG51bGwgb3IgZW1wdHksXG4gICAgICAgICAqIG9yIGlmIGxlYWRpbmcgY29lZmZpY2llbnQgaXMgMCBhbmQgdGhpcyBpcyBub3QgYVxuICAgICAgICAgKiBjb25zdGFudCBwb2x5bm9taWFsICh0aGF0IGlzLCBpdCBpcyBub3QgdGhlIG1vbm9taWFsIFwiMFwiKVxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3RydWN0b3IoZmllbGQsIGNvZWZmaWNpZW50cykge1xuICAgICAgICAgICAgaWYgKGNvZWZmaWNpZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmZpZWxkID0gZmllbGQ7XG4gICAgICAgICAgICBjb25zdCBjb2VmZmljaWVudHNMZW5ndGggPSBjb2VmZmljaWVudHMubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGNvZWZmaWNpZW50c0xlbmd0aCA+IDEgJiYgY29lZmZpY2llbnRzWzBdID09PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gTGVhZGluZyB0ZXJtIG11c3QgYmUgbm9uLXplcm8gZm9yIGFueXRoaW5nIGV4Y2VwdCB0aGUgY29uc3RhbnQgcG9seW5vbWlhbCBcIjBcIlxuICAgICAgICAgICAgICAgIGxldCBmaXJzdE5vblplcm8gPSAxO1xuICAgICAgICAgICAgICAgIHdoaWxlIChmaXJzdE5vblplcm8gPCBjb2VmZmljaWVudHNMZW5ndGggJiYgY29lZmZpY2llbnRzW2ZpcnN0Tm9uWmVyb10gPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3ROb25aZXJvKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChmaXJzdE5vblplcm8gPT09IGNvZWZmaWNpZW50c0xlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvZWZmaWNpZW50cyA9IEludDMyQXJyYXkuZnJvbShbMF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb2VmZmljaWVudHMgPSBuZXcgSW50MzJBcnJheShjb2VmZmljaWVudHNMZW5ndGggLSBmaXJzdE5vblplcm8pO1xuICAgICAgICAgICAgICAgICAgICBTeXN0ZW0uYXJyYXljb3B5KGNvZWZmaWNpZW50cywgZmlyc3ROb25aZXJvLCB0aGlzLmNvZWZmaWNpZW50cywgMCwgdGhpcy5jb2VmZmljaWVudHMubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvZWZmaWNpZW50cyA9IGNvZWZmaWNpZW50cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBnZXRDb2VmZmljaWVudHMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb2VmZmljaWVudHM7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gZGVncmVlIG9mIHRoaXMgcG9seW5vbWlhbFxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0RGVncmVlKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29lZmZpY2llbnRzLmxlbmd0aCAtIDE7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gdHJ1ZSBpZmYgdGhpcyBwb2x5bm9taWFsIGlzIHRoZSBtb25vbWlhbCBcIjBcIlxuICAgICAgICAgKi9cbiAgICAgICAgaXNaZXJvKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29lZmZpY2llbnRzWzBdID09PSAwO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIGNvZWZmaWNpZW50IG9mIHheZGVncmVlIHRlcm0gaW4gdGhpcyBwb2x5bm9taWFsXG4gICAgICAgICAqL1xuICAgICAgICBnZXRDb2VmZmljaWVudChkZWdyZWUgLyppbnQqLykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29lZmZpY2llbnRzW3RoaXMuY29lZmZpY2llbnRzLmxlbmd0aCAtIDEgLSBkZWdyZWVdO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIGV2YWx1YXRpb24gb2YgdGhpcyBwb2x5bm9taWFsIGF0IGEgZ2l2ZW4gcG9pbnRcbiAgICAgICAgICovXG4gICAgICAgIGV2YWx1YXRlQXQoYSAvKmludCovKSB7XG4gICAgICAgICAgICBpZiAoYSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIEp1c3QgcmV0dXJuIHRoZSB4XjAgY29lZmZpY2llbnRcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRDb2VmZmljaWVudCgwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNvZWZmaWNpZW50cyA9IHRoaXMuY29lZmZpY2llbnRzO1xuICAgICAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgICAgIGlmIChhID09PSAxKSB7XG4gICAgICAgICAgICAgICAgLy8gSnVzdCB0aGUgc3VtIG9mIHRoZSBjb2VmZmljaWVudHNcbiAgICAgICAgICAgICAgICByZXN1bHQgPSAwO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW5ndGggPSBjb2VmZmljaWVudHMubGVuZ3RoOyBpICE9PSBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb2VmZmljaWVudCA9IGNvZWZmaWNpZW50c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gQWJzdHJhY3RHZW5lcmljR0YuYWRkT3JTdWJ0cmFjdChyZXN1bHQsIGNvZWZmaWNpZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdCA9IGNvZWZmaWNpZW50c1swXTtcbiAgICAgICAgICAgIGNvbnN0IHNpemUgPSBjb2VmZmljaWVudHMubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgZmllbGQgPSB0aGlzLmZpZWxkO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBBYnN0cmFjdEdlbmVyaWNHRi5hZGRPclN1YnRyYWN0KGZpZWxkLm11bHRpcGx5KGEsIHJlc3VsdCksIGNvZWZmaWNpZW50c1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGFkZE9yU3VidHJhY3Qob3RoZXIpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5maWVsZC5lcXVhbHMob3RoZXIuZmllbGQpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignR2VuZXJpY0dGUG9seXMgZG8gbm90IGhhdmUgc2FtZSBHZW5lcmljR0YgZmllbGQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmlzWmVybygpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG90aGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG90aGVyLmlzWmVybygpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgc21hbGxlckNvZWZmaWNpZW50cyA9IHRoaXMuY29lZmZpY2llbnRzO1xuICAgICAgICAgICAgbGV0IGxhcmdlckNvZWZmaWNpZW50cyA9IG90aGVyLmNvZWZmaWNpZW50cztcbiAgICAgICAgICAgIGlmIChzbWFsbGVyQ29lZmZpY2llbnRzLmxlbmd0aCA+IGxhcmdlckNvZWZmaWNpZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0ZW1wID0gc21hbGxlckNvZWZmaWNpZW50cztcbiAgICAgICAgICAgICAgICBzbWFsbGVyQ29lZmZpY2llbnRzID0gbGFyZ2VyQ29lZmZpY2llbnRzO1xuICAgICAgICAgICAgICAgIGxhcmdlckNvZWZmaWNpZW50cyA9IHRlbXA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgc3VtRGlmZiA9IG5ldyBJbnQzMkFycmF5KGxhcmdlckNvZWZmaWNpZW50cy5sZW5ndGgpO1xuICAgICAgICAgICAgY29uc3QgbGVuZ3RoRGlmZiA9IGxhcmdlckNvZWZmaWNpZW50cy5sZW5ndGggLSBzbWFsbGVyQ29lZmZpY2llbnRzLmxlbmd0aDtcbiAgICAgICAgICAgIC8vIENvcHkgaGlnaC1vcmRlciB0ZXJtcyBvbmx5IGZvdW5kIGluIGhpZ2hlci1kZWdyZWUgcG9seW5vbWlhbCdzIGNvZWZmaWNpZW50c1xuICAgICAgICAgICAgU3lzdGVtLmFycmF5Y29weShsYXJnZXJDb2VmZmljaWVudHMsIDAsIHN1bURpZmYsIDAsIGxlbmd0aERpZmYpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IGxlbmd0aERpZmY7IGkgPCBsYXJnZXJDb2VmZmljaWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBzdW1EaWZmW2ldID0gQWJzdHJhY3RHZW5lcmljR0YuYWRkT3JTdWJ0cmFjdChzbWFsbGVyQ29lZmZpY2llbnRzW2kgLSBsZW5ndGhEaWZmXSwgbGFyZ2VyQ29lZmZpY2llbnRzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgR2VuZXJpY0dGUG9seSh0aGlzLmZpZWxkLCBzdW1EaWZmKTtcbiAgICAgICAgfVxuICAgICAgICBtdWx0aXBseShvdGhlcikge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmZpZWxkLmVxdWFscyhvdGhlci5maWVsZCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCdHZW5lcmljR0ZQb2x5cyBkbyBub3QgaGF2ZSBzYW1lIEdlbmVyaWNHRiBmaWVsZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuaXNaZXJvKCkgfHwgb3RoZXIuaXNaZXJvKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5maWVsZC5nZXRaZXJvKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhQ29lZmZpY2llbnRzID0gdGhpcy5jb2VmZmljaWVudHM7XG4gICAgICAgICAgICBjb25zdCBhTGVuZ3RoID0gYUNvZWZmaWNpZW50cy5sZW5ndGg7XG4gICAgICAgICAgICBjb25zdCBiQ29lZmZpY2llbnRzID0gb3RoZXIuY29lZmZpY2llbnRzO1xuICAgICAgICAgICAgY29uc3QgYkxlbmd0aCA9IGJDb2VmZmljaWVudHMubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgcHJvZHVjdCA9IG5ldyBJbnQzMkFycmF5KGFMZW5ndGggKyBiTGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICBjb25zdCBmaWVsZCA9IHRoaXMuZmllbGQ7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFMZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFDb2VmZiA9IGFDb2VmZmljaWVudHNbaV07XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBiTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvZHVjdFtpICsgal0gPSBBYnN0cmFjdEdlbmVyaWNHRi5hZGRPclN1YnRyYWN0KHByb2R1Y3RbaSArIGpdLCBmaWVsZC5tdWx0aXBseShhQ29lZmYsIGJDb2VmZmljaWVudHNbal0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IEdlbmVyaWNHRlBvbHkoZmllbGQsIHByb2R1Y3QpO1xuICAgICAgICB9XG4gICAgICAgIG11bHRpcGx5U2NhbGFyKHNjYWxhciAvKmludCovKSB7XG4gICAgICAgICAgICBpZiAoc2NhbGFyID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmllbGQuZ2V0WmVybygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNjYWxhciA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMuY29lZmZpY2llbnRzLmxlbmd0aDtcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkID0gdGhpcy5maWVsZDtcbiAgICAgICAgICAgIGNvbnN0IHByb2R1Y3QgPSBuZXcgSW50MzJBcnJheShzaXplKTtcbiAgICAgICAgICAgIGNvbnN0IGNvZWZmaWNpZW50cyA9IHRoaXMuY29lZmZpY2llbnRzO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgICAgICAgICAgICBwcm9kdWN0W2ldID0gZmllbGQubXVsdGlwbHkoY29lZmZpY2llbnRzW2ldLCBzY2FsYXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBHZW5lcmljR0ZQb2x5KGZpZWxkLCBwcm9kdWN0KTtcbiAgICAgICAgfVxuICAgICAgICBtdWx0aXBseUJ5TW9ub21pYWwoZGVncmVlIC8qaW50Ki8sIGNvZWZmaWNpZW50IC8qaW50Ki8pIHtcbiAgICAgICAgICAgIGlmIChkZWdyZWUgPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvZWZmaWNpZW50ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmllbGQuZ2V0WmVybygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY29lZmZpY2llbnRzID0gdGhpcy5jb2VmZmljaWVudHM7XG4gICAgICAgICAgICBjb25zdCBzaXplID0gY29lZmZpY2llbnRzLmxlbmd0aDtcbiAgICAgICAgICAgIGNvbnN0IHByb2R1Y3QgPSBuZXcgSW50MzJBcnJheShzaXplICsgZGVncmVlKTtcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkID0gdGhpcy5maWVsZDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcHJvZHVjdFtpXSA9IGZpZWxkLm11bHRpcGx5KGNvZWZmaWNpZW50c1tpXSwgY29lZmZpY2llbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBHZW5lcmljR0ZQb2x5KGZpZWxkLCBwcm9kdWN0KTtcbiAgICAgICAgfVxuICAgICAgICBkaXZpZGUob3RoZXIpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5maWVsZC5lcXVhbHMob3RoZXIuZmllbGQpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignR2VuZXJpY0dGUG9seXMgZG8gbm90IGhhdmUgc2FtZSBHZW5lcmljR0YgZmllbGQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvdGhlci5pc1plcm8oKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oJ0RpdmlkZSBieSAwJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBmaWVsZCA9IHRoaXMuZmllbGQ7XG4gICAgICAgICAgICBsZXQgcXVvdGllbnQgPSBmaWVsZC5nZXRaZXJvKCk7XG4gICAgICAgICAgICBsZXQgcmVtYWluZGVyID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IGRlbm9taW5hdG9yTGVhZGluZ1Rlcm0gPSBvdGhlci5nZXRDb2VmZmljaWVudChvdGhlci5nZXREZWdyZWUoKSk7XG4gICAgICAgICAgICBjb25zdCBpbnZlcnNlRGVub21pbmF0b3JMZWFkaW5nVGVybSA9IGZpZWxkLmludmVyc2UoZGVub21pbmF0b3JMZWFkaW5nVGVybSk7XG4gICAgICAgICAgICB3aGlsZSAocmVtYWluZGVyLmdldERlZ3JlZSgpID49IG90aGVyLmdldERlZ3JlZSgpICYmICFyZW1haW5kZXIuaXNaZXJvKCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkZWdyZWVEaWZmZXJlbmNlID0gcmVtYWluZGVyLmdldERlZ3JlZSgpIC0gb3RoZXIuZ2V0RGVncmVlKCk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2NhbGUgPSBmaWVsZC5tdWx0aXBseShyZW1haW5kZXIuZ2V0Q29lZmZpY2llbnQocmVtYWluZGVyLmdldERlZ3JlZSgpKSwgaW52ZXJzZURlbm9taW5hdG9yTGVhZGluZ1Rlcm0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRlcm0gPSBvdGhlci5tdWx0aXBseUJ5TW9ub21pYWwoZGVncmVlRGlmZmVyZW5jZSwgc2NhbGUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGl0ZXJhdGlvblF1b3RpZW50ID0gZmllbGQuYnVpbGRNb25vbWlhbChkZWdyZWVEaWZmZXJlbmNlLCBzY2FsZSk7XG4gICAgICAgICAgICAgICAgcXVvdGllbnQgPSBxdW90aWVudC5hZGRPclN1YnRyYWN0KGl0ZXJhdGlvblF1b3RpZW50KTtcbiAgICAgICAgICAgICAgICByZW1haW5kZXIgPSByZW1haW5kZXIuYWRkT3JTdWJ0cmFjdCh0ZXJtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbcXVvdGllbnQsIHJlbWFpbmRlcl07XG4gICAgICAgIH1cbiAgICAgICAgLypAT3ZlcnJpZGUqL1xuICAgICAgICB0b1N0cmluZygpIHtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSAnJztcbiAgICAgICAgICAgIGZvciAobGV0IGRlZ3JlZSA9IHRoaXMuZ2V0RGVncmVlKCk7IGRlZ3JlZSA+PSAwOyBkZWdyZWUtLSkge1xuICAgICAgICAgICAgICAgIGxldCBjb2VmZmljaWVudCA9IHRoaXMuZ2V0Q29lZmZpY2llbnQoZGVncmVlKTtcbiAgICAgICAgICAgICAgICBpZiAoY29lZmZpY2llbnQgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvZWZmaWNpZW50IDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9ICcgLSAnO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29lZmZpY2llbnQgPSAtY29lZmZpY2llbnQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gJyArICc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlZ3JlZSA9PT0gMCB8fCBjb2VmZmljaWVudCAhPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYWxwaGFQb3dlciA9IHRoaXMuZmllbGQubG9nKGNvZWZmaWNpZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhbHBoYVBvd2VyID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9ICcxJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGFscGhhUG93ZXIgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ2EnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9ICdhXic7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IGFscGhhUG93ZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlZ3JlZSAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlZ3JlZSA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSAneCc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ3heJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gZGVncmVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEN1c3RvbSBFcnJvciBjbGFzcyBvZiB0eXBlIEV4Y2VwdGlvbi5cbiAgICAgKi9cbiAgICBjbGFzcyBBcml0aG1ldGljRXhjZXB0aW9uIGV4dGVuZHMgRXhjZXB0aW9uIHtcbiAgICB9XG4gICAgQXJpdGhtZXRpY0V4Y2VwdGlvbi5raW5kID0gJ0FyaXRobWV0aWNFeGNlcHRpb24nO1xuXG4gICAgLypcbiAgICAgKiBDb3B5cmlnaHQgMjAwNyBaWGluZyBhdXRob3JzXG4gICAgICpcbiAgICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgICAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgICAgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgICAgKlxuICAgICAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gICAgICpcbiAgICAgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICAgICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgICAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICAgICAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgICAgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiA8cD5UaGlzIGNsYXNzIGNvbnRhaW5zIHV0aWxpdHkgbWV0aG9kcyBmb3IgcGVyZm9ybWluZyBtYXRoZW1hdGljYWwgb3BlcmF0aW9ucyBvdmVyXG4gICAgICogdGhlIEdhbG9pcyBGaWVsZHMuIE9wZXJhdGlvbnMgdXNlIGEgZ2l2ZW4gcHJpbWl0aXZlIHBvbHlub21pYWwgaW4gY2FsY3VsYXRpb25zLjwvcD5cbiAgICAgKlxuICAgICAqIDxwPlRocm91Z2hvdXQgdGhpcyBwYWNrYWdlLCBlbGVtZW50cyBvZiB0aGUgR0YgYXJlIHJlcHJlc2VudGVkIGFzIGFuIHtAY29kZSBpbnR9XG4gICAgICogZm9yIGNvbnZlbmllbmNlIGFuZCBzcGVlZCAoYnV0IGF0IHRoZSBjb3N0IG9mIG1lbW9yeSkuXG4gICAgICogPC9wPlxuICAgICAqXG4gICAgICogQGF1dGhvciBTZWFuIE93ZW5cbiAgICAgKiBAYXV0aG9yIERhdmlkIE9saXZpZXJcbiAgICAgKi9cbiAgICBjbGFzcyBHZW5lcmljR0YgZXh0ZW5kcyBBYnN0cmFjdEdlbmVyaWNHRiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgYSByZXByZXNlbnRhdGlvbiBvZiBHRihzaXplKSB1c2luZyB0aGUgZ2l2ZW4gcHJpbWl0aXZlIHBvbHlub21pYWwuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBwcmltaXRpdmUgaXJyZWR1Y2libGUgcG9seW5vbWlhbCB3aG9zZSBjb2VmZmljaWVudHMgYXJlIHJlcHJlc2VudGVkIGJ5XG4gICAgICAgICAqICB0aGUgYml0cyBvZiBhbiBpbnQsIHdoZXJlIHRoZSBsZWFzdC1zaWduaWZpY2FudCBiaXQgcmVwcmVzZW50cyB0aGUgY29uc3RhbnRcbiAgICAgICAgICogIGNvZWZmaWNpZW50XG4gICAgICAgICAqIEBwYXJhbSBzaXplIHRoZSBzaXplIG9mIHRoZSBmaWVsZFxuICAgICAgICAgKiBAcGFyYW0gYiB0aGUgZmFjdG9yIGIgaW4gdGhlIGdlbmVyYXRvciBwb2x5bm9taWFsIGNhbiBiZSAwLSBvciAxLWJhc2VkXG4gICAgICAgICAqICAoZyh4KSA9ICh4K2FeYikoeCthXihiKzEpKS4uLih4K2FeKGIrMnQtMSkpKS5cbiAgICAgICAgICogIEluIG1vc3QgY2FzZXMgaXQgc2hvdWxkIGJlIDEsIGJ1dCBmb3IgUVIgY29kZSBpdCBpcyAwLlxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3RydWN0b3IocHJpbWl0aXZlIC8qaW50Ki8sIHNpemUgLyppbnQqLywgZ2VuZXJhdG9yQmFzZSAvKmludCovKSB7XG4gICAgICAgICAgICBzdXBlcigpO1xuICAgICAgICAgICAgdGhpcy5wcmltaXRpdmUgPSBwcmltaXRpdmU7XG4gICAgICAgICAgICB0aGlzLnNpemUgPSBzaXplO1xuICAgICAgICAgICAgdGhpcy5nZW5lcmF0b3JCYXNlID0gZ2VuZXJhdG9yQmFzZTtcbiAgICAgICAgICAgIGNvbnN0IGV4cFRhYmxlID0gbmV3IEludDMyQXJyYXkoc2l6ZSk7XG4gICAgICAgICAgICBsZXQgeCA9IDE7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgICAgICAgICAgICAgIGV4cFRhYmxlW2ldID0geDtcbiAgICAgICAgICAgICAgICB4ICo9IDI7IC8vIHdlJ3JlIGFzc3VtaW5nIHRoZSBnZW5lcmF0b3IgYWxwaGEgaXMgMlxuICAgICAgICAgICAgICAgIGlmICh4ID49IHNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgeCBePSBwcmltaXRpdmU7XG4gICAgICAgICAgICAgICAgICAgIHggJj0gc2l6ZSAtIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5leHBUYWJsZSA9IGV4cFRhYmxlO1xuICAgICAgICAgICAgY29uc3QgbG9nVGFibGUgPSBuZXcgSW50MzJBcnJheShzaXplKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2l6ZSAtIDE7IGkrKykge1xuICAgICAgICAgICAgICAgIGxvZ1RhYmxlW2V4cFRhYmxlW2ldXSA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmxvZ1RhYmxlID0gbG9nVGFibGU7XG4gICAgICAgICAgICAvLyBsb2dUYWJsZVswXSA9PSAwIGJ1dCB0aGlzIHNob3VsZCBuZXZlciBiZSB1c2VkXG4gICAgICAgICAgICB0aGlzLnplcm8gPSBuZXcgR2VuZXJpY0dGUG9seSh0aGlzLCBJbnQzMkFycmF5LmZyb20oWzBdKSk7XG4gICAgICAgICAgICB0aGlzLm9uZSA9IG5ldyBHZW5lcmljR0ZQb2x5KHRoaXMsIEludDMyQXJyYXkuZnJvbShbMV0pKTtcbiAgICAgICAgfVxuICAgICAgICBnZXRaZXJvKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuemVybztcbiAgICAgICAgfVxuICAgICAgICBnZXRPbmUoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vbmU7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gdGhlIG1vbm9taWFsIHJlcHJlc2VudGluZyBjb2VmZmljaWVudCAqIHheZGVncmVlXG4gICAgICAgICAqL1xuICAgICAgICBidWlsZE1vbm9taWFsKGRlZ3JlZSAvKmludCovLCBjb2VmZmljaWVudCAvKmludCovKSB7XG4gICAgICAgICAgICBpZiAoZGVncmVlIDwgMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb2VmZmljaWVudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnplcm87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjb2VmZmljaWVudHMgPSBuZXcgSW50MzJBcnJheShkZWdyZWUgKyAxKTtcbiAgICAgICAgICAgIGNvZWZmaWNpZW50c1swXSA9IGNvZWZmaWNpZW50O1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBHZW5lcmljR0ZQb2x5KHRoaXMsIGNvZWZmaWNpZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gbXVsdGlwbGljYXRpdmUgaW52ZXJzZSBvZiBhXG4gICAgICAgICAqL1xuICAgICAgICBpbnZlcnNlKGEgLyppbnQqLykge1xuICAgICAgICAgICAgaWYgKGEgPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJpdGhtZXRpY0V4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXhwVGFibGVbdGhpcy5zaXplIC0gdGhpcy5sb2dUYWJsZVthXSAtIDFdO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHByb2R1Y3Qgb2YgYSBhbmQgYiBpbiBHRihzaXplKVxuICAgICAgICAgKi9cbiAgICAgICAgbXVsdGlwbHkoYSAvKmludCovLCBiIC8qaW50Ki8pIHtcbiAgICAgICAgICAgIGlmIChhID09PSAwIHx8IGIgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmV4cFRhYmxlWyh0aGlzLmxvZ1RhYmxlW2FdICsgdGhpcy5sb2dUYWJsZVtiXSkgJSAodGhpcy5zaXplIC0gMSldO1xuICAgICAgICB9XG4gICAgICAgIGdldFNpemUoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zaXplO1xuICAgICAgICB9XG4gICAgICAgIGdldEdlbmVyYXRvckJhc2UoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZW5lcmF0b3JCYXNlO1xuICAgICAgICB9XG4gICAgICAgIC8qQE92ZXJyaWRlKi9cbiAgICAgICAgdG9TdHJpbmcoKSB7XG4gICAgICAgICAgICByZXR1cm4gKCdHRigweCcgKyBJbnRlZ2VyLnRvSGV4U3RyaW5nKHRoaXMucHJpbWl0aXZlKSArICcsJyArIHRoaXMuc2l6ZSArICcpJyk7XG4gICAgICAgIH1cbiAgICAgICAgZXF1YWxzKG8pIHtcbiAgICAgICAgICAgIHJldHVybiBvID09PSB0aGlzO1xuICAgICAgICB9XG4gICAgfVxuICAgIEdlbmVyaWNHRi5BWlRFQ19EQVRBXzEyID0gbmV3IEdlbmVyaWNHRigweDEwNjksIDQwOTYsIDEpOyAvLyB4XjEyICsgeF42ICsgeF41ICsgeF4zICsgMVxuICAgIEdlbmVyaWNHRi5BWlRFQ19EQVRBXzEwID0gbmV3IEdlbmVyaWNHRigweDQwOSwgMTAyNCwgMSk7IC8vIHheMTAgKyB4XjMgKyAxXG4gICAgR2VuZXJpY0dGLkFaVEVDX0RBVEFfNiA9IG5ldyBHZW5lcmljR0YoMHg0MywgNjQsIDEpOyAvLyB4XjYgKyB4ICsgMVxuICAgIEdlbmVyaWNHRi5BWlRFQ19QQVJBTSA9IG5ldyBHZW5lcmljR0YoMHgxMywgMTYsIDEpOyAvLyB4XjQgKyB4ICsgMVxuICAgIEdlbmVyaWNHRi5RUl9DT0RFX0ZJRUxEXzI1NiA9IG5ldyBHZW5lcmljR0YoMHgwMTFkLCAyNTYsIDApOyAvLyB4XjggKyB4XjQgKyB4XjMgKyB4XjIgKyAxXG4gICAgR2VuZXJpY0dGLkRBVEFfTUFUUklYX0ZJRUxEXzI1NiA9IG5ldyBHZW5lcmljR0YoMHgwMTJkLCAyNTYsIDEpOyAvLyB4XjggKyB4XjUgKyB4XjMgKyB4XjIgKyAxXG4gICAgR2VuZXJpY0dGLkFaVEVDX0RBVEFfOCA9IEdlbmVyaWNHRi5EQVRBX01BVFJJWF9GSUVMRF8yNTY7XG4gICAgR2VuZXJpY0dGLk1BWElDT0RFX0ZJRUxEXzY0ID0gR2VuZXJpY0dGLkFaVEVDX0RBVEFfNjtcblxuICAgIC8qKlxuICAgICAqIEN1c3RvbSBFcnJvciBjbGFzcyBvZiB0eXBlIEV4Y2VwdGlvbi5cbiAgICAgKi9cbiAgICBjbGFzcyBSZWVkU29sb21vbkV4Y2VwdGlvbiBleHRlbmRzIEV4Y2VwdGlvbiB7XG4gICAgfVxuICAgIFJlZWRTb2xvbW9uRXhjZXB0aW9uLmtpbmQgPSAnUmVlZFNvbG9tb25FeGNlcHRpb24nO1xuXG4gICAgLyoqXG4gICAgICogQ3VzdG9tIEVycm9yIGNsYXNzIG9mIHR5cGUgRXhjZXB0aW9uLlxuICAgICAqL1xuICAgIGNsYXNzIElsbGVnYWxTdGF0ZUV4Y2VwdGlvbiBleHRlbmRzIEV4Y2VwdGlvbiB7XG4gICAgfVxuICAgIElsbGVnYWxTdGF0ZUV4Y2VwdGlvbi5raW5kID0gJ0lsbGVnYWxTdGF0ZUV4Y2VwdGlvbic7XG5cbiAgICAvKlxuICAgICAqIENvcHlyaWdodCAyMDA3IFpYaW5nIGF1dGhvcnNcbiAgICAgKlxuICAgICAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gICAgICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgICAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgICAqXG4gICAgICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAgICAgKlxuICAgICAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgICAgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICAgICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gICAgICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICAgICAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIDxwPkltcGxlbWVudHMgUmVlZC1Tb2xvbW9uIGRlY29kaW5nLCBhcyB0aGUgbmFtZSBpbXBsaWVzLjwvcD5cbiAgICAgKlxuICAgICAqIDxwPlRoZSBhbGdvcml0aG0gd2lsbCBub3QgYmUgZXhwbGFpbmVkIGhlcmUsIGJ1dCB0aGUgZm9sbG93aW5nIHJlZmVyZW5jZXMgd2VyZSBoZWxwZnVsXG4gICAgICogaW4gY3JlYXRpbmcgdGhpcyBpbXBsZW1lbnRhdGlvbjo8L3A+XG4gICAgICpcbiAgICAgKiA8dWw+XG4gICAgICogPGxpPkJydWNlIE1hZ2dzLlxuICAgICAqIDxhIGhyZWY9XCJodHRwOi8vd3d3LmNzLmNtdS5lZHUvYWZzL2NzLmNtdS5lZHUvcHJvamVjdC9wc2NpY28tZ3V5Yi9yZWFsd29ybGQvd3d3L3JzX2RlY29kZS5wc1wiPlxuICAgICAqIFwiRGVjb2RpbmcgUmVlZC1Tb2xvbW9uIENvZGVzXCI8L2E+IChzZWUgZGlzY3Vzc2lvbiBvZiBGb3JuZXkncyBGb3JtdWxhKTwvbGk+XG4gICAgICogPGxpPkouSS4gSGFsbC4gPGEgaHJlZj1cInd3dy5tdGgubXN1LmVkdS9+amhhbGwvY2xhc3Nlcy9jb2Rlbm90ZXMvR1JTLnBkZlwiPlxuICAgICAqIFwiQ2hhcHRlciA1LiBHZW5lcmFsaXplZCBSZWVkLVNvbG9tb24gQ29kZXNcIjwvYT5cbiAgICAgKiAoc2VlIGRpc2N1c3Npb24gb2YgRXVjbGlkZWFuIGFsZ29yaXRobSk8L2xpPlxuICAgICAqIDwvdWw+XG4gICAgICpcbiAgICAgKiA8cD5NdWNoIGNyZWRpdCBpcyBkdWUgdG8gV2lsbGlhbSBSdWNrbGlkZ2Ugc2luY2UgcG9ydGlvbnMgb2YgdGhpcyBjb2RlIGFyZSBhbiBpbmRpcmVjdFxuICAgICAqIHBvcnQgb2YgaGlzIEMrKyBSZWVkLVNvbG9tb24gaW1wbGVtZW50YXRpb24uPC9wPlxuICAgICAqXG4gICAgICogQGF1dGhvciBTZWFuIE93ZW5cbiAgICAgKiBAYXV0aG9yIFdpbGxpYW0gUnVja2xpZGdlXG4gICAgICogQGF1dGhvciBzYW5mb3Jkc3F1aXJlc1xuICAgICAqL1xuICAgIGNsYXNzIFJlZWRTb2xvbW9uRGVjb2RlciB7XG4gICAgICAgIGNvbnN0cnVjdG9yKGZpZWxkKSB7XG4gICAgICAgICAgICB0aGlzLmZpZWxkID0gZmllbGQ7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIDxwPkRlY29kZXMgZ2l2ZW4gc2V0IG9mIHJlY2VpdmVkIGNvZGV3b3Jkcywgd2hpY2ggaW5jbHVkZSBib3RoIGRhdGEgYW5kIGVycm9yLWNvcnJlY3Rpb25cbiAgICAgICAgICogY29kZXdvcmRzLiBSZWFsbHksIHRoaXMgbWVhbnMgaXQgdXNlcyBSZWVkLVNvbG9tb24gdG8gZGV0ZWN0IGFuZCBjb3JyZWN0IGVycm9ycywgaW4tcGxhY2UsXG4gICAgICAgICAqIGluIHRoZSBpbnB1dC48L3A+XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSByZWNlaXZlZCBkYXRhIGFuZCBlcnJvci1jb3JyZWN0aW9uIGNvZGV3b3Jkc1xuICAgICAgICAgKiBAcGFyYW0gdHdvUyBudW1iZXIgb2YgZXJyb3ItY29ycmVjdGlvbiBjb2Rld29yZHMgYXZhaWxhYmxlXG4gICAgICAgICAqIEB0aHJvd3MgUmVlZFNvbG9tb25FeGNlcHRpb24gaWYgZGVjb2RpbmcgZmFpbHMgZm9yIGFueSByZWFzb25cbiAgICAgICAgICovXG4gICAgICAgIGRlY29kZShyZWNlaXZlZCwgdHdvUyAvKmludCovKSB7XG4gICAgICAgICAgICBjb25zdCBmaWVsZCA9IHRoaXMuZmllbGQ7XG4gICAgICAgICAgICBjb25zdCBwb2x5ID0gbmV3IEdlbmVyaWNHRlBvbHkoZmllbGQsIHJlY2VpdmVkKTtcbiAgICAgICAgICAgIGNvbnN0IHN5bmRyb21lQ29lZmZpY2llbnRzID0gbmV3IEludDMyQXJyYXkodHdvUyk7XG4gICAgICAgICAgICBsZXQgbm9FcnJvciA9IHRydWU7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHR3b1M7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGV2YWxSZXN1bHQgPSBwb2x5LmV2YWx1YXRlQXQoZmllbGQuZXhwKGkgKyBmaWVsZC5nZXRHZW5lcmF0b3JCYXNlKCkpKTtcbiAgICAgICAgICAgICAgICBzeW5kcm9tZUNvZWZmaWNpZW50c1tzeW5kcm9tZUNvZWZmaWNpZW50cy5sZW5ndGggLSAxIC0gaV0gPSBldmFsUmVzdWx0O1xuICAgICAgICAgICAgICAgIGlmIChldmFsUmVzdWx0ICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vRXJyb3IgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm9FcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHN5bmRyb21lID0gbmV3IEdlbmVyaWNHRlBvbHkoZmllbGQsIHN5bmRyb21lQ29lZmZpY2llbnRzKTtcbiAgICAgICAgICAgIGNvbnN0IHNpZ21hT21lZ2EgPSB0aGlzLnJ1bkV1Y2xpZGVhbkFsZ29yaXRobShmaWVsZC5idWlsZE1vbm9taWFsKHR3b1MsIDEpLCBzeW5kcm9tZSwgdHdvUyk7XG4gICAgICAgICAgICBjb25zdCBzaWdtYSA9IHNpZ21hT21lZ2FbMF07XG4gICAgICAgICAgICBjb25zdCBvbWVnYSA9IHNpZ21hT21lZ2FbMV07XG4gICAgICAgICAgICBjb25zdCBlcnJvckxvY2F0aW9ucyA9IHRoaXMuZmluZEVycm9yTG9jYXRpb25zKHNpZ21hKTtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yTWFnbml0dWRlcyA9IHRoaXMuZmluZEVycm9yTWFnbml0dWRlcyhvbWVnYSwgZXJyb3JMb2NhdGlvbnMpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlcnJvckxvY2F0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBvc2l0aW9uID0gcmVjZWl2ZWQubGVuZ3RoIC0gMSAtIGZpZWxkLmxvZyhlcnJvckxvY2F0aW9uc1tpXSk7XG4gICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVlZFNvbG9tb25FeGNlcHRpb24oJ0JhZCBlcnJvciBsb2NhdGlvbicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZWNlaXZlZFtwb3NpdGlvbl0gPSBHZW5lcmljR0YuYWRkT3JTdWJ0cmFjdChyZWNlaXZlZFtwb3NpdGlvbl0sIGVycm9yTWFnbml0dWRlc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcnVuRXVjbGlkZWFuQWxnb3JpdGhtKGEsIGIsIFIgLyppbnQqLykge1xuICAgICAgICAgICAgLy8gQXNzdW1lIGEncyBkZWdyZWUgaXMgPj0gYidzXG4gICAgICAgICAgICBpZiAoYS5nZXREZWdyZWUoKSA8IGIuZ2V0RGVncmVlKCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0ZW1wID0gYTtcbiAgICAgICAgICAgICAgICBhID0gYjtcbiAgICAgICAgICAgICAgICBiID0gdGVtcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGZpZWxkID0gdGhpcy5maWVsZDtcbiAgICAgICAgICAgIGxldCByTGFzdCA9IGE7XG4gICAgICAgICAgICBsZXQgciA9IGI7XG4gICAgICAgICAgICBsZXQgdExhc3QgPSBmaWVsZC5nZXRaZXJvKCk7XG4gICAgICAgICAgICBsZXQgdCA9IGZpZWxkLmdldE9uZSgpO1xuICAgICAgICAgICAgLy8gUnVuIEV1Y2xpZGVhbiBhbGdvcml0aG0gdW50aWwgcidzIGRlZ3JlZSBpcyBsZXNzIHRoYW4gUi8yXG4gICAgICAgICAgICB3aGlsZSAoci5nZXREZWdyZWUoKSA+PSAoUiAvIDIgfCAwKSkge1xuICAgICAgICAgICAgICAgIGxldCByTGFzdExhc3QgPSByTGFzdDtcbiAgICAgICAgICAgICAgICBsZXQgdExhc3RMYXN0ID0gdExhc3Q7XG4gICAgICAgICAgICAgICAgckxhc3QgPSByO1xuICAgICAgICAgICAgICAgIHRMYXN0ID0gdDtcbiAgICAgICAgICAgICAgICAvLyBEaXZpZGUgckxhc3RMYXN0IGJ5IHJMYXN0LCB3aXRoIHF1b3RpZW50IGluIHEgYW5kIHJlbWFpbmRlciBpbiByXG4gICAgICAgICAgICAgICAgaWYgKHJMYXN0LmlzWmVybygpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE9vcHMsIEV1Y2xpZGVhbiBhbGdvcml0aG0gYWxyZWFkeSB0ZXJtaW5hdGVkP1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVlZFNvbG9tb25FeGNlcHRpb24oJ3Jfe2ktMX0gd2FzIHplcm8nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgciA9IHJMYXN0TGFzdDtcbiAgICAgICAgICAgICAgICBsZXQgcSA9IGZpZWxkLmdldFplcm8oKTtcbiAgICAgICAgICAgICAgICBjb25zdCBkZW5vbWluYXRvckxlYWRpbmdUZXJtID0gckxhc3QuZ2V0Q29lZmZpY2llbnQockxhc3QuZ2V0RGVncmVlKCkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRsdEludmVyc2UgPSBmaWVsZC5pbnZlcnNlKGRlbm9taW5hdG9yTGVhZGluZ1Rlcm0pO1xuICAgICAgICAgICAgICAgIHdoaWxlIChyLmdldERlZ3JlZSgpID49IHJMYXN0LmdldERlZ3JlZSgpICYmICFyLmlzWmVybygpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlZ3JlZURpZmYgPSByLmdldERlZ3JlZSgpIC0gckxhc3QuZ2V0RGVncmVlKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNjYWxlID0gZmllbGQubXVsdGlwbHkoci5nZXRDb2VmZmljaWVudChyLmdldERlZ3JlZSgpKSwgZGx0SW52ZXJzZSk7XG4gICAgICAgICAgICAgICAgICAgIHEgPSBxLmFkZE9yU3VidHJhY3QoZmllbGQuYnVpbGRNb25vbWlhbChkZWdyZWVEaWZmLCBzY2FsZSkpO1xuICAgICAgICAgICAgICAgICAgICByID0gci5hZGRPclN1YnRyYWN0KHJMYXN0Lm11bHRpcGx5QnlNb25vbWlhbChkZWdyZWVEaWZmLCBzY2FsZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0ID0gcS5tdWx0aXBseSh0TGFzdCkuYWRkT3JTdWJ0cmFjdCh0TGFzdExhc3QpO1xuICAgICAgICAgICAgICAgIGlmIChyLmdldERlZ3JlZSgpID49IHJMYXN0LmdldERlZ3JlZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsU3RhdGVFeGNlcHRpb24oJ0RpdmlzaW9uIGFsZ29yaXRobSBmYWlsZWQgdG8gcmVkdWNlIHBvbHlub21pYWw/Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc2lnbWFUaWxkZUF0WmVybyA9IHQuZ2V0Q29lZmZpY2llbnQoMCk7XG4gICAgICAgICAgICBpZiAoc2lnbWFUaWxkZUF0WmVybyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZWVkU29sb21vbkV4Y2VwdGlvbignc2lnbWFUaWxkZSgwKSB3YXMgemVybycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaW52ZXJzZSA9IGZpZWxkLmludmVyc2Uoc2lnbWFUaWxkZUF0WmVybyk7XG4gICAgICAgICAgICBjb25zdCBzaWdtYSA9IHQubXVsdGlwbHlTY2FsYXIoaW52ZXJzZSk7XG4gICAgICAgICAgICBjb25zdCBvbWVnYSA9IHIubXVsdGlwbHlTY2FsYXIoaW52ZXJzZSk7XG4gICAgICAgICAgICByZXR1cm4gW3NpZ21hLCBvbWVnYV07XG4gICAgICAgIH1cbiAgICAgICAgZmluZEVycm9yTG9jYXRpb25zKGVycm9yTG9jYXRvcikge1xuICAgICAgICAgICAgLy8gVGhpcyBpcyBhIGRpcmVjdCBhcHBsaWNhdGlvbiBvZiBDaGllbidzIHNlYXJjaFxuICAgICAgICAgICAgY29uc3QgbnVtRXJyb3JzID0gZXJyb3JMb2NhdG9yLmdldERlZ3JlZSgpO1xuICAgICAgICAgICAgaWYgKG51bUVycm9ycyA9PT0gMSkgeyAvLyBzaG9ydGN1dFxuICAgICAgICAgICAgICAgIHJldHVybiBJbnQzMkFycmF5LmZyb20oW2Vycm9yTG9jYXRvci5nZXRDb2VmZmljaWVudCgxKV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IEludDMyQXJyYXkobnVtRXJyb3JzKTtcbiAgICAgICAgICAgIGxldCBlID0gMDtcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkID0gdGhpcy5maWVsZDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgZmllbGQuZ2V0U2l6ZSgpICYmIGUgPCBudW1FcnJvcnM7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChlcnJvckxvY2F0b3IuZXZhbHVhdGVBdChpKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRbZV0gPSBmaWVsZC5pbnZlcnNlKGkpO1xuICAgICAgICAgICAgICAgICAgICBlKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGUgIT09IG51bUVycm9ycykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZWVkU29sb21vbkV4Y2VwdGlvbignRXJyb3IgbG9jYXRvciBkZWdyZWUgZG9lcyBub3QgbWF0Y2ggbnVtYmVyIG9mIHJvb3RzJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGZpbmRFcnJvck1hZ25pdHVkZXMoZXJyb3JFdmFsdWF0b3IsIGVycm9yTG9jYXRpb25zKSB7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIGRpcmVjdGx5IGFwcGx5aW5nIEZvcm5leSdzIEZvcm11bGFcbiAgICAgICAgICAgIGNvbnN0IHMgPSBlcnJvckxvY2F0aW9ucy5sZW5ndGg7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgSW50MzJBcnJheShzKTtcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkID0gdGhpcy5maWVsZDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeGlJbnZlcnNlID0gZmllbGQuaW52ZXJzZShlcnJvckxvY2F0aW9uc1tpXSk7XG4gICAgICAgICAgICAgICAgbGV0IGRlbm9taW5hdG9yID0gMTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHM7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSAhPT0gaikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGVub21pbmF0b3IgPSBmaWVsZC5tdWx0aXBseShkZW5vbWluYXRvcixcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgIEdlbmVyaWNHRi5hZGRPclN1YnRyYWN0KDEsIGZpZWxkLm11bHRpcGx5KGVycm9yTG9jYXRpb25zW2pdLCB4aUludmVyc2UpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFib3ZlIHNob3VsZCB3b3JrIGJ1dCBmYWlscyBvbiBzb21lIEFwcGxlIGFuZCBMaW51eCBKREtzIGR1ZSB0byBhIEhvdHNwb3QgYnVnLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQmVsb3cgaXMgYSBmdW5ueS1sb29raW5nIHdvcmthcm91bmQgZnJvbSBTdGV2ZW4gUGFya2VzXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZXJtID0gZmllbGQubXVsdGlwbHkoZXJyb3JMb2NhdGlvbnNbal0sIHhpSW52ZXJzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZXJtUGx1czEgPSAodGVybSAmIDB4MSkgPT09IDAgPyB0ZXJtIHwgMSA6IHRlcm0gJiB+MTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbm9taW5hdG9yID0gZmllbGQubXVsdGlwbHkoZGVub21pbmF0b3IsIHRlcm1QbHVzMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0W2ldID0gZmllbGQubXVsdGlwbHkoZXJyb3JFdmFsdWF0b3IuZXZhbHVhdGVBdCh4aUludmVyc2UpLCBmaWVsZC5pbnZlcnNlKGRlbm9taW5hdG9yKSk7XG4gICAgICAgICAgICAgICAgaWYgKGZpZWxkLmdldEdlbmVyYXRvckJhc2UoKSAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRbaV0gPSBmaWVsZC5tdWx0aXBseShyZXN1bHRbaV0sIHhpSW52ZXJzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qXG4gICAgICogQ29weXJpZ2h0IDIwMTAgWlhpbmcgYXV0aG9yc1xuICAgICAqXG4gICAgICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgICAgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICAgICpcbiAgICAgKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICAgICAqXG4gICAgICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICAgICAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgICAgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgICAgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gICAgICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gICAgICovXG4gICAgLy8gaW1wb3J0IGphdmEudXRpbC5BcnJheXM7XG4gICAgdmFyIFRhYmxlO1xuICAgIChmdW5jdGlvbiAoVGFibGUpIHtcbiAgICAgICAgVGFibGVbVGFibGVbXCJVUFBFUlwiXSA9IDBdID0gXCJVUFBFUlwiO1xuICAgICAgICBUYWJsZVtUYWJsZVtcIkxPV0VSXCJdID0gMV0gPSBcIkxPV0VSXCI7XG4gICAgICAgIFRhYmxlW1RhYmxlW1wiTUlYRURcIl0gPSAyXSA9IFwiTUlYRURcIjtcbiAgICAgICAgVGFibGVbVGFibGVbXCJESUdJVFwiXSA9IDNdID0gXCJESUdJVFwiO1xuICAgICAgICBUYWJsZVtUYWJsZVtcIlBVTkNUXCJdID0gNF0gPSBcIlBVTkNUXCI7XG4gICAgICAgIFRhYmxlW1RhYmxlW1wiQklOQVJZXCJdID0gNV0gPSBcIkJJTkFSWVwiO1xuICAgIH0pKFRhYmxlIHx8IChUYWJsZSA9IHt9KSk7XG4gICAgLyoqXG4gICAgICogPHA+VGhlIG1haW4gY2xhc3Mgd2hpY2ggaW1wbGVtZW50cyBBenRlYyBDb2RlIGRlY29kaW5nIC0tIGFzIG9wcG9zZWQgdG8gbG9jYXRpbmcgYW5kIGV4dHJhY3RpbmdcbiAgICAgKiB0aGUgQXp0ZWMgQ29kZSBmcm9tIGFuIGltYWdlLjwvcD5cbiAgICAgKlxuICAgICAqIEBhdXRob3IgRGF2aWQgT2xpdmllclxuICAgICAqL1xuICAgIGNsYXNzIERlY29kZXIge1xuICAgICAgICBkZWNvZGUoZGV0ZWN0b3JSZXN1bHQpIHtcbiAgICAgICAgICAgIHRoaXMuZGRhdGEgPSBkZXRlY3RvclJlc3VsdDtcbiAgICAgICAgICAgIGxldCBtYXRyaXggPSBkZXRlY3RvclJlc3VsdC5nZXRCaXRzKCk7XG4gICAgICAgICAgICBsZXQgcmF3Yml0cyA9IHRoaXMuZXh0cmFjdEJpdHMobWF0cml4KTtcbiAgICAgICAgICAgIGxldCBjb3JyZWN0ZWRCaXRzID0gdGhpcy5jb3JyZWN0Qml0cyhyYXdiaXRzKTtcbiAgICAgICAgICAgIGxldCByYXdCeXRlcyA9IERlY29kZXIuY29udmVydEJvb2xBcnJheVRvQnl0ZUFycmF5KGNvcnJlY3RlZEJpdHMpO1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IERlY29kZXIuZ2V0RW5jb2RlZERhdGEoY29ycmVjdGVkQml0cyk7XG4gICAgICAgICAgICBsZXQgZGVjb2RlclJlc3VsdCA9IG5ldyBEZWNvZGVyUmVzdWx0KHJhd0J5dGVzLCByZXN1bHQsIG51bGwsIG51bGwpO1xuICAgICAgICAgICAgZGVjb2RlclJlc3VsdC5zZXROdW1CaXRzKGNvcnJlY3RlZEJpdHMubGVuZ3RoKTtcbiAgICAgICAgICAgIHJldHVybiBkZWNvZGVyUmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoaXMgbWV0aG9kIGlzIHVzZWQgZm9yIHRlc3RpbmcgdGhlIGhpZ2gtbGV2ZWwgZW5jb2RlclxuICAgICAgICBzdGF0aWMgaGlnaExldmVsRGVjb2RlKGNvcnJlY3RlZEJpdHMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEVuY29kZWREYXRhKGNvcnJlY3RlZEJpdHMpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIHRoZSBzdHJpbmcgZW5jb2RlZCBpbiB0aGUgYXp0ZWMgY29kZSBiaXRzXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4gdGhlIGRlY29kZWQgc3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgZ2V0RW5jb2RlZERhdGEoY29ycmVjdGVkQml0cykge1xuICAgICAgICAgICAgbGV0IGVuZEluZGV4ID0gY29ycmVjdGVkQml0cy5sZW5ndGg7XG4gICAgICAgICAgICBsZXQgbGF0Y2hUYWJsZSA9IFRhYmxlLlVQUEVSOyAvLyB0YWJsZSBtb3N0IHJlY2VudGx5IGxhdGNoZWQgdG9cbiAgICAgICAgICAgIGxldCBzaGlmdFRhYmxlID0gVGFibGUuVVBQRVI7IC8vIHRhYmxlIHRvIHVzZSBmb3IgdGhlIG5leHQgcmVhZFxuICAgICAgICAgICAgbGV0IHJlc3VsdCA9ICcnO1xuICAgICAgICAgICAgbGV0IGluZGV4ID0gMDtcbiAgICAgICAgICAgIHdoaWxlIChpbmRleCA8IGVuZEluZGV4KSB7XG4gICAgICAgICAgICAgICAgaWYgKHNoaWZ0VGFibGUgPT09IFRhYmxlLkJJTkFSWSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZW5kSW5kZXggLSBpbmRleCA8IDUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxldCBsZW5ndGggPSBEZWNvZGVyLnJlYWRDb2RlKGNvcnJlY3RlZEJpdHMsIGluZGV4LCA1KTtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggKz0gNTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVuZEluZGV4IC0gaW5kZXggPCAxMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID0gRGVjb2Rlci5yZWFkQ29kZShjb3JyZWN0ZWRCaXRzLCBpbmRleCwgMTEpICsgMzE7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleCArPSAxMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBjaGFyQ291bnQgPSAwOyBjaGFyQ291bnQgPCBsZW5ndGg7IGNoYXJDb3VudCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZW5kSW5kZXggLSBpbmRleCA8IDgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGVuZEluZGV4OyAvLyBGb3JjZSBvdXRlciBsb29wIHRvIGV4aXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvZGUgPSBEZWNvZGVyLnJlYWRDb2RlKGNvcnJlY3RlZEJpdHMsIGluZGV4LCA4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSAvKihjaGFyKSovIFN0cmluZ1V0aWxzLmNhc3RBc05vblV0ZjhDaGFyKGNvZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggKz0gODtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBHbyBiYWNrIHRvIHdoYXRldmVyIG1vZGUgd2UgaGFkIGJlZW4gaW5cbiAgICAgICAgICAgICAgICAgICAgc2hpZnRUYWJsZSA9IGxhdGNoVGFibGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsZXQgc2l6ZSA9IHNoaWZ0VGFibGUgPT09IFRhYmxlLkRJR0lUID8gNCA6IDU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbmRJbmRleCAtIGluZGV4IDwgc2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGV0IGNvZGUgPSBEZWNvZGVyLnJlYWRDb2RlKGNvcnJlY3RlZEJpdHMsIGluZGV4LCBzaXplKTtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggKz0gc2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHN0ciA9IERlY29kZXIuZ2V0Q2hhcmFjdGVyKHNoaWZ0VGFibGUsIGNvZGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RyLnN0YXJ0c1dpdGgoJ0NUUkxfJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRhYmxlIGNoYW5nZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElTTy9JRUMgMjQ3Nzg6MjAwOCBwcmVzY3JpYmVzIGVuZGluZyBhIHNoaWZ0IHNlcXVlbmNlIGluIHRoZSBtb2RlIGZyb20gd2hpY2ggaXQgd2FzIGludm9rZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGF0J3MgaW5jbHVkaW5nIHdoZW4gdGhhdCBtb2RlIGlzIGEgc2hpZnQuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBPdXIgdGVzdCBjYXNlIGRsdXNicy5wbmcgZm9yIGlzc3VlICM2NDIgZXhlcmNpc2VzIHRoYXQuXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXRjaFRhYmxlID0gc2hpZnRUYWJsZTsgLy8gTGF0Y2ggdGhlIGN1cnJlbnQgbW9kZSwgc28gYXMgdG8gcmV0dXJuIHRvIFVwcGVyIGFmdGVyIFUvUyBCL1NcbiAgICAgICAgICAgICAgICAgICAgICAgIHNoaWZ0VGFibGUgPSBEZWNvZGVyLmdldFRhYmxlKHN0ci5jaGFyQXQoNSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0ci5jaGFyQXQoNikgPT09ICdMJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhdGNoVGFibGUgPSBzaGlmdFRhYmxlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IHN0cjtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdvIGJhY2sgdG8gd2hhdGV2ZXIgbW9kZSB3ZSBoYWQgYmVlbiBpblxuICAgICAgICAgICAgICAgICAgICAgICAgc2hpZnRUYWJsZSA9IGxhdGNoVGFibGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBnZXRzIHRoZSB0YWJsZSBjb3JyZXNwb25kaW5nIHRvIHRoZSBjaGFyIHBhc3NlZFxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGdldFRhYmxlKHQpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodCkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ0wnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gVGFibGUuTE9XRVI7XG4gICAgICAgICAgICAgICAgY2FzZSAnUCc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBUYWJsZS5QVU5DVDtcbiAgICAgICAgICAgICAgICBjYXNlICdNJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFRhYmxlLk1JWEVEO1xuICAgICAgICAgICAgICAgIGNhc2UgJ0QnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gVGFibGUuRElHSVQ7XG4gICAgICAgICAgICAgICAgY2FzZSAnQic6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBUYWJsZS5CSU5BUlk7XG4gICAgICAgICAgICAgICAgY2FzZSAnVSc6XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFRhYmxlLlVQUEVSO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIHRoZSBjaGFyYWN0ZXIgKG9yIHN0cmluZykgY29ycmVzcG9uZGluZyB0byB0aGUgcGFzc2VkIGNvZGUgaW4gdGhlIGdpdmVuIHRhYmxlXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB0YWJsZSB0aGUgdGFibGUgdXNlZFxuICAgICAgICAgKiBAcGFyYW0gY29kZSB0aGUgY29kZSBvZiB0aGUgY2hhcmFjdGVyXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgZ2V0Q2hhcmFjdGVyKHRhYmxlLCBjb2RlKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhYmxlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBUYWJsZS5VUFBFUjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIERlY29kZXIuVVBQRVJfVEFCTEVbY29kZV07XG4gICAgICAgICAgICAgICAgY2FzZSBUYWJsZS5MT1dFUjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIERlY29kZXIuTE9XRVJfVEFCTEVbY29kZV07XG4gICAgICAgICAgICAgICAgY2FzZSBUYWJsZS5NSVhFRDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIERlY29kZXIuTUlYRURfVEFCTEVbY29kZV07XG4gICAgICAgICAgICAgICAgY2FzZSBUYWJsZS5QVU5DVDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIERlY29kZXIuUFVOQ1RfVEFCTEVbY29kZV07XG4gICAgICAgICAgICAgICAgY2FzZSBUYWJsZS5ESUdJVDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIERlY29kZXIuRElHSVRfVEFCTEVbY29kZV07XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgLy8gU2hvdWxkIG5vdCByZWFjaCBoZXJlLlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbFN0YXRlRXhjZXB0aW9uKCdCYWQgdGFibGUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogPHA+UGVyZm9ybXMgUlMgZXJyb3IgY29ycmVjdGlvbiBvbiBhbiBhcnJheSBvZiBiaXRzLjwvcD5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB0aGUgY29ycmVjdGVkIGFycmF5XG4gICAgICAgICAqIEB0aHJvd3MgRm9ybWF0RXhjZXB0aW9uIGlmIHRoZSBpbnB1dCBjb250YWlucyB0b28gbWFueSBlcnJvcnNcbiAgICAgICAgICovXG4gICAgICAgIGNvcnJlY3RCaXRzKHJhd2JpdHMpIHtcbiAgICAgICAgICAgIGxldCBnZjtcbiAgICAgICAgICAgIGxldCBjb2Rld29yZFNpemU7XG4gICAgICAgICAgICBpZiAodGhpcy5kZGF0YS5nZXROYkxheWVycygpIDw9IDIpIHtcbiAgICAgICAgICAgICAgICBjb2Rld29yZFNpemUgPSA2O1xuICAgICAgICAgICAgICAgIGdmID0gR2VuZXJpY0dGLkFaVEVDX0RBVEFfNjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuZGRhdGEuZ2V0TmJMYXllcnMoKSA8PSA4KSB7XG4gICAgICAgICAgICAgICAgY29kZXdvcmRTaXplID0gODtcbiAgICAgICAgICAgICAgICBnZiA9IEdlbmVyaWNHRi5BWlRFQ19EQVRBXzg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLmRkYXRhLmdldE5iTGF5ZXJzKCkgPD0gMjIpIHtcbiAgICAgICAgICAgICAgICBjb2Rld29yZFNpemUgPSAxMDtcbiAgICAgICAgICAgICAgICBnZiA9IEdlbmVyaWNHRi5BWlRFQ19EQVRBXzEwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29kZXdvcmRTaXplID0gMTI7XG4gICAgICAgICAgICAgICAgZ2YgPSBHZW5lcmljR0YuQVpURUNfREFUQV8xMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBudW1EYXRhQ29kZXdvcmRzID0gdGhpcy5kZGF0YS5nZXROYkRhdGFibG9ja3MoKTtcbiAgICAgICAgICAgIGxldCBudW1Db2Rld29yZHMgPSByYXdiaXRzLmxlbmd0aCAvIGNvZGV3b3JkU2l6ZTtcbiAgICAgICAgICAgIGlmIChudW1Db2Rld29yZHMgPCBudW1EYXRhQ29kZXdvcmRzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IG9mZnNldCA9IHJhd2JpdHMubGVuZ3RoICUgY29kZXdvcmRTaXplO1xuICAgICAgICAgICAgbGV0IGRhdGFXb3JkcyA9IG5ldyBJbnQzMkFycmF5KG51bUNvZGV3b3Jkcyk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUNvZGV3b3JkczsgaSsrLCBvZmZzZXQgKz0gY29kZXdvcmRTaXplKSB7XG4gICAgICAgICAgICAgICAgZGF0YVdvcmRzW2ldID0gRGVjb2Rlci5yZWFkQ29kZShyYXdiaXRzLCBvZmZzZXQsIGNvZGV3b3JkU2l6ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGxldCByc0RlY29kZXIgPSBuZXcgUmVlZFNvbG9tb25EZWNvZGVyKGdmKTtcbiAgICAgICAgICAgICAgICByc0RlY29kZXIuZGVjb2RlKGRhdGFXb3JkcywgbnVtQ29kZXdvcmRzIC0gbnVtRGF0YUNvZGV3b3Jkcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uKGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE5vdyBwZXJmb3JtIHRoZSB1bnN0dWZmaW5nIG9wZXJhdGlvbi5cbiAgICAgICAgICAgIC8vIEZpcnN0LCBjb3VudCBob3cgbWFueSBiaXRzIGFyZSBnb2luZyB0byBiZSB0aHJvd24gb3V0IGFzIHN0dWZmaW5nXG4gICAgICAgICAgICBsZXQgbWFzayA9ICgxIDw8IGNvZGV3b3JkU2l6ZSkgLSAxO1xuICAgICAgICAgICAgbGV0IHN0dWZmZWRCaXRzID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtRGF0YUNvZGV3b3JkczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGRhdGFXb3JkID0gZGF0YVdvcmRzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChkYXRhV29yZCA9PT0gMCB8fCBkYXRhV29yZCA9PT0gbWFzaykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGRhdGFXb3JkID09PSAxIHx8IGRhdGFXb3JkID09PSBtYXNrIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICBzdHVmZmVkQml0cysrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE5vdywgYWN0dWFsbHkgdW5wYWNrIHRoZSBiaXRzIGFuZCByZW1vdmUgdGhlIHN0dWZmaW5nXG4gICAgICAgICAgICBsZXQgY29ycmVjdGVkQml0cyA9IG5ldyBBcnJheShudW1EYXRhQ29kZXdvcmRzICogY29kZXdvcmRTaXplIC0gc3R1ZmZlZEJpdHMpO1xuICAgICAgICAgICAgbGV0IGluZGV4ID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtRGF0YUNvZGV3b3JkczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGRhdGFXb3JkID0gZGF0YVdvcmRzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChkYXRhV29yZCA9PT0gMSB8fCBkYXRhV29yZCA9PT0gbWFzayAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbmV4dCBjb2Rld29yZFNpemUtMSBiaXRzIGFyZSBhbGwgemVyb3Mgb3IgYWxsIG9uZXNcbiAgICAgICAgICAgICAgICAgICAgY29ycmVjdGVkQml0cy5maWxsKGRhdGFXb3JkID4gMSwgaW5kZXgsIGluZGV4ICsgY29kZXdvcmRTaXplIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFycmF5cy5maWxsKGNvcnJlY3RlZEJpdHMsIGluZGV4LCBpbmRleCArIGNvZGV3b3JkU2l6ZSAtIDEsIGRhdGFXb3JkID4gMSk7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ICs9IGNvZGV3b3JkU2l6ZSAtIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBiaXQgPSBjb2Rld29yZFNpemUgLSAxOyBiaXQgPj0gMDsgLS1iaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvcnJlY3RlZEJpdHNbaW5kZXgrK10gPSAoZGF0YVdvcmQgJiAoMSA8PCBiaXQpKSAhPT0gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjb3JyZWN0ZWRCaXRzO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIHRoZSBhcnJheSBvZiBiaXRzIGZyb20gYW4gQXp0ZWMgQ29kZSBtYXRyaXhcbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB0aGUgYXJyYXkgb2YgYml0c1xuICAgICAgICAgKi9cbiAgICAgICAgZXh0cmFjdEJpdHMobWF0cml4KSB7XG4gICAgICAgICAgICBsZXQgY29tcGFjdCA9IHRoaXMuZGRhdGEuaXNDb21wYWN0KCk7XG4gICAgICAgICAgICBsZXQgbGF5ZXJzID0gdGhpcy5kZGF0YS5nZXROYkxheWVycygpO1xuICAgICAgICAgICAgbGV0IGJhc2VNYXRyaXhTaXplID0gKGNvbXBhY3QgPyAxMSA6IDE0KSArIGxheWVycyAqIDQ7IC8vIG5vdCBpbmNsdWRpbmcgYWxpZ25tZW50IGxpbmVzXG4gICAgICAgICAgICBsZXQgYWxpZ25tZW50TWFwID0gbmV3IEludDMyQXJyYXkoYmFzZU1hdHJpeFNpemUpO1xuICAgICAgICAgICAgbGV0IHJhd2JpdHMgPSBuZXcgQXJyYXkodGhpcy50b3RhbEJpdHNJbkxheWVyKGxheWVycywgY29tcGFjdCkpO1xuICAgICAgICAgICAgaWYgKGNvbXBhY3QpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFsaWdubWVudE1hcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBhbGlnbm1lbnRNYXBbaV0gPSBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBtYXRyaXhTaXplID0gYmFzZU1hdHJpeFNpemUgKyAxICsgMiAqIEludGVnZXIudHJ1bmNEaXZpc2lvbigoSW50ZWdlci50cnVuY0RpdmlzaW9uKGJhc2VNYXRyaXhTaXplLCAyKSAtIDEpLCAxNSk7XG4gICAgICAgICAgICAgICAgbGV0IG9yaWdDZW50ZXIgPSBiYXNlTWF0cml4U2l6ZSAvIDI7XG4gICAgICAgICAgICAgICAgbGV0IGNlbnRlciA9IEludGVnZXIudHJ1bmNEaXZpc2lvbihtYXRyaXhTaXplLCAyKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9yaWdDZW50ZXI7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbmV3T2Zmc2V0ID0gaSArIEludGVnZXIudHJ1bmNEaXZpc2lvbihpLCAxNSk7XG4gICAgICAgICAgICAgICAgICAgIGFsaWdubWVudE1hcFtvcmlnQ2VudGVyIC0gaSAtIDFdID0gY2VudGVyIC0gbmV3T2Zmc2V0IC0gMTtcbiAgICAgICAgICAgICAgICAgICAgYWxpZ25tZW50TWFwW29yaWdDZW50ZXIgKyBpXSA9IGNlbnRlciArIG5ld09mZnNldCArIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIHJvd09mZnNldCA9IDA7IGkgPCBsYXllcnM7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCByb3dTaXplID0gKGxheWVycyAtIGkpICogNCArIChjb21wYWN0ID8gOSA6IDEyKTtcbiAgICAgICAgICAgICAgICAvLyBUaGUgdG9wLWxlZnQgbW9zdCBwb2ludCBvZiB0aGlzIGxheWVyIGlzIDxsb3csIGxvdz4gKG5vdCBpbmNsdWRpbmcgYWxpZ25tZW50IGxpbmVzKVxuICAgICAgICAgICAgICAgIGxldCBsb3cgPSBpICogMjtcbiAgICAgICAgICAgICAgICAvLyBUaGUgYm90dG9tLXJpZ2h0IG1vc3QgcG9pbnQgb2YgdGhpcyBsYXllciBpcyA8aGlnaCwgaGlnaD4gKG5vdCBpbmNsdWRpbmcgYWxpZ25tZW50IGxpbmVzKVxuICAgICAgICAgICAgICAgIGxldCBoaWdoID0gYmFzZU1hdHJpeFNpemUgLSAxIC0gbG93O1xuICAgICAgICAgICAgICAgIC8vIFdlIHB1bGwgYml0cyBmcm9tIHRoZSB0d28gMiB4IHJvd1NpemUgY29sdW1ucyBhbmQgdHdvIHJvd1NpemUgeCAyIHJvd3NcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHJvd1NpemU7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgY29sdW1uT2Zmc2V0ID0gaiAqIDI7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgMjsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBsZWZ0IGNvbHVtblxuICAgICAgICAgICAgICAgICAgICAgICAgcmF3Yml0c1tyb3dPZmZzZXQgKyBjb2x1bW5PZmZzZXQgKyBrXSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0cml4LmdldChhbGlnbm1lbnRNYXBbbG93ICsga10sIGFsaWdubWVudE1hcFtsb3cgKyBqXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBib3R0b20gcm93XG4gICAgICAgICAgICAgICAgICAgICAgICByYXdiaXRzW3Jvd09mZnNldCArIDIgKiByb3dTaXplICsgY29sdW1uT2Zmc2V0ICsga10gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdHJpeC5nZXQoYWxpZ25tZW50TWFwW2xvdyArIGpdLCBhbGlnbm1lbnRNYXBbaGlnaCAtIGtdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJpZ2h0IGNvbHVtblxuICAgICAgICAgICAgICAgICAgICAgICAgcmF3Yml0c1tyb3dPZmZzZXQgKyA0ICogcm93U2l6ZSArIGNvbHVtbk9mZnNldCArIGtdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRyaXguZ2V0KGFsaWdubWVudE1hcFtoaWdoIC0ga10sIGFsaWdubWVudE1hcFtoaWdoIC0gal0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdG9wIHJvd1xuICAgICAgICAgICAgICAgICAgICAgICAgcmF3Yml0c1tyb3dPZmZzZXQgKyA2ICogcm93U2l6ZSArIGNvbHVtbk9mZnNldCArIGtdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRyaXguZ2V0KGFsaWdubWVudE1hcFtoaWdoIC0gal0sIGFsaWdubWVudE1hcFtsb3cgKyBrXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcm93T2Zmc2V0ICs9IHJvd1NpemUgKiA4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJhd2JpdHM7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlYWRzIGEgY29kZSBvZiBnaXZlbiBsZW5ndGggYW5kIGF0IGdpdmVuIGluZGV4IGluIGFuIGFycmF5IG9mIGJpdHNcbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyByZWFkQ29kZShyYXdiaXRzLCBzdGFydEluZGV4LCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCByZXMgPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0SW5kZXg7IGkgPCBzdGFydEluZGV4ICsgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICByZXMgPDw9IDE7XG4gICAgICAgICAgICAgICAgaWYgKHJhd2JpdHNbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzIHw9IDB4MDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUmVhZHMgYSBjb2RlIG9mIGxlbmd0aCA4IGluIGFuIGFycmF5IG9mIGJpdHMsIHBhZGRpbmcgd2l0aCB6ZXJvc1xuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIHJlYWRCeXRlKHJhd2JpdHMsIHN0YXJ0SW5kZXgpIHtcbiAgICAgICAgICAgIGxldCBuID0gcmF3Yml0cy5sZW5ndGggLSBzdGFydEluZGV4O1xuICAgICAgICAgICAgaWYgKG4gPj0gOCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBEZWNvZGVyLnJlYWRDb2RlKHJhd2JpdHMsIHN0YXJ0SW5kZXgsIDgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIERlY29kZXIucmVhZENvZGUocmF3Yml0cywgc3RhcnRJbmRleCwgbikgPDwgKDggLSBuKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUGFja3MgYSBiaXQgYXJyYXkgaW50byBieXRlcywgbW9zdCBzaWduaWZpY2FudCBiaXQgZmlyc3RcbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBjb252ZXJ0Qm9vbEFycmF5VG9CeXRlQXJyYXkoYm9vbEFycikge1xuICAgICAgICAgICAgbGV0IGJ5dGVBcnIgPSBuZXcgVWludDhBcnJheSgoYm9vbEFyci5sZW5ndGggKyA3KSAvIDgpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlQXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYnl0ZUFycltpXSA9IERlY29kZXIucmVhZEJ5dGUoYm9vbEFyciwgOCAqIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGJ5dGVBcnI7XG4gICAgICAgIH1cbiAgICAgICAgdG90YWxCaXRzSW5MYXllcihsYXllcnMsIGNvbXBhY3QpIHtcbiAgICAgICAgICAgIHJldHVybiAoKGNvbXBhY3QgPyA4OCA6IDExMikgKyAxNiAqIGxheWVycykgKiBsYXllcnM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgRGVjb2Rlci5VUFBFUl9UQUJMRSA9IFtcbiAgICAgICAgJ0NUUkxfUFMnLCAnICcsICdBJywgJ0InLCAnQycsICdEJywgJ0UnLCAnRicsICdHJywgJ0gnLCAnSScsICdKJywgJ0snLCAnTCcsICdNJywgJ04nLCAnTycsICdQJyxcbiAgICAgICAgJ1EnLCAnUicsICdTJywgJ1QnLCAnVScsICdWJywgJ1cnLCAnWCcsICdZJywgJ1onLCAnQ1RSTF9MTCcsICdDVFJMX01MJywgJ0NUUkxfREwnLCAnQ1RSTF9CUydcbiAgICBdO1xuICAgIERlY29kZXIuTE9XRVJfVEFCTEUgPSBbXG4gICAgICAgICdDVFJMX1BTJywgJyAnLCAnYScsICdiJywgJ2MnLCAnZCcsICdlJywgJ2YnLCAnZycsICdoJywgJ2knLCAnaicsICdrJywgJ2wnLCAnbScsICduJywgJ28nLCAncCcsXG4gICAgICAgICdxJywgJ3InLCAncycsICd0JywgJ3UnLCAndicsICd3JywgJ3gnLCAneScsICd6JywgJ0NUUkxfVVMnLCAnQ1RSTF9NTCcsICdDVFJMX0RMJywgJ0NUUkxfQlMnXG4gICAgXTtcbiAgICBEZWNvZGVyLk1JWEVEX1RBQkxFID0gW1xuICAgICAgICAvLyBNb2R1bGUgcGFyc2UgZmFpbGVkOiBPY3RhbCBsaXRlcmFsIGluIHN0cmljdCBtb2RlICg1MDoyOSlcbiAgICAgICAgLy8gc28gbnVtYmVyIHN0cmluZyB3ZXJlIHNjYXBlZFxuICAgICAgICAnQ1RSTF9QUycsICcgJywgJ1xcXFwxJywgJ1xcXFwyJywgJ1xcXFwzJywgJ1xcXFw0JywgJ1xcXFw1JywgJ1xcXFw2JywgJ1xcXFw3JywgJ1xcYicsICdcXHQnLCAnXFxuJyxcbiAgICAgICAgJ1xcXFwxMycsICdcXGYnLCAnXFxyJywgJ1xcXFwzMycsICdcXFxcMzQnLCAnXFxcXDM1JywgJ1xcXFwzNicsICdcXFxcMzcnLCAnQCcsICdcXFxcJywgJ14nLCAnXycsXG4gICAgICAgICdgJywgJ3wnLCAnficsICdcXFxcMTc3JywgJ0NUUkxfTEwnLCAnQ1RSTF9VTCcsICdDVFJMX1BMJywgJ0NUUkxfQlMnXG4gICAgXTtcbiAgICBEZWNvZGVyLlBVTkNUX1RBQkxFID0gW1xuICAgICAgICAnJywgJ1xccicsICdcXHJcXG4nLCAnLiAnLCAnLCAnLCAnOiAnLCAnIScsICdcIicsICcjJywgJyQnLCAnJScsICcmJywgJ1xcJycsICcoJywgJyknLFxuICAgICAgICAnKicsICcrJywgJywnLCAnLScsICcuJywgJy8nLCAnOicsICc7JywgJzwnLCAnPScsICc+JywgJz8nLCAnWycsICddJywgJ3snLCAnfScsICdDVFJMX1VMJ1xuICAgIF07XG4gICAgRGVjb2Rlci5ESUdJVF9UQUJMRSA9IFtcbiAgICAgICAgJ0NUUkxfUFMnLCAnICcsICcwJywgJzEnLCAnMicsICczJywgJzQnLCAnNScsICc2JywgJzcnLCAnOCcsICc5JywgJywnLCAnLicsICdDVFJMX1VMJywgJ0NUUkxfVVMnXG4gICAgXTtcblxuICAgIC8qXG4gICAgICogQ29weXJpZ2h0IDIwMTIgWlhpbmcgYXV0aG9yc1xuICAgICAqXG4gICAgICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgICAgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICAgICpcbiAgICAgKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICAgICAqXG4gICAgICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICAgICAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgICAgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgICAgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gICAgICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gICAgICovXG4gICAgLypuYW1lc3BhY2UgY29tLmdvb2dsZS56eGluZy5jb21tb24uZGV0ZWN0b3IgeyovXG4gICAgLyoqXG4gICAgICogR2VuZXJhbCBtYXRoLXJlbGF0ZWQgYW5kIG51bWVyaWMgdXRpbGl0eSBmdW5jdGlvbnMuXG4gICAgICovXG4gICAgY2xhc3MgTWF0aFV0aWxzIHtcbiAgICAgICAgY29uc3RydWN0b3IoKSB7IH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVuZHMgdXAgYmVpbmcgYSBiaXQgZmFzdGVyIHRoYW4ge0BsaW5rIE1hdGgjcm91bmQoZmxvYXQpfS4gVGhpcyBtZXJlbHkgcm91bmRzIGl0c1xuICAgICAgICAgKiBhcmd1bWVudCB0byB0aGUgbmVhcmVzdCBpbnQsIHdoZXJlIHguNSByb3VuZHMgdXAgdG8geCsxLiBTZW1hbnRpY3Mgb2YgdGhpcyBzaG9ydGN1dFxuICAgICAgICAgKiBkaWZmZXIgc2xpZ2h0bHkgZnJvbSB7QGxpbmsgTWF0aCNyb3VuZChmbG9hdCl9IGluIHRoYXQgaGFsZiByb3VuZHMgZG93biBmb3IgbmVnYXRpdmVcbiAgICAgICAgICogdmFsdWVzLiAtMi41IHJvdW5kcyB0byAtMywgbm90IC0yLiBGb3IgcHVycG9zZXMgaGVyZSBpdCBtYWtlcyBubyBkaWZmZXJlbmNlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gZCByZWFsIHZhbHVlIHRvIHJvdW5kXG4gICAgICAgICAqIEByZXR1cm4gbmVhcmVzdCB7QGNvZGUgaW50fVxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIHJvdW5kKGQgLypmbG9hdCovKSB7XG4gICAgICAgICAgICBpZiAoTmFOID09PSBkKVxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgaWYgKGQgPD0gTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIE51bWJlci5NSU5fU0FGRV9JTlRFR0VSO1xuICAgICAgICAgICAgaWYgKGQgPj0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIE51bWJlci5NQVhfU0FGRV9JTlRFR0VSO1xuICAgICAgICAgICAgcmV0dXJuIC8qKGludCkgKi8gKGQgKyAoZCA8IDAuMCA/IC0wLjUgOiAwLjUpKSB8IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVFlQRVNDUklQVFBPUlQ6IG1heWJlIHJlbW92ZSByb3VuZCBtZXRob2QgYW5kIGNhbGwgZGlyZWN0bHkgTWF0aC5yb3VuZCwgaXQgbG9va3MgbGlrZSBpdCBkb2Vzbid0IG1ha2Ugc2Vuc2UgZm9yIGpzXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gYVggcG9pbnQgQSB4IGNvb3JkaW5hdGVcbiAgICAgICAgICogQHBhcmFtIGFZIHBvaW50IEEgeSBjb29yZGluYXRlXG4gICAgICAgICAqIEBwYXJhbSBiWCBwb2ludCBCIHggY29vcmRpbmF0ZVxuICAgICAgICAgKiBAcGFyYW0gYlkgcG9pbnQgQiB5IGNvb3JkaW5hdGVcbiAgICAgICAgICogQHJldHVybiBFdWNsaWRlYW4gZGlzdGFuY2UgYmV0d2VlbiBwb2ludHMgQSBhbmQgQlxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGRpc3RhbmNlKGFYIC8qZmxvYXR8aW50Ki8sIGFZIC8qZmxvYXR8aW50Ki8sIGJYIC8qZmxvYXR8aW50Ki8sIGJZIC8qZmxvYXR8aW50Ki8pIHtcbiAgICAgICAgICAgIGNvbnN0IHhEaWZmID0gYVggLSBiWDtcbiAgICAgICAgICAgIGNvbnN0IHlEaWZmID0gYVkgLSBiWTtcbiAgICAgICAgICAgIHJldHVybiAvKihmbG9hdCkgKi8gTWF0aC5zcXJ0KHhEaWZmICogeERpZmYgKyB5RGlmZiAqIHlEaWZmKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIGFYIHBvaW50IEEgeCBjb29yZGluYXRlXG4gICAgICAgICAqIEBwYXJhbSBhWSBwb2ludCBBIHkgY29vcmRpbmF0ZVxuICAgICAgICAgKiBAcGFyYW0gYlggcG9pbnQgQiB4IGNvb3JkaW5hdGVcbiAgICAgICAgICogQHBhcmFtIGJZIHBvaW50IEIgeSBjb29yZGluYXRlXG4gICAgICAgICAqIEByZXR1cm4gRXVjbGlkZWFuIGRpc3RhbmNlIGJldHdlZW4gcG9pbnRzIEEgYW5kIEJcbiAgICAgICAgICovXG4gICAgICAgIC8vIHB1YmxpYyBzdGF0aWMgZGlzdGFuY2UoYVg6IG51bWJlciAvKmludCovLCBhWTogbnVtYmVyIC8qaW50Ki8sIGJYOiBudW1iZXIgLyppbnQqLywgYlk6IG51bWJlciAvKmludCovKTogZmxvYXQge1xuICAgICAgICAvLyAgIGNvbnN0IHhEaWZmID0gYVggLSBiWFxuICAgICAgICAvLyAgIGNvbnN0IHlEaWZmID0gYVkgLSBiWVxuICAgICAgICAvLyAgIHJldHVybiAoZmxvYXQpIE1hdGguc3FydCh4RGlmZiAqIHhEaWZmICsgeURpZmYgKiB5RGlmZik7XG4gICAgICAgIC8vIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSBhcnJheSB2YWx1ZXMgdG8gc3VtXG4gICAgICAgICAqIEByZXR1cm4gc3VtIG9mIHZhbHVlcyBpbiBhcnJheVxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIHN1bShhcnJheSkge1xuICAgICAgICAgICAgbGV0IGNvdW50ID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW5ndGggPSBhcnJheS5sZW5ndGg7IGkgIT09IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYSA9IGFycmF5W2ldO1xuICAgICAgICAgICAgICAgIGNvdW50ICs9IGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY291bnQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQb255ZmlsbCBmb3IgSmF2YSdzIEZsb2F0IGNsYXNzLlxuICAgICAqL1xuICAgIGNsYXNzIEZsb2F0IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNpbmNUUyBoYXMgbm8gZGlmZmVyZW5jZSBiZXR3ZWVuIGludCBhbmQgZmxvYXQsIHRoZXJlJ3MgYWxsIG51bWJlcnMsXG4gICAgICAgICAqIHRoaXMgaXMgdXNlZCBvbmx5IHRvIHBvbHlmaWxsIEphdmEgY29kZS5cbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBmbG9hdFRvSW50Qml0cyhmKSB7XG4gICAgICAgICAgICByZXR1cm4gZjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgZmxvYXQgbWF4IHZhbHVlIGluIEpTIGlzIHRoZSBudW1iZXIgbWF4IHZhbHVlLlxuICAgICAqL1xuICAgIEZsb2F0Lk1BWF9WQUxVRSA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSO1xuXG4gICAgLypcbiAgICAgKiBDb3B5cmlnaHQgMjAwNyBaWGluZyBhdXRob3JzXG4gICAgICpcbiAgICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgICAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgICAgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgICAgKlxuICAgICAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gICAgICpcbiAgICAgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICAgICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgICAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICAgICAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgICAgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiA8cD5FbmNhcHN1bGF0ZXMgYSBwb2ludCBvZiBpbnRlcmVzdCBpbiBhbiBpbWFnZSBjb250YWluaW5nIGEgYmFyY29kZS4gVHlwaWNhbGx5LCB0aGlzXG4gICAgICogd291bGQgYmUgdGhlIGxvY2F0aW9uIG9mIGEgZmluZGVyIHBhdHRlcm4gb3IgdGhlIGNvcm5lciBvZiB0aGUgYmFyY29kZSwgZm9yIGV4YW1wbGUuPC9wPlxuICAgICAqXG4gICAgICogQGF1dGhvciBTZWFuIE93ZW5cbiAgICAgKi9cbiAgICBjbGFzcyBSZXN1bHRQb2ludCB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHgsIHkpIHtcbiAgICAgICAgICAgIHRoaXMueCA9IHg7XG4gICAgICAgICAgICB0aGlzLnkgPSB5O1xuICAgICAgICB9XG4gICAgICAgIGdldFgoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy54O1xuICAgICAgICB9XG4gICAgICAgIGdldFkoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy55O1xuICAgICAgICB9XG4gICAgICAgIC8qQE92ZXJyaWRlKi9cbiAgICAgICAgZXF1YWxzKG90aGVyKSB7XG4gICAgICAgICAgICBpZiAob3RoZXIgaW5zdGFuY2VvZiBSZXN1bHRQb2ludCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG90aGVyUG9pbnQgPSBvdGhlcjtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy54ID09PSBvdGhlclBvaW50LnggJiYgdGhpcy55ID09PSBvdGhlclBvaW50Lnk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLypAT3ZlcnJpZGUqL1xuICAgICAgICBoYXNoQ29kZSgpIHtcbiAgICAgICAgICAgIHJldHVybiAzMSAqIEZsb2F0LmZsb2F0VG9JbnRCaXRzKHRoaXMueCkgKyBGbG9hdC5mbG9hdFRvSW50Qml0cyh0aGlzLnkpO1xuICAgICAgICB9XG4gICAgICAgIC8qQE92ZXJyaWRlKi9cbiAgICAgICAgdG9TdHJpbmcoKSB7XG4gICAgICAgICAgICByZXR1cm4gJygnICsgdGhpcy54ICsgJywnICsgdGhpcy55ICsgJyknO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPcmRlcnMgYW4gYXJyYXkgb2YgdGhyZWUgUmVzdWx0UG9pbnRzIGluIGFuIG9yZGVyIFtBLEIsQ10gc3VjaCB0aGF0IEFCIGlzIGxlc3MgdGhhbiBBQ1xuICAgICAgICAgKiBhbmQgQkMgaXMgbGVzcyB0aGFuIEFDLCBhbmQgdGhlIGFuZ2xlIGJldHdlZW4gQkMgYW5kIEJBIGlzIGxlc3MgdGhhbiAxODAgZGVncmVlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHBhdHRlcm5zIGFycmF5IG9mIHRocmVlIHtAY29kZSBSZXN1bHRQb2ludH0gdG8gb3JkZXJcbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBvcmRlckJlc3RQYXR0ZXJucyhwYXR0ZXJucykge1xuICAgICAgICAgICAgLy8gRmluZCBkaXN0YW5jZXMgYmV0d2VlbiBwYXR0ZXJuIGNlbnRlcnNcbiAgICAgICAgICAgIGNvbnN0IHplcm9PbmVEaXN0YW5jZSA9IHRoaXMuZGlzdGFuY2UocGF0dGVybnNbMF0sIHBhdHRlcm5zWzFdKTtcbiAgICAgICAgICAgIGNvbnN0IG9uZVR3b0Rpc3RhbmNlID0gdGhpcy5kaXN0YW5jZShwYXR0ZXJuc1sxXSwgcGF0dGVybnNbMl0pO1xuICAgICAgICAgICAgY29uc3QgemVyb1R3b0Rpc3RhbmNlID0gdGhpcy5kaXN0YW5jZShwYXR0ZXJuc1swXSwgcGF0dGVybnNbMl0pO1xuICAgICAgICAgICAgbGV0IHBvaW50QTtcbiAgICAgICAgICAgIGxldCBwb2ludEI7XG4gICAgICAgICAgICBsZXQgcG9pbnRDO1xuICAgICAgICAgICAgLy8gQXNzdW1lIG9uZSBjbG9zZXN0IHRvIG90aGVyIHR3byBpcyBCOyBBIGFuZCBDIHdpbGwganVzdCBiZSBndWVzc2VzIGF0IGZpcnN0XG4gICAgICAgICAgICBpZiAob25lVHdvRGlzdGFuY2UgPj0gemVyb09uZURpc3RhbmNlICYmIG9uZVR3b0Rpc3RhbmNlID49IHplcm9Ud29EaXN0YW5jZSkge1xuICAgICAgICAgICAgICAgIHBvaW50QiA9IHBhdHRlcm5zWzBdO1xuICAgICAgICAgICAgICAgIHBvaW50QSA9IHBhdHRlcm5zWzFdO1xuICAgICAgICAgICAgICAgIHBvaW50QyA9IHBhdHRlcm5zWzJdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoemVyb1R3b0Rpc3RhbmNlID49IG9uZVR3b0Rpc3RhbmNlICYmIHplcm9Ud29EaXN0YW5jZSA+PSB6ZXJvT25lRGlzdGFuY2UpIHtcbiAgICAgICAgICAgICAgICBwb2ludEIgPSBwYXR0ZXJuc1sxXTtcbiAgICAgICAgICAgICAgICBwb2ludEEgPSBwYXR0ZXJuc1swXTtcbiAgICAgICAgICAgICAgICBwb2ludEMgPSBwYXR0ZXJuc1syXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBvaW50QiA9IHBhdHRlcm5zWzJdO1xuICAgICAgICAgICAgICAgIHBvaW50QSA9IHBhdHRlcm5zWzBdO1xuICAgICAgICAgICAgICAgIHBvaW50QyA9IHBhdHRlcm5zWzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVXNlIGNyb3NzIHByb2R1Y3QgdG8gZmlndXJlIG91dCB3aGV0aGVyIEEgYW5kIEMgYXJlIGNvcnJlY3Qgb3IgZmxpcHBlZC5cbiAgICAgICAgICAgIC8vIFRoaXMgYXNrcyB3aGV0aGVyIEJDIHggQkEgaGFzIGEgcG9zaXRpdmUgeiBjb21wb25lbnQsIHdoaWNoIGlzIHRoZSBhcnJhbmdlbWVudFxuICAgICAgICAgICAgLy8gd2Ugd2FudCBmb3IgQSwgQiwgQy4gSWYgaXQncyBuZWdhdGl2ZSwgdGhlbiB3ZSd2ZSBnb3QgaXQgZmxpcHBlZCBhcm91bmQgYW5kXG4gICAgICAgICAgICAvLyBzaG91bGQgc3dhcCBBIGFuZCBDLlxuICAgICAgICAgICAgaWYgKHRoaXMuY3Jvc3NQcm9kdWN0Wihwb2ludEEsIHBvaW50QiwgcG9pbnRDKSA8IDAuMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRlbXAgPSBwb2ludEE7XG4gICAgICAgICAgICAgICAgcG9pbnRBID0gcG9pbnRDO1xuICAgICAgICAgICAgICAgIHBvaW50QyA9IHRlbXA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXR0ZXJuc1swXSA9IHBvaW50QTtcbiAgICAgICAgICAgIHBhdHRlcm5zWzFdID0gcG9pbnRCO1xuICAgICAgICAgICAgcGF0dGVybnNbMl0gPSBwb2ludEM7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSBwYXR0ZXJuMSBmaXJzdCBwYXR0ZXJuXG4gICAgICAgICAqIEBwYXJhbSBwYXR0ZXJuMiBzZWNvbmQgcGF0dGVyblxuICAgICAgICAgKiBAcmV0dXJuIGRpc3RhbmNlIGJldHdlZW4gdHdvIHBvaW50c1xuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGRpc3RhbmNlKHBhdHRlcm4xLCBwYXR0ZXJuMikge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGhVdGlscy5kaXN0YW5jZShwYXR0ZXJuMS54LCBwYXR0ZXJuMS55LCBwYXR0ZXJuMi54LCBwYXR0ZXJuMi55KTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgeiBjb21wb25lbnQgb2YgdGhlIGNyb3NzIHByb2R1Y3QgYmV0d2VlbiB2ZWN0b3JzIEJDIGFuZCBCQS5cbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBjcm9zc1Byb2R1Y3RaKHBvaW50QSwgcG9pbnRCLCBwb2ludEMpIHtcbiAgICAgICAgICAgIGNvbnN0IGJYID0gcG9pbnRCLng7XG4gICAgICAgICAgICBjb25zdCBiWSA9IHBvaW50Qi55O1xuICAgICAgICAgICAgcmV0dXJuICgocG9pbnRDLnggLSBiWCkgKiAocG9pbnRBLnkgLSBiWSkpIC0gKChwb2ludEMueSAtIGJZKSAqIChwb2ludEEueCAtIGJYKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKlxuICAgICAqIENvcHlyaWdodCAyMDA3IFpYaW5nIGF1dGhvcnNcbiAgICAgKlxuICAgICAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gICAgICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgICAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgICAqXG4gICAgICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAgICAgKlxuICAgICAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgICAgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICAgICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gICAgICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICAgICAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIDxwPkVuY2Fwc3VsYXRlcyB0aGUgcmVzdWx0IG9mIGRldGVjdGluZyBhIGJhcmNvZGUgaW4gYW4gaW1hZ2UuIFRoaXMgaW5jbHVkZXMgdGhlIHJhd1xuICAgICAqIG1hdHJpeCBvZiBibGFjay93aGl0ZSBwaXhlbHMgY29ycmVzcG9uZGluZyB0byB0aGUgYmFyY29kZSwgYW5kIHBvc3NpYmx5IHBvaW50cyBvZiBpbnRlcmVzdFxuICAgICAqIGluIHRoZSBpbWFnZSwgbGlrZSB0aGUgbG9jYXRpb24gb2YgZmluZGVyIHBhdHRlcm5zIG9yIGNvcm5lcnMgb2YgdGhlIGJhcmNvZGUgaW4gdGhlIGltYWdlLjwvcD5cbiAgICAgKlxuICAgICAqIEBhdXRob3IgU2VhbiBPd2VuXG4gICAgICovXG4gICAgY2xhc3MgRGV0ZWN0b3JSZXN1bHQge1xuICAgICAgICBjb25zdHJ1Y3RvcihiaXRzLCBwb2ludHMpIHtcbiAgICAgICAgICAgIHRoaXMuYml0cyA9IGJpdHM7XG4gICAgICAgICAgICB0aGlzLnBvaW50cyA9IHBvaW50cztcbiAgICAgICAgfVxuICAgICAgICBnZXRCaXRzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYml0cztcbiAgICAgICAgfVxuICAgICAgICBnZXRQb2ludHMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wb2ludHM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKlxuICAgICAqIENvcHlyaWdodCAyMDEwIFpYaW5nIGF1dGhvcnNcbiAgICAgKlxuICAgICAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gICAgICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgICAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgICAqXG4gICAgICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAgICAgKlxuICAgICAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgICAgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICAgICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gICAgICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICAgICAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIDxwPkV4dGVuZHMge0BsaW5rIERldGVjdG9yUmVzdWx0fSB3aXRoIG1vcmUgaW5mb3JtYXRpb24gc3BlY2lmaWMgdG8gdGhlIEF6dGVjIGZvcm1hdCxcbiAgICAgKiBsaWtlIHRoZSBudW1iZXIgb2YgbGF5ZXJzIGFuZCB3aGV0aGVyIGl0J3MgY29tcGFjdC48L3A+XG4gICAgICpcbiAgICAgKiBAYXV0aG9yIFNlYW4gT3dlblxuICAgICAqL1xuICAgIGNsYXNzIEF6dGVjRGV0ZWN0b3JSZXN1bHQgZXh0ZW5kcyBEZXRlY3RvclJlc3VsdCB7XG4gICAgICAgIGNvbnN0cnVjdG9yKGJpdHMsIHBvaW50cywgY29tcGFjdCwgbmJEYXRhYmxvY2tzLCBuYkxheWVycykge1xuICAgICAgICAgICAgc3VwZXIoYml0cywgcG9pbnRzKTtcbiAgICAgICAgICAgIHRoaXMuY29tcGFjdCA9IGNvbXBhY3Q7XG4gICAgICAgICAgICB0aGlzLm5iRGF0YWJsb2NrcyA9IG5iRGF0YWJsb2NrcztcbiAgICAgICAgICAgIHRoaXMubmJMYXllcnMgPSBuYkxheWVycztcbiAgICAgICAgfVxuICAgICAgICBnZXROYkxheWVycygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5iTGF5ZXJzO1xuICAgICAgICB9XG4gICAgICAgIGdldE5iRGF0YWJsb2NrcygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5iRGF0YWJsb2NrcztcbiAgICAgICAgfVxuICAgICAgICBpc0NvbXBhY3QoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb21wYWN0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBDb3B5cmlnaHQgMjAxMCBaWGluZyBhdXRob3JzXG4gICAgICpcbiAgICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgICAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgICAgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgICAgKlxuICAgICAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gICAgICpcbiAgICAgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICAgICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgICAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICAgICAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgICAgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiA8cD5cbiAgICAgKiBEZXRlY3RzIGEgY2FuZGlkYXRlIGJhcmNvZGUtbGlrZSByZWN0YW5ndWxhciByZWdpb24gd2l0aGluIGFuIGltYWdlLiBJdFxuICAgICAqIHN0YXJ0cyBhcm91bmQgdGhlIGNlbnRlciBvZiB0aGUgaW1hZ2UsIGluY3JlYXNlcyB0aGUgc2l6ZSBvZiB0aGUgY2FuZGlkYXRlXG4gICAgICogcmVnaW9uIHVudGlsIGl0IGZpbmRzIGEgd2hpdGUgcmVjdGFuZ3VsYXIgcmVnaW9uLiBCeSBrZWVwaW5nIHRyYWNrIG9mIHRoZVxuICAgICAqIGxhc3QgYmxhY2sgcG9pbnRzIGl0IGVuY291bnRlcmVkLCBpdCBkZXRlcm1pbmVzIHRoZSBjb3JuZXJzIG9mIHRoZSBiYXJjb2RlLlxuICAgICAqIDwvcD5cbiAgICAgKlxuICAgICAqIEBhdXRob3IgRGF2aWQgT2xpdmllclxuICAgICAqL1xuICAgIGNsYXNzIFdoaXRlUmVjdGFuZ2xlRGV0ZWN0b3Ige1xuICAgICAgICAvLyBwdWJsaWMgY29uc3RydWN0b3IocHJpdmF0ZSBpbWFnZTogQml0TWF0cml4KSAvKnRocm93cyBOb3RGb3VuZEV4Y2VwdGlvbiovIHtcbiAgICAgICAgLy8gICB0aGlzKGltYWdlLCBJTklUX1NJWkUsIGltYWdlLmdldFdpZHRoKCkgLyAyLCBpbWFnZS5nZXRIZWlnaHQoKSAvIDIpXG4gICAgICAgIC8vIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSBpbWFnZSBiYXJjb2RlIGltYWdlIHRvIGZpbmQgYSByZWN0YW5nbGUgaW5cbiAgICAgICAgICogQHBhcmFtIGluaXRTaXplIGluaXRpYWwgc2l6ZSBvZiBzZWFyY2ggYXJlYSBhcm91bmQgY2VudGVyXG4gICAgICAgICAqIEBwYXJhbSB4IHggcG9zaXRpb24gb2Ygc2VhcmNoIGNlbnRlclxuICAgICAgICAgKiBAcGFyYW0geSB5IHBvc2l0aW9uIG9mIHNlYXJjaCBjZW50ZXJcbiAgICAgICAgICogQHRocm93cyBOb3RGb3VuZEV4Y2VwdGlvbiBpZiBpbWFnZSBpcyB0b28gc21hbGwgdG8gYWNjb21tb2RhdGUge0Bjb2RlIGluaXRTaXplfVxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3RydWN0b3IoaW1hZ2UsIGluaXRTaXplIC8qaW50Ki8sIHggLyppbnQqLywgeSAvKmludCovKSB7XG4gICAgICAgICAgICB0aGlzLmltYWdlID0gaW1hZ2U7XG4gICAgICAgICAgICB0aGlzLmhlaWdodCA9IGltYWdlLmdldEhlaWdodCgpO1xuICAgICAgICAgICAgdGhpcy53aWR0aCA9IGltYWdlLmdldFdpZHRoKCk7XG4gICAgICAgICAgICBpZiAodW5kZWZpbmVkID09PSBpbml0U2l6ZSB8fCBudWxsID09PSBpbml0U2l6ZSkge1xuICAgICAgICAgICAgICAgIGluaXRTaXplID0gV2hpdGVSZWN0YW5nbGVEZXRlY3Rvci5JTklUX1NJWkU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodW5kZWZpbmVkID09PSB4IHx8IG51bGwgPT09IHgpIHtcbiAgICAgICAgICAgICAgICB4ID0gaW1hZ2UuZ2V0V2lkdGgoKSAvIDIgfCAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHVuZGVmaW5lZCA9PT0geSB8fCBudWxsID09PSB5KSB7XG4gICAgICAgICAgICAgICAgeSA9IGltYWdlLmdldEhlaWdodCgpIC8gMiB8IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBoYWxmc2l6ZSA9IGluaXRTaXplIC8gMiB8IDA7XG4gICAgICAgICAgICB0aGlzLmxlZnRJbml0ID0geCAtIGhhbGZzaXplO1xuICAgICAgICAgICAgdGhpcy5yaWdodEluaXQgPSB4ICsgaGFsZnNpemU7XG4gICAgICAgICAgICB0aGlzLnVwSW5pdCA9IHkgLSBoYWxmc2l6ZTtcbiAgICAgICAgICAgIHRoaXMuZG93bkluaXQgPSB5ICsgaGFsZnNpemU7XG4gICAgICAgICAgICBpZiAodGhpcy51cEluaXQgPCAwIHx8IHRoaXMubGVmdEluaXQgPCAwIHx8IHRoaXMuZG93bkluaXQgPj0gdGhpcy5oZWlnaHQgfHwgdGhpcy5yaWdodEluaXQgPj0gdGhpcy53aWR0aCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiA8cD5cbiAgICAgICAgICogRGV0ZWN0cyBhIGNhbmRpZGF0ZSBiYXJjb2RlLWxpa2UgcmVjdGFuZ3VsYXIgcmVnaW9uIHdpdGhpbiBhbiBpbWFnZS4gSXRcbiAgICAgICAgICogc3RhcnRzIGFyb3VuZCB0aGUgY2VudGVyIG9mIHRoZSBpbWFnZSwgaW5jcmVhc2VzIHRoZSBzaXplIG9mIHRoZSBjYW5kaWRhdGVcbiAgICAgICAgICogcmVnaW9uIHVudGlsIGl0IGZpbmRzIGEgd2hpdGUgcmVjdGFuZ3VsYXIgcmVnaW9uLlxuICAgICAgICAgKiA8L3A+XG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge0BsaW5rIFJlc3VsdFBvaW50fVtdIGRlc2NyaWJpbmcgdGhlIGNvcm5lcnMgb2YgdGhlIHJlY3Rhbmd1bGFyXG4gICAgICAgICAqICAgICAgICAgcmVnaW9uLiBUaGUgZmlyc3QgYW5kIGxhc3QgcG9pbnRzIGFyZSBvcHBvc2VkIG9uIHRoZSBkaWFnb25hbCwgYXNcbiAgICAgICAgICogICAgICAgICBhcmUgdGhlIHNlY29uZCBhbmQgdGhpcmQuIFRoZSBmaXJzdCBwb2ludCB3aWxsIGJlIHRoZSB0b3Btb3N0XG4gICAgICAgICAqICAgICAgICAgcG9pbnQgYW5kIHRoZSBsYXN0LCB0aGUgYm90dG9tbW9zdC4gVGhlIHNlY29uZCBwb2ludCB3aWxsIGJlXG4gICAgICAgICAqICAgICAgICAgbGVmdG1vc3QgYW5kIHRoZSB0aGlyZCwgdGhlIHJpZ2h0bW9zdFxuICAgICAgICAgKiBAdGhyb3dzIE5vdEZvdW5kRXhjZXB0aW9uIGlmIG5vIERhdGEgTWF0cml4IENvZGUgY2FuIGJlIGZvdW5kXG4gICAgICAgICAqL1xuICAgICAgICBkZXRlY3QoKSB7XG4gICAgICAgICAgICBsZXQgbGVmdCA9IHRoaXMubGVmdEluaXQ7XG4gICAgICAgICAgICBsZXQgcmlnaHQgPSB0aGlzLnJpZ2h0SW5pdDtcbiAgICAgICAgICAgIGxldCB1cCA9IHRoaXMudXBJbml0O1xuICAgICAgICAgICAgbGV0IGRvd24gPSB0aGlzLmRvd25Jbml0O1xuICAgICAgICAgICAgbGV0IHNpemVFeGNlZWRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IGFCbGFja1BvaW50Rm91bmRPbkJvcmRlciA9IHRydWU7XG4gICAgICAgICAgICBsZXQgYXRMZWFzdE9uZUJsYWNrUG9pbnRGb3VuZE9uQm9yZGVyID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgYXRMZWFzdE9uZUJsYWNrUG9pbnRGb3VuZE9uUmlnaHQgPSBmYWxzZTtcbiAgICAgICAgICAgIGxldCBhdExlYXN0T25lQmxhY2tQb2ludEZvdW5kT25Cb3R0b20gPSBmYWxzZTtcbiAgICAgICAgICAgIGxldCBhdExlYXN0T25lQmxhY2tQb2ludEZvdW5kT25MZWZ0ID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgYXRMZWFzdE9uZUJsYWNrUG9pbnRGb3VuZE9uVG9wID0gZmFsc2U7XG4gICAgICAgICAgICBjb25zdCB3aWR0aCA9IHRoaXMud2lkdGg7XG4gICAgICAgICAgICBjb25zdCBoZWlnaHQgPSB0aGlzLmhlaWdodDtcbiAgICAgICAgICAgIHdoaWxlIChhQmxhY2tQb2ludEZvdW5kT25Cb3JkZXIpIHtcbiAgICAgICAgICAgICAgICBhQmxhY2tQb2ludEZvdW5kT25Cb3JkZXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAvLyAuLi4uLlxuICAgICAgICAgICAgICAgIC8vIC4gICB8XG4gICAgICAgICAgICAgICAgLy8gLi4uLi5cbiAgICAgICAgICAgICAgICBsZXQgcmlnaHRCb3JkZXJOb3RXaGl0ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgd2hpbGUgKChyaWdodEJvcmRlck5vdFdoaXRlIHx8ICFhdExlYXN0T25lQmxhY2tQb2ludEZvdW5kT25SaWdodCkgJiYgcmlnaHQgPCB3aWR0aCkge1xuICAgICAgICAgICAgICAgICAgICByaWdodEJvcmRlck5vdFdoaXRlID0gdGhpcy5jb250YWluc0JsYWNrUG9pbnQodXAsIGRvd24sIHJpZ2h0LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyaWdodEJvcmRlck5vdFdoaXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgYUJsYWNrUG9pbnRGb3VuZE9uQm9yZGVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0TGVhc3RPbmVCbGFja1BvaW50Rm91bmRPblJpZ2h0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghYXRMZWFzdE9uZUJsYWNrUG9pbnRGb3VuZE9uUmlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0Kys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJpZ2h0ID49IHdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgIHNpemVFeGNlZWRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyAuLi4uLlxuICAgICAgICAgICAgICAgIC8vIC4gICAuXG4gICAgICAgICAgICAgICAgLy8gLl9fXy5cbiAgICAgICAgICAgICAgICBsZXQgYm90dG9tQm9yZGVyTm90V2hpdGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHdoaWxlICgoYm90dG9tQm9yZGVyTm90V2hpdGUgfHwgIWF0TGVhc3RPbmVCbGFja1BvaW50Rm91bmRPbkJvdHRvbSkgJiYgZG93biA8IGhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICBib3R0b21Cb3JkZXJOb3RXaGl0ZSA9IHRoaXMuY29udGFpbnNCbGFja1BvaW50KGxlZnQsIHJpZ2h0LCBkb3duLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJvdHRvbUJvcmRlck5vdFdoaXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb3duKys7XG4gICAgICAgICAgICAgICAgICAgICAgICBhQmxhY2tQb2ludEZvdW5kT25Cb3JkZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXRMZWFzdE9uZUJsYWNrUG9pbnRGb3VuZE9uQm90dG9tID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghYXRMZWFzdE9uZUJsYWNrUG9pbnRGb3VuZE9uQm90dG9tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb3duKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGRvd24gPj0gaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIHNpemVFeGNlZWRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyAuLi4uLlxuICAgICAgICAgICAgICAgIC8vIHwgICAuXG4gICAgICAgICAgICAgICAgLy8gLi4uLi5cbiAgICAgICAgICAgICAgICBsZXQgbGVmdEJvcmRlck5vdFdoaXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoKGxlZnRCb3JkZXJOb3RXaGl0ZSB8fCAhYXRMZWFzdE9uZUJsYWNrUG9pbnRGb3VuZE9uTGVmdCkgJiYgbGVmdCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnRCb3JkZXJOb3RXaGl0ZSA9IHRoaXMuY29udGFpbnNCbGFja1BvaW50KHVwLCBkb3duLCBsZWZ0LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsZWZ0Qm9yZGVyTm90V2hpdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQtLTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFCbGFja1BvaW50Rm91bmRPbkJvcmRlciA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBhdExlYXN0T25lQmxhY2tQb2ludEZvdW5kT25MZWZ0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghYXRMZWFzdE9uZUJsYWNrUG9pbnRGb3VuZE9uTGVmdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdC0tO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChsZWZ0IDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBzaXplRXhjZWVkZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gLl9fXy5cbiAgICAgICAgICAgICAgICAvLyAuICAgLlxuICAgICAgICAgICAgICAgIC8vIC4uLi4uXG4gICAgICAgICAgICAgICAgbGV0IHRvcEJvcmRlck5vdFdoaXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoKHRvcEJvcmRlck5vdFdoaXRlIHx8ICFhdExlYXN0T25lQmxhY2tQb2ludEZvdW5kT25Ub3ApICYmIHVwID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdG9wQm9yZGVyTm90V2hpdGUgPSB0aGlzLmNvbnRhaW5zQmxhY2tQb2ludChsZWZ0LCByaWdodCwgdXAsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodG9wQm9yZGVyTm90V2hpdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwLS07XG4gICAgICAgICAgICAgICAgICAgICAgICBhQmxhY2tQb2ludEZvdW5kT25Cb3JkZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXRMZWFzdE9uZUJsYWNrUG9pbnRGb3VuZE9uVG9wID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghYXRMZWFzdE9uZUJsYWNrUG9pbnRGb3VuZE9uVG9wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cC0tO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh1cCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc2l6ZUV4Y2VlZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChhQmxhY2tQb2ludEZvdW5kT25Cb3JkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgYXRMZWFzdE9uZUJsYWNrUG9pbnRGb3VuZE9uQm9yZGVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXNpemVFeGNlZWRlZCAmJiBhdExlYXN0T25lQmxhY2tQb2ludEZvdW5kT25Cb3JkZXIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXhTaXplID0gcmlnaHQgLSBsZWZ0O1xuICAgICAgICAgICAgICAgIGxldCB6ID0gbnVsbDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgeiA9PT0gbnVsbCAmJiBpIDwgbWF4U2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHogPSB0aGlzLmdldEJsYWNrUG9pbnRPblNlZ21lbnQobGVmdCwgZG93biAtIGksIGxlZnQgKyBpLCBkb3duKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHogPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IHQgPSBudWxsO1xuICAgICAgICAgICAgICAgIC8vIGdvIGRvd24gcmlnaHRcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgdCA9PT0gbnVsbCAmJiBpIDwgbWF4U2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHQgPSB0aGlzLmdldEJsYWNrUG9pbnRPblNlZ21lbnQobGVmdCwgdXAgKyBpLCBsZWZ0ICsgaSwgdXApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgeCA9IG51bGw7XG4gICAgICAgICAgICAgICAgLy8gZ28gZG93biBsZWZ0XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IHggPT09IG51bGwgJiYgaSA8IG1heFNpemU7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB4ID0gdGhpcy5nZXRCbGFja1BvaW50T25TZWdtZW50KHJpZ2h0LCB1cCArIGksIHJpZ2h0IC0gaSwgdXApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoeCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgeSA9IG51bGw7XG4gICAgICAgICAgICAgICAgLy8gZ28gdXAgbGVmdFxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyB5ID09PSBudWxsICYmIGkgPCBtYXhTaXplOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgeSA9IHRoaXMuZ2V0QmxhY2tQb2ludE9uU2VnbWVudChyaWdodCwgZG93biAtIGksIHJpZ2h0IC0gaSwgZG93bik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh5ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNlbnRlckVkZ2VzKHksIHosIHgsIHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZ2V0QmxhY2tQb2ludE9uU2VnbWVudChhWCAvKmZsb2F0Ki8sIGFZIC8qZmxvYXQqLywgYlggLypmbG9hdCovLCBiWSAvKmZsb2F0Ki8pIHtcbiAgICAgICAgICAgIGNvbnN0IGRpc3QgPSBNYXRoVXRpbHMucm91bmQoTWF0aFV0aWxzLmRpc3RhbmNlKGFYLCBhWSwgYlgsIGJZKSk7XG4gICAgICAgICAgICBjb25zdCB4U3RlcCA9IChiWCAtIGFYKSAvIGRpc3Q7XG4gICAgICAgICAgICBjb25zdCB5U3RlcCA9IChiWSAtIGFZKSAvIGRpc3Q7XG4gICAgICAgICAgICBjb25zdCBpbWFnZSA9IHRoaXMuaW1hZ2U7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRpc3Q7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHggPSBNYXRoVXRpbHMucm91bmQoYVggKyBpICogeFN0ZXApO1xuICAgICAgICAgICAgICAgIGNvbnN0IHkgPSBNYXRoVXRpbHMucm91bmQoYVkgKyBpICogeVN0ZXApO1xuICAgICAgICAgICAgICAgIGlmIChpbWFnZS5nZXQoeCwgeSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBSZXN1bHRQb2ludCh4LCB5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogcmVjZW50ZXJzIHRoZSBwb2ludHMgb2YgYSBjb25zdGFudCBkaXN0YW5jZSB0b3dhcmRzIHRoZSBjZW50ZXJcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHkgYm90dG9tIG1vc3QgcG9pbnRcbiAgICAgICAgICogQHBhcmFtIHogbGVmdCBtb3N0IHBvaW50XG4gICAgICAgICAqIEBwYXJhbSB4IHJpZ2h0IG1vc3QgcG9pbnRcbiAgICAgICAgICogQHBhcmFtIHQgdG9wIG1vc3QgcG9pbnRcbiAgICAgICAgICogQHJldHVybiB7QGxpbmsgUmVzdWx0UG9pbnR9W10gZGVzY3JpYmluZyB0aGUgY29ybmVycyBvZiB0aGUgcmVjdGFuZ3VsYXJcbiAgICAgICAgICogICAgICAgICByZWdpb24uIFRoZSBmaXJzdCBhbmQgbGFzdCBwb2ludHMgYXJlIG9wcG9zZWQgb24gdGhlIGRpYWdvbmFsLCBhc1xuICAgICAgICAgKiAgICAgICAgIGFyZSB0aGUgc2Vjb25kIGFuZCB0aGlyZC4gVGhlIGZpcnN0IHBvaW50IHdpbGwgYmUgdGhlIHRvcG1vc3RcbiAgICAgICAgICogICAgICAgICBwb2ludCBhbmQgdGhlIGxhc3QsIHRoZSBib3R0b21tb3N0LiBUaGUgc2Vjb25kIHBvaW50IHdpbGwgYmVcbiAgICAgICAgICogICAgICAgICBsZWZ0bW9zdCBhbmQgdGhlIHRoaXJkLCB0aGUgcmlnaHRtb3N0XG4gICAgICAgICAqL1xuICAgICAgICBjZW50ZXJFZGdlcyh5LCB6LCB4LCB0KSB7XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gICAgICAgdCAgICAgICAgICAgIHRcbiAgICAgICAgICAgIC8vICB6ICAgICAgICAgICAgICAgICAgICAgIHhcbiAgICAgICAgICAgIC8vICAgICAgICB4ICAgIE9SICAgIHpcbiAgICAgICAgICAgIC8vICAgeSAgICAgICAgICAgICAgICAgICAgeVxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIGNvbnN0IHlpID0geS5nZXRYKCk7XG4gICAgICAgICAgICBjb25zdCB5aiA9IHkuZ2V0WSgpO1xuICAgICAgICAgICAgY29uc3QgemkgPSB6LmdldFgoKTtcbiAgICAgICAgICAgIGNvbnN0IHpqID0gei5nZXRZKCk7XG4gICAgICAgICAgICBjb25zdCB4aSA9IHguZ2V0WCgpO1xuICAgICAgICAgICAgY29uc3QgeGogPSB4LmdldFkoKTtcbiAgICAgICAgICAgIGNvbnN0IHRpID0gdC5nZXRYKCk7XG4gICAgICAgICAgICBjb25zdCB0aiA9IHQuZ2V0WSgpO1xuICAgICAgICAgICAgY29uc3QgQ09SUiA9IFdoaXRlUmVjdGFuZ2xlRGV0ZWN0b3IuQ09SUjtcbiAgICAgICAgICAgIGlmICh5aSA8IHRoaXMud2lkdGggLyAyLjApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICBuZXcgUmVzdWx0UG9pbnQodGkgLSBDT1JSLCB0aiArIENPUlIpLFxuICAgICAgICAgICAgICAgICAgICBuZXcgUmVzdWx0UG9pbnQoemkgKyBDT1JSLCB6aiArIENPUlIpLFxuICAgICAgICAgICAgICAgICAgICBuZXcgUmVzdWx0UG9pbnQoeGkgLSBDT1JSLCB4aiAtIENPUlIpLFxuICAgICAgICAgICAgICAgICAgICBuZXcgUmVzdWx0UG9pbnQoeWkgKyBDT1JSLCB5aiAtIENPUlIpXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgIG5ldyBSZXN1bHRQb2ludCh0aSArIENPUlIsIHRqICsgQ09SUiksXG4gICAgICAgICAgICAgICAgICAgIG5ldyBSZXN1bHRQb2ludCh6aSArIENPUlIsIHpqIC0gQ09SUiksXG4gICAgICAgICAgICAgICAgICAgIG5ldyBSZXN1bHRQb2ludCh4aSAtIENPUlIsIHhqICsgQ09SUiksXG4gICAgICAgICAgICAgICAgICAgIG5ldyBSZXN1bHRQb2ludCh5aSAtIENPUlIsIHlqIC0gQ09SUilcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgYSBzZWdtZW50IGNvbnRhaW5zIGEgYmxhY2sgcG9pbnRcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGEgICAgICAgICAgbWluIHZhbHVlIG9mIHRoZSBzY2FubmVkIGNvb3JkaW5hdGVcbiAgICAgICAgICogQHBhcmFtIGIgICAgICAgICAgbWF4IHZhbHVlIG9mIHRoZSBzY2FubmVkIGNvb3JkaW5hdGVcbiAgICAgICAgICogQHBhcmFtIGZpeGVkICAgICAgdmFsdWUgb2YgZml4ZWQgY29vcmRpbmF0ZVxuICAgICAgICAgKiBAcGFyYW0gaG9yaXpvbnRhbCBzZXQgdG8gdHJ1ZSBpZiBzY2FuIG11c3QgYmUgaG9yaXpvbnRhbCwgZmFsc2UgaWYgdmVydGljYWxcbiAgICAgICAgICogQHJldHVybiB0cnVlIGlmIGEgYmxhY2sgcG9pbnQgaGFzIGJlZW4gZm91bmQsIGVsc2UgZmFsc2UuXG4gICAgICAgICAqL1xuICAgICAgICBjb250YWluc0JsYWNrUG9pbnQoYSAvKmludCovLCBiIC8qaW50Ki8sIGZpeGVkIC8qaW50Ki8sIGhvcml6b250YWwpIHtcbiAgICAgICAgICAgIGNvbnN0IGltYWdlID0gdGhpcy5pbWFnZTtcbiAgICAgICAgICAgIGlmIChob3Jpem9udGFsKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgeCA9IGE7IHggPD0gYjsgeCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbWFnZS5nZXQoeCwgZml4ZWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHkgPSBhOyB5IDw9IGI7IHkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW1hZ2UuZ2V0KGZpeGVkLCB5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgV2hpdGVSZWN0YW5nbGVEZXRlY3Rvci5JTklUX1NJWkUgPSAxMDtcbiAgICBXaGl0ZVJlY3RhbmdsZURldGVjdG9yLkNPUlIgPSAxO1xuXG4gICAgLypcbiAgICAgKiBDb3B5cmlnaHQgMjAwNyBaWGluZyBhdXRob3JzXG4gICAgICpcbiAgICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgICAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgICAgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgICAgKlxuICAgICAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gICAgICpcbiAgICAgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICAgICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgICAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICAgICAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgICAgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBJbXBsZW1lbnRhdGlvbnMgb2YgdGhpcyBjbGFzcyBjYW4sIGdpdmVuIGxvY2F0aW9ucyBvZiBmaW5kZXIgcGF0dGVybnMgZm9yIGEgUVIgY29kZSBpbiBhblxuICAgICAqIGltYWdlLCBzYW1wbGUgdGhlIHJpZ2h0IHBvaW50cyBpbiB0aGUgaW1hZ2UgdG8gcmVjb25zdHJ1Y3QgdGhlIFFSIGNvZGUsIGFjY291bnRpbmcgZm9yXG4gICAgICogcGVyc3BlY3RpdmUgZGlzdG9ydGlvbi4gSXQgaXMgYWJzdHJhY3RlZCBzaW5jZSBpdCBpcyByZWxhdGl2ZWx5IGV4cGVuc2l2ZSBhbmQgc2hvdWxkIGJlIGFsbG93ZWRcbiAgICAgKiB0byB0YWtlIGFkdmFudGFnZSBvZiBwbGF0Zm9ybS1zcGVjaWZpYyBvcHRpbWl6ZWQgaW1wbGVtZW50YXRpb25zLCBsaWtlIFN1bidzIEphdmEgQWR2YW5jZWRcbiAgICAgKiBJbWFnaW5nIGxpYnJhcnksIGJ1dCB3aGljaCBtYXkgbm90IGJlIGF2YWlsYWJsZSBpbiBvdGhlciBlbnZpcm9ubWVudHMgc3VjaCBhcyBKMk1FLCBhbmQgdmljZVxuICAgICAqIHZlcnNhLlxuICAgICAqXG4gICAgICogVGhlIGltcGxlbWVudGF0aW9uIHVzZWQgY2FuIGJlIGNvbnRyb2xsZWQgYnkgY2FsbGluZyB7QGxpbmsgI3NldEdyaWRTYW1wbGVyKEdyaWRTYW1wbGVyKX1cbiAgICAgKiB3aXRoIGFuIGluc3RhbmNlIG9mIGEgY2xhc3Mgd2hpY2ggaW1wbGVtZW50cyB0aGlzIGludGVyZmFjZS5cbiAgICAgKlxuICAgICAqIEBhdXRob3IgU2VhbiBPd2VuXG4gICAgICovXG4gICAgY2xhc3MgR3JpZFNhbXBsZXIge1xuICAgICAgICAvKipcbiAgICAgICAgICogPHA+Q2hlY2tzIGEgc2V0IG9mIHBvaW50cyB0aGF0IGhhdmUgYmVlbiB0cmFuc2Zvcm1lZCB0byBzYW1wbGUgcG9pbnRzIG9uIGFuIGltYWdlIGFnYWluc3RcbiAgICAgICAgICogdGhlIGltYWdlJ3MgZGltZW5zaW9ucyB0byBzZWUgaWYgdGhlIHBvaW50IGFyZSBldmVuIHdpdGhpbiB0aGUgaW1hZ2UuPC9wPlxuICAgICAgICAgKlxuICAgICAgICAgKiA8cD5UaGlzIG1ldGhvZCB3aWxsIGFjdHVhbGx5IFwibnVkZ2VcIiB0aGUgZW5kcG9pbnRzIGJhY2sgb250byB0aGUgaW1hZ2UgaWYgdGhleSBhcmUgZm91bmQgdG8gYmVcbiAgICAgICAgICogYmFyZWx5IChsZXNzIHRoYW4gMSBwaXhlbCkgb2ZmIHRoZSBpbWFnZS4gVGhpcyBhY2NvdW50cyBmb3IgaW1wZXJmZWN0IGRldGVjdGlvbiBvZiBmaW5kZXJcbiAgICAgICAgICogcGF0dGVybnMgaW4gYW4gaW1hZ2Ugd2hlcmUgdGhlIFFSIENvZGUgcnVucyBhbGwgdGhlIHdheSB0byB0aGUgaW1hZ2UgYm9yZGVyLjwvcD5cbiAgICAgICAgICpcbiAgICAgICAgICogPHA+Rm9yIGVmZmljaWVuY3ksIHRoZSBtZXRob2Qgd2lsbCBjaGVjayBwb2ludHMgZnJvbSBlaXRoZXIgZW5kIG9mIHRoZSBsaW5lIHVudGlsIG9uZSBpcyBmb3VuZFxuICAgICAgICAgKiB0byBiZSB3aXRoaW4gdGhlIGltYWdlLiBCZWNhdXNlIHRoZSBzZXQgb2YgcG9pbnRzIGFyZSBhc3N1bWVkIHRvIGJlIGxpbmVhciwgdGhpcyBpcyB2YWxpZC48L3A+XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBpbWFnZSBpbWFnZSBpbnRvIHdoaWNoIHRoZSBwb2ludHMgc2hvdWxkIG1hcFxuICAgICAgICAgKiBAcGFyYW0gcG9pbnRzIGFjdHVhbCBwb2ludHMgaW4geDEseTEsLi4uLHhuLHluIGZvcm1cbiAgICAgICAgICogQHRocm93cyBOb3RGb3VuZEV4Y2VwdGlvbiBpZiBhbiBlbmRwb2ludCBpcyBsaWVzIG91dHNpZGUgdGhlIGltYWdlIGJvdW5kYXJpZXNcbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBjaGVja0FuZE51ZGdlUG9pbnRzKGltYWdlLCBwb2ludHMpIHtcbiAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gaW1hZ2UuZ2V0V2lkdGgoKTtcbiAgICAgICAgICAgIGNvbnN0IGhlaWdodCA9IGltYWdlLmdldEhlaWdodCgpO1xuICAgICAgICAgICAgLy8gQ2hlY2sgYW5kIG51ZGdlIHBvaW50cyBmcm9tIHN0YXJ0IHVudGlsIHdlIHNlZSBzb21lIHRoYXQgYXJlIE9LOlxuICAgICAgICAgICAgbGV0IG51ZGdlZCA9IHRydWU7XG4gICAgICAgICAgICBmb3IgKGxldCBvZmZzZXQgPSAwOyBvZmZzZXQgPCBwb2ludHMubGVuZ3RoICYmIG51ZGdlZDsgb2Zmc2V0ICs9IDIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB4ID0gTWF0aC5mbG9vcihwb2ludHNbb2Zmc2V0XSk7XG4gICAgICAgICAgICAgICAgY29uc3QgeSA9IE1hdGguZmxvb3IocG9pbnRzW29mZnNldCArIDFdKTtcbiAgICAgICAgICAgICAgICBpZiAoeCA8IC0xIHx8IHggPiB3aWR0aCB8fCB5IDwgLTEgfHwgeSA+IGhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbnVkZ2VkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaWYgKHggPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50c1tvZmZzZXRdID0gMC4wO1xuICAgICAgICAgICAgICAgICAgICBudWRnZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh4ID09PSB3aWR0aCkge1xuICAgICAgICAgICAgICAgICAgICBwb2ludHNbb2Zmc2V0XSA9IHdpZHRoIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgbnVkZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50c1tvZmZzZXQgKyAxXSA9IDAuMDtcbiAgICAgICAgICAgICAgICAgICAgbnVkZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoeSA9PT0gaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50c1tvZmZzZXQgKyAxXSA9IGhlaWdodCAtIDE7XG4gICAgICAgICAgICAgICAgICAgIG51ZGdlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ2hlY2sgYW5kIG51ZGdlIHBvaW50cyBmcm9tIGVuZDpcbiAgICAgICAgICAgIG51ZGdlZCA9IHRydWU7XG4gICAgICAgICAgICBmb3IgKGxldCBvZmZzZXQgPSBwb2ludHMubGVuZ3RoIC0gMjsgb2Zmc2V0ID49IDAgJiYgbnVkZ2VkOyBvZmZzZXQgLT0gMikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHggPSBNYXRoLmZsb29yKHBvaW50c1tvZmZzZXRdKTtcbiAgICAgICAgICAgICAgICBjb25zdCB5ID0gTWF0aC5mbG9vcihwb2ludHNbb2Zmc2V0ICsgMV0pO1xuICAgICAgICAgICAgICAgIGlmICh4IDwgLTEgfHwgeCA+IHdpZHRoIHx8IHkgPCAtMSB8fCB5ID4gaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBudWRnZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAoeCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzW29mZnNldF0gPSAwLjA7XG4gICAgICAgICAgICAgICAgICAgIG51ZGdlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHggPT09IHdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50c1tvZmZzZXRdID0gd2lkdGggLSAxO1xuICAgICAgICAgICAgICAgICAgICBudWRnZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoeSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzW29mZnNldCArIDFdID0gMC4wO1xuICAgICAgICAgICAgICAgICAgICBudWRnZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh5ID09PSBoZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzW29mZnNldCArIDFdID0gaGVpZ2h0IC0gMTtcbiAgICAgICAgICAgICAgICAgICAgbnVkZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKlxuICAgICAqIENvcHlyaWdodCAyMDA3IFpYaW5nIGF1dGhvcnNcbiAgICAgKlxuICAgICAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gICAgICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgICAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgICAqXG4gICAgICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAgICAgKlxuICAgICAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgICAgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICAgICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gICAgICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICAgICAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICAgICAqL1xuICAgIC8qbmFtZXNwYWNlIGNvbS5nb29nbGUuenhpbmcuY29tbW9uIHsqL1xuICAgIC8qKlxuICAgICAqIDxwPlRoaXMgY2xhc3MgaW1wbGVtZW50cyBhIHBlcnNwZWN0aXZlIHRyYW5zZm9ybSBpbiB0d28gZGltZW5zaW9ucy4gR2l2ZW4gZm91ciBzb3VyY2UgYW5kIGZvdXJcbiAgICAgKiBkZXN0aW5hdGlvbiBwb2ludHMsIGl0IHdpbGwgY29tcHV0ZSB0aGUgdHJhbnNmb3JtYXRpb24gaW1wbGllZCBiZXR3ZWVuIHRoZW0uIFRoZSBjb2RlIGlzIGJhc2VkXG4gICAgICogZGlyZWN0bHkgdXBvbiBzZWN0aW9uIDMuNC4yIG9mIEdlb3JnZSBXb2xiZXJnJ3MgXCJEaWdpdGFsIEltYWdlIFdhcnBpbmdcIjsgc2VlIHBhZ2VzIDU0LTU2LjwvcD5cbiAgICAgKlxuICAgICAqIEBhdXRob3IgU2VhbiBPd2VuXG4gICAgICovXG4gICAgY2xhc3MgUGVyc3BlY3RpdmVUcmFuc2Zvcm0ge1xuICAgICAgICBjb25zdHJ1Y3RvcihhMTEgLypmbG9hdCovLCBhMjEgLypmbG9hdCovLCBhMzEgLypmbG9hdCovLCBhMTIgLypmbG9hdCovLCBhMjIgLypmbG9hdCovLCBhMzIgLypmbG9hdCovLCBhMTMgLypmbG9hdCovLCBhMjMgLypmbG9hdCovLCBhMzMgLypmbG9hdCovKSB7XG4gICAgICAgICAgICB0aGlzLmExMSA9IGExMTtcbiAgICAgICAgICAgIHRoaXMuYTIxID0gYTIxO1xuICAgICAgICAgICAgdGhpcy5hMzEgPSBhMzE7XG4gICAgICAgICAgICB0aGlzLmExMiA9IGExMjtcbiAgICAgICAgICAgIHRoaXMuYTIyID0gYTIyO1xuICAgICAgICAgICAgdGhpcy5hMzIgPSBhMzI7XG4gICAgICAgICAgICB0aGlzLmExMyA9IGExMztcbiAgICAgICAgICAgIHRoaXMuYTIzID0gYTIzO1xuICAgICAgICAgICAgdGhpcy5hMzMgPSBhMzM7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIHF1YWRyaWxhdGVyYWxUb1F1YWRyaWxhdGVyYWwoeDAgLypmbG9hdCovLCB5MCAvKmZsb2F0Ki8sIHgxIC8qZmxvYXQqLywgeTEgLypmbG9hdCovLCB4MiAvKmZsb2F0Ki8sIHkyIC8qZmxvYXQqLywgeDMgLypmbG9hdCovLCB5MyAvKmZsb2F0Ki8sIHgwcCAvKmZsb2F0Ki8sIHkwcCAvKmZsb2F0Ki8sIHgxcCAvKmZsb2F0Ki8sIHkxcCAvKmZsb2F0Ki8sIHgycCAvKmZsb2F0Ki8sIHkycCAvKmZsb2F0Ki8sIHgzcCAvKmZsb2F0Ki8sIHkzcCAvKmZsb2F0Ki8pIHtcbiAgICAgICAgICAgIGNvbnN0IHFUb1MgPSBQZXJzcGVjdGl2ZVRyYW5zZm9ybS5xdWFkcmlsYXRlcmFsVG9TcXVhcmUoeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKTtcbiAgICAgICAgICAgIGNvbnN0IHNUb1EgPSBQZXJzcGVjdGl2ZVRyYW5zZm9ybS5zcXVhcmVUb1F1YWRyaWxhdGVyYWwoeDBwLCB5MHAsIHgxcCwgeTFwLCB4MnAsIHkycCwgeDNwLCB5M3ApO1xuICAgICAgICAgICAgcmV0dXJuIHNUb1EudGltZXMocVRvUyk7XG4gICAgICAgIH1cbiAgICAgICAgdHJhbnNmb3JtUG9pbnRzKHBvaW50cykge1xuICAgICAgICAgICAgY29uc3QgbWF4ID0gcG9pbnRzLmxlbmd0aDtcbiAgICAgICAgICAgIGNvbnN0IGExMSA9IHRoaXMuYTExO1xuICAgICAgICAgICAgY29uc3QgYTEyID0gdGhpcy5hMTI7XG4gICAgICAgICAgICBjb25zdCBhMTMgPSB0aGlzLmExMztcbiAgICAgICAgICAgIGNvbnN0IGEyMSA9IHRoaXMuYTIxO1xuICAgICAgICAgICAgY29uc3QgYTIyID0gdGhpcy5hMjI7XG4gICAgICAgICAgICBjb25zdCBhMjMgPSB0aGlzLmEyMztcbiAgICAgICAgICAgIGNvbnN0IGEzMSA9IHRoaXMuYTMxO1xuICAgICAgICAgICAgY29uc3QgYTMyID0gdGhpcy5hMzI7XG4gICAgICAgICAgICBjb25zdCBhMzMgPSB0aGlzLmEzMztcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF4OyBpICs9IDIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB4ID0gcG9pbnRzW2ldO1xuICAgICAgICAgICAgICAgIGNvbnN0IHkgPSBwb2ludHNbaSArIDFdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlbm9taW5hdG9yID0gYTEzICogeCArIGEyMyAqIHkgKyBhMzM7XG4gICAgICAgICAgICAgICAgcG9pbnRzW2ldID0gKGExMSAqIHggKyBhMjEgKiB5ICsgYTMxKSAvIGRlbm9taW5hdG9yO1xuICAgICAgICAgICAgICAgIHBvaW50c1tpICsgMV0gPSAoYTEyICogeCArIGEyMiAqIHkgKyBhMzIpIC8gZGVub21pbmF0b3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdHJhbnNmb3JtUG9pbnRzV2l0aFZhbHVlcyh4VmFsdWVzLCB5VmFsdWVzKSB7XG4gICAgICAgICAgICBjb25zdCBhMTEgPSB0aGlzLmExMTtcbiAgICAgICAgICAgIGNvbnN0IGExMiA9IHRoaXMuYTEyO1xuICAgICAgICAgICAgY29uc3QgYTEzID0gdGhpcy5hMTM7XG4gICAgICAgICAgICBjb25zdCBhMjEgPSB0aGlzLmEyMTtcbiAgICAgICAgICAgIGNvbnN0IGEyMiA9IHRoaXMuYTIyO1xuICAgICAgICAgICAgY29uc3QgYTIzID0gdGhpcy5hMjM7XG4gICAgICAgICAgICBjb25zdCBhMzEgPSB0aGlzLmEzMTtcbiAgICAgICAgICAgIGNvbnN0IGEzMiA9IHRoaXMuYTMyO1xuICAgICAgICAgICAgY29uc3QgYTMzID0gdGhpcy5hMzM7XG4gICAgICAgICAgICBjb25zdCBuID0geFZhbHVlcy5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHggPSB4VmFsdWVzW2ldO1xuICAgICAgICAgICAgICAgIGNvbnN0IHkgPSB5VmFsdWVzW2ldO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlbm9taW5hdG9yID0gYTEzICogeCArIGEyMyAqIHkgKyBhMzM7XG4gICAgICAgICAgICAgICAgeFZhbHVlc1tpXSA9IChhMTEgKiB4ICsgYTIxICogeSArIGEzMSkgLyBkZW5vbWluYXRvcjtcbiAgICAgICAgICAgICAgICB5VmFsdWVzW2ldID0gKGExMiAqIHggKyBhMjIgKiB5ICsgYTMyKSAvIGRlbm9taW5hdG9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBzcXVhcmVUb1F1YWRyaWxhdGVyYWwoeDAgLypmbG9hdCovLCB5MCAvKmZsb2F0Ki8sIHgxIC8qZmxvYXQqLywgeTEgLypmbG9hdCovLCB4MiAvKmZsb2F0Ki8sIHkyIC8qZmxvYXQqLywgeDMgLypmbG9hdCovLCB5MyAvKmZsb2F0Ki8pIHtcbiAgICAgICAgICAgIGNvbnN0IGR4MyA9IHgwIC0geDEgKyB4MiAtIHgzO1xuICAgICAgICAgICAgY29uc3QgZHkzID0geTAgLSB5MSArIHkyIC0geTM7XG4gICAgICAgICAgICBpZiAoZHgzID09PSAwLjAgJiYgZHkzID09PSAwLjApIHtcbiAgICAgICAgICAgICAgICAvLyBBZmZpbmVcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFBlcnNwZWN0aXZlVHJhbnNmb3JtKHgxIC0geDAsIHgyIC0geDEsIHgwLCB5MSAtIHkwLCB5MiAtIHkxLCB5MCwgMC4wLCAwLjAsIDEuMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkeDEgPSB4MSAtIHgyO1xuICAgICAgICAgICAgICAgIGNvbnN0IGR4MiA9IHgzIC0geDI7XG4gICAgICAgICAgICAgICAgY29uc3QgZHkxID0geTEgLSB5MjtcbiAgICAgICAgICAgICAgICBjb25zdCBkeTIgPSB5MyAtIHkyO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlbm9taW5hdG9yID0gZHgxICogZHkyIC0gZHgyICogZHkxO1xuICAgICAgICAgICAgICAgIGNvbnN0IGExMyA9IChkeDMgKiBkeTIgLSBkeDIgKiBkeTMpIC8gZGVub21pbmF0b3I7XG4gICAgICAgICAgICAgICAgY29uc3QgYTIzID0gKGR4MSAqIGR5MyAtIGR4MyAqIGR5MSkgLyBkZW5vbWluYXRvcjtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFBlcnNwZWN0aXZlVHJhbnNmb3JtKHgxIC0geDAgKyBhMTMgKiB4MSwgeDMgLSB4MCArIGEyMyAqIHgzLCB4MCwgeTEgLSB5MCArIGExMyAqIHkxLCB5MyAtIHkwICsgYTIzICogeTMsIHkwLCBhMTMsIGEyMywgMS4wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgcXVhZHJpbGF0ZXJhbFRvU3F1YXJlKHgwIC8qZmxvYXQqLywgeTAgLypmbG9hdCovLCB4MSAvKmZsb2F0Ki8sIHkxIC8qZmxvYXQqLywgeDIgLypmbG9hdCovLCB5MiAvKmZsb2F0Ki8sIHgzIC8qZmxvYXQqLywgeTMgLypmbG9hdCovKSB7XG4gICAgICAgICAgICAvLyBIZXJlLCB0aGUgYWRqb2ludCBzZXJ2ZXMgYXMgdGhlIGludmVyc2U6XG4gICAgICAgICAgICByZXR1cm4gUGVyc3BlY3RpdmVUcmFuc2Zvcm0uc3F1YXJlVG9RdWFkcmlsYXRlcmFsKHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHgzLCB5MykuYnVpbGRBZGpvaW50KCk7XG4gICAgICAgIH1cbiAgICAgICAgYnVpbGRBZGpvaW50KCkge1xuICAgICAgICAgICAgLy8gQWRqb2ludCBpcyB0aGUgdHJhbnNwb3NlIG9mIHRoZSBjb2ZhY3RvciBtYXRyaXg6XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBlcnNwZWN0aXZlVHJhbnNmb3JtKHRoaXMuYTIyICogdGhpcy5hMzMgLSB0aGlzLmEyMyAqIHRoaXMuYTMyLCB0aGlzLmEyMyAqIHRoaXMuYTMxIC0gdGhpcy5hMjEgKiB0aGlzLmEzMywgdGhpcy5hMjEgKiB0aGlzLmEzMiAtIHRoaXMuYTIyICogdGhpcy5hMzEsIHRoaXMuYTEzICogdGhpcy5hMzIgLSB0aGlzLmExMiAqIHRoaXMuYTMzLCB0aGlzLmExMSAqIHRoaXMuYTMzIC0gdGhpcy5hMTMgKiB0aGlzLmEzMSwgdGhpcy5hMTIgKiB0aGlzLmEzMSAtIHRoaXMuYTExICogdGhpcy5hMzIsIHRoaXMuYTEyICogdGhpcy5hMjMgLSB0aGlzLmExMyAqIHRoaXMuYTIyLCB0aGlzLmExMyAqIHRoaXMuYTIxIC0gdGhpcy5hMTEgKiB0aGlzLmEyMywgdGhpcy5hMTEgKiB0aGlzLmEyMiAtIHRoaXMuYTEyICogdGhpcy5hMjEpO1xuICAgICAgICB9XG4gICAgICAgIHRpbWVzKG90aGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBlcnNwZWN0aXZlVHJhbnNmb3JtKHRoaXMuYTExICogb3RoZXIuYTExICsgdGhpcy5hMjEgKiBvdGhlci5hMTIgKyB0aGlzLmEzMSAqIG90aGVyLmExMywgdGhpcy5hMTEgKiBvdGhlci5hMjEgKyB0aGlzLmEyMSAqIG90aGVyLmEyMiArIHRoaXMuYTMxICogb3RoZXIuYTIzLCB0aGlzLmExMSAqIG90aGVyLmEzMSArIHRoaXMuYTIxICogb3RoZXIuYTMyICsgdGhpcy5hMzEgKiBvdGhlci5hMzMsIHRoaXMuYTEyICogb3RoZXIuYTExICsgdGhpcy5hMjIgKiBvdGhlci5hMTIgKyB0aGlzLmEzMiAqIG90aGVyLmExMywgdGhpcy5hMTIgKiBvdGhlci5hMjEgKyB0aGlzLmEyMiAqIG90aGVyLmEyMiArIHRoaXMuYTMyICogb3RoZXIuYTIzLCB0aGlzLmExMiAqIG90aGVyLmEzMSArIHRoaXMuYTIyICogb3RoZXIuYTMyICsgdGhpcy5hMzIgKiBvdGhlci5hMzMsIHRoaXMuYTEzICogb3RoZXIuYTExICsgdGhpcy5hMjMgKiBvdGhlci5hMTIgKyB0aGlzLmEzMyAqIG90aGVyLmExMywgdGhpcy5hMTMgKiBvdGhlci5hMjEgKyB0aGlzLmEyMyAqIG90aGVyLmEyMiArIHRoaXMuYTMzICogb3RoZXIuYTIzLCB0aGlzLmExMyAqIG90aGVyLmEzMSArIHRoaXMuYTIzICogb3RoZXIuYTMyICsgdGhpcy5hMzMgKiBvdGhlci5hMzMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBDb3B5cmlnaHQgMjAwNyBaWGluZyBhdXRob3JzXG4gICAgICpcbiAgICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgICAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgICAgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgICAgKlxuICAgICAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gICAgICpcbiAgICAgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICAgICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgICAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICAgICAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgICAgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIFNlYW4gT3dlblxuICAgICAqL1xuICAgIGNsYXNzIERlZmF1bHRHcmlkU2FtcGxlciBleHRlbmRzIEdyaWRTYW1wbGVyIHtcbiAgICAgICAgLypAT3ZlcnJpZGUqL1xuICAgICAgICBzYW1wbGVHcmlkKGltYWdlLCBkaW1lbnNpb25YIC8qaW50Ki8sIGRpbWVuc2lvblkgLyppbnQqLywgcDFUb1ggLypmbG9hdCovLCBwMVRvWSAvKmZsb2F0Ki8sIHAyVG9YIC8qZmxvYXQqLywgcDJUb1kgLypmbG9hdCovLCBwM1RvWCAvKmZsb2F0Ki8sIHAzVG9ZIC8qZmxvYXQqLywgcDRUb1ggLypmbG9hdCovLCBwNFRvWSAvKmZsb2F0Ki8sIHAxRnJvbVggLypmbG9hdCovLCBwMUZyb21ZIC8qZmxvYXQqLywgcDJGcm9tWCAvKmZsb2F0Ki8sIHAyRnJvbVkgLypmbG9hdCovLCBwM0Zyb21YIC8qZmxvYXQqLywgcDNGcm9tWSAvKmZsb2F0Ki8sIHA0RnJvbVggLypmbG9hdCovLCBwNEZyb21ZIC8qZmxvYXQqLykge1xuICAgICAgICAgICAgY29uc3QgdHJhbnNmb3JtID0gUGVyc3BlY3RpdmVUcmFuc2Zvcm0ucXVhZHJpbGF0ZXJhbFRvUXVhZHJpbGF0ZXJhbChwMVRvWCwgcDFUb1ksIHAyVG9YLCBwMlRvWSwgcDNUb1gsIHAzVG9ZLCBwNFRvWCwgcDRUb1ksIHAxRnJvbVgsIHAxRnJvbVksIHAyRnJvbVgsIHAyRnJvbVksIHAzRnJvbVgsIHAzRnJvbVksIHA0RnJvbVgsIHA0RnJvbVkpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2FtcGxlR3JpZFdpdGhUcmFuc2Zvcm0oaW1hZ2UsIGRpbWVuc2lvblgsIGRpbWVuc2lvblksIHRyYW5zZm9ybSk7XG4gICAgICAgIH1cbiAgICAgICAgLypAT3ZlcnJpZGUqL1xuICAgICAgICBzYW1wbGVHcmlkV2l0aFRyYW5zZm9ybShpbWFnZSwgZGltZW5zaW9uWCAvKmludCovLCBkaW1lbnNpb25ZIC8qaW50Ki8sIHRyYW5zZm9ybSkge1xuICAgICAgICAgICAgaWYgKGRpbWVuc2lvblggPD0gMCB8fCBkaW1lbnNpb25ZIDw9IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGJpdHMgPSBuZXcgQml0TWF0cml4KGRpbWVuc2lvblgsIGRpbWVuc2lvblkpO1xuICAgICAgICAgICAgY29uc3QgcG9pbnRzID0gbmV3IEZsb2F0MzJBcnJheSgyICogZGltZW5zaW9uWCk7XG4gICAgICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IGRpbWVuc2lvblk7IHkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1heCA9IHBvaW50cy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgY29uc3QgaVZhbHVlID0geSArIDAuNTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IG1heDsgeCArPSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50c1t4XSA9ICh4IC8gMikgKyAwLjU7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50c1t4ICsgMV0gPSBpVmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybS50cmFuc2Zvcm1Qb2ludHMocG9pbnRzKTtcbiAgICAgICAgICAgICAgICAvLyBRdWljayBjaGVjayB0byBzZWUgaWYgcG9pbnRzIHRyYW5zZm9ybWVkIHRvIHNvbWV0aGluZyBpbnNpZGUgdGhlIGltYWdlXG4gICAgICAgICAgICAgICAgLy8gc3VmZmljaWVudCB0byBjaGVjayB0aGUgZW5kcG9pbnRzXG4gICAgICAgICAgICAgICAgR3JpZFNhbXBsZXIuY2hlY2tBbmROdWRnZVBvaW50cyhpbWFnZSwgcG9pbnRzKTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IG1heDsgeCArPSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW1hZ2UuZ2V0KE1hdGguZmxvb3IocG9pbnRzW3hdKSwgTWF0aC5mbG9vcihwb2ludHNbeCArIDFdKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBCbGFjaygtaXNoKSBwaXhlbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJpdHMuc2V0KHggLyAyLCB5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoYWlvb2JlIC8qOiBBcnJheUluZGV4T3V0T2ZCb3VuZHNFeGNlcHRpb24qLykge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGZlZWxzIHdyb25nLCBidXQsIHNvbWV0aW1lcyBpZiB0aGUgZmluZGVyIHBhdHRlcm5zIGFyZSBtaXNpZGVudGlmaWVkLCB0aGUgcmVzdWx0aW5nXG4gICAgICAgICAgICAgICAgICAgIC8vIHRyYW5zZm9ybSBnZXRzIFwidHdpc3RlZFwiIHN1Y2ggdGhhdCBpdCBtYXBzIGEgc3RyYWlnaHQgbGluZSBvZiBwb2ludHMgdG8gYSBzZXQgb2YgcG9pbnRzXG4gICAgICAgICAgICAgICAgICAgIC8vIHdob3NlIGVuZHBvaW50cyBhcmUgaW4gYm91bmRzLCBidXQgb3RoZXJzIGFyZSBub3QuIFRoZXJlIGlzIHByb2JhYmx5IHNvbWUgbWF0aGVtYXRpY2FsXG4gICAgICAgICAgICAgICAgICAgIC8vIHdheSB0byBkZXRlY3QgdGhpcyBhYm91dCB0aGUgdHJhbnNmb3JtYXRpb24gdGhhdCBJIGRvbid0IGtub3cgeWV0LlxuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIHJlc3VsdHMgaW4gYW4gdWdseSBydW50aW1lIGV4Y2VwdGlvbiBkZXNwaXRlIG91ciBjbGV2ZXIgY2hlY2tzIGFib3ZlIC0tIGNhbid0IGhhdmVcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhhdC4gV2UgY291bGQgY2hlY2sgZWFjaCBwb2ludCdzIGNvb3JkaW5hdGVzIGJ1dCB0aGF0IGZlZWxzIGR1cGxpY2F0aXZlLiBXZSBzZXR0bGUgZm9yXG4gICAgICAgICAgICAgICAgICAgIC8vIGNhdGNoaW5nIGFuZCB3cmFwcGluZyBBcnJheUluZGV4T3V0T2ZCb3VuZHNFeGNlcHRpb24uXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBiaXRzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY2xhc3MgR3JpZFNhbXBsZXJJbnN0YW5jZSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIHRoZSBpbXBsZW1lbnRhdGlvbiBvZiBHcmlkU2FtcGxlciB1c2VkIGJ5IHRoZSBsaWJyYXJ5LiBPbmUgZ2xvYmFsXG4gICAgICAgICAqIGluc3RhbmNlIGlzIHN0b3JlZCwgd2hpY2ggbWF5IHNvdW5kIHByb2JsZW1hdGljLiBCdXQsIHRoZSBpbXBsZW1lbnRhdGlvbiBwcm92aWRlZFxuICAgICAgICAgKiBvdWdodCB0byBiZSBhcHByb3ByaWF0ZSBmb3IgdGhlIGVudGlyZSBwbGF0Zm9ybSwgYW5kIGFsbCB1c2VzIG9mIHRoaXMgbGlicmFyeVxuICAgICAgICAgKiBpbiB0aGUgd2hvbGUgbGlmZXRpbWUgb2YgdGhlIEpWTS4gRm9yIGluc3RhbmNlLCBhbiBBbmRyb2lkIGFjdGl2aXR5IGNhbiBzd2FwIGluXG4gICAgICAgICAqIGFuIGltcGxlbWVudGF0aW9uIHRoYXQgdGFrZXMgYWR2YW50YWdlIG9mIG5hdGl2ZSBwbGF0Zm9ybSBsaWJyYXJpZXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBuZXdHcmlkU2FtcGxlciBUaGUgcGxhdGZvcm0tc3BlY2lmaWMgb2JqZWN0IHRvIGluc3RhbGwuXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgc2V0R3JpZFNhbXBsZXIobmV3R3JpZFNhbXBsZXIpIHtcbiAgICAgICAgICAgIEdyaWRTYW1wbGVySW5zdGFuY2UuZ3JpZFNhbXBsZXIgPSBuZXdHcmlkU2FtcGxlcjtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB0aGUgY3VycmVudCBpbXBsZW1lbnRhdGlvbiBvZiBHcmlkU2FtcGxlclxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGdldEluc3RhbmNlKCkge1xuICAgICAgICAgICAgcmV0dXJuIEdyaWRTYW1wbGVySW5zdGFuY2UuZ3JpZFNhbXBsZXI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgR3JpZFNhbXBsZXJJbnN0YW5jZS5ncmlkU2FtcGxlciA9IG5ldyBEZWZhdWx0R3JpZFNhbXBsZXIoKTtcblxuICAgIC8qXG4gICAgICogQ29weXJpZ2h0IDIwMTAgWlhpbmcgYXV0aG9yc1xuICAgICAqXG4gICAgICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgICAgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICAgICpcbiAgICAgKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICAgICAqXG4gICAgICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICAgICAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgICAgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgICAgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gICAgICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gICAgICovXG4gICAgY2xhc3MgUG9pbnQge1xuICAgICAgICBjb25zdHJ1Y3Rvcih4LCB5KSB7XG4gICAgICAgICAgICB0aGlzLnggPSB4O1xuICAgICAgICAgICAgdGhpcy55ID0geTtcbiAgICAgICAgfVxuICAgICAgICB0b1Jlc3VsdFBvaW50KCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZXN1bHRQb2ludCh0aGlzLmdldFgoKSwgdGhpcy5nZXRZKCkpO1xuICAgICAgICB9XG4gICAgICAgIGdldFgoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy54O1xuICAgICAgICB9XG4gICAgICAgIGdldFkoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy55O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuY2Fwc3VsYXRlcyBsb2dpYyB0aGF0IGNhbiBkZXRlY3QgYW4gQXp0ZWMgQ29kZSBpbiBhbiBpbWFnZSwgZXZlbiBpZiB0aGUgQXp0ZWMgQ29kZVxuICAgICAqIGlzIHJvdGF0ZWQgb3Igc2tld2VkLCBvciBwYXJ0aWFsbHkgb2JzY3VyZWQuXG4gICAgICpcbiAgICAgKiBAYXV0aG9yIERhdmlkIE9saXZpZXJcbiAgICAgKiBAYXV0aG9yIEZyYW5rIFllbGxpblxuICAgICAqL1xuICAgIGNsYXNzIERldGVjdG9yIHtcbiAgICAgICAgY29uc3RydWN0b3IoaW1hZ2UpIHtcbiAgICAgICAgICAgIHRoaXMuRVhQRUNURURfQ09STkVSX0JJVFMgPSBuZXcgSW50MzJBcnJheShbXG4gICAgICAgICAgICAgICAgMHhlZTAsXG4gICAgICAgICAgICAgICAgMHgxZGMsXG4gICAgICAgICAgICAgICAgMHg4M2IsXG4gICAgICAgICAgICAgICAgMHg3MDcsXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIHRoaXMuaW1hZ2UgPSBpbWFnZTtcbiAgICAgICAgfVxuICAgICAgICBkZXRlY3QoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZXRlY3RNaXJyb3IoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXRlY3RzIGFuIEF6dGVjIENvZGUgaW4gYW4gaW1hZ2UuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBpc01pcnJvciBpZiB0cnVlLCBpbWFnZSBpcyBhIG1pcnJvci1pbWFnZSBvZiBvcmlnaW5hbFxuICAgICAgICAgKiBAcmV0dXJuIHtAbGluayBBenRlY0RldGVjdG9yUmVzdWx0fSBlbmNhcHN1bGF0aW5nIHJlc3VsdHMgb2YgZGV0ZWN0aW5nIGFuIEF6dGVjIENvZGVcbiAgICAgICAgICogQHRocm93cyBOb3RGb3VuZEV4Y2VwdGlvbiBpZiBubyBBenRlYyBDb2RlIGNhbiBiZSBmb3VuZFxuICAgICAgICAgKi9cbiAgICAgICAgZGV0ZWN0TWlycm9yKGlzTWlycm9yKSB7XG4gICAgICAgICAgICAvLyAxLiBHZXQgdGhlIGNlbnRlciBvZiB0aGUgYXp0ZWMgbWF0cml4XG4gICAgICAgICAgICBsZXQgcENlbnRlciA9IHRoaXMuZ2V0TWF0cml4Q2VudGVyKCk7XG4gICAgICAgICAgICAvLyAyLiBHZXQgdGhlIGNlbnRlciBwb2ludHMgb2YgdGhlIGZvdXIgZGlhZ29uYWwgcG9pbnRzIGp1c3Qgb3V0c2lkZSB0aGUgYnVsbCdzIGV5ZVxuICAgICAgICAgICAgLy8gIFt0b3BSaWdodCwgYm90dG9tUmlnaHQsIGJvdHRvbUxlZnQsIHRvcExlZnRdXG4gICAgICAgICAgICBsZXQgYnVsbHNFeWVDb3JuZXJzID0gdGhpcy5nZXRCdWxsc0V5ZUNvcm5lcnMocENlbnRlcik7XG4gICAgICAgICAgICBpZiAoaXNNaXJyb3IpIHtcbiAgICAgICAgICAgICAgICBsZXQgdGVtcCA9IGJ1bGxzRXllQ29ybmVyc1swXTtcbiAgICAgICAgICAgICAgICBidWxsc0V5ZUNvcm5lcnNbMF0gPSBidWxsc0V5ZUNvcm5lcnNbMl07XG4gICAgICAgICAgICAgICAgYnVsbHNFeWVDb3JuZXJzWzJdID0gdGVtcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIDMuIEdldCB0aGUgc2l6ZSBvZiB0aGUgbWF0cml4IGFuZCBvdGhlciBwYXJhbWV0ZXJzIGZyb20gdGhlIGJ1bGwncyBleWVcbiAgICAgICAgICAgIHRoaXMuZXh0cmFjdFBhcmFtZXRlcnMoYnVsbHNFeWVDb3JuZXJzKTtcbiAgICAgICAgICAgIC8vIDQuIFNhbXBsZSB0aGUgZ3JpZFxuICAgICAgICAgICAgbGV0IGJpdHMgPSB0aGlzLnNhbXBsZUdyaWQodGhpcy5pbWFnZSwgYnVsbHNFeWVDb3JuZXJzW3RoaXMuc2hpZnQgJSA0XSwgYnVsbHNFeWVDb3JuZXJzWyh0aGlzLnNoaWZ0ICsgMSkgJSA0XSwgYnVsbHNFeWVDb3JuZXJzWyh0aGlzLnNoaWZ0ICsgMikgJSA0XSwgYnVsbHNFeWVDb3JuZXJzWyh0aGlzLnNoaWZ0ICsgMykgJSA0XSk7XG4gICAgICAgICAgICAvLyA1LiBHZXQgdGhlIGNvcm5lcnMgb2YgdGhlIG1hdHJpeC5cbiAgICAgICAgICAgIGxldCBjb3JuZXJzID0gdGhpcy5nZXRNYXRyaXhDb3JuZXJQb2ludHMoYnVsbHNFeWVDb3JuZXJzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQXp0ZWNEZXRlY3RvclJlc3VsdChiaXRzLCBjb3JuZXJzLCB0aGlzLmNvbXBhY3QsIHRoaXMubmJEYXRhQmxvY2tzLCB0aGlzLm5iTGF5ZXJzKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogRXh0cmFjdHMgdGhlIG51bWJlciBvZiBkYXRhIGxheWVycyBhbmQgZGF0YSBibG9ja3MgZnJvbSB0aGUgbGF5ZXIgYXJvdW5kIHRoZSBidWxsJ3MgZXllLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gYnVsbHNFeWVDb3JuZXJzIHRoZSBhcnJheSBvZiBidWxsJ3MgZXllIGNvcm5lcnNcbiAgICAgICAgICogQHRocm93cyBOb3RGb3VuZEV4Y2VwdGlvbiBpbiBjYXNlIG9mIHRvbyBtYW55IGVycm9ycyBvciBpbnZhbGlkIHBhcmFtZXRlcnNcbiAgICAgICAgICovXG4gICAgICAgIGV4dHJhY3RQYXJhbWV0ZXJzKGJ1bGxzRXllQ29ybmVycykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWRQb2ludChidWxsc0V5ZUNvcm5lcnNbMF0pIHx8ICF0aGlzLmlzVmFsaWRQb2ludChidWxsc0V5ZUNvcm5lcnNbMV0pIHx8XG4gICAgICAgICAgICAgICAgIXRoaXMuaXNWYWxpZFBvaW50KGJ1bGxzRXllQ29ybmVyc1syXSkgfHwgIXRoaXMuaXNWYWxpZFBvaW50KGJ1bGxzRXllQ29ybmVyc1szXSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBsZW5ndGggPSAyICogdGhpcy5uYkNlbnRlckxheWVycztcbiAgICAgICAgICAgIC8vIEdldCB0aGUgYml0cyBhcm91bmQgdGhlIGJ1bGwncyBleWVcbiAgICAgICAgICAgIGxldCBzaWRlcyA9IG5ldyBJbnQzMkFycmF5KFtcbiAgICAgICAgICAgICAgICB0aGlzLnNhbXBsZUxpbmUoYnVsbHNFeWVDb3JuZXJzWzBdLCBidWxsc0V5ZUNvcm5lcnNbMV0sIGxlbmd0aCksXG4gICAgICAgICAgICAgICAgdGhpcy5zYW1wbGVMaW5lKGJ1bGxzRXllQ29ybmVyc1sxXSwgYnVsbHNFeWVDb3JuZXJzWzJdLCBsZW5ndGgpLFxuICAgICAgICAgICAgICAgIHRoaXMuc2FtcGxlTGluZShidWxsc0V5ZUNvcm5lcnNbMl0sIGJ1bGxzRXllQ29ybmVyc1szXSwgbGVuZ3RoKSxcbiAgICAgICAgICAgICAgICB0aGlzLnNhbXBsZUxpbmUoYnVsbHNFeWVDb3JuZXJzWzNdLCBidWxsc0V5ZUNvcm5lcnNbMF0sIGxlbmd0aCkgLy8gVG9wXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIC8vIGJ1bGxzRXllQ29ybmVyc1tzaGlmdF0gaXMgdGhlIGNvcm5lciBvZiB0aGUgYnVsbHMnZXllIHRoYXQgaGFzIHRocmVlXG4gICAgICAgICAgICAvLyBvcmllbnRhdGlvbiBtYXJrcy5cbiAgICAgICAgICAgIC8vIHNpZGVzW3NoaWZ0XSBpcyB0aGUgcm93L2NvbHVtbiB0aGF0IGdvZXMgZnJvbSB0aGUgY29ybmVyIHdpdGggdGhyZWVcbiAgICAgICAgICAgIC8vIG9yaWVudGF0aW9uIG1hcmtzIHRvIHRoZSBjb3JuZXIgd2l0aCB0d28uXG4gICAgICAgICAgICB0aGlzLnNoaWZ0ID0gdGhpcy5nZXRSb3RhdGlvbihzaWRlcywgbGVuZ3RoKTtcbiAgICAgICAgICAgIC8vIEZsYXR0ZW4gdGhlIHBhcmFtZXRlciBiaXRzIGludG8gYSBzaW5nbGUgMjgtIG9yIDQwLWJpdCBsb25nXG4gICAgICAgICAgICBsZXQgcGFyYW1ldGVyRGF0YSA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBzaWRlID0gc2lkZXNbKHRoaXMuc2hpZnQgKyBpKSAlIDRdO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbXBhY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRWFjaCBzaWRlIG9mIHRoZSBmb3JtIC4uWFhYWFhYWC4gd2hlcmUgWHMgYXJlIHBhcmFtZXRlciBkYXRhXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtZXRlckRhdGEgPDw9IDc7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtZXRlckRhdGEgKz0gKHNpZGUgPj4gMSkgJiAweDdGO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRWFjaCBzaWRlIG9mIHRoZSBmb3JtIC4uWFhYWFguWFhYWFguIHdoZXJlIFhzIGFyZSBwYXJhbWV0ZXIgZGF0YVxuICAgICAgICAgICAgICAgICAgICBwYXJhbWV0ZXJEYXRhIDw8PSAxMDtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1ldGVyRGF0YSArPSAoKHNpZGUgPj4gMikgJiAoMHgxZiA8PCA1KSkgKyAoKHNpZGUgPj4gMSkgJiAweDFGKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDb3JyZWN0cyBwYXJhbWV0ZXIgZGF0YSB1c2luZyBSUy4gIFJldHVybnMganVzdCB0aGUgZGF0YSBwb3J0aW9uXG4gICAgICAgICAgICAvLyB3aXRob3V0IHRoZSBlcnJvciBjb3JyZWN0aW9uLlxuICAgICAgICAgICAgbGV0IGNvcnJlY3RlZERhdGEgPSB0aGlzLmdldENvcnJlY3RlZFBhcmFtZXRlckRhdGEocGFyYW1ldGVyRGF0YSwgdGhpcy5jb21wYWN0KTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbXBhY3QpIHtcbiAgICAgICAgICAgICAgICAvLyA4IGJpdHM6ICAyIGJpdHMgbGF5ZXJzIGFuZCA2IGJpdHMgZGF0YSBibG9ja3NcbiAgICAgICAgICAgICAgICB0aGlzLm5iTGF5ZXJzID0gKGNvcnJlY3RlZERhdGEgPj4gNikgKyAxO1xuICAgICAgICAgICAgICAgIHRoaXMubmJEYXRhQmxvY2tzID0gKGNvcnJlY3RlZERhdGEgJiAweDNGKSArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyAxNiBiaXRzOiAgNSBiaXRzIGxheWVycyBhbmQgMTEgYml0cyBkYXRhIGJsb2Nrc1xuICAgICAgICAgICAgICAgIHRoaXMubmJMYXllcnMgPSAoY29ycmVjdGVkRGF0YSA+PiAxMSkgKyAxO1xuICAgICAgICAgICAgICAgIHRoaXMubmJEYXRhQmxvY2tzID0gKGNvcnJlY3RlZERhdGEgJiAweDdGRikgKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGdldFJvdGF0aW9uKHNpZGVzLCBsZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIEluIGEgbm9ybWFsIHBhdHRlcm4sIHdlIGV4cGVjdCB0byBTZWVcbiAgICAgICAgICAgIC8vICAgKiogICAgLiogICAgICAgICAgICAgRCAgICAgICBBXG4gICAgICAgICAgICAvLyAgICogICAgICAqXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gICAuICAgICAgKlxuICAgICAgICAgICAgLy8gICAuLiAgICAuLiAgICAgICAgICAgICBDICAgICAgIEJcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBHcmFiIHRoZSAzIGJpdHMgZnJvbSBlYWNoIG9mIHRoZSBzaWRlcyB0aGUgZm9ybSB0aGUgbG9jYXRvciBwYXR0ZXJuIGFuZCBjb25jYXRlbmF0ZVxuICAgICAgICAgICAgLy8gaW50byBhIDEyLWJpdCBpbnRlZ2VyLiAgU3RhcnQgd2l0aCB0aGUgYml0IGF0IEFcbiAgICAgICAgICAgIGxldCBjb3JuZXJCaXRzID0gMDtcbiAgICAgICAgICAgIHNpZGVzLmZvckVhY2goKHNpZGUsIGlkeCwgYXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gWFguLi4uLi5YIHdoZXJlIFgncyBhcmUgb3JpZW50YXRpb24gbWFya3NcbiAgICAgICAgICAgICAgICBsZXQgdCA9ICgoc2lkZSA+PiAobGVuZ3RoIC0gMikpIDw8IDEpICsgKHNpZGUgJiAxKTtcbiAgICAgICAgICAgICAgICBjb3JuZXJCaXRzID0gKGNvcm5lckJpdHMgPDwgMykgKyB0O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBmb3IgKHZhciBzaWRlIGluIHNpZGVzKSB7XG4gICAgICAgICAgICAvLyAgICAgLy8gWFguLi4uLi5YIHdoZXJlIFgncyBhcmUgb3JpZW50YXRpb24gbWFya3NcbiAgICAgICAgICAgIC8vICAgICB2YXIgdCA9ICgoc2lkZSA+PiAobGVuZ3RoIC0gMikpIDw8IDEpICsgKHNpZGUgJiAxKTtcbiAgICAgICAgICAgIC8vICAgICBjb3JuZXJCaXRzID0gKGNvcm5lckJpdHMgPDwgMykgKyB0O1xuICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgLy8gTW92IHRoZSBib3R0b20gYml0IHRvIHRoZSB0b3AsIHNvIHRoYXQgdGhlIHRocmVlIGJpdHMgb2YgdGhlIGxvY2F0b3IgcGF0dGVybiBhdCBBIGFyZVxuICAgICAgICAgICAgLy8gdG9nZXRoZXIuICBjb3JuZXJCaXRzIGlzIG5vdzpcbiAgICAgICAgICAgIC8vICAzIG9yaWVudGF0aW9uIGJpdHMgYXQgQSB8fCAzIG9yaWVudGF0aW9uIGJpdHMgYXQgQiB8fCAuLi4gfHwgMyBvcmllbnRhdGlvbiBiaXRzIGF0IERcbiAgICAgICAgICAgIGNvcm5lckJpdHMgPSAoKGNvcm5lckJpdHMgJiAxKSA8PCAxMSkgKyAoY29ybmVyQml0cyA+PiAxKTtcbiAgICAgICAgICAgIC8vIFRoZSByZXN1bHQgc2hpZnQgaW5kaWNhdGVzIHdoaWNoIGVsZW1lbnQgb2YgQnVsbHNFeWVDb3JuZXJzW10gZ29lcyBpbnRvIHRoZSB0b3AtbGVmdFxuICAgICAgICAgICAgLy8gY29ybmVyLiBTaW5jZSB0aGUgZm91ciByb3RhdGlvbiB2YWx1ZXMgaGF2ZSBhIEhhbW1pbmcgZGlzdGFuY2Ugb2YgOCwgd2VcbiAgICAgICAgICAgIC8vIGNhbiBlYXNpbHkgdG9sZXJhdGUgdHdvIGVycm9ycy5cbiAgICAgICAgICAgIGZvciAobGV0IHNoaWZ0ID0gMDsgc2hpZnQgPCA0OyBzaGlmdCsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKEludGVnZXIuYml0Q291bnQoY29ybmVyQml0cyBeIHRoaXMuRVhQRUNURURfQ09STkVSX0JJVFNbc2hpZnRdKSA8PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzaGlmdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ29ycmVjdHMgdGhlIHBhcmFtZXRlciBiaXRzIHVzaW5nIFJlZWQtU29sb21vbiBhbGdvcml0aG0uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBwYXJhbWV0ZXJEYXRhIHBhcmFtZXRlciBiaXRzXG4gICAgICAgICAqIEBwYXJhbSBjb21wYWN0IHRydWUgaWYgdGhpcyBpcyBhIGNvbXBhY3QgQXp0ZWMgY29kZVxuICAgICAgICAgKiBAdGhyb3dzIE5vdEZvdW5kRXhjZXB0aW9uIGlmIHRoZSBhcnJheSBjb250YWlucyB0b28gbWFueSBlcnJvcnNcbiAgICAgICAgICovXG4gICAgICAgIGdldENvcnJlY3RlZFBhcmFtZXRlckRhdGEocGFyYW1ldGVyRGF0YSwgY29tcGFjdCkge1xuICAgICAgICAgICAgbGV0IG51bUNvZGV3b3JkcztcbiAgICAgICAgICAgIGxldCBudW1EYXRhQ29kZXdvcmRzO1xuICAgICAgICAgICAgaWYgKGNvbXBhY3QpIHtcbiAgICAgICAgICAgICAgICBudW1Db2Rld29yZHMgPSA3O1xuICAgICAgICAgICAgICAgIG51bURhdGFDb2Rld29yZHMgPSAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbnVtQ29kZXdvcmRzID0gMTA7XG4gICAgICAgICAgICAgICAgbnVtRGF0YUNvZGV3b3JkcyA9IDQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgbnVtRUNDb2Rld29yZHMgPSBudW1Db2Rld29yZHMgLSBudW1EYXRhQ29kZXdvcmRzO1xuICAgICAgICAgICAgbGV0IHBhcmFtZXRlcldvcmRzID0gbmV3IEludDMyQXJyYXkobnVtQ29kZXdvcmRzKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBudW1Db2Rld29yZHMgLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICAgICAgICAgIHBhcmFtZXRlcldvcmRzW2ldID0gcGFyYW1ldGVyRGF0YSAmIDB4RjtcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJEYXRhID4+PSA0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBsZXQgcnNEZWNvZGVyID0gbmV3IFJlZWRTb2xvbW9uRGVjb2RlcihHZW5lcmljR0YuQVpURUNfUEFSQU0pO1xuICAgICAgICAgICAgICAgIHJzRGVjb2Rlci5kZWNvZGUocGFyYW1ldGVyV29yZHMsIG51bUVDQ29kZXdvcmRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChpZ25vcmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUb3NzIHRoZSBlcnJvciBjb3JyZWN0aW9uLiAgSnVzdCByZXR1cm4gdGhlIGRhdGEgYXMgYW4gaW50ZWdlclxuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bURhdGFDb2Rld29yZHM7IGkrKykge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IChyZXN1bHQgPDwgNCkgKyBwYXJhbWV0ZXJXb3Jkc1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpbmRzIHRoZSBjb3JuZXJzIG9mIGEgYnVsbC1leWUgY2VudGVyZWQgb24gdGhlIHBhc3NlZCBwb2ludC5cbiAgICAgICAgICogVGhpcyByZXR1cm5zIHRoZSBjZW50ZXJzIG9mIHRoZSBkaWFnb25hbCBwb2ludHMganVzdCBvdXRzaWRlIHRoZSBidWxsJ3MgZXllXG4gICAgICAgICAqIFJldHVybnMgW3RvcFJpZ2h0LCBib3R0b21SaWdodCwgYm90dG9tTGVmdCwgdG9wTGVmdF1cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHBDZW50ZXIgQ2VudGVyIHBvaW50XG4gICAgICAgICAqIEByZXR1cm4gVGhlIGNvcm5lcnMgb2YgdGhlIGJ1bGwtZXllXG4gICAgICAgICAqIEB0aHJvd3MgTm90Rm91bmRFeGNlcHRpb24gSWYgbm8gdmFsaWQgYnVsbC1leWUgY2FuIGJlIGZvdW5kXG4gICAgICAgICAqL1xuICAgICAgICBnZXRCdWxsc0V5ZUNvcm5lcnMocENlbnRlcikge1xuICAgICAgICAgICAgbGV0IHBpbmEgPSBwQ2VudGVyO1xuICAgICAgICAgICAgbGV0IHBpbmIgPSBwQ2VudGVyO1xuICAgICAgICAgICAgbGV0IHBpbmMgPSBwQ2VudGVyO1xuICAgICAgICAgICAgbGV0IHBpbmQgPSBwQ2VudGVyO1xuICAgICAgICAgICAgbGV0IGNvbG9yID0gdHJ1ZTtcbiAgICAgICAgICAgIGZvciAodGhpcy5uYkNlbnRlckxheWVycyA9IDE7IHRoaXMubmJDZW50ZXJMYXllcnMgPCA5OyB0aGlzLm5iQ2VudGVyTGF5ZXJzKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgcG91dGEgPSB0aGlzLmdldEZpcnN0RGlmZmVyZW50KHBpbmEsIGNvbG9yLCAxLCAtMSk7XG4gICAgICAgICAgICAgICAgbGV0IHBvdXRiID0gdGhpcy5nZXRGaXJzdERpZmZlcmVudChwaW5iLCBjb2xvciwgMSwgMSk7XG4gICAgICAgICAgICAgICAgbGV0IHBvdXRjID0gdGhpcy5nZXRGaXJzdERpZmZlcmVudChwaW5jLCBjb2xvciwgLTEsIDEpO1xuICAgICAgICAgICAgICAgIGxldCBwb3V0ZCA9IHRoaXMuZ2V0Rmlyc3REaWZmZXJlbnQocGluZCwgY29sb3IsIC0xLCAtMSk7XG4gICAgICAgICAgICAgICAgLy8gZCAgICAgIGFcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIGMgICAgICBiXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubmJDZW50ZXJMYXllcnMgPiAyKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBxID0gKHRoaXMuZGlzdGFuY2VQb2ludChwb3V0ZCwgcG91dGEpICogdGhpcy5uYkNlbnRlckxheWVycykgLyAodGhpcy5kaXN0YW5jZVBvaW50KHBpbmQsIHBpbmEpICogKHRoaXMubmJDZW50ZXJMYXllcnMgKyAyKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChxIDwgMC43NSB8fCBxID4gMS4yNSB8fCAhdGhpcy5pc1doaXRlT3JCbGFja1JlY3RhbmdsZShwb3V0YSwgcG91dGIsIHBvdXRjLCBwb3V0ZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBpbmEgPSBwb3V0YTtcbiAgICAgICAgICAgICAgICBwaW5iID0gcG91dGI7XG4gICAgICAgICAgICAgICAgcGluYyA9IHBvdXRjO1xuICAgICAgICAgICAgICAgIHBpbmQgPSBwb3V0ZDtcbiAgICAgICAgICAgICAgICBjb2xvciA9ICFjb2xvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLm5iQ2VudGVyTGF5ZXJzICE9PSA1ICYmIHRoaXMubmJDZW50ZXJMYXllcnMgIT09IDcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY29tcGFjdCA9IHRoaXMubmJDZW50ZXJMYXllcnMgPT09IDU7XG4gICAgICAgICAgICAvLyBFeHBhbmQgdGhlIHNxdWFyZSBieSAuNSBwaXhlbCBpbiBlYWNoIGRpcmVjdGlvbiBzbyB0aGF0IHdlJ3JlIG9uIHRoZSBib3JkZXJcbiAgICAgICAgICAgIC8vIGJldHdlZW4gdGhlIHdoaXRlIHNxdWFyZSBhbmQgdGhlIGJsYWNrIHNxdWFyZVxuICAgICAgICAgICAgbGV0IHBpbmF4ID0gbmV3IFJlc3VsdFBvaW50KHBpbmEuZ2V0WCgpICsgMC41LCBwaW5hLmdldFkoKSAtIDAuNSk7XG4gICAgICAgICAgICBsZXQgcGluYnggPSBuZXcgUmVzdWx0UG9pbnQocGluYi5nZXRYKCkgKyAwLjUsIHBpbmIuZ2V0WSgpICsgMC41KTtcbiAgICAgICAgICAgIGxldCBwaW5jeCA9IG5ldyBSZXN1bHRQb2ludChwaW5jLmdldFgoKSAtIDAuNSwgcGluYy5nZXRZKCkgKyAwLjUpO1xuICAgICAgICAgICAgbGV0IHBpbmR4ID0gbmV3IFJlc3VsdFBvaW50KHBpbmQuZ2V0WCgpIC0gMC41LCBwaW5kLmdldFkoKSAtIDAuNSk7XG4gICAgICAgICAgICAvLyBFeHBhbmQgdGhlIHNxdWFyZSBzbyB0aGF0IGl0cyBjb3JuZXJzIGFyZSB0aGUgY2VudGVycyBvZiB0aGUgcG9pbnRzXG4gICAgICAgICAgICAvLyBqdXN0IG91dHNpZGUgdGhlIGJ1bGwncyBleWUuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5leHBhbmRTcXVhcmUoW3BpbmF4LCBwaW5ieCwgcGluY3gsIHBpbmR4XSwgMiAqIHRoaXMubmJDZW50ZXJMYXllcnMgLSAzLCAyICogdGhpcy5uYkNlbnRlckxheWVycyk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpbmRzIGEgY2FuZGlkYXRlIGNlbnRlciBwb2ludCBvZiBhbiBBenRlYyBjb2RlIGZyb20gYW4gaW1hZ2VcbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB0aGUgY2VudGVyIHBvaW50XG4gICAgICAgICAqL1xuICAgICAgICBnZXRNYXRyaXhDZW50ZXIoKSB7XG4gICAgICAgICAgICBsZXQgcG9pbnRBO1xuICAgICAgICAgICAgbGV0IHBvaW50QjtcbiAgICAgICAgICAgIGxldCBwb2ludEM7XG4gICAgICAgICAgICBsZXQgcG9pbnREO1xuICAgICAgICAgICAgLy8gR2V0IGEgd2hpdGUgcmVjdGFuZ2xlIHRoYXQgY2FuIGJlIHRoZSBib3JkZXIgb2YgdGhlIG1hdHJpeCBpbiBjZW50ZXIgYnVsbCdzIGV5ZSBvclxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBsZXQgY29ybmVyUG9pbnRzID0gbmV3IFdoaXRlUmVjdGFuZ2xlRGV0ZWN0b3IodGhpcy5pbWFnZSkuZGV0ZWN0KCk7XG4gICAgICAgICAgICAgICAgcG9pbnRBID0gY29ybmVyUG9pbnRzWzBdO1xuICAgICAgICAgICAgICAgIHBvaW50QiA9IGNvcm5lclBvaW50c1sxXTtcbiAgICAgICAgICAgICAgICBwb2ludEMgPSBjb3JuZXJQb2ludHNbMl07XG4gICAgICAgICAgICAgICAgcG9pbnREID0gY29ybmVyUG9pbnRzWzNdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGV4Y2VwdGlvbiBjYW4gYmUgaW4gY2FzZSB0aGUgaW5pdGlhbCByZWN0YW5nbGUgaXMgd2hpdGVcbiAgICAgICAgICAgICAgICAvLyBJbiB0aGF0IGNhc2UsIHN1cmVseSBpbiB0aGUgYnVsbCdzIGV5ZSwgd2UgdHJ5IHRvIGV4cGFuZCB0aGUgcmVjdGFuZ2xlLlxuICAgICAgICAgICAgICAgIGxldCBjeCA9IHRoaXMuaW1hZ2UuZ2V0V2lkdGgoKSAvIDI7XG4gICAgICAgICAgICAgICAgbGV0IGN5ID0gdGhpcy5pbWFnZS5nZXRIZWlnaHQoKSAvIDI7XG4gICAgICAgICAgICAgICAgcG9pbnRBID0gdGhpcy5nZXRGaXJzdERpZmZlcmVudChuZXcgUG9pbnQoY3ggKyA3LCBjeSAtIDcpLCBmYWxzZSwgMSwgLTEpLnRvUmVzdWx0UG9pbnQoKTtcbiAgICAgICAgICAgICAgICBwb2ludEIgPSB0aGlzLmdldEZpcnN0RGlmZmVyZW50KG5ldyBQb2ludChjeCArIDcsIGN5ICsgNyksIGZhbHNlLCAxLCAxKS50b1Jlc3VsdFBvaW50KCk7XG4gICAgICAgICAgICAgICAgcG9pbnRDID0gdGhpcy5nZXRGaXJzdERpZmZlcmVudChuZXcgUG9pbnQoY3ggLSA3LCBjeSArIDcpLCBmYWxzZSwgLTEsIDEpLnRvUmVzdWx0UG9pbnQoKTtcbiAgICAgICAgICAgICAgICBwb2ludEQgPSB0aGlzLmdldEZpcnN0RGlmZmVyZW50KG5ldyBQb2ludChjeCAtIDcsIGN5IC0gNyksIGZhbHNlLCAtMSwgLTEpLnRvUmVzdWx0UG9pbnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENvbXB1dGUgdGhlIGNlbnRlciBvZiB0aGUgcmVjdGFuZ2xlXG4gICAgICAgICAgICBsZXQgY3ggPSBNYXRoVXRpbHMucm91bmQoKHBvaW50QS5nZXRYKCkgKyBwb2ludEQuZ2V0WCgpICsgcG9pbnRCLmdldFgoKSArIHBvaW50Qy5nZXRYKCkpIC8gNC4wKTtcbiAgICAgICAgICAgIGxldCBjeSA9IE1hdGhVdGlscy5yb3VuZCgocG9pbnRBLmdldFkoKSArIHBvaW50RC5nZXRZKCkgKyBwb2ludEIuZ2V0WSgpICsgcG9pbnRDLmdldFkoKSkgLyA0LjApO1xuICAgICAgICAgICAgLy8gUmVkZXRlcm1pbmUgdGhlIHdoaXRlIHJlY3RhbmdsZSBzdGFydGluZyBmcm9tIHByZXZpb3VzbHkgY29tcHV0ZWQgY2VudGVyLlxuICAgICAgICAgICAgLy8gVGhpcyB3aWxsIGVuc3VyZSB0aGF0IHdlIGVuZCB1cCB3aXRoIGEgd2hpdGUgcmVjdGFuZ2xlIGluIGNlbnRlciBidWxsJ3MgZXllXG4gICAgICAgICAgICAvLyBpbiBvcmRlciB0byBjb21wdXRlIGEgbW9yZSBhY2N1cmF0ZSBjZW50ZXIuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGxldCBjb3JuZXJQb2ludHMgPSBuZXcgV2hpdGVSZWN0YW5nbGVEZXRlY3Rvcih0aGlzLmltYWdlLCAxNSwgY3gsIGN5KS5kZXRlY3QoKTtcbiAgICAgICAgICAgICAgICBwb2ludEEgPSBjb3JuZXJQb2ludHNbMF07XG4gICAgICAgICAgICAgICAgcG9pbnRCID0gY29ybmVyUG9pbnRzWzFdO1xuICAgICAgICAgICAgICAgIHBvaW50QyA9IGNvcm5lclBvaW50c1syXTtcbiAgICAgICAgICAgICAgICBwb2ludEQgPSBjb3JuZXJQb2ludHNbM107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgZXhjZXB0aW9uIGNhbiBiZSBpbiBjYXNlIHRoZSBpbml0aWFsIHJlY3RhbmdsZSBpcyB3aGl0ZVxuICAgICAgICAgICAgICAgIC8vIEluIHRoYXQgY2FzZSB3ZSB0cnkgdG8gZXhwYW5kIHRoZSByZWN0YW5nbGUuXG4gICAgICAgICAgICAgICAgcG9pbnRBID0gdGhpcy5nZXRGaXJzdERpZmZlcmVudChuZXcgUG9pbnQoY3ggKyA3LCBjeSAtIDcpLCBmYWxzZSwgMSwgLTEpLnRvUmVzdWx0UG9pbnQoKTtcbiAgICAgICAgICAgICAgICBwb2ludEIgPSB0aGlzLmdldEZpcnN0RGlmZmVyZW50KG5ldyBQb2ludChjeCArIDcsIGN5ICsgNyksIGZhbHNlLCAxLCAxKS50b1Jlc3VsdFBvaW50KCk7XG4gICAgICAgICAgICAgICAgcG9pbnRDID0gdGhpcy5nZXRGaXJzdERpZmZlcmVudChuZXcgUG9pbnQoY3ggLSA3LCBjeSArIDcpLCBmYWxzZSwgLTEsIDEpLnRvUmVzdWx0UG9pbnQoKTtcbiAgICAgICAgICAgICAgICBwb2ludEQgPSB0aGlzLmdldEZpcnN0RGlmZmVyZW50KG5ldyBQb2ludChjeCAtIDcsIGN5IC0gNyksIGZhbHNlLCAtMSwgLTEpLnRvUmVzdWx0UG9pbnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJlY29tcHV0ZSB0aGUgY2VudGVyIG9mIHRoZSByZWN0YW5nbGVcbiAgICAgICAgICAgIGN4ID0gTWF0aFV0aWxzLnJvdW5kKChwb2ludEEuZ2V0WCgpICsgcG9pbnRELmdldFgoKSArIHBvaW50Qi5nZXRYKCkgKyBwb2ludEMuZ2V0WCgpKSAvIDQuMCk7XG4gICAgICAgICAgICBjeSA9IE1hdGhVdGlscy5yb3VuZCgocG9pbnRBLmdldFkoKSArIHBvaW50RC5nZXRZKCkgKyBwb2ludEIuZ2V0WSgpICsgcG9pbnRDLmdldFkoKSkgLyA0LjApO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludChjeCwgY3kpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIHRoZSBBenRlYyBjb2RlIGNvcm5lcnMgZnJvbSB0aGUgYnVsbCdzIGV5ZSBjb3JuZXJzIGFuZCB0aGUgcGFyYW1ldGVycy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGJ1bGxzRXllQ29ybmVycyB0aGUgYXJyYXkgb2YgYnVsbCdzIGV5ZSBjb3JuZXJzXG4gICAgICAgICAqIEByZXR1cm4gdGhlIGFycmF5IG9mIGF6dGVjIGNvZGUgY29ybmVyc1xuICAgICAgICAgKi9cbiAgICAgICAgZ2V0TWF0cml4Q29ybmVyUG9pbnRzKGJ1bGxzRXllQ29ybmVycykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXhwYW5kU3F1YXJlKGJ1bGxzRXllQ29ybmVycywgMiAqIHRoaXMubmJDZW50ZXJMYXllcnMsIHRoaXMuZ2V0RGltZW5zaW9uKCkpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgQml0TWF0cml4IGJ5IHNhbXBsaW5nIHRoZSBwcm92aWRlZCBpbWFnZS5cbiAgICAgICAgICogdG9wTGVmdCwgdG9wUmlnaHQsIGJvdHRvbVJpZ2h0LCBhbmQgYm90dG9tTGVmdCBhcmUgdGhlIGNlbnRlcnMgb2YgdGhlIHNxdWFyZXMgb24gdGhlXG4gICAgICAgICAqIGRpYWdvbmFsIGp1c3Qgb3V0c2lkZSB0aGUgYnVsbCdzIGV5ZS5cbiAgICAgICAgICovXG4gICAgICAgIHNhbXBsZUdyaWQoaW1hZ2UsIHRvcExlZnQsIHRvcFJpZ2h0LCBib3R0b21SaWdodCwgYm90dG9tTGVmdCkge1xuICAgICAgICAgICAgbGV0IHNhbXBsZXIgPSBHcmlkU2FtcGxlckluc3RhbmNlLmdldEluc3RhbmNlKCk7XG4gICAgICAgICAgICBsZXQgZGltZW5zaW9uID0gdGhpcy5nZXREaW1lbnNpb24oKTtcbiAgICAgICAgICAgIGxldCBsb3cgPSBkaW1lbnNpb24gLyAyIC0gdGhpcy5uYkNlbnRlckxheWVycztcbiAgICAgICAgICAgIGxldCBoaWdoID0gZGltZW5zaW9uIC8gMiArIHRoaXMubmJDZW50ZXJMYXllcnM7XG4gICAgICAgICAgICByZXR1cm4gc2FtcGxlci5zYW1wbGVHcmlkKGltYWdlLCBkaW1lbnNpb24sIGRpbWVuc2lvbiwgbG93LCBsb3csIC8vIHRvcGxlZnRcbiAgICAgICAgICAgIGhpZ2gsIGxvdywgLy8gdG9wcmlnaHRcbiAgICAgICAgICAgIGhpZ2gsIGhpZ2gsIC8vIGJvdHRvbXJpZ2h0XG4gICAgICAgICAgICBsb3csIGhpZ2gsIC8vIGJvdHRvbWxlZnRcbiAgICAgICAgICAgIHRvcExlZnQuZ2V0WCgpLCB0b3BMZWZ0LmdldFkoKSwgdG9wUmlnaHQuZ2V0WCgpLCB0b3BSaWdodC5nZXRZKCksIGJvdHRvbVJpZ2h0LmdldFgoKSwgYm90dG9tUmlnaHQuZ2V0WSgpLCBib3R0b21MZWZ0LmdldFgoKSwgYm90dG9tTGVmdC5nZXRZKCkpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTYW1wbGVzIGEgbGluZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHAxICAgc3RhcnQgcG9pbnQgKGluY2x1c2l2ZSlcbiAgICAgICAgICogQHBhcmFtIHAyICAgZW5kIHBvaW50IChleGNsdXNpdmUpXG4gICAgICAgICAqIEBwYXJhbSBzaXplIG51bWJlciBvZiBiaXRzXG4gICAgICAgICAqIEByZXR1cm4gdGhlIGFycmF5IG9mIGJpdHMgYXMgYW4gaW50IChmaXJzdCBiaXQgaXMgaGlnaC1vcmRlciBiaXQgb2YgcmVzdWx0KVxuICAgICAgICAgKi9cbiAgICAgICAgc2FtcGxlTGluZShwMSwgcDIsIHNpemUpIHtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSAwO1xuICAgICAgICAgICAgbGV0IGQgPSB0aGlzLmRpc3RhbmNlUmVzdWx0UG9pbnQocDEsIHAyKTtcbiAgICAgICAgICAgIGxldCBtb2R1bGVTaXplID0gZCAvIHNpemU7XG4gICAgICAgICAgICBsZXQgcHggPSBwMS5nZXRYKCk7XG4gICAgICAgICAgICBsZXQgcHkgPSBwMS5nZXRZKCk7XG4gICAgICAgICAgICBsZXQgZHggPSBtb2R1bGVTaXplICogKHAyLmdldFgoKSAtIHAxLmdldFgoKSkgLyBkO1xuICAgICAgICAgICAgbGV0IGR5ID0gbW9kdWxlU2l6ZSAqIChwMi5nZXRZKCkgLSBwMS5nZXRZKCkpIC8gZDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaW1hZ2UuZ2V0KE1hdGhVdGlscy5yb3VuZChweCArIGkgKiBkeCksIE1hdGhVdGlscy5yb3VuZChweSArIGkgKiBkeSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCB8PSAxIDw8IChzaXplIC0gaSAtIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gdHJ1ZSBpZiB0aGUgYm9yZGVyIG9mIHRoZSByZWN0YW5nbGUgcGFzc2VkIGluIHBhcmFtZXRlciBpcyBjb21wb3VuZCBvZiB3aGl0ZSBwb2ludHMgb25seVxuICAgICAgICAgKiAgICAgICAgIG9yIGJsYWNrIHBvaW50cyBvbmx5XG4gICAgICAgICAqL1xuICAgICAgICBpc1doaXRlT3JCbGFja1JlY3RhbmdsZShwMSwgcDIsIHAzLCBwNCkge1xuICAgICAgICAgICAgbGV0IGNvcnIgPSAzO1xuICAgICAgICAgICAgcDEgPSBuZXcgUG9pbnQocDEuZ2V0WCgpIC0gY29yciwgcDEuZ2V0WSgpICsgY29ycik7XG4gICAgICAgICAgICBwMiA9IG5ldyBQb2ludChwMi5nZXRYKCkgLSBjb3JyLCBwMi5nZXRZKCkgLSBjb3JyKTtcbiAgICAgICAgICAgIHAzID0gbmV3IFBvaW50KHAzLmdldFgoKSArIGNvcnIsIHAzLmdldFkoKSAtIGNvcnIpO1xuICAgICAgICAgICAgcDQgPSBuZXcgUG9pbnQocDQuZ2V0WCgpICsgY29yciwgcDQuZ2V0WSgpICsgY29ycik7XG4gICAgICAgICAgICBsZXQgY0luaXQgPSB0aGlzLmdldENvbG9yKHA0LCBwMSk7XG4gICAgICAgICAgICBpZiAoY0luaXQgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgYyA9IHRoaXMuZ2V0Q29sb3IocDEsIHAyKTtcbiAgICAgICAgICAgIGlmIChjICE9PSBjSW5pdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGMgPSB0aGlzLmdldENvbG9yKHAyLCBwMyk7XG4gICAgICAgICAgICBpZiAoYyAhPT0gY0luaXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjID0gdGhpcy5nZXRDb2xvcihwMywgcDQpO1xuICAgICAgICAgICAgcmV0dXJuIGMgPT09IGNJbml0O1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIHRoZSBjb2xvciBvZiBhIHNlZ21lbnRcbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiAxIGlmIHNlZ21lbnQgbW9yZSB0aGFuIDkwJSBibGFjaywgLTEgaWYgc2VnbWVudCBpcyBtb3JlIHRoYW4gOTAlIHdoaXRlLCAwIGVsc2VcbiAgICAgICAgICovXG4gICAgICAgIGdldENvbG9yKHAxLCBwMikge1xuICAgICAgICAgICAgbGV0IGQgPSB0aGlzLmRpc3RhbmNlUG9pbnQocDEsIHAyKTtcbiAgICAgICAgICAgIGxldCBkeCA9IChwMi5nZXRYKCkgLSBwMS5nZXRYKCkpIC8gZDtcbiAgICAgICAgICAgIGxldCBkeSA9IChwMi5nZXRZKCkgLSBwMS5nZXRZKCkpIC8gZDtcbiAgICAgICAgICAgIGxldCBlcnJvciA9IDA7XG4gICAgICAgICAgICBsZXQgcHggPSBwMS5nZXRYKCk7XG4gICAgICAgICAgICBsZXQgcHkgPSBwMS5nZXRZKCk7XG4gICAgICAgICAgICBsZXQgY29sb3JNb2RlbCA9IHRoaXMuaW1hZ2UuZ2V0KHAxLmdldFgoKSwgcDEuZ2V0WSgpKTtcbiAgICAgICAgICAgIGxldCBpTWF4ID0gTWF0aC5jZWlsKGQpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpTWF4OyBpKyspIHtcbiAgICAgICAgICAgICAgICBweCArPSBkeDtcbiAgICAgICAgICAgICAgICBweSArPSBkeTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pbWFnZS5nZXQoTWF0aFV0aWxzLnJvdW5kKHB4KSwgTWF0aFV0aWxzLnJvdW5kKHB5KSkgIT09IGNvbG9yTW9kZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZXJyUmF0aW8gPSBlcnJvciAvIGQ7XG4gICAgICAgICAgICBpZiAoZXJyUmF0aW8gPiAwLjEgJiYgZXJyUmF0aW8gPCAwLjkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAoZXJyUmF0aW8gPD0gMC4xKSA9PT0gY29sb3JNb2RlbCA/IDEgOiAtMTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0cyB0aGUgY29vcmRpbmF0ZSBvZiB0aGUgZmlyc3QgcG9pbnQgd2l0aCBhIGRpZmZlcmVudCBjb2xvciBpbiB0aGUgZ2l2ZW4gZGlyZWN0aW9uXG4gICAgICAgICAqL1xuICAgICAgICBnZXRGaXJzdERpZmZlcmVudChpbml0LCBjb2xvciwgZHgsIGR5KSB7XG4gICAgICAgICAgICBsZXQgeCA9IGluaXQuZ2V0WCgpICsgZHg7XG4gICAgICAgICAgICBsZXQgeSA9IGluaXQuZ2V0WSgpICsgZHk7XG4gICAgICAgICAgICB3aGlsZSAodGhpcy5pc1ZhbGlkKHgsIHkpICYmIHRoaXMuaW1hZ2UuZ2V0KHgsIHkpID09PSBjb2xvcikge1xuICAgICAgICAgICAgICAgIHggKz0gZHg7XG4gICAgICAgICAgICAgICAgeSArPSBkeTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHggLT0gZHg7XG4gICAgICAgICAgICB5IC09IGR5O1xuICAgICAgICAgICAgd2hpbGUgKHRoaXMuaXNWYWxpZCh4LCB5KSAmJiB0aGlzLmltYWdlLmdldCh4LCB5KSA9PT0gY29sb3IpIHtcbiAgICAgICAgICAgICAgICB4ICs9IGR4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgeCAtPSBkeDtcbiAgICAgICAgICAgIHdoaWxlICh0aGlzLmlzVmFsaWQoeCwgeSkgJiYgdGhpcy5pbWFnZS5nZXQoeCwgeSkgPT09IGNvbG9yKSB7XG4gICAgICAgICAgICAgICAgeSArPSBkeTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHkgLT0gZHk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KHgsIHkpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFeHBhbmQgdGhlIHNxdWFyZSByZXByZXNlbnRlZCBieSB0aGUgY29ybmVyIHBvaW50cyBieSBwdXNoaW5nIG91dCBlcXVhbGx5IGluIGFsbCBkaXJlY3Rpb25zXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBjb3JuZXJQb2ludHMgdGhlIGNvcm5lcnMgb2YgdGhlIHNxdWFyZSwgd2hpY2ggaGFzIHRoZSBidWxsJ3MgZXllIGF0IGl0cyBjZW50ZXJcbiAgICAgICAgICogQHBhcmFtIG9sZFNpZGUgdGhlIG9yaWdpbmFsIGxlbmd0aCBvZiB0aGUgc2lkZSBvZiB0aGUgc3F1YXJlIGluIHRoZSB0YXJnZXQgYml0IG1hdHJpeFxuICAgICAgICAgKiBAcGFyYW0gbmV3U2lkZSB0aGUgbmV3IGxlbmd0aCBvZiB0aGUgc2l6ZSBvZiB0aGUgc3F1YXJlIGluIHRoZSB0YXJnZXQgYml0IG1hdHJpeFxuICAgICAgICAgKiBAcmV0dXJuIHRoZSBjb3JuZXJzIG9mIHRoZSBleHBhbmRlZCBzcXVhcmVcbiAgICAgICAgICovXG4gICAgICAgIGV4cGFuZFNxdWFyZShjb3JuZXJQb2ludHMsIG9sZFNpZGUsIG5ld1NpZGUpIHtcbiAgICAgICAgICAgIGxldCByYXRpbyA9IG5ld1NpZGUgLyAoMi4wICogb2xkU2lkZSk7XG4gICAgICAgICAgICBsZXQgZHggPSBjb3JuZXJQb2ludHNbMF0uZ2V0WCgpIC0gY29ybmVyUG9pbnRzWzJdLmdldFgoKTtcbiAgICAgICAgICAgIGxldCBkeSA9IGNvcm5lclBvaW50c1swXS5nZXRZKCkgLSBjb3JuZXJQb2ludHNbMl0uZ2V0WSgpO1xuICAgICAgICAgICAgbGV0IGNlbnRlcnggPSAoY29ybmVyUG9pbnRzWzBdLmdldFgoKSArIGNvcm5lclBvaW50c1syXS5nZXRYKCkpIC8gMi4wO1xuICAgICAgICAgICAgbGV0IGNlbnRlcnkgPSAoY29ybmVyUG9pbnRzWzBdLmdldFkoKSArIGNvcm5lclBvaW50c1syXS5nZXRZKCkpIC8gMi4wO1xuICAgICAgICAgICAgbGV0IHJlc3VsdDAgPSBuZXcgUmVzdWx0UG9pbnQoY2VudGVyeCArIHJhdGlvICogZHgsIGNlbnRlcnkgKyByYXRpbyAqIGR5KTtcbiAgICAgICAgICAgIGxldCByZXN1bHQyID0gbmV3IFJlc3VsdFBvaW50KGNlbnRlcnggLSByYXRpbyAqIGR4LCBjZW50ZXJ5IC0gcmF0aW8gKiBkeSk7XG4gICAgICAgICAgICBkeCA9IGNvcm5lclBvaW50c1sxXS5nZXRYKCkgLSBjb3JuZXJQb2ludHNbM10uZ2V0WCgpO1xuICAgICAgICAgICAgZHkgPSBjb3JuZXJQb2ludHNbMV0uZ2V0WSgpIC0gY29ybmVyUG9pbnRzWzNdLmdldFkoKTtcbiAgICAgICAgICAgIGNlbnRlcnggPSAoY29ybmVyUG9pbnRzWzFdLmdldFgoKSArIGNvcm5lclBvaW50c1szXS5nZXRYKCkpIC8gMi4wO1xuICAgICAgICAgICAgY2VudGVyeSA9IChjb3JuZXJQb2ludHNbMV0uZ2V0WSgpICsgY29ybmVyUG9pbnRzWzNdLmdldFkoKSkgLyAyLjA7XG4gICAgICAgICAgICBsZXQgcmVzdWx0MSA9IG5ldyBSZXN1bHRQb2ludChjZW50ZXJ4ICsgcmF0aW8gKiBkeCwgY2VudGVyeSArIHJhdGlvICogZHkpO1xuICAgICAgICAgICAgbGV0IHJlc3VsdDMgPSBuZXcgUmVzdWx0UG9pbnQoY2VudGVyeCAtIHJhdGlvICogZHgsIGNlbnRlcnkgLSByYXRpbyAqIGR5KTtcbiAgICAgICAgICAgIGxldCByZXN1bHRzID0gW3Jlc3VsdDAsIHJlc3VsdDEsIHJlc3VsdDIsIHJlc3VsdDNdO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgIH1cbiAgICAgICAgaXNWYWxpZCh4LCB5KSB7XG4gICAgICAgICAgICByZXR1cm4geCA+PSAwICYmIHggPCB0aGlzLmltYWdlLmdldFdpZHRoKCkgJiYgeSA+IDAgJiYgeSA8IHRoaXMuaW1hZ2UuZ2V0SGVpZ2h0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaXNWYWxpZFBvaW50KHBvaW50KSB7XG4gICAgICAgICAgICBsZXQgeCA9IE1hdGhVdGlscy5yb3VuZChwb2ludC5nZXRYKCkpO1xuICAgICAgICAgICAgbGV0IHkgPSBNYXRoVXRpbHMucm91bmQocG9pbnQuZ2V0WSgpKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlzVmFsaWQoeCwgeSk7XG4gICAgICAgIH1cbiAgICAgICAgZGlzdGFuY2VQb2ludChhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aFV0aWxzLmRpc3RhbmNlKGEuZ2V0WCgpLCBhLmdldFkoKSwgYi5nZXRYKCksIGIuZ2V0WSgpKTtcbiAgICAgICAgfVxuICAgICAgICBkaXN0YW5jZVJlc3VsdFBvaW50KGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoVXRpbHMuZGlzdGFuY2UoYS5nZXRYKCksIGEuZ2V0WSgpLCBiLmdldFgoKSwgYi5nZXRZKCkpO1xuICAgICAgICB9XG4gICAgICAgIGdldERpbWVuc2lvbigpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbXBhY3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gNCAqIHRoaXMubmJMYXllcnMgKyAxMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLm5iTGF5ZXJzIDw9IDQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gNCAqIHRoaXMubmJMYXllcnMgKyAxNTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiA0ICogdGhpcy5uYkxheWVycyArIDIgKiAoSW50ZWdlci50cnVuY0RpdmlzaW9uKCh0aGlzLm5iTGF5ZXJzIC0gNCksIDgpICsgMSkgKyAxNTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qXG4gICAgICogQ29weXJpZ2h0IDIwMTAgWlhpbmcgYXV0aG9yc1xuICAgICAqXG4gICAgICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgICAgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICAgICpcbiAgICAgKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICAgICAqXG4gICAgICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICAgICAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgICAgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgICAgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gICAgICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gICAgICovXG4gICAgLy8gaW1wb3J0IGphdmEudXRpbC5MaXN0O1xuICAgIC8vIGltcG9ydCBqYXZhLnV0aWwuTWFwO1xuICAgIC8qKlxuICAgICAqIFRoaXMgaW1wbGVtZW50YXRpb24gY2FuIGRldGVjdCBhbmQgZGVjb2RlIEF6dGVjIGNvZGVzIGluIGFuIGltYWdlLlxuICAgICAqXG4gICAgICogQGF1dGhvciBEYXZpZCBPbGl2aWVyXG4gICAgICovXG4gICAgY2xhc3MgQXp0ZWNSZWFkZXIge1xuICAgICAgICAvKipcbiAgICAgICAgICogTG9jYXRlcyBhbmQgZGVjb2RlcyBhIERhdGEgTWF0cml4IGNvZGUgaW4gYW4gaW1hZ2UuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4gYSBTdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBjb250ZW50IGVuY29kZWQgYnkgdGhlIERhdGEgTWF0cml4IGNvZGVcbiAgICAgICAgICogQHRocm93cyBOb3RGb3VuZEV4Y2VwdGlvbiBpZiBhIERhdGEgTWF0cml4IGNvZGUgY2Fubm90IGJlIGZvdW5kXG4gICAgICAgICAqIEB0aHJvd3MgRm9ybWF0RXhjZXB0aW9uIGlmIGEgRGF0YSBNYXRyaXggY29kZSBjYW5ub3QgYmUgZGVjb2RlZFxuICAgICAgICAgKi9cbiAgICAgICAgZGVjb2RlKGltYWdlLCBoaW50cyA9IG51bGwpIHtcbiAgICAgICAgICAgIGxldCBleGNlcHRpb24gPSBudWxsO1xuICAgICAgICAgICAgbGV0IGRldGVjdG9yID0gbmV3IERldGVjdG9yKGltYWdlLmdldEJsYWNrTWF0cml4KCkpO1xuICAgICAgICAgICAgbGV0IHBvaW50cyA9IG51bGw7XG4gICAgICAgICAgICBsZXQgZGVjb2RlclJlc3VsdCA9IG51bGw7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGxldCBkZXRlY3RvclJlc3VsdCA9IGRldGVjdG9yLmRldGVjdE1pcnJvcihmYWxzZSk7XG4gICAgICAgICAgICAgICAgcG9pbnRzID0gZGV0ZWN0b3JSZXN1bHQuZ2V0UG9pbnRzKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXBvcnRGb3VuZFJlc3VsdFBvaW50cyhoaW50cywgcG9pbnRzKTtcbiAgICAgICAgICAgICAgICBkZWNvZGVyUmVzdWx0ID0gbmV3IERlY29kZXIoKS5kZWNvZGUoZGV0ZWN0b3JSZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBleGNlcHRpb24gPSBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRlY29kZXJSZXN1bHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkZXRlY3RvclJlc3VsdCA9IGRldGVjdG9yLmRldGVjdE1pcnJvcih0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzID0gZGV0ZWN0b3JSZXN1bHQuZ2V0UG9pbnRzKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVwb3J0Rm91bmRSZXN1bHRQb2ludHMoaGludHMsIHBvaW50cyk7XG4gICAgICAgICAgICAgICAgICAgIGRlY29kZXJSZXN1bHQgPSBuZXcgRGVjb2RlcigpLmRlY29kZShkZXRlY3RvclJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChleGNlcHRpb24gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IG5ldyBSZXN1bHQoZGVjb2RlclJlc3VsdC5nZXRUZXh0KCksIGRlY29kZXJSZXN1bHQuZ2V0UmF3Qnl0ZXMoKSwgZGVjb2RlclJlc3VsdC5nZXROdW1CaXRzKCksIHBvaW50cywgQmFyY29kZUZvcm1hdCQxLkFaVEVDLCBTeXN0ZW0uY3VycmVudFRpbWVNaWxsaXMoKSk7XG4gICAgICAgICAgICBsZXQgYnl0ZVNlZ21lbnRzID0gZGVjb2RlclJlc3VsdC5nZXRCeXRlU2VnbWVudHMoKTtcbiAgICAgICAgICAgIGlmIChieXRlU2VnbWVudHMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXRNZXRhZGF0YShSZXN1bHRNZXRhZGF0YVR5cGUkMS5CWVRFX1NFR01FTlRTLCBieXRlU2VnbWVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGVjTGV2ZWwgPSBkZWNvZGVyUmVzdWx0LmdldEVDTGV2ZWwoKTtcbiAgICAgICAgICAgIGlmIChlY0xldmVsICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHV0TWV0YWRhdGEoUmVzdWx0TWV0YWRhdGFUeXBlJDEuRVJST1JfQ09SUkVDVElPTl9MRVZFTCwgZWNMZXZlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHJlcG9ydEZvdW5kUmVzdWx0UG9pbnRzKGhpbnRzLCBwb2ludHMpIHtcbiAgICAgICAgICAgIGlmIChoaW50cyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbGV0IHJwY2IgPSBoaW50cy5nZXQoRGVjb2RlSGludFR5cGUkMS5ORUVEX1JFU1VMVF9QT0lOVF9DQUxMQkFDSyk7XG4gICAgICAgICAgICAgICAgaWYgKHJwY2IgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBwb2ludHMuZm9yRWFjaCgocG9pbnQsIGlkeCwgYXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBycGNiLmZvdW5kUG9zc2libGVSZXN1bHRQb2ludChwb2ludCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBAT3ZlcnJpZGVcbiAgICAgICAgcmVzZXQoKSB7XG4gICAgICAgICAgICAvLyBkbyBub3RoaW5nXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBenRlYyBDb2RlIHJlYWRlciB0byB1c2UgZnJvbSBicm93c2VyLlxuICAgICAqXG4gICAgICogQGNsYXNzIEJyb3dzZXJBenRlY0NvZGVSZWFkZXJcbiAgICAgKiBAZXh0ZW5kcyB7QnJvd3NlckNvZGVSZWFkZXJ9XG4gICAgICovXG4gICAgY2xhc3MgQnJvd3NlckF6dGVjQ29kZVJlYWRlciBleHRlbmRzIEJyb3dzZXJDb2RlUmVhZGVyIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgQnJvd3NlckF6dGVjQ29kZVJlYWRlci5cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFt0aW1lQmV0d2VlblNjYW5zTWlsbGlzPTUwMF0gdGhlIHRpbWUgZGVsYXkgYmV0d2VlbiBzdWJzZXF1ZW50IGRlY29kZSB0cmllc1xuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyT2YgQnJvd3NlckF6dGVjQ29kZVJlYWRlclxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3RydWN0b3IodGltZUJldHdlZW5TY2Fuc01pbGxpcyA9IDUwMCkge1xuICAgICAgICAgICAgc3VwZXIobmV3IEF6dGVjUmVhZGVyKCksIHRpbWVCZXR3ZWVuU2NhbnNNaWxsaXMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRW5jYXBzdWxhdGVzIGZ1bmN0aW9uYWxpdHkgYW5kIGltcGxlbWVudGF0aW9uIHRoYXQgaXMgY29tbW9uIHRvIGFsbCBmYW1pbGllc1xuICAgICAqIG9mIG9uZS1kaW1lbnNpb25hbCBiYXJjb2Rlcy5cbiAgICAgKlxuICAgICAqIEBhdXRob3IgZHN3aXRraW5AZ29vZ2xlLmNvbSAoRGFuaWVsIFN3aXRraW4pXG4gICAgICogQGF1dGhvciBTZWFuIE93ZW5cbiAgICAgKi9cbiAgICBjbGFzcyBPbmVEUmVhZGVyIHtcbiAgICAgICAgLypcbiAgICAgICAgQE92ZXJyaWRlXG4gICAgICAgIHB1YmxpYyBSZXN1bHQgZGVjb2RlKEJpbmFyeUJpdG1hcCBpbWFnZSkgdGhyb3dzIE5vdEZvdW5kRXhjZXB0aW9uLCBGb3JtYXRFeGNlcHRpb24ge1xuICAgICAgICAgIHJldHVybiBkZWNvZGUoaW1hZ2UsIG51bGwpO1xuICAgICAgICB9XG4gICAgICAgICovXG4gICAgICAgIC8vIE5vdGUgdGhhdCB3ZSBkb24ndCB0cnkgcm90YXRpb24gd2l0aG91dCB0aGUgdHJ5IGhhcmRlciBmbGFnLCBldmVuIGlmIHJvdGF0aW9uIHdhcyBzdXBwb3J0ZWQuXG4gICAgICAgIC8vIEBPdmVycmlkZVxuICAgICAgICBkZWNvZGUoaW1hZ2UsIGhpbnRzKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRvRGVjb2RlKGltYWdlLCBoaW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAobmZlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdHJ5SGFyZGVyID0gaGludHMgJiYgKGhpbnRzLmdldChEZWNvZGVIaW50VHlwZSQxLlRSWV9IQVJERVIpID09PSB0cnVlKTtcbiAgICAgICAgICAgICAgICBpZiAodHJ5SGFyZGVyICYmIGltYWdlLmlzUm90YXRlU3VwcG9ydGVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgcm90YXRlZEltYWdlID0gaW1hZ2Uucm90YXRlQ291bnRlckNsb2Nrd2lzZSgpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLmRvRGVjb2RlKHJvdGF0ZWRJbWFnZSwgaGludHMpO1xuICAgICAgICAgICAgICAgICAgICAvLyBSZWNvcmQgdGhhdCB3ZSBmb3VuZCBpdCByb3RhdGVkIDkwIGRlZ3JlZXMgQ0NXIC8gMjcwIGRlZ3JlZXMgQ1dcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWV0YWRhdGEgPSByZXN1bHQuZ2V0UmVzdWx0TWV0YWRhdGEoKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG9yaWVudGF0aW9uID0gMjcwO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWV0YWRhdGEgIT09IG51bGwgJiYgKG1ldGFkYXRhLmdldChSZXN1bHRNZXRhZGF0YVR5cGUkMS5PUklFTlRBVElPTikgPT09IHRydWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBCdXQgaWYgd2UgZm91bmQgaXQgcmV2ZXJzZWQgaW4gZG9EZWNvZGUoKSwgYWRkIGluIHRoYXQgcmVzdWx0IGhlcmU6XG4gICAgICAgICAgICAgICAgICAgICAgICBvcmllbnRhdGlvbiA9IChvcmllbnRhdGlvbiArIG1ldGFkYXRhLmdldChSZXN1bHRNZXRhZGF0YVR5cGUkMS5PUklFTlRBVElPTikgJSAzNjApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXRNZXRhZGF0YShSZXN1bHRNZXRhZGF0YVR5cGUkMS5PUklFTlRBVElPTiwgb3JpZW50YXRpb24pO1xuICAgICAgICAgICAgICAgICAgICAvLyBVcGRhdGUgcmVzdWx0IHBvaW50c1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwb2ludHMgPSByZXN1bHQuZ2V0UmVzdWx0UG9pbnRzKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb2ludHMgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGhlaWdodCA9IHJvdGF0ZWRJbWFnZS5nZXRIZWlnaHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzW2ldID0gbmV3IFJlc3VsdFBvaW50KGhlaWdodCAtIHBvaW50c1tpXS5nZXRZKCkgLSAxLCBwb2ludHNbaV0uZ2V0WCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEBPdmVycmlkZVxuICAgICAgICByZXNldCgpIHtcbiAgICAgICAgICAgIC8vIGRvIG5vdGhpbmdcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogV2UncmUgZ29pbmcgdG8gZXhhbWluZSByb3dzIGZyb20gdGhlIG1pZGRsZSBvdXR3YXJkLCBzZWFyY2hpbmcgYWx0ZXJuYXRlbHkgYWJvdmUgYW5kIGJlbG93IHRoZVxuICAgICAgICAgKiBtaWRkbGUsIGFuZCBmYXJ0aGVyIG91dCBlYWNoIHRpbWUuIHJvd1N0ZXAgaXMgdGhlIG51bWJlciBvZiByb3dzIGJldHdlZW4gZWFjaCBzdWNjZXNzaXZlXG4gICAgICAgICAqIGF0dGVtcHQgYWJvdmUgYW5kIGJlbG93IHRoZSBtaWRkbGUuIFNvIHdlJ2Qgc2NhbiByb3cgbWlkZGxlLCB0aGVuIG1pZGRsZSAtIHJvd1N0ZXAsIHRoZW5cbiAgICAgICAgICogbWlkZGxlICsgcm93U3RlcCwgdGhlbiBtaWRkbGUgLSAoMiAqIHJvd1N0ZXApLCBldGMuXG4gICAgICAgICAqIHJvd1N0ZXAgaXMgYmlnZ2VyIGFzIHRoZSBpbWFnZSBpcyB0YWxsZXIsIGJ1dCBpcyBhbHdheXMgYXQgbGVhc3QgMS4gV2UndmUgc29tZXdoYXQgYXJiaXRyYXJpbHlcbiAgICAgICAgICogZGVjaWRlZCB0aGF0IG1vdmluZyB1cCBhbmQgZG93biBieSBhYm91dCAxLzE2IG9mIHRoZSBpbWFnZSBpcyBwcmV0dHkgZ29vZDsgd2UgdHJ5IG1vcmUgb2YgdGhlXG4gICAgICAgICAqIGltYWdlIGlmIFwidHJ5aW5nIGhhcmRlclwiLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gaW1hZ2UgVGhlIGltYWdlIHRvIGRlY29kZVxuICAgICAgICAgKiBAcGFyYW0gaGludHMgQW55IGhpbnRzIHRoYXQgd2VyZSByZXF1ZXN0ZWRcbiAgICAgICAgICogQHJldHVybiBUaGUgY29udGVudHMgb2YgdGhlIGRlY29kZWQgYmFyY29kZVxuICAgICAgICAgKiBAdGhyb3dzIE5vdEZvdW5kRXhjZXB0aW9uIEFueSBzcG9udGFuZW91cyBlcnJvcnMgd2hpY2ggb2NjdXJcbiAgICAgICAgICovXG4gICAgICAgIGRvRGVjb2RlKGltYWdlLCBoaW50cykge1xuICAgICAgICAgICAgY29uc3Qgd2lkdGggPSBpbWFnZS5nZXRXaWR0aCgpO1xuICAgICAgICAgICAgY29uc3QgaGVpZ2h0ID0gaW1hZ2UuZ2V0SGVpZ2h0KCk7XG4gICAgICAgICAgICBsZXQgcm93ID0gbmV3IEJpdEFycmF5KHdpZHRoKTtcbiAgICAgICAgICAgIGNvbnN0IHRyeUhhcmRlciA9IGhpbnRzICYmIChoaW50cy5nZXQoRGVjb2RlSGludFR5cGUkMS5UUllfSEFSREVSKSA9PT0gdHJ1ZSk7XG4gICAgICAgICAgICBjb25zdCByb3dTdGVwID0gTWF0aC5tYXgoMSwgaGVpZ2h0ID4+ICh0cnlIYXJkZXIgPyA4IDogNSkpO1xuICAgICAgICAgICAgbGV0IG1heExpbmVzO1xuICAgICAgICAgICAgaWYgKHRyeUhhcmRlcikge1xuICAgICAgICAgICAgICAgIG1heExpbmVzID0gaGVpZ2h0OyAvLyBMb29rIGF0IHRoZSB3aG9sZSBpbWFnZSwgbm90IGp1c3QgdGhlIGNlbnRlclxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbWF4TGluZXMgPSAxNTsgLy8gMTUgcm93cyBzcGFjZWQgMS8zMiBhcGFydCBpcyByb3VnaGx5IHRoZSBtaWRkbGUgaGFsZiBvZiB0aGUgaW1hZ2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG1pZGRsZSA9IE1hdGgudHJ1bmMoaGVpZ2h0IC8gMik7XG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IG1heExpbmVzOyB4KyspIHtcbiAgICAgICAgICAgICAgICAvLyBTY2FubmluZyBmcm9tIHRoZSBtaWRkbGUgb3V0LiBEZXRlcm1pbmUgd2hpY2ggcm93IHdlJ3JlIGxvb2tpbmcgYXQgbmV4dDpcbiAgICAgICAgICAgICAgICBjb25zdCByb3dTdGVwc0Fib3ZlT3JCZWxvdyA9IE1hdGgudHJ1bmMoKHggKyAxKSAvIDIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzQWJvdmUgPSAoeCAmIDB4MDEpID09PSAwOyAvLyBpLmUuIGlzIHggZXZlbj9cbiAgICAgICAgICAgICAgICBjb25zdCByb3dOdW1iZXIgPSBtaWRkbGUgKyByb3dTdGVwICogKGlzQWJvdmUgPyByb3dTdGVwc0Fib3ZlT3JCZWxvdyA6IC1yb3dTdGVwc0Fib3ZlT3JCZWxvdyk7XG4gICAgICAgICAgICAgICAgaWYgKHJvd051bWJlciA8IDAgfHwgcm93TnVtYmVyID49IGhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBPb3BzLCBpZiB3ZSBydW4gb2ZmIHRoZSB0b3Agb3IgYm90dG9tLCBzdG9wXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBFc3RpbWF0ZSBibGFjayBwb2ludCBmb3IgdGhpcyByb3cgYW5kIGxvYWQgaXQ6XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcm93ID0gaW1hZ2UuZ2V0QmxhY2tSb3cocm93TnVtYmVyLCByb3cpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoaWdub3JlZCkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gV2hpbGUgd2UgaGF2ZSB0aGUgaW1hZ2UgZGF0YSBpbiBhIEJpdEFycmF5LCBpdCdzIGZhaXJseSBjaGVhcCB0byByZXZlcnNlIGl0IGluIHBsYWNlIHRvXG4gICAgICAgICAgICAgICAgLy8gaGFuZGxlIGRlY29kaW5nIHVwc2lkZSBkb3duIGJhcmNvZGVzLlxuICAgICAgICAgICAgICAgIGZvciAobGV0IGF0dGVtcHQgPSAwOyBhdHRlbXB0IDwgMjsgYXR0ZW1wdCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhdHRlbXB0ID09PSAxKSB7IC8vIHRyeWluZyBhZ2Fpbj9cbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdy5yZXZlcnNlKCk7IC8vIHJldmVyc2UgdGhlIHJvdyBhbmQgY29udGludWVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgbWVhbnMgd2Ugd2lsbCBvbmx5IGV2ZXIgZHJhdyByZXN1bHQgcG9pbnRzICpvbmNlKiBpbiB0aGUgbGlmZSBvZiB0aGlzIG1ldGhvZFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2luY2Ugd2Ugd2FudCB0byBhdm9pZCBkcmF3aW5nIHRoZSB3cm9uZyBwb2ludHMgYWZ0ZXIgZmxpcHBpbmcgdGhlIHJvdywgYW5kLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZG9uJ3Qgd2FudCB0byBjbHV0dGVyIHdpdGggbm9pc2UgZnJvbSBldmVyeSBzaW5nbGUgcm93IHNjYW4gLS0ganVzdCB0aGUgc2NhbnNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoYXQgc3RhcnQgb24gdGhlIGNlbnRlciBsaW5lLlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhpbnRzICYmIChoaW50cy5nZXQoRGVjb2RlSGludFR5cGUkMS5ORUVEX1JFU1VMVF9QT0lOVF9DQUxMQkFDSykgPT09IHRydWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3SGludHMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGludHMuZm9yRWFjaCgoaGludCwga2V5KSA9PiBuZXdIaW50cy5zZXQoa2V5LCBoaW50KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3SGludHMuZGVsZXRlKERlY29kZUhpbnRUeXBlJDEuTkVFRF9SRVNVTFRfUE9JTlRfQ0FMTEJBQ0spO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhpbnRzID0gbmV3SGludHM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIExvb2sgZm9yIGEgYmFyY29kZVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5kZWNvZGVSb3cocm93TnVtYmVyLCByb3csIGhpbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGZvdW5kIG91ciBiYXJjb2RlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXR0ZW1wdCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJ1dCBpdCB3YXMgdXBzaWRlIGRvd24sIHNvIG5vdGUgdGhhdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXRNZXRhZGF0YShSZXN1bHRNZXRhZGF0YVR5cGUkMS5PUklFTlRBVElPTiwgMTgwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBbmQgcmVtZW1iZXIgdG8gZmxpcCB0aGUgcmVzdWx0IHBvaW50cyBob3Jpem9udGFsbHkuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcG9pbnRzID0gcmVzdWx0LmdldFJlc3VsdFBvaW50cygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwb2ludHMgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzWzBdID0gbmV3IFJlc3VsdFBvaW50KHdpZHRoIC0gcG9pbnRzWzBdLmdldFgoKSAtIDEsIHBvaW50c1swXS5nZXRZKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludHNbMV0gPSBuZXcgUmVzdWx0UG9pbnQod2lkdGggLSBwb2ludHNbMV0uZ2V0WCgpIC0gMSwgcG9pbnRzWzFdLmdldFkoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAocmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnRpbnVlIC0tIGp1c3QgY291bGRuJ3QgZGVjb2RlIHRoaXMgcm93XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUmVjb3JkcyB0aGUgc2l6ZSBvZiBzdWNjZXNzaXZlIHJ1bnMgb2Ygd2hpdGUgYW5kIGJsYWNrIHBpeGVscyBpbiBhIHJvdywgc3RhcnRpbmcgYXQgYSBnaXZlbiBwb2ludC5cbiAgICAgICAgICogVGhlIHZhbHVlcyBhcmUgcmVjb3JkZWQgaW4gdGhlIGdpdmVuIGFycmF5LCBhbmQgdGhlIG51bWJlciBvZiBydW5zIHJlY29yZGVkIGlzIGVxdWFsIHRvIHRoZSBzaXplXG4gICAgICAgICAqIG9mIHRoZSBhcnJheS4gSWYgdGhlIHJvdyBzdGFydHMgb24gYSB3aGl0ZSBwaXhlbCBhdCB0aGUgZ2l2ZW4gc3RhcnQgcG9pbnQsIHRoZW4gdGhlIGZpcnN0IGNvdW50XG4gICAgICAgICAqIHJlY29yZGVkIGlzIHRoZSBydW4gb2Ygd2hpdGUgcGl4ZWxzIHN0YXJ0aW5nIGZyb20gdGhhdCBwb2ludDsgbGlrZXdpc2UgaXQgaXMgdGhlIGNvdW50IG9mIGEgcnVuXG4gICAgICAgICAqIG9mIGJsYWNrIHBpeGVscyBpZiB0aGUgcm93IGJlZ2luIG9uIGEgYmxhY2sgcGl4ZWxzIGF0IHRoYXQgcG9pbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSByb3cgcm93IHRvIGNvdW50IGZyb21cbiAgICAgICAgICogQHBhcmFtIHN0YXJ0IG9mZnNldCBpbnRvIHJvdyB0byBzdGFydCBhdFxuICAgICAgICAgKiBAcGFyYW0gY291bnRlcnMgYXJyYXkgaW50byB3aGljaCB0byByZWNvcmQgY291bnRzXG4gICAgICAgICAqIEB0aHJvd3MgTm90Rm91bmRFeGNlcHRpb24gaWYgY291bnRlcnMgY2Fubm90IGJlIGZpbGxlZCBlbnRpcmVseSBmcm9tIHJvdyBiZWZvcmUgcnVubmluZyBvdXRcbiAgICAgICAgICogIG9mIHBpeGVsc1xuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIHJlY29yZFBhdHRlcm4ocm93LCBzdGFydCwgY291bnRlcnMpIHtcbiAgICAgICAgICAgIGNvbnN0IG51bUNvdW50ZXJzID0gY291bnRlcnMubGVuZ3RoO1xuICAgICAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IG51bUNvdW50ZXJzOyBpbmRleCsrKVxuICAgICAgICAgICAgICAgIGNvdW50ZXJzW2luZGV4XSA9IDA7XG4gICAgICAgICAgICBjb25zdCBlbmQgPSByb3cuZ2V0U2l6ZSgpO1xuICAgICAgICAgICAgaWYgKHN0YXJ0ID49IGVuZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGlzV2hpdGUgPSAhcm93LmdldChzdGFydCk7XG4gICAgICAgICAgICBsZXQgY291bnRlclBvc2l0aW9uID0gMDtcbiAgICAgICAgICAgIGxldCBpID0gc3RhcnQ7XG4gICAgICAgICAgICB3aGlsZSAoaSA8IGVuZCkge1xuICAgICAgICAgICAgICAgIGlmIChyb3cuZ2V0KGkpICE9PSBpc1doaXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJzW2NvdW50ZXJQb3NpdGlvbl0rKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgrK2NvdW50ZXJQb3NpdGlvbiA9PT0gbnVtQ291bnRlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlcnNbY291bnRlclBvc2l0aW9uXSA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc1doaXRlID0gIWlzV2hpdGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgd2UgcmVhZCBmdWxseSB0aGUgbGFzdCBzZWN0aW9uIG9mIHBpeGVscyBhbmQgZmlsbGVkIHVwIG91ciBjb3VudGVycyAtLSBvciBmaWxsZWRcbiAgICAgICAgICAgIC8vIHRoZSBsYXN0IGNvdW50ZXIgYnV0IHJhbiBvZmYgdGhlIHNpZGUgb2YgdGhlIGltYWdlLCBPSy4gT3RoZXJ3aXNlLCBhIHByb2JsZW0uXG4gICAgICAgICAgICBpZiAoIShjb3VudGVyUG9zaXRpb24gPT09IG51bUNvdW50ZXJzIHx8IChjb3VudGVyUG9zaXRpb24gPT09IG51bUNvdW50ZXJzIC0gMSAmJiBpID09PSBlbmQpKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyByZWNvcmRQYXR0ZXJuSW5SZXZlcnNlKHJvdywgc3RhcnQsIGNvdW50ZXJzKSB7XG4gICAgICAgICAgICAvLyBUaGlzIGNvdWxkIGJlIG1vcmUgZWZmaWNpZW50IEkgZ3Vlc3NcbiAgICAgICAgICAgIGxldCBudW1UcmFuc2l0aW9uc0xlZnQgPSBjb3VudGVycy5sZW5ndGg7XG4gICAgICAgICAgICBsZXQgbGFzdCA9IHJvdy5nZXQoc3RhcnQpO1xuICAgICAgICAgICAgd2hpbGUgKHN0YXJ0ID4gMCAmJiBudW1UcmFuc2l0aW9uc0xlZnQgPj0gMCkge1xuICAgICAgICAgICAgICAgIGlmIChyb3cuZ2V0KC0tc3RhcnQpICE9PSBsYXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIG51bVRyYW5zaXRpb25zTGVmdC0tO1xuICAgICAgICAgICAgICAgICAgICBsYXN0ID0gIWxhc3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG51bVRyYW5zaXRpb25zTGVmdCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBPbmVEUmVhZGVyLnJlY29yZFBhdHRlcm4ocm93LCBzdGFydCArIDEsIGNvdW50ZXJzKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogRGV0ZXJtaW5lcyBob3cgY2xvc2VseSBhIHNldCBvZiBvYnNlcnZlZCBjb3VudHMgb2YgcnVucyBvZiBibGFjay93aGl0ZSB2YWx1ZXMgbWF0Y2hlcyBhIGdpdmVuXG4gICAgICAgICAqIHRhcmdldCBwYXR0ZXJuLiBUaGlzIGlzIHJlcG9ydGVkIGFzIHRoZSByYXRpbyBvZiB0aGUgdG90YWwgdmFyaWFuY2UgZnJvbSB0aGUgZXhwZWN0ZWQgcGF0dGVyblxuICAgICAgICAgKiBwcm9wb3J0aW9ucyBhY3Jvc3MgYWxsIHBhdHRlcm4gZWxlbWVudHMsIHRvIHRoZSBsZW5ndGggb2YgdGhlIHBhdHRlcm4uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBjb3VudGVycyBvYnNlcnZlZCBjb3VudGVyc1xuICAgICAgICAgKiBAcGFyYW0gcGF0dGVybiBleHBlY3RlZCBwYXR0ZXJuXG4gICAgICAgICAqIEBwYXJhbSBtYXhJbmRpdmlkdWFsVmFyaWFuY2UgVGhlIG1vc3QgYW55IGNvdW50ZXIgY2FuIGRpZmZlciBiZWZvcmUgd2UgZ2l2ZSB1cFxuICAgICAgICAgKiBAcmV0dXJuIHJhdGlvIG9mIHRvdGFsIHZhcmlhbmNlIGJldHdlZW4gY291bnRlcnMgYW5kIHBhdHRlcm4gY29tcGFyZWQgdG8gdG90YWwgcGF0dGVybiBzaXplXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgcGF0dGVybk1hdGNoVmFyaWFuY2UoY291bnRlcnMsIHBhdHRlcm4sIG1heEluZGl2aWR1YWxWYXJpYW5jZSkge1xuICAgICAgICAgICAgY29uc3QgbnVtQ291bnRlcnMgPSBjb3VudGVycy5sZW5ndGg7XG4gICAgICAgICAgICBsZXQgdG90YWwgPSAwO1xuICAgICAgICAgICAgbGV0IHBhdHRlcm5MZW5ndGggPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1Db3VudGVyczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdG90YWwgKz0gY291bnRlcnNbaV07XG4gICAgICAgICAgICAgICAgcGF0dGVybkxlbmd0aCArPSBwYXR0ZXJuW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRvdGFsIDwgcGF0dGVybkxlbmd0aCkge1xuICAgICAgICAgICAgICAgIC8vIElmIHdlIGRvbid0IGV2ZW4gaGF2ZSBvbmUgcGl4ZWwgcGVyIHVuaXQgb2YgYmFyIHdpZHRoLCBhc3N1bWUgdGhpcyBpcyB0b28gc21hbGxcbiAgICAgICAgICAgICAgICAvLyB0byByZWxpYWJseSBtYXRjaCwgc28gZmFpbDpcbiAgICAgICAgICAgICAgICByZXR1cm4gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdW5pdEJhcldpZHRoID0gdG90YWwgLyBwYXR0ZXJuTGVuZ3RoO1xuICAgICAgICAgICAgbWF4SW5kaXZpZHVhbFZhcmlhbmNlICo9IHVuaXRCYXJXaWR0aDtcbiAgICAgICAgICAgIGxldCB0b3RhbFZhcmlhbmNlID0gMC4wO1xuICAgICAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCBudW1Db3VudGVyczsgeCsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY291bnRlciA9IGNvdW50ZXJzW3hdO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNjYWxlZFBhdHRlcm4gPSBwYXR0ZXJuW3hdICogdW5pdEJhcldpZHRoO1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhcmlhbmNlID0gY291bnRlciA+IHNjYWxlZFBhdHRlcm4gPyBjb3VudGVyIC0gc2NhbGVkUGF0dGVybiA6IHNjYWxlZFBhdHRlcm4gLSBjb3VudGVyO1xuICAgICAgICAgICAgICAgIGlmICh2YXJpYW5jZSA+IG1heEluZGl2aWR1YWxWYXJpYW5jZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0b3RhbFZhcmlhbmNlICs9IHZhcmlhbmNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRvdGFsVmFyaWFuY2UgLyB0b3RhbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIDxwPkRlY29kZXMgQ29kZSAxMjggYmFyY29kZXMuPC9wPlxuICAgICAqXG4gICAgICogQGF1dGhvciBTZWFuIE93ZW5cbiAgICAgKi9cbiAgICBjbGFzcyBDb2RlMTI4UmVhZGVyIGV4dGVuZHMgT25lRFJlYWRlciB7XG4gICAgICAgIHN0YXRpYyBmaW5kU3RhcnRQYXR0ZXJuKHJvdykge1xuICAgICAgICAgICAgY29uc3Qgd2lkdGggPSByb3cuZ2V0U2l6ZSgpO1xuICAgICAgICAgICAgY29uc3Qgcm93T2Zmc2V0ID0gcm93LmdldE5leHRTZXQoMCk7XG4gICAgICAgICAgICBsZXQgY291bnRlclBvc2l0aW9uID0gMDtcbiAgICAgICAgICAgIGxldCBjb3VudGVycyA9IEludDMyQXJyYXkuZnJvbShbMCwgMCwgMCwgMCwgMCwgMF0pO1xuICAgICAgICAgICAgbGV0IHBhdHRlcm5TdGFydCA9IHJvd09mZnNldDtcbiAgICAgICAgICAgIGxldCBpc1doaXRlID0gZmFsc2U7XG4gICAgICAgICAgICBjb25zdCBwYXR0ZXJuTGVuZ3RoID0gNjtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSByb3dPZmZzZXQ7IGkgPCB3aWR0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJvdy5nZXQoaSkgIT09IGlzV2hpdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY291bnRlcnNbY291bnRlclBvc2l0aW9uXSsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvdW50ZXJQb3NpdGlvbiA9PT0gKHBhdHRlcm5MZW5ndGggLSAxKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGJlc3RWYXJpYW5jZSA9IENvZGUxMjhSZWFkZXIuTUFYX0FWR19WQVJJQU5DRTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBiZXN0TWF0Y2ggPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHN0YXJ0Q29kZSA9IENvZGUxMjhSZWFkZXIuQ09ERV9TVEFSVF9BOyBzdGFydENvZGUgPD0gQ29kZTEyOFJlYWRlci5DT0RFX1NUQVJUX0M7IHN0YXJ0Q29kZSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFyaWFuY2UgPSBPbmVEUmVhZGVyLnBhdHRlcm5NYXRjaFZhcmlhbmNlKGNvdW50ZXJzLCBDb2RlMTI4UmVhZGVyLkNPREVfUEFUVEVSTlNbc3RhcnRDb2RlXSwgQ29kZTEyOFJlYWRlci5NQVhfSU5ESVZJRFVBTF9WQVJJQU5DRSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhcmlhbmNlIDwgYmVzdFZhcmlhbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RWYXJpYW5jZSA9IHZhcmlhbmNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2ggPSBzdGFydENvZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTG9vayBmb3Igd2hpdGVzcGFjZSBiZWZvcmUgc3RhcnQgcGF0dGVybiwgPj0gNTAlIG9mIHdpZHRoIG9mIHN0YXJ0IHBhdHRlcm5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiZXN0TWF0Y2ggPj0gMCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdy5pc1JhbmdlKE1hdGgubWF4KDAsIHBhdHRlcm5TdGFydCAtIChpIC0gcGF0dGVyblN0YXJ0KSAvIDIpLCBwYXR0ZXJuU3RhcnQsIGZhbHNlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBJbnQzMkFycmF5LmZyb20oW3BhdHRlcm5TdGFydCwgaSwgYmVzdE1hdGNoXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuU3RhcnQgKz0gY291bnRlcnNbMF0gKyBjb3VudGVyc1sxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJzID0gY291bnRlcnMuc2xpY2UoMiwgY291bnRlcnMubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyc1tjb3VudGVyUG9zaXRpb24gLSAxXSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyc1tjb3VudGVyUG9zaXRpb25dID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJQb3NpdGlvbi0tO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlclBvc2l0aW9uKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY291bnRlcnNbY291bnRlclBvc2l0aW9uXSA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGlzV2hpdGUgPSAhaXNXaGl0ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgZGVjb2RlQ29kZShyb3csIGNvdW50ZXJzLCByb3dPZmZzZXQpIHtcbiAgICAgICAgICAgIE9uZURSZWFkZXIucmVjb3JkUGF0dGVybihyb3csIHJvd09mZnNldCwgY291bnRlcnMpO1xuICAgICAgICAgICAgbGV0IGJlc3RWYXJpYW5jZSA9IENvZGUxMjhSZWFkZXIuTUFYX0FWR19WQVJJQU5DRTsgLy8gd29yc3QgdmFyaWFuY2Ugd2UnbGwgYWNjZXB0XG4gICAgICAgICAgICBsZXQgYmVzdE1hdGNoID0gLTE7XG4gICAgICAgICAgICBmb3IgKGxldCBkID0gMDsgZCA8IENvZGUxMjhSZWFkZXIuQ09ERV9QQVRURVJOUy5sZW5ndGg7IGQrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhdHRlcm4gPSBDb2RlMTI4UmVhZGVyLkNPREVfUEFUVEVSTlNbZF07XG4gICAgICAgICAgICAgICAgY29uc3QgdmFyaWFuY2UgPSB0aGlzLnBhdHRlcm5NYXRjaFZhcmlhbmNlKGNvdW50ZXJzLCBwYXR0ZXJuLCBDb2RlMTI4UmVhZGVyLk1BWF9JTkRJVklEVUFMX1ZBUklBTkNFKTtcbiAgICAgICAgICAgICAgICBpZiAodmFyaWFuY2UgPCBiZXN0VmFyaWFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgYmVzdFZhcmlhbmNlID0gdmFyaWFuY2U7XG4gICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaCA9IGQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVE9ETyBXZSdyZSBvdmVybG9va2luZyB0aGUgZmFjdCB0aGF0IHRoZSBTVE9QIHBhdHRlcm4gaGFzIDcgdmFsdWVzLCBub3QgNi5cbiAgICAgICAgICAgIGlmIChiZXN0TWF0Y2ggPj0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBiZXN0TWF0Y2g7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBkZWNvZGVSb3cocm93TnVtYmVyLCByb3csIGhpbnRzKSB7XG4gICAgICAgICAgICBjb25zdCBjb252ZXJ0Rk5DMSA9IGhpbnRzICYmIChoaW50cy5nZXQoRGVjb2RlSGludFR5cGUkMS5BU1NVTUVfR1MxKSA9PT0gdHJ1ZSk7XG4gICAgICAgICAgICBjb25zdCBzdGFydFBhdHRlcm5JbmZvID0gQ29kZTEyOFJlYWRlci5maW5kU3RhcnRQYXR0ZXJuKHJvdyk7XG4gICAgICAgICAgICBjb25zdCBzdGFydENvZGUgPSBzdGFydFBhdHRlcm5JbmZvWzJdO1xuICAgICAgICAgICAgbGV0IGN1cnJlbnRSYXdDb2Rlc0luZGV4ID0gMDtcbiAgICAgICAgICAgIGNvbnN0IHJhd0NvZGVzID0gbmV3IFVpbnQ4QXJyYXkoMjApO1xuICAgICAgICAgICAgcmF3Q29kZXNbY3VycmVudFJhd0NvZGVzSW5kZXgrK10gPSBzdGFydENvZGU7XG4gICAgICAgICAgICBsZXQgY29kZVNldDtcbiAgICAgICAgICAgIHN3aXRjaCAoc3RhcnRDb2RlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBDb2RlMTI4UmVhZGVyLkNPREVfU1RBUlRfQTpcbiAgICAgICAgICAgICAgICAgICAgY29kZVNldCA9IENvZGUxMjhSZWFkZXIuQ09ERV9DT0RFX0E7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQ29kZTEyOFJlYWRlci5DT0RFX1NUQVJUX0I6XG4gICAgICAgICAgICAgICAgICAgIGNvZGVTZXQgPSBDb2RlMTI4UmVhZGVyLkNPREVfQ09ERV9CO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIENvZGUxMjhSZWFkZXIuQ09ERV9TVEFSVF9DOlxuICAgICAgICAgICAgICAgICAgICBjb2RlU2V0ID0gQ29kZTEyOFJlYWRlci5DT0RFX0NPREVfQztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGRvbmUgPSBmYWxzZTtcbiAgICAgICAgICAgIGxldCBpc05leHRTaGlmdGVkID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gJyc7XG4gICAgICAgICAgICBsZXQgbGFzdFN0YXJ0ID0gc3RhcnRQYXR0ZXJuSW5mb1swXTtcbiAgICAgICAgICAgIGxldCBuZXh0U3RhcnQgPSBzdGFydFBhdHRlcm5JbmZvWzFdO1xuICAgICAgICAgICAgY29uc3QgY291bnRlcnMgPSBJbnQzMkFycmF5LmZyb20oWzAsIDAsIDAsIDAsIDAsIDBdKTtcbiAgICAgICAgICAgIGxldCBsYXN0Q29kZSA9IDA7XG4gICAgICAgICAgICBsZXQgY29kZSA9IDA7XG4gICAgICAgICAgICBsZXQgY2hlY2tzdW1Ub3RhbCA9IHN0YXJ0Q29kZTtcbiAgICAgICAgICAgIGxldCBtdWx0aXBsaWVyID0gMDtcbiAgICAgICAgICAgIGxldCBsYXN0Q2hhcmFjdGVyV2FzUHJpbnRhYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgIGxldCB1cHBlck1vZGUgPSBmYWxzZTtcbiAgICAgICAgICAgIGxldCBzaGlmdFVwcGVyTW9kZSA9IGZhbHNlO1xuICAgICAgICAgICAgd2hpbGUgKCFkb25lKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdW5zaGlmdCA9IGlzTmV4dFNoaWZ0ZWQ7XG4gICAgICAgICAgICAgICAgaXNOZXh0U2hpZnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIC8vIFNhdmUgb2ZmIGxhc3QgY29kZVxuICAgICAgICAgICAgICAgIGxhc3RDb2RlID0gY29kZTtcbiAgICAgICAgICAgICAgICAvLyBEZWNvZGUgYW5vdGhlciBjb2RlIGZyb20gaW1hZ2VcbiAgICAgICAgICAgICAgICBjb2RlID0gQ29kZTEyOFJlYWRlci5kZWNvZGVDb2RlKHJvdywgY291bnRlcnMsIG5leHRTdGFydCk7XG4gICAgICAgICAgICAgICAgcmF3Q29kZXNbY3VycmVudFJhd0NvZGVzSW5kZXgrK10gPSBjb2RlO1xuICAgICAgICAgICAgICAgIC8vIFJlbWVtYmVyIHdoZXRoZXIgdGhlIGxhc3QgY29kZSB3YXMgcHJpbnRhYmxlIG9yIG5vdCAoZXhjbHVkaW5nIENPREVfU1RPUClcbiAgICAgICAgICAgICAgICBpZiAoY29kZSAhPT0gQ29kZTEyOFJlYWRlci5DT0RFX1NUT1ApIHtcbiAgICAgICAgICAgICAgICAgICAgbGFzdENoYXJhY3Rlcldhc1ByaW50YWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEFkZCB0byBjaGVja3N1bSBjb21wdXRhdGlvbiAoaWYgbm90IENPREVfU1RPUCBvZiBjb3Vyc2UpXG4gICAgICAgICAgICAgICAgaWYgKGNvZGUgIT09IENvZGUxMjhSZWFkZXIuQ09ERV9TVE9QKSB7XG4gICAgICAgICAgICAgICAgICAgIG11bHRpcGxpZXIrKztcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tzdW1Ub3RhbCArPSBtdWx0aXBsaWVyICogY29kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQWR2YW5jZSB0byB3aGVyZSB0aGUgbmV4dCBjb2RlIHdpbGwgdG8gc3RhcnRcbiAgICAgICAgICAgICAgICBsYXN0U3RhcnQgPSBuZXh0U3RhcnQ7XG4gICAgICAgICAgICAgICAgbmV4dFN0YXJ0ICs9IGNvdW50ZXJzLnJlZHVjZSgocHJldmlvdXMsIGN1cnJlbnQpID0+IHByZXZpb3VzICsgY3VycmVudCwgMCk7XG4gICAgICAgICAgICAgICAgLy8gVGFrZSBjYXJlIG9mIGlsbGVnYWwgc3RhcnQgY29kZXNcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBDb2RlMTI4UmVhZGVyLkNPREVfU1RBUlRfQTpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBDb2RlMTI4UmVhZGVyLkNPREVfU1RBUlRfQjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBDb2RlMTI4UmVhZGVyLkNPREVfU1RBUlRfQzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3dpdGNoIChjb2RlU2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgQ29kZTEyOFJlYWRlci5DT0RFX0NPREVfQTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2RlIDwgNjQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2hpZnRVcHBlck1vZGUgPT09IHVwcGVyTW9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoJyAnLmNoYXJDb2RlQXQoMCkgKyBjb2RlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoJyAnLmNoYXJDb2RlQXQoMCkgKyBjb2RlICsgMTI4KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoaWZ0VXBwZXJNb2RlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjb2RlIDwgOTYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2hpZnRVcHBlck1vZGUgPT09IHVwcGVyTW9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoY29kZSAtIDY0KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoY29kZSArIDY0KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoaWZ0VXBwZXJNb2RlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEb24ndCBsZXQgQ09ERV9TVE9QLCB3aGljaCBhbHdheXMgYXBwZWFycywgYWZmZWN0IHdoZXRoZXIgd2hldGhlciB3ZSB0aGluayB0aGUgbGFzdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvZGUgd2FzIHByaW50YWJsZSBvciBub3QuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGUgIT09IENvZGUxMjhSZWFkZXIuQ09ERV9TVE9QKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RDaGFyYWN0ZXJXYXNQcmludGFibGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChjb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQ29kZTEyOFJlYWRlci5DT0RFX0ZOQ18xOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnZlcnRGTkMxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gR1MxIHNwZWNpZmljYXRpb24gNS40LjMuNy4gYW5kIDUuNC42LjQuIElmIHRoZSBmaXJzdCBjaGFyIGFmdGVyIHRoZSBzdGFydCBjb2RlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlzIEZOQzEgdGhlbiB0aGlzIGlzIEdTMS0xMjguIFdlIGFkZCB0aGUgc3ltYm9sb2d5IGlkZW50aWZpZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnXUMxJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdTMSBzcGVjaWZpY2F0aW9uIDUuNC43LjUuIEV2ZXJ5IHN1YnNlcXVlbnQgRk5DMSBpcyByZXR1cm5lZCBhcyBBU0NJSSAyOSAoR1MpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDI5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBDb2RlMTI4UmVhZGVyLkNPREVfRk5DXzI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQ29kZTEyOFJlYWRlci5DT0RFX0ZOQ18zOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZG8gbm90aGluZz9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIENvZGUxMjhSZWFkZXIuQ09ERV9GTkNfNF9BOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF1cHBlck1vZGUgJiYgc2hpZnRVcHBlck1vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cHBlck1vZGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoaWZ0VXBwZXJNb2RlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh1cHBlck1vZGUgJiYgc2hpZnRVcHBlck1vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cHBlck1vZGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGlmdFVwcGVyTW9kZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hpZnRVcHBlck1vZGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQ29kZTEyOFJlYWRlci5DT0RFX1NISUZUOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNOZXh0U2hpZnRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlU2V0ID0gQ29kZTEyOFJlYWRlci5DT0RFX0NPREVfQjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIENvZGUxMjhSZWFkZXIuQ09ERV9DT0RFX0I6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlU2V0ID0gQ29kZTEyOFJlYWRlci5DT0RFX0NPREVfQjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIENvZGUxMjhSZWFkZXIuQ09ERV9DT0RFX0M6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlU2V0ID0gQ29kZTEyOFJlYWRlci5DT0RFX0NPREVfQztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIENvZGUxMjhSZWFkZXIuQ09ERV9TVE9QOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBDb2RlMTI4UmVhZGVyLkNPREVfQ09ERV9COlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGUgPCA5Nikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaGlmdFVwcGVyTW9kZSA9PT0gdXBwZXJNb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCgnICcuY2hhckNvZGVBdCgwKSArIGNvZGUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCgnICcuY2hhckNvZGVBdCgwKSArIGNvZGUgKyAxMjgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hpZnRVcHBlck1vZGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2RlICE9PSBDb2RlMTI4UmVhZGVyLkNPREVfU1RPUCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0Q2hhcmFjdGVyV2FzUHJpbnRhYmxlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIENvZGUxMjhSZWFkZXIuQ09ERV9GTkNfMTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb252ZXJ0Rk5DMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdTMSBzcGVjaWZpY2F0aW9uIDUuNC4zLjcuIGFuZCA1LjQuNi40LiBJZiB0aGUgZmlyc3QgY2hhciBhZnRlciB0aGUgc3RhcnQgY29kZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpcyBGTkMxIHRoZW4gdGhpcyBpcyBHUzEtMTI4LiBXZSBhZGQgdGhlIHN5bWJvbG9neSBpZGVudGlmaWVyLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ11DMSc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBHUzEgc3BlY2lmaWNhdGlvbiA1LjQuNy41LiBFdmVyeSBzdWJzZXF1ZW50IEZOQzEgaXMgcmV0dXJuZWQgYXMgQVNDSUkgMjkgKEdTKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgyOSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQ29kZTEyOFJlYWRlci5DT0RFX0ZOQ18yOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIENvZGUxMjhSZWFkZXIuQ09ERV9GTkNfMzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRvIG5vdGhpbmc/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBDb2RlMTI4UmVhZGVyLkNPREVfRk5DXzRfQjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdXBwZXJNb2RlICYmIHNoaWZ0VXBwZXJNb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBwZXJNb2RlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGlmdFVwcGVyTW9kZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodXBwZXJNb2RlICYmIHNoaWZ0VXBwZXJNb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBwZXJNb2RlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hpZnRVcHBlck1vZGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoaWZ0VXBwZXJNb2RlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIENvZGUxMjhSZWFkZXIuQ09ERV9TSElGVDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzTmV4dFNoaWZ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZVNldCA9IENvZGUxMjhSZWFkZXIuQ09ERV9DT0RFX0E7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBDb2RlMTI4UmVhZGVyLkNPREVfQ09ERV9BOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZVNldCA9IENvZGUxMjhSZWFkZXIuQ09ERV9DT0RFX0E7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBDb2RlMTI4UmVhZGVyLkNPREVfQ09ERV9DOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZVNldCA9IENvZGUxMjhSZWFkZXIuQ09ERV9DT0RFX0M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBDb2RlMTI4UmVhZGVyLkNPREVfU1RPUDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgQ29kZTEyOFJlYWRlci5DT0RFX0NPREVfQzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2RlIDwgMTAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGUgPCAxMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gJzAnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gY29kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2RlICE9PSBDb2RlMTI4UmVhZGVyLkNPREVfU1RPUCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0Q2hhcmFjdGVyV2FzUHJpbnRhYmxlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIENvZGUxMjhSZWFkZXIuQ09ERV9GTkNfMTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb252ZXJ0Rk5DMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdTMSBzcGVjaWZpY2F0aW9uIDUuNC4zLjcuIGFuZCA1LjQuNi40LiBJZiB0aGUgZmlyc3QgY2hhciBhZnRlciB0aGUgc3RhcnQgY29kZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpcyBGTkMxIHRoZW4gdGhpcyBpcyBHUzEtMTI4LiBXZSBhZGQgdGhlIHN5bWJvbG9neSBpZGVudGlmaWVyLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ11DMSc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBHUzEgc3BlY2lmaWNhdGlvbiA1LjQuNy41LiBFdmVyeSBzdWJzZXF1ZW50IEZOQzEgaXMgcmV0dXJuZWQgYXMgQVNDSUkgMjkgKEdTKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgyOSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQ29kZTEyOFJlYWRlci5DT0RFX0NPREVfQTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVTZXQgPSBDb2RlMTI4UmVhZGVyLkNPREVfQ09ERV9BO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQ29kZTEyOFJlYWRlci5DT0RFX0NPREVfQjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVTZXQgPSBDb2RlMTI4UmVhZGVyLkNPREVfQ09ERV9CO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQ29kZTEyOFJlYWRlci5DT0RFX1NUT1A6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBVbnNoaWZ0IGJhY2sgdG8gYW5vdGhlciBjb2RlIHNldCBpZiB3ZSB3ZXJlIHNoaWZ0ZWRcbiAgICAgICAgICAgICAgICBpZiAodW5zaGlmdCkge1xuICAgICAgICAgICAgICAgICAgICBjb2RlU2V0ID0gY29kZVNldCA9PT0gQ29kZTEyOFJlYWRlci5DT0RFX0NPREVfQSA/IENvZGUxMjhSZWFkZXIuQ09ERV9DT0RFX0IgOiBDb2RlMTI4UmVhZGVyLkNPREVfQ09ERV9BO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxhc3RQYXR0ZXJuU2l6ZSA9IG5leHRTdGFydCAtIGxhc3RTdGFydDtcbiAgICAgICAgICAgIC8vIENoZWNrIGZvciBhbXBsZSB3aGl0ZXNwYWNlIGZvbGxvd2luZyBwYXR0ZXJuLCBidXQsIHRvIGRvIHRoaXMgd2UgZmlyc3QgbmVlZCB0byByZW1lbWJlciB0aGF0XG4gICAgICAgICAgICAvLyB3ZSBmdWRnZWQgZGVjb2RpbmcgQ09ERV9TVE9QIHNpbmNlIGl0IGFjdHVhbGx5IGhhcyA3IGJhcnMsIG5vdCA2LiBUaGVyZSBpcyBhIGJsYWNrIGJhciBsZWZ0XG4gICAgICAgICAgICAvLyB0byByZWFkIG9mZi4gV291bGQgYmUgc2xpZ2h0bHkgYmV0dGVyIHRvIHByb3Blcmx5IHJlYWQuIEhlcmUgd2UganVzdCBza2lwIGl0OlxuICAgICAgICAgICAgbmV4dFN0YXJ0ID0gcm93LmdldE5leHRVbnNldChuZXh0U3RhcnQpO1xuICAgICAgICAgICAgaWYgKCFyb3cuaXNSYW5nZShuZXh0U3RhcnQsIE1hdGgubWluKHJvdy5nZXRTaXplKCksIG5leHRTdGFydCArIChuZXh0U3RhcnQgLSBsYXN0U3RhcnQpIC8gMiksIGZhbHNlKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUHVsbCBvdXQgZnJvbSBzdW0gdGhlIHZhbHVlIG9mIHRoZSBwZW51bHRpbWF0ZSBjaGVjayBjb2RlXG4gICAgICAgICAgICBjaGVja3N1bVRvdGFsIC09IG11bHRpcGxpZXIgKiBsYXN0Q29kZTtcbiAgICAgICAgICAgIC8vIGxhc3RDb2RlIGlzIHRoZSBjaGVja3N1bSB0aGVuOlxuICAgICAgICAgICAgaWYgKGNoZWNrc3VtVG90YWwgJSAxMDMgIT09IGxhc3RDb2RlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IENoZWNrc3VtRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBOZWVkIHRvIHB1bGwgb3V0IHRoZSBjaGVjayBkaWdpdHMgZnJvbSBzdHJpbmdcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdExlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG4gICAgICAgICAgICBpZiAocmVzdWx0TGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gZmFsc2UgcG9zaXRpdmVcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE9ubHkgYm90aGVyIGlmIHRoZSByZXN1bHQgaGFkIGF0IGxlYXN0IG9uZSBjaGFyYWN0ZXIsIGFuZCBpZiB0aGUgY2hlY2tzdW0gZGlnaXQgaGFwcGVuZWQgdG9cbiAgICAgICAgICAgIC8vIGJlIGEgcHJpbnRhYmxlIGNoYXJhY3Rlci4gSWYgaXQgd2FzIGp1c3QgaW50ZXJwcmV0ZWQgYXMgYSBjb250cm9sIGNvZGUsIG5vdGhpbmcgdG8gcmVtb3ZlLlxuICAgICAgICAgICAgaWYgKHJlc3VsdExlbmd0aCA+IDAgJiYgbGFzdENoYXJhY3Rlcldhc1ByaW50YWJsZSkge1xuICAgICAgICAgICAgICAgIGlmIChjb2RlU2V0ID09PSBDb2RlMTI4UmVhZGVyLkNPREVfQ09ERV9DKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5zdWJzdHJpbmcoMCwgcmVzdWx0TGVuZ3RoIC0gMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuc3Vic3RyaW5nKDAsIHJlc3VsdExlbmd0aCAtIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxlZnQgPSAoc3RhcnRQYXR0ZXJuSW5mb1sxXSArIHN0YXJ0UGF0dGVybkluZm9bMF0pIC8gMi4wO1xuICAgICAgICAgICAgY29uc3QgcmlnaHQgPSBsYXN0U3RhcnQgKyBsYXN0UGF0dGVyblNpemUgLyAyLjA7XG4gICAgICAgICAgICBjb25zdCByYXdDb2Rlc1NpemUgPSByYXdDb2Rlcy5sZW5ndGg7XG4gICAgICAgICAgICBjb25zdCByYXdCeXRlcyA9IG5ldyBVaW50OEFycmF5KHJhd0NvZGVzU2l6ZSk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJhd0NvZGVzU2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcmF3Qnl0ZXNbaV0gPSByYXdDb2Rlc1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHBvaW50cyA9IFtuZXcgUmVzdWx0UG9pbnQobGVmdCwgcm93TnVtYmVyKSwgbmV3IFJlc3VsdFBvaW50KHJpZ2h0LCByb3dOdW1iZXIpXTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVzdWx0KHJlc3VsdCwgcmF3Qnl0ZXMsIDAsIHBvaW50cywgQmFyY29kZUZvcm1hdCQxLkNPREVfMTI4LCBuZXcgRGF0ZSgpLmdldFRpbWUoKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgQ29kZTEyOFJlYWRlci5DT0RFX1BBVFRFUk5TID0gW1xuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzIsIDEsIDIsIDIsIDIsIDJdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsyLCAyLCAyLCAxLCAyLCAyXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMiwgMiwgMiwgMiwgMiwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDIsIDEsIDIsIDIsIDNdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAyLCAxLCAzLCAyLCAyXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMywgMSwgMiwgMiwgMl0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDIsIDIsIDIsIDEsIDNdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAyLCAyLCAzLCAxLCAyXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMywgMiwgMiwgMSwgMl0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzIsIDIsIDEsIDIsIDEsIDNdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsyLCAyLCAxLCAzLCAxLCAyXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMiwgMywgMSwgMiwgMSwgMl0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDEsIDIsIDIsIDMsIDJdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAyLCAyLCAxLCAzLCAyXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMiwgMiwgMiwgMywgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDEsIDMsIDIsIDIsIDJdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAyLCAzLCAxLCAyLCAyXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMiwgMywgMiwgMiwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzIsIDIsIDMsIDIsIDEsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsyLCAyLCAxLCAxLCAzLCAyXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMiwgMiwgMSwgMiwgMywgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzIsIDEsIDMsIDIsIDEsIDJdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsyLCAyLCAzLCAxLCAxLCAyXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMywgMSwgMiwgMSwgMywgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzMsIDEsIDEsIDIsIDIsIDJdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFszLCAyLCAxLCAxLCAyLCAyXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMywgMiwgMSwgMiwgMiwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzMsIDEsIDIsIDIsIDEsIDJdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFszLCAyLCAyLCAxLCAxLCAyXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMywgMiwgMiwgMiwgMSwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzIsIDEsIDIsIDEsIDIsIDNdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsyLCAxLCAyLCAzLCAyLCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMiwgMywgMiwgMSwgMiwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDEsIDEsIDMsIDIsIDNdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAzLCAxLCAxLCAyLCAzXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMywgMSwgMywgMiwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDEsIDIsIDMsIDEsIDNdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAzLCAyLCAxLCAxLCAzXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMywgMiwgMywgMSwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzIsIDEsIDEsIDMsIDEsIDNdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsyLCAzLCAxLCAxLCAxLCAzXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMiwgMywgMSwgMywgMSwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDEsIDIsIDEsIDMsIDNdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAxLCAyLCAzLCAzLCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMywgMiwgMSwgMywgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDEsIDMsIDEsIDIsIDNdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAxLCAzLCAzLCAyLCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMywgMywgMSwgMiwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzMsIDEsIDMsIDEsIDIsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsyLCAxLCAxLCAzLCAzLCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMiwgMywgMSwgMSwgMywgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzIsIDEsIDMsIDEsIDEsIDNdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsyLCAxLCAzLCAzLCAxLCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMiwgMSwgMywgMSwgMywgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzMsIDEsIDEsIDEsIDIsIDNdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFszLCAxLCAxLCAzLCAyLCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMywgMywgMSwgMSwgMiwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzMsIDEsIDIsIDEsIDEsIDNdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFszLCAxLCAyLCAzLCAxLCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMywgMywgMiwgMSwgMSwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzMsIDEsIDQsIDEsIDEsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsyLCAyLCAxLCA0LCAxLCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNCwgMywgMSwgMSwgMSwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDEsIDEsIDIsIDIsIDRdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAxLCAxLCA0LCAyLCAyXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMiwgMSwgMSwgMiwgNF0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDIsIDEsIDQsIDIsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCA0LCAxLCAxLCAyLCAyXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgNCwgMSwgMiwgMiwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDEsIDIsIDIsIDEsIDRdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAxLCAyLCA0LCAxLCAyXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMiwgMiwgMSwgMSwgNF0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDIsIDIsIDQsIDEsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCA0LCAyLCAxLCAxLCAyXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgNCwgMiwgMiwgMSwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzIsIDQsIDEsIDIsIDEsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsyLCAyLCAxLCAxLCAxLCA0XSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNCwgMSwgMywgMSwgMSwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzIsIDQsIDEsIDEsIDEsIDJdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAzLCA0LCAxLCAxLCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMSwgMSwgMiwgNCwgMl0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDIsIDEsIDEsIDQsIDJdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAyLCAxLCAyLCA0LCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMSwgNCwgMiwgMSwgMl0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDIsIDQsIDEsIDEsIDJdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAyLCA0LCAyLCAxLCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNCwgMSwgMSwgMiwgMSwgMl0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzQsIDIsIDEsIDEsIDEsIDJdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFs0LCAyLCAxLCAyLCAxLCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMiwgMSwgMiwgMSwgNCwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzIsIDEsIDQsIDEsIDIsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFs0LCAxLCAyLCAxLCAyLCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMSwgMSwgMSwgNCwgM10pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDEsIDEsIDMsIDQsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAzLCAxLCAxLCA0LCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMSwgNCwgMSwgMSwgM10pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDEsIDQsIDMsIDEsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFs0LCAxLCAxLCAxLCAxLCAzXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNCwgMSwgMSwgMywgMSwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDEsIDMsIDEsIDQsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAxLCA0LCAxLCAzLCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMywgMSwgMSwgMSwgNCwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzQsIDEsIDEsIDEsIDMsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsyLCAxLCAxLCA0LCAxLCAyXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMiwgMSwgMSwgMiwgMSwgNF0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzIsIDEsIDEsIDIsIDMsIDJdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsyLCAzLCAzLCAxLCAxLCAxLCAyXSksXG4gICAgXTtcbiAgICBDb2RlMTI4UmVhZGVyLk1BWF9BVkdfVkFSSUFOQ0UgPSAwLjI1O1xuICAgIENvZGUxMjhSZWFkZXIuTUFYX0lORElWSURVQUxfVkFSSUFOQ0UgPSAwLjc7XG4gICAgQ29kZTEyOFJlYWRlci5DT0RFX1NISUZUID0gOTg7XG4gICAgQ29kZTEyOFJlYWRlci5DT0RFX0NPREVfQyA9IDk5O1xuICAgIENvZGUxMjhSZWFkZXIuQ09ERV9DT0RFX0IgPSAxMDA7XG4gICAgQ29kZTEyOFJlYWRlci5DT0RFX0NPREVfQSA9IDEwMTtcbiAgICBDb2RlMTI4UmVhZGVyLkNPREVfRk5DXzEgPSAxMDI7XG4gICAgQ29kZTEyOFJlYWRlci5DT0RFX0ZOQ18yID0gOTc7XG4gICAgQ29kZTEyOFJlYWRlci5DT0RFX0ZOQ18zID0gOTY7XG4gICAgQ29kZTEyOFJlYWRlci5DT0RFX0ZOQ180X0EgPSAxMDE7XG4gICAgQ29kZTEyOFJlYWRlci5DT0RFX0ZOQ180X0IgPSAxMDA7XG4gICAgQ29kZTEyOFJlYWRlci5DT0RFX1NUQVJUX0EgPSAxMDM7XG4gICAgQ29kZTEyOFJlYWRlci5DT0RFX1NUQVJUX0IgPSAxMDQ7XG4gICAgQ29kZTEyOFJlYWRlci5DT0RFX1NUQVJUX0MgPSAxMDU7XG4gICAgQ29kZTEyOFJlYWRlci5DT0RFX1NUT1AgPSAxMDY7XG5cbiAgICAvKipcbiAgICAgKiA8cD5EZWNvZGVzIENvZGUgMzkgYmFyY29kZXMuIFN1cHBvcnRzIFwiRnVsbCBBU0NJSSBDb2RlIDM5XCIgaWYgVVNFX0NPREVfMzlfRVhURU5ERURfTU9ERSBpcyBzZXQuPC9wPlxuICAgICAqXG4gICAgICogQGF1dGhvciBTZWFuIE93ZW5cbiAgICAgKiBAc2VlIENvZGU5M1JlYWRlclxuICAgICAqL1xuICAgIGNsYXNzIENvZGUzOVJlYWRlciBleHRlbmRzIE9uZURSZWFkZXIge1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIHJlYWRlciB0aGF0IGFzc3VtZXMgYWxsIGVuY29kZWQgZGF0YSBpcyBkYXRhLCBhbmQgZG9lcyBub3QgdHJlYXQgdGhlIGZpbmFsXG4gICAgICAgICAqIGNoYXJhY3RlciBhcyBhIGNoZWNrIGRpZ2l0LiBJdCB3aWxsIG5vdCBkZWNvZGVkIFwiZXh0ZW5kZWQgQ29kZSAzOVwiIHNlcXVlbmNlcy5cbiAgICAgICAgICovXG4gICAgICAgIC8vIHB1YmxpYyBDb2RlMzlSZWFkZXIoKSB7XG4gICAgICAgIC8vICAgdGhpcyhmYWxzZSk7XG4gICAgICAgIC8vIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSByZWFkZXIgdGhhdCBjYW4gYmUgY29uZmlndXJlZCB0byBjaGVjayB0aGUgbGFzdCBjaGFyYWN0ZXIgYXMgYSBjaGVjayBkaWdpdC5cbiAgICAgICAgICogSXQgd2lsbCBub3QgZGVjb2RlZCBcImV4dGVuZGVkIENvZGUgMzlcIiBzZXF1ZW5jZXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB1c2luZ0NoZWNrRGlnaXQgaWYgdHJ1ZSwgdHJlYXQgdGhlIGxhc3QgZGF0YSBjaGFyYWN0ZXIgYXMgYSBjaGVjayBkaWdpdCwgbm90XG4gICAgICAgICAqIGRhdGEsIGFuZCB2ZXJpZnkgdGhhdCB0aGUgY2hlY2tzdW0gcGFzc2VzLlxuICAgICAgICAgKi9cbiAgICAgICAgLy8gcHVibGljIENvZGUzOVJlYWRlcihib29sZWFuIHVzaW5nQ2hlY2tEaWdpdCkge1xuICAgICAgICAvLyAgIHRoaXModXNpbmdDaGVja0RpZ2l0LCBmYWxzZSk7XG4gICAgICAgIC8vIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSByZWFkZXIgdGhhdCBjYW4gYmUgY29uZmlndXJlZCB0byBjaGVjayB0aGUgbGFzdCBjaGFyYWN0ZXIgYXMgYSBjaGVjayBkaWdpdCxcbiAgICAgICAgICogb3Igb3B0aW9uYWxseSBhdHRlbXB0IHRvIGRlY29kZSBcImV4dGVuZGVkIENvZGUgMzlcIiBzZXF1ZW5jZXMgdGhhdCBhcmUgdXNlZCB0byBlbmNvZGVcbiAgICAgICAgICogdGhlIGZ1bGwgQVNDSUkgY2hhcmFjdGVyIHNldC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHVzaW5nQ2hlY2tEaWdpdCBpZiB0cnVlLCB0cmVhdCB0aGUgbGFzdCBkYXRhIGNoYXJhY3RlciBhcyBhIGNoZWNrIGRpZ2l0LCBub3RcbiAgICAgICAgICogZGF0YSwgYW5kIHZlcmlmeSB0aGF0IHRoZSBjaGVja3N1bSBwYXNzZXMuXG4gICAgICAgICAqIEBwYXJhbSBleHRlbmRlZE1vZGUgaWYgdHJ1ZSwgd2lsbCBhdHRlbXB0IHRvIGRlY29kZSBleHRlbmRlZCBDb2RlIDM5IHNlcXVlbmNlcyBpbiB0aGVcbiAgICAgICAgICogdGV4dC5cbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0cnVjdG9yKHVzaW5nQ2hlY2tEaWdpdCA9IGZhbHNlLCBleHRlbmRlZE1vZGUgPSBmYWxzZSkge1xuICAgICAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgICAgIHRoaXMudXNpbmdDaGVja0RpZ2l0ID0gdXNpbmdDaGVja0RpZ2l0O1xuICAgICAgICAgICAgdGhpcy5leHRlbmRlZE1vZGUgPSBleHRlbmRlZE1vZGU7XG4gICAgICAgICAgICB0aGlzLmRlY29kZVJvd1Jlc3VsdCA9ICcnO1xuICAgICAgICAgICAgdGhpcy5jb3VudGVycyA9IG5ldyBJbnQzMkFycmF5KDkpO1xuICAgICAgICB9XG4gICAgICAgIGRlY29kZVJvdyhyb3dOdW1iZXIsIHJvdywgaGludHMpIHtcbiAgICAgICAgICAgIGxldCB0aGVDb3VudGVycyA9IHRoaXMuY291bnRlcnM7XG4gICAgICAgICAgICB0aGVDb3VudGVycy5maWxsKDApO1xuICAgICAgICAgICAgdGhpcy5kZWNvZGVSb3dSZXN1bHQgPSAnJztcbiAgICAgICAgICAgIGxldCBzdGFydCA9IENvZGUzOVJlYWRlci5maW5kQXN0ZXJpc2tQYXR0ZXJuKHJvdywgdGhlQ291bnRlcnMpO1xuICAgICAgICAgICAgLy8gUmVhZCBvZmYgd2hpdGUgc3BhY2VcbiAgICAgICAgICAgIGxldCBuZXh0U3RhcnQgPSByb3cuZ2V0TmV4dFNldChzdGFydFsxXSk7XG4gICAgICAgICAgICBsZXQgZW5kID0gcm93LmdldFNpemUoKTtcbiAgICAgICAgICAgIGxldCBkZWNvZGVkQ2hhcjtcbiAgICAgICAgICAgIGxldCBsYXN0U3RhcnQ7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgQ29kZTM5UmVhZGVyLnJlY29yZFBhdHRlcm4ocm93LCBuZXh0U3RhcnQsIHRoZUNvdW50ZXJzKTtcbiAgICAgICAgICAgICAgICBsZXQgcGF0dGVybiA9IENvZGUzOVJlYWRlci50b05hcnJvd1dpZGVQYXR0ZXJuKHRoZUNvdW50ZXJzKTtcbiAgICAgICAgICAgICAgICBpZiAocGF0dGVybiA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlY29kZWRDaGFyID0gQ29kZTM5UmVhZGVyLnBhdHRlcm5Ub0NoYXIocGF0dGVybik7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWNvZGVSb3dSZXN1bHQgKz0gZGVjb2RlZENoYXI7XG4gICAgICAgICAgICAgICAgbGFzdFN0YXJ0ID0gbmV4dFN0YXJ0O1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGNvdW50ZXIgb2YgdGhlQ291bnRlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dFN0YXJ0ICs9IGNvdW50ZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFJlYWQgb2ZmIHdoaXRlIHNwYWNlXG4gICAgICAgICAgICAgICAgbmV4dFN0YXJ0ID0gcm93LmdldE5leHRTZXQobmV4dFN0YXJ0KTtcbiAgICAgICAgICAgIH0gd2hpbGUgKGRlY29kZWRDaGFyICE9PSAnKicpO1xuICAgICAgICAgICAgdGhpcy5kZWNvZGVSb3dSZXN1bHQgPSB0aGlzLmRlY29kZVJvd1Jlc3VsdC5zdWJzdHJpbmcoMCwgdGhpcy5kZWNvZGVSb3dSZXN1bHQubGVuZ3RoIC0gMSk7IC8vIHJlbW92ZSBhc3Rlcmlza1xuICAgICAgICAgICAgLy8gTG9vayBmb3Igd2hpdGVzcGFjZSBhZnRlciBwYXR0ZXJuOlxuICAgICAgICAgICAgbGV0IGxhc3RQYXR0ZXJuU2l6ZSA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCBjb3VudGVyIG9mIHRoZUNvdW50ZXJzKSB7XG4gICAgICAgICAgICAgICAgbGFzdFBhdHRlcm5TaXplICs9IGNvdW50ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgd2hpdGVTcGFjZUFmdGVyRW5kID0gbmV4dFN0YXJ0IC0gbGFzdFN0YXJ0IC0gbGFzdFBhdHRlcm5TaXplO1xuICAgICAgICAgICAgLy8gSWYgNTAlIG9mIGxhc3QgcGF0dGVybiBzaXplLCBmb2xsb3dpbmcgbGFzdCBwYXR0ZXJuLCBpcyBub3Qgd2hpdGVzcGFjZSwgZmFpbFxuICAgICAgICAgICAgLy8gKGJ1dCBpZiBpdCdzIHdoaXRlc3BhY2UgdG8gdGhlIHZlcnkgZW5kIG9mIHRoZSBpbWFnZSwgdGhhdCdzIE9LKVxuICAgICAgICAgICAgaWYgKG5leHRTdGFydCAhPT0gZW5kICYmICh3aGl0ZVNwYWNlQWZ0ZXJFbmQgKiAyKSA8IGxhc3RQYXR0ZXJuU2l6ZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMudXNpbmdDaGVja0RpZ2l0KSB7XG4gICAgICAgICAgICAgICAgbGV0IG1heCA9IHRoaXMuZGVjb2RlUm93UmVzdWx0Lmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgbGV0IHRvdGFsID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1heDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvdGFsICs9IENvZGUzOVJlYWRlci5BTFBIQUJFVF9TVFJJTkcuaW5kZXhPZih0aGlzLmRlY29kZVJvd1Jlc3VsdC5jaGFyQXQoaSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kZWNvZGVSb3dSZXN1bHQuY2hhckF0KG1heCkgIT09IENvZGUzOVJlYWRlci5BTFBIQUJFVF9TVFJJTkcuY2hhckF0KHRvdGFsICUgNDMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBDaGVja3N1bUV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmRlY29kZVJvd1Jlc3VsdCA9IHRoaXMuZGVjb2RlUm93UmVzdWx0LnN1YnN0cmluZygwLCBtYXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuZGVjb2RlUm93UmVzdWx0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIGZhbHNlIHBvc2l0aXZlXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcmVzdWx0U3RyaW5nO1xuICAgICAgICAgICAgaWYgKHRoaXMuZXh0ZW5kZWRNb2RlKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0U3RyaW5nID0gQ29kZTM5UmVhZGVyLmRlY29kZUV4dGVuZGVkKHRoaXMuZGVjb2RlUm93UmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyA9IHRoaXMuZGVjb2RlUm93UmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGxlZnQgPSAoc3RhcnRbMV0gKyBzdGFydFswXSkgLyAyLjA7XG4gICAgICAgICAgICBsZXQgcmlnaHQgPSBsYXN0U3RhcnQgKyBsYXN0UGF0dGVyblNpemUgLyAyLjA7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlc3VsdChyZXN1bHRTdHJpbmcsIG51bGwsIDAsIFtuZXcgUmVzdWx0UG9pbnQobGVmdCwgcm93TnVtYmVyKSwgbmV3IFJlc3VsdFBvaW50KHJpZ2h0LCByb3dOdW1iZXIpXSwgQmFyY29kZUZvcm1hdCQxLkNPREVfMzksIG5ldyBEYXRlKCkuZ2V0VGltZSgpKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgZmluZEFzdGVyaXNrUGF0dGVybihyb3csIGNvdW50ZXJzKSB7XG4gICAgICAgICAgICBsZXQgd2lkdGggPSByb3cuZ2V0U2l6ZSgpO1xuICAgICAgICAgICAgbGV0IHJvd09mZnNldCA9IHJvdy5nZXROZXh0U2V0KDApO1xuICAgICAgICAgICAgbGV0IGNvdW50ZXJQb3NpdGlvbiA9IDA7XG4gICAgICAgICAgICBsZXQgcGF0dGVyblN0YXJ0ID0gcm93T2Zmc2V0O1xuICAgICAgICAgICAgbGV0IGlzV2hpdGUgPSBmYWxzZTtcbiAgICAgICAgICAgIGxldCBwYXR0ZXJuTGVuZ3RoID0gY291bnRlcnMubGVuZ3RoO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHJvd09mZnNldDsgaSA8IHdpZHRoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAocm93LmdldChpKSAhPT0gaXNXaGl0ZSkge1xuICAgICAgICAgICAgICAgICAgICBjb3VudGVyc1tjb3VudGVyUG9zaXRpb25dKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY291bnRlclBvc2l0aW9uID09PSBwYXR0ZXJuTGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTG9vayBmb3Igd2hpdGVzcGFjZSBiZWZvcmUgc3RhcnQgcGF0dGVybiwgPj0gNTAlIG9mIHdpZHRoIG9mIHN0YXJ0IHBhdHRlcm5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnRvTmFycm93V2lkZVBhdHRlcm4oY291bnRlcnMpID09PSBDb2RlMzlSZWFkZXIuQVNURVJJU0tfRU5DT0RJTkcgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3cuaXNSYW5nZShNYXRoLm1heCgwLCBwYXR0ZXJuU3RhcnQgLSBNYXRoLmZsb29yKChpIC0gcGF0dGVyblN0YXJ0KSAvIDIpKSwgcGF0dGVyblN0YXJ0LCBmYWxzZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW3BhdHRlcm5TdGFydCwgaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuU3RhcnQgKz0gY291bnRlcnNbMF0gKyBjb3VudGVyc1sxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJzLmNvcHlXaXRoaW4oMCwgMiwgMiArIGNvdW50ZXJQb3NpdGlvbiAtIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlcnNbY291bnRlclBvc2l0aW9uIC0gMV0gPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlcnNbY291bnRlclBvc2l0aW9uXSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyUG9zaXRpb24tLTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJQb3NpdGlvbisrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJzW2NvdW50ZXJQb3NpdGlvbl0gPSAxO1xuICAgICAgICAgICAgICAgICAgICBpc1doaXRlID0gIWlzV2hpdGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRm9yIGVmZmljaWVuY3ksIHJldHVybnMgLTEgb24gZmFpbHVyZS4gTm90IHRocm93aW5nIGhlcmUgc2F2ZWQgYXMgbWFueSBhcyA3MDAgZXhjZXB0aW9uc1xuICAgICAgICAvLyBwZXIgaW1hZ2Ugd2hlbiB1c2luZyBzb21lIG9mIG91ciBibGFja2JveCBpbWFnZXMuXG4gICAgICAgIHN0YXRpYyB0b05hcnJvd1dpZGVQYXR0ZXJuKGNvdW50ZXJzKSB7XG4gICAgICAgICAgICBsZXQgbnVtQ291bnRlcnMgPSBjb3VudGVycy5sZW5ndGg7XG4gICAgICAgICAgICBsZXQgbWF4TmFycm93Q291bnRlciA9IDA7XG4gICAgICAgICAgICBsZXQgd2lkZUNvdW50ZXJzO1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIGxldCBtaW5Db3VudGVyID0gMHg3ZmZmZmZmZjtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBjb3VudGVyIG9mIGNvdW50ZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb3VudGVyIDwgbWluQ291bnRlciAmJiBjb3VudGVyID4gbWF4TmFycm93Q291bnRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWluQ291bnRlciA9IGNvdW50ZXI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbWF4TmFycm93Q291bnRlciA9IG1pbkNvdW50ZXI7XG4gICAgICAgICAgICAgICAgd2lkZUNvdW50ZXJzID0gMDtcbiAgICAgICAgICAgICAgICBsZXQgdG90YWxXaWRlQ291bnRlcnNXaWR0aCA9IDA7XG4gICAgICAgICAgICAgICAgbGV0IHBhdHRlcm4gPSAwO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtQ291bnRlcnM7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgY291bnRlciA9IGNvdW50ZXJzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY291bnRlciA+IG1heE5hcnJvd0NvdW50ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdHRlcm4gfD0gMSA8PCAobnVtQ291bnRlcnMgLSAxIC0gaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aWRlQ291bnRlcnMrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvdGFsV2lkZUNvdW50ZXJzV2lkdGggKz0gY291bnRlcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAod2lkZUNvdW50ZXJzID09PSAzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZvdW5kIDMgd2lkZSBjb3VudGVycywgYnV0IGFyZSB0aGV5IGNsb3NlIGVub3VnaCBpbiB3aWR0aD9cbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgY2FuIHBlcmZvcm0gYSBjaGVhcCwgY29uc2VydmF0aXZlIGNoZWNrIHRvIHNlZSBpZiBhbnkgaW5kaXZpZHVhbFxuICAgICAgICAgICAgICAgICAgICAvLyBjb3VudGVyIGlzIG1vcmUgdGhhbiAxLjUgdGltZXMgdGhlIGF2ZXJhZ2U6XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtQ291bnRlcnMgJiYgd2lkZUNvdW50ZXJzID4gMDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgY291bnRlciA9IGNvdW50ZXJzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvdW50ZXIgPiBtYXhOYXJyb3dDb3VudGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkZUNvdW50ZXJzLS07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdG90YWxXaWRlQ291bnRlcnNXaWR0aCA9IDMgKiBhdmVyYWdlLCBzbyB0aGlzIGNoZWNrcyBpZiBjb3VudGVyID49IDMvMiAqIGF2ZXJhZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGNvdW50ZXIgKiAyKSA+PSB0b3RhbFdpZGVDb3VudGVyc1dpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhdHRlcm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAod2lkZUNvdW50ZXJzID4gMyk7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIHBhdHRlcm5Ub0NoYXIocGF0dGVybikge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBDb2RlMzlSZWFkZXIuQ0hBUkFDVEVSX0VOQ09ESU5HUy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChDb2RlMzlSZWFkZXIuQ0hBUkFDVEVSX0VOQ09ESU5HU1tpXSA9PT0gcGF0dGVybikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQ29kZTM5UmVhZGVyLkFMUEhBQkVUX1NUUklORy5jaGFyQXQoaSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhdHRlcm4gPT09IENvZGUzOVJlYWRlci5BU1RFUklTS19FTkNPRElORykge1xuICAgICAgICAgICAgICAgIHJldHVybiAnKic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgZGVjb2RlRXh0ZW5kZWQoZW5jb2RlZCkge1xuICAgICAgICAgICAgbGV0IGxlbmd0aCA9IGVuY29kZWQubGVuZ3RoO1xuICAgICAgICAgICAgbGV0IGRlY29kZWQgPSAnJztcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgYyA9IGVuY29kZWQuY2hhckF0KGkpO1xuICAgICAgICAgICAgICAgIGlmIChjID09PSAnKycgfHwgYyA9PT0gJyQnIHx8IGMgPT09ICclJyB8fCBjID09PSAnLycpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5leHQgPSBlbmNvZGVkLmNoYXJBdChpICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkZWNvZGVkQ2hhciA9ICdcXDAnO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJysnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICtBIHRvICtaIG1hcCB0byBhIHRvIHpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV4dCA+PSAnQScgJiYgbmV4dCA8PSAnWicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjb2RlZENoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG5leHQuY2hhckNvZGVBdCgwKSArIDMyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICckJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAkQSB0byAkWiBtYXAgdG8gY29udHJvbCBjb2RlcyBTSCB0byBTQlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXh0ID49ICdBJyAmJiBuZXh0IDw9ICdaJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNvZGVkQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUobmV4dC5jaGFyQ29kZUF0KDApIC0gNjQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJyUnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICVBIHRvICVFIG1hcCB0byBjb250cm9sIGNvZGVzIEVTQyB0byBVU1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXh0ID49ICdBJyAmJiBuZXh0IDw9ICdFJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNvZGVkQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUobmV4dC5jaGFyQ29kZUF0KDApIC0gMzgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChuZXh0ID49ICdGJyAmJiBuZXh0IDw9ICdKJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNvZGVkQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUobmV4dC5jaGFyQ29kZUF0KDApIC0gMTEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChuZXh0ID49ICdLJyAmJiBuZXh0IDw9ICdPJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNvZGVkQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUobmV4dC5jaGFyQ29kZUF0KDApICsgMTYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChuZXh0ID49ICdQJyAmJiBuZXh0IDw9ICdUJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNvZGVkQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUobmV4dC5jaGFyQ29kZUF0KDApICsgNDMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChuZXh0ID09PSAnVScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjb2RlZENoYXIgPSAnXFwwJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobmV4dCA9PT0gJ1YnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY29kZWRDaGFyID0gJ0AnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChuZXh0ID09PSAnVycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjb2RlZENoYXIgPSAnYCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5leHQgPT09ICdYJyB8fCBuZXh0ID09PSAnWScgfHwgbmV4dCA9PT0gJ1onKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY29kZWRDaGFyID0gJ1xceDdmJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICcvJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAvQSB0byAvTyBtYXAgdG8gISB0byAsIGFuZCAvWiBtYXBzIHRvIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV4dCA+PSAnQScgJiYgbmV4dCA8PSAnTycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjb2RlZENoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG5leHQuY2hhckNvZGVBdCgwKSAtIDMyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobmV4dCA9PT0gJ1onKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY29kZWRDaGFyID0gJzonO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkZWNvZGVkICs9IGRlY29kZWRDaGFyO1xuICAgICAgICAgICAgICAgICAgICAvLyBidW1wIHVwIGkgYWdhaW4gc2luY2Ugd2UgcmVhZCB0d28gY2hhcmFjdGVyc1xuICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkZWNvZGVkICs9IGM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRlY29kZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgQ29kZTM5UmVhZGVyLkFMUEhBQkVUX1NUUklORyA9ICcwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVotLiAkLyslJztcbiAgICAvKipcbiAgICAgKiBUaGVzZSByZXByZXNlbnQgdGhlIGVuY29kaW5ncyBvZiBjaGFyYWN0ZXJzLCBhcyBwYXR0ZXJucyBvZiB3aWRlIGFuZCBuYXJyb3cgYmFycy5cbiAgICAgKiBUaGUgOSBsZWFzdC1zaWduaWZpY2FudCBiaXRzIG9mIGVhY2ggaW50IGNvcnJlc3BvbmQgdG8gdGhlIHBhdHRlcm4gb2Ygd2lkZSBhbmQgbmFycm93LFxuICAgICAqIHdpdGggMXMgcmVwcmVzZW50aW5nIFwid2lkZVwiIGFuZCAwcyByZXByZXNlbnRpbmcgbmFycm93LlxuICAgICAqL1xuICAgIENvZGUzOVJlYWRlci5DSEFSQUNURVJfRU5DT0RJTkdTID0gW1xuICAgICAgICAweDAzNCwgMHgxMjEsIDB4MDYxLCAweDE2MCwgMHgwMzEsIDB4MTMwLCAweDA3MCwgMHgwMjUsIDB4MTI0LCAweDA2NCxcbiAgICAgICAgMHgxMDksIDB4MDQ5LCAweDE0OCwgMHgwMTksIDB4MTE4LCAweDA1OCwgMHgwMEQsIDB4MTBDLCAweDA0QywgMHgwMUMsXG4gICAgICAgIDB4MTAzLCAweDA0MywgMHgxNDIsIDB4MDEzLCAweDExMiwgMHgwNTIsIDB4MDA3LCAweDEwNiwgMHgwNDYsIDB4MDE2LFxuICAgICAgICAweDE4MSwgMHgwQzEsIDB4MUMwLCAweDA5MSwgMHgxOTAsIDB4MEQwLCAweDA4NSwgMHgxODQsIDB4MEM0LCAweDBBOCxcbiAgICAgICAgMHgwQTIsIDB4MDhBLCAweDAyQSAvLyAvLSVcbiAgICBdO1xuICAgIENvZGUzOVJlYWRlci5BU1RFUklTS19FTkNPRElORyA9IDB4MDk0O1xuXG4gICAgLyoqXG4gICAgICogPHA+RGVjb2RlcyBJVEYgYmFyY29kZXMuPC9wPlxuICAgICAqXG4gICAgICogQGF1dGhvciBUamllY29cbiAgICAgKi9cbiAgICBjbGFzcyBJVEZSZWFkZXIgZXh0ZW5kcyBPbmVEUmVhZGVyIHtcbiAgICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgICAgICAvLyBwcml2YXRlIHN0YXRpYyBXID0gMzsgLy8gUGl4ZWwgd2lkdGggb2YgYSAzeCB3aWRlIGxpbmVcbiAgICAgICAgICAgIC8vIHByaXZhdGUgc3RhdGljIHcgPSAyOyAvLyBQaXhlbCB3aWR0aCBvZiBhIDJ4IHdpZGUgbGluZVxuICAgICAgICAgICAgLy8gcHJpdmF0ZSBzdGF0aWMgTiA9IDE7IC8vIFBpeGVkIHdpZHRoIG9mIGEgbmFycm93IGxpbmVcbiAgICAgICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgICAgICAvLyBTdG9yZXMgdGhlIGFjdHVhbCBuYXJyb3cgbGluZSB3aWR0aCBvZiB0aGUgaW1hZ2UgYmVpbmcgZGVjb2RlZC5cbiAgICAgICAgICAgIHRoaXMubmFycm93TGluZVdpZHRoID0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2VlIElURldyaXRlci5QQVRURVJOU1xuICAgICAgICAvKlxuICAgICAgXG4gICAgICAgIC8hKipcbiAgICAgICAgICogUGF0dGVybnMgb2YgV2lkZSAvIE5hcnJvdyBsaW5lcyB0byBpbmRpY2F0ZSBlYWNoIGRpZ2l0XG4gICAgICAgICAqIS9cbiAgICAgICAgKi9cbiAgICAgICAgZGVjb2RlUm93KHJvd051bWJlciwgcm93LCBoaW50cykge1xuICAgICAgICAgICAgLy8gRmluZCBvdXQgd2hlcmUgdGhlIE1pZGRsZSBzZWN0aW9uIChwYXlsb2FkKSBzdGFydHMgJiBlbmRzXG4gICAgICAgICAgICBsZXQgc3RhcnRSYW5nZSA9IHRoaXMuZGVjb2RlU3RhcnQocm93KTtcbiAgICAgICAgICAgIGxldCBlbmRSYW5nZSA9IHRoaXMuZGVjb2RlRW5kKHJvdyk7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gbmV3IFN0cmluZ0J1aWxkZXIoKTtcbiAgICAgICAgICAgIElURlJlYWRlci5kZWNvZGVNaWRkbGUocm93LCBzdGFydFJhbmdlWzFdLCBlbmRSYW5nZVswXSwgcmVzdWx0KTtcbiAgICAgICAgICAgIGxldCByZXN1bHRTdHJpbmcgPSByZXN1bHQudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGxldCBhbGxvd2VkTGVuZ3RocyA9IG51bGw7XG4gICAgICAgICAgICBpZiAoaGludHMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGFsbG93ZWRMZW5ndGhzID0gaGludHMuZ2V0KERlY29kZUhpbnRUeXBlJDEuQUxMT1dFRF9MRU5HVEhTKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhbGxvd2VkTGVuZ3RocyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgYWxsb3dlZExlbmd0aHMgPSBJVEZSZWFkZXIuREVGQVVMVF9BTExPV0VEX0xFTkdUSFM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUbyBhdm9pZCBmYWxzZSBwb3NpdGl2ZXMgd2l0aCAyRCBiYXJjb2RlcyAoYW5kIG90aGVyIHBhdHRlcm5zKSwgbWFrZVxuICAgICAgICAgICAgLy8gYW4gYXNzdW1wdGlvbiB0aGF0IHRoZSBkZWNvZGVkIHN0cmluZyBtdXN0IGJlIGEgJ3N0YW5kYXJkJyBsZW5ndGggaWYgaXQncyBzaG9ydFxuICAgICAgICAgICAgbGV0IGxlbmd0aCA9IHJlc3VsdFN0cmluZy5sZW5ndGg7XG4gICAgICAgICAgICBsZXQgbGVuZ3RoT0sgPSBmYWxzZTtcbiAgICAgICAgICAgIGxldCBtYXhBbGxvd2VkTGVuZ3RoID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IHZhbHVlIG9mIGFsbG93ZWRMZW5ndGhzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxlbmd0aCA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoT0sgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID4gbWF4QWxsb3dlZExlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBtYXhBbGxvd2VkTGVuZ3RoID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFsZW5ndGhPSyAmJiBsZW5ndGggPiBtYXhBbGxvd2VkTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbGVuZ3RoT0sgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFsZW5ndGhPSykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHBvaW50cyA9IFtuZXcgUmVzdWx0UG9pbnQoc3RhcnRSYW5nZVsxXSwgcm93TnVtYmVyKSwgbmV3IFJlc3VsdFBvaW50KGVuZFJhbmdlWzBdLCByb3dOdW1iZXIpXTtcbiAgICAgICAgICAgIGxldCByZXN1bHRSZXR1cm4gPSBuZXcgUmVzdWx0KHJlc3VsdFN0cmluZywgbnVsbCwgLy8gbm8gbmF0dXJhbCBieXRlIHJlcHJlc2VudGF0aW9uIGZvciB0aGVzZSBiYXJjb2Rlc1xuICAgICAgICAgICAgMCwgcG9pbnRzLCBCYXJjb2RlRm9ybWF0JDEuSVRGLCBuZXcgRGF0ZSgpLmdldFRpbWUoKSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0UmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8qXG4gICAgICAgIC8hKipcbiAgICAgICAgICogQHBhcmFtIHJvdyAgICAgICAgICByb3cgb2YgYmxhY2svd2hpdGUgdmFsdWVzIHRvIHNlYXJjaFxuICAgICAgICAgKiBAcGFyYW0gcGF5bG9hZFN0YXJ0IG9mZnNldCBvZiBzdGFydCBwYXR0ZXJuXG4gICAgICAgICAqIEBwYXJhbSByZXN1bHRTdHJpbmcge0BsaW5rIFN0cmluZ0J1aWxkZXJ9IHRvIGFwcGVuZCBkZWNvZGVkIGNoYXJzIHRvXG4gICAgICAgICAqIEB0aHJvd3MgTm90Rm91bmRFeGNlcHRpb24gaWYgZGVjb2RpbmcgY291bGQgbm90IGNvbXBsZXRlIHN1Y2Nlc3NmdWxseVxuICAgICAgICAgKiEvKi9cbiAgICAgICAgc3RhdGljIGRlY29kZU1pZGRsZShyb3csIHBheWxvYWRTdGFydCwgcGF5bG9hZEVuZCwgcmVzdWx0U3RyaW5nKSB7XG4gICAgICAgICAgICAvLyBEaWdpdHMgYXJlIGludGVybGVhdmVkIGluIHBhaXJzIC0gNSBibGFjayBsaW5lcyBmb3Igb25lIGRpZ2l0LCBhbmQgdGhlXG4gICAgICAgICAgICAvLyA1XG4gICAgICAgICAgICAvLyBpbnRlcmxlYXZlZCB3aGl0ZSBsaW5lcyBmb3IgdGhlIHNlY29uZCBkaWdpdC5cbiAgICAgICAgICAgIC8vIFRoZXJlZm9yZSwgbmVlZCB0byBzY2FuIDEwIGxpbmVzIGFuZCB0aGVuXG4gICAgICAgICAgICAvLyBzcGxpdCB0aGVzZSBpbnRvIHR3byBhcnJheXNcbiAgICAgICAgICAgIGxldCBjb3VudGVyRGlnaXRQYWlyID0gbmV3IEludDMyQXJyYXkoMTApOyAvLyAxMFxuICAgICAgICAgICAgbGV0IGNvdW50ZXJCbGFjayA9IG5ldyBJbnQzMkFycmF5KDUpOyAvLyA1XG4gICAgICAgICAgICBsZXQgY291bnRlcldoaXRlID0gbmV3IEludDMyQXJyYXkoNSk7IC8vIDVcbiAgICAgICAgICAgIGNvdW50ZXJEaWdpdFBhaXIuZmlsbCgwKTtcbiAgICAgICAgICAgIGNvdW50ZXJCbGFjay5maWxsKDApO1xuICAgICAgICAgICAgY291bnRlcldoaXRlLmZpbGwoMCk7XG4gICAgICAgICAgICB3aGlsZSAocGF5bG9hZFN0YXJ0IDwgcGF5bG9hZEVuZCkge1xuICAgICAgICAgICAgICAgIC8vIEdldCAxMCBydW5zIG9mIGJsYWNrL3doaXRlLlxuICAgICAgICAgICAgICAgIE9uZURSZWFkZXIucmVjb3JkUGF0dGVybihyb3csIHBheWxvYWRTdGFydCwgY291bnRlckRpZ2l0UGFpcik7XG4gICAgICAgICAgICAgICAgLy8gU3BsaXQgdGhlbSBpbnRvIGVhY2ggYXJyYXlcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IDU7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgdHdvSyA9IDIgKiBrO1xuICAgICAgICAgICAgICAgICAgICBjb3VudGVyQmxhY2tba10gPSBjb3VudGVyRGlnaXRQYWlyW3R3b0tdO1xuICAgICAgICAgICAgICAgICAgICBjb3VudGVyV2hpdGVba10gPSBjb3VudGVyRGlnaXRQYWlyW3R3b0sgKyAxXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGJlc3RNYXRjaCA9IElURlJlYWRlci5kZWNvZGVEaWdpdChjb3VudGVyQmxhY2spO1xuICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZy5hcHBlbmQoYmVzdE1hdGNoLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgIGJlc3RNYXRjaCA9IHRoaXMuZGVjb2RlRGlnaXQoY291bnRlcldoaXRlKTtcbiAgICAgICAgICAgICAgICByZXN1bHRTdHJpbmcuYXBwZW5kKGJlc3RNYXRjaC50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICBjb3VudGVyRGlnaXRQYWlyLmZvckVhY2goZnVuY3Rpb24gKGNvdW50ZXJEaWdpdCkge1xuICAgICAgICAgICAgICAgICAgICBwYXlsb2FkU3RhcnQgKz0gY291bnRlckRpZ2l0O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qLyEqKlxuICAgICAgICAgKiBJZGVudGlmeSB3aGVyZSB0aGUgc3RhcnQgb2YgdGhlIG1pZGRsZSAvIHBheWxvYWQgc2VjdGlvbiBzdGFydHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSByb3cgcm93IG9mIGJsYWNrL3doaXRlIHZhbHVlcyB0byBzZWFyY2hcbiAgICAgICAgICogQHJldHVybiBBcnJheSwgY29udGFpbmluZyBpbmRleCBvZiBzdGFydCBvZiAnc3RhcnQgYmxvY2snIGFuZCBlbmQgb2ZcbiAgICAgICAgICogICAgICAgICAnc3RhcnQgYmxvY2snXG4gICAgICAgICAqIS8qL1xuICAgICAgICBkZWNvZGVTdGFydChyb3cpIHtcbiAgICAgICAgICAgIGxldCBlbmRTdGFydCA9IElURlJlYWRlci5za2lwV2hpdGVTcGFjZShyb3cpO1xuICAgICAgICAgICAgbGV0IHN0YXJ0UGF0dGVybiA9IElURlJlYWRlci5maW5kR3VhcmRQYXR0ZXJuKHJvdywgZW5kU3RhcnQsIElURlJlYWRlci5TVEFSVF9QQVRURVJOKTtcbiAgICAgICAgICAgIC8vIERldGVybWluZSB0aGUgd2lkdGggb2YgYSBuYXJyb3cgbGluZSBpbiBwaXhlbHMuIFdlIGNhbiBkbyB0aGlzIGJ5XG4gICAgICAgICAgICAvLyBnZXR0aW5nIHRoZSB3aWR0aCBvZiB0aGUgc3RhcnQgcGF0dGVybiBhbmQgZGl2aWRpbmcgYnkgNCBiZWNhdXNlIGl0c1xuICAgICAgICAgICAgLy8gbWFkZSB1cCBvZiA0IG5hcnJvdyBsaW5lcy5cbiAgICAgICAgICAgIHRoaXMubmFycm93TGluZVdpZHRoID0gKHN0YXJ0UGF0dGVyblsxXSAtIHN0YXJ0UGF0dGVyblswXSkgLyA0O1xuICAgICAgICAgICAgdGhpcy52YWxpZGF0ZVF1aWV0Wm9uZShyb3csIHN0YXJ0UGF0dGVyblswXSk7XG4gICAgICAgICAgICByZXR1cm4gc3RhcnRQYXR0ZXJuO1xuICAgICAgICB9XG4gICAgICAgIC8qLyEqKlxuICAgICAgICAgKiBUaGUgc3RhcnQgJiBlbmQgcGF0dGVybnMgbXVzdCBiZSBwcmUvcG9zdCBmaXhlZCBieSBhIHF1aWV0IHpvbmUuIFRoaXNcbiAgICAgICAgICogem9uZSBtdXN0IGJlIGF0IGxlYXN0IDEwIHRpbWVzIHRoZSB3aWR0aCBvZiBhIG5hcnJvdyBsaW5lLiAgU2NhbiBiYWNrIHVudGlsXG4gICAgICAgICAqIHdlIGVpdGhlciBnZXQgdG8gdGhlIHN0YXJ0IG9mIHRoZSBiYXJjb2RlIG9yIG1hdGNoIHRoZSBuZWNlc3NhcnkgbnVtYmVyIG9mXG4gICAgICAgICAqIHF1aWV0IHpvbmUgcGl4ZWxzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBOb3RlOiBJdHMgYXNzdW1lZCB0aGUgcm93IGlzIHJldmVyc2VkIHdoZW4gdXNpbmcgdGhpcyBtZXRob2QgdG8gZmluZFxuICAgICAgICAgKiBxdWlldCB6b25lIGFmdGVyIHRoZSBlbmQgcGF0dGVybi5cbiAgICAgICAgICpcbiAgICAgICAgICogcmVmOiBodHRwOi8vd3d3LmJhcmNvZGUtMS5uZXQvaTI1Y29kZS5odG1sXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSByb3cgYml0IGFycmF5IHJlcHJlc2VudGluZyB0aGUgc2Nhbm5lZCBiYXJjb2RlLlxuICAgICAgICAgKiBAcGFyYW0gc3RhcnRQYXR0ZXJuIGluZGV4IGludG8gcm93IG9mIHRoZSBzdGFydCBvciBlbmQgcGF0dGVybi5cbiAgICAgICAgICogQHRocm93cyBOb3RGb3VuZEV4Y2VwdGlvbiBpZiB0aGUgcXVpZXQgem9uZSBjYW5ub3QgYmUgZm91bmRcbiAgICAgICAgICohLyovXG4gICAgICAgIHZhbGlkYXRlUXVpZXRab25lKHJvdywgc3RhcnRQYXR0ZXJuKSB7XG4gICAgICAgICAgICBsZXQgcXVpZXRDb3VudCA9IHRoaXMubmFycm93TGluZVdpZHRoICogMTA7IC8vIGV4cGVjdCB0byBmaW5kIHRoaXMgbWFueSBwaXhlbHMgb2YgcXVpZXQgem9uZVxuICAgICAgICAgICAgLy8gaWYgdGhlcmUgYXJlIG5vdCBzbyBtYW55IHBpeGVsIGF0IGFsbCBsZXQncyB0cnkgYXMgbWFueSBhcyBwb3NzaWJsZVxuICAgICAgICAgICAgcXVpZXRDb3VudCA9IHF1aWV0Q291bnQgPCBzdGFydFBhdHRlcm4gPyBxdWlldENvdW50IDogc3RhcnRQYXR0ZXJuO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0UGF0dGVybiAtIDE7IHF1aWV0Q291bnQgPiAwICYmIGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJvdy5nZXQoaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHF1aWV0Q291bnQtLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChxdWlldENvdW50ICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gVW5hYmxlIHRvIGZpbmQgdGhlIG5lY2Vzc2FyeSBudW1iZXIgb2YgcXVpZXQgem9uZSBwaXhlbHMuXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLypcbiAgICAgICAgLyEqKlxuICAgICAgICAgKiBTa2lwIGFsbCB3aGl0ZXNwYWNlIHVudGlsIHdlIGdldCB0byB0aGUgZmlyc3QgYmxhY2sgbGluZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHJvdyByb3cgb2YgYmxhY2svd2hpdGUgdmFsdWVzIHRvIHNlYXJjaFxuICAgICAgICAgKiBAcmV0dXJuIGluZGV4IG9mIHRoZSBmaXJzdCBibGFjayBsaW5lLlxuICAgICAgICAgKiBAdGhyb3dzIE5vdEZvdW5kRXhjZXB0aW9uIFRocm93cyBleGNlcHRpb24gaWYgbm8gYmxhY2sgbGluZXMgYXJlIGZvdW5kIGluIHRoZSByb3dcbiAgICAgICAgICohLyovXG4gICAgICAgIHN0YXRpYyBza2lwV2hpdGVTcGFjZShyb3cpIHtcbiAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gcm93LmdldFNpemUoKTtcbiAgICAgICAgICAgIGNvbnN0IGVuZFN0YXJ0ID0gcm93LmdldE5leHRTZXQoMCk7XG4gICAgICAgICAgICBpZiAoZW5kU3RhcnQgPT09IHdpZHRoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZW5kU3RhcnQ7XG4gICAgICAgIH1cbiAgICAgICAgLyovISoqXG4gICAgICAgICAqIElkZW50aWZ5IHdoZXJlIHRoZSBlbmQgb2YgdGhlIG1pZGRsZSAvIHBheWxvYWQgc2VjdGlvbiBlbmRzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gcm93IHJvdyBvZiBibGFjay93aGl0ZSB2YWx1ZXMgdG8gc2VhcmNoXG4gICAgICAgICAqIEByZXR1cm4gQXJyYXksIGNvbnRhaW5pbmcgaW5kZXggb2Ygc3RhcnQgb2YgJ2VuZCBibG9jaycgYW5kIGVuZCBvZiAnZW5kXG4gICAgICAgICAqICAgICAgICAgYmxvY2snXG4gICAgICAgICAqIS8qL1xuICAgICAgICBkZWNvZGVFbmQocm93KSB7XG4gICAgICAgICAgICAvLyBGb3IgY29udmVuaWVuY2UsIHJldmVyc2UgdGhlIHJvdyBhbmQgdGhlblxuICAgICAgICAgICAgLy8gc2VhcmNoIGZyb20gJ3RoZSBzdGFydCcgZm9yIHRoZSBlbmQgYmxvY2tcbiAgICAgICAgICAgIHJvdy5yZXZlcnNlKCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGxldCBlbmRTdGFydCA9IElURlJlYWRlci5za2lwV2hpdGVTcGFjZShyb3cpO1xuICAgICAgICAgICAgICAgIGxldCBlbmRQYXR0ZXJuO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGVuZFBhdHRlcm4gPSBJVEZSZWFkZXIuZmluZEd1YXJkUGF0dGVybihyb3csIGVuZFN0YXJ0LCBJVEZSZWFkZXIuRU5EX1BBVFRFUk5fUkVWRVJTRURbMF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgTm90Rm91bmRFeGNlcHRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZFBhdHRlcm4gPSBJVEZSZWFkZXIuZmluZEd1YXJkUGF0dGVybihyb3csIGVuZFN0YXJ0LCBJVEZSZWFkZXIuRU5EX1BBVFRFUk5fUkVWRVJTRURbMV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFRoZSBzdGFydCAmIGVuZCBwYXR0ZXJucyBtdXN0IGJlIHByZS9wb3N0IGZpeGVkIGJ5IGEgcXVpZXQgem9uZS4gVGhpc1xuICAgICAgICAgICAgICAgIC8vIHpvbmUgbXVzdCBiZSBhdCBsZWFzdCAxMCB0aW1lcyB0aGUgd2lkdGggb2YgYSBuYXJyb3cgbGluZS5cbiAgICAgICAgICAgICAgICAvLyByZWY6IGh0dHA6Ly93d3cuYmFyY29kZS0xLm5ldC9pMjVjb2RlLmh0bWxcbiAgICAgICAgICAgICAgICB0aGlzLnZhbGlkYXRlUXVpZXRab25lKHJvdywgZW5kUGF0dGVyblswXSk7XG4gICAgICAgICAgICAgICAgLy8gTm93IHJlY2FsY3VsYXRlIHRoZSBpbmRpY2VzIG9mIHdoZXJlIHRoZSAnZW5kYmxvY2snIHN0YXJ0cyAmIHN0b3BzIHRvXG4gICAgICAgICAgICAgICAgLy8gYWNjb21tb2RhdGVcbiAgICAgICAgICAgICAgICAvLyB0aGUgcmV2ZXJzZWQgbmF0dXJlIG9mIHRoZSBzZWFyY2hcbiAgICAgICAgICAgICAgICBsZXQgdGVtcCA9IGVuZFBhdHRlcm5bMF07XG4gICAgICAgICAgICAgICAgZW5kUGF0dGVyblswXSA9IHJvdy5nZXRTaXplKCkgLSBlbmRQYXR0ZXJuWzFdO1xuICAgICAgICAgICAgICAgIGVuZFBhdHRlcm5bMV0gPSByb3cuZ2V0U2l6ZSgpIC0gdGVtcDtcbiAgICAgICAgICAgICAgICByZXR1cm4gZW5kUGF0dGVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIC8vIFB1dCB0aGUgcm93IGJhY2sgdGhlIHJpZ2h0IHdheS5cbiAgICAgICAgICAgICAgICByb3cucmV2ZXJzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qXG4gICAgICAgIC8hKipcbiAgICAgICAgICogQHBhcmFtIHJvdyAgICAgICByb3cgb2YgYmxhY2svd2hpdGUgdmFsdWVzIHRvIHNlYXJjaFxuICAgICAgICAgKiBAcGFyYW0gcm93T2Zmc2V0IHBvc2l0aW9uIHRvIHN0YXJ0IHNlYXJjaFxuICAgICAgICAgKiBAcGFyYW0gcGF0dGVybiAgIHBhdHRlcm4gb2YgY291bnRzIG9mIG51bWJlciBvZiBibGFjayBhbmQgd2hpdGUgcGl4ZWxzIHRoYXQgYXJlXG4gICAgICAgICAqICAgICAgICAgICAgICAgICAgYmVpbmcgc2VhcmNoZWQgZm9yIGFzIGEgcGF0dGVyblxuICAgICAgICAgKiBAcmV0dXJuIHN0YXJ0L2VuZCBob3Jpem9udGFsIG9mZnNldCBvZiBndWFyZCBwYXR0ZXJuLCBhcyBhbiBhcnJheSBvZiB0d29cbiAgICAgICAgICogICAgICAgICBpbnRzXG4gICAgICAgICAqIEB0aHJvd3MgTm90Rm91bmRFeGNlcHRpb24gaWYgcGF0dGVybiBpcyBub3QgZm91bmRcbiAgICAgICAgICohLyovXG4gICAgICAgIHN0YXRpYyBmaW5kR3VhcmRQYXR0ZXJuKHJvdywgcm93T2Zmc2V0LCBwYXR0ZXJuKSB7XG4gICAgICAgICAgICBsZXQgcGF0dGVybkxlbmd0aCA9IHBhdHRlcm4ubGVuZ3RoO1xuICAgICAgICAgICAgbGV0IGNvdW50ZXJzID0gbmV3IEludDMyQXJyYXkocGF0dGVybkxlbmd0aCk7XG4gICAgICAgICAgICBsZXQgd2lkdGggPSByb3cuZ2V0U2l6ZSgpO1xuICAgICAgICAgICAgbGV0IGlzV2hpdGUgPSBmYWxzZTtcbiAgICAgICAgICAgIGxldCBjb3VudGVyUG9zaXRpb24gPSAwO1xuICAgICAgICAgICAgbGV0IHBhdHRlcm5TdGFydCA9IHJvd09mZnNldDtcbiAgICAgICAgICAgIGNvdW50ZXJzLmZpbGwoMCk7XG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gcm93T2Zmc2V0OyB4IDwgd2lkdGg7IHgrKykge1xuICAgICAgICAgICAgICAgIGlmIChyb3cuZ2V0KHgpICE9PSBpc1doaXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJzW2NvdW50ZXJQb3NpdGlvbl0rKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb3VudGVyUG9zaXRpb24gPT09IHBhdHRlcm5MZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoT25lRFJlYWRlci5wYXR0ZXJuTWF0Y2hWYXJpYW5jZShjb3VudGVycywgcGF0dGVybiwgSVRGUmVhZGVyLk1BWF9JTkRJVklEVUFMX1ZBUklBTkNFKSA8IElURlJlYWRlci5NQVhfQVZHX1ZBUklBTkNFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtwYXR0ZXJuU3RhcnQsIHhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0dGVyblN0YXJ0ICs9IGNvdW50ZXJzWzBdICsgY291bnRlcnNbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBTeXN0ZW0uYXJyYXljb3B5KGNvdW50ZXJzLCAyLCBjb3VudGVycywgMCwgY291bnRlclBvc2l0aW9uIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyc1tjb3VudGVyUG9zaXRpb24gLSAxXSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyc1tjb3VudGVyUG9zaXRpb25dID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJQb3NpdGlvbi0tO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlclBvc2l0aW9uKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY291bnRlcnNbY291bnRlclBvc2l0aW9uXSA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGlzV2hpdGUgPSAhaXNXaGl0ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICAvKi8hKipcbiAgICAgICAgICogQXR0ZW1wdHMgdG8gZGVjb2RlIGEgc2VxdWVuY2Ugb2YgSVRGIGJsYWNrL3doaXRlIGxpbmVzIGludG8gc2luZ2xlXG4gICAgICAgICAqIGRpZ2l0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gY291bnRlcnMgdGhlIGNvdW50cyBvZiBydW5zIG9mIG9ic2VydmVkIGJsYWNrL3doaXRlL2JsYWNrLy4uLiB2YWx1ZXNcbiAgICAgICAgICogQHJldHVybiBUaGUgZGVjb2RlZCBkaWdpdFxuICAgICAgICAgKiBAdGhyb3dzIE5vdEZvdW5kRXhjZXB0aW9uIGlmIGRpZ2l0IGNhbm5vdCBiZSBkZWNvZGVkXG4gICAgICAgICAqIS8qL1xuICAgICAgICBzdGF0aWMgZGVjb2RlRGlnaXQoY291bnRlcnMpIHtcbiAgICAgICAgICAgIGxldCBiZXN0VmFyaWFuY2UgPSBJVEZSZWFkZXIuTUFYX0FWR19WQVJJQU5DRTsgLy8gd29yc3QgdmFyaWFuY2Ugd2UnbGwgYWNjZXB0XG4gICAgICAgICAgICBsZXQgYmVzdE1hdGNoID0gLTE7XG4gICAgICAgICAgICBsZXQgbWF4ID0gSVRGUmVhZGVyLlBBVFRFUk5TLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF4OyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgcGF0dGVybiA9IElURlJlYWRlci5QQVRURVJOU1tpXTtcbiAgICAgICAgICAgICAgICBsZXQgdmFyaWFuY2UgPSBPbmVEUmVhZGVyLnBhdHRlcm5NYXRjaFZhcmlhbmNlKGNvdW50ZXJzLCBwYXR0ZXJuLCBJVEZSZWFkZXIuTUFYX0lORElWSURVQUxfVkFSSUFOQ0UpO1xuICAgICAgICAgICAgICAgIGlmICh2YXJpYW5jZSA8IGJlc3RWYXJpYW5jZSkge1xuICAgICAgICAgICAgICAgICAgICBiZXN0VmFyaWFuY2UgPSB2YXJpYW5jZTtcbiAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoID0gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodmFyaWFuY2UgPT09IGJlc3RWYXJpYW5jZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiB3ZSBmaW5kIGEgc2Vjb25kICdiZXN0IG1hdGNoJyB3aXRoIHRoZSBzYW1lIHZhcmlhbmNlLCB3ZSBjYW4gbm90IHJlbGlhYmx5IHJlcG9ydCB0byBoYXZlIGEgc3VpdGFibGUgbWF0Y2hcbiAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoID0gLTE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGJlc3RNYXRjaCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJlc3RNYXRjaCAlIDEwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgSVRGUmVhZGVyLlBBVFRFUk5TID0gW1xuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDEsIDIsIDIsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsyLCAxLCAxLCAxLCAyXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMiwgMSwgMSwgMl0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzIsIDIsIDEsIDEsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAxLCAyLCAxLCAyXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMiwgMSwgMiwgMSwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDIsIDIsIDEsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAxLCAxLCAyLCAyXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMiwgMSwgMSwgMiwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDIsIDEsIDIsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAxLCAzLCAzLCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMywgMSwgMSwgMSwgM10pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDMsIDEsIDEsIDNdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFszLCAzLCAxLCAxLCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMSwgMywgMSwgM10pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzMsIDEsIDMsIDEsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAzLCAzLCAxLCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMSwgMSwgMywgM10pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzMsIDEsIDEsIDMsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAzLCAxLCAzLCAxXSkgLy8gOVxuICAgIF07XG4gICAgSVRGUmVhZGVyLk1BWF9BVkdfVkFSSUFOQ0UgPSAwLjM4O1xuICAgIElURlJlYWRlci5NQVhfSU5ESVZJRFVBTF9WQVJJQU5DRSA9IDAuNTtcbiAgICAvKiAvISoqIFZhbGlkIElURiBsZW5ndGhzLiBBbnl0aGluZyBsb25nZXIgdGhhbiB0aGUgbGFyZ2VzdCB2YWx1ZSBpcyBhbHNvIGFsbG93ZWQuICohLyovXG4gICAgSVRGUmVhZGVyLkRFRkFVTFRfQUxMT1dFRF9MRU5HVEhTID0gWzYsIDgsIDEwLCAxMiwgMTRdO1xuICAgIC8qLyEqKlxuICAgICAqIFN0YXJ0L2VuZCBndWFyZCBwYXR0ZXJuLlxuICAgICAqXG4gICAgICogTm90ZTogVGhlIGVuZCBwYXR0ZXJuIGlzIHJldmVyc2VkIGJlY2F1c2UgdGhlIHJvdyBpcyByZXZlcnNlZCBiZWZvcmVcbiAgICAgKiBzZWFyY2hpbmcgZm9yIHRoZSBFTkRfUEFUVEVSTlxuICAgICAqIS8qL1xuICAgIElURlJlYWRlci5TVEFSVF9QQVRURVJOID0gSW50MzJBcnJheS5mcm9tKFsxLCAxLCAxLCAxXSk7XG4gICAgSVRGUmVhZGVyLkVORF9QQVRURVJOX1JFVkVSU0VEID0gW1xuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDEsIDJdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAxLCAzXSkgLy8gM3hcbiAgICBdO1xuXG4gICAgLyoqXG4gICAgICogPHA+RW5jYXBzdWxhdGVzIGZ1bmN0aW9uYWxpdHkgYW5kIGltcGxlbWVudGF0aW9uIHRoYXQgaXMgY29tbW9uIHRvIFVQQyBhbmQgRUFOIGZhbWlsaWVzXG4gICAgICogb2Ygb25lLWRpbWVuc2lvbmFsIGJhcmNvZGVzLjwvcD5cbiAgICAgKlxuICAgICAqIEBhdXRob3IgZHN3aXRraW5AZ29vZ2xlLmNvbSAoRGFuaWVsIFN3aXRraW4pXG4gICAgICogQGF1dGhvciBTZWFuIE93ZW5cbiAgICAgKiBAYXV0aG9yIGFsYXNkYWlyQGdvb2dsZS5jb20gKEFsYXNkYWlyIE1hY2tpbnRvc2gpXG4gICAgICovXG4gICAgY2xhc3MgQWJzdHJhY3RVUENFQU5SZWFkZXIgZXh0ZW5kcyBPbmVEUmVhZGVyIHtcbiAgICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICAgICAgdGhpcy5kZWNvZGVSb3dTdHJpbmdCdWZmZXIgPSAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRpYyBmaW5kU3RhcnRHdWFyZFBhdHRlcm4ocm93KSB7XG4gICAgICAgICAgICBsZXQgZm91bmRTdGFydCA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IHN0YXJ0UmFuZ2U7XG4gICAgICAgICAgICBsZXQgbmV4dFN0YXJ0ID0gMDtcbiAgICAgICAgICAgIGxldCBjb3VudGVycyA9IEludDMyQXJyYXkuZnJvbShbMCwgMCwgMF0pO1xuICAgICAgICAgICAgd2hpbGUgKCFmb3VuZFN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgY291bnRlcnMgPSBJbnQzMkFycmF5LmZyb20oWzAsIDAsIDBdKTtcbiAgICAgICAgICAgICAgICBzdGFydFJhbmdlID0gQWJzdHJhY3RVUENFQU5SZWFkZXIuZmluZEd1YXJkUGF0dGVybihyb3csIG5leHRTdGFydCwgZmFsc2UsIHRoaXMuU1RBUlRfRU5EX1BBVFRFUk4sIGNvdW50ZXJzKTtcbiAgICAgICAgICAgICAgICBsZXQgc3RhcnQgPSBzdGFydFJhbmdlWzBdO1xuICAgICAgICAgICAgICAgIG5leHRTdGFydCA9IHN0YXJ0UmFuZ2VbMV07XG4gICAgICAgICAgICAgICAgbGV0IHF1aWV0U3RhcnQgPSBzdGFydCAtIChuZXh0U3RhcnQgLSBzdGFydCk7XG4gICAgICAgICAgICAgICAgaWYgKHF1aWV0U3RhcnQgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICBmb3VuZFN0YXJ0ID0gcm93LmlzUmFuZ2UocXVpZXRTdGFydCwgc3RhcnQsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc3RhcnRSYW5nZTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgY2hlY2tDaGVja3N1bShzKSB7XG4gICAgICAgICAgICByZXR1cm4gQWJzdHJhY3RVUENFQU5SZWFkZXIuY2hlY2tTdGFuZGFyZFVQQ0VBTkNoZWNrc3VtKHMpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBjaGVja1N0YW5kYXJkVVBDRUFOQ2hlY2tzdW0ocykge1xuICAgICAgICAgICAgbGV0IGxlbmd0aCA9IHMubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBsZXQgY2hlY2sgPSBwYXJzZUludChzLmNoYXJBdChsZW5ndGggLSAxKSwgMTApO1xuICAgICAgICAgICAgcmV0dXJuIEFic3RyYWN0VVBDRUFOUmVhZGVyLmdldFN0YW5kYXJkVVBDRUFOQ2hlY2tzdW0ocy5zdWJzdHJpbmcoMCwgbGVuZ3RoIC0gMSkpID09PSBjaGVjaztcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgZ2V0U3RhbmRhcmRVUENFQU5DaGVja3N1bShzKSB7XG4gICAgICAgICAgICBsZXQgbGVuZ3RoID0gcy5sZW5ndGg7XG4gICAgICAgICAgICBsZXQgc3VtID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBsZW5ndGggLSAxOyBpID49IDA7IGkgLT0gMikge1xuICAgICAgICAgICAgICAgIGxldCBkaWdpdCA9IHMuY2hhckF0KGkpLmNoYXJDb2RlQXQoMCkgLSAnMCcuY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICAgICAgICBpZiAoZGlnaXQgPCAwIHx8IGRpZ2l0ID4gOSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN1bSArPSBkaWdpdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN1bSAqPSAzO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IGxlbmd0aCAtIDI7IGkgPj0gMDsgaSAtPSAyKSB7XG4gICAgICAgICAgICAgICAgbGV0IGRpZ2l0ID0gcy5jaGFyQXQoaSkuY2hhckNvZGVBdCgwKSAtICcwJy5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgICAgICAgIGlmIChkaWdpdCA8IDAgfHwgZGlnaXQgPiA5KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3VtICs9IGRpZ2l0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICgxMDAwIC0gc3VtKSAlIDEwO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBkZWNvZGVFbmQocm93LCBlbmRTdGFydCkge1xuICAgICAgICAgICAgcmV0dXJuIEFic3RyYWN0VVBDRUFOUmVhZGVyLmZpbmRHdWFyZFBhdHRlcm4ocm93LCBlbmRTdGFydCwgZmFsc2UsIEFic3RyYWN0VVBDRUFOUmVhZGVyLlNUQVJUX0VORF9QQVRURVJOLCBuZXcgSW50MzJBcnJheShBYnN0cmFjdFVQQ0VBTlJlYWRlci5TVEFSVF9FTkRfUEFUVEVSTi5sZW5ndGgpLmZpbGwoMCkpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdGhyb3dzIE5vdEZvdW5kRXhjZXB0aW9uXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgZmluZEd1YXJkUGF0dGVybldpdGhvdXRDb3VudGVycyhyb3csIHJvd09mZnNldCwgd2hpdGVGaXJzdCwgcGF0dGVybikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmluZEd1YXJkUGF0dGVybihyb3csIHJvd09mZnNldCwgd2hpdGVGaXJzdCwgcGF0dGVybiwgbmV3IEludDMyQXJyYXkocGF0dGVybi5sZW5ndGgpKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHJvdyByb3cgb2YgYmxhY2svd2hpdGUgdmFsdWVzIHRvIHNlYXJjaFxuICAgICAgICAgKiBAcGFyYW0gcm93T2Zmc2V0IHBvc2l0aW9uIHRvIHN0YXJ0IHNlYXJjaFxuICAgICAgICAgKiBAcGFyYW0gd2hpdGVGaXJzdCBpZiB0cnVlLCBpbmRpY2F0ZXMgdGhhdCB0aGUgcGF0dGVybiBzcGVjaWZpZXMgd2hpdGUvYmxhY2svd2hpdGUvLi4uXG4gICAgICAgICAqIHBpeGVsIGNvdW50cywgb3RoZXJ3aXNlLCBpdCBpcyBpbnRlcnByZXRlZCBhcyBibGFjay93aGl0ZS9ibGFjay8uLi5cbiAgICAgICAgICogQHBhcmFtIHBhdHRlcm4gcGF0dGVybiBvZiBjb3VudHMgb2YgbnVtYmVyIG9mIGJsYWNrIGFuZCB3aGl0ZSBwaXhlbHMgdGhhdCBhcmUgYmVpbmdcbiAgICAgICAgICogc2VhcmNoZWQgZm9yIGFzIGEgcGF0dGVyblxuICAgICAgICAgKiBAcGFyYW0gY291bnRlcnMgYXJyYXkgb2YgY291bnRlcnMsIGFzIGxvbmcgYXMgcGF0dGVybiwgdG8gcmUtdXNlXG4gICAgICAgICAqIEByZXR1cm4gc3RhcnQvZW5kIGhvcml6b250YWwgb2Zmc2V0IG9mIGd1YXJkIHBhdHRlcm4sIGFzIGFuIGFycmF5IG9mIHR3byBpbnRzXG4gICAgICAgICAqIEB0aHJvd3MgTm90Rm91bmRFeGNlcHRpb24gaWYgcGF0dGVybiBpcyBub3QgZm91bmRcbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBmaW5kR3VhcmRQYXR0ZXJuKHJvdywgcm93T2Zmc2V0LCB3aGl0ZUZpcnN0LCBwYXR0ZXJuLCBjb3VudGVycykge1xuICAgICAgICAgICAgbGV0IHdpZHRoID0gcm93LmdldFNpemUoKTtcbiAgICAgICAgICAgIHJvd09mZnNldCA9IHdoaXRlRmlyc3QgPyByb3cuZ2V0TmV4dFVuc2V0KHJvd09mZnNldCkgOiByb3cuZ2V0TmV4dFNldChyb3dPZmZzZXQpO1xuICAgICAgICAgICAgbGV0IGNvdW50ZXJQb3NpdGlvbiA9IDA7XG4gICAgICAgICAgICBsZXQgcGF0dGVyblN0YXJ0ID0gcm93T2Zmc2V0O1xuICAgICAgICAgICAgbGV0IHBhdHRlcm5MZW5ndGggPSBwYXR0ZXJuLmxlbmd0aDtcbiAgICAgICAgICAgIGxldCBpc1doaXRlID0gd2hpdGVGaXJzdDtcbiAgICAgICAgICAgIGZvciAobGV0IHggPSByb3dPZmZzZXQ7IHggPCB3aWR0aDsgeCsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJvdy5nZXQoeCkgIT09IGlzV2hpdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY291bnRlcnNbY291bnRlclBvc2l0aW9uXSsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvdW50ZXJQb3NpdGlvbiA9PT0gcGF0dGVybkxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChPbmVEUmVhZGVyLnBhdHRlcm5NYXRjaFZhcmlhbmNlKGNvdW50ZXJzLCBwYXR0ZXJuLCBBYnN0cmFjdFVQQ0VBTlJlYWRlci5NQVhfSU5ESVZJRFVBTF9WQVJJQU5DRSkgPCBBYnN0cmFjdFVQQ0VBTlJlYWRlci5NQVhfQVZHX1ZBUklBTkNFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEludDMyQXJyYXkuZnJvbShbcGF0dGVyblN0YXJ0LCB4XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuU3RhcnQgKz0gY291bnRlcnNbMF0gKyBjb3VudGVyc1sxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzbGljZSA9IGNvdW50ZXJzLnNsaWNlKDIsIGNvdW50ZXJzLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudGVyUG9zaXRpb24gLSAxOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyc1tpXSA9IHNsaWNlW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlcnNbY291bnRlclBvc2l0aW9uIC0gMV0gPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlcnNbY291bnRlclBvc2l0aW9uXSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyUG9zaXRpb24tLTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJQb3NpdGlvbisrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJzW2NvdW50ZXJQb3NpdGlvbl0gPSAxO1xuICAgICAgICAgICAgICAgICAgICBpc1doaXRlID0gIWlzV2hpdGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGRlY29kZURpZ2l0KHJvdywgY291bnRlcnMsIHJvd09mZnNldCwgcGF0dGVybnMpIHtcbiAgICAgICAgICAgIHRoaXMucmVjb3JkUGF0dGVybihyb3csIHJvd09mZnNldCwgY291bnRlcnMpO1xuICAgICAgICAgICAgbGV0IGJlc3RWYXJpYW5jZSA9IHRoaXMuTUFYX0FWR19WQVJJQU5DRTtcbiAgICAgICAgICAgIGxldCBiZXN0TWF0Y2ggPSAtMTtcbiAgICAgICAgICAgIGxldCBtYXggPSBwYXR0ZXJucy5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1heDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHBhdHRlcm4gPSBwYXR0ZXJuc1tpXTtcbiAgICAgICAgICAgICAgICBsZXQgdmFyaWFuY2UgPSBPbmVEUmVhZGVyLnBhdHRlcm5NYXRjaFZhcmlhbmNlKGNvdW50ZXJzLCBwYXR0ZXJuLCBBYnN0cmFjdFVQQ0VBTlJlYWRlci5NQVhfSU5ESVZJRFVBTF9WQVJJQU5DRSk7XG4gICAgICAgICAgICAgICAgaWYgKHZhcmlhbmNlIDwgYmVzdFZhcmlhbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGJlc3RWYXJpYW5jZSA9IHZhcmlhbmNlO1xuICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2ggPSBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChiZXN0TWF0Y2ggPj0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBiZXN0TWF0Y2g7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBUaGVzZSB0d28gdmFsdWVzIGFyZSBjcml0aWNhbCBmb3IgZGV0ZXJtaW5pbmcgaG93IHBlcm1pc3NpdmUgdGhlIGRlY29kaW5nIHdpbGwgYmUuXG4gICAgLy8gV2UndmUgYXJyaXZlZCBhdCB0aGVzZSB2YWx1ZXMgdGhyb3VnaCBhIGxvdCBvZiB0cmlhbCBhbmQgZXJyb3IuIFNldHRpbmcgdGhlbSBhbnkgaGlnaGVyXG4gICAgLy8gbGV0cyBmYWxzZSBwb3NpdGl2ZXMgY3JlZXAgaW4gcXVpY2tseS5cbiAgICBBYnN0cmFjdFVQQ0VBTlJlYWRlci5NQVhfQVZHX1ZBUklBTkNFID0gMC40ODtcbiAgICBBYnN0cmFjdFVQQ0VBTlJlYWRlci5NQVhfSU5ESVZJRFVBTF9WQVJJQU5DRSA9IDAuNztcbiAgICAvKipcbiAgICAgKiBTdGFydC9lbmQgZ3VhcmQgcGF0dGVybi5cbiAgICAgKi9cbiAgICBBYnN0cmFjdFVQQ0VBTlJlYWRlci5TVEFSVF9FTkRfUEFUVEVSTiA9IEludDMyQXJyYXkuZnJvbShbMSwgMSwgMV0pO1xuICAgIC8qKlxuICAgICAqIFBhdHRlcm4gbWFya2luZyB0aGUgbWlkZGxlIG9mIGEgVVBDL0VBTiBwYXR0ZXJuLCBzZXBhcmF0aW5nIHRoZSB0d28gaGFsdmVzLlxuICAgICAqL1xuICAgIEFic3RyYWN0VVBDRUFOUmVhZGVyLk1JRERMRV9QQVRURVJOID0gSW50MzJBcnJheS5mcm9tKFsxLCAxLCAxLCAxLCAxXSk7XG4gICAgLyoqXG4gICAgICogZW5kIGd1YXJkIHBhdHRlcm4uXG4gICAgICovXG4gICAgQWJzdHJhY3RVUENFQU5SZWFkZXIuRU5EX1BBVFRFUk4gPSBJbnQzMkFycmF5LmZyb20oWzEsIDEsIDEsIDEsIDEsIDFdKTtcbiAgICAvKipcbiAgICAgKiBcIk9kZFwiLCBvciBcIkxcIiBwYXR0ZXJucyB1c2VkIHRvIGVuY29kZSBVUEMvRUFOIGRpZ2l0cy5cbiAgICAgKi9cbiAgICBBYnN0cmFjdFVQQ0VBTlJlYWRlci5MX1BBVFRFUk5TID0gW1xuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzMsIDIsIDEsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsyLCAyLCAyLCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMiwgMSwgMiwgMl0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDQsIDEsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAxLCAzLCAyXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMiwgMywgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDEsIDEsIDRdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAzLCAxLCAyXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMiwgMSwgM10pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzMsIDEsIDEsIDJdKSxcbiAgICBdO1xuXG4gICAgLyoqXG4gICAgICogQHNlZSBVUENFQU5FeHRlbnNpb24yU3VwcG9ydFxuICAgICAqL1xuICAgIGNsYXNzIFVQQ0VBTkV4dGVuc2lvbjVTdXBwb3J0IHtcbiAgICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgICAgICB0aGlzLkNIRUNLX0RJR0lUX0VOQ09ESU5HUyA9IFsweDE4LCAweDE0LCAweDEyLCAweDExLCAweDBDLCAweDA2LCAweDAzLCAweDBBLCAweDA5LCAweDA1XTtcbiAgICAgICAgICAgIHRoaXMuZGVjb2RlTWlkZGxlQ291bnRlcnMgPSBJbnQzMkFycmF5LmZyb20oWzAsIDAsIDAsIDBdKTtcbiAgICAgICAgICAgIHRoaXMuZGVjb2RlUm93U3RyaW5nQnVmZmVyID0gJyc7XG4gICAgICAgIH1cbiAgICAgICAgZGVjb2RlUm93KHJvd051bWJlciwgcm93LCBleHRlbnNpb25TdGFydFJhbmdlKSB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5kZWNvZGVSb3dTdHJpbmdCdWZmZXI7XG4gICAgICAgICAgICBsZXQgZW5kID0gdGhpcy5kZWNvZGVNaWRkbGUocm93LCBleHRlbnNpb25TdGFydFJhbmdlLCByZXN1bHQpO1xuICAgICAgICAgICAgbGV0IHJlc3VsdFN0cmluZyA9IHJlc3VsdC50b1N0cmluZygpO1xuICAgICAgICAgICAgbGV0IGV4dGVuc2lvbkRhdGEgPSBVUENFQU5FeHRlbnNpb241U3VwcG9ydC5wYXJzZUV4dGVuc2lvblN0cmluZyhyZXN1bHRTdHJpbmcpO1xuICAgICAgICAgICAgbGV0IHJlc3VsdFBvaW50cyA9IFtcbiAgICAgICAgICAgICAgICBuZXcgUmVzdWx0UG9pbnQoKGV4dGVuc2lvblN0YXJ0UmFuZ2VbMF0gKyBleHRlbnNpb25TdGFydFJhbmdlWzFdKSAvIDIuMCwgcm93TnVtYmVyKSxcbiAgICAgICAgICAgICAgICBuZXcgUmVzdWx0UG9pbnQoZW5kLCByb3dOdW1iZXIpXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgbGV0IGV4dGVuc2lvblJlc3VsdCA9IG5ldyBSZXN1bHQocmVzdWx0U3RyaW5nLCBudWxsLCAwLCByZXN1bHRQb2ludHMsIEJhcmNvZGVGb3JtYXQkMS5VUENfRUFOX0VYVEVOU0lPTiwgbmV3IERhdGUoKS5nZXRUaW1lKCkpO1xuICAgICAgICAgICAgaWYgKGV4dGVuc2lvbkRhdGEgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGV4dGVuc2lvblJlc3VsdC5wdXRBbGxNZXRhZGF0YShleHRlbnNpb25EYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBleHRlbnNpb25SZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgZGVjb2RlTWlkZGxlKHJvdywgc3RhcnRSYW5nZSwgcmVzdWx0U3RyaW5nKSB7XG4gICAgICAgICAgICBsZXQgY291bnRlcnMgPSB0aGlzLmRlY29kZU1pZGRsZUNvdW50ZXJzO1xuICAgICAgICAgICAgY291bnRlcnNbMF0gPSAwO1xuICAgICAgICAgICAgY291bnRlcnNbMV0gPSAwO1xuICAgICAgICAgICAgY291bnRlcnNbMl0gPSAwO1xuICAgICAgICAgICAgY291bnRlcnNbM10gPSAwO1xuICAgICAgICAgICAgbGV0IGVuZCA9IHJvdy5nZXRTaXplKCk7XG4gICAgICAgICAgICBsZXQgcm93T2Zmc2V0ID0gc3RhcnRSYW5nZVsxXTtcbiAgICAgICAgICAgIGxldCBsZ1BhdHRlcm5Gb3VuZCA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IDUgJiYgcm93T2Zmc2V0IDwgZW5kOyB4KyspIHtcbiAgICAgICAgICAgICAgICBsZXQgYmVzdE1hdGNoID0gQWJzdHJhY3RVUENFQU5SZWFkZXIuZGVjb2RlRGlnaXQoXG4gICAgICAgICAgICAgICAgICAgIHJvdyxcbiAgICAgICAgICAgICAgICAgICAgY291bnRlcnMsXG4gICAgICAgICAgICAgICAgICAgIHJvd09mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgQWJzdHJhY3RVUENFQU5SZWFkZXIuTF9BTkRfR19QQVRURVJOUyk7XG4gICAgICAgICAgICAgICAgcmVzdWx0U3RyaW5nICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKCcwJy5jaGFyQ29kZUF0KDApICsgYmVzdE1hdGNoICUgMTApKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBjb3VudGVyIG9mIGNvdW50ZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvd09mZnNldCArPSBjb3VudGVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYmVzdE1hdGNoID49IDEwKSB7XG4gICAgICAgICAgICAgICAgICAgIGxnUGF0dGVybkZvdW5kIHw9IDEgPDwgKDQgLSB4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHggIT09IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVhZCBvZmYgc2VwYXJhdG9yIGlmIG5vdCBsYXN0XG4gICAgICAgICAgICAgICAgICAgIHJvd09mZnNldCA9IHJvdy5nZXROZXh0U2V0KHJvd09mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIHJvd09mZnNldCA9IHJvdy5nZXROZXh0VW5zZXQocm93T2Zmc2V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzdWx0U3RyaW5nLmxlbmd0aCAhPT0gNSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGNoZWNrRGlnaXQgPSB0aGlzLmRldGVybWluZUNoZWNrRGlnaXQobGdQYXR0ZXJuRm91bmQpO1xuICAgICAgICAgICAgaWYgKFVQQ0VBTkV4dGVuc2lvbjVTdXBwb3J0LmV4dGVuc2lvbkNoZWNrc3VtKHJlc3VsdFN0cmluZy50b1N0cmluZygpKSAhPT0gY2hlY2tEaWdpdCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJvd09mZnNldDtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgZXh0ZW5zaW9uQ2hlY2tzdW0ocykge1xuICAgICAgICAgICAgbGV0IGxlbmd0aCA9IHMubGVuZ3RoO1xuICAgICAgICAgICAgbGV0IHN1bSA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gbGVuZ3RoIC0gMjsgaSA+PSAwOyBpIC09IDIpIHtcbiAgICAgICAgICAgICAgICBzdW0gKz0gcy5jaGFyQXQoaSkuY2hhckNvZGVBdCgwKSAtICcwJy5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3VtICo9IDM7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gbGVuZ3RoIC0gMTsgaSA+PSAwOyBpIC09IDIpIHtcbiAgICAgICAgICAgICAgICBzdW0gKz0gcy5jaGFyQXQoaSkuY2hhckNvZGVBdCgwKSAtICcwJy5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3VtICo9IDM7XG4gICAgICAgICAgICByZXR1cm4gc3VtICUgMTA7XG4gICAgICAgIH1cbiAgICAgICAgZGV0ZXJtaW5lQ2hlY2tEaWdpdChsZ1BhdHRlcm5Gb3VuZCkge1xuICAgICAgICAgICAgZm9yIChsZXQgZCA9IDA7IGQgPCAxMDsgZCsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxnUGF0dGVybkZvdW5kID09PSB0aGlzLkNIRUNLX0RJR0lUX0VOQ09ESU5HU1tkXSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgcGFyc2VFeHRlbnNpb25TdHJpbmcocmF3KSB7XG4gICAgICAgICAgICBpZiAocmF3Lmxlbmd0aCAhPT0gNSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHZhbHVlID0gVVBDRUFORXh0ZW5zaW9uNVN1cHBvcnQucGFyc2VFeHRlbnNpb241U3RyaW5nKHJhdyk7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBNYXAoW1tSZXN1bHRNZXRhZGF0YVR5cGUkMS5TVUdHRVNURURfUFJJQ0UsIHZhbHVlXV0pO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBwYXJzZUV4dGVuc2lvbjVTdHJpbmcocmF3KSB7XG4gICAgICAgICAgICBsZXQgY3VycmVuY3k7XG4gICAgICAgICAgICBzd2l0Y2ggKHJhdy5jaGFyQXQoMCkpIHtcbiAgICAgICAgICAgICAgICBjYXNlICcwJzpcbiAgICAgICAgICAgICAgICAgICAgY3VycmVuY3kgPSAnXHUwMEEzJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnNSc6XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbmN5ID0gJyQnO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICc5JzpcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVmZXJlbmNlOiBodHRwOi8vd3d3LmpvbGx5dGVjaC5jb21cbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChyYXcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJzkwMDAwJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBObyBzdWdnZXN0ZWQgcmV0YWlsIHByaWNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICc5OTk5MSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29tcGxlbWVudGFyeVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnMC4wMCc7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICc5OTk5MCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdVc2VkJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UuLi4gdW5rbm93biBjdXJyZW5jeT9cbiAgICAgICAgICAgICAgICAgICAgY3VycmVuY3kgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgY3VycmVuY3kgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcmF3QW1vdW50ID0gcGFyc2VJbnQocmF3LnN1YnN0cmluZygxKSk7XG4gICAgICAgICAgICBsZXQgdW5pdHNTdHJpbmcgPSAocmF3QW1vdW50IC8gMTAwKS50b1N0cmluZygpO1xuICAgICAgICAgICAgbGV0IGh1bmRyZWR0aHMgPSByYXdBbW91bnQgJSAxMDA7XG4gICAgICAgICAgICBsZXQgaHVuZHJlZHRoc1N0cmluZyA9IGh1bmRyZWR0aHMgPCAxMCA/ICcwJyArIGh1bmRyZWR0aHMgOiBodW5kcmVkdGhzLnRvU3RyaW5nKCk7IC8vIGZpeG1lXG4gICAgICAgICAgICByZXR1cm4gY3VycmVuY3kgKyB1bml0c1N0cmluZyArICcuJyArIGh1bmRyZWR0aHNTdHJpbmc7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAc2VlIFVQQ0VBTkV4dGVuc2lvbjVTdXBwb3J0XG4gICAgICovXG4gICAgY2xhc3MgVVBDRUFORXh0ZW5zaW9uMlN1cHBvcnQge1xuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgICAgIHRoaXMuZGVjb2RlTWlkZGxlQ291bnRlcnMgPSBJbnQzMkFycmF5LmZyb20oWzAsIDAsIDAsIDBdKTtcbiAgICAgICAgICAgIHRoaXMuZGVjb2RlUm93U3RyaW5nQnVmZmVyID0gJyc7XG4gICAgICAgIH1cbiAgICAgICAgZGVjb2RlUm93KHJvd051bWJlciwgcm93LCBleHRlbnNpb25TdGFydFJhbmdlKSB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5kZWNvZGVSb3dTdHJpbmdCdWZmZXI7XG4gICAgICAgICAgICBsZXQgZW5kID0gdGhpcy5kZWNvZGVNaWRkbGUocm93LCBleHRlbnNpb25TdGFydFJhbmdlLCByZXN1bHQpO1xuICAgICAgICAgICAgbGV0IHJlc3VsdFN0cmluZyA9IHJlc3VsdC50b1N0cmluZygpO1xuICAgICAgICAgICAgbGV0IGV4dGVuc2lvbkRhdGEgPSBVUENFQU5FeHRlbnNpb24yU3VwcG9ydC5wYXJzZUV4dGVuc2lvblN0cmluZyhyZXN1bHRTdHJpbmcpO1xuICAgICAgICAgICAgbGV0IHJlc3VsdFBvaW50cyA9IFtcbiAgICAgICAgICAgICAgICBuZXcgUmVzdWx0UG9pbnQoKGV4dGVuc2lvblN0YXJ0UmFuZ2VbMF0gKyBleHRlbnNpb25TdGFydFJhbmdlWzFdKSAvIDIuMCwgcm93TnVtYmVyKSxcbiAgICAgICAgICAgICAgICBuZXcgUmVzdWx0UG9pbnQoZW5kLCByb3dOdW1iZXIpXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgbGV0IGV4dGVuc2lvblJlc3VsdCA9IG5ldyBSZXN1bHQocmVzdWx0U3RyaW5nLCBudWxsLCAwLCByZXN1bHRQb2ludHMsIEJhcmNvZGVGb3JtYXQkMS5VUENfRUFOX0VYVEVOU0lPTiwgbmV3IERhdGUoKS5nZXRUaW1lKCkpO1xuICAgICAgICAgICAgaWYgKGV4dGVuc2lvbkRhdGEgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGV4dGVuc2lvblJlc3VsdC5wdXRBbGxNZXRhZGF0YShleHRlbnNpb25EYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBleHRlbnNpb25SZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgZGVjb2RlTWlkZGxlKHJvdywgc3RhcnRSYW5nZSwgcmVzdWx0U3RyaW5nKSB7XG4gICAgICAgICAgICBsZXQgY291bnRlcnMgPSB0aGlzLmRlY29kZU1pZGRsZUNvdW50ZXJzO1xuICAgICAgICAgICAgY291bnRlcnNbMF0gPSAwO1xuICAgICAgICAgICAgY291bnRlcnNbMV0gPSAwO1xuICAgICAgICAgICAgY291bnRlcnNbMl0gPSAwO1xuICAgICAgICAgICAgY291bnRlcnNbM10gPSAwO1xuICAgICAgICAgICAgbGV0IGVuZCA9IHJvdy5nZXRTaXplKCk7XG4gICAgICAgICAgICBsZXQgcm93T2Zmc2V0ID0gc3RhcnRSYW5nZVsxXTtcbiAgICAgICAgICAgIGxldCBjaGVja1Bhcml0eSA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IDIgJiYgcm93T2Zmc2V0IDwgZW5kOyB4KyspIHtcbiAgICAgICAgICAgICAgICBsZXQgYmVzdE1hdGNoID0gQWJzdHJhY3RVUENFQU5SZWFkZXIuZGVjb2RlRGlnaXQocm93LCBjb3VudGVycywgcm93T2Zmc2V0LCBBYnN0cmFjdFVQQ0VBTlJlYWRlci5MX0FORF9HX1BBVFRFUk5TKTtcbiAgICAgICAgICAgICAgICByZXN1bHRTdHJpbmcgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoJzAnLmNoYXJDb2RlQXQoMCkgKyBiZXN0TWF0Y2ggJSAxMCkpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGNvdW50ZXIgb2YgY291bnRlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgcm93T2Zmc2V0ICs9IGNvdW50ZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChiZXN0TWF0Y2ggPj0gMTApIHtcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tQYXJpdHkgfD0gMSA8PCAoMSAtIHgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoeCAhPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBSZWFkIG9mZiBzZXBhcmF0b3IgaWYgbm90IGxhc3RcbiAgICAgICAgICAgICAgICAgICAgcm93T2Zmc2V0ID0gcm93LmdldE5leHRTZXQocm93T2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgcm93T2Zmc2V0ID0gcm93LmdldE5leHRVbnNldChyb3dPZmZzZXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXN1bHRTdHJpbmcubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFyc2VJbnQocmVzdWx0U3RyaW5nLnRvU3RyaW5nKCkpICUgNCAhPT0gY2hlY2tQYXJpdHkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByb3dPZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIHBhcnNlRXh0ZW5zaW9uU3RyaW5nKHJhdykge1xuICAgICAgICAgICAgaWYgKHJhdy5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgTWFwKFtbUmVzdWx0TWV0YWRhdGFUeXBlJDEuSVNTVUVfTlVNQkVSLCBwYXJzZUludChyYXcpXV0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY2xhc3MgVVBDRUFORXh0ZW5zaW9uU3VwcG9ydCB7XG4gICAgICAgIHN0YXRpYyBkZWNvZGVSb3cocm93TnVtYmVyLCByb3csIHJvd09mZnNldCkge1xuICAgICAgICAgICAgbGV0IGV4dGVuc2lvblN0YXJ0UmFuZ2UgPSBBYnN0cmFjdFVQQ0VBTlJlYWRlci5maW5kR3VhcmRQYXR0ZXJuKFxuICAgICAgICAgICAgICAgIHJvdyxcbiAgICAgICAgICAgICAgICByb3dPZmZzZXQsXG4gICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICAgdGhpcy5FWFRFTlNJT05fU1RBUlRfUEFUVEVSTixcbiAgICAgICAgICAgICAgICBuZXcgSW50MzJBcnJheSh0aGlzLkVYVEVOU0lPTl9TVEFSVF9QQVRURVJOLmxlbmd0aCkuZmlsbCgwKSk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIC8vIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIGxldCBmaXZlU3VwcG9ydCA9IG5ldyBVUENFQU5FeHRlbnNpb241U3VwcG9ydCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmaXZlU3VwcG9ydC5kZWNvZGVSb3cocm93TnVtYmVyLCByb3csIGV4dGVuc2lvblN0YXJ0UmFuZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIC8vIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIGxldCB0d29TdXBwb3J0ID0gbmV3IFVQQ0VBTkV4dGVuc2lvbjJTdXBwb3J0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR3b1N1cHBvcnQuZGVjb2RlUm93KHJvd051bWJlciwgcm93LCBleHRlbnNpb25TdGFydFJhbmdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBVUENFQU5FeHRlbnNpb25TdXBwb3J0LkVYVEVOU0lPTl9TVEFSVF9QQVRURVJOID0gSW50MzJBcnJheS5mcm9tKFsxLCAxLCAyXSk7XG5cbiAgICAvKipcbiAgICAgKiA8cD5FbmNhcHN1bGF0ZXMgZnVuY3Rpb25hbGl0eSBhbmQgaW1wbGVtZW50YXRpb24gdGhhdCBpcyBjb21tb24gdG8gVVBDIGFuZCBFQU4gZmFtaWxpZXNcbiAgICAgKiBvZiBvbmUtZGltZW5zaW9uYWwgYmFyY29kZXMuPC9wPlxuICAgICAqXG4gICAgICogQGF1dGhvciBkc3dpdGtpbkBnb29nbGUuY29tIChEYW5pZWwgU3dpdGtpbilcbiAgICAgKiBAYXV0aG9yIFNlYW4gT3dlblxuICAgICAqIEBhdXRob3IgYWxhc2RhaXJAZ29vZ2xlLmNvbSAoQWxhc2RhaXIgTWFja2ludG9zaClcbiAgICAgKi9cbiAgICBjbGFzcyBVUENFQU5SZWFkZXIgZXh0ZW5kcyBBYnN0cmFjdFVQQ0VBTlJlYWRlciB7XG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgICAgIHRoaXMuZGVjb2RlUm93U3RyaW5nQnVmZmVyID0gJyc7XG4gICAgICAgICAgICBVUENFQU5SZWFkZXIuTF9BTkRfR19QQVRURVJOUyA9IFVQQ0VBTlJlYWRlci5MX1BBVFRFUk5TLm1hcChhcnIgPT4gSW50MzJBcnJheS5mcm9tKGFycikpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDEwOyBpIDwgMjA7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCB3aWR0aHMgPSBVUENFQU5SZWFkZXIuTF9QQVRURVJOU1tpIC0gMTBdO1xuICAgICAgICAgICAgICAgIGxldCByZXZlcnNlZFdpZHRocyA9IG5ldyBJbnQzMkFycmF5KHdpZHRocy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgd2lkdGhzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldmVyc2VkV2lkdGhzW2pdID0gd2lkdGhzW3dpZHRocy5sZW5ndGggLSBqIC0gMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFVQQ0VBTlJlYWRlci5MX0FORF9HX1BBVFRFUk5TW2ldID0gcmV2ZXJzZWRXaWR0aHM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZGVjb2RlUm93KHJvd051bWJlciwgcm93LCBoaW50cykge1xuICAgICAgICAgICAgbGV0IHN0YXJ0R3VhcmRSYW5nZSA9IFVQQ0VBTlJlYWRlci5maW5kU3RhcnRHdWFyZFBhdHRlcm4ocm93KTtcbiAgICAgICAgICAgIGxldCByZXN1bHRQb2ludENhbGxiYWNrID0gaGludHMgPT0gbnVsbCA/IG51bGwgOiBoaW50cy5nZXQoRGVjb2RlSGludFR5cGUkMS5ORUVEX1JFU1VMVF9QT0lOVF9DQUxMQkFDSyk7XG4gICAgICAgICAgICBpZiAocmVzdWx0UG9pbnRDYWxsYmFjayAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0UG9pbnQgPSBuZXcgUmVzdWx0UG9pbnQoKHN0YXJ0R3VhcmRSYW5nZVswXSArIHN0YXJ0R3VhcmRSYW5nZVsxXSkgLyAyLjAsIHJvd051bWJlcik7XG4gICAgICAgICAgICAgICAgcmVzdWx0UG9pbnRDYWxsYmFjay5mb3VuZFBvc3NpYmxlUmVzdWx0UG9pbnQocmVzdWx0UG9pbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGJ1ZGVsbG8gPSB0aGlzLmRlY29kZU1pZGRsZShyb3csIHN0YXJ0R3VhcmRSYW5nZSwgdGhpcy5kZWNvZGVSb3dTdHJpbmdCdWZmZXIpO1xuICAgICAgICAgICAgbGV0IGVuZFN0YXJ0ID0gYnVkZWxsby5yb3dPZmZzZXQ7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gYnVkZWxsby5yZXN1bHRTdHJpbmc7XG4gICAgICAgICAgICBpZiAocmVzdWx0UG9pbnRDYWxsYmFjayAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0UG9pbnQgPSBuZXcgUmVzdWx0UG9pbnQoZW5kU3RhcnQsIHJvd051bWJlcik7XG4gICAgICAgICAgICAgICAgcmVzdWx0UG9pbnRDYWxsYmFjay5mb3VuZFBvc3NpYmxlUmVzdWx0UG9pbnQocmVzdWx0UG9pbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGVuZFJhbmdlID0gdGhpcy5kZWNvZGVFbmQocm93LCBlbmRTdGFydCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0UG9pbnRDYWxsYmFjayAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0UG9pbnQgPSBuZXcgUmVzdWx0UG9pbnQoKGVuZFJhbmdlWzBdICsgZW5kUmFuZ2VbMV0pIC8gMi4wLCByb3dOdW1iZXIpO1xuICAgICAgICAgICAgICAgIHJlc3VsdFBvaW50Q2FsbGJhY2suZm91bmRQb3NzaWJsZVJlc3VsdFBvaW50KHJlc3VsdFBvaW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGVyZSBpcyBhIHF1aWV0IHpvbmUgYXQgbGVhc3QgYXMgYmlnIGFzIHRoZSBlbmQgcGF0dGVybiBhZnRlciB0aGUgYmFyY29kZS4gVGhlXG4gICAgICAgICAgICAvLyBzcGVjIG1pZ2h0IHdhbnQgbW9yZSB3aGl0ZXNwYWNlLCBidXQgaW4gcHJhY3RpY2UgdGhpcyBpcyB0aGUgbWF4aW11bSB3ZSBjYW4gY291bnQgb24uXG4gICAgICAgICAgICBsZXQgZW5kID0gZW5kUmFuZ2VbMV07XG4gICAgICAgICAgICBsZXQgcXVpZXRFbmQgPSBlbmQgKyAoZW5kIC0gZW5kUmFuZ2VbMF0pO1xuICAgICAgICAgICAgaWYgKHF1aWV0RW5kID49IHJvdy5nZXRTaXplKCkgfHwgIXJvdy5pc1JhbmdlKGVuZCwgcXVpZXRFbmQsIGZhbHNlKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHJlc3VsdFN0cmluZyA9IHJlc3VsdC50b1N0cmluZygpO1xuICAgICAgICAgICAgLy8gVVBDL0VBTiBzaG91bGQgbmV2ZXIgYmUgbGVzcyB0aGFuIDggY2hhcnMgYW55d2F5XG4gICAgICAgICAgICBpZiAocmVzdWx0U3RyaW5nLmxlbmd0aCA8IDgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIVVQQ0VBTlJlYWRlci5jaGVja0NoZWNrc3VtKHJlc3VsdFN0cmluZykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQ2hlY2tzdW1FeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBsZWZ0ID0gKHN0YXJ0R3VhcmRSYW5nZVsxXSArIHN0YXJ0R3VhcmRSYW5nZVswXSkgLyAyLjA7XG4gICAgICAgICAgICBsZXQgcmlnaHQgPSAoZW5kUmFuZ2VbMV0gKyBlbmRSYW5nZVswXSkgLyAyLjA7XG4gICAgICAgICAgICBsZXQgZm9ybWF0ID0gdGhpcy5nZXRCYXJjb2RlRm9ybWF0KCk7XG4gICAgICAgICAgICBsZXQgcmVzdWx0UG9pbnQgPSBbbmV3IFJlc3VsdFBvaW50KGxlZnQsIHJvd051bWJlciksIG5ldyBSZXN1bHRQb2ludChyaWdodCwgcm93TnVtYmVyKV07XG4gICAgICAgICAgICBsZXQgZGVjb2RlUmVzdWx0ID0gbmV3IFJlc3VsdChyZXN1bHRTdHJpbmcsIG51bGwsIDAsIHJlc3VsdFBvaW50LCBmb3JtYXQsIG5ldyBEYXRlKCkuZ2V0VGltZSgpKTtcbiAgICAgICAgICAgIGxldCBleHRlbnNpb25MZW5ndGggPSAwO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBsZXQgZXh0ZW5zaW9uUmVzdWx0ID0gVVBDRUFORXh0ZW5zaW9uU3VwcG9ydC5kZWNvZGVSb3cocm93TnVtYmVyLCByb3csIGVuZFJhbmdlWzFdKTtcbiAgICAgICAgICAgICAgICBkZWNvZGVSZXN1bHQucHV0TWV0YWRhdGEoUmVzdWx0TWV0YWRhdGFUeXBlJDEuVVBDX0VBTl9FWFRFTlNJT04sIGV4dGVuc2lvblJlc3VsdC5nZXRUZXh0KCkpO1xuICAgICAgICAgICAgICAgIGRlY29kZVJlc3VsdC5wdXRBbGxNZXRhZGF0YShleHRlbnNpb25SZXN1bHQuZ2V0UmVzdWx0TWV0YWRhdGEoKSk7XG4gICAgICAgICAgICAgICAgZGVjb2RlUmVzdWx0LmFkZFJlc3VsdFBvaW50cyhleHRlbnNpb25SZXN1bHQuZ2V0UmVzdWx0UG9pbnRzKCkpO1xuICAgICAgICAgICAgICAgIGV4dGVuc2lvbkxlbmd0aCA9IGV4dGVuc2lvblJlc3VsdC5nZXRUZXh0KCkubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGlnbm9yZUVycm9yKSB7fVxuICAgICAgICAgICAgbGV0IGFsbG93ZWRFeHRlbnNpb25zID0gaGludHMgPT0gbnVsbCA/IG51bGwgOiBoaW50cy5nZXQoRGVjb2RlSGludFR5cGUkMS5BTExPV0VEX0VBTl9FWFRFTlNJT05TKTtcbiAgICAgICAgICAgIGlmIChhbGxvd2VkRXh0ZW5zaW9ucyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbGV0IHZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgbGVuZ3RoIGluIGFsbG93ZWRFeHRlbnNpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChleHRlbnNpb25MZW5ndGgudG9TdHJpbmcoKSA9PT0gbGVuZ3RoKSB7IC8vIGNoZWNrIG1lXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXZhbGlkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkZWNvZGVSZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgZGVjb2RlRW5kKHJvdywgZW5kU3RhcnQpIHtcbiAgICAgICAgICAgIHJldHVybiBVUENFQU5SZWFkZXIuZmluZEd1YXJkUGF0dGVybihcbiAgICAgICAgICAgICAgICByb3csIGVuZFN0YXJ0LCBmYWxzZSwgVVBDRUFOUmVhZGVyLlNUQVJUX0VORF9QQVRURVJOLFxuICAgICAgICAgICAgICAgIG5ldyBJbnQzMkFycmF5KFVQQ0VBTlJlYWRlci5TVEFSVF9FTkRfUEFUVEVSTi5sZW5ndGgpLmZpbGwoMCkpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBjaGVja0NoZWNrc3VtKHMpIHtcbiAgICAgICAgICAgIHJldHVybiBVUENFQU5SZWFkZXIuY2hlY2tTdGFuZGFyZFVQQ0VBTkNoZWNrc3VtKHMpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBjaGVja1N0YW5kYXJkVVBDRUFOQ2hlY2tzdW0ocykge1xuICAgICAgICAgICAgbGV0IGxlbmd0aCA9IHMubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBsZXQgY2hlY2sgPSBwYXJzZUludChzLmNoYXJBdChsZW5ndGggLSAxKSwgMTApO1xuICAgICAgICAgICAgcmV0dXJuIFVQQ0VBTlJlYWRlci5nZXRTdGFuZGFyZFVQQ0VBTkNoZWNrc3VtKHMuc3Vic3RyaW5nKDAsIGxlbmd0aCAtIDEpKSA9PT0gY2hlY2s7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGdldFN0YW5kYXJkVVBDRUFOQ2hlY2tzdW0ocykge1xuICAgICAgICAgICAgbGV0IGxlbmd0aCA9IHMubGVuZ3RoO1xuICAgICAgICAgICAgbGV0IHN1bSA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gbGVuZ3RoIC0gMTsgaSA+PSAwOyBpIC09IDIpIHtcbiAgICAgICAgICAgICAgICBsZXQgZGlnaXQgPSBzLmNoYXJBdChpKS5jaGFyQ29kZUF0KDApIC0gJzAnLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgICAgICAgaWYgKGRpZ2l0IDwgMCB8fCBkaWdpdCA+IDkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdW0gKz0gZGlnaXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdW0gKj0gMztcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBsZW5ndGggLSAyOyBpID49IDA7IGkgLT0gMikge1xuICAgICAgICAgICAgICAgIGxldCBkaWdpdCA9IHMuY2hhckF0KGkpLmNoYXJDb2RlQXQoMCkgLSAnMCcuY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICAgICAgICBpZiAoZGlnaXQgPCAwIHx8IGRpZ2l0ID4gOSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN1bSArPSBkaWdpdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAoMTAwMCAtIHN1bSkgJSAxMDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIDxwPkltcGxlbWVudHMgZGVjb2Rpbmcgb2YgdGhlIEVBTi0xMyBmb3JtYXQuPC9wPlxuICAgICAqXG4gICAgICogQGF1dGhvciBkc3dpdGtpbkBnb29nbGUuY29tIChEYW5pZWwgU3dpdGtpbilcbiAgICAgKiBAYXV0aG9yIFNlYW4gT3dlblxuICAgICAqIEBhdXRob3IgYWxhc2RhaXJAZ29vZ2xlLmNvbSAoQWxhc2RhaXIgTWFja2ludG9zaClcbiAgICAgKi9cbiAgICBjbGFzcyBFQU4xM1JlYWRlciBleHRlbmRzIFVQQ0VBTlJlYWRlciB7XG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgICAgIHRoaXMuZGVjb2RlTWlkZGxlQ291bnRlcnMgPSBJbnQzMkFycmF5LmZyb20oWzAsIDAsIDAsIDBdKTtcbiAgICAgICAgfVxuICAgICAgICBkZWNvZGVNaWRkbGUocm93LCBzdGFydFJhbmdlLCByZXN1bHRTdHJpbmcpIHtcbiAgICAgICAgICAgIGxldCBjb3VudGVycyA9IHRoaXMuZGVjb2RlTWlkZGxlQ291bnRlcnM7XG4gICAgICAgICAgICBjb3VudGVyc1swXSA9IDA7XG4gICAgICAgICAgICBjb3VudGVyc1sxXSA9IDA7XG4gICAgICAgICAgICBjb3VudGVyc1syXSA9IDA7XG4gICAgICAgICAgICBjb3VudGVyc1szXSA9IDA7XG4gICAgICAgICAgICBsZXQgZW5kID0gcm93LmdldFNpemUoKTtcbiAgICAgICAgICAgIGxldCByb3dPZmZzZXQgPSBzdGFydFJhbmdlWzFdO1xuICAgICAgICAgICAgbGV0IGxnUGF0dGVybkZvdW5kID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgNiAmJiByb3dPZmZzZXQgPCBlbmQ7IHgrKykge1xuICAgICAgICAgICAgICAgIGxldCBiZXN0TWF0Y2ggPSBVUENFQU5SZWFkZXIuZGVjb2RlRGlnaXQocm93LCBjb3VudGVycywgcm93T2Zmc2V0LCBVUENFQU5SZWFkZXIuTF9BTkRfR19QQVRURVJOUyk7XG4gICAgICAgICAgICAgICAgcmVzdWx0U3RyaW5nICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKCcwJy5jaGFyQ29kZUF0KDApICsgYmVzdE1hdGNoICUgMTApKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBjb3VudGVyIG9mIGNvdW50ZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvd09mZnNldCArPSBjb3VudGVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYmVzdE1hdGNoID49IDEwKSB7XG4gICAgICAgICAgICAgICAgICAgIGxnUGF0dGVybkZvdW5kIHw9IDEgPDwgKDUgLSB4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHRTdHJpbmcgPSBFQU4xM1JlYWRlci5kZXRlcm1pbmVGaXJzdERpZ2l0KHJlc3VsdFN0cmluZywgbGdQYXR0ZXJuRm91bmQpO1xuICAgICAgICAgICAgbGV0IG1pZGRsZVJhbmdlID0gVVBDRUFOUmVhZGVyLmZpbmRHdWFyZFBhdHRlcm4oXG4gICAgICAgICAgICAgICAgcm93LFxuICAgICAgICAgICAgICAgIHJvd09mZnNldCxcbiAgICAgICAgICAgICAgICB0cnVlLFxuICAgICAgICAgICAgICAgIFVQQ0VBTlJlYWRlci5NSURETEVfUEFUVEVSTixcbiAgICAgICAgICAgICAgICBuZXcgSW50MzJBcnJheShVUENFQU5SZWFkZXIuTUlERExFX1BBVFRFUk4ubGVuZ3RoKS5maWxsKDApKTtcbiAgICAgICAgICAgIHJvd09mZnNldCA9IG1pZGRsZVJhbmdlWzFdO1xuICAgICAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCA2ICYmIHJvd09mZnNldCA8IGVuZDsgeCsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGJlc3RNYXRjaCA9IFVQQ0VBTlJlYWRlci5kZWNvZGVEaWdpdChyb3csIGNvdW50ZXJzLCByb3dPZmZzZXQsIFVQQ0VBTlJlYWRlci5MX1BBVFRFUk5TKTtcbiAgICAgICAgICAgICAgICByZXN1bHRTdHJpbmcgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoJzAnLmNoYXJDb2RlQXQoMCkgKyBiZXN0TWF0Y2gpKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBjb3VudGVyIG9mIGNvdW50ZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvd09mZnNldCArPSBjb3VudGVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IHJvd09mZnNldCwgcmVzdWx0U3RyaW5nIH07XG4gICAgICAgIH1cbiAgICAgICAgZ2V0QmFyY29kZUZvcm1hdCgpIHtcbiAgICAgICAgICAgIHJldHVybiBCYXJjb2RlRm9ybWF0JDEuRUFOXzEzO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBkZXRlcm1pbmVGaXJzdERpZ2l0KHJlc3VsdFN0cmluZywgbGdQYXR0ZXJuRm91bmQpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGQgPSAwOyBkIDwgMTA7IGQrKykge1xuICAgICAgICAgICAgICAgIGlmIChsZ1BhdHRlcm5Gb3VuZCA9PT0gdGhpcy5GSVJTVF9ESUdJVF9FTkNPRElOR1NbZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0U3RyaW5nID0gU3RyaW5nLmZyb21DaGFyQ29kZSgoJzAnLmNoYXJDb2RlQXQoMCkgKyBkKSkgKyByZXN1bHRTdHJpbmc7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRTdHJpbmc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgRUFOMTNSZWFkZXIuRklSU1RfRElHSVRfRU5DT0RJTkdTID0gWzB4MDAsIDB4MEIsIDB4MEQsIDB4RSwgMHgxMywgMHgxOSwgMHgxQywgMHgxNSwgMHgxNiwgMHgxQV07XG5cbiAgICAvKipcbiAgICAgKiA8cD5JbXBsZW1lbnRzIGRlY29kaW5nIG9mIHRoZSBFQU4tOCBmb3JtYXQuPC9wPlxuICAgICAqXG4gICAgICogQGF1dGhvciBTZWFuIE93ZW5cbiAgICAgKi9cbiAgICBjbGFzcyBFQU44UmVhZGVyIGV4dGVuZHMgVVBDRUFOUmVhZGVyIHtcbiAgICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgICAgICBzdXBlcigpO1xuICAgICAgICAgICAgdGhpcy5kZWNvZGVNaWRkbGVDb3VudGVycyA9IEludDMyQXJyYXkuZnJvbShbMCwgMCwgMCwgMF0pO1xuICAgICAgICB9XG4gICAgICAgIGRlY29kZU1pZGRsZShyb3csIHN0YXJ0UmFuZ2UsIHJlc3VsdFN0cmluZykge1xuICAgICAgICAgICAgY29uc3QgY291bnRlcnMgPSB0aGlzLmRlY29kZU1pZGRsZUNvdW50ZXJzO1xuICAgICAgICAgICAgY291bnRlcnNbMF0gPSAwO1xuICAgICAgICAgICAgY291bnRlcnNbMV0gPSAwO1xuICAgICAgICAgICAgY291bnRlcnNbMl0gPSAwO1xuICAgICAgICAgICAgY291bnRlcnNbM10gPSAwO1xuICAgICAgICAgICAgbGV0IGVuZCA9IHJvdy5nZXRTaXplKCk7XG4gICAgICAgICAgICBsZXQgcm93T2Zmc2V0ID0gc3RhcnRSYW5nZVsxXTtcbiAgICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgNCAmJiByb3dPZmZzZXQgPCBlbmQ7IHgrKykge1xuICAgICAgICAgICAgICAgIGxldCBiZXN0TWF0Y2ggPSBVUENFQU5SZWFkZXIuZGVjb2RlRGlnaXQocm93LCBjb3VudGVycywgcm93T2Zmc2V0LCBVUENFQU5SZWFkZXIuTF9QQVRURVJOUyk7XG4gICAgICAgICAgICAgICAgcmVzdWx0U3RyaW5nICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKCcwJy5jaGFyQ29kZUF0KDApICsgYmVzdE1hdGNoKSk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgY291bnRlciBvZiBjb3VudGVycykge1xuICAgICAgICAgICAgICAgICAgICByb3dPZmZzZXQgKz0gY291bnRlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgbWlkZGxlUmFuZ2UgPSBVUENFQU5SZWFkZXIuZmluZEd1YXJkUGF0dGVybihyb3csIHJvd09mZnNldCwgdHJ1ZSwgVVBDRUFOUmVhZGVyLk1JRERMRV9QQVRURVJOLCBuZXcgSW50MzJBcnJheShVUENFQU5SZWFkZXIuTUlERExFX1BBVFRFUk4ubGVuZ3RoKS5maWxsKDApKTtcbiAgICAgICAgICAgIHJvd09mZnNldCA9IG1pZGRsZVJhbmdlWzFdO1xuICAgICAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCA0ICYmIHJvd09mZnNldCA8IGVuZDsgeCsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGJlc3RNYXRjaCA9IFVQQ0VBTlJlYWRlci5kZWNvZGVEaWdpdChyb3csIGNvdW50ZXJzLCByb3dPZmZzZXQsIFVQQ0VBTlJlYWRlci5MX1BBVFRFUk5TKTtcbiAgICAgICAgICAgICAgICByZXN1bHRTdHJpbmcgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoJzAnLmNoYXJDb2RlQXQoMCkgKyBiZXN0TWF0Y2gpKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBjb3VudGVyIG9mIGNvdW50ZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvd09mZnNldCArPSBjb3VudGVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IHJvd09mZnNldCwgcmVzdWx0U3RyaW5nIH07XG4gICAgICAgIH1cbiAgICAgICAgZ2V0QmFyY29kZUZvcm1hdCgpIHtcbiAgICAgICAgICAgIHJldHVybiBCYXJjb2RlRm9ybWF0JDEuRUFOXzg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFbmNhcHN1bGF0ZXMgZnVuY3Rpb25hbGl0eSBhbmQgaW1wbGVtZW50YXRpb24gdGhhdCBpcyBjb21tb24gdG8gYWxsIGZhbWlsaWVzXG4gICAgICogb2Ygb25lLWRpbWVuc2lvbmFsIGJhcmNvZGVzLlxuICAgICAqXG4gICAgICogQGF1dGhvciBkc3dpdGtpbkBnb29nbGUuY29tIChEYW5pZWwgU3dpdGtpbilcbiAgICAgKiBAYXV0aG9yIFNlYW4gT3dlblxuICAgICAqIEBhdXRob3Igc2FtMjMzMiAoU2FtIFJ1ZGxvZmYpXG4gICAgICpcbiAgICAgKiBAc291cmNlIGh0dHBzOi8vZ2l0aHViLmNvbS96eGluZy96eGluZy9ibG9iLzNjOTY5MjMyNzZkZDU3ODVkNThlYjk3MGI2YmEzZjgwZDM2YTk1MDUvY29yZS9zcmMvbWFpbi9qYXZhL2NvbS9nb29nbGUvenhpbmcvb25lZC9VUENBUmVhZGVyLmphdmFcbiAgICAgKlxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICBjbGFzcyBVUENBUmVhZGVyIGV4dGVuZHMgVVBDRUFOUmVhZGVyIHtcbiAgICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICAgICAgdGhpcy5lYW4xM1JlYWRlciA9IG5ldyBFQU4xM1JlYWRlcigpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEBPdmVycmlkZVxuICAgICAgICBnZXRCYXJjb2RlRm9ybWF0KCkge1xuICAgICAgICAgICAgcmV0dXJuIEJhcmNvZGVGb3JtYXQkMS5VUENfQTtcbiAgICAgICAgfVxuICAgICAgICAvLyBOb3RlIHRoYXQgd2UgZG9uJ3QgdHJ5IHJvdGF0aW9uIHdpdGhvdXQgdGhlIHRyeSBoYXJkZXIgZmxhZywgZXZlbiBpZiByb3RhdGlvbiB3YXMgc3VwcG9ydGVkLlxuICAgICAgICAvLyBAT3ZlcnJpZGVcbiAgICAgICAgZGVjb2RlKGltYWdlLCBoaW50cykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWF5YmVSZXR1cm5SZXN1bHQodGhpcy5lYW4xM1JlYWRlci5kZWNvZGUoaW1hZ2UpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBAT3ZlcnJpZGVcbiAgICAgICAgZGVjb2RlUm93KHJvd051bWJlciwgcm93LCBoaW50cykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWF5YmVSZXR1cm5SZXN1bHQodGhpcy5lYW4xM1JlYWRlci5kZWNvZGVSb3cocm93TnVtYmVyLCByb3csIGhpbnRzKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQE92ZXJyaWRlXG4gICAgICAgIGRlY29kZU1pZGRsZShyb3csIHN0YXJ0UmFuZ2UsIHJlc3VsdFN0cmluZykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFuMTNSZWFkZXIuZGVjb2RlTWlkZGxlKHJvdywgc3RhcnRSYW5nZSwgcmVzdWx0U3RyaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBtYXliZVJldHVyblJlc3VsdChyZXN1bHQpIHtcbiAgICAgICAgICAgIGxldCB0ZXh0ID0gcmVzdWx0LmdldFRleHQoKTtcbiAgICAgICAgICAgIGlmICh0ZXh0LmNoYXJBdCgwKSA9PT0gJzAnKSB7XG4gICAgICAgICAgICAgICAgbGV0IHVwY2FSZXN1bHQgPSBuZXcgUmVzdWx0KHRleHQuc3Vic3RyaW5nKDEpLCBudWxsLCBudWxsLCByZXN1bHQuZ2V0UmVzdWx0UG9pbnRzKCksIEJhcmNvZGVGb3JtYXQkMS5VUENfQSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5nZXRSZXN1bHRNZXRhZGF0YSgpICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdXBjYVJlc3VsdC5wdXRBbGxNZXRhZGF0YShyZXN1bHQuZ2V0UmVzdWx0TWV0YWRhdGEoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB1cGNhUmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVzZXQoKSB7XG4gICAgICAgICAgICB0aGlzLmVhbjEzUmVhZGVyLnJlc2V0KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiA8cD5JbXBsZW1lbnRzIGRlY29kaW5nIG9mIHRoZSBVUEMtRSBmb3JtYXQuPC9wPlxuICAgICAqIDxwPjxhIGhyZWY9XCJodHRwOi8vd3d3LmJhcmNvZGVpc2xhbmQuY29tL3VwY2UucGh0bWxcIj5UaGlzPC9hPiBpcyBhIGdyZWF0IHJlZmVyZW5jZSBmb3JcbiAgICAgKiBVUEMtRSBpbmZvcm1hdGlvbi48L3A+XG4gICAgICpcbiAgICAgKiBAYXV0aG9yIFNlYW4gT3dlblxuICAgICAqXG4gICAgICogQHNvdXJjZSBodHRwczovL2dpdGh1Yi5jb20venhpbmcvenhpbmcvYmxvYi8zYzk2OTIzMjc2ZGQ1Nzg1ZDU4ZWI5NzBiNmJhM2Y4MGQzNmE5NTA1L2NvcmUvc3JjL21haW4vamF2YS9jb20vZ29vZ2xlL3p4aW5nL29uZWQvVVBDRVJlYWRlci5qYXZhXG4gICAgICpcbiAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgLyogZmluYWwgKi8gY2xhc3MgVVBDRVJlYWRlciBleHRlbmRzIFVQQ0VBTlJlYWRlciB7XG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgICAgIHRoaXMuZGVjb2RlTWlkZGxlQ291bnRlcnMgPSBuZXcgSW50MzJBcnJheSg0KTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHRocm93cyBOb3RGb3VuZEV4Y2VwdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgLy8gQE92ZXJyaWRlXG4gICAgICAgIGRlY29kZU1pZGRsZShyb3csIHN0YXJ0UmFuZ2UsIHJlc3VsdCkge1xuICAgICAgICAgICAgY29uc3QgY291bnRlcnMgPSB0aGlzLmRlY29kZU1pZGRsZUNvdW50ZXJzLm1hcCh4ID0+IHgpO1xuICAgICAgICAgICAgY291bnRlcnNbMF0gPSAwO1xuICAgICAgICAgICAgY291bnRlcnNbMV0gPSAwO1xuICAgICAgICAgICAgY291bnRlcnNbMl0gPSAwO1xuICAgICAgICAgICAgY291bnRlcnNbM10gPSAwO1xuICAgICAgICAgICAgY29uc3QgZW5kID0gcm93LmdldFNpemUoKTtcbiAgICAgICAgICAgIGxldCByb3dPZmZzZXQgPSBzdGFydFJhbmdlWzFdO1xuICAgICAgICAgICAgbGV0IGxnUGF0dGVybkZvdW5kID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgNiAmJiByb3dPZmZzZXQgPCBlbmQ7IHgrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJlc3RNYXRjaCA9IFVQQ0VSZWFkZXIuZGVjb2RlRGlnaXQoXG4gICAgICAgICAgICAgICAgICAgIHJvdywgY291bnRlcnMsIHJvd09mZnNldCwgVVBDRVJlYWRlci5MX0FORF9HX1BBVFRFUk5TKTtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoJzAnLmNoYXJDb2RlQXQoMCkgKyAoYmVzdE1hdGNoICUgMTApKSk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgY291bnRlciBvZiBjb3VudGVycykge1xuICAgICAgICAgICAgICAgICAgICByb3dPZmZzZXQgKz0gY291bnRlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGJlc3RNYXRjaCA+PSAxMCkge1xuICAgICAgICAgICAgICAgICAgICBsZ1BhdHRlcm5Gb3VuZCB8PSAoMSA8PCAoNSAtIHgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcmVzdWx0U3RyaW5nID0gVVBDRVJlYWRlci5kZXRlcm1pbmVOdW1TeXNBbmRDaGVja0RpZ2l0KFxuICAgICAgICAgICAgICAgIHJlc3VsdCwgbGdQYXR0ZXJuRm91bmQpO1xuICAgICAgICAgICAgcmV0dXJuIHtyb3dPZmZzZXQsIHJlc3VsdFN0cmluZ307XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0aHJvd3MgTm90Rm91bmRFeGNlcHRpb25cbiAgICAgICAgICovXG4gICAgICAgIC8vIEBPdmVycmlkZVxuICAgICAgICBkZWNvZGVFbmQocm93LCBlbmRTdGFydCkge1xuICAgICAgICAgICAgcmV0dXJuIFVQQ0VSZWFkZXIuZmluZEd1YXJkUGF0dGVybldpdGhvdXRDb3VudGVycyhcbiAgICAgICAgICAgICAgICByb3csIGVuZFN0YXJ0LCB0cnVlLCBVUENFUmVhZGVyLk1JRERMRV9FTkRfUEFUVEVSTik7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0aHJvd3MgRm9ybWF0RXhjZXB0aW9uXG4gICAgICAgICAqL1xuICAgICAgICAvLyBAT3ZlcnJpZGVcbiAgICAgICAgY2hlY2tDaGVja3N1bShzKSB7XG4gICAgICAgICAgICByZXR1cm4gVVBDRUFOUmVhZGVyLmNoZWNrQ2hlY2tzdW0oVVBDRVJlYWRlci5jb252ZXJ0VVBDRXRvVVBDQShzKSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0aHJvd3MgTm90Rm91bmRFeGNlcHRpb25cbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBkZXRlcm1pbmVOdW1TeXNBbmRDaGVja0RpZ2l0KHJlc3VsdFN0cmluZywgbGdQYXR0ZXJuRm91bmQpIHtcbiAgICAgICAgICAgIGZvciAobGV0IG51bVN5cyA9IDA7IG51bVN5cyA8PSAxOyBudW1TeXMrKykge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGQgPSAwOyBkIDwgMTA7IGQrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAobGdQYXR0ZXJuRm91bmQgPT09IHRoaXMuTlVNU1lTX0FORF9DSEVDS19ESUdJVF9QQVRURVJOU1tudW1TeXNdW2RdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcHJlZml4ID0gU3RyaW5nLmZyb21DaGFyQ29kZSgnMCcuY2hhckNvZGVBdCgwKSArIG51bVN5cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgc3VmZml4ID0gU3RyaW5nLmZyb21DaGFyQ29kZSgnMCcuY2hhckNvZGVBdCgwKSArIGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByZWZpeCArIHJlc3VsdFN0cmluZyArIHN1ZmZpeDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IE5vdEZvdW5kRXhjZXB0aW9uLmdldE5vdEZvdW5kSW5zdGFuY2UoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBAT3ZlcnJpZGVcbiAgICAgICAgZ2V0QmFyY29kZUZvcm1hdCgpIHtcbiAgICAgICAgICAgIHJldHVybiBCYXJjb2RlRm9ybWF0JDEuVVBDX0U7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEV4cGFuZHMgYSBVUEMtRSB2YWx1ZSBiYWNrIGludG8gaXRzIGZ1bGwsIGVxdWl2YWxlbnQgVVBDLUEgY29kZSB2YWx1ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHVwY2UgVVBDLUUgY29kZSBhcyBzdHJpbmcgb2YgZGlnaXRzXG4gICAgICAgICAqIEByZXR1cm4gZXF1aXZhbGVudCBVUEMtQSBjb2RlIGFzIHN0cmluZyBvZiBkaWdpdHNcbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBjb252ZXJ0VVBDRXRvVVBDQSh1cGNlKSB7XG4gICAgICAgICAgICAvLyB0aGUgZm9sbG93aW5nIGxpbmUgaXMgZXF1aXZhbGVudCB0byB1cGNlLmdldENoYXJzKDEsIDcsIHVwY2VDaGFycywgMCk7XG4gICAgICAgICAgICBjb25zdCB1cGNlQ2hhcnMgPSB1cGNlLnNsaWNlKDEsIDcpLnNwbGl0KCcnKS5tYXAoeCA9PiB4LmNoYXJDb2RlQXQoMCkpO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IFN0cmluZ0J1aWxkZXIoIC8qMTIqLyk7XG4gICAgICAgICAgICByZXN1bHQuYXBwZW5kKHVwY2UuY2hhckF0KDApKTtcbiAgICAgICAgICAgIGxldCBsYXN0Q2hhciA9IHVwY2VDaGFyc1s1XTtcbiAgICAgICAgICAgIHN3aXRjaCAobGFzdENoYXIpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZENoYXJzKHVwY2VDaGFycywgMCwgMik7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQobGFzdENoYXIpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKCcwMDAwJyk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmRDaGFycyh1cGNlQ2hhcnMsIDIsIDMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmRDaGFycyh1cGNlQ2hhcnMsIDAsIDMpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKCcwMDAwMCcpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kQ2hhcnModXBjZUNoYXJzLCAzLCAyKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kQ2hhcnModXBjZUNoYXJzLCAwLCA0KTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZCgnMDAwMDAnKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZCh1cGNlQ2hhcnNbNF0pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kQ2hhcnModXBjZUNoYXJzLCAwLCA1KTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZCgnMDAwMCcpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKGxhc3RDaGFyKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBPbmx5IGFwcGVuZCBjaGVjayBkaWdpdCBpbiBjb252ZXJzaW9uIGlmIHN1cHBsaWVkXG4gICAgICAgICAgICBpZiAodXBjZS5sZW5ndGggPj0gOCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQodXBjZS5jaGFyQXQoNykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBwYXR0ZXJuIHRoYXQgbWFya3MgdGhlIG1pZGRsZSwgYW5kIGVuZCwgb2YgYSBVUEMtRSBwYXR0ZXJuLlxuICAgICAqIFRoZXJlIGlzIG5vIFwic2Vjb25kIGhhbGZcIiB0byBhIFVQQy1FIGJhcmNvZGUuXG4gICAgICovXG4gICAgVVBDRVJlYWRlci5NSURETEVfRU5EX1BBVFRFUk4gPSBJbnQzMkFycmF5LmZyb20oWzEsIDEsIDEsIDEsIDEsIDFdKTtcbiAgICAvLyBGb3IgYW4gVVBDLUUgYmFyY29kZSwgdGhlIGZpbmFsIGRpZ2l0IGlzIHJlcHJlc2VudGVkIGJ5IHRoZSBwYXJpdGllcyB1c2VkXG4gICAgLy8gdG8gZW5jb2RlIHRoZSBtaWRkbGUgc2l4IGRpZ2l0cywgYWNjb3JkaW5nIHRvIHRoZSB0YWJsZSBiZWxvdy5cbiAgICAvL1xuICAgIC8vICAgICAgICAgICAgICAgIFBhcml0eSBvZiBuZXh0IDYgZGlnaXRzXG4gICAgLy8gICAgRGlnaXQgICAwICAgICAxICAgICAyICAgICAzICAgICA0ICAgICA1XG4gICAgLy8gICAgICAgMCAgICBFdmVuICAgRXZlbiAgRXZlbiBPZGQgIE9kZCAgIE9kZFxuICAgIC8vICAgICAgIDEgICAgRXZlbiAgIEV2ZW4gIE9kZCAgRXZlbiBPZGQgICBPZGRcbiAgICAvLyAgICAgICAyICAgIEV2ZW4gICBFdmVuICBPZGQgIE9kZCAgRXZlbiAgT2RkXG4gICAgLy8gICAgICAgMyAgICBFdmVuICAgRXZlbiAgT2RkICBPZGQgIE9kZCAgIEV2ZW5cbiAgICAvLyAgICAgICA0ICAgIEV2ZW4gICBPZGQgICBFdmVuIEV2ZW4gT2RkICAgT2RkXG4gICAgLy8gICAgICAgNSAgICBFdmVuICAgT2RkICAgT2RkICBFdmVuIEV2ZW4gIE9kZFxuICAgIC8vICAgICAgIDYgICAgRXZlbiAgIE9kZCAgIE9kZCAgT2RkICBFdmVuICBFdmVuXG4gICAgLy8gICAgICAgNyAgICBFdmVuICAgT2RkICAgRXZlbiBPZGQgIEV2ZW4gIE9kZFxuICAgIC8vICAgICAgIDggICAgRXZlbiAgIE9kZCAgIEV2ZW4gT2RkICBPZGQgICBFdmVuXG4gICAgLy8gICAgICAgOSAgICBFdmVuICAgT2RkICAgT2RkICBFdmVuIE9kZCAgIEV2ZW5cbiAgICAvL1xuICAgIC8vIFRoZSBlbmNvZGluZyBpcyByZXByZXNlbnRlZCBieSB0aGUgZm9sbG93aW5nIGFycmF5LCB3aGljaCBpcyBhIGJpdCBwYXR0ZXJuXG4gICAgLy8gdXNpbmcgT2RkID0gMCBhbmQgRXZlbiA9IDEuIEZvciBleGFtcGxlLCA1IGlzIHJlcHJlc2VudGVkIGJ5OlxuICAgIC8vXG4gICAgLy8gICAgICAgICAgICAgIE9kZCBFdmVuIEV2ZW4gT2RkIE9kZCBFdmVuXG4gICAgLy8gaW4gYmluYXJ5OlxuICAgIC8vICAgICAgICAgICAgICAgIDAgICAgMSAgICAxICAgMCAgIDAgICAgMSAgID09IDB4MTlcbiAgICAvL1xuICAgIC8qKlxuICAgICAqIFNlZSB7QGxpbmsgI0xfQU5EX0dfUEFUVEVSTlN9OyB0aGVzZSB2YWx1ZXMgc2ltaWxhcmx5IHJlcHJlc2VudCBwYXR0ZXJucyBvZlxuICAgICAqIGV2ZW4tb2RkIHBhcml0eSBlbmNvZGluZ3Mgb2YgZGlnaXRzIHRoYXQgaW1wbHkgYm90aCB0aGUgbnVtYmVyIHN5c3RlbSAoMCBvciAxKVxuICAgICAqIHVzZWQsIGFuZCB0aGUgY2hlY2sgZGlnaXQuXG4gICAgICovXG4gICAgVVBDRVJlYWRlci5OVU1TWVNfQU5EX0NIRUNLX0RJR0lUX1BBVFRFUk5TID0gW1xuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzB4MzgsIDB4MzQsIDB4MzIsIDB4MzEsIDB4MkMsIDB4MjYsIDB4MjMsIDB4MkEsIDB4MjksIDB4MjVdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsweDA3LCAweDBCLCAweDBELCAweDBFLCAweDEzLCAweDE5LCAweDFDLCAweDE1LCAweDE2LCAweDFBXSksXG4gICAgXTtcblxuICAgIC8qKlxuICAgICAqIDxwPkEgcmVhZGVyIHRoYXQgY2FuIHJlYWQgYWxsIGF2YWlsYWJsZSBVUEMvRUFOIGZvcm1hdHMuIElmIGEgY2FsbGVyIHdhbnRzIHRvIHRyeSB0b1xuICAgICAqIHJlYWQgYWxsIHN1Y2ggZm9ybWF0cywgaXQgaXMgbW9zdCBlZmZpY2llbnQgdG8gdXNlIHRoaXMgaW1wbGVtZW50YXRpb24gcmF0aGVyIHRoYW4gaW52b2tlXG4gICAgICogaW5kaXZpZHVhbCByZWFkZXJzLjwvcD5cbiAgICAgKlxuICAgICAqIEBhdXRob3IgU2VhbiBPd2VuXG4gICAgICovXG4gICAgY2xhc3MgTXVsdGlGb3JtYXRVUENFQU5SZWFkZXIgZXh0ZW5kcyBPbmVEUmVhZGVyIHtcbiAgICAgICAgY29uc3RydWN0b3IoaGludHMpIHtcbiAgICAgICAgICAgIHN1cGVyKCk7XG4gICAgICAgICAgICBsZXQgcG9zc2libGVGb3JtYXRzID0gaGludHMgPT0gbnVsbCA/IG51bGwgOiBoaW50cy5nZXQoRGVjb2RlSGludFR5cGUkMS5QT1NTSUJMRV9GT1JNQVRTKTtcbiAgICAgICAgICAgIGxldCByZWFkZXJzID0gW107XG4gICAgICAgICAgICBpZiAoIWlzTnVsbE9yVW5kZWZpbmVkKHBvc3NpYmxlRm9ybWF0cykpIHtcbiAgICAgICAgICAgICAgICBpZiAocG9zc2libGVGb3JtYXRzLmluZGV4T2YoQmFyY29kZUZvcm1hdCQxLkVBTl8xMykgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZWFkZXJzLnB1c2gobmV3IEVBTjEzUmVhZGVyKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocG9zc2libGVGb3JtYXRzLmluZGV4T2YoQmFyY29kZUZvcm1hdCQxLlVQQ19BKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlcnMucHVzaChuZXcgVVBDQVJlYWRlcigpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHBvc3NpYmxlRm9ybWF0cy5pbmRleE9mKEJhcmNvZGVGb3JtYXQkMS5FQU5fOCkgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZWFkZXJzLnB1c2gobmV3IEVBTjhSZWFkZXIoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwb3NzaWJsZUZvcm1hdHMuaW5kZXhPZihCYXJjb2RlRm9ybWF0JDEuVVBDX0UpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVycy5wdXNoKG5ldyBVUENFUmVhZGVyKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gTm8gaGludHMgcHJvdmlkZWQuXG4gICAgICAgICAgICAgICAgcmVhZGVycy5wdXNoKG5ldyBFQU4xM1JlYWRlcigpKTtcbiAgICAgICAgICAgICAgICByZWFkZXJzLnB1c2gobmV3IFVQQ0FSZWFkZXIoKSk7XG4gICAgICAgICAgICAgICAgcmVhZGVycy5wdXNoKG5ldyBFQU44UmVhZGVyKCkpO1xuICAgICAgICAgICAgICAgIHJlYWRlcnMucHVzaChuZXcgVVBDRVJlYWRlcigpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmVhZGVycyA9IHJlYWRlcnM7XG4gICAgICAgIH1cbiAgICAgICAgZGVjb2RlUm93KHJvd051bWJlciwgcm93LCBoaW50cykge1xuICAgICAgICAgICAgZm9yIChsZXQgcmVhZGVyIG9mIHRoaXMucmVhZGVycykge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnN0IHJlc3VsdDogUmVzdWx0ID0gcmVhZGVyLmRlY29kZVJvdyhyb3dOdW1iZXIsIHJvdywgc3RhcnRHdWFyZFBhdHRlcm4sIGhpbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gcmVhZGVyLmRlY29kZVJvdyhyb3dOdW1iZXIsIHJvdywgaGludHMpO1xuICAgICAgICAgICAgICAgICAgICAvLyBTcGVjaWFsIGNhc2U6IGEgMTItZGlnaXQgY29kZSBlbmNvZGVkIGluIFVQQy1BIGlzIGlkZW50aWNhbCB0byBhIFwiMFwiXG4gICAgICAgICAgICAgICAgICAgIC8vIGZvbGxvd2VkIGJ5IHRob3NlIDEyIGRpZ2l0cyBlbmNvZGVkIGFzIEVBTi0xMy4gRWFjaCB3aWxsIHJlY29nbml6ZSBzdWNoIGEgY29kZSxcbiAgICAgICAgICAgICAgICAgICAgLy8gVVBDLUEgYXMgYSAxMi1kaWdpdCBzdHJpbmcgYW5kIEVBTi0xMyBhcyBhIDEzLWRpZ2l0IHN0cmluZyBzdGFydGluZyB3aXRoIFwiMFwiLlxuICAgICAgICAgICAgICAgICAgICAvLyBJbmRpdmlkdWFsbHkgdGhlc2UgYXJlIGNvcnJlY3QgYW5kIHRoZWlyIHJlYWRlcnMgd2lsbCBib3RoIHJlYWQgc3VjaCBhIGNvZGVcbiAgICAgICAgICAgICAgICAgICAgLy8gYW5kIGNvcnJlY3RseSBjYWxsIGl0IEVBTi0xMywgb3IgVVBDLUEsIHJlc3BlY3RpdmVseS5cbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgLy8gSW4gdGhpcyBjYXNlLCBpZiB3ZSd2ZSBiZWVuIGxvb2tpbmcgZm9yIGJvdGggdHlwZXMsIHdlJ2QgbGlrZSB0byBjYWxsIGl0XG4gICAgICAgICAgICAgICAgICAgIC8vIGEgVVBDLUEgY29kZS4gQnV0IGZvciBlZmZpY2llbmN5IHdlIG9ubHkgcnVuIHRoZSBFQU4tMTMgZGVjb2RlciB0byBhbHNvIHJlYWRcbiAgICAgICAgICAgICAgICAgICAgLy8gVVBDLUEuIFNvIHdlIHNwZWNpYWwgY2FzZSBpdCBoZXJlLCBhbmQgY29udmVydCBhbiBFQU4tMTMgcmVzdWx0IHRvIGEgVVBDLUFcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVzdWx0IGlmIGFwcHJvcHJpYXRlLlxuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAvLyBCdXQsIGRvbid0IHJldHVybiBVUEMtQSBpZiBVUEMtQSB3YXMgbm90IGEgcmVxdWVzdGVkIGZvcm1hdCFcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZWFuMTNNYXlCZVVQQ0EgPSByZXN1bHQuZ2V0QmFyY29kZUZvcm1hdCgpID09PSBCYXJjb2RlRm9ybWF0JDEuRUFOXzEzICYmXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuZ2V0VGV4dCgpLmNoYXJBdCgwKSA9PT0gJzAnO1xuICAgICAgICAgICAgICAgICAgICAvLyBAU3VwcHJlc3NXYXJuaW5ncyhcInVuY2hlY2tlZFwiKVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwb3NzaWJsZUZvcm1hdHMgPSBoaW50cyA9PSBudWxsID8gbnVsbCA6IGhpbnRzLmdldChEZWNvZGVIaW50VHlwZSQxLlBPU1NJQkxFX0ZPUk1BVFMpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjYW5SZXR1cm5VUENBID0gcG9zc2libGVGb3JtYXRzID09IG51bGwgfHwgcG9zc2libGVGb3JtYXRzLmluY2x1ZGVzKEJhcmNvZGVGb3JtYXQkMS5VUENfQSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlYW4xM01heUJlVVBDQSAmJiBjYW5SZXR1cm5VUENBKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByYXdCeXRlcyA9IHJlc3VsdC5nZXRSYXdCeXRlcygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVHJhbnNmZXIgdGhlIG1ldGFkYXRhIGFjcm9zc1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0VVBDQSA9IG5ldyBSZXN1bHQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmdldFRleHQoKS5zdWJzdHJpbmcoMSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmF3Qnl0ZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHJhd0J5dGVzID8gcmF3Qnl0ZXMubGVuZ3RoIDogbnVsbCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmdldFJlc3VsdFBvaW50cygpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEJhcmNvZGVGb3JtYXQkMS5VUENfQSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRVUENBLnB1dEFsbE1ldGFkYXRhKHJlc3VsdC5nZXRSZXN1bHRNZXRhZGF0YSgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRVUENBO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzZXQoKSB7XG4gICAgICAgICAgICBmb3IgKGxldCByZWFkZXIgb2YgdGhpcy5yZWFkZXJzKSB7XG4gICAgICAgICAgICAgICAgcmVhZGVyLnJlc2V0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBpbXBvcnQgSW50ZWdlciBmcm9tICcuLi8uLi91dGlsL0ludGVnZXInO1xuICAgIC8vIGltcG9ydCBGbG9hdCBmcm9tICcuLi8uLi91dGlsL0Zsb2F0JztcbiAgICBjbGFzcyBBYnN0cmFjdFJTU1JlYWRlciBleHRlbmRzIE9uZURSZWFkZXIge1xuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgICAgIHN1cGVyKCk7XG4gICAgICAgICAgICB0aGlzLmRlY29kZUZpbmRlckNvdW50ZXJzID0gbmV3IEludDMyQXJyYXkoNCk7XG4gICAgICAgICAgICB0aGlzLmRhdGFDaGFyYWN0ZXJDb3VudGVycyA9IG5ldyBJbnQzMkFycmF5KDgpO1xuICAgICAgICAgICAgdGhpcy5vZGRSb3VuZGluZ0Vycm9ycyA9IG5ldyBBcnJheSg0KTtcbiAgICAgICAgICAgIHRoaXMuZXZlblJvdW5kaW5nRXJyb3JzID0gbmV3IEFycmF5KDQpO1xuICAgICAgICAgICAgdGhpcy5vZGRDb3VudHMgPSBuZXcgQXJyYXkodGhpcy5kYXRhQ2hhcmFjdGVyQ291bnRlcnMubGVuZ3RoIC8gMik7XG4gICAgICAgICAgICB0aGlzLmV2ZW5Db3VudHMgPSBuZXcgQXJyYXkodGhpcy5kYXRhQ2hhcmFjdGVyQ291bnRlcnMubGVuZ3RoIC8gMik7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0RGVjb2RlRmluZGVyQ291bnRlcnMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGVGaW5kZXJDb3VudGVycztcbiAgICAgICAgfVxuICAgICAgICBnZXREYXRhQ2hhcmFjdGVyQ291bnRlcnMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhQ2hhcmFjdGVyQ291bnRlcnM7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0T2RkUm91bmRpbmdFcnJvcnMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vZGRSb3VuZGluZ0Vycm9ycztcbiAgICAgICAgfVxuICAgICAgICBnZXRFdmVuUm91bmRpbmdFcnJvcnMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ldmVuUm91bmRpbmdFcnJvcnM7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0T2RkQ291bnRzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub2RkQ291bnRzO1xuICAgICAgICB9XG4gICAgICAgIGdldEV2ZW5Db3VudHMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ldmVuQ291bnRzO1xuICAgICAgICB9XG4gICAgICAgIHBhcnNlRmluZGVyVmFsdWUoY291bnRlcnMsIGZpbmRlclBhdHRlcm5zKSB7XG4gICAgICAgICAgICBmb3IgKGxldCB2YWx1ZSA9IDA7IHZhbHVlIDwgZmluZGVyUGF0dGVybnMubGVuZ3RoOyB2YWx1ZSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKE9uZURSZWFkZXIucGF0dGVybk1hdGNoVmFyaWFuY2UoY291bnRlcnMsIGZpbmRlclBhdHRlcm5zW3ZhbHVlXSwgQWJzdHJhY3RSU1NSZWFkZXIuTUFYX0lORElWSURVQUxfVkFSSUFOQ0UpIDwgQWJzdHJhY3RSU1NSZWFkZXIuTUFYX0FWR19WQVJJQU5DRSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSBhcnJheSB2YWx1ZXMgdG8gc3VtXG4gICAgICAgICAqIEByZXR1cm4gc3VtIG9mIHZhbHVlc1xuICAgICAgICAgKiBAZGVwcmVjYXRlZCBjYWxsIHtAbGluayBNYXRoVXRpbHMjc3VtKGludFtdKX1cbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBjb3VudChhcnJheSkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGhVdGlscy5zdW0obmV3IEludDMyQXJyYXkoYXJyYXkpKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgaW5jcmVtZW50KGFycmF5LCBlcnJvcnMpIHtcbiAgICAgICAgICAgIGxldCBpbmRleCA9IDA7XG4gICAgICAgICAgICBsZXQgYmlnZ2VzdEVycm9yID0gZXJyb3JzWzBdO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChlcnJvcnNbaV0gPiBiaWdnZXN0RXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgYmlnZ2VzdEVycm9yID0gZXJyb3JzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXJyYXlbaW5kZXhdKys7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGRlY3JlbWVudChhcnJheSwgZXJyb3JzKSB7XG4gICAgICAgICAgICBsZXQgaW5kZXggPSAwO1xuICAgICAgICAgICAgbGV0IGJpZ2dlc3RFcnJvciA9IGVycm9yc1swXTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3JzW2ldIDwgYmlnZ2VzdEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGJpZ2dlc3RFcnJvciA9IGVycm9yc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFycmF5W2luZGV4XS0tO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBpc0ZpbmRlclBhdHRlcm4oY291bnRlcnMpIHtcbiAgICAgICAgICAgIGxldCBmaXJzdFR3b1N1bSA9IGNvdW50ZXJzWzBdICsgY291bnRlcnNbMV07XG4gICAgICAgICAgICBsZXQgc3VtID0gZmlyc3RUd29TdW0gKyBjb3VudGVyc1syXSArIGNvdW50ZXJzWzNdO1xuICAgICAgICAgICAgbGV0IHJhdGlvID0gZmlyc3RUd29TdW0gLyBzdW07XG4gICAgICAgICAgICBpZiAocmF0aW8gPj0gQWJzdHJhY3RSU1NSZWFkZXIuTUlOX0ZJTkRFUl9QQVRURVJOX1JBVElPICYmIHJhdGlvIDw9IEFic3RyYWN0UlNTUmVhZGVyLk1BWF9GSU5ERVJfUEFUVEVSTl9SQVRJTykge1xuICAgICAgICAgICAgICAgIC8vIHBhc3NlcyByYXRpbyB0ZXN0IGluIHNwZWMsIGJ1dCBzZWUgaWYgdGhlIGNvdW50cyBhcmUgdW5yZWFzb25hYmxlXG4gICAgICAgICAgICAgICAgbGV0IG1pbkNvdW50ZXIgPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcbiAgICAgICAgICAgICAgICBsZXQgbWF4Q291bnRlciA9IE51bWJlci5NSU5fU0FGRV9JTlRFR0VSO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGNvdW50ZXIgb2YgY291bnRlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvdW50ZXIgPiBtYXhDb3VudGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhDb3VudGVyID0gY291bnRlcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoY291bnRlciA8IG1pbkNvdW50ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbkNvdW50ZXIgPSBjb3VudGVyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBtYXhDb3VudGVyIDwgMTAgKiBtaW5Db3VudGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIEFic3RyYWN0UlNTUmVhZGVyLk1BWF9BVkdfVkFSSUFOQ0UgPSAwLjI7XG4gICAgQWJzdHJhY3RSU1NSZWFkZXIuTUFYX0lORElWSURVQUxfVkFSSUFOQ0UgPSAwLjQ1O1xuICAgIEFic3RyYWN0UlNTUmVhZGVyLk1JTl9GSU5ERVJfUEFUVEVSTl9SQVRJTyA9IDkuNSAvIDEyLjA7XG4gICAgQWJzdHJhY3RSU1NSZWFkZXIuTUFYX0ZJTkRFUl9QQVRURVJOX1JBVElPID0gMTIuNSAvIDE0LjA7XG5cbiAgICBjbGFzcyBEYXRhQ2hhcmFjdGVyIHtcbiAgICAgICAgY29uc3RydWN0b3IodmFsdWUsIGNoZWNrc3VtUG9ydGlvbikge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5jaGVja3N1bVBvcnRpb24gPSBjaGVja3N1bVBvcnRpb247XG4gICAgICAgIH1cbiAgICAgICAgZ2V0VmFsdWUoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBnZXRDaGVja3N1bVBvcnRpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jaGVja3N1bVBvcnRpb247XG4gICAgICAgIH1cbiAgICAgICAgdG9TdHJpbmcoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZSArICcoJyArIHRoaXMuY2hlY2tzdW1Qb3J0aW9uICsgJyknO1xuICAgICAgICB9XG4gICAgICAgIGVxdWFscyhvKSB7XG4gICAgICAgICAgICBpZiAoIShvIGluc3RhbmNlb2YgRGF0YUNoYXJhY3RlcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0aGF0ID0gbztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlID09PSB0aGF0LnZhbHVlICYmIHRoaXMuY2hlY2tzdW1Qb3J0aW9uID09PSB0aGF0LmNoZWNrc3VtUG9ydGlvbjtcbiAgICAgICAgfVxuICAgICAgICBoYXNoQ29kZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlIF4gdGhpcy5jaGVja3N1bVBvcnRpb247XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjbGFzcyBGaW5kZXJQYXR0ZXJuIHtcbiAgICAgICAgY29uc3RydWN0b3IodmFsdWUsIHN0YXJ0RW5kLCBzdGFydCwgZW5kLCByb3dOdW1iZXIpIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRFbmQgPSBzdGFydEVuZDtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRFbmQgPSBzdGFydEVuZDtcbiAgICAgICAgICAgIHRoaXMucmVzdWx0UG9pbnRzID0gbmV3IEFycmF5KCk7XG4gICAgICAgICAgICB0aGlzLnJlc3VsdFBvaW50cy5wdXNoKG5ldyBSZXN1bHRQb2ludChzdGFydCwgcm93TnVtYmVyKSk7XG4gICAgICAgICAgICB0aGlzLnJlc3VsdFBvaW50cy5wdXNoKG5ldyBSZXN1bHRQb2ludChlbmQsIHJvd051bWJlcikpO1xuICAgICAgICB9XG4gICAgICAgIGdldFZhbHVlKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0U3RhcnRFbmQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdGFydEVuZDtcbiAgICAgICAgfVxuICAgICAgICBnZXRSZXN1bHRQb2ludHMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHRQb2ludHM7XG4gICAgICAgIH1cbiAgICAgICAgZXF1YWxzKG8pIHtcbiAgICAgICAgICAgIGlmICghKG8gaW5zdGFuY2VvZiBGaW5kZXJQYXR0ZXJuKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHRoYXQgPSBvO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUgPT09IHRoYXQudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaGFzaENvZGUoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJTUyB1dGlsIGZ1bmN0aW9ucy5cbiAgICAgKi9cbiAgICBjbGFzcyBSU1NVdGlscyB7XG4gICAgICAgIGNvbnN0cnVjdG9yKCkgeyB9XG4gICAgICAgIHN0YXRpYyBnZXRSU1N2YWx1ZSh3aWR0aHMsIG1heFdpZHRoLCBub05hcnJvdykge1xuICAgICAgICAgICAgbGV0IG4gPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgd2lkdGggb2Ygd2lkdGhzKSB7XG4gICAgICAgICAgICAgICAgbiArPSB3aWR0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCB2YWwgPSAwO1xuICAgICAgICAgICAgbGV0IG5hcnJvd01hc2sgPSAwO1xuICAgICAgICAgICAgbGV0IGVsZW1lbnRzID0gd2lkdGhzLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAobGV0IGJhciA9IDA7IGJhciA8IGVsZW1lbnRzIC0gMTsgYmFyKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgZWxtV2lkdGg7XG4gICAgICAgICAgICAgICAgZm9yIChlbG1XaWR0aCA9IDEsIG5hcnJvd01hc2sgfD0gMSA8PCBiYXI7IGVsbVdpZHRoIDwgd2lkdGhzW2Jhcl07IGVsbVdpZHRoKyssIG5hcnJvd01hc2sgJj0gfigxIDw8IGJhcikpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHN1YlZhbCA9IFJTU1V0aWxzLmNvbWJpbnMobiAtIGVsbVdpZHRoIC0gMSwgZWxlbWVudHMgLSBiYXIgLSAyKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vTmFycm93ICYmIChuYXJyb3dNYXNrID09PSAwKSAmJiAobiAtIGVsbVdpZHRoIC0gKGVsZW1lbnRzIC0gYmFyIC0gMSkgPj0gZWxlbWVudHMgLSBiYXIgLSAxKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3ViVmFsIC09IFJTU1V0aWxzLmNvbWJpbnMobiAtIGVsbVdpZHRoIC0gKGVsZW1lbnRzIC0gYmFyKSwgZWxlbWVudHMgLSBiYXIgLSAyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudHMgLSBiYXIgLSAxID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGxlc3NWYWwgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgbXh3RWxlbWVudCA9IG4gLSBlbG1XaWR0aCAtIChlbGVtZW50cyAtIGJhciAtIDIpOyBteHdFbGVtZW50ID4gbWF4V2lkdGg7IG14d0VsZW1lbnQtLSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlc3NWYWwgKz0gUlNTVXRpbHMuY29tYmlucyhuIC0gZWxtV2lkdGggLSBteHdFbGVtZW50IC0gMSwgZWxlbWVudHMgLSBiYXIgLSAzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YlZhbCAtPSBsZXNzVmFsICogKGVsZW1lbnRzIC0gMSAtIGJhcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobiAtIGVsbVdpZHRoID4gbWF4V2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YlZhbC0tO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhbCArPSBzdWJWYWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG4gLT0gZWxtV2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBjb21iaW5zKG4sIHIpIHtcbiAgICAgICAgICAgIGxldCBtYXhEZW5vbTtcbiAgICAgICAgICAgIGxldCBtaW5EZW5vbTtcbiAgICAgICAgICAgIGlmIChuIC0gciA+IHIpIHtcbiAgICAgICAgICAgICAgICBtaW5EZW5vbSA9IHI7XG4gICAgICAgICAgICAgICAgbWF4RGVub20gPSBuIC0gcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1pbkRlbm9tID0gbiAtIHI7XG4gICAgICAgICAgICAgICAgbWF4RGVub20gPSByO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHZhbCA9IDE7XG4gICAgICAgICAgICBsZXQgaiA9IDE7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gbjsgaSA+IG1heERlbm9tOyBpLS0pIHtcbiAgICAgICAgICAgICAgICB2YWwgKj0gaTtcbiAgICAgICAgICAgICAgICBpZiAoaiA8PSBtaW5EZW5vbSkge1xuICAgICAgICAgICAgICAgICAgICB2YWwgLz0gajtcbiAgICAgICAgICAgICAgICAgICAgaisrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlICgoaiA8PSBtaW5EZW5vbSkpIHtcbiAgICAgICAgICAgICAgICB2YWwgLz0gajtcbiAgICAgICAgICAgICAgICBqKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY2xhc3MgQml0QXJyYXlCdWlsZGVyIHtcbiAgICAgICAgc3RhdGljIGJ1aWxkQml0QXJyYXkocGFpcnMpIHtcbiAgICAgICAgICAgIGxldCBjaGFyTnVtYmVyID0gKHBhaXJzLmxlbmd0aCAqIDIpIC0gMTtcbiAgICAgICAgICAgIGlmIChwYWlyc1twYWlycy5sZW5ndGggLSAxXS5nZXRSaWdodENoYXIoKSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY2hhck51bWJlciAtPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHNpemUgPSAxMiAqIGNoYXJOdW1iZXI7XG4gICAgICAgICAgICBsZXQgYmluYXJ5ID0gbmV3IEJpdEFycmF5KHNpemUpO1xuICAgICAgICAgICAgbGV0IGFjY1BvcyA9IDA7XG4gICAgICAgICAgICBsZXQgZmlyc3RQYWlyID0gcGFpcnNbMF07XG4gICAgICAgICAgICBsZXQgZmlyc3RWYWx1ZSA9IGZpcnN0UGFpci5nZXRSaWdodENoYXIoKS5nZXRWYWx1ZSgpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDExOyBpID49IDA7IC0taSkge1xuICAgICAgICAgICAgICAgIGlmICgoZmlyc3RWYWx1ZSAmICgxIDw8IGkpKSAhPSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGJpbmFyeS5zZXQoYWNjUG9zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYWNjUG9zKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHBhaXJzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgbGV0IGN1cnJlbnRQYWlyID0gcGFpcnNbaV07XG4gICAgICAgICAgICAgICAgbGV0IGxlZnRWYWx1ZSA9IGN1cnJlbnRQYWlyLmdldExlZnRDaGFyKCkuZ2V0VmFsdWUoKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMTE7IGogPj0gMDsgLS1qKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgobGVmdFZhbHVlICYgKDEgPDwgaikpICE9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJpbmFyeS5zZXQoYWNjUG9zKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBhY2NQb3MrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRQYWlyLmdldFJpZ2h0Q2hhcigpICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJpZ2h0VmFsdWUgPSBjdXJyZW50UGFpci5nZXRSaWdodENoYXIoKS5nZXRWYWx1ZSgpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMTE7IGogPj0gMDsgLS1qKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHJpZ2h0VmFsdWUgJiAoMSA8PCBqKSkgIT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJpbmFyeS5zZXQoYWNjUG9zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGFjY1BvcysrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGJpbmFyeTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNsYXNzIEJsb2NrUGFyc2VkUmVzdWx0IHtcbiAgICAgICAgY29uc3RydWN0b3IoZmluaXNoZWQsIGRlY29kZWRJbmZvcm1hdGlvbikge1xuICAgICAgICAgICAgaWYgKGRlY29kZWRJbmZvcm1hdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVjb2RlZEluZm9ybWF0aW9uID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZmluaXNoZWQgPSBmaW5pc2hlZDtcbiAgICAgICAgICAgICAgICB0aGlzLmRlY29kZWRJbmZvcm1hdGlvbiA9IGRlY29kZWRJbmZvcm1hdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBnZXREZWNvZGVkSW5mb3JtYXRpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGVkSW5mb3JtYXRpb247XG4gICAgICAgIH1cbiAgICAgICAgaXNGaW5pc2hlZCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbmlzaGVkO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY2xhc3MgRGVjb2RlZE9iamVjdCB7XG4gICAgICAgIGNvbnN0cnVjdG9yKG5ld1Bvc2l0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLm5ld1Bvc2l0aW9uID0gbmV3UG9zaXRpb247XG4gICAgICAgIH1cbiAgICAgICAgZ2V0TmV3UG9zaXRpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5uZXdQb3NpdGlvbjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNsYXNzIERlY29kZWRDaGFyIGV4dGVuZHMgRGVjb2RlZE9iamVjdCB7XG4gICAgICAgIGNvbnN0cnVjdG9yKG5ld1Bvc2l0aW9uLCB2YWx1ZSkge1xuICAgICAgICAgICAgc3VwZXIobmV3UG9zaXRpb24pO1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGdldFZhbHVlKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaXNGTkMxKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUgPT09IERlY29kZWRDaGFyLkZOQzE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgRGVjb2RlZENoYXIuRk5DMSA9ICckJztcblxuICAgIGNsYXNzIERlY29kZWRJbmZvcm1hdGlvbiBleHRlbmRzIERlY29kZWRPYmplY3Qge1xuICAgICAgICBjb25zdHJ1Y3RvcihuZXdQb3NpdGlvbiwgbmV3U3RyaW5nLCByZW1haW5pbmdWYWx1ZSkge1xuICAgICAgICAgICAgc3VwZXIobmV3UG9zaXRpb24pO1xuICAgICAgICAgICAgaWYgKHJlbWFpbmluZ1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1haW5pbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMucmVtYWluaW5nVmFsdWUgPSB0aGlzLnJlbWFpbmluZ1ZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1haW5pbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbWFpbmluZ1ZhbHVlID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubmV3U3RyaW5nID0gbmV3U3RyaW5nO1xuICAgICAgICB9XG4gICAgICAgIGdldE5ld1N0cmluZygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5ld1N0cmluZztcbiAgICAgICAgfVxuICAgICAgICBpc1JlbWFpbmluZygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbWFpbmluZztcbiAgICAgICAgfVxuICAgICAgICBnZXRSZW1haW5pbmdWYWx1ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbWFpbmluZ1ZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY2xhc3MgRGVjb2RlZE51bWVyaWMgZXh0ZW5kcyBEZWNvZGVkT2JqZWN0IHtcbiAgICAgICAgY29uc3RydWN0b3IobmV3UG9zaXRpb24sIGZpcnN0RGlnaXQsIHNlY29uZERpZ2l0KSB7XG4gICAgICAgICAgICBzdXBlcihuZXdQb3NpdGlvbik7XG4gICAgICAgICAgICBpZiAoZmlyc3REaWdpdCA8IDAgfHwgZmlyc3REaWdpdCA+IDEwIHx8IHNlY29uZERpZ2l0IDwgMCB8fCBzZWNvbmREaWdpdCA+IDEwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5maXJzdERpZ2l0ID0gZmlyc3REaWdpdDtcbiAgICAgICAgICAgIHRoaXMuc2Vjb25kRGlnaXQgPSBzZWNvbmREaWdpdDtcbiAgICAgICAgfVxuICAgICAgICBnZXRGaXJzdERpZ2l0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmlyc3REaWdpdDtcbiAgICAgICAgfVxuICAgICAgICBnZXRTZWNvbmREaWdpdCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNlY29uZERpZ2l0O1xuICAgICAgICB9XG4gICAgICAgIGdldFZhbHVlKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmlyc3REaWdpdCAqIDEwICsgdGhpcy5zZWNvbmREaWdpdDtcbiAgICAgICAgfVxuICAgICAgICBpc0ZpcnN0RGlnaXRGTkMxKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmlyc3REaWdpdCA9PT0gRGVjb2RlZE51bWVyaWMuRk5DMTtcbiAgICAgICAgfVxuICAgICAgICBpc1NlY29uZERpZ2l0Rk5DMSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNlY29uZERpZ2l0ID09PSBEZWNvZGVkTnVtZXJpYy5GTkMxO1xuICAgICAgICB9XG4gICAgICAgIGlzQW55Rk5DMSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpcnN0RGlnaXQgPT09IERlY29kZWROdW1lcmljLkZOQzEgfHwgdGhpcy5zZWNvbmREaWdpdCA9PT0gRGVjb2RlZE51bWVyaWMuRk5DMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBEZWNvZGVkTnVtZXJpYy5GTkMxID0gMTA7XG5cbiAgICBjbGFzcyBGaWVsZFBhcnNlciB7XG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBwYXJzZUZpZWxkc0luR2VuZXJhbFB1cnBvc2UocmF3SW5mb3JtYXRpb24pIHtcbiAgICAgICAgICAgIGlmICghcmF3SW5mb3JtYXRpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFByb2Nlc3NpbmcgMi1kaWdpdCBBSXNcbiAgICAgICAgICAgIGlmIChyYXdJbmZvcm1hdGlvbi5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZmlyc3RUd29EaWdpdHMgPSByYXdJbmZvcm1hdGlvbi5zdWJzdHJpbmcoMCwgMik7XG4gICAgICAgICAgICBmb3IgKGxldCBkYXRhTGVuZ3RoIG9mIEZpZWxkUGFyc2VyLlRXT19ESUdJVF9EQVRBX0xFTkdUSCkge1xuICAgICAgICAgICAgICAgIGlmIChkYXRhTGVuZ3RoWzBdID09PSBmaXJzdFR3b0RpZ2l0cykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YUxlbmd0aFsxXSA9PT0gRmllbGRQYXJzZXIuVkFSSUFCTEVfTEVOR1RIKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gRmllbGRQYXJzZXIucHJvY2Vzc1ZhcmlhYmxlQUkoMiwgZGF0YUxlbmd0aFsyXSwgcmF3SW5mb3JtYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBGaWVsZFBhcnNlci5wcm9jZXNzRml4ZWRBSSgyLCBkYXRhTGVuZ3RoWzFdLCByYXdJbmZvcm1hdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJhd0luZm9ybWF0aW9uLmxlbmd0aCA8IDMpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBmaXJzdFRocmVlRGlnaXRzID0gcmF3SW5mb3JtYXRpb24uc3Vic3RyaW5nKDAsIDMpO1xuICAgICAgICAgICAgZm9yIChsZXQgZGF0YUxlbmd0aCBvZiBGaWVsZFBhcnNlci5USFJFRV9ESUdJVF9EQVRBX0xFTkdUSCkge1xuICAgICAgICAgICAgICAgIGlmIChkYXRhTGVuZ3RoWzBdID09PSBmaXJzdFRocmVlRGlnaXRzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhTGVuZ3RoWzFdID09PSBGaWVsZFBhcnNlci5WQVJJQUJMRV9MRU5HVEgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBGaWVsZFBhcnNlci5wcm9jZXNzVmFyaWFibGVBSSgzLCBkYXRhTGVuZ3RoWzJdLCByYXdJbmZvcm1hdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEZpZWxkUGFyc2VyLnByb2Nlc3NGaXhlZEFJKDMsIGRhdGFMZW5ndGhbMV0sIHJhd0luZm9ybWF0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBkYXRhTGVuZ3RoIG9mIEZpZWxkUGFyc2VyLlRIUkVFX0RJR0lUX1BMVVNfRElHSVRfREFUQV9MRU5HVEgpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGF0YUxlbmd0aFswXSA9PT0gZmlyc3RUaHJlZURpZ2l0cykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YUxlbmd0aFsxXSA9PT0gRmllbGRQYXJzZXIuVkFSSUFCTEVfTEVOR1RIKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gRmllbGRQYXJzZXIucHJvY2Vzc1ZhcmlhYmxlQUkoNCwgZGF0YUxlbmd0aFsyXSwgcmF3SW5mb3JtYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBGaWVsZFBhcnNlci5wcm9jZXNzRml4ZWRBSSg0LCBkYXRhTGVuZ3RoWzFdLCByYXdJbmZvcm1hdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJhd0luZm9ybWF0aW9uLmxlbmd0aCA8IDQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBmaXJzdEZvdXJEaWdpdHMgPSByYXdJbmZvcm1hdGlvbi5zdWJzdHJpbmcoMCwgNCk7XG4gICAgICAgICAgICBmb3IgKGxldCBkYXRhTGVuZ3RoIG9mIEZpZWxkUGFyc2VyLkZPVVJfRElHSVRfREFUQV9MRU5HVEgpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGF0YUxlbmd0aFswXSA9PT0gZmlyc3RGb3VyRGlnaXRzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhTGVuZ3RoWzFdID09PSBGaWVsZFBhcnNlci5WQVJJQUJMRV9MRU5HVEgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBGaWVsZFBhcnNlci5wcm9jZXNzVmFyaWFibGVBSSg0LCBkYXRhTGVuZ3RoWzJdLCByYXdJbmZvcm1hdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEZpZWxkUGFyc2VyLnByb2Nlc3NGaXhlZEFJKDQsIGRhdGFMZW5ndGhbMV0sIHJhd0luZm9ybWF0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgcHJvY2Vzc0ZpeGVkQUkoYWlTaXplLCBmaWVsZFNpemUsIHJhd0luZm9ybWF0aW9uKSB7XG4gICAgICAgICAgICBpZiAocmF3SW5mb3JtYXRpb24ubGVuZ3RoIDwgYWlTaXplKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgYWkgPSByYXdJbmZvcm1hdGlvbi5zdWJzdHJpbmcoMCwgYWlTaXplKTtcbiAgICAgICAgICAgIGlmIChyYXdJbmZvcm1hdGlvbi5sZW5ndGggPCBhaVNpemUgKyBmaWVsZFNpemUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBmaWVsZCA9IHJhd0luZm9ybWF0aW9uLnN1YnN0cmluZyhhaVNpemUsIGFpU2l6ZSArIGZpZWxkU2l6ZSk7XG4gICAgICAgICAgICBsZXQgcmVtYWluaW5nID0gcmF3SW5mb3JtYXRpb24uc3Vic3RyaW5nKGFpU2l6ZSArIGZpZWxkU2l6ZSk7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gJygnICsgYWkgKyAnKScgKyBmaWVsZDtcbiAgICAgICAgICAgIGxldCBwYXJzZWRBSSA9IEZpZWxkUGFyc2VyLnBhcnNlRmllbGRzSW5HZW5lcmFsUHVycG9zZShyZW1haW5pbmcpO1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlZEFJID09IG51bGwgPyByZXN1bHQgOiByZXN1bHQgKyBwYXJzZWRBSTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgcHJvY2Vzc1ZhcmlhYmxlQUkoYWlTaXplLCB2YXJpYWJsZUZpZWxkU2l6ZSwgcmF3SW5mb3JtYXRpb24pIHtcbiAgICAgICAgICAgIGxldCBhaSA9IHJhd0luZm9ybWF0aW9uLnN1YnN0cmluZygwLCBhaVNpemUpO1xuICAgICAgICAgICAgbGV0IG1heFNpemU7XG4gICAgICAgICAgICBpZiAocmF3SW5mb3JtYXRpb24ubGVuZ3RoIDwgYWlTaXplICsgdmFyaWFibGVGaWVsZFNpemUpIHtcbiAgICAgICAgICAgICAgICBtYXhTaXplID0gcmF3SW5mb3JtYXRpb24ubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbWF4U2l6ZSA9IGFpU2l6ZSArIHZhcmlhYmxlRmllbGRTaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGZpZWxkID0gcmF3SW5mb3JtYXRpb24uc3Vic3RyaW5nKGFpU2l6ZSwgbWF4U2l6ZSk7XG4gICAgICAgICAgICBsZXQgcmVtYWluaW5nID0gcmF3SW5mb3JtYXRpb24uc3Vic3RyaW5nKG1heFNpemUpO1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9ICcoJyArIGFpICsgJyknICsgZmllbGQ7XG4gICAgICAgICAgICBsZXQgcGFyc2VkQUkgPSBGaWVsZFBhcnNlci5wYXJzZUZpZWxkc0luR2VuZXJhbFB1cnBvc2UocmVtYWluaW5nKTtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZWRBSSA9PSBudWxsID8gcmVzdWx0IDogcmVzdWx0ICsgcGFyc2VkQUk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgRmllbGRQYXJzZXIuVkFSSUFCTEVfTEVOR1RIID0gW107XG4gICAgRmllbGRQYXJzZXIuVFdPX0RJR0lUX0RBVEFfTEVOR1RIID0gW1xuICAgICAgICBbJzAwJywgMThdLFxuICAgICAgICBbJzAxJywgMTRdLFxuICAgICAgICBbJzAyJywgMTRdLFxuICAgICAgICBbJzEwJywgRmllbGRQYXJzZXIuVkFSSUFCTEVfTEVOR1RILCAyMF0sXG4gICAgICAgIFsnMTEnLCA2XSxcbiAgICAgICAgWycxMicsIDZdLFxuICAgICAgICBbJzEzJywgNl0sXG4gICAgICAgIFsnMTUnLCA2XSxcbiAgICAgICAgWycxNycsIDZdLFxuICAgICAgICBbJzIwJywgMl0sXG4gICAgICAgIFsnMjEnLCBGaWVsZFBhcnNlci5WQVJJQUJMRV9MRU5HVEgsIDIwXSxcbiAgICAgICAgWycyMicsIEZpZWxkUGFyc2VyLlZBUklBQkxFX0xFTkdUSCwgMjldLFxuICAgICAgICBbJzMwJywgRmllbGRQYXJzZXIuVkFSSUFCTEVfTEVOR1RILCA4XSxcbiAgICAgICAgWyczNycsIEZpZWxkUGFyc2VyLlZBUklBQkxFX0xFTkdUSCwgOF0sXG4gICAgICAgIC8vIGludGVybmFsIGNvbXBhbnkgY29kZXNcbiAgICAgICAgWyc5MCcsIEZpZWxkUGFyc2VyLlZBUklBQkxFX0xFTkdUSCwgMzBdLFxuICAgICAgICBbJzkxJywgRmllbGRQYXJzZXIuVkFSSUFCTEVfTEVOR1RILCAzMF0sXG4gICAgICAgIFsnOTInLCBGaWVsZFBhcnNlci5WQVJJQUJMRV9MRU5HVEgsIDMwXSxcbiAgICAgICAgWyc5MycsIEZpZWxkUGFyc2VyLlZBUklBQkxFX0xFTkdUSCwgMzBdLFxuICAgICAgICBbJzk0JywgRmllbGRQYXJzZXIuVkFSSUFCTEVfTEVOR1RILCAzMF0sXG4gICAgICAgIFsnOTUnLCBGaWVsZFBhcnNlci5WQVJJQUJMRV9MRU5HVEgsIDMwXSxcbiAgICAgICAgWyc5NicsIEZpZWxkUGFyc2VyLlZBUklBQkxFX0xFTkdUSCwgMzBdLFxuICAgICAgICBbJzk3JywgRmllbGRQYXJzZXIuVkFSSUFCTEVfTEVOR1RILCAzXSxcbiAgICAgICAgWyc5OCcsIEZpZWxkUGFyc2VyLlZBUklBQkxFX0xFTkdUSCwgMzBdLFxuICAgICAgICBbJzk5JywgRmllbGRQYXJzZXIuVkFSSUFCTEVfTEVOR1RILCAzMF0sXG4gICAgXTtcbiAgICBGaWVsZFBhcnNlci5USFJFRV9ESUdJVF9EQVRBX0xFTkdUSCA9IFtcbiAgICAgICAgLy8gU2FtZSBmb3JtYXQgYXMgYWJvdmVcbiAgICAgICAgWycyNDAnLCBGaWVsZFBhcnNlci5WQVJJQUJMRV9MRU5HVEgsIDMwXSxcbiAgICAgICAgWycyNDEnLCBGaWVsZFBhcnNlci5WQVJJQUJMRV9MRU5HVEgsIDMwXSxcbiAgICAgICAgWycyNDInLCBGaWVsZFBhcnNlci5WQVJJQUJMRV9MRU5HVEgsIDZdLFxuICAgICAgICBbJzI1MCcsIEZpZWxkUGFyc2VyLlZBUklBQkxFX0xFTkdUSCwgMzBdLFxuICAgICAgICBbJzI1MScsIEZpZWxkUGFyc2VyLlZBUklBQkxFX0xFTkdUSCwgMzBdLFxuICAgICAgICBbJzI1MycsIEZpZWxkUGFyc2VyLlZBUklBQkxFX0xFTkdUSCwgMTddLFxuICAgICAgICBbJzI1NCcsIEZpZWxkUGFyc2VyLlZBUklBQkxFX0xFTkdUSCwgMjBdLFxuICAgICAgICBbJzQwMCcsIEZpZWxkUGFyc2VyLlZBUklBQkxFX0xFTkdUSCwgMzBdLFxuICAgICAgICBbJzQwMScsIEZpZWxkUGFyc2VyLlZBUklBQkxFX0xFTkdUSCwgMzBdLFxuICAgICAgICBbJzQwMicsIDE3XSxcbiAgICAgICAgWyc0MDMnLCBGaWVsZFBhcnNlci5WQVJJQUJMRV9MRU5HVEgsIDMwXSxcbiAgICAgICAgWyc0MTAnLCAxM10sXG4gICAgICAgIFsnNDExJywgMTNdLFxuICAgICAgICBbJzQxMicsIDEzXSxcbiAgICAgICAgWyc0MTMnLCAxM10sXG4gICAgICAgIFsnNDE0JywgMTNdLFxuICAgICAgICBbJzQyMCcsIEZpZWxkUGFyc2VyLlZBUklBQkxFX0xFTkdUSCwgMjBdLFxuICAgICAgICBbJzQyMScsIEZpZWxkUGFyc2VyLlZBUklBQkxFX0xFTkdUSCwgMTVdLFxuICAgICAgICBbJzQyMicsIDNdLFxuICAgICAgICBbJzQyMycsIEZpZWxkUGFyc2VyLlZBUklBQkxFX0xFTkdUSCwgMTVdLFxuICAgICAgICBbJzQyNCcsIDNdLFxuICAgICAgICBbJzQyNScsIDNdLFxuICAgICAgICBbJzQyNicsIDNdLFxuICAgIF07XG4gICAgRmllbGRQYXJzZXIuVEhSRUVfRElHSVRfUExVU19ESUdJVF9EQVRBX0xFTkdUSCA9IFtcbiAgICAgICAgLy8gU2FtZSBmb3JtYXQgYXMgYWJvdmVcbiAgICAgICAgWyczMTAnLCA2XSxcbiAgICAgICAgWyczMTEnLCA2XSxcbiAgICAgICAgWyczMTInLCA2XSxcbiAgICAgICAgWyczMTMnLCA2XSxcbiAgICAgICAgWyczMTQnLCA2XSxcbiAgICAgICAgWyczMTUnLCA2XSxcbiAgICAgICAgWyczMTYnLCA2XSxcbiAgICAgICAgWyczMjAnLCA2XSxcbiAgICAgICAgWyczMjEnLCA2XSxcbiAgICAgICAgWyczMjInLCA2XSxcbiAgICAgICAgWyczMjMnLCA2XSxcbiAgICAgICAgWyczMjQnLCA2XSxcbiAgICAgICAgWyczMjUnLCA2XSxcbiAgICAgICAgWyczMjYnLCA2XSxcbiAgICAgICAgWyczMjcnLCA2XSxcbiAgICAgICAgWyczMjgnLCA2XSxcbiAgICAgICAgWyczMjknLCA2XSxcbiAgICAgICAgWyczMzAnLCA2XSxcbiAgICAgICAgWyczMzEnLCA2XSxcbiAgICAgICAgWyczMzInLCA2XSxcbiAgICAgICAgWyczMzMnLCA2XSxcbiAgICAgICAgWyczMzQnLCA2XSxcbiAgICAgICAgWyczMzUnLCA2XSxcbiAgICAgICAgWyczMzYnLCA2XSxcbiAgICAgICAgWyczNDAnLCA2XSxcbiAgICAgICAgWyczNDEnLCA2XSxcbiAgICAgICAgWyczNDInLCA2XSxcbiAgICAgICAgWyczNDMnLCA2XSxcbiAgICAgICAgWyczNDQnLCA2XSxcbiAgICAgICAgWyczNDUnLCA2XSxcbiAgICAgICAgWyczNDYnLCA2XSxcbiAgICAgICAgWyczNDcnLCA2XSxcbiAgICAgICAgWyczNDgnLCA2XSxcbiAgICAgICAgWyczNDknLCA2XSxcbiAgICAgICAgWyczNTAnLCA2XSxcbiAgICAgICAgWyczNTEnLCA2XSxcbiAgICAgICAgWyczNTInLCA2XSxcbiAgICAgICAgWyczNTMnLCA2XSxcbiAgICAgICAgWyczNTQnLCA2XSxcbiAgICAgICAgWyczNTUnLCA2XSxcbiAgICAgICAgWyczNTYnLCA2XSxcbiAgICAgICAgWyczNTcnLCA2XSxcbiAgICAgICAgWyczNjAnLCA2XSxcbiAgICAgICAgWyczNjEnLCA2XSxcbiAgICAgICAgWyczNjInLCA2XSxcbiAgICAgICAgWyczNjMnLCA2XSxcbiAgICAgICAgWyczNjQnLCA2XSxcbiAgICAgICAgWyczNjUnLCA2XSxcbiAgICAgICAgWyczNjYnLCA2XSxcbiAgICAgICAgWyczNjcnLCA2XSxcbiAgICAgICAgWyczNjgnLCA2XSxcbiAgICAgICAgWyczNjknLCA2XSxcbiAgICAgICAgWyczOTAnLCBGaWVsZFBhcnNlci5WQVJJQUJMRV9MRU5HVEgsIDE1XSxcbiAgICAgICAgWyczOTEnLCBGaWVsZFBhcnNlci5WQVJJQUJMRV9MRU5HVEgsIDE4XSxcbiAgICAgICAgWyczOTInLCBGaWVsZFBhcnNlci5WQVJJQUJMRV9MRU5HVEgsIDE1XSxcbiAgICAgICAgWyczOTMnLCBGaWVsZFBhcnNlci5WQVJJQUJMRV9MRU5HVEgsIDE4XSxcbiAgICAgICAgWyc3MDMnLCBGaWVsZFBhcnNlci5WQVJJQUJMRV9MRU5HVEgsIDMwXSxcbiAgICBdO1xuICAgIEZpZWxkUGFyc2VyLkZPVVJfRElHSVRfREFUQV9MRU5HVEggPSBbXG4gICAgICAgIC8vIFNhbWUgZm9ybWF0IGFzIGFib3ZlXG4gICAgICAgIFsnNzAwMScsIDEzXSxcbiAgICAgICAgWyc3MDAyJywgRmllbGRQYXJzZXIuVkFSSUFCTEVfTEVOR1RILCAzMF0sXG4gICAgICAgIFsnNzAwMycsIDEwXSxcbiAgICAgICAgWyc4MDAxJywgMTRdLFxuICAgICAgICBbJzgwMDInLCBGaWVsZFBhcnNlci5WQVJJQUJMRV9MRU5HVEgsIDIwXSxcbiAgICAgICAgWyc4MDAzJywgRmllbGRQYXJzZXIuVkFSSUFCTEVfTEVOR1RILCAzMF0sXG4gICAgICAgIFsnODAwNCcsIEZpZWxkUGFyc2VyLlZBUklBQkxFX0xFTkdUSCwgMzBdLFxuICAgICAgICBbJzgwMDUnLCA2XSxcbiAgICAgICAgWyc4MDA2JywgMThdLFxuICAgICAgICBbJzgwMDcnLCBGaWVsZFBhcnNlci5WQVJJQUJMRV9MRU5HVEgsIDMwXSxcbiAgICAgICAgWyc4MDA4JywgRmllbGRQYXJzZXIuVkFSSUFCTEVfTEVOR1RILCAxMl0sXG4gICAgICAgIFsnODAxOCcsIDE4XSxcbiAgICAgICAgWyc4MDIwJywgRmllbGRQYXJzZXIuVkFSSUFCTEVfTEVOR1RILCAyNV0sXG4gICAgICAgIFsnODEwMCcsIDZdLFxuICAgICAgICBbJzgxMDEnLCAxMF0sXG4gICAgICAgIFsnODEwMicsIDJdLFxuICAgICAgICBbJzgxMTAnLCBGaWVsZFBhcnNlci5WQVJJQUJMRV9MRU5HVEgsIDcwXSxcbiAgICAgICAgWyc4MjAwJywgRmllbGRQYXJzZXIuVkFSSUFCTEVfTEVOR1RILCA3MF0sXG4gICAgXTtcblxuICAgIGNsYXNzIEdlbmVyYWxBcHBJZERlY29kZXIge1xuICAgICAgICBjb25zdHJ1Y3RvcihpbmZvcm1hdGlvbikge1xuICAgICAgICAgICAgdGhpcy5idWZmZXIgPSBuZXcgU3RyaW5nQnVpbGRlcigpO1xuICAgICAgICAgICAgdGhpcy5pbmZvcm1hdGlvbiA9IGluZm9ybWF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGRlY29kZUFsbENvZGVzKGJ1ZmYsIGluaXRpYWxQb3NpdGlvbikge1xuICAgICAgICAgICAgbGV0IGN1cnJlbnRQb3NpdGlvbiA9IGluaXRpYWxQb3NpdGlvbjtcbiAgICAgICAgICAgIGxldCByZW1haW5pbmcgPSBudWxsO1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIGxldCBpbmZvID0gdGhpcy5kZWNvZGVHZW5lcmFsUHVycG9zZUZpZWxkKGN1cnJlbnRQb3NpdGlvbiwgcmVtYWluaW5nKTtcbiAgICAgICAgICAgICAgICBsZXQgcGFyc2VkRmllbGRzID0gRmllbGRQYXJzZXIucGFyc2VGaWVsZHNJbkdlbmVyYWxQdXJwb3NlKGluZm8uZ2V0TmV3U3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgIGlmIChwYXJzZWRGaWVsZHMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBidWZmLmFwcGVuZChwYXJzZWRGaWVsZHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaW5mby5pc1JlbWFpbmluZygpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbWFpbmluZyA9ICcnICsgaW5mby5nZXRSZW1haW5pbmdWYWx1ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVtYWluaW5nID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRQb3NpdGlvbiA9PT0gaW5mby5nZXROZXdQb3NpdGlvbigpKSB7IC8vIE5vIHN0ZXAgZm9yd2FyZCFcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN1cnJlbnRQb3NpdGlvbiA9IGluZm8uZ2V0TmV3UG9zaXRpb24oKTtcbiAgICAgICAgICAgIH0gd2hpbGUgKHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuIGJ1ZmYudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBpc1N0aWxsTnVtZXJpYyhwb3MpIHtcbiAgICAgICAgICAgIC8vIEl0J3MgbnVtZXJpYyBpZiBpdCBzdGlsbCBoYXMgNyBwb3NpdGlvbnNcbiAgICAgICAgICAgIC8vIGFuZCBvbmUgb2YgdGhlIGZpcnN0IDQgYml0cyBpcyBcIjFcIi5cbiAgICAgICAgICAgIGlmIChwb3MgKyA3ID4gdGhpcy5pbmZvcm1hdGlvbi5nZXRTaXplKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcG9zICsgNCA8PSB0aGlzLmluZm9ybWF0aW9uLmdldFNpemUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBwb3M7IGkgPCBwb3MgKyAzOyArK2kpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pbmZvcm1hdGlvbi5nZXQoaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5mb3JtYXRpb24uZ2V0KHBvcyArIDMpO1xuICAgICAgICB9XG4gICAgICAgIGRlY29kZU51bWVyaWMocG9zKSB7XG4gICAgICAgICAgICBpZiAocG9zICsgNyA+IHRoaXMuaW5mb3JtYXRpb24uZ2V0U2l6ZSgpKSB7XG4gICAgICAgICAgICAgICAgbGV0IG51bWVyaWMgPSB0aGlzLmV4dHJhY3ROdW1lcmljVmFsdWVGcm9tQml0QXJyYXkocG9zLCA0KTtcbiAgICAgICAgICAgICAgICBpZiAobnVtZXJpYyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IERlY29kZWROdW1lcmljKHRoaXMuaW5mb3JtYXRpb24uZ2V0U2l6ZSgpLCBEZWNvZGVkTnVtZXJpYy5GTkMxLCBEZWNvZGVkTnVtZXJpYy5GTkMxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBEZWNvZGVkTnVtZXJpYyh0aGlzLmluZm9ybWF0aW9uLmdldFNpemUoKSwgbnVtZXJpYyAtIDEsIERlY29kZWROdW1lcmljLkZOQzEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IG51bWVyaWMgPSB0aGlzLmV4dHJhY3ROdW1lcmljVmFsdWVGcm9tQml0QXJyYXkocG9zLCA3KTtcbiAgICAgICAgICAgIGxldCBkaWdpdDEgPSAobnVtZXJpYyAtIDgpIC8gMTE7XG4gICAgICAgICAgICBsZXQgZGlnaXQyID0gKG51bWVyaWMgLSA4KSAlIDExO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEZWNvZGVkTnVtZXJpYyhwb3MgKyA3LCBkaWdpdDEsIGRpZ2l0Mik7XG4gICAgICAgIH1cbiAgICAgICAgZXh0cmFjdE51bWVyaWNWYWx1ZUZyb21CaXRBcnJheShwb3MsIGJpdHMpIHtcbiAgICAgICAgICAgIHJldHVybiBHZW5lcmFsQXBwSWREZWNvZGVyLmV4dHJhY3ROdW1lcmljVmFsdWVGcm9tQml0QXJyYXkodGhpcy5pbmZvcm1hdGlvbiwgcG9zLCBiaXRzKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgZXh0cmFjdE51bWVyaWNWYWx1ZUZyb21CaXRBcnJheShpbmZvcm1hdGlvbiwgcG9zLCBiaXRzKSB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiaXRzOyArK2kpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5mb3JtYXRpb24uZ2V0KHBvcyArIGkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlIHw9IDEgPDwgKGJpdHMgLSBpIC0gMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGRlY29kZUdlbmVyYWxQdXJwb3NlRmllbGQocG9zLCByZW1haW5pbmcpIHtcbiAgICAgICAgICAgIC8vIHRoaXMuYnVmZmVyLnNldExlbmd0aCgwKTtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyLnNldExlbmd0aFRvWmVybygpO1xuICAgICAgICAgICAgaWYgKHJlbWFpbmluZyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5idWZmZXIuYXBwZW5kKHJlbWFpbmluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnQuc2V0UG9zaXRpb24ocG9zKTtcbiAgICAgICAgICAgIGxldCBsYXN0RGVjb2RlZCA9IHRoaXMucGFyc2VCbG9ja3MoKTtcbiAgICAgICAgICAgIGlmIChsYXN0RGVjb2RlZCAhPSBudWxsICYmIGxhc3REZWNvZGVkLmlzUmVtYWluaW5nKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IERlY29kZWRJbmZvcm1hdGlvbih0aGlzLmN1cnJlbnQuZ2V0UG9zaXRpb24oKSwgdGhpcy5idWZmZXIudG9TdHJpbmcoKSwgbGFzdERlY29kZWQuZ2V0UmVtYWluaW5nVmFsdWUoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IERlY29kZWRJbmZvcm1hdGlvbih0aGlzLmN1cnJlbnQuZ2V0UG9zaXRpb24oKSwgdGhpcy5idWZmZXIudG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcGFyc2VCbG9ja3MoKSB7XG4gICAgICAgICAgICBsZXQgaXNGaW5pc2hlZDtcbiAgICAgICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgbGV0IGluaXRpYWxQb3NpdGlvbiA9IHRoaXMuY3VycmVudC5nZXRQb3NpdGlvbigpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnQuaXNBbHBoYSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMucGFyc2VBbHBoYUJsb2NrKCk7XG4gICAgICAgICAgICAgICAgICAgIGlzRmluaXNoZWQgPSByZXN1bHQuaXNGaW5pc2hlZCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLmN1cnJlbnQuaXNJc29JZWM2NDYoKSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLnBhcnNlSXNvSWVjNjQ2QmxvY2soKTtcbiAgICAgICAgICAgICAgICAgICAgaXNGaW5pc2hlZCA9IHJlc3VsdC5pc0ZpbmlzaGVkKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgeyAvLyBpdCBtdXN0IGJlIG51bWVyaWNcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5wYXJzZU51bWVyaWNCbG9jaygpO1xuICAgICAgICAgICAgICAgICAgICBpc0ZpbmlzaGVkID0gcmVzdWx0LmlzRmluaXNoZWQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IHBvc2l0aW9uQ2hhbmdlZCA9IGluaXRpYWxQb3NpdGlvbiAhPT0gdGhpcy5jdXJyZW50LmdldFBvc2l0aW9uKCk7XG4gICAgICAgICAgICAgICAgaWYgKCFwb3NpdGlvbkNoYW5nZWQgJiYgIWlzRmluaXNoZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAoIWlzRmluaXNoZWQpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5nZXREZWNvZGVkSW5mb3JtYXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICBwYXJzZU51bWVyaWNCbG9jaygpIHtcbiAgICAgICAgICAgIHdoaWxlICh0aGlzLmlzU3RpbGxOdW1lcmljKHRoaXMuY3VycmVudC5nZXRQb3NpdGlvbigpKSkge1xuICAgICAgICAgICAgICAgIGxldCBudW1lcmljID0gdGhpcy5kZWNvZGVOdW1lcmljKHRoaXMuY3VycmVudC5nZXRQb3NpdGlvbigpKTtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnQuc2V0UG9zaXRpb24obnVtZXJpYy5nZXROZXdQb3NpdGlvbigpKTtcbiAgICAgICAgICAgICAgICBpZiAobnVtZXJpYy5pc0ZpcnN0RGlnaXRGTkMxKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGluZm9ybWF0aW9uO1xuICAgICAgICAgICAgICAgICAgICBpZiAobnVtZXJpYy5pc1NlY29uZERpZ2l0Rk5DMSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmZvcm1hdGlvbiA9IG5ldyBEZWNvZGVkSW5mb3JtYXRpb24odGhpcy5jdXJyZW50LmdldFBvc2l0aW9uKCksIHRoaXMuYnVmZmVyLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5mb3JtYXRpb24gPSBuZXcgRGVjb2RlZEluZm9ybWF0aW9uKHRoaXMuY3VycmVudC5nZXRQb3NpdGlvbigpLCB0aGlzLmJ1ZmZlci50b1N0cmluZygpLCBudW1lcmljLmdldFNlY29uZERpZ2l0KCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQmxvY2tQYXJzZWRSZXN1bHQodHJ1ZSwgaW5mb3JtYXRpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlci5hcHBlbmQobnVtZXJpYy5nZXRGaXJzdERpZ2l0KCkpO1xuICAgICAgICAgICAgICAgIGlmIChudW1lcmljLmlzU2Vjb25kRGlnaXRGTkMxKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGluZm9ybWF0aW9uID0gbmV3IERlY29kZWRJbmZvcm1hdGlvbih0aGlzLmN1cnJlbnQuZ2V0UG9zaXRpb24oKSwgdGhpcy5idWZmZXIudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQmxvY2tQYXJzZWRSZXN1bHQodHJ1ZSwgaW5mb3JtYXRpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlci5hcHBlbmQobnVtZXJpYy5nZXRTZWNvbmREaWdpdCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmlzTnVtZXJpY1RvQWxwaGFOdW1lcmljTGF0Y2godGhpcy5jdXJyZW50LmdldFBvc2l0aW9uKCkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50LnNldEFscGhhKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50LmluY3JlbWVudFBvc2l0aW9uKDQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBCbG9ja1BhcnNlZFJlc3VsdChmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgcGFyc2VJc29JZWM2NDZCbG9jaygpIHtcbiAgICAgICAgICAgIHdoaWxlICh0aGlzLmlzU3RpbGxJc29JZWM2NDYodGhpcy5jdXJyZW50LmdldFBvc2l0aW9uKCkpKSB7XG4gICAgICAgICAgICAgICAgbGV0IGlzbyA9IHRoaXMuZGVjb2RlSXNvSWVjNjQ2KHRoaXMuY3VycmVudC5nZXRQb3NpdGlvbigpKTtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnQuc2V0UG9zaXRpb24oaXNvLmdldE5ld1Bvc2l0aW9uKCkpO1xuICAgICAgICAgICAgICAgIGlmIChpc28uaXNGTkMxKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGluZm9ybWF0aW9uID0gbmV3IERlY29kZWRJbmZvcm1hdGlvbih0aGlzLmN1cnJlbnQuZ2V0UG9zaXRpb24oKSwgdGhpcy5idWZmZXIudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQmxvY2tQYXJzZWRSZXN1bHQodHJ1ZSwgaW5mb3JtYXRpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlci5hcHBlbmQoaXNvLmdldFZhbHVlKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuaXNBbHBoYU9yNjQ2VG9OdW1lcmljTGF0Y2godGhpcy5jdXJyZW50LmdldFBvc2l0aW9uKCkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50LmluY3JlbWVudFBvc2l0aW9uKDMpO1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudC5zZXROdW1lcmljKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLmlzQWxwaGFUbzY0NlRvQWxwaGFMYXRjaCh0aGlzLmN1cnJlbnQuZ2V0UG9zaXRpb24oKSkpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50LmdldFBvc2l0aW9uKCkgKyA1IDwgdGhpcy5pbmZvcm1hdGlvbi5nZXRTaXplKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50LmluY3JlbWVudFBvc2l0aW9uKDUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50LnNldFBvc2l0aW9uKHRoaXMuaW5mb3JtYXRpb24uZ2V0U2l6ZSgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50LnNldEFscGhhKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJsb2NrUGFyc2VkUmVzdWx0KGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBwYXJzZUFscGhhQmxvY2soKSB7XG4gICAgICAgICAgICB3aGlsZSAodGhpcy5pc1N0aWxsQWxwaGEodGhpcy5jdXJyZW50LmdldFBvc2l0aW9uKCkpKSB7XG4gICAgICAgICAgICAgICAgbGV0IGFscGhhID0gdGhpcy5kZWNvZGVBbHBoYW51bWVyaWModGhpcy5jdXJyZW50LmdldFBvc2l0aW9uKCkpO1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudC5zZXRQb3NpdGlvbihhbHBoYS5nZXROZXdQb3NpdGlvbigpKTtcbiAgICAgICAgICAgICAgICBpZiAoYWxwaGEuaXNGTkMxKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGluZm9ybWF0aW9uID0gbmV3IERlY29kZWRJbmZvcm1hdGlvbih0aGlzLmN1cnJlbnQuZ2V0UG9zaXRpb24oKSwgdGhpcy5idWZmZXIudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQmxvY2tQYXJzZWRSZXN1bHQodHJ1ZSwgaW5mb3JtYXRpb24pOyAvLyBlbmQgb2YgdGhlIGNoYXIgYmxvY2tcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5idWZmZXIuYXBwZW5kKGFscGhhLmdldFZhbHVlKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuaXNBbHBoYU9yNjQ2VG9OdW1lcmljTGF0Y2godGhpcy5jdXJyZW50LmdldFBvc2l0aW9uKCkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50LmluY3JlbWVudFBvc2l0aW9uKDMpO1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudC5zZXROdW1lcmljKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLmlzQWxwaGFUbzY0NlRvQWxwaGFMYXRjaCh0aGlzLmN1cnJlbnQuZ2V0UG9zaXRpb24oKSkpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50LmdldFBvc2l0aW9uKCkgKyA1IDwgdGhpcy5pbmZvcm1hdGlvbi5nZXRTaXplKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50LmluY3JlbWVudFBvc2l0aW9uKDUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50LnNldFBvc2l0aW9uKHRoaXMuaW5mb3JtYXRpb24uZ2V0U2l6ZSgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50LnNldElzb0llYzY0NigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBCbG9ja1BhcnNlZFJlc3VsdChmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgaXNTdGlsbElzb0llYzY0Nihwb3MpIHtcbiAgICAgICAgICAgIGlmIChwb3MgKyA1ID4gdGhpcy5pbmZvcm1hdGlvbi5nZXRTaXplKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZml2ZUJpdFZhbHVlID0gdGhpcy5leHRyYWN0TnVtZXJpY1ZhbHVlRnJvbUJpdEFycmF5KHBvcywgNSk7XG4gICAgICAgICAgICBpZiAoZml2ZUJpdFZhbHVlID49IDUgJiYgZml2ZUJpdFZhbHVlIDwgMTYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwb3MgKyA3ID4gdGhpcy5pbmZvcm1hdGlvbi5nZXRTaXplKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgc2V2ZW5CaXRWYWx1ZSA9IHRoaXMuZXh0cmFjdE51bWVyaWNWYWx1ZUZyb21CaXRBcnJheShwb3MsIDcpO1xuICAgICAgICAgICAgaWYgKHNldmVuQml0VmFsdWUgPj0gNjQgJiYgc2V2ZW5CaXRWYWx1ZSA8IDExNikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBvcyArIDggPiB0aGlzLmluZm9ybWF0aW9uLmdldFNpemUoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBlaWdodEJpdFZhbHVlID0gdGhpcy5leHRyYWN0TnVtZXJpY1ZhbHVlRnJvbUJpdEFycmF5KHBvcywgOCk7XG4gICAgICAgICAgICByZXR1cm4gZWlnaHRCaXRWYWx1ZSA+PSAyMzIgJiYgZWlnaHRCaXRWYWx1ZSA8IDI1MztcbiAgICAgICAgfVxuICAgICAgICBkZWNvZGVJc29JZWM2NDYocG9zKSB7XG4gICAgICAgICAgICBsZXQgZml2ZUJpdFZhbHVlID0gdGhpcy5leHRyYWN0TnVtZXJpY1ZhbHVlRnJvbUJpdEFycmF5KHBvcywgNSk7XG4gICAgICAgICAgICBpZiAoZml2ZUJpdFZhbHVlID09PSAxNSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRGVjb2RlZENoYXIocG9zICsgNSwgRGVjb2RlZENoYXIuRk5DMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZml2ZUJpdFZhbHVlID49IDUgJiYgZml2ZUJpdFZhbHVlIDwgMTUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IERlY29kZWRDaGFyKHBvcyArIDUsICgnMCcgKyAoZml2ZUJpdFZhbHVlIC0gNSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBzZXZlbkJpdFZhbHVlID0gdGhpcy5leHRyYWN0TnVtZXJpY1ZhbHVlRnJvbUJpdEFycmF5KHBvcywgNyk7XG4gICAgICAgICAgICBpZiAoc2V2ZW5CaXRWYWx1ZSA+PSA2NCAmJiBzZXZlbkJpdFZhbHVlIDwgOTApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IERlY29kZWRDaGFyKHBvcyArIDcsICgnJyArIChzZXZlbkJpdFZhbHVlICsgMSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZXZlbkJpdFZhbHVlID49IDkwICYmIHNldmVuQml0VmFsdWUgPCAxMTYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IERlY29kZWRDaGFyKHBvcyArIDcsICgnJyArIChzZXZlbkJpdFZhbHVlICsgNykpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBlaWdodEJpdFZhbHVlID0gdGhpcy5leHRyYWN0TnVtZXJpY1ZhbHVlRnJvbUJpdEFycmF5KHBvcywgOCk7XG4gICAgICAgICAgICBsZXQgYztcbiAgICAgICAgICAgIHN3aXRjaCAoZWlnaHRCaXRWYWx1ZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMjMyOlxuICAgICAgICAgICAgICAgICAgICBjID0gJyEnO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDIzMzpcbiAgICAgICAgICAgICAgICAgICAgYyA9ICdcIic7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjM0OlxuICAgICAgICAgICAgICAgICAgICBjID0gJyUnO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDIzNTpcbiAgICAgICAgICAgICAgICAgICAgYyA9ICcmJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyMzY6XG4gICAgICAgICAgICAgICAgICAgIGMgPSAnXFwnJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyMzc6XG4gICAgICAgICAgICAgICAgICAgIGMgPSAnKCc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjM4OlxuICAgICAgICAgICAgICAgICAgICBjID0gJyknO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDIzOTpcbiAgICAgICAgICAgICAgICAgICAgYyA9ICcqJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyNDA6XG4gICAgICAgICAgICAgICAgICAgIGMgPSAnKyc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjQxOlxuICAgICAgICAgICAgICAgICAgICBjID0gJywnO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI0MjpcbiAgICAgICAgICAgICAgICAgICAgYyA9ICctJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyNDM6XG4gICAgICAgICAgICAgICAgICAgIGMgPSAnLic7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjQ0OlxuICAgICAgICAgICAgICAgICAgICBjID0gJy8nO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI0NTpcbiAgICAgICAgICAgICAgICAgICAgYyA9ICc6JztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyNDY6XG4gICAgICAgICAgICAgICAgICAgIGMgPSAnOyc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjQ3OlxuICAgICAgICAgICAgICAgICAgICBjID0gJzwnO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI0ODpcbiAgICAgICAgICAgICAgICAgICAgYyA9ICc9JztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyNDk6XG4gICAgICAgICAgICAgICAgICAgIGMgPSAnPic7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjUwOlxuICAgICAgICAgICAgICAgICAgICBjID0gJz8nO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI1MTpcbiAgICAgICAgICAgICAgICAgICAgYyA9ICdfJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyNTI6XG4gICAgICAgICAgICAgICAgICAgIGMgPSAnICc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgRGVjb2RlZENoYXIocG9zICsgOCwgYyk7XG4gICAgICAgIH1cbiAgICAgICAgaXNTdGlsbEFscGhhKHBvcykge1xuICAgICAgICAgICAgaWYgKHBvcyArIDUgPiB0aGlzLmluZm9ybWF0aW9uLmdldFNpemUoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFdlIG5vdyBjaGVjayBpZiBpdCdzIGEgdmFsaWQgNS1iaXQgdmFsdWUgKDAuLjkgYW5kIEZOQzEpXG4gICAgICAgICAgICBsZXQgZml2ZUJpdFZhbHVlID0gdGhpcy5leHRyYWN0TnVtZXJpY1ZhbHVlRnJvbUJpdEFycmF5KHBvcywgNSk7XG4gICAgICAgICAgICBpZiAoZml2ZUJpdFZhbHVlID49IDUgJiYgZml2ZUJpdFZhbHVlIDwgMTYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwb3MgKyA2ID4gdGhpcy5pbmZvcm1hdGlvbi5nZXRTaXplKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgc2l4Qml0VmFsdWUgPSB0aGlzLmV4dHJhY3ROdW1lcmljVmFsdWVGcm9tQml0QXJyYXkocG9zLCA2KTtcbiAgICAgICAgICAgIHJldHVybiBzaXhCaXRWYWx1ZSA+PSAxNiAmJiBzaXhCaXRWYWx1ZSA8IDYzOyAvLyA2MyBub3QgaW5jbHVkZWRcbiAgICAgICAgfVxuICAgICAgICBkZWNvZGVBbHBoYW51bWVyaWMocG9zKSB7XG4gICAgICAgICAgICBsZXQgZml2ZUJpdFZhbHVlID0gdGhpcy5leHRyYWN0TnVtZXJpY1ZhbHVlRnJvbUJpdEFycmF5KHBvcywgNSk7XG4gICAgICAgICAgICBpZiAoZml2ZUJpdFZhbHVlID09PSAxNSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRGVjb2RlZENoYXIocG9zICsgNSwgRGVjb2RlZENoYXIuRk5DMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZml2ZUJpdFZhbHVlID49IDUgJiYgZml2ZUJpdFZhbHVlIDwgMTUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IERlY29kZWRDaGFyKHBvcyArIDUsICgnMCcgKyAoZml2ZUJpdFZhbHVlIC0gNSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBzaXhCaXRWYWx1ZSA9IHRoaXMuZXh0cmFjdE51bWVyaWNWYWx1ZUZyb21CaXRBcnJheShwb3MsIDYpO1xuICAgICAgICAgICAgaWYgKHNpeEJpdFZhbHVlID49IDMyICYmIHNpeEJpdFZhbHVlIDwgNTgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IERlY29kZWRDaGFyKHBvcyArIDYsICgnJyArIChzaXhCaXRWYWx1ZSArIDMzKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGM7XG4gICAgICAgICAgICBzd2l0Y2ggKHNpeEJpdFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSA1ODpcbiAgICAgICAgICAgICAgICAgICAgYyA9ICcqJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA1OTpcbiAgICAgICAgICAgICAgICAgICAgYyA9ICcsJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA2MDpcbiAgICAgICAgICAgICAgICAgICAgYyA9ICctJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA2MTpcbiAgICAgICAgICAgICAgICAgICAgYyA9ICcuJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA2MjpcbiAgICAgICAgICAgICAgICAgICAgYyA9ICcvJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxTdGF0ZUV4Y2VwdGlvbignRGVjb2RpbmcgaW52YWxpZCBhbHBoYW51bWVyaWMgdmFsdWU6ICcgKyBzaXhCaXRWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IERlY29kZWRDaGFyKHBvcyArIDYsIGMpO1xuICAgICAgICB9XG4gICAgICAgIGlzQWxwaGFUbzY0NlRvQWxwaGFMYXRjaChwb3MpIHtcbiAgICAgICAgICAgIGlmIChwb3MgKyAxID4gdGhpcy5pbmZvcm1hdGlvbi5nZXRTaXplKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDUgJiYgaSArIHBvcyA8IHRoaXMuaW5mb3JtYXRpb24uZ2V0U2l6ZSgpOyArK2kpIHtcbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaW5mb3JtYXRpb24uZ2V0KHBvcyArIDIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5pbmZvcm1hdGlvbi5nZXQocG9zICsgaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlzQWxwaGFPcjY0NlRvTnVtZXJpY0xhdGNoKHBvcykge1xuICAgICAgICAgICAgLy8gTmV4dCBpcyBhbHBoYW51bWVyaWMgaWYgdGhlcmUgYXJlIDMgcG9zaXRpb25zIGFuZCB0aGV5IGFyZSBhbGwgemVyb3NcbiAgICAgICAgICAgIGlmIChwb3MgKyAzID4gdGhpcy5pbmZvcm1hdGlvbi5nZXRTaXplKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gcG9zOyBpIDwgcG9zICsgMzsgKytpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaW5mb3JtYXRpb24uZ2V0KGkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpc051bWVyaWNUb0FscGhhTnVtZXJpY0xhdGNoKHBvcykge1xuICAgICAgICAgICAgLy8gTmV4dCBpcyBhbHBoYW51bWVyaWMgaWYgdGhlcmUgYXJlIDQgcG9zaXRpb25zIGFuZCB0aGV5IGFyZSBhbGwgemVyb3MsIG9yXG4gICAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBhIHN1YnNldCBvZiB0aGlzIGp1c3QgYmVmb3JlIHRoZSBlbmQgb2YgdGhlIHN5bWJvbFxuICAgICAgICAgICAgaWYgKHBvcyArIDEgPiB0aGlzLmluZm9ybWF0aW9uLmdldFNpemUoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNCAmJiBpICsgcG9zIDwgdGhpcy5pbmZvcm1hdGlvbi5nZXRTaXplKCk7ICsraSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmluZm9ybWF0aW9uLmdldChwb3MgKyBpKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjbGFzcyBBYnN0cmFjdEV4cGFuZGVkRGVjb2RlciB7XG4gICAgICAgIGNvbnN0cnVjdG9yKGluZm9ybWF0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmluZm9ybWF0aW9uID0gaW5mb3JtYXRpb247XG4gICAgICAgICAgICB0aGlzLmdlbmVyYWxEZWNvZGVyID0gbmV3IEdlbmVyYWxBcHBJZERlY29kZXIoaW5mb3JtYXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGdldEluZm9ybWF0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5mb3JtYXRpb247XG4gICAgICAgIH1cbiAgICAgICAgZ2V0R2VuZXJhbERlY29kZXIoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZW5lcmFsRGVjb2RlcjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNsYXNzIEFJMDFkZWNvZGVyIGV4dGVuZHMgQWJzdHJhY3RFeHBhbmRlZERlY29kZXIge1xuICAgICAgICBjb25zdHJ1Y3RvcihpbmZvcm1hdGlvbikge1xuICAgICAgICAgICAgc3VwZXIoaW5mb3JtYXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGVuY29kZUNvbXByZXNzZWRHdGluKGJ1ZiwgY3VycmVudFBvcykge1xuICAgICAgICAgICAgYnVmLmFwcGVuZCgnKDAxKScpO1xuICAgICAgICAgICAgbGV0IGluaXRpYWxQb3NpdGlvbiA9IGJ1Zi5sZW5ndGgoKTtcbiAgICAgICAgICAgIGJ1Zi5hcHBlbmQoJzknKTtcbiAgICAgICAgICAgIHRoaXMuZW5jb2RlQ29tcHJlc3NlZEd0aW5XaXRob3V0QUkoYnVmLCBjdXJyZW50UG9zLCBpbml0aWFsUG9zaXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGVuY29kZUNvbXByZXNzZWRHdGluV2l0aG91dEFJKGJ1ZiwgY3VycmVudFBvcywgaW5pdGlhbEJ1ZmZlclBvc2l0aW9uKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7ICsraSkge1xuICAgICAgICAgICAgICAgIGxldCBjdXJyZW50QmxvY2sgPSB0aGlzLmdldEdlbmVyYWxEZWNvZGVyKCkuZXh0cmFjdE51bWVyaWNWYWx1ZUZyb21CaXRBcnJheShjdXJyZW50UG9zICsgMTAgKiBpLCAxMCk7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRCbG9jayAvIDEwMCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBidWYuYXBwZW5kKCcwJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50QmxvY2sgLyAxMCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBidWYuYXBwZW5kKCcwJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJ1Zi5hcHBlbmQoY3VycmVudEJsb2NrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIEFJMDFkZWNvZGVyLmFwcGVuZENoZWNrRGlnaXQoYnVmLCBpbml0aWFsQnVmZmVyUG9zaXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBhcHBlbmRDaGVja0RpZ2l0KGJ1ZiwgY3VycmVudFBvcykge1xuICAgICAgICAgICAgbGV0IGNoZWNrRGlnaXQgPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgLy8gbGV0IGRpZ2l0ID0gYnVmLmNoYXJBdChpICsgY3VycmVudFBvcykgLSAnMCc7XG4gICAgICAgICAgICAgICAgLy8gVG8gYmUgY2hlY2tlZFxuICAgICAgICAgICAgICAgIGxldCBkaWdpdCA9IGJ1Zi5jaGFyQXQoaSArIGN1cnJlbnRQb3MpLmNoYXJDb2RlQXQoMCkgLSAnMCcuY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICAgICAgICBjaGVja0RpZ2l0ICs9IChpICYgMHgwMSkgPT09IDAgPyAzICogZGlnaXQgOiBkaWdpdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoZWNrRGlnaXQgPSAxMCAtIChjaGVja0RpZ2l0ICUgMTApO1xuICAgICAgICAgICAgaWYgKGNoZWNrRGlnaXQgPT09IDEwKSB7XG4gICAgICAgICAgICAgICAgY2hlY2tEaWdpdCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBidWYuYXBwZW5kKGNoZWNrRGlnaXQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIEFJMDFkZWNvZGVyLkdUSU5fU0laRSA9IDQwO1xuXG4gICAgY2xhc3MgQUkwMUFuZE90aGVyQUlzIGV4dGVuZHMgQUkwMWRlY29kZXIge1xuICAgICAgICAvLyB0aGUgc2Vjb25kIG9uZSBpcyB0aGUgZW5jb2RhdGlvbiBtZXRob2QsIGFuZCB0aGUgb3RoZXIgdHdvIGFyZSBmb3IgdGhlIHZhcmlhYmxlIGxlbmd0aFxuICAgICAgICBjb25zdHJ1Y3RvcihpbmZvcm1hdGlvbikge1xuICAgICAgICAgICAgc3VwZXIoaW5mb3JtYXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIHBhcnNlSW5mb3JtYXRpb24oKSB7XG4gICAgICAgICAgICBsZXQgYnVmZiA9IG5ldyBTdHJpbmdCdWlsZGVyKCk7XG4gICAgICAgICAgICBidWZmLmFwcGVuZCgnKDAxKScpO1xuICAgICAgICAgICAgbGV0IGluaXRpYWxHdGluUG9zaXRpb24gPSBidWZmLmxlbmd0aCgpO1xuICAgICAgICAgICAgbGV0IGZpcnN0R3RpbkRpZ2l0ID0gdGhpcy5nZXRHZW5lcmFsRGVjb2RlcigpLmV4dHJhY3ROdW1lcmljVmFsdWVGcm9tQml0QXJyYXkoQUkwMUFuZE90aGVyQUlzLkhFQURFUl9TSVpFLCA0KTtcbiAgICAgICAgICAgIGJ1ZmYuYXBwZW5kKGZpcnN0R3RpbkRpZ2l0KTtcbiAgICAgICAgICAgIHRoaXMuZW5jb2RlQ29tcHJlc3NlZEd0aW5XaXRob3V0QUkoYnVmZiwgQUkwMUFuZE90aGVyQUlzLkhFQURFUl9TSVpFICsgNCwgaW5pdGlhbEd0aW5Qb3NpdGlvbik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRHZW5lcmFsRGVjb2RlcigpLmRlY29kZUFsbENvZGVzKGJ1ZmYsIEFJMDFBbmRPdGhlckFJcy5IRUFERVJfU0laRSArIDQ0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBBSTAxQW5kT3RoZXJBSXMuSEVBREVSX1NJWkUgPSAxICsgMSArIDI7IC8vIGZpcnN0IGJpdCBlbmNvZGVzIHRoZSBsaW5rYWdlIGZsYWcsXG5cbiAgICBjbGFzcyBBbnlBSURlY29kZXIgZXh0ZW5kcyBBYnN0cmFjdEV4cGFuZGVkRGVjb2RlciB7XG4gICAgICAgIGNvbnN0cnVjdG9yKGluZm9ybWF0aW9uKSB7XG4gICAgICAgICAgICBzdXBlcihpbmZvcm1hdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgcGFyc2VJbmZvcm1hdGlvbigpIHtcbiAgICAgICAgICAgIGxldCBidWYgPSBuZXcgU3RyaW5nQnVpbGRlcigpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0R2VuZXJhbERlY29kZXIoKS5kZWNvZGVBbGxDb2RlcyhidWYsIEFueUFJRGVjb2Rlci5IRUFERVJfU0laRSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgQW55QUlEZWNvZGVyLkhFQURFUl9TSVpFID0gMiArIDEgKyAyO1xuXG4gICAgY2xhc3MgQUkwMXdlaWdodERlY29kZXIgZXh0ZW5kcyBBSTAxZGVjb2RlciB7XG4gICAgICAgIGNvbnN0cnVjdG9yKGluZm9ybWF0aW9uKSB7XG4gICAgICAgICAgICBzdXBlcihpbmZvcm1hdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgZW5jb2RlQ29tcHJlc3NlZFdlaWdodChidWYsIGN1cnJlbnRQb3MsIHdlaWdodFNpemUpIHtcbiAgICAgICAgICAgIGxldCBvcmlnaW5hbFdlaWdodE51bWVyaWMgPSB0aGlzLmdldEdlbmVyYWxEZWNvZGVyKCkuZXh0cmFjdE51bWVyaWNWYWx1ZUZyb21CaXRBcnJheShjdXJyZW50UG9zLCB3ZWlnaHRTaXplKTtcbiAgICAgICAgICAgIHRoaXMuYWRkV2VpZ2h0Q29kZShidWYsIG9yaWdpbmFsV2VpZ2h0TnVtZXJpYyk7XG4gICAgICAgICAgICBsZXQgd2VpZ2h0TnVtZXJpYyA9IHRoaXMuY2hlY2tXZWlnaHQob3JpZ2luYWxXZWlnaHROdW1lcmljKTtcbiAgICAgICAgICAgIGxldCBjdXJyZW50RGl2aXNvciA9IDEwMDAwMDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNTsgKytpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHdlaWdodE51bWVyaWMgLyBjdXJyZW50RGl2aXNvciA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBidWYuYXBwZW5kKCcwJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN1cnJlbnREaXZpc29yIC89IDEwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnVmLmFwcGVuZCh3ZWlnaHROdW1lcmljKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNsYXNzIEFJMDEzeDB4RGVjb2RlciBleHRlbmRzIEFJMDF3ZWlnaHREZWNvZGVyIHtcbiAgICAgICAgY29uc3RydWN0b3IoaW5mb3JtYXRpb24pIHtcbiAgICAgICAgICAgIHN1cGVyKGluZm9ybWF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBwYXJzZUluZm9ybWF0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZ2V0SW5mb3JtYXRpb24oKS5nZXRTaXplKCkgIT0gQUkwMTN4MHhEZWNvZGVyLkhFQURFUl9TSVpFICsgQUkwMXdlaWdodERlY29kZXIuR1RJTl9TSVpFICsgQUkwMTN4MHhEZWNvZGVyLldFSUdIVF9TSVpFKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgYnVmID0gbmV3IFN0cmluZ0J1aWxkZXIoKTtcbiAgICAgICAgICAgIHRoaXMuZW5jb2RlQ29tcHJlc3NlZEd0aW4oYnVmLCBBSTAxM3gweERlY29kZXIuSEVBREVSX1NJWkUpO1xuICAgICAgICAgICAgdGhpcy5lbmNvZGVDb21wcmVzc2VkV2VpZ2h0KGJ1ZiwgQUkwMTN4MHhEZWNvZGVyLkhFQURFUl9TSVpFICsgQUkwMXdlaWdodERlY29kZXIuR1RJTl9TSVpFLCBBSTAxM3gweERlY29kZXIuV0VJR0hUX1NJWkUpO1xuICAgICAgICAgICAgcmV0dXJuIGJ1Zi50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIEFJMDEzeDB4RGVjb2Rlci5IRUFERVJfU0laRSA9IDQgKyAxO1xuICAgIEFJMDEzeDB4RGVjb2Rlci5XRUlHSFRfU0laRSA9IDE1O1xuXG4gICAgY2xhc3MgQUkwMTMxMDNkZWNvZGVyIGV4dGVuZHMgQUkwMTN4MHhEZWNvZGVyIHtcbiAgICAgICAgY29uc3RydWN0b3IoaW5mb3JtYXRpb24pIHtcbiAgICAgICAgICAgIHN1cGVyKGluZm9ybWF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBhZGRXZWlnaHRDb2RlKGJ1Ziwgd2VpZ2h0KSB7XG4gICAgICAgICAgICBidWYuYXBwZW5kKCcoMzEwMyknKTtcbiAgICAgICAgfVxuICAgICAgICBjaGVja1dlaWdodCh3ZWlnaHQpIHtcbiAgICAgICAgICAgIHJldHVybiB3ZWlnaHQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjbGFzcyBBSTAxMzIweERlY29kZXIgZXh0ZW5kcyBBSTAxM3gweERlY29kZXIge1xuICAgICAgICBjb25zdHJ1Y3RvcihpbmZvcm1hdGlvbikge1xuICAgICAgICAgICAgc3VwZXIoaW5mb3JtYXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGFkZFdlaWdodENvZGUoYnVmLCB3ZWlnaHQpIHtcbiAgICAgICAgICAgIGlmICh3ZWlnaHQgPCAxMDAwMCkge1xuICAgICAgICAgICAgICAgIGJ1Zi5hcHBlbmQoJygzMjAyKScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYnVmLmFwcGVuZCgnKDMyMDMpJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2hlY2tXZWlnaHQod2VpZ2h0KSB7XG4gICAgICAgICAgICBpZiAod2VpZ2h0IDwgMTAwMDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gd2VpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHdlaWdodCAtIDEwMDAwO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY2xhc3MgQUkwMTM5MnhEZWNvZGVyIGV4dGVuZHMgQUkwMWRlY29kZXIge1xuICAgICAgICBjb25zdHJ1Y3RvcihpbmZvcm1hdGlvbikge1xuICAgICAgICAgICAgc3VwZXIoaW5mb3JtYXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIHBhcnNlSW5mb3JtYXRpb24oKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5nZXRJbmZvcm1hdGlvbigpLmdldFNpemUoKSA8IEFJMDEzOTJ4RGVjb2Rlci5IRUFERVJfU0laRSArIEFJMDFkZWNvZGVyLkdUSU5fU0laRSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGJ1ZiA9IG5ldyBTdHJpbmdCdWlsZGVyKCk7XG4gICAgICAgICAgICB0aGlzLmVuY29kZUNvbXByZXNzZWRHdGluKGJ1ZiwgQUkwMTM5MnhEZWNvZGVyLkhFQURFUl9TSVpFKTtcbiAgICAgICAgICAgIGxldCBsYXN0QUlkaWdpdCA9IHRoaXMuZ2V0R2VuZXJhbERlY29kZXIoKS5leHRyYWN0TnVtZXJpY1ZhbHVlRnJvbUJpdEFycmF5KEFJMDEzOTJ4RGVjb2Rlci5IRUFERVJfU0laRSArIEFJMDFkZWNvZGVyLkdUSU5fU0laRSwgQUkwMTM5MnhEZWNvZGVyLkxBU1RfRElHSVRfU0laRSk7XG4gICAgICAgICAgICBidWYuYXBwZW5kKCcoMzkyJyk7XG4gICAgICAgICAgICBidWYuYXBwZW5kKGxhc3RBSWRpZ2l0KTtcbiAgICAgICAgICAgIGJ1Zi5hcHBlbmQoJyknKTtcbiAgICAgICAgICAgIGxldCBkZWNvZGVkSW5mb3JtYXRpb24gPSB0aGlzLmdldEdlbmVyYWxEZWNvZGVyKCkuZGVjb2RlR2VuZXJhbFB1cnBvc2VGaWVsZChBSTAxMzkyeERlY29kZXIuSEVBREVSX1NJWkUgKyBBSTAxZGVjb2Rlci5HVElOX1NJWkUgKyBBSTAxMzkyeERlY29kZXIuTEFTVF9ESUdJVF9TSVpFLCBudWxsKTtcbiAgICAgICAgICAgIGJ1Zi5hcHBlbmQoZGVjb2RlZEluZm9ybWF0aW9uLmdldE5ld1N0cmluZygpKTtcbiAgICAgICAgICAgIHJldHVybiBidWYudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBBSTAxMzkyeERlY29kZXIuSEVBREVSX1NJWkUgPSA1ICsgMSArIDI7XG4gICAgQUkwMTM5MnhEZWNvZGVyLkxBU1RfRElHSVRfU0laRSA9IDI7XG5cbiAgICBjbGFzcyBBSTAxMzkzeERlY29kZXIgZXh0ZW5kcyBBSTAxZGVjb2RlciB7XG4gICAgICAgIGNvbnN0cnVjdG9yKGluZm9ybWF0aW9uKSB7XG4gICAgICAgICAgICBzdXBlcihpbmZvcm1hdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgcGFyc2VJbmZvcm1hdGlvbigpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmdldEluZm9ybWF0aW9uKCkuZ2V0U2l6ZSgpIDwgQUkwMTM5M3hEZWNvZGVyLkhFQURFUl9TSVpFICsgQUkwMWRlY29kZXIuR1RJTl9TSVpFKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgYnVmID0gbmV3IFN0cmluZ0J1aWxkZXIoKTtcbiAgICAgICAgICAgIHRoaXMuZW5jb2RlQ29tcHJlc3NlZEd0aW4oYnVmLCBBSTAxMzkzeERlY29kZXIuSEVBREVSX1NJWkUpO1xuICAgICAgICAgICAgbGV0IGxhc3RBSWRpZ2l0ID0gdGhpcy5nZXRHZW5lcmFsRGVjb2RlcigpLmV4dHJhY3ROdW1lcmljVmFsdWVGcm9tQml0QXJyYXkoQUkwMTM5M3hEZWNvZGVyLkhFQURFUl9TSVpFICsgQUkwMWRlY29kZXIuR1RJTl9TSVpFLCBBSTAxMzkzeERlY29kZXIuTEFTVF9ESUdJVF9TSVpFKTtcbiAgICAgICAgICAgIGJ1Zi5hcHBlbmQoJygzOTMnKTtcbiAgICAgICAgICAgIGJ1Zi5hcHBlbmQobGFzdEFJZGlnaXQpO1xuICAgICAgICAgICAgYnVmLmFwcGVuZCgnKScpO1xuICAgICAgICAgICAgbGV0IGZpcnN0VGhyZWVEaWdpdHMgPSB0aGlzLmdldEdlbmVyYWxEZWNvZGVyKCkuZXh0cmFjdE51bWVyaWNWYWx1ZUZyb21CaXRBcnJheShBSTAxMzkzeERlY29kZXIuSEVBREVSX1NJWkUgKyBBSTAxZGVjb2Rlci5HVElOX1NJWkUgKyBBSTAxMzkzeERlY29kZXIuTEFTVF9ESUdJVF9TSVpFLCBBSTAxMzkzeERlY29kZXIuRklSU1RfVEhSRUVfRElHSVRTX1NJWkUpO1xuICAgICAgICAgICAgaWYgKGZpcnN0VGhyZWVEaWdpdHMgLyAxMDAgPT0gMCkge1xuICAgICAgICAgICAgICAgIGJ1Zi5hcHBlbmQoJzAnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmaXJzdFRocmVlRGlnaXRzIC8gMTAgPT0gMCkge1xuICAgICAgICAgICAgICAgIGJ1Zi5hcHBlbmQoJzAnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ1Zi5hcHBlbmQoZmlyc3RUaHJlZURpZ2l0cyk7XG4gICAgICAgICAgICBsZXQgZ2VuZXJhbEluZm9ybWF0aW9uID0gdGhpcy5nZXRHZW5lcmFsRGVjb2RlcigpLmRlY29kZUdlbmVyYWxQdXJwb3NlRmllbGQoQUkwMTM5M3hEZWNvZGVyLkhFQURFUl9TSVpFICsgQUkwMWRlY29kZXIuR1RJTl9TSVpFICsgQUkwMTM5M3hEZWNvZGVyLkxBU1RfRElHSVRfU0laRSArIEFJMDEzOTN4RGVjb2Rlci5GSVJTVF9USFJFRV9ESUdJVFNfU0laRSwgbnVsbCk7XG4gICAgICAgICAgICBidWYuYXBwZW5kKGdlbmVyYWxJbmZvcm1hdGlvbi5nZXROZXdTdHJpbmcoKSk7XG4gICAgICAgICAgICByZXR1cm4gYnVmLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgQUkwMTM5M3hEZWNvZGVyLkhFQURFUl9TSVpFID0gNSArIDEgKyAyO1xuICAgIEFJMDEzOTN4RGVjb2Rlci5MQVNUX0RJR0lUX1NJWkUgPSAyO1xuICAgIEFJMDEzOTN4RGVjb2Rlci5GSVJTVF9USFJFRV9ESUdJVFNfU0laRSA9IDEwO1xuXG4gICAgY2xhc3MgQUkwMTN4MHgxeERlY29kZXIgZXh0ZW5kcyBBSTAxd2VpZ2h0RGVjb2RlciB7XG4gICAgICAgIGNvbnN0cnVjdG9yKGluZm9ybWF0aW9uLCBmaXJzdEFJZGlnaXRzLCBkYXRlQ29kZSkge1xuICAgICAgICAgICAgc3VwZXIoaW5mb3JtYXRpb24pO1xuICAgICAgICAgICAgdGhpcy5kYXRlQ29kZSA9IGRhdGVDb2RlO1xuICAgICAgICAgICAgdGhpcy5maXJzdEFJZGlnaXRzID0gZmlyc3RBSWRpZ2l0cztcbiAgICAgICAgfVxuICAgICAgICBwYXJzZUluZm9ybWF0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZ2V0SW5mb3JtYXRpb24oKS5nZXRTaXplKCkgIT0gQUkwMTN4MHgxeERlY29kZXIuSEVBREVSX1NJWkUgKyBBSTAxM3gweDF4RGVjb2Rlci5HVElOX1NJWkUgKyBBSTAxM3gweDF4RGVjb2Rlci5XRUlHSFRfU0laRSArIEFJMDEzeDB4MXhEZWNvZGVyLkRBVEVfU0laRSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGJ1ZiA9IG5ldyBTdHJpbmdCdWlsZGVyKCk7XG4gICAgICAgICAgICB0aGlzLmVuY29kZUNvbXByZXNzZWRHdGluKGJ1ZiwgQUkwMTN4MHgxeERlY29kZXIuSEVBREVSX1NJWkUpO1xuICAgICAgICAgICAgdGhpcy5lbmNvZGVDb21wcmVzc2VkV2VpZ2h0KGJ1ZiwgQUkwMTN4MHgxeERlY29kZXIuSEVBREVSX1NJWkUgKyBBSTAxM3gweDF4RGVjb2Rlci5HVElOX1NJWkUsIEFJMDEzeDB4MXhEZWNvZGVyLldFSUdIVF9TSVpFKTtcbiAgICAgICAgICAgIHRoaXMuZW5jb2RlQ29tcHJlc3NlZERhdGUoYnVmLCBBSTAxM3gweDF4RGVjb2Rlci5IRUFERVJfU0laRSArIEFJMDEzeDB4MXhEZWNvZGVyLkdUSU5fU0laRSArIEFJMDEzeDB4MXhEZWNvZGVyLldFSUdIVF9TSVpFKTtcbiAgICAgICAgICAgIHJldHVybiBidWYudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBlbmNvZGVDb21wcmVzc2VkRGF0ZShidWYsIGN1cnJlbnRQb3MpIHtcbiAgICAgICAgICAgIGxldCBudW1lcmljRGF0ZSA9IHRoaXMuZ2V0R2VuZXJhbERlY29kZXIoKS5leHRyYWN0TnVtZXJpY1ZhbHVlRnJvbUJpdEFycmF5KGN1cnJlbnRQb3MsIEFJMDEzeDB4MXhEZWNvZGVyLkRBVEVfU0laRSk7XG4gICAgICAgICAgICBpZiAobnVtZXJpY0RhdGUgPT0gMzg0MDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBidWYuYXBwZW5kKCcoJyk7XG4gICAgICAgICAgICBidWYuYXBwZW5kKHRoaXMuZGF0ZUNvZGUpO1xuICAgICAgICAgICAgYnVmLmFwcGVuZCgnKScpO1xuICAgICAgICAgICAgbGV0IGRheSA9IG51bWVyaWNEYXRlICUgMzI7XG4gICAgICAgICAgICBudW1lcmljRGF0ZSAvPSAzMjtcbiAgICAgICAgICAgIGxldCBtb250aCA9IG51bWVyaWNEYXRlICUgMTIgKyAxO1xuICAgICAgICAgICAgbnVtZXJpY0RhdGUgLz0gMTI7XG4gICAgICAgICAgICBsZXQgeWVhciA9IG51bWVyaWNEYXRlO1xuICAgICAgICAgICAgaWYgKHllYXIgLyAxMCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgYnVmLmFwcGVuZCgnMCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnVmLmFwcGVuZCh5ZWFyKTtcbiAgICAgICAgICAgIGlmIChtb250aCAvIDEwID09IDApIHtcbiAgICAgICAgICAgICAgICBidWYuYXBwZW5kKCcwJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBidWYuYXBwZW5kKG1vbnRoKTtcbiAgICAgICAgICAgIGlmIChkYXkgLyAxMCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgYnVmLmFwcGVuZCgnMCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnVmLmFwcGVuZChkYXkpO1xuICAgICAgICB9XG4gICAgICAgIGFkZFdlaWdodENvZGUoYnVmLCB3ZWlnaHQpIHtcbiAgICAgICAgICAgIGJ1Zi5hcHBlbmQoJygnKTtcbiAgICAgICAgICAgIGJ1Zi5hcHBlbmQodGhpcy5maXJzdEFJZGlnaXRzKTtcbiAgICAgICAgICAgIGJ1Zi5hcHBlbmQod2VpZ2h0IC8gMTAwMDAwKTtcbiAgICAgICAgICAgIGJ1Zi5hcHBlbmQoJyknKTtcbiAgICAgICAgfVxuICAgICAgICBjaGVja1dlaWdodCh3ZWlnaHQpIHtcbiAgICAgICAgICAgIHJldHVybiB3ZWlnaHQgJSAxMDAwMDA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgQUkwMTN4MHgxeERlY29kZXIuSEVBREVSX1NJWkUgPSA3ICsgMTtcbiAgICBBSTAxM3gweDF4RGVjb2Rlci5XRUlHSFRfU0laRSA9IDIwO1xuICAgIEFJMDEzeDB4MXhEZWNvZGVyLkRBVEVfU0laRSA9IDE2O1xuXG4gICAgZnVuY3Rpb24gY3JlYXRlRGVjb2RlcihpbmZvcm1hdGlvbikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKGluZm9ybWF0aW9uLmdldCgxKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQUkwMUFuZE90aGVyQUlzKGluZm9ybWF0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaW5mb3JtYXRpb24uZ2V0KDIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBbnlBSURlY29kZXIoaW5mb3JtYXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGZvdXJCaXRFbmNvZGF0aW9uTWV0aG9kID0gR2VuZXJhbEFwcElkRGVjb2Rlci5leHRyYWN0TnVtZXJpY1ZhbHVlRnJvbUJpdEFycmF5KGluZm9ybWF0aW9uLCAxLCA0KTtcbiAgICAgICAgICAgIHN3aXRjaCAoZm91ckJpdEVuY29kYXRpb25NZXRob2QpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IHJldHVybiBuZXcgQUkwMTMxMDNkZWNvZGVyKGluZm9ybWF0aW9uKTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IHJldHVybiBuZXcgQUkwMTMyMHhEZWNvZGVyKGluZm9ybWF0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBmaXZlQml0RW5jb2RhdGlvbk1ldGhvZCA9IEdlbmVyYWxBcHBJZERlY29kZXIuZXh0cmFjdE51bWVyaWNWYWx1ZUZyb21CaXRBcnJheShpbmZvcm1hdGlvbiwgMSwgNSk7XG4gICAgICAgICAgICBzd2l0Y2ggKGZpdmVCaXRFbmNvZGF0aW9uTWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxMjogcmV0dXJuIG5ldyBBSTAxMzkyeERlY29kZXIoaW5mb3JtYXRpb24pO1xuICAgICAgICAgICAgICAgIGNhc2UgMTM6IHJldHVybiBuZXcgQUkwMTM5M3hEZWNvZGVyKGluZm9ybWF0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBzZXZlbkJpdEVuY29kYXRpb25NZXRob2QgPSBHZW5lcmFsQXBwSWREZWNvZGVyLmV4dHJhY3ROdW1lcmljVmFsdWVGcm9tQml0QXJyYXkoaW5mb3JtYXRpb24sIDEsIDcpO1xuICAgICAgICAgICAgc3dpdGNoIChzZXZlbkJpdEVuY29kYXRpb25NZXRob2QpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDU2OiByZXR1cm4gbmV3IEFJMDEzeDB4MXhEZWNvZGVyKGluZm9ybWF0aW9uLCAnMzEwJywgJzExJyk7XG4gICAgICAgICAgICAgICAgY2FzZSA1NzogcmV0dXJuIG5ldyBBSTAxM3gweDF4RGVjb2RlcihpbmZvcm1hdGlvbiwgJzMyMCcsICcxMScpO1xuICAgICAgICAgICAgICAgIGNhc2UgNTg6IHJldHVybiBuZXcgQUkwMTN4MHgxeERlY29kZXIoaW5mb3JtYXRpb24sICczMTAnLCAnMTMnKTtcbiAgICAgICAgICAgICAgICBjYXNlIDU5OiByZXR1cm4gbmV3IEFJMDEzeDB4MXhEZWNvZGVyKGluZm9ybWF0aW9uLCAnMzIwJywgJzEzJyk7XG4gICAgICAgICAgICAgICAgY2FzZSA2MDogcmV0dXJuIG5ldyBBSTAxM3gweDF4RGVjb2RlcihpbmZvcm1hdGlvbiwgJzMxMCcsICcxNScpO1xuICAgICAgICAgICAgICAgIGNhc2UgNjE6IHJldHVybiBuZXcgQUkwMTN4MHgxeERlY29kZXIoaW5mb3JtYXRpb24sICczMjAnLCAnMTUnKTtcbiAgICAgICAgICAgICAgICBjYXNlIDYyOiByZXR1cm4gbmV3IEFJMDEzeDB4MXhEZWNvZGVyKGluZm9ybWF0aW9uLCAnMzEwJywgJzE3Jyk7XG4gICAgICAgICAgICAgICAgY2FzZSA2MzogcmV0dXJuIG5ldyBBSTAxM3gweDF4RGVjb2RlcihpbmZvcm1hdGlvbiwgJzMyMCcsICcxNycpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhlKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsU3RhdGVFeGNlcHRpb24oJ3Vua25vd24gZGVjb2RlcjogJyArIGluZm9ybWF0aW9uKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNsYXNzIEV4cGFuZGVkUGFpciB7XG4gICAgICAgIGNvbnN0cnVjdG9yKGxlZnRDaGFyLCByaWdodENoYXIsIGZpbmRlclBhdHRlciwgbWF5QmVMYXN0KSB7XG4gICAgICAgICAgICB0aGlzLmxlZnRjaGFyID0gbGVmdENoYXI7XG4gICAgICAgICAgICB0aGlzLnJpZ2h0Y2hhciA9IHJpZ2h0Q2hhcjtcbiAgICAgICAgICAgIHRoaXMuZmluZGVycGF0dGVybiA9IGZpbmRlclBhdHRlcjtcbiAgICAgICAgICAgIHRoaXMubWF5YmVMYXN0ID0gbWF5QmVMYXN0O1xuICAgICAgICB9XG4gICAgICAgIG1heUJlTGFzdCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1heWJlTGFzdDtcbiAgICAgICAgfVxuICAgICAgICBnZXRMZWZ0Q2hhcigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxlZnRjaGFyO1xuICAgICAgICB9XG4gICAgICAgIGdldFJpZ2h0Q2hhcigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJpZ2h0Y2hhcjtcbiAgICAgICAgfVxuICAgICAgICBnZXRGaW5kZXJQYXR0ZXJuKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmluZGVycGF0dGVybjtcbiAgICAgICAgfVxuICAgICAgICBtdXN0QmVMYXN0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmlnaHRjaGFyID09IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdG9TdHJpbmcoKSB7XG4gICAgICAgICAgICByZXR1cm4gJ1sgJyArIHRoaXMubGVmdGNoYXIgKyAnLCAnICsgdGhpcy5yaWdodGNoYXIgKyAnIDogJyArICh0aGlzLmZpbmRlcnBhdHRlcm4gPT0gbnVsbCA/ICdudWxsJyA6IHRoaXMuZmluZGVycGF0dGVybi5nZXRWYWx1ZSgpKSArICcgXSc7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGVxdWFscyhvMSwgbzIpIHtcbiAgICAgICAgICAgIGlmICghKG8xIGluc3RhbmNlb2YgRXhwYW5kZWRQYWlyKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBFeHBhbmRlZFBhaXIuZXF1YWxzT3JOdWxsKG8xLmxlZnRjaGFyLCBvMi5sZWZ0Y2hhcikgJiZcbiAgICAgICAgICAgICAgICBFeHBhbmRlZFBhaXIuZXF1YWxzT3JOdWxsKG8xLnJpZ2h0Y2hhciwgbzIucmlnaHRjaGFyKSAmJlxuICAgICAgICAgICAgICAgIEV4cGFuZGVkUGFpci5lcXVhbHNPck51bGwobzEuZmluZGVycGF0dGVybiwgbzIuZmluZGVycGF0dGVybik7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGVxdWFsc09yTnVsbChvMSwgbzIpIHtcbiAgICAgICAgICAgIHJldHVybiBvMSA9PT0gbnVsbCA/IG8yID09PSBudWxsIDogRXhwYW5kZWRQYWlyLmVxdWFscyhvMSwgbzIpO1xuICAgICAgICB9XG4gICAgICAgIGhhc2hDb2RlKCkge1xuICAgICAgICAgICAgLy8gcmV0dXJuIEV4cGFuZGVkUGFpci5oYXNoTm90TnVsbChsZWZ0Q2hhcikgXiBoYXNoTm90TnVsbChyaWdodENoYXIpIF4gaGFzaE5vdE51bGwoZmluZGVyUGF0dGVybik7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSB0aGlzLmxlZnRjaGFyLmdldFZhbHVlKCkgXiB0aGlzLnJpZ2h0Y2hhci5nZXRWYWx1ZSgpIF4gdGhpcy5maW5kZXJwYXR0ZXJuLmdldFZhbHVlKCk7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjbGFzcyBFeHBhbmRlZFJvdyB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHBhaXJzLCByb3dOdW1iZXIsIHdhc1JldmVyc2VkKSB7XG4gICAgICAgICAgICB0aGlzLnBhaXJzID0gcGFpcnM7XG4gICAgICAgICAgICB0aGlzLnJvd051bWJlciA9IHJvd051bWJlcjtcbiAgICAgICAgICAgIHRoaXMud2FzUmV2ZXJzZWQgPSB3YXNSZXZlcnNlZDtcbiAgICAgICAgfVxuICAgICAgICBnZXRQYWlycygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhaXJzO1xuICAgICAgICB9XG4gICAgICAgIGdldFJvd051bWJlcigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJvd051bWJlcjtcbiAgICAgICAgfVxuICAgICAgICBpc1JldmVyc2VkKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud2FzUmV2ZXJzZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY2hlY2sgaW1wbGVtZW50YXRpb25cbiAgICAgICAgaXNFcXVpdmFsZW50KG90aGVyUGFpcnMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNoZWNrRXF1YWxpdGl0eSh0aGlzLCBvdGhlclBhaXJzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBAT3ZlcnJpZGVcbiAgICAgICAgdG9TdHJpbmcoKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3sgJyArIHRoaXMucGFpcnMgKyAnIH0nO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUd28gcm93cyBhcmUgZXF1YWwgaWYgdGhleSBjb250YWluIHRoZSBzYW1lIHBhaXJzIGluIHRoZSBzYW1lIG9yZGVyLlxuICAgICAgICAgKi9cbiAgICAgICAgLy8gQE92ZXJyaWRlXG4gICAgICAgIC8vIGNoZWNrIGltcGxlbWVudGF0aW9uXG4gICAgICAgIGVxdWFscyhvMSwgbzIpIHtcbiAgICAgICAgICAgIGlmICghKG8xIGluc3RhbmNlb2YgRXhwYW5kZWRSb3cpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hlY2tFcXVhbGl0aXR5KG8xLCBvMikgJiYgbzEud2FzUmV2ZXJzZWQgPT09IG8yLndhc1JldmVyc2VkO1xuICAgICAgICB9XG4gICAgICAgIGNoZWNrRXF1YWxpdGl0eShwYWlyMSwgcGFpcjIpIHtcbiAgICAgICAgICAgIGlmICghcGFpcjEgfHwgIXBhaXIyKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgICAgICBwYWlyMS5mb3JFYWNoKChlMSwgaSkgPT4ge1xuICAgICAgICAgICAgICAgIHBhaXIyLmZvckVhY2goZTIgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZTEuZ2V0TGVmdENoYXIoKS5nZXRWYWx1ZSgpID09PSBlMi5nZXRMZWZ0Q2hhcigpLmdldFZhbHVlKCkgJiYgZTEuZ2V0UmlnaHRDaGFyKCkuZ2V0VmFsdWUoKSA9PT0gZTIuZ2V0UmlnaHRDaGFyKCkuZ2V0VmFsdWUoKSAmJiBlMS5nZXRGaW5kZXJQYXR0ZXIoKS5nZXRWYWx1ZSgpID09PSBlMi5nZXRGaW5kZXJQYXR0ZXIoKS5nZXRWYWx1ZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBpbXBvcnQgamF2YS51dGlsLkFycmF5TGlzdDtcbiAgICAvLyBpbXBvcnQgamF2YS51dGlsLkl0ZXJhdG9yO1xuICAgIC8vIGltcG9ydCBqYXZhLnV0aWwuTGlzdDtcbiAgICAvLyBpbXBvcnQgamF2YS51dGlsLk1hcDtcbiAgICAvLyBpbXBvcnQgamF2YS51dGlsLkNvbGxlY3Rpb25zO1xuICAgIGNsYXNzIFJTU0V4cGFuZGVkUmVhZGVyIGV4dGVuZHMgQWJzdHJhY3RSU1NSZWFkZXIge1xuICAgICAgICBjb25zdHJ1Y3Rvcih2ZXJib3NlKSB7XG4gICAgICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICAgICAgdGhpcy5wYWlycyA9IG5ldyBBcnJheShSU1NFeHBhbmRlZFJlYWRlci5NQVhfUEFJUlMpO1xuICAgICAgICAgICAgdGhpcy5yb3dzID0gbmV3IEFycmF5KCk7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0RW5kID0gWzJdO1xuICAgICAgICAgICAgdGhpcy52ZXJib3NlID0gKHZlcmJvc2UgPT09IHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGRlY29kZVJvdyhyb3dOdW1iZXIsIHJvdywgaGludHMpIHtcbiAgICAgICAgICAgIC8vIFJvd3MgY2FuIHN0YXJ0IHdpdGggZXZlbiBwYXR0ZXJuIGluIGNhc2UgaW4gcHJldiByb3dzIHRoZXJlIHdoZXJlIG9kZCBudW1iZXIgb2YgcGF0dGVycy5cbiAgICAgICAgICAgIC8vIFNvIGxldHMgdHJ5IHR3aWNlXG4gICAgICAgICAgICAvLyB0aGlzLnBhaXJzLmNsZWFyKCk7XG4gICAgICAgICAgICB0aGlzLnBhaXJzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0RnJvbUV2ZW4gPSBmYWxzZTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFJTU0V4cGFuZGVkUmVhZGVyLmNvbnN0cnVjdFJlc3VsdCh0aGlzLmRlY29kZVJvdzJwYWlycyhyb3dOdW1iZXIsIHJvdykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAvLyBPS1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnZlcmJvc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5wYWlycy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgdGhpcy5zdGFydEZyb21FdmVuID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiBSU1NFeHBhbmRlZFJlYWRlci5jb25zdHJ1Y3RSZXN1bHQodGhpcy5kZWNvZGVSb3cycGFpcnMocm93TnVtYmVyLCByb3cpKTtcbiAgICAgICAgfVxuICAgICAgICByZXNldCgpIHtcbiAgICAgICAgICAgIHRoaXMucGFpcnMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIHRoaXMucm93cy5sZW5ndGggPSAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vdCBwcml2YXRlIGZvciB0ZXN0aW5nXG4gICAgICAgIGRlY29kZVJvdzJwYWlycyhyb3dOdW1iZXIsIHJvdykge1xuICAgICAgICAgICAgbGV0IGRvbmUgPSBmYWxzZTtcbiAgICAgICAgICAgIHdoaWxlICghZG9uZSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFpcnMucHVzaCh0aGlzLnJldHJpZXZlTmV4dFBhaXIocm93LCB0aGlzLnBhaXJzLCByb3dOdW1iZXIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIE5vdEZvdW5kRXhjZXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMucGFpcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBleGl0IHRoaXMgbG9vcCB3aGVuIHJldHJpZXZlTmV4dFBhaXIoKSBmYWlscyBhbmQgdGhyb3dzXG4gICAgICAgICAgICAgICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRPRE86IHZlcmlmeSBzZXF1ZW5jZSBvZiBmaW5kZXIgcGF0dGVybnMgYXMgaW4gY2hlY2tQYWlyU2VxdWVuY2UoKVxuICAgICAgICAgICAgaWYgKHRoaXMuY2hlY2tDaGVja3N1bSgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFpcnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgdHJ5U3RhY2tlZERlY29kZTtcbiAgICAgICAgICAgIGlmICh0aGlzLnJvd3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdHJ5U3RhY2tlZERlY29kZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0cnlTdGFja2VkRGVjb2RlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBsZXQgdHJ5U3RhY2tlZERlY29kZSA9ICF0aGlzLnJvd3MuaXNFbXB0eSgpO1xuICAgICAgICAgICAgdGhpcy5zdG9yZVJvdyhyb3dOdW1iZXIsIGZhbHNlKTsgLy8gVE9ETzogZGVhbCB3aXRoIHJldmVyc2VkIHJvd3NcbiAgICAgICAgICAgIGlmICh0cnlTdGFja2VkRGVjb2RlKSB7XG4gICAgICAgICAgICAgICAgLy8gV2hlbiB0aGUgaW1hZ2UgaXMgMTgwLXJvdGF0ZWQsIHRoZW4gcm93cyBhcmUgc29ydGVkIGluIHdyb25nIGRpcmVjdGlvbi5cbiAgICAgICAgICAgICAgICAvLyBUcnkgdHdpY2Ugd2l0aCBib3RoIHRoZSBkaXJlY3Rpb25zLlxuICAgICAgICAgICAgICAgIGxldCBwcyA9IHRoaXMuY2hlY2tSb3dzQm9vbGVhbihmYWxzZSk7XG4gICAgICAgICAgICAgICAgaWYgKHBzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwcyA9IHRoaXMuY2hlY2tSb3dzQm9vbGVhbih0cnVlKTtcbiAgICAgICAgICAgICAgICBpZiAocHMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTmVlZCB0byBWZXJpZnlcbiAgICAgICAgY2hlY2tSb3dzQm9vbGVhbihyZXZlcnNlKSB7XG4gICAgICAgICAgICAvLyBMaW1pdCBudW1iZXIgb2Ygcm93cyB3ZSBhcmUgY2hlY2tpbmdcbiAgICAgICAgICAgIC8vIFdlIHVzZSByZWN1cnNpdmUgYWxnb3JpdGhtIHdpdGggcHVyZSBjb21wbGV4aXR5IGFuZCBkb24ndCB3YW50IGl0IHRvIHRha2UgZm9yZXZlclxuICAgICAgICAgICAgLy8gU3RhY2tlZCBiYXJjb2RlIGNhbiBoYXZlIHVwIHRvIDExIHJvd3MsIHNvIDI1IHNlZW1zIHJlYXNvbmFibGUgZW5vdWdoXG4gICAgICAgICAgICBpZiAodGhpcy5yb3dzLmxlbmd0aCA+IDI1KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yb3dzLmxlbmd0aCA9IDA7IC8vIFdlIHdpbGwgbmV2ZXIgaGF2ZSBhIGNoYW5jZSB0byBnZXQgcmVzdWx0LCBzbyBjbGVhciBpdFxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5wYWlycy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgaWYgKHJldmVyc2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJvd3MgPSB0aGlzLnJvd3MucmV2ZXJzZSgpO1xuICAgICAgICAgICAgICAgIC8vIENvbGxlY3Rpb25zLnJldmVyc2UodGhpcy5yb3dzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBwcyA9IG51bGw7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHBzID0gdGhpcy5jaGVja1Jvd3MobmV3IEFycmF5KCksIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAvLyBPS1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnZlcmJvc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJldmVyc2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJvd3MgPSB0aGlzLnJvd3MucmV2ZXJzZSgpO1xuICAgICAgICAgICAgICAgIC8vIENvbGxlY3Rpb25zLnJldmVyc2UodGhpcy5yb3dzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwcztcbiAgICAgICAgfVxuICAgICAgICAvLyBUcnkgdG8gY29uc3RydWN0IGEgdmFsaWQgcm93cyBzZXF1ZW5jZVxuICAgICAgICAvLyBSZWN1cnNpb24gaXMgdXNlZCB0byBpbXBsZW1lbnQgYmFja3RyYWNraW5nXG4gICAgICAgIGNoZWNrUm93cyhjb2xsZWN0ZWRSb3dzLCBjdXJyZW50Um93KSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gY3VycmVudFJvdzsgaSA8IHRoaXMucm93cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCByb3cgPSB0aGlzLnJvd3NbaV07XG4gICAgICAgICAgICAgICAgdGhpcy5wYWlycy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGNvbGxlY3RlZFJvdyBvZiBjb2xsZWN0ZWRSb3dzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFpcnMucHVzaChjb2xsZWN0ZWRSb3cuZ2V0UGFpcnMoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMucGFpcnMucHVzaChyb3cuZ2V0UGFpcnMoKSk7XG4gICAgICAgICAgICAgICAgaWYgKCFSU1NFeHBhbmRlZFJlYWRlci5pc1ZhbGlkU2VxdWVuY2UodGhpcy5wYWlycykpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNoZWNrQ2hlY2tzdW0oKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYWlycztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IHJzID0gbmV3IEFycmF5KGNvbGxlY3RlZFJvd3MpO1xuICAgICAgICAgICAgICAgIHJzLnB1c2gocm93KTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAvLyBSZWN1cnNpb246IHRyeSB0byBhZGQgbW9yZSByb3dzXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNoZWNrUm93cyhycywgaSArIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSBmYWlsZWQsIHRyeSB0aGUgbmV4dCBjYW5kaWRhdGVcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudmVyYm9zZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXaGV0aGVyIHRoZSBwYWlycyBmb3JtIGEgdmFsaWQgZmluZCBwYXR0ZXJuIHNlcXVlbmNlLFxuICAgICAgICAvLyBlaXRoZXIgY29tcGxldGUgb3IgYSBwcmVmaXhcbiAgICAgICAgc3RhdGljIGlzVmFsaWRTZXF1ZW5jZShwYWlycykge1xuICAgICAgICAgICAgZm9yIChsZXQgc2VxdWVuY2Ugb2YgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVFRFUk5fU0VRVUVOQ0VTKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhaXJzLmxlbmd0aCA+IHNlcXVlbmNlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IHN0b3AgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgcGFpcnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhaXJzW2pdLmdldEZpbmRlclBhdHRlcm4oKS5nZXRWYWx1ZSgpICE9IHNlcXVlbmNlW2pdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdG9wID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc3RvcCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgc3RvcmVSb3cocm93TnVtYmVyLCB3YXNSZXZlcnNlZCkge1xuICAgICAgICAgICAgLy8gRGlzY2FyZCBpZiBkdXBsaWNhdGUgYWJvdmUgb3IgYmVsb3c7IG90aGVyd2lzZSBpbnNlcnQgaW4gb3JkZXIgYnkgcm93IG51bWJlci5cbiAgICAgICAgICAgIGxldCBpbnNlcnRQb3MgPSAwO1xuICAgICAgICAgICAgbGV0IHByZXZJc1NhbWUgPSBmYWxzZTtcbiAgICAgICAgICAgIGxldCBuZXh0SXNTYW1lID0gZmFsc2U7XG4gICAgICAgICAgICB3aGlsZSAoaW5zZXJ0UG9zIDwgdGhpcy5yb3dzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGxldCBlcm93ID0gdGhpcy5yb3dzW2luc2VydFBvc107XG4gICAgICAgICAgICAgICAgaWYgKGVyb3cuZ2V0Um93TnVtYmVyKCkgPiByb3dOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dElzU2FtZSA9IGVyb3cuaXNFcXVpdmFsZW50KHRoaXMucGFpcnMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcHJldklzU2FtZSA9IGVyb3cuaXNFcXVpdmFsZW50KHRoaXMucGFpcnMpO1xuICAgICAgICAgICAgICAgIGluc2VydFBvcysrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5leHRJc1NhbWUgfHwgcHJldklzU2FtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFdoZW4gdGhlIHJvdyB3YXMgcGFydGlhbGx5IGRlY29kZWQgKGUuZy4gMiBwYWlycyBmb3VuZCBpbnN0ZWFkIG9mIDMpLFxuICAgICAgICAgICAgLy8gaXQgd2lsbCBwcmV2ZW50IHVzIGZyb20gZGV0ZWN0aW5nIHRoZSBiYXJjb2RlLlxuICAgICAgICAgICAgLy8gVHJ5IHRvIG1lcmdlIHBhcnRpYWwgcm93c1xuICAgICAgICAgICAgLy8gQ2hlY2sgd2hldGhlciB0aGUgcm93IGlzIHBhcnQgb2YgYW4gYWxscmVhZHkgZGV0ZWN0ZWQgcm93XG4gICAgICAgICAgICBpZiAoUlNTRXhwYW5kZWRSZWFkZXIuaXNQYXJ0aWFsUm93KHRoaXMucGFpcnMsIHRoaXMucm93cykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJvd3MucHVzaChpbnNlcnRQb3MsIG5ldyBFeHBhbmRlZFJvdyh0aGlzLnBhaXJzLCByb3dOdW1iZXIsIHdhc1JldmVyc2VkKSk7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZVBhcnRpYWxSb3dzKHRoaXMucGFpcnMsIHRoaXMucm93cyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVtb3ZlIGFsbCB0aGUgcm93cyB0aGF0IGNvbnRhaW5zIG9ubHkgc3BlY2lmaWVkIHBhaXJzXG4gICAgICAgIHJlbW92ZVBhcnRpYWxSb3dzKHBhaXJzLCByb3dzKSB7XG4gICAgICAgICAgICAvLyBmb3IgKEl0ZXJhdG9yPEV4cGFuZGVkUm93PiBpdGVyYXRvciA9IHJvd3MuaXRlcmF0b3IoKTsgaXRlcmF0b3IuaGFzTmV4dCgpOykge1xuICAgICAgICAgICAgLy8gICBFeHBhbmRlZFJvdyByID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAgICAgLy8gICBpZiAoci5nZXRQYWlycygpLnNpemUoKSA9PSBwYWlycy5zaXplKCkpIHtcbiAgICAgICAgICAgIC8vICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIC8vICAgfVxuICAgICAgICAgICAgLy8gICBib29sZWFuIGFsbEZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vICAgZm9yIChFeHBhbmRlZFBhaXIgcCA6IHIuZ2V0UGFpcnMoKSkge1xuICAgICAgICAgICAgLy8gICAgIGJvb2xlYW4gZm91bmQgPSBmYWxzZTtcbiAgICAgICAgICAgIC8vICAgICBmb3IgKEV4cGFuZGVkUGFpciBwcCA6IHBhaXJzKSB7XG4gICAgICAgICAgICAvLyAgICAgICBpZiAocC5lcXVhbHMocHApKSB7XG4gICAgICAgICAgICAvLyAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvLyAgICAgICB9XG4gICAgICAgICAgICAvLyAgICAgfVxuICAgICAgICAgICAgLy8gICAgIGlmICghZm91bmQpIHtcbiAgICAgICAgICAgIC8vICAgICAgIGFsbEZvdW5kID0gZmFsc2U7XG4gICAgICAgICAgICAvLyAgICAgICBicmVhaztcbiAgICAgICAgICAgIC8vICAgICB9XG4gICAgICAgICAgICAvLyAgIH1cbiAgICAgICAgICAgIC8vICAgaWYgKGFsbEZvdW5kKSB7XG4gICAgICAgICAgICAvLyAgICAgLy8gJ3BhaXJzJyBjb250YWlucyBhbGwgdGhlIHBhaXJzIGZyb20gdGhlIHJvdyAncidcbiAgICAgICAgICAgIC8vICAgICBpdGVyYXRvci5yZW1vdmUoKTtcbiAgICAgICAgICAgIC8vICAgfVxuICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgZm9yIChsZXQgcm93IG9mIHJvd3MpIHtcbiAgICAgICAgICAgICAgICBpZiAocm93LmdldFBhaXJzKCkubGVuZ3RoID09PSBwYWlycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAobGV0IHAgb2Ygcm93LmdldFBhaXJzKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgcHAgb2YgcGFpcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChFeHBhbmRlZFBhaXIuZXF1YWxzKHAsIHBwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFJldHVybnMgdHJ1ZSB3aGVuIG9uZSBvZiB0aGUgcm93cyBhbHJlYWR5IGNvbnRhaW5zIGFsbCB0aGUgcGFpcnNcbiAgICAgICAgc3RhdGljIGlzUGFydGlhbFJvdyhwYWlycywgcm93cykge1xuICAgICAgICAgICAgZm9yIChsZXQgciBvZiByb3dzKSB7XG4gICAgICAgICAgICAgICAgbGV0IGFsbEZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBwIG9mIHBhaXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBmb3VuZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBwcCBvZiByLmdldFBhaXJzKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwLmVxdWFscyhwcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFmb3VuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWxsRm91bmQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChhbGxGb3VuZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgcm93ICdyJyBjb250YWluIGFsbCB0aGUgcGFpcnMgZnJvbSAncGFpcnMnXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBPbmx5IHVzZWQgZm9yIHVuaXQgdGVzdGluZ1xuICAgICAgICBnZXRSb3dzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucm93cztcbiAgICAgICAgfVxuICAgICAgICAvLyBOb3QgcHJpdmF0ZSBmb3IgdW5pdCB0ZXN0aW5nXG4gICAgICAgIHN0YXRpYyBjb25zdHJ1Y3RSZXN1bHQocGFpcnMpIHtcbiAgICAgICAgICAgIGxldCBiaW5hcnkgPSBCaXRBcnJheUJ1aWxkZXIuYnVpbGRCaXRBcnJheShwYWlycyk7XG4gICAgICAgICAgICBsZXQgZGVjb2RlciA9IGNyZWF0ZURlY29kZXIoYmluYXJ5KTtcbiAgICAgICAgICAgIGxldCByZXN1bHRpbmdTdHJpbmcgPSBkZWNvZGVyLnBhcnNlSW5mb3JtYXRpb24oKTtcbiAgICAgICAgICAgIGxldCBmaXJzdFBvaW50cyA9IHBhaXJzWzBdLmdldEZpbmRlclBhdHRlcm4oKS5nZXRSZXN1bHRQb2ludHMoKTtcbiAgICAgICAgICAgIGxldCBsYXN0UG9pbnRzID0gcGFpcnNbcGFpcnMubGVuZ3RoIC0gMV0uZ2V0RmluZGVyUGF0dGVybigpLmdldFJlc3VsdFBvaW50cygpO1xuICAgICAgICAgICAgbGV0IHBvaW50cyA9IFtmaXJzdFBvaW50c1swXSwgZmlyc3RQb2ludHNbMV0sIGxhc3RQb2ludHNbMF0sIGxhc3RQb2ludHNbMV1dO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZXN1bHQocmVzdWx0aW5nU3RyaW5nLCBudWxsLCBudWxsLCBwb2ludHMsIEJhcmNvZGVGb3JtYXQkMS5SU1NfRVhQQU5ERUQsIG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGNoZWNrQ2hlY2tzdW0oKSB7XG4gICAgICAgICAgICBsZXQgZmlyc3RQYWlyID0gdGhpcy5wYWlycy5nZXQoMCk7XG4gICAgICAgICAgICBsZXQgY2hlY2tDaGFyYWN0ZXIgPSBmaXJzdFBhaXIuZ2V0TGVmdENoYXIoKTtcbiAgICAgICAgICAgIGxldCBmaXJzdENoYXJhY3RlciA9IGZpcnN0UGFpci5nZXRSaWdodENoYXIoKTtcbiAgICAgICAgICAgIGlmIChmaXJzdENoYXJhY3RlciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGNoZWNrc3VtID0gZmlyc3RDaGFyYWN0ZXIuZ2V0Q2hlY2tzdW1Qb3J0aW9uKCk7XG4gICAgICAgICAgICBsZXQgcyA9IDI7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHRoaXMucGFpcnMuc2l6ZSgpOyArK2kpIHtcbiAgICAgICAgICAgICAgICBsZXQgY3VycmVudFBhaXIgPSB0aGlzLnBhaXJzLmdldChpKTtcbiAgICAgICAgICAgICAgICBjaGVja3N1bSArPSBjdXJyZW50UGFpci5nZXRMZWZ0Q2hhcigpLmdldENoZWNrc3VtUG9ydGlvbigpO1xuICAgICAgICAgICAgICAgIHMrKztcbiAgICAgICAgICAgICAgICBsZXQgY3VycmVudFJpZ2h0Q2hhciA9IGN1cnJlbnRQYWlyLmdldFJpZ2h0Q2hhcigpO1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50UmlnaHRDaGFyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tzdW0gKz0gY3VycmVudFJpZ2h0Q2hhci5nZXRDaGVja3N1bVBvcnRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgcysrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoZWNrc3VtICU9IDIxMTtcbiAgICAgICAgICAgIGxldCBjaGVja0NoYXJhY3RlclZhbHVlID0gMjExICogKHMgLSA0KSArIGNoZWNrc3VtO1xuICAgICAgICAgICAgcmV0dXJuIGNoZWNrQ2hhcmFjdGVyVmFsdWUgPT0gY2hlY2tDaGFyYWN0ZXIuZ2V0VmFsdWUoKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgZ2V0TmV4dFNlY29uZEJhcihyb3csIGluaXRpYWxQb3MpIHtcbiAgICAgICAgICAgIGxldCBjdXJyZW50UG9zO1xuICAgICAgICAgICAgaWYgKHJvdy5nZXQoaW5pdGlhbFBvcykpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UG9zID0gcm93LmdldE5leHRVbnNldChpbml0aWFsUG9zKTtcbiAgICAgICAgICAgICAgICBjdXJyZW50UG9zID0gcm93LmdldE5leHRTZXQoY3VycmVudFBvcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UG9zID0gcm93LmdldE5leHRTZXQoaW5pdGlhbFBvcyk7XG4gICAgICAgICAgICAgICAgY3VycmVudFBvcyA9IHJvdy5nZXROZXh0VW5zZXQoY3VycmVudFBvcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY3VycmVudFBvcztcbiAgICAgICAgfVxuICAgICAgICAvLyBub3QgcHJpdmF0ZSBmb3IgdGVzdGluZ1xuICAgICAgICByZXRyaWV2ZU5leHRQYWlyKHJvdywgcHJldmlvdXNQYWlycywgcm93TnVtYmVyKSB7XG4gICAgICAgICAgICBsZXQgaXNPZGRQYXR0ZXJuID0gcHJldmlvdXNQYWlycy5sZW5ndGggJSAyID09IDA7XG4gICAgICAgICAgICBpZiAodGhpcy5zdGFydEZyb21FdmVuKSB7XG4gICAgICAgICAgICAgICAgaXNPZGRQYXR0ZXJuID0gIWlzT2RkUGF0dGVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBwYXR0ZXJuO1xuICAgICAgICAgICAgbGV0IGtlZXBGaW5kaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIGxldCBmb3JjZWRPZmZzZXQgPSAtMTtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpbmROZXh0UGFpcihyb3csIHByZXZpb3VzUGFpcnMsIGZvcmNlZE9mZnNldCk7XG4gICAgICAgICAgICAgICAgcGF0dGVybiA9IHRoaXMucGFyc2VGb3VuZEZpbmRlclBhdHRlcm4ocm93LCByb3dOdW1iZXIsIGlzT2RkUGF0dGVybik7XG4gICAgICAgICAgICAgICAgaWYgKHBhdHRlcm4gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBmb3JjZWRPZmZzZXQgPSBSU1NFeHBhbmRlZFJlYWRlci5nZXROZXh0U2Vjb25kQmFyKHJvdywgdGhpcy5zdGFydEVuZFswXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBrZWVwRmluZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKGtlZXBGaW5kaW5nKTtcbiAgICAgICAgICAgIC8vIFdoZW4gc3RhY2tlZCBzeW1ib2wgaXMgc3BsaXQgb3ZlciBtdWx0aXBsZSByb3dzLCB0aGVyZSdzIG5vIHdheSB0byBndWVzcyBpZiB0aGlzIHBhaXIgY2FuIGJlIGxhc3Qgb3Igbm90LlxuICAgICAgICAgICAgLy8gYm9vbGVhbiBtYXlCZUxhc3QgPSBjaGVja1BhaXJTZXF1ZW5jZShwcmV2aW91c1BhaXJzLCBwYXR0ZXJuKTtcbiAgICAgICAgICAgIGxldCBsZWZ0Q2hhciA9IHRoaXMuZGVjb2RlRGF0YUNoYXJhY3Rlcihyb3csIHBhdHRlcm4sIGlzT2RkUGF0dGVybiwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNFbXB0eVBhaXIocHJldmlvdXNQYWlycykgJiYgcHJldmlvdXNQYWlyc1twcmV2aW91c1BhaXJzLmxlbmd0aCAtIDFdLm11c3RCZUxhc3QoKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHJpZ2h0Q2hhcjtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmlnaHRDaGFyID0gdGhpcy5kZWNvZGVEYXRhQ2hhcmFjdGVyKHJvdywgcGF0dGVybiwgaXNPZGRQYXR0ZXJuLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHJpZ2h0Q2hhciA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudmVyYm9zZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IEV4cGFuZGVkUGFpcihsZWZ0Q2hhciwgcmlnaHRDaGFyLCBwYXR0ZXJuLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBpc0VtcHR5UGFpcihwYWlycykge1xuICAgICAgICAgICAgaWYgKHBhaXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGZpbmROZXh0UGFpcihyb3csIHByZXZpb3VzUGFpcnMsIGZvcmNlZE9mZnNldCkge1xuICAgICAgICAgICAgbGV0IGNvdW50ZXJzID0gdGhpcy5nZXREZWNvZGVGaW5kZXJDb3VudGVycygpO1xuICAgICAgICAgICAgY291bnRlcnNbMF0gPSAwO1xuICAgICAgICAgICAgY291bnRlcnNbMV0gPSAwO1xuICAgICAgICAgICAgY291bnRlcnNbMl0gPSAwO1xuICAgICAgICAgICAgY291bnRlcnNbM10gPSAwO1xuICAgICAgICAgICAgbGV0IHdpZHRoID0gcm93LmdldFNpemUoKTtcbiAgICAgICAgICAgIGxldCByb3dPZmZzZXQ7XG4gICAgICAgICAgICBpZiAoZm9yY2VkT2Zmc2V0ID49IDApIHtcbiAgICAgICAgICAgICAgICByb3dPZmZzZXQgPSBmb3JjZWRPZmZzZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLmlzRW1wdHlQYWlyKHByZXZpb3VzUGFpcnMpKSB7XG4gICAgICAgICAgICAgICAgcm93T2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBsYXN0UGFpciA9IHByZXZpb3VzUGFpcnNbcHJldmlvdXNQYWlycy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICByb3dPZmZzZXQgPSBsYXN0UGFpci5nZXRGaW5kZXJQYXR0ZXJuKCkuZ2V0U3RhcnRFbmQoKVsxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBzZWFyY2hpbmdFdmVuUGFpciA9IHByZXZpb3VzUGFpcnMubGVuZ3RoICUgMiAhPSAwO1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhcnRGcm9tRXZlbikge1xuICAgICAgICAgICAgICAgIHNlYXJjaGluZ0V2ZW5QYWlyID0gIXNlYXJjaGluZ0V2ZW5QYWlyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGlzV2hpdGUgPSBmYWxzZTtcbiAgICAgICAgICAgIHdoaWxlIChyb3dPZmZzZXQgPCB3aWR0aCkge1xuICAgICAgICAgICAgICAgIGlzV2hpdGUgPSAhcm93LmdldChyb3dPZmZzZXQpO1xuICAgICAgICAgICAgICAgIGlmICghaXNXaGl0ZSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcm93T2Zmc2V0Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgY291bnRlclBvc2l0aW9uID0gMDtcbiAgICAgICAgICAgIGxldCBwYXR0ZXJuU3RhcnQgPSByb3dPZmZzZXQ7XG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gcm93T2Zmc2V0OyB4IDwgd2lkdGg7IHgrKykge1xuICAgICAgICAgICAgICAgIGlmIChyb3cuZ2V0KHgpICE9IGlzV2hpdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY291bnRlcnNbY291bnRlclBvc2l0aW9uXSsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvdW50ZXJQb3NpdGlvbiA9PSAzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VhcmNoaW5nRXZlblBhaXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBSU1NFeHBhbmRlZFJlYWRlci5yZXZlcnNlQ291bnRlcnMoY291bnRlcnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFJTU0V4cGFuZGVkUmVhZGVyLmlzRmluZGVyUGF0dGVybihjb3VudGVycykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0RW5kWzBdID0gcGF0dGVyblN0YXJ0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRFbmRbMV0gPSB4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWFyY2hpbmdFdmVuUGFpcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFJTU0V4cGFuZGVkUmVhZGVyLnJldmVyc2VDb3VudGVycyhjb3VudGVycyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuU3RhcnQgKz0gY291bnRlcnNbMF0gKyBjb3VudGVyc1sxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJzWzBdID0gY291bnRlcnNbMl07XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyc1sxXSA9IGNvdW50ZXJzWzNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlcnNbMl0gPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlcnNbM10gPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlclBvc2l0aW9uLS07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyUG9zaXRpb24rKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb3VudGVyc1tjb3VudGVyUG9zaXRpb25dID0gMTtcbiAgICAgICAgICAgICAgICAgICAgaXNXaGl0ZSA9ICFpc1doaXRlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyByZXZlcnNlQ291bnRlcnMoY291bnRlcnMpIHtcbiAgICAgICAgICAgIGxldCBsZW5ndGggPSBjb3VudGVycy5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aCAvIDI7ICsraSkge1xuICAgICAgICAgICAgICAgIGxldCB0bXAgPSBjb3VudGVyc1tpXTtcbiAgICAgICAgICAgICAgICBjb3VudGVyc1tpXSA9IGNvdW50ZXJzW2xlbmd0aCAtIGkgLSAxXTtcbiAgICAgICAgICAgICAgICBjb3VudGVyc1tsZW5ndGggLSBpIC0gMV0gPSB0bXA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcGFyc2VGb3VuZEZpbmRlclBhdHRlcm4ocm93LCByb3dOdW1iZXIsIG9kZFBhdHRlcm4pIHtcbiAgICAgICAgICAgIC8vIEFjdHVhbGx5IHdlIGZvdW5kIGVsZW1lbnRzIDItNS5cbiAgICAgICAgICAgIGxldCBmaXJzdENvdW50ZXI7XG4gICAgICAgICAgICBsZXQgc3RhcnQ7XG4gICAgICAgICAgICBsZXQgZW5kO1xuICAgICAgICAgICAgaWYgKG9kZFBhdHRlcm4pIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBwYXR0ZXJuIG51bWJlciBpcyBvZGQsIHdlIG5lZWQgdG8gbG9jYXRlIGVsZW1lbnQgMSAqYmVmb3JlKiB0aGUgY3VycmVudCBibG9jay5cbiAgICAgICAgICAgICAgICBsZXQgZmlyc3RFbGVtZW50U3RhcnQgPSB0aGlzLnN0YXJ0RW5kWzBdIC0gMTtcbiAgICAgICAgICAgICAgICAvLyBMb2NhdGUgZWxlbWVudCAxXG4gICAgICAgICAgICAgICAgd2hpbGUgKGZpcnN0RWxlbWVudFN0YXJ0ID49IDAgJiYgIXJvdy5nZXQoZmlyc3RFbGVtZW50U3RhcnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0RWxlbWVudFN0YXJ0LS07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpcnN0RWxlbWVudFN0YXJ0Kys7XG4gICAgICAgICAgICAgICAgZmlyc3RDb3VudGVyID0gdGhpcy5zdGFydEVuZFswXSAtIGZpcnN0RWxlbWVudFN0YXJ0O1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0gZmlyc3RFbGVtZW50U3RhcnQ7XG4gICAgICAgICAgICAgICAgZW5kID0gdGhpcy5zdGFydEVuZFsxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIElmIHBhdHRlcm4gbnVtYmVyIGlzIGV2ZW4sIHRoZSBwYXR0ZXJuIGlzIHJldmVyc2VkLCBzbyB3ZSBuZWVkIHRvIGxvY2F0ZSBlbGVtZW50IDEgKmFmdGVyKiB0aGUgY3VycmVudCBibG9jay5cbiAgICAgICAgICAgICAgICBzdGFydCA9IHRoaXMuc3RhcnRFbmRbMF07XG4gICAgICAgICAgICAgICAgZW5kID0gcm93LmdldE5leHRVbnNldCh0aGlzLnN0YXJ0RW5kWzFdICsgMSk7XG4gICAgICAgICAgICAgICAgZmlyc3RDb3VudGVyID0gZW5kIC0gdGhpcy5zdGFydEVuZFsxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE1ha2UgJ2NvdW50ZXJzJyBob2xkIDEtNFxuICAgICAgICAgICAgbGV0IGNvdW50ZXJzID0gdGhpcy5nZXREZWNvZGVGaW5kZXJDb3VudGVycygpO1xuICAgICAgICAgICAgU3lzdGVtLmFycmF5Y29weShjb3VudGVycywgMCwgY291bnRlcnMsIDEsIGNvdW50ZXJzLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgY291bnRlcnNbMF0gPSBmaXJzdENvdW50ZXI7XG4gICAgICAgICAgICBsZXQgdmFsdWU7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5wYXJzZUZpbmRlclZhbHVlKGNvdW50ZXJzLCBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUVEVSTlMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHJldHVybiBuZXcgRmluZGVyUGF0dGVybih2YWx1ZSwgbmV3IGludFtdIHsgc3RhcnQsIGVuZCB9LCBzdGFydCwgZW5kLCByb3dOdW1iZXJ9KTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRmluZGVyUGF0dGVybih2YWx1ZSwgW3N0YXJ0LCBlbmRdLCBzdGFydCwgZW5kLCByb3dOdW1iZXIpO1xuICAgICAgICB9XG4gICAgICAgIGRlY29kZURhdGFDaGFyYWN0ZXIocm93LCBwYXR0ZXJuLCBpc09kZFBhdHRlcm4sIGxlZnRDaGFyKSB7XG4gICAgICAgICAgICBsZXQgY291bnRlcnMgPSB0aGlzLmdldERhdGFDaGFyYWN0ZXJDb3VudGVycygpO1xuICAgICAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCBjb3VudGVycy5sZW5ndGg7IHgrKykge1xuICAgICAgICAgICAgICAgIGNvdW50ZXJzW3hdID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsZWZ0Q2hhcikge1xuICAgICAgICAgICAgICAgIFJTU0V4cGFuZGVkUmVhZGVyLnJlY29yZFBhdHRlcm5JblJldmVyc2Uocm93LCBwYXR0ZXJuLmdldFN0YXJ0RW5kKClbMF0sIGNvdW50ZXJzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIFJTU0V4cGFuZGVkUmVhZGVyLnJlY29yZFBhdHRlcm4ocm93LCBwYXR0ZXJuLmdldFN0YXJ0RW5kKClbMV0sIGNvdW50ZXJzKTtcbiAgICAgICAgICAgICAgICAvLyByZXZlcnNlIGl0XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGogPSBjb3VudGVycy5sZW5ndGggLSAxOyBpIDwgajsgaSsrLCBqLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRlbXAgPSBjb3VudGVyc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgY291bnRlcnNbaV0gPSBjb3VudGVyc1tqXTtcbiAgICAgICAgICAgICAgICAgICAgY291bnRlcnNbal0gPSB0ZW1wO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gLy8gY291bnRlcnNbXSBoYXMgdGhlIHBpeGVscyBvZiB0aGUgbW9kdWxlXG4gICAgICAgICAgICBsZXQgbnVtTW9kdWxlcyA9IDE3OyAvLyBsZWZ0IGFuZCByaWdodCBkYXRhIGNoYXJhY3RlcnMgaGF2ZSBhbGwgdGhlIHNhbWUgbGVuZ3RoXG4gICAgICAgICAgICBsZXQgZWxlbWVudFdpZHRoID0gTWF0aFV0aWxzLnN1bShuZXcgSW50MzJBcnJheShjb3VudGVycykpIC8gbnVtTW9kdWxlcztcbiAgICAgICAgICAgIC8vIFNhbml0eSBjaGVjazogZWxlbWVudCB3aWR0aCBmb3IgcGF0dGVybiBhbmQgdGhlIGNoYXJhY3RlciBzaG91bGQgbWF0Y2hcbiAgICAgICAgICAgIGxldCBleHBlY3RlZEVsZW1lbnRXaWR0aCA9IChwYXR0ZXJuLmdldFN0YXJ0RW5kKClbMV0gLSBwYXR0ZXJuLmdldFN0YXJ0RW5kKClbMF0pIC8gMTUuMDtcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyhlbGVtZW50V2lkdGggLSBleHBlY3RlZEVsZW1lbnRXaWR0aCkgLyBleHBlY3RlZEVsZW1lbnRXaWR0aCA+IDAuMykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IG9kZENvdW50cyA9IHRoaXMuZ2V0T2RkQ291bnRzKCk7XG4gICAgICAgICAgICBsZXQgZXZlbkNvdW50cyA9IHRoaXMuZ2V0RXZlbkNvdW50cygpO1xuICAgICAgICAgICAgbGV0IG9kZFJvdW5kaW5nRXJyb3JzID0gdGhpcy5nZXRPZGRSb3VuZGluZ0Vycm9ycygpO1xuICAgICAgICAgICAgbGV0IGV2ZW5Sb3VuZGluZ0Vycm9ycyA9IHRoaXMuZ2V0RXZlblJvdW5kaW5nRXJyb3JzKCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHZhbHVlID0gMS4wICogY291bnRlcnNbaV0gLyBlbGVtZW50V2lkdGg7XG4gICAgICAgICAgICAgICAgbGV0IGNvdW50ID0gdmFsdWUgKyAwLjU7IC8vIFJvdW5kXG4gICAgICAgICAgICAgICAgaWYgKGNvdW50IDwgMSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPCAwLjMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ID0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY291bnQgPiA4KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA+IDguNykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY291bnQgPSA4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgb2Zmc2V0ID0gaSAvIDI7XG4gICAgICAgICAgICAgICAgaWYgKChpICYgMHgwMSkgPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBvZGRDb3VudHNbb2Zmc2V0XSA9IGNvdW50O1xuICAgICAgICAgICAgICAgICAgICBvZGRSb3VuZGluZ0Vycm9yc1tvZmZzZXRdID0gdmFsdWUgLSBjb3VudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW5Db3VudHNbb2Zmc2V0XSA9IGNvdW50O1xuICAgICAgICAgICAgICAgICAgICBldmVuUm91bmRpbmdFcnJvcnNbb2Zmc2V0XSA9IHZhbHVlIC0gY291bnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5hZGp1c3RPZGRFdmVuQ291bnRzKG51bU1vZHVsZXMpO1xuICAgICAgICAgICAgbGV0IHdlaWdodFJvd051bWJlciA9IDQgKiBwYXR0ZXJuLmdldFZhbHVlKCkgKyAoaXNPZGRQYXR0ZXJuID8gMCA6IDIpICsgKGxlZnRDaGFyID8gMCA6IDEpIC0gMTtcbiAgICAgICAgICAgIGxldCBvZGRTdW0gPSAwO1xuICAgICAgICAgICAgbGV0IG9kZENoZWNrc3VtUG9ydGlvbiA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gb2RkQ291bnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgaWYgKFJTU0V4cGFuZGVkUmVhZGVyLmlzTm90QTFsZWZ0KHBhdHRlcm4sIGlzT2RkUGF0dGVybiwgbGVmdENoYXIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB3ZWlnaHQgPSBSU1NFeHBhbmRlZFJlYWRlci5XRUlHSFRTW3dlaWdodFJvd051bWJlcl1bMiAqIGldO1xuICAgICAgICAgICAgICAgICAgICBvZGRDaGVja3N1bVBvcnRpb24gKz0gb2RkQ291bnRzW2ldICogd2VpZ2h0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvZGRTdW0gKz0gb2RkQ291bnRzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGV2ZW5DaGVja3N1bVBvcnRpb24gPSAwO1xuICAgICAgICAgICAgLy8gaW50IGV2ZW5TdW0gPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IGV2ZW5Db3VudHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICBpZiAoUlNTRXhwYW5kZWRSZWFkZXIuaXNOb3RBMWxlZnQocGF0dGVybiwgaXNPZGRQYXR0ZXJuLCBsZWZ0Q2hhcikpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHdlaWdodCA9IFJTU0V4cGFuZGVkUmVhZGVyLldFSUdIVFNbd2VpZ2h0Um93TnVtYmVyXVsyICogaSArIDFdO1xuICAgICAgICAgICAgICAgICAgICBldmVuQ2hlY2tzdW1Qb3J0aW9uICs9IGV2ZW5Db3VudHNbaV0gKiB3ZWlnaHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGV2ZW5TdW0gKz0gZXZlbkNvdW50c1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBjaGVja3N1bVBvcnRpb24gPSBvZGRDaGVja3N1bVBvcnRpb24gKyBldmVuQ2hlY2tzdW1Qb3J0aW9uO1xuICAgICAgICAgICAgaWYgKChvZGRTdW0gJiAweDAxKSAhPSAwIHx8IG9kZFN1bSA+IDEzIHx8IG9kZFN1bSA8IDQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBncm91cCA9ICgxMyAtIG9kZFN1bSkgLyAyO1xuICAgICAgICAgICAgbGV0IG9kZFdpZGVzdCA9IFJTU0V4cGFuZGVkUmVhZGVyLlNZTUJPTF9XSURFU1RbZ3JvdXBdO1xuICAgICAgICAgICAgbGV0IGV2ZW5XaWRlc3QgPSA5IC0gb2RkV2lkZXN0O1xuICAgICAgICAgICAgbGV0IHZPZGQgPSBSU1NVdGlscy5nZXRSU1N2YWx1ZShvZGRDb3VudHMsIG9kZFdpZGVzdCwgdHJ1ZSk7XG4gICAgICAgICAgICBsZXQgdkV2ZW4gPSBSU1NVdGlscy5nZXRSU1N2YWx1ZShldmVuQ291bnRzLCBldmVuV2lkZXN0LCBmYWxzZSk7XG4gICAgICAgICAgICBsZXQgdEV2ZW4gPSBSU1NFeHBhbmRlZFJlYWRlci5FVkVOX1RPVEFMX1NVQlNFVFtncm91cF07XG4gICAgICAgICAgICBsZXQgZ1N1bSA9IFJTU0V4cGFuZGVkUmVhZGVyLkdTVU1bZ3JvdXBdO1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gdk9kZCAqIHRFdmVuICsgdkV2ZW4gKyBnU3VtO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRhQ2hhcmFjdGVyKHZhbHVlLCBjaGVja3N1bVBvcnRpb24pO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBpc05vdEExbGVmdChwYXR0ZXJuLCBpc09kZFBhdHRlcm4sIGxlZnRDaGFyKSB7XG4gICAgICAgICAgICAvLyBBMTogcGF0dGVybi5nZXRWYWx1ZSBpcyAwIChBKSwgYW5kIGl0J3MgYW4gb2RkUGF0dGVybiwgYW5kIGl0IGlzIGEgbGVmdCBjaGFyXG4gICAgICAgICAgICByZXR1cm4gIShwYXR0ZXJuLmdldFZhbHVlKCkgPT0gMCAmJiBpc09kZFBhdHRlcm4gJiYgbGVmdENoYXIpO1xuICAgICAgICB9XG4gICAgICAgIGFkanVzdE9kZEV2ZW5Db3VudHMobnVtTW9kdWxlcykge1xuICAgICAgICAgICAgbGV0IG9kZFN1bSA9IE1hdGhVdGlscy5zdW0obmV3IEludDMyQXJyYXkodGhpcy5nZXRPZGRDb3VudHMoKSkpO1xuICAgICAgICAgICAgbGV0IGV2ZW5TdW0gPSBNYXRoVXRpbHMuc3VtKG5ldyBJbnQzMkFycmF5KHRoaXMuZ2V0RXZlbkNvdW50cygpKSk7XG4gICAgICAgICAgICBsZXQgaW5jcmVtZW50T2RkID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgZGVjcmVtZW50T2RkID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAob2RkU3VtID4gMTMpIHtcbiAgICAgICAgICAgICAgICBkZWNyZW1lbnRPZGQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAob2RkU3VtIDwgNCkge1xuICAgICAgICAgICAgICAgIGluY3JlbWVudE9kZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgaW5jcmVtZW50RXZlbiA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IGRlY3JlbWVudEV2ZW4gPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChldmVuU3VtID4gMTMpIHtcbiAgICAgICAgICAgICAgICBkZWNyZW1lbnRFdmVuID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW5TdW0gPCA0KSB7XG4gICAgICAgICAgICAgICAgaW5jcmVtZW50RXZlbiA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgbWlzbWF0Y2ggPSBvZGRTdW0gKyBldmVuU3VtIC0gbnVtTW9kdWxlcztcbiAgICAgICAgICAgIGxldCBvZGRQYXJpdHlCYWQgPSAob2RkU3VtICYgMHgwMSkgPT0gMTtcbiAgICAgICAgICAgIGxldCBldmVuUGFyaXR5QmFkID0gKGV2ZW5TdW0gJiAweDAxKSA9PSAwO1xuICAgICAgICAgICAgaWYgKG1pc21hdGNoID09IDEpIHtcbiAgICAgICAgICAgICAgICBpZiAob2RkUGFyaXR5QmFkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChldmVuUGFyaXR5QmFkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkZWNyZW1lbnRPZGQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFldmVuUGFyaXR5QmFkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkZWNyZW1lbnRFdmVuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChtaXNtYXRjaCA9PSAtMSkge1xuICAgICAgICAgICAgICAgIGlmIChvZGRQYXJpdHlCYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW5QYXJpdHlCYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGluY3JlbWVudE9kZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWV2ZW5QYXJpdHlCYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGluY3JlbWVudEV2ZW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG1pc21hdGNoID09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAob2RkUGFyaXR5QmFkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZXZlblBhcml0eUJhZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gQm90aCBiYWRcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9kZFN1bSA8IGV2ZW5TdW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY3JlbWVudE9kZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWNyZW1lbnRFdmVuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlY3JlbWVudE9kZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmNyZW1lbnRFdmVuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW5QYXJpdHlCYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIE5vdGhpbmcgdG8gZG8hXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaW5jcmVtZW50T2RkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRlY3JlbWVudE9kZCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgUlNTRXhwYW5kZWRSZWFkZXIuaW5jcmVtZW50KHRoaXMuZ2V0T2RkQ291bnRzKCksIHRoaXMuZ2V0T2RkUm91bmRpbmdFcnJvcnMoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGVjcmVtZW50T2RkKSB7XG4gICAgICAgICAgICAgICAgUlNTRXhwYW5kZWRSZWFkZXIuZGVjcmVtZW50KHRoaXMuZ2V0T2RkQ291bnRzKCksIHRoaXMuZ2V0T2RkUm91bmRpbmdFcnJvcnMoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaW5jcmVtZW50RXZlbikge1xuICAgICAgICAgICAgICAgIGlmIChkZWNyZW1lbnRFdmVuKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBSU1NFeHBhbmRlZFJlYWRlci5pbmNyZW1lbnQodGhpcy5nZXRFdmVuQ291bnRzKCksIHRoaXMuZ2V0T2RkUm91bmRpbmdFcnJvcnMoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGVjcmVtZW50RXZlbikge1xuICAgICAgICAgICAgICAgIFJTU0V4cGFuZGVkUmVhZGVyLmRlY3JlbWVudCh0aGlzLmdldEV2ZW5Db3VudHMoKSwgdGhpcy5nZXRFdmVuUm91bmRpbmdFcnJvcnMoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgUlNTRXhwYW5kZWRSZWFkZXIuU1lNQk9MX1dJREVTVCA9IFs3LCA1LCA0LCAzLCAxXTtcbiAgICBSU1NFeHBhbmRlZFJlYWRlci5FVkVOX1RPVEFMX1NVQlNFVCA9IFs0LCAyMCwgNTIsIDEwNCwgMjA0XTtcbiAgICBSU1NFeHBhbmRlZFJlYWRlci5HU1VNID0gWzAsIDM0OCwgMTM4OCwgMjk0OCwgMzk4OF07XG4gICAgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVFRFUk5TID0gW1xuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDgsIDQsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFszLCA2LCA0LCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMywgNCwgNiwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzMsIDIsIDgsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsyLCA2LCA1LCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMiwgMiwgOSwgMV0pIC8vIEZcbiAgICBdO1xuICAgIFJTU0V4cGFuZGVkUmVhZGVyLldFSUdIVFMgPSBbXG4gICAgICAgIFsxLCAzLCA5LCAyNywgODEsIDMyLCA5NiwgNzddLFxuICAgICAgICBbMjAsIDYwLCAxODAsIDExOCwgMTQzLCA3LCAyMSwgNjNdLFxuICAgICAgICBbMTg5LCAxNDUsIDEzLCAzOSwgMTE3LCAxNDAsIDIwOSwgMjA1XSxcbiAgICAgICAgWzE5MywgMTU3LCA0OSwgMTQ3LCAxOSwgNTcsIDE3MSwgOTFdLFxuICAgICAgICBbNjIsIDE4NiwgMTM2LCAxOTcsIDE2OSwgODUsIDQ0LCAxMzJdLFxuICAgICAgICBbMTg1LCAxMzMsIDE4OCwgMTQyLCA0LCAxMiwgMzYsIDEwOF0sXG4gICAgICAgIFsxMTMsIDEyOCwgMTczLCA5NywgODAsIDI5LCA4NywgNTBdLFxuICAgICAgICBbMTUwLCAyOCwgODQsIDQxLCAxMjMsIDE1OCwgNTIsIDE1Nl0sXG4gICAgICAgIFs0NiwgMTM4LCAyMDMsIDE4NywgMTM5LCAyMDYsIDE5NiwgMTY2XSxcbiAgICAgICAgWzc2LCAxNywgNTEsIDE1MywgMzcsIDExMSwgMTIyLCAxNTVdLFxuICAgICAgICBbNDMsIDEyOSwgMTc2LCAxMDYsIDEwNywgMTEwLCAxMTksIDE0Nl0sXG4gICAgICAgIFsxNiwgNDgsIDE0NCwgMTAsIDMwLCA5MCwgNTksIDE3N10sXG4gICAgICAgIFsxMDksIDExNiwgMTM3LCAyMDAsIDE3OCwgMTEyLCAxMjUsIDE2NF0sXG4gICAgICAgIFs3MCwgMjEwLCAyMDgsIDIwMiwgMTg0LCAxMzAsIDE3OSwgMTE1XSxcbiAgICAgICAgWzEzNCwgMTkxLCAxNTEsIDMxLCA5MywgNjgsIDIwNCwgMTkwXSxcbiAgICAgICAgWzE0OCwgMjIsIDY2LCAxOTgsIDE3MiwgOTQsIDcxLCAyXSxcbiAgICAgICAgWzYsIDE4LCA1NCwgMTYyLCA2NCwgMTkyLCAxNTQsIDQwXSxcbiAgICAgICAgWzEyMCwgMTQ5LCAyNSwgNzUsIDE0LCA0MiwgMTI2LCAxNjddLFxuICAgICAgICBbNzksIDI2LCA3OCwgMjMsIDY5LCAyMDcsIDE5OSwgMTc1XSxcbiAgICAgICAgWzEwMywgOTgsIDgzLCAzOCwgMTE0LCAxMzEsIDE4MiwgMTI0XSxcbiAgICAgICAgWzE2MSwgNjEsIDE4MywgMTI3LCAxNzAsIDg4LCA1MywgMTU5XSxcbiAgICAgICAgWzU1LCAxNjUsIDczLCA4LCAyNCwgNzIsIDUsIDE1XSxcbiAgICAgICAgWzQ1LCAxMzUsIDE5NCwgMTYwLCA1OCwgMTc0LCAxMDAsIDg5XVxuICAgIF07XG4gICAgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9BID0gMDtcbiAgICBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0IgPSAxO1xuICAgIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfQyA9IDI7XG4gICAgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9EID0gMztcbiAgICBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0UgPSA0O1xuICAgIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfRiA9IDU7XG4gICAgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVFRFUk5fU0VRVUVOQ0VTID0gW1xuICAgICAgICBbUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9BLCBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0FdLFxuICAgICAgICBbUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9BLCBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0IsIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfQl0sXG4gICAgICAgIFtSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0EsIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfQywgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9CLCBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0RdLFxuICAgICAgICBbUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9BLCBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0UsIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfQiwgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9ELCBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0NdLFxuICAgICAgICBbUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9BLCBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0UsIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfQiwgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9ELCBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0QsIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfRl0sXG4gICAgICAgIFtSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0EsIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfRSwgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9CLCBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0QsIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfRSwgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9GLCBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0ZdLFxuICAgICAgICBbUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9BLCBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0EsIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfQiwgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9CLCBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0MsIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfQywgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9ELCBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0RdLFxuICAgICAgICBbUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9BLCBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0EsIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfQiwgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9CLCBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0MsIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfQywgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9ELCBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0UsIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfRV0sXG4gICAgICAgIFtSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0EsIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfQSwgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9CLCBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0IsIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfQywgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9DLCBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0QsIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfRSwgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9GLCBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0ZdLFxuICAgICAgICBbUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9BLCBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0EsIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfQiwgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9CLCBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0MsIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfRCwgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9ELCBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0UsIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfRSwgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9GLCBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0ZdLFxuICAgIF07XG4gICAgUlNTRXhwYW5kZWRSZWFkZXIuTUFYX1BBSVJTID0gMTE7XG5cbiAgICBjbGFzcyBQYWlyIGV4dGVuZHMgRGF0YUNoYXJhY3RlciB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHZhbHVlLCBjaGVja3N1bVBvcnRpb24sIGZpbmRlclBhdHRlcm4pIHtcbiAgICAgICAgICAgIHN1cGVyKHZhbHVlLCBjaGVja3N1bVBvcnRpb24pO1xuICAgICAgICAgICAgdGhpcy5jb3VudCA9IDA7XG4gICAgICAgICAgICB0aGlzLmZpbmRlclBhdHRlcm4gPSBmaW5kZXJQYXR0ZXJuO1xuICAgICAgICB9XG4gICAgICAgIGdldEZpbmRlclBhdHRlcm4oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maW5kZXJQYXR0ZXJuO1xuICAgICAgICB9XG4gICAgICAgIGdldENvdW50KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgaW5jcmVtZW50Q291bnQoKSB7XG4gICAgICAgICAgICB0aGlzLmNvdW50Kys7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjbGFzcyBSU1MxNFJlYWRlciBleHRlbmRzIEFic3RyYWN0UlNTUmVhZGVyIHtcbiAgICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICAgICAgdGhpcy5wb3NzaWJsZUxlZnRQYWlycyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5wb3NzaWJsZVJpZ2h0UGFpcnMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBkZWNvZGVSb3cocm93TnVtYmVyLCByb3csIGhpbnRzKSB7XG4gICAgICAgICAgICBjb25zdCBsZWZ0UGFpciA9IHRoaXMuZGVjb2RlUGFpcihyb3csIGZhbHNlLCByb3dOdW1iZXIsIGhpbnRzKTtcbiAgICAgICAgICAgIFJTUzE0UmVhZGVyLmFkZE9yVGFsbHkodGhpcy5wb3NzaWJsZUxlZnRQYWlycywgbGVmdFBhaXIpO1xuICAgICAgICAgICAgcm93LnJldmVyc2UoKTtcbiAgICAgICAgICAgIGxldCByaWdodFBhaXIgPSB0aGlzLmRlY29kZVBhaXIocm93LCB0cnVlLCByb3dOdW1iZXIsIGhpbnRzKTtcbiAgICAgICAgICAgIFJTUzE0UmVhZGVyLmFkZE9yVGFsbHkodGhpcy5wb3NzaWJsZVJpZ2h0UGFpcnMsIHJpZ2h0UGFpcik7XG4gICAgICAgICAgICByb3cucmV2ZXJzZSgpO1xuICAgICAgICAgICAgZm9yIChsZXQgbGVmdCBvZiB0aGlzLnBvc3NpYmxlTGVmdFBhaXJzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxlZnQuZ2V0Q291bnQoKSA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgcmlnaHQgb2YgdGhpcy5wb3NzaWJsZVJpZ2h0UGFpcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyaWdodC5nZXRDb3VudCgpID4gMSAmJiBSU1MxNFJlYWRlci5jaGVja0NoZWNrc3VtKGxlZnQsIHJpZ2h0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBSU1MxNFJlYWRlci5jb25zdHJ1Y3RSZXN1bHQobGVmdCwgcmlnaHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGFkZE9yVGFsbHkocG9zc2libGVQYWlycywgcGFpcikge1xuICAgICAgICAgICAgaWYgKHBhaXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBmb3VuZCA9IGZhbHNlO1xuICAgICAgICAgICAgZm9yIChsZXQgb3RoZXIgb2YgcG9zc2libGVQYWlycykge1xuICAgICAgICAgICAgICAgIGlmIChvdGhlci5nZXRWYWx1ZSgpID09PSBwYWlyLmdldFZhbHVlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgb3RoZXIuaW5jcmVtZW50Q291bnQoKTtcbiAgICAgICAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWZvdW5kKSB7XG4gICAgICAgICAgICAgICAgcG9zc2libGVQYWlycy5wdXNoKHBhaXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlc2V0KCkge1xuICAgICAgICAgICAgdGhpcy5wb3NzaWJsZUxlZnRQYWlycy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgdGhpcy5wb3NzaWJsZVJpZ2h0UGFpcnMubGVuZ3RoID0gMDtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgY29uc3RydWN0UmVzdWx0KGxlZnRQYWlyLCByaWdodFBhaXIpIHtcbiAgICAgICAgICAgIGxldCBzeW1ib2xWYWx1ZSA9IDQ1MzcwNzcgKiBsZWZ0UGFpci5nZXRWYWx1ZSgpICsgcmlnaHRQYWlyLmdldFZhbHVlKCk7XG4gICAgICAgICAgICBsZXQgdGV4dCA9IG5ldyBTdHJpbmcoc3ltYm9sVmFsdWUpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBsZXQgYnVmZmVyID0gbmV3IFN0cmluZ0J1aWxkZXIoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAxMyAtIHRleHQubGVuZ3RoOyBpID4gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgYnVmZmVyLmFwcGVuZCgnMCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnVmZmVyLmFwcGVuZCh0ZXh0KTtcbiAgICAgICAgICAgIGxldCBjaGVja0RpZ2l0ID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTM7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBkaWdpdCA9IGJ1ZmZlci5jaGFyQXQoaSkuY2hhckNvZGVBdCgwKSAtICcwJy5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgICAgICAgIGNoZWNrRGlnaXQgKz0gKChpICYgMHgwMSkgPT09IDApID8gMyAqIGRpZ2l0IDogZGlnaXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGVja0RpZ2l0ID0gMTAgLSAoY2hlY2tEaWdpdCAlIDEwKTtcbiAgICAgICAgICAgIGlmIChjaGVja0RpZ2l0ID09PSAxMCkge1xuICAgICAgICAgICAgICAgIGNoZWNrRGlnaXQgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnVmZmVyLmFwcGVuZChjaGVja0RpZ2l0LnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgbGV0IGxlZnRQb2ludHMgPSBsZWZ0UGFpci5nZXRGaW5kZXJQYXR0ZXJuKCkuZ2V0UmVzdWx0UG9pbnRzKCk7XG4gICAgICAgICAgICBsZXQgcmlnaHRQb2ludHMgPSByaWdodFBhaXIuZ2V0RmluZGVyUGF0dGVybigpLmdldFJlc3VsdFBvaW50cygpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZXN1bHQoYnVmZmVyLnRvU3RyaW5nKCksIG51bGwsIDAsIFtsZWZ0UG9pbnRzWzBdLCBsZWZ0UG9pbnRzWzFdLCByaWdodFBvaW50c1swXSwgcmlnaHRQb2ludHNbMV1dLCBCYXJjb2RlRm9ybWF0JDEuUlNTXzE0LCBuZXcgRGF0ZSgpLmdldFRpbWUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGNoZWNrQ2hlY2tzdW0obGVmdFBhaXIsIHJpZ2h0UGFpcikge1xuICAgICAgICAgICAgbGV0IGNoZWNrVmFsdWUgPSAobGVmdFBhaXIuZ2V0Q2hlY2tzdW1Qb3J0aW9uKCkgKyAxNiAqIHJpZ2h0UGFpci5nZXRDaGVja3N1bVBvcnRpb24oKSkgJSA3OTtcbiAgICAgICAgICAgIGxldCB0YXJnZXRDaGVja1ZhbHVlID0gOSAqIGxlZnRQYWlyLmdldEZpbmRlclBhdHRlcm4oKS5nZXRWYWx1ZSgpICsgcmlnaHRQYWlyLmdldEZpbmRlclBhdHRlcm4oKS5nZXRWYWx1ZSgpO1xuICAgICAgICAgICAgaWYgKHRhcmdldENoZWNrVmFsdWUgPiA3Mikge1xuICAgICAgICAgICAgICAgIHRhcmdldENoZWNrVmFsdWUtLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0YXJnZXRDaGVja1ZhbHVlID4gOCkge1xuICAgICAgICAgICAgICAgIHRhcmdldENoZWNrVmFsdWUtLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjaGVja1ZhbHVlID09PSB0YXJnZXRDaGVja1ZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGRlY29kZVBhaXIocm93LCByaWdodCwgcm93TnVtYmVyLCBoaW50cykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBsZXQgc3RhcnRFbmQgPSB0aGlzLmZpbmRGaW5kZXJQYXR0ZXJuKHJvdywgcmlnaHQpO1xuICAgICAgICAgICAgICAgIGxldCBwYXR0ZXJuID0gdGhpcy5wYXJzZUZvdW5kRmluZGVyUGF0dGVybihyb3csIHJvd051bWJlciwgcmlnaHQsIHN0YXJ0RW5kKTtcbiAgICAgICAgICAgICAgICBsZXQgcmVzdWx0UG9pbnRDYWxsYmFjayA9IGhpbnRzID09IG51bGwgPyBudWxsIDogaGludHMuZ2V0KERlY29kZUhpbnRUeXBlJDEuTkVFRF9SRVNVTFRfUE9JTlRfQ0FMTEJBQ0spO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHRQb2ludENhbGxiYWNrICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNlbnRlciA9IChzdGFydEVuZFswXSArIHN0YXJ0RW5kWzFdKSAvIDIuMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByb3cgaXMgYWN0dWFsbHkgcmV2ZXJzZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIGNlbnRlciA9IHJvdy5nZXRTaXplKCkgLSAxIC0gY2VudGVyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFBvaW50Q2FsbGJhY2suZm91bmRQb3NzaWJsZVJlc3VsdFBvaW50KG5ldyBSZXN1bHRQb2ludChjZW50ZXIsIHJvd051bWJlcikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgb3V0c2lkZSA9IHRoaXMuZGVjb2RlRGF0YUNoYXJhY3Rlcihyb3csIHBhdHRlcm4sIHRydWUpO1xuICAgICAgICAgICAgICAgIGxldCBpbnNpZGUgPSB0aGlzLmRlY29kZURhdGFDaGFyYWN0ZXIocm93LCBwYXR0ZXJuLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQYWlyKDE1OTcgKiBvdXRzaWRlLmdldFZhbHVlKCkgKyBpbnNpZGUuZ2V0VmFsdWUoKSwgb3V0c2lkZS5nZXRDaGVja3N1bVBvcnRpb24oKSArIDQgKiBpbnNpZGUuZ2V0Q2hlY2tzdW1Qb3J0aW9uKCksIHBhdHRlcm4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGRlY29kZURhdGFDaGFyYWN0ZXIocm93LCBwYXR0ZXJuLCBvdXRzaWRlQ2hhcikge1xuICAgICAgICAgICAgbGV0IGNvdW50ZXJzID0gdGhpcy5nZXREYXRhQ2hhcmFjdGVyQ291bnRlcnMoKTtcbiAgICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgY291bnRlcnMubGVuZ3RoOyB4KyspIHtcbiAgICAgICAgICAgICAgICBjb3VudGVyc1t4XSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3V0c2lkZUNoYXIpIHtcbiAgICAgICAgICAgICAgICBPbmVEUmVhZGVyLnJlY29yZFBhdHRlcm5JblJldmVyc2Uocm93LCBwYXR0ZXJuLmdldFN0YXJ0RW5kKClbMF0sIGNvdW50ZXJzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIE9uZURSZWFkZXIucmVjb3JkUGF0dGVybihyb3csIHBhdHRlcm4uZ2V0U3RhcnRFbmQoKVsxXSArIDEsIGNvdW50ZXJzKTtcbiAgICAgICAgICAgICAgICAvLyByZXZlcnNlIGl0XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGogPSBjb3VudGVycy5sZW5ndGggLSAxOyBpIDwgajsgaSsrLCBqLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRlbXAgPSBjb3VudGVyc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgY291bnRlcnNbaV0gPSBjb3VudGVyc1tqXTtcbiAgICAgICAgICAgICAgICAgICAgY291bnRlcnNbal0gPSB0ZW1wO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBudW1Nb2R1bGVzID0gb3V0c2lkZUNoYXIgPyAxNiA6IDE1O1xuICAgICAgICAgICAgbGV0IGVsZW1lbnRXaWR0aCA9IE1hdGhVdGlscy5zdW0obmV3IEludDMyQXJyYXkoY291bnRlcnMpKSAvIG51bU1vZHVsZXM7XG4gICAgICAgICAgICBsZXQgb2RkQ291bnRzID0gdGhpcy5nZXRPZGRDb3VudHMoKTtcbiAgICAgICAgICAgIGxldCBldmVuQ291bnRzID0gdGhpcy5nZXRFdmVuQ291bnRzKCk7XG4gICAgICAgICAgICBsZXQgb2RkUm91bmRpbmdFcnJvcnMgPSB0aGlzLmdldE9kZFJvdW5kaW5nRXJyb3JzKCk7XG4gICAgICAgICAgICBsZXQgZXZlblJvdW5kaW5nRXJyb3JzID0gdGhpcy5nZXRFdmVuUm91bmRpbmdFcnJvcnMoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgdmFsdWUgPSBjb3VudGVyc1tpXSAvIGVsZW1lbnRXaWR0aDtcbiAgICAgICAgICAgICAgICBsZXQgY291bnQgPSBNYXRoLmZsb29yKHZhbHVlICsgMC41KTtcbiAgICAgICAgICAgICAgICBpZiAoY291bnQgPCAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ID0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY291bnQgPiA4KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ID0gODtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IG9mZnNldCA9IE1hdGguZmxvb3IoaSAvIDIpO1xuICAgICAgICAgICAgICAgIGlmICgoaSAmIDB4MDEpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG9kZENvdW50c1tvZmZzZXRdID0gY291bnQ7XG4gICAgICAgICAgICAgICAgICAgIG9kZFJvdW5kaW5nRXJyb3JzW29mZnNldF0gPSB2YWx1ZSAtIGNvdW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbkNvdW50c1tvZmZzZXRdID0gY291bnQ7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW5Sb3VuZGluZ0Vycm9yc1tvZmZzZXRdID0gdmFsdWUgLSBjb3VudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmFkanVzdE9kZEV2ZW5Db3VudHMob3V0c2lkZUNoYXIsIG51bU1vZHVsZXMpO1xuICAgICAgICAgICAgbGV0IG9kZFN1bSA9IDA7XG4gICAgICAgICAgICBsZXQgb2RkQ2hlY2tzdW1Qb3J0aW9uID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBvZGRDb3VudHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICBvZGRDaGVja3N1bVBvcnRpb24gKj0gOTtcbiAgICAgICAgICAgICAgICBvZGRDaGVja3N1bVBvcnRpb24gKz0gb2RkQ291bnRzW2ldO1xuICAgICAgICAgICAgICAgIG9kZFN1bSArPSBvZGRDb3VudHNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZXZlbkNoZWNrc3VtUG9ydGlvbiA9IDA7XG4gICAgICAgICAgICBsZXQgZXZlblN1bSA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gZXZlbkNvdW50cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgIGV2ZW5DaGVja3N1bVBvcnRpb24gKj0gOTtcbiAgICAgICAgICAgICAgICBldmVuQ2hlY2tzdW1Qb3J0aW9uICs9IGV2ZW5Db3VudHNbaV07XG4gICAgICAgICAgICAgICAgZXZlblN1bSArPSBldmVuQ291bnRzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGNoZWNrc3VtUG9ydGlvbiA9IG9kZENoZWNrc3VtUG9ydGlvbiArIDMgKiBldmVuQ2hlY2tzdW1Qb3J0aW9uO1xuICAgICAgICAgICAgaWYgKG91dHNpZGVDaGFyKSB7XG4gICAgICAgICAgICAgICAgaWYgKChvZGRTdW0gJiAweDAxKSAhPT0gMCB8fCBvZGRTdW0gPiAxMiB8fCBvZGRTdW0gPCA0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgZ3JvdXAgPSAoMTIgLSBvZGRTdW0pIC8gMjtcbiAgICAgICAgICAgICAgICBsZXQgb2RkV2lkZXN0ID0gUlNTMTRSZWFkZXIuT1VUU0lERV9PRERfV0lERVNUW2dyb3VwXTtcbiAgICAgICAgICAgICAgICBsZXQgZXZlbldpZGVzdCA9IDkgLSBvZGRXaWRlc3Q7XG4gICAgICAgICAgICAgICAgbGV0IHZPZGQgPSBSU1NVdGlscy5nZXRSU1N2YWx1ZShvZGRDb3VudHMsIG9kZFdpZGVzdCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIGxldCB2RXZlbiA9IFJTU1V0aWxzLmdldFJTU3ZhbHVlKGV2ZW5Db3VudHMsIGV2ZW5XaWRlc3QsIHRydWUpO1xuICAgICAgICAgICAgICAgIGxldCB0RXZlbiA9IFJTUzE0UmVhZGVyLk9VVFNJREVfRVZFTl9UT1RBTF9TVUJTRVRbZ3JvdXBdO1xuICAgICAgICAgICAgICAgIGxldCBnU3VtID0gUlNTMTRSZWFkZXIuT1VUU0lERV9HU1VNW2dyb3VwXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IERhdGFDaGFyYWN0ZXIodk9kZCAqIHRFdmVuICsgdkV2ZW4gKyBnU3VtLCBjaGVja3N1bVBvcnRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKChldmVuU3VtICYgMHgwMSkgIT09IDAgfHwgZXZlblN1bSA+IDEwIHx8IGV2ZW5TdW0gPCA0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgZ3JvdXAgPSAoMTAgLSBldmVuU3VtKSAvIDI7XG4gICAgICAgICAgICAgICAgbGV0IG9kZFdpZGVzdCA9IFJTUzE0UmVhZGVyLklOU0lERV9PRERfV0lERVNUW2dyb3VwXTtcbiAgICAgICAgICAgICAgICBsZXQgZXZlbldpZGVzdCA9IDkgLSBvZGRXaWRlc3Q7XG4gICAgICAgICAgICAgICAgbGV0IHZPZGQgPSBSU1NVdGlscy5nZXRSU1N2YWx1ZShvZGRDb3VudHMsIG9kZFdpZGVzdCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgbGV0IHZFdmVuID0gUlNTVXRpbHMuZ2V0UlNTdmFsdWUoZXZlbkNvdW50cywgZXZlbldpZGVzdCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIGxldCB0T2RkID0gUlNTMTRSZWFkZXIuSU5TSURFX09ERF9UT1RBTF9TVUJTRVRbZ3JvdXBdO1xuICAgICAgICAgICAgICAgIGxldCBnU3VtID0gUlNTMTRSZWFkZXIuSU5TSURFX0dTVU1bZ3JvdXBdO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRGF0YUNoYXJhY3Rlcih2RXZlbiAqIHRPZGQgKyB2T2RkICsgZ1N1bSwgY2hlY2tzdW1Qb3J0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmaW5kRmluZGVyUGF0dGVybihyb3csIHJpZ2h0RmluZGVyUGF0dGVybikge1xuICAgICAgICAgICAgbGV0IGNvdW50ZXJzID0gdGhpcy5nZXREZWNvZGVGaW5kZXJDb3VudGVycygpO1xuICAgICAgICAgICAgY291bnRlcnNbMF0gPSAwO1xuICAgICAgICAgICAgY291bnRlcnNbMV0gPSAwO1xuICAgICAgICAgICAgY291bnRlcnNbMl0gPSAwO1xuICAgICAgICAgICAgY291bnRlcnNbM10gPSAwO1xuICAgICAgICAgICAgbGV0IHdpZHRoID0gcm93LmdldFNpemUoKTtcbiAgICAgICAgICAgIGxldCBpc1doaXRlID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgcm93T2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIHdoaWxlIChyb3dPZmZzZXQgPCB3aWR0aCkge1xuICAgICAgICAgICAgICAgIGlzV2hpdGUgPSAhcm93LmdldChyb3dPZmZzZXQpO1xuICAgICAgICAgICAgICAgIGlmIChyaWdodEZpbmRlclBhdHRlcm4gPT09IGlzV2hpdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2lsbCBlbmNvdW50ZXIgd2hpdGUgZmlyc3Qgd2hlbiBzZWFyY2hpbmcgZm9yIHJpZ2h0IGZpbmRlciBwYXR0ZXJuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByb3dPZmZzZXQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBjb3VudGVyUG9zaXRpb24gPSAwO1xuICAgICAgICAgICAgbGV0IHBhdHRlcm5TdGFydCA9IHJvd09mZnNldDtcbiAgICAgICAgICAgIGZvciAobGV0IHggPSByb3dPZmZzZXQ7IHggPCB3aWR0aDsgeCsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJvdy5nZXQoeCkgIT09IGlzV2hpdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY291bnRlcnNbY291bnRlclBvc2l0aW9uXSsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvdW50ZXJQb3NpdGlvbiA9PT0gMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEFic3RyYWN0UlNTUmVhZGVyLmlzRmluZGVyUGF0dGVybihjb3VudGVycykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW3BhdHRlcm5TdGFydCwgeF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuU3RhcnQgKz0gY291bnRlcnNbMF0gKyBjb3VudGVyc1sxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJzWzBdID0gY291bnRlcnNbMl07XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyc1sxXSA9IGNvdW50ZXJzWzNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlcnNbMl0gPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlcnNbM10gPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlclBvc2l0aW9uLS07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyUG9zaXRpb24rKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb3VudGVyc1tjb3VudGVyUG9zaXRpb25dID0gMTtcbiAgICAgICAgICAgICAgICAgICAgaXNXaGl0ZSA9ICFpc1doaXRlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIHBhcnNlRm91bmRGaW5kZXJQYXR0ZXJuKHJvdywgcm93TnVtYmVyLCByaWdodCwgc3RhcnRFbmQpIHtcbiAgICAgICAgICAgIC8vIEFjdHVhbGx5IHdlIGZvdW5kIGVsZW1lbnRzIDItNVxuICAgICAgICAgICAgbGV0IGZpcnN0SXNCbGFjayA9IHJvdy5nZXQoc3RhcnRFbmRbMF0pO1xuICAgICAgICAgICAgbGV0IGZpcnN0RWxlbWVudFN0YXJ0ID0gc3RhcnRFbmRbMF0gLSAxO1xuICAgICAgICAgICAgLy8gTG9jYXRlIGVsZW1lbnQgMVxuICAgICAgICAgICAgd2hpbGUgKGZpcnN0RWxlbWVudFN0YXJ0ID49IDAgJiYgZmlyc3RJc0JsYWNrICE9PSByb3cuZ2V0KGZpcnN0RWxlbWVudFN0YXJ0KSkge1xuICAgICAgICAgICAgICAgIGZpcnN0RWxlbWVudFN0YXJ0LS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaXJzdEVsZW1lbnRTdGFydCsrO1xuICAgICAgICAgICAgY29uc3QgZmlyc3RDb3VudGVyID0gc3RhcnRFbmRbMF0gLSBmaXJzdEVsZW1lbnRTdGFydDtcbiAgICAgICAgICAgIC8vIE1ha2UgJ2NvdW50ZXJzJyBob2xkIDEtNFxuICAgICAgICAgICAgY29uc3QgY291bnRlcnMgPSB0aGlzLmdldERlY29kZUZpbmRlckNvdW50ZXJzKCk7XG4gICAgICAgICAgICBjb25zdCBjb3B5ID0gbmV3IEludDMyQXJyYXkoY291bnRlcnMubGVuZ3RoKTtcbiAgICAgICAgICAgIFN5c3RlbS5hcnJheWNvcHkoY291bnRlcnMsIDAsIGNvcHksIDEsIGNvdW50ZXJzLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgY29weVswXSA9IGZpcnN0Q291bnRlcjtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5wYXJzZUZpbmRlclZhbHVlKGNvcHksIFJTUzE0UmVhZGVyLkZJTkRFUl9QQVRURVJOUyk7XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSBmaXJzdEVsZW1lbnRTdGFydDtcbiAgICAgICAgICAgIGxldCBlbmQgPSBzdGFydEVuZFsxXTtcbiAgICAgICAgICAgIGlmIChyaWdodCkge1xuICAgICAgICAgICAgICAgIC8vIHJvdyBpcyBhY3R1YWxseSByZXZlcnNlZFxuICAgICAgICAgICAgICAgIHN0YXJ0ID0gcm93LmdldFNpemUoKSAtIDEgLSBzdGFydDtcbiAgICAgICAgICAgICAgICBlbmQgPSByb3cuZ2V0U2l6ZSgpIC0gMSAtIGVuZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgRmluZGVyUGF0dGVybih2YWx1ZSwgW2ZpcnN0RWxlbWVudFN0YXJ0LCBzdGFydEVuZFsxXV0sIHN0YXJ0LCBlbmQsIHJvd051bWJlcik7XG4gICAgICAgIH1cbiAgICAgICAgYWRqdXN0T2RkRXZlbkNvdW50cyhvdXRzaWRlQ2hhciwgbnVtTW9kdWxlcykge1xuICAgICAgICAgICAgbGV0IG9kZFN1bSA9IE1hdGhVdGlscy5zdW0obmV3IEludDMyQXJyYXkodGhpcy5nZXRPZGRDb3VudHMoKSkpO1xuICAgICAgICAgICAgbGV0IGV2ZW5TdW0gPSBNYXRoVXRpbHMuc3VtKG5ldyBJbnQzMkFycmF5KHRoaXMuZ2V0RXZlbkNvdW50cygpKSk7XG4gICAgICAgICAgICBsZXQgaW5jcmVtZW50T2RkID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgZGVjcmVtZW50T2RkID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgaW5jcmVtZW50RXZlbiA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IGRlY3JlbWVudEV2ZW4gPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChvdXRzaWRlQ2hhcikge1xuICAgICAgICAgICAgICAgIGlmIChvZGRTdW0gPiAxMikge1xuICAgICAgICAgICAgICAgICAgICBkZWNyZW1lbnRPZGQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChvZGRTdW0gPCA0KSB7XG4gICAgICAgICAgICAgICAgICAgIGluY3JlbWVudE9kZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChldmVuU3VtID4gMTIpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVjcmVtZW50RXZlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW5TdW0gPCA0KSB7XG4gICAgICAgICAgICAgICAgICAgIGluY3JlbWVudEV2ZW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChvZGRTdW0gPiAxMSkge1xuICAgICAgICAgICAgICAgICAgICBkZWNyZW1lbnRPZGQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChvZGRTdW0gPCA1KSB7XG4gICAgICAgICAgICAgICAgICAgIGluY3JlbWVudE9kZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChldmVuU3VtID4gMTApIHtcbiAgICAgICAgICAgICAgICAgICAgZGVjcmVtZW50RXZlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW5TdW0gPCA0KSB7XG4gICAgICAgICAgICAgICAgICAgIGluY3JlbWVudEV2ZW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBtaXNtYXRjaCA9IG9kZFN1bSArIGV2ZW5TdW0gLSBudW1Nb2R1bGVzO1xuICAgICAgICAgICAgbGV0IG9kZFBhcml0eUJhZCA9IChvZGRTdW0gJiAweDAxKSA9PT0gKG91dHNpZGVDaGFyID8gMSA6IDApO1xuICAgICAgICAgICAgbGV0IGV2ZW5QYXJpdHlCYWQgPSAoZXZlblN1bSAmIDB4MDEpID09PSAxO1xuICAgICAgICAgICAgaWYgKG1pc21hdGNoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9kZFBhcml0eUJhZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXZlblBhcml0eUJhZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZGVjcmVtZW50T2RkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZXZlblBhcml0eUJhZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZGVjcmVtZW50RXZlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobWlzbWF0Y2ggPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9kZFBhcml0eUJhZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXZlblBhcml0eUJhZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaW5jcmVtZW50T2RkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZXZlblBhcml0eUJhZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaW5jcmVtZW50RXZlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobWlzbWF0Y2ggPT09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAob2RkUGFyaXR5QmFkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZXZlblBhcml0eUJhZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gQm90aCBiYWRcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9kZFN1bSA8IGV2ZW5TdW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY3JlbWVudE9kZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWNyZW1lbnRFdmVuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlY3JlbWVudE9kZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmNyZW1lbnRFdmVuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW5QYXJpdHlCYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIE5vdGhpbmcgdG8gZG8hXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaW5jcmVtZW50T2RkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRlY3JlbWVudE9kZCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgQWJzdHJhY3RSU1NSZWFkZXIuaW5jcmVtZW50KHRoaXMuZ2V0T2RkQ291bnRzKCksIHRoaXMuZ2V0T2RkUm91bmRpbmdFcnJvcnMoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGVjcmVtZW50T2RkKSB7XG4gICAgICAgICAgICAgICAgQWJzdHJhY3RSU1NSZWFkZXIuZGVjcmVtZW50KHRoaXMuZ2V0T2RkQ291bnRzKCksIHRoaXMuZ2V0T2RkUm91bmRpbmdFcnJvcnMoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaW5jcmVtZW50RXZlbikge1xuICAgICAgICAgICAgICAgIGlmIChkZWNyZW1lbnRFdmVuKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBBYnN0cmFjdFJTU1JlYWRlci5pbmNyZW1lbnQodGhpcy5nZXRFdmVuQ291bnRzKCksIHRoaXMuZ2V0T2RkUm91bmRpbmdFcnJvcnMoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGVjcmVtZW50RXZlbikge1xuICAgICAgICAgICAgICAgIEFic3RyYWN0UlNTUmVhZGVyLmRlY3JlbWVudCh0aGlzLmdldEV2ZW5Db3VudHMoKSwgdGhpcy5nZXRFdmVuUm91bmRpbmdFcnJvcnMoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgUlNTMTRSZWFkZXIuT1VUU0lERV9FVkVOX1RPVEFMX1NVQlNFVCA9IFsxLCAxMCwgMzQsIDcwLCAxMjZdO1xuICAgIFJTUzE0UmVhZGVyLklOU0lERV9PRERfVE9UQUxfU1VCU0VUID0gWzQsIDIwLCA0OCwgODFdO1xuICAgIFJTUzE0UmVhZGVyLk9VVFNJREVfR1NVTSA9IFswLCAxNjEsIDk2MSwgMjAxNSwgMjcxNV07XG4gICAgUlNTMTRSZWFkZXIuSU5TSURFX0dTVU0gPSBbMCwgMzM2LCAxMDM2LCAxNTE2XTtcbiAgICBSU1MxNFJlYWRlci5PVVRTSURFX09ERF9XSURFU1QgPSBbOCwgNiwgNCwgMywgMV07XG4gICAgUlNTMTRSZWFkZXIuSU5TSURFX09ERF9XSURFU1QgPSBbMiwgNCwgNiwgOF07XG4gICAgUlNTMTRSZWFkZXIuRklOREVSX1BBVFRFUk5TID0gW1xuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzMsIDgsIDIsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFszLCA1LCA1LCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMywgMywgNywgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzMsIDEsIDksIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsyLCA3LCA0LCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMiwgNSwgNiwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzIsIDMsIDgsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCA1LCA3LCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMywgOSwgMV0pLFxuICAgIF07XG5cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIERhbmllbCBTd2l0a2luIDxkc3dpdGtpbkBnb29nbGUuY29tPlxuICAgICAqIEBhdXRob3IgU2VhbiBPd2VuXG4gICAgICovXG4gICAgY2xhc3MgTXVsdGlGb3JtYXRPbmVEUmVhZGVyIGV4dGVuZHMgT25lRFJlYWRlciB7XG4gICAgICAgIGNvbnN0cnVjdG9yKGhpbnRzLCB2ZXJib3NlKSB7XG4gICAgICAgICAgICBzdXBlcigpO1xuICAgICAgICAgICAgdGhpcy5yZWFkZXJzID0gW107XG4gICAgICAgICAgICB0aGlzLnZlcmJvc2UgPSAodmVyYm9zZSA9PT0gdHJ1ZSk7XG4gICAgICAgICAgICBjb25zdCBwb3NzaWJsZUZvcm1hdHMgPSAhaGludHMgPyBudWxsIDogaGludHMuZ2V0KERlY29kZUhpbnRUeXBlJDEuUE9TU0lCTEVfRk9STUFUUyk7XG4gICAgICAgICAgICBjb25zdCB1c2VDb2RlMzlDaGVja0RpZ2l0ID0gaGludHMgJiYgaGludHMuZ2V0KERlY29kZUhpbnRUeXBlJDEuQVNTVU1FX0NPREVfMzlfQ0hFQ0tfRElHSVQpICE9PSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAocG9zc2libGVGb3JtYXRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBvc3NpYmxlRm9ybWF0cy5pbmNsdWRlcyhCYXJjb2RlRm9ybWF0JDEuRUFOXzEzKSB8fFxuICAgICAgICAgICAgICAgICAgICBwb3NzaWJsZUZvcm1hdHMuaW5jbHVkZXMoQmFyY29kZUZvcm1hdCQxLlVQQ19BKSB8fFxuICAgICAgICAgICAgICAgICAgICBwb3NzaWJsZUZvcm1hdHMuaW5jbHVkZXMoQmFyY29kZUZvcm1hdCQxLkVBTl84KSB8fFxuICAgICAgICAgICAgICAgICAgICBwb3NzaWJsZUZvcm1hdHMuaW5jbHVkZXMoQmFyY29kZUZvcm1hdCQxLlVQQ19FKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWRlcnMucHVzaChuZXcgTXVsdGlGb3JtYXRVUENFQU5SZWFkZXIoaGludHMpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHBvc3NpYmxlRm9ybWF0cy5pbmNsdWRlcyhCYXJjb2RlRm9ybWF0JDEuQ09ERV8zOSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkZXJzLnB1c2gobmV3IENvZGUzOVJlYWRlcih1c2VDb2RlMzlDaGVja0RpZ2l0KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGlmIChwb3NzaWJsZUZvcm1hdHMuaW5jbHVkZXMoQmFyY29kZUZvcm1hdC5DT0RFXzkzKSkge1xuICAgICAgICAgICAgICAgIC8vICAgIHRoaXMucmVhZGVycy5wdXNoKG5ldyBDb2RlOTNSZWFkZXIoKSk7XG4gICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgICAgIGlmIChwb3NzaWJsZUZvcm1hdHMuaW5jbHVkZXMoQmFyY29kZUZvcm1hdCQxLkNPREVfMTI4KSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWRlcnMucHVzaChuZXcgQ29kZTEyOFJlYWRlcigpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHBvc3NpYmxlRm9ybWF0cy5pbmNsdWRlcyhCYXJjb2RlRm9ybWF0JDEuSVRGKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWRlcnMucHVzaChuZXcgSVRGUmVhZGVyKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBpZiAocG9zc2libGVGb3JtYXRzLmluY2x1ZGVzKEJhcmNvZGVGb3JtYXQuQ09EQUJBUikpIHtcbiAgICAgICAgICAgICAgICAvLyAgICB0aGlzLnJlYWRlcnMucHVzaChuZXcgQ29kYUJhclJlYWRlcigpKTtcbiAgICAgICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICAgICAgaWYgKHBvc3NpYmxlRm9ybWF0cy5pbmNsdWRlcyhCYXJjb2RlRm9ybWF0JDEuUlNTXzE0KSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWRlcnMucHVzaChuZXcgUlNTMTRSZWFkZXIoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwb3NzaWJsZUZvcm1hdHMuaW5jbHVkZXMoQmFyY29kZUZvcm1hdCQxLlJTU19FWFBBTkRFRCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkZXJzLnB1c2gobmV3IFJTU0V4cGFuZGVkUmVhZGVyKHRoaXMudmVyYm9zZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gQ2FzZSB3aGVuIG5vIGhpbnRzIHdlcmUgcHJvdmlkZWQgLT4gYWRkIGFsbC5cbiAgICAgICAgICAgICAgICB0aGlzLnJlYWRlcnMucHVzaChuZXcgTXVsdGlGb3JtYXRVUENFQU5SZWFkZXIoaGludHMpKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlYWRlcnMucHVzaChuZXcgQ29kZTM5UmVhZGVyKCkpO1xuICAgICAgICAgICAgICAgIC8vIHRoaXMucmVhZGVycy5wdXNoKG5ldyBDb2RhQmFyUmVhZGVyKCkpO1xuICAgICAgICAgICAgICAgIC8vIHRoaXMucmVhZGVycy5wdXNoKG5ldyBDb2RlOTNSZWFkZXIoKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWFkZXJzLnB1c2gobmV3IE11bHRpRm9ybWF0VVBDRUFOUmVhZGVyKGhpbnRzKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWFkZXJzLnB1c2gobmV3IENvZGUxMjhSZWFkZXIoKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWFkZXJzLnB1c2gobmV3IElURlJlYWRlcigpKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlYWRlcnMucHVzaChuZXcgUlNTMTRSZWFkZXIoKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWFkZXJzLnB1c2gobmV3IFJTU0V4cGFuZGVkUmVhZGVyKHRoaXMudmVyYm9zZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEBPdmVycmlkZVxuICAgICAgICBkZWNvZGVSb3cocm93TnVtYmVyLCByb3csIGhpbnRzKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucmVhZGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlYWRlcnNbaV0uZGVjb2RlUm93KHJvd051bWJlciwgcm93LCBoaW50cyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChyZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBjb250aW51ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEBPdmVycmlkZVxuICAgICAgICByZXNldCgpIHtcbiAgICAgICAgICAgIHRoaXMucmVhZGVycy5mb3JFYWNoKHJlYWRlciA9PiByZWFkZXIucmVzZXQoKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCBNb3ZpbmcgdG8gQHp4aW5nL2Jyb3dzZXJcbiAgICAgKlxuICAgICAqIEJhcmNvZGUgcmVhZGVyIHJlYWRlciB0byB1c2UgZnJvbSBicm93c2VyLlxuICAgICAqL1xuICAgIGNsYXNzIEJyb3dzZXJCYXJjb2RlUmVhZGVyIGV4dGVuZHMgQnJvd3NlckNvZGVSZWFkZXIge1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBCcm93c2VyQmFyY29kZVJlYWRlci5cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFt0aW1lQmV0d2VlblNjYW5zTWlsbGlzPTUwMF0gdGhlIHRpbWUgZGVsYXkgYmV0d2VlbiBzdWJzZXF1ZW50IGRlY29kZSB0cmllc1xuICAgICAgICAgKiBAcGFyYW0ge01hcDxEZWNvZGVIaW50VHlwZSwgYW55Pn0gaGludHNcbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0cnVjdG9yKHRpbWVCZXR3ZWVuU2NhbnNNaWxsaXMgPSA1MDAsIGhpbnRzKSB7XG4gICAgICAgICAgICBzdXBlcihuZXcgTXVsdGlGb3JtYXRPbmVEUmVhZGVyKGhpbnRzKSwgdGltZUJldHdlZW5TY2Fuc01pbGxpcywgaGludHMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBDb3B5cmlnaHQgMjAwNyBaWGluZyBhdXRob3JzXG4gICAgICpcbiAgICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgICAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgICAgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgICAgKlxuICAgICAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gICAgICpcbiAgICAgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICAgICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgICAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICAgICAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgICAgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiA8cD5FbmNhcHN1bGF0ZXMgYSBzZXQgb2YgZXJyb3ItY29ycmVjdGlvbiBibG9ja3MgaW4gb25lIHN5bWJvbCB2ZXJzaW9uLiBNb3N0IHZlcnNpb25zIHdpbGxcbiAgICAgKiB1c2UgYmxvY2tzIG9mIGRpZmZlcmluZyBzaXplcyB3aXRoaW4gb25lIHZlcnNpb24sIHNvLCB0aGlzIGVuY2Fwc3VsYXRlcyB0aGUgcGFyYW1ldGVycyBmb3JcbiAgICAgKiBlYWNoIHNldCBvZiBibG9ja3MuIEl0IGFsc28gaG9sZHMgdGhlIG51bWJlciBvZiBlcnJvci1jb3JyZWN0aW9uIGNvZGV3b3JkcyBwZXIgYmxvY2sgc2luY2UgaXRcbiAgICAgKiB3aWxsIGJlIHRoZSBzYW1lIGFjcm9zcyBhbGwgYmxvY2tzIHdpdGhpbiBvbmUgdmVyc2lvbi48L3A+XG4gICAgICovXG4gICAgY2xhc3MgRUNCbG9ja3Mge1xuICAgICAgICBjb25zdHJ1Y3RvcihlY0NvZGV3b3JkcywgZWNCbG9ja3MxLCBlY0Jsb2NrczIpIHtcbiAgICAgICAgICAgIHRoaXMuZWNDb2Rld29yZHMgPSBlY0NvZGV3b3JkcztcbiAgICAgICAgICAgIHRoaXMuZWNCbG9ja3MgPSBbZWNCbG9ja3MxXTtcbiAgICAgICAgICAgIGVjQmxvY2tzMiAmJiB0aGlzLmVjQmxvY2tzLnB1c2goZWNCbG9ja3MyKTtcbiAgICAgICAgfVxuICAgICAgICBnZXRFQ0NvZGV3b3JkcygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVjQ29kZXdvcmRzO1xuICAgICAgICB9XG4gICAgICAgIGdldEVDQmxvY2tzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWNCbG9ja3M7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogPHA+RW5jYXBzdWxhdGVzIHRoZSBwYXJhbWV0ZXJzIGZvciBvbmUgZXJyb3ItY29ycmVjdGlvbiBibG9jayBpbiBvbmUgc3ltYm9sIHZlcnNpb24uXG4gICAgICogVGhpcyBpbmNsdWRlcyB0aGUgbnVtYmVyIG9mIGRhdGEgY29kZXdvcmRzLCBhbmQgdGhlIG51bWJlciBvZiB0aW1lcyBhIGJsb2NrIHdpdGggdGhlc2VcbiAgICAgKiBwYXJhbWV0ZXJzIGlzIHVzZWQgY29uc2VjdXRpdmVseSBpbiB0aGUgRGF0YSBNYXRyaXggY29kZSB2ZXJzaW9uJ3MgZm9ybWF0LjwvcD5cbiAgICAgKi9cbiAgICBjbGFzcyBFQ0Ige1xuICAgICAgICBjb25zdHJ1Y3Rvcihjb3VudCwgZGF0YUNvZGV3b3Jkcykge1xuICAgICAgICAgICAgdGhpcy5jb3VudCA9IGNvdW50O1xuICAgICAgICAgICAgdGhpcy5kYXRhQ29kZXdvcmRzID0gZGF0YUNvZGV3b3JkcztcbiAgICAgICAgfVxuICAgICAgICBnZXRDb3VudCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvdW50O1xuICAgICAgICB9XG4gICAgICAgIGdldERhdGFDb2Rld29yZHMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhQ29kZXdvcmRzO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBWZXJzaW9uIG9iamVjdCBlbmNhcHN1bGF0ZXMgYXR0cmlidXRlcyBhYm91dCBhIHBhcnRpY3VsYXJcbiAgICAgKiBzaXplIERhdGEgTWF0cml4IENvZGUuXG4gICAgICpcbiAgICAgKiBAYXV0aG9yIGJicm93bkBnb29nbGUuY29tIChCcmlhbiBCcm93bilcbiAgICAgKi9cbiAgICBjbGFzcyBWZXJzaW9uIHtcbiAgICAgICAgY29uc3RydWN0b3IodmVyc2lvbk51bWJlciwgc3ltYm9sU2l6ZVJvd3MsIHN5bWJvbFNpemVDb2x1bW5zLCBkYXRhUmVnaW9uU2l6ZVJvd3MsIGRhdGFSZWdpb25TaXplQ29sdW1ucywgZWNCbG9ja3MpIHtcbiAgICAgICAgICAgIHRoaXMudmVyc2lvbk51bWJlciA9IHZlcnNpb25OdW1iZXI7XG4gICAgICAgICAgICB0aGlzLnN5bWJvbFNpemVSb3dzID0gc3ltYm9sU2l6ZVJvd3M7XG4gICAgICAgICAgICB0aGlzLnN5bWJvbFNpemVDb2x1bW5zID0gc3ltYm9sU2l6ZUNvbHVtbnM7XG4gICAgICAgICAgICB0aGlzLmRhdGFSZWdpb25TaXplUm93cyA9IGRhdGFSZWdpb25TaXplUm93cztcbiAgICAgICAgICAgIHRoaXMuZGF0YVJlZ2lvblNpemVDb2x1bW5zID0gZGF0YVJlZ2lvblNpemVDb2x1bW5zO1xuICAgICAgICAgICAgdGhpcy5lY0Jsb2NrcyA9IGVjQmxvY2tzO1xuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSB0b3RhbCBudW1iZXIgb2YgY29kZXdvcmRzXG4gICAgICAgICAgICBsZXQgdG90YWwgPSAwO1xuICAgICAgICAgICAgY29uc3QgZWNDb2Rld29yZHMgPSBlY0Jsb2Nrcy5nZXRFQ0NvZGV3b3JkcygpO1xuICAgICAgICAgICAgY29uc3QgZWNiQXJyYXkgPSBlY0Jsb2Nrcy5nZXRFQ0Jsb2NrcygpO1xuICAgICAgICAgICAgZm9yIChsZXQgZWNCbG9jayBvZiBlY2JBcnJheSkge1xuICAgICAgICAgICAgICAgIHRvdGFsICs9IGVjQmxvY2suZ2V0Q291bnQoKSAqIChlY0Jsb2NrLmdldERhdGFDb2Rld29yZHMoKSArIGVjQ29kZXdvcmRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudG90YWxDb2Rld29yZHMgPSB0b3RhbDtcbiAgICAgICAgfVxuICAgICAgICBnZXRWZXJzaW9uTnVtYmVyKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmVyc2lvbk51bWJlcjtcbiAgICAgICAgfVxuICAgICAgICBnZXRTeW1ib2xTaXplUm93cygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN5bWJvbFNpemVSb3dzO1xuICAgICAgICB9XG4gICAgICAgIGdldFN5bWJvbFNpemVDb2x1bW5zKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3ltYm9sU2l6ZUNvbHVtbnM7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0RGF0YVJlZ2lvblNpemVSb3dzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVJlZ2lvblNpemVSb3dzO1xuICAgICAgICB9XG4gICAgICAgIGdldERhdGFSZWdpb25TaXplQ29sdW1ucygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGFSZWdpb25TaXplQ29sdW1ucztcbiAgICAgICAgfVxuICAgICAgICBnZXRUb3RhbENvZGV3b3JkcygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvdGFsQ29kZXdvcmRzO1xuICAgICAgICB9XG4gICAgICAgIGdldEVDQmxvY2tzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWNCbG9ja3M7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIDxwPkRlZHVjZXMgdmVyc2lvbiBpbmZvcm1hdGlvbiBmcm9tIERhdGEgTWF0cml4IGRpbWVuc2lvbnMuPC9wPlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gbnVtUm93cyBOdW1iZXIgb2Ygcm93cyBpbiBtb2R1bGVzXG4gICAgICAgICAqIEBwYXJhbSBudW1Db2x1bW5zIE51bWJlciBvZiBjb2x1bW5zIGluIG1vZHVsZXNcbiAgICAgICAgICogQHJldHVybiBWZXJzaW9uIGZvciBhIERhdGEgTWF0cml4IENvZGUgb2YgdGhvc2UgZGltZW5zaW9uc1xuICAgICAgICAgKiBAdGhyb3dzIEZvcm1hdEV4Y2VwdGlvbiBpZiBkaW1lbnNpb25zIGRvIGNvcnJlc3BvbmQgdG8gYSB2YWxpZCBEYXRhIE1hdHJpeCBzaXplXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgZ2V0VmVyc2lvbkZvckRpbWVuc2lvbnMobnVtUm93cywgbnVtQ29sdW1ucykge1xuICAgICAgICAgICAgaWYgKChudW1Sb3dzICYgMHgwMSkgIT09IDAgfHwgKG51bUNvbHVtbnMgJiAweDAxKSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IHZlcnNpb24gb2YgVmVyc2lvbi5WRVJTSU9OUykge1xuICAgICAgICAgICAgICAgIGlmICh2ZXJzaW9uLnN5bWJvbFNpemVSb3dzID09PSBudW1Sb3dzICYmIHZlcnNpb24uc3ltYm9sU2l6ZUNvbHVtbnMgPT09IG51bUNvbHVtbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZlcnNpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIC8vICBAT3ZlcnJpZGVcbiAgICAgICAgdG9TdHJpbmcoKSB7XG4gICAgICAgICAgICByZXR1cm4gJycgKyB0aGlzLnZlcnNpb25OdW1iZXI7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNlZSBJU08gMTYwMjI6MjAwNiA1LjUuMSBUYWJsZSA3XG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgYnVpbGRWZXJzaW9ucygpIHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgbmV3IFZlcnNpb24oMSwgMTAsIDEwLCA4LCA4LCBuZXcgRUNCbG9ja3MoNSwgbmV3IEVDQigxLCAzKSkpLFxuICAgICAgICAgICAgICAgIG5ldyBWZXJzaW9uKDIsIDEyLCAxMiwgMTAsIDEwLCBuZXcgRUNCbG9ja3MoNywgbmV3IEVDQigxLCA1KSkpLFxuICAgICAgICAgICAgICAgIG5ldyBWZXJzaW9uKDMsIDE0LCAxNCwgMTIsIDEyLCBuZXcgRUNCbG9ja3MoMTAsIG5ldyBFQ0IoMSwgOCkpKSxcbiAgICAgICAgICAgICAgICBuZXcgVmVyc2lvbig0LCAxNiwgMTYsIDE0LCAxNCwgbmV3IEVDQmxvY2tzKDEyLCBuZXcgRUNCKDEsIDEyKSkpLFxuICAgICAgICAgICAgICAgIG5ldyBWZXJzaW9uKDUsIDE4LCAxOCwgMTYsIDE2LCBuZXcgRUNCbG9ja3MoMTQsIG5ldyBFQ0IoMSwgMTgpKSksXG4gICAgICAgICAgICAgICAgbmV3IFZlcnNpb24oNiwgMjAsIDIwLCAxOCwgMTgsIG5ldyBFQ0Jsb2NrcygxOCwgbmV3IEVDQigxLCAyMikpKSxcbiAgICAgICAgICAgICAgICBuZXcgVmVyc2lvbig3LCAyMiwgMjIsIDIwLCAyMCwgbmV3IEVDQmxvY2tzKDIwLCBuZXcgRUNCKDEsIDMwKSkpLFxuICAgICAgICAgICAgICAgIG5ldyBWZXJzaW9uKDgsIDI0LCAyNCwgMjIsIDIyLCBuZXcgRUNCbG9ja3MoMjQsIG5ldyBFQ0IoMSwgMzYpKSksXG4gICAgICAgICAgICAgICAgbmV3IFZlcnNpb24oOSwgMjYsIDI2LCAyNCwgMjQsIG5ldyBFQ0Jsb2NrcygyOCwgbmV3IEVDQigxLCA0NCkpKSxcbiAgICAgICAgICAgICAgICBuZXcgVmVyc2lvbigxMCwgMzIsIDMyLCAxNCwgMTQsIG5ldyBFQ0Jsb2NrcygzNiwgbmV3IEVDQigxLCA2MikpKSxcbiAgICAgICAgICAgICAgICBuZXcgVmVyc2lvbigxMSwgMzYsIDM2LCAxNiwgMTYsIG5ldyBFQ0Jsb2Nrcyg0MiwgbmV3IEVDQigxLCA4NikpKSxcbiAgICAgICAgICAgICAgICBuZXcgVmVyc2lvbigxMiwgNDAsIDQwLCAxOCwgMTgsIG5ldyBFQ0Jsb2Nrcyg0OCwgbmV3IEVDQigxLCAxMTQpKSksXG4gICAgICAgICAgICAgICAgbmV3IFZlcnNpb24oMTMsIDQ0LCA0NCwgMjAsIDIwLCBuZXcgRUNCbG9ja3MoNTYsIG5ldyBFQ0IoMSwgMTQ0KSkpLFxuICAgICAgICAgICAgICAgIG5ldyBWZXJzaW9uKDE0LCA0OCwgNDgsIDIyLCAyMiwgbmV3IEVDQmxvY2tzKDY4LCBuZXcgRUNCKDEsIDE3NCkpKSxcbiAgICAgICAgICAgICAgICBuZXcgVmVyc2lvbigxNSwgNTIsIDUyLCAyNCwgMjQsIG5ldyBFQ0Jsb2Nrcyg0MiwgbmV3IEVDQigyLCAxMDIpKSksXG4gICAgICAgICAgICAgICAgbmV3IFZlcnNpb24oMTYsIDY0LCA2NCwgMTQsIDE0LCBuZXcgRUNCbG9ja3MoNTYsIG5ldyBFQ0IoMiwgMTQwKSkpLFxuICAgICAgICAgICAgICAgIG5ldyBWZXJzaW9uKDE3LCA3MiwgNzIsIDE2LCAxNiwgbmV3IEVDQmxvY2tzKDM2LCBuZXcgRUNCKDQsIDkyKSkpLFxuICAgICAgICAgICAgICAgIG5ldyBWZXJzaW9uKDE4LCA4MCwgODAsIDE4LCAxOCwgbmV3IEVDQmxvY2tzKDQ4LCBuZXcgRUNCKDQsIDExNCkpKSxcbiAgICAgICAgICAgICAgICBuZXcgVmVyc2lvbigxOSwgODgsIDg4LCAyMCwgMjAsIG5ldyBFQ0Jsb2Nrcyg1NiwgbmV3IEVDQig0LCAxNDQpKSksXG4gICAgICAgICAgICAgICAgbmV3IFZlcnNpb24oMjAsIDk2LCA5NiwgMjIsIDIyLCBuZXcgRUNCbG9ja3MoNjgsIG5ldyBFQ0IoNCwgMTc0KSkpLFxuICAgICAgICAgICAgICAgIG5ldyBWZXJzaW9uKDIxLCAxMDQsIDEwNCwgMjQsIDI0LCBuZXcgRUNCbG9ja3MoNTYsIG5ldyBFQ0IoNiwgMTM2KSkpLFxuICAgICAgICAgICAgICAgIG5ldyBWZXJzaW9uKDIyLCAxMjAsIDEyMCwgMTgsIDE4LCBuZXcgRUNCbG9ja3MoNjgsIG5ldyBFQ0IoNiwgMTc1KSkpLFxuICAgICAgICAgICAgICAgIG5ldyBWZXJzaW9uKDIzLCAxMzIsIDEzMiwgMjAsIDIwLCBuZXcgRUNCbG9ja3MoNjIsIG5ldyBFQ0IoOCwgMTYzKSkpLFxuICAgICAgICAgICAgICAgIG5ldyBWZXJzaW9uKDI0LCAxNDQsIDE0NCwgMjIsIDIyLCBuZXcgRUNCbG9ja3MoNjIsIG5ldyBFQ0IoOCwgMTU2KSwgbmV3IEVDQigyLCAxNTUpKSksXG4gICAgICAgICAgICAgICAgbmV3IFZlcnNpb24oMjUsIDgsIDE4LCA2LCAxNiwgbmV3IEVDQmxvY2tzKDcsIG5ldyBFQ0IoMSwgNSkpKSxcbiAgICAgICAgICAgICAgICBuZXcgVmVyc2lvbigyNiwgOCwgMzIsIDYsIDE0LCBuZXcgRUNCbG9ja3MoMTEsIG5ldyBFQ0IoMSwgMTApKSksXG4gICAgICAgICAgICAgICAgbmV3IFZlcnNpb24oMjcsIDEyLCAyNiwgMTAsIDI0LCBuZXcgRUNCbG9ja3MoMTQsIG5ldyBFQ0IoMSwgMTYpKSksXG4gICAgICAgICAgICAgICAgbmV3IFZlcnNpb24oMjgsIDEyLCAzNiwgMTAsIDE2LCBuZXcgRUNCbG9ja3MoMTgsIG5ldyBFQ0IoMSwgMjIpKSksXG4gICAgICAgICAgICAgICAgbmV3IFZlcnNpb24oMjksIDE2LCAzNiwgMTQsIDE2LCBuZXcgRUNCbG9ja3MoMjQsIG5ldyBFQ0IoMSwgMzIpKSksXG4gICAgICAgICAgICAgICAgbmV3IFZlcnNpb24oMzAsIDE2LCA0OCwgMTQsIDIyLCBuZXcgRUNCbG9ja3MoMjgsIG5ldyBFQ0IoMSwgNDkpKSlcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgVmVyc2lvbi5WRVJTSU9OUyA9IFZlcnNpb24uYnVpbGRWZXJzaW9ucygpO1xuXG4gICAgLypcbiAgICAgKiBDb3B5cmlnaHQgMjAwNyBaWGluZyBhdXRob3JzXG4gICAgICpcbiAgICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgICAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgICAgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgICAgKlxuICAgICAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gICAgICpcbiAgICAgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICAgICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgICAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICAgICAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgICAgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIGJicm93bkBnb29nbGUuY29tIChCcmlhbiBCcm93bilcbiAgICAgKi9cbiAgICBjbGFzcyBCaXRNYXRyaXhQYXJzZXIge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIGJpdE1hdHJpeCB7QGxpbmsgQml0TWF0cml4fSB0byBwYXJzZVxuICAgICAgICAgKiBAdGhyb3dzIEZvcm1hdEV4Y2VwdGlvbiBpZiBkaW1lbnNpb24gaXMgPCA4IG9yID4gMTQ0IG9yIG5vdCAwIG1vZCAyXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdHJ1Y3RvcihiaXRNYXRyaXgpIHtcbiAgICAgICAgICAgIGNvbnN0IGRpbWVuc2lvbiA9IGJpdE1hdHJpeC5nZXRIZWlnaHQoKTtcbiAgICAgICAgICAgIGlmIChkaW1lbnNpb24gPCA4IHx8IGRpbWVuc2lvbiA+IDE0NCB8fCAoZGltZW5zaW9uICYgMHgwMSkgIT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnZlcnNpb24gPSBCaXRNYXRyaXhQYXJzZXIucmVhZFZlcnNpb24oYml0TWF0cml4KTtcbiAgICAgICAgICAgIHRoaXMubWFwcGluZ0JpdE1hdHJpeCA9IHRoaXMuZXh0cmFjdERhdGFSZWdpb24oYml0TWF0cml4KTtcbiAgICAgICAgICAgIHRoaXMucmVhZE1hcHBpbmdNYXRyaXggPSBuZXcgQml0TWF0cml4KHRoaXMubWFwcGluZ0JpdE1hdHJpeC5nZXRXaWR0aCgpLCB0aGlzLm1hcHBpbmdCaXRNYXRyaXguZ2V0SGVpZ2h0KCkpO1xuICAgICAgICB9XG4gICAgICAgIGdldFZlcnNpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52ZXJzaW9uO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiA8cD5DcmVhdGVzIHRoZSB2ZXJzaW9uIG9iamVjdCBiYXNlZCBvbiB0aGUgZGltZW5zaW9uIG9mIHRoZSBvcmlnaW5hbCBiaXQgbWF0cml4IGZyb21cbiAgICAgICAgICogdGhlIGRhdGFtYXRyaXggY29kZS48L3A+XG4gICAgICAgICAqXG4gICAgICAgICAqIDxwPlNlZSBJU08gMTYwMjI6MjAwNiBUYWJsZSA3IC0gRUNDIDIwMCBzeW1ib2wgYXR0cmlidXRlczwvcD5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGJpdE1hdHJpeCBPcmlnaW5hbCB7QGxpbmsgQml0TWF0cml4fSBpbmNsdWRpbmcgYWxpZ25tZW50IHBhdHRlcm5zXG4gICAgICAgICAqIEByZXR1cm4ge0BsaW5rIFZlcnNpb259IGVuY2Fwc3VsYXRpbmcgdGhlIERhdGEgTWF0cml4IENvZGUncyBcInZlcnNpb25cIlxuICAgICAgICAgKiBAdGhyb3dzIEZvcm1hdEV4Y2VwdGlvbiBpZiB0aGUgZGltZW5zaW9ucyBvZiB0aGUgbWFwcGluZyBtYXRyaXggYXJlIG5vdCB2YWxpZFxuICAgICAgICAgKiBEYXRhIE1hdHJpeCBkaW1lbnNpb25zLlxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIHJlYWRWZXJzaW9uKGJpdE1hdHJpeCkge1xuICAgICAgICAgICAgY29uc3QgbnVtUm93cyA9IGJpdE1hdHJpeC5nZXRIZWlnaHQoKTtcbiAgICAgICAgICAgIGNvbnN0IG51bUNvbHVtbnMgPSBiaXRNYXRyaXguZ2V0V2lkdGgoKTtcbiAgICAgICAgICAgIHJldHVybiBWZXJzaW9uLmdldFZlcnNpb25Gb3JEaW1lbnNpb25zKG51bVJvd3MsIG51bUNvbHVtbnMpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiA8cD5SZWFkcyB0aGUgYml0cyBpbiB0aGUge0BsaW5rIEJpdE1hdHJpeH0gcmVwcmVzZW50aW5nIHRoZSBtYXBwaW5nIG1hdHJpeCAoTm8gYWxpZ25tZW50IHBhdHRlcm5zKVxuICAgICAgICAgKiBpbiB0aGUgY29ycmVjdCBvcmRlciBpbiBvcmRlciB0byByZWNvbnN0aXR1dGUgdGhlIGNvZGV3b3JkcyBieXRlcyBjb250YWluZWQgd2l0aGluIHRoZVxuICAgICAgICAgKiBEYXRhIE1hdHJpeCBDb2RlLjwvcD5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiBieXRlcyBlbmNvZGVkIHdpdGhpbiB0aGUgRGF0YSBNYXRyaXggQ29kZVxuICAgICAgICAgKiBAdGhyb3dzIEZvcm1hdEV4Y2VwdGlvbiBpZiB0aGUgZXhhY3QgbnVtYmVyIG9mIGJ5dGVzIGV4cGVjdGVkIGlzIG5vdCByZWFkXG4gICAgICAgICAqL1xuICAgICAgICByZWFkQ29kZXdvcmRzKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IEludDhBcnJheSh0aGlzLnZlcnNpb24uZ2V0VG90YWxDb2Rld29yZHMoKSk7XG4gICAgICAgICAgICBsZXQgcmVzdWx0T2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIGxldCByb3cgPSA0O1xuICAgICAgICAgICAgbGV0IGNvbHVtbiA9IDA7XG4gICAgICAgICAgICBjb25zdCBudW1Sb3dzID0gdGhpcy5tYXBwaW5nQml0TWF0cml4LmdldEhlaWdodCgpO1xuICAgICAgICAgICAgY29uc3QgbnVtQ29sdW1ucyA9IHRoaXMubWFwcGluZ0JpdE1hdHJpeC5nZXRXaWR0aCgpO1xuICAgICAgICAgICAgbGV0IGNvcm5lcjFSZWFkID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgY29ybmVyMlJlYWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGxldCBjb3JuZXIzUmVhZCA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IGNvcm5lcjRSZWFkID0gZmFsc2U7XG4gICAgICAgICAgICAvLyBSZWFkIGFsbCBvZiB0aGUgY29kZXdvcmRzXG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgdGhlIGZvdXIgY29ybmVyIGNhc2VzXG4gICAgICAgICAgICAgICAgaWYgKChyb3cgPT09IG51bVJvd3MpICYmIChjb2x1bW4gPT09IDApICYmICFjb3JuZXIxUmVhZCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRbcmVzdWx0T2Zmc2V0KytdID0gdGhpcy5yZWFkQ29ybmVyMShudW1Sb3dzLCBudW1Db2x1bW5zKSAmIDB4ZmY7XG4gICAgICAgICAgICAgICAgICAgIHJvdyAtPSAyO1xuICAgICAgICAgICAgICAgICAgICBjb2x1bW4gKz0gMjtcbiAgICAgICAgICAgICAgICAgICAgY29ybmVyMVJlYWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICgocm93ID09PSBudW1Sb3dzIC0gMikgJiYgKGNvbHVtbiA9PT0gMCkgJiYgKChudW1Db2x1bW5zICYgMHgwMykgIT09IDApICYmICFjb3JuZXIyUmVhZCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRbcmVzdWx0T2Zmc2V0KytdID0gdGhpcy5yZWFkQ29ybmVyMihudW1Sb3dzLCBudW1Db2x1bW5zKSAmIDB4ZmY7XG4gICAgICAgICAgICAgICAgICAgIHJvdyAtPSAyO1xuICAgICAgICAgICAgICAgICAgICBjb2x1bW4gKz0gMjtcbiAgICAgICAgICAgICAgICAgICAgY29ybmVyMlJlYWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICgocm93ID09PSBudW1Sb3dzICsgNCkgJiYgKGNvbHVtbiA9PT0gMikgJiYgKChudW1Db2x1bW5zICYgMHgwNykgPT09IDApICYmICFjb3JuZXIzUmVhZCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRbcmVzdWx0T2Zmc2V0KytdID0gdGhpcy5yZWFkQ29ybmVyMyhudW1Sb3dzLCBudW1Db2x1bW5zKSAmIDB4ZmY7XG4gICAgICAgICAgICAgICAgICAgIHJvdyAtPSAyO1xuICAgICAgICAgICAgICAgICAgICBjb2x1bW4gKz0gMjtcbiAgICAgICAgICAgICAgICAgICAgY29ybmVyM1JlYWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICgocm93ID09PSBudW1Sb3dzIC0gMikgJiYgKGNvbHVtbiA9PT0gMCkgJiYgKChudW1Db2x1bW5zICYgMHgwNykgPT09IDQpICYmICFjb3JuZXI0UmVhZCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRbcmVzdWx0T2Zmc2V0KytdID0gdGhpcy5yZWFkQ29ybmVyNChudW1Sb3dzLCBudW1Db2x1bW5zKSAmIDB4ZmY7XG4gICAgICAgICAgICAgICAgICAgIHJvdyAtPSAyO1xuICAgICAgICAgICAgICAgICAgICBjb2x1bW4gKz0gMjtcbiAgICAgICAgICAgICAgICAgICAgY29ybmVyNFJlYWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU3dlZXAgdXB3YXJkIGRpYWdvbmFsbHkgdG8gdGhlIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgocm93IDwgbnVtUm93cykgJiYgKGNvbHVtbiA+PSAwKSAmJiAhdGhpcy5yZWFkTWFwcGluZ01hdHJpeC5nZXQoY29sdW1uLCByb3cpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W3Jlc3VsdE9mZnNldCsrXSA9IHRoaXMucmVhZFV0YWgocm93LCBjb2x1bW4sIG51bVJvd3MsIG51bUNvbHVtbnMpICYgMHhmZjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdyAtPSAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uICs9IDI7XG4gICAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKChyb3cgPj0gMCkgJiYgKGNvbHVtbiA8IG51bUNvbHVtbnMpKTtcbiAgICAgICAgICAgICAgICAgICAgcm93ICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbiArPSAzO1xuICAgICAgICAgICAgICAgICAgICAvLyBTd2VlcCBkb3dud2FyZCBkaWFnb25hbGx5IHRvIHRoZSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgocm93ID49IDApICYmIChjb2x1bW4gPCBudW1Db2x1bW5zKSAmJiAhdGhpcy5yZWFkTWFwcGluZ01hdHJpeC5nZXQoY29sdW1uLCByb3cpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W3Jlc3VsdE9mZnNldCsrXSA9IHRoaXMucmVhZFV0YWgocm93LCBjb2x1bW4sIG51bVJvd3MsIG51bUNvbHVtbnMpICYgMHhmZjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdyArPSAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uIC09IDI7XG4gICAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKChyb3cgPCBudW1Sb3dzKSAmJiAoY29sdW1uID49IDApKTtcbiAgICAgICAgICAgICAgICAgICAgcm93ICs9IDM7XG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbiArPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKChyb3cgPCBudW1Sb3dzKSB8fCAoY29sdW1uIDwgbnVtQ29sdW1ucykpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdE9mZnNldCAhPT0gdGhpcy52ZXJzaW9uLmdldFRvdGFsQ29kZXdvcmRzKCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiA8cD5SZWFkcyBhIGJpdCBvZiB0aGUgbWFwcGluZyBtYXRyaXggYWNjb3VudGluZyBmb3IgYm91bmRhcnkgd3JhcHBpbmcuPC9wPlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gcm93IFJvdyB0byByZWFkIGluIHRoZSBtYXBwaW5nIG1hdHJpeFxuICAgICAgICAgKiBAcGFyYW0gY29sdW1uIENvbHVtbiB0byByZWFkIGluIHRoZSBtYXBwaW5nIG1hdHJpeFxuICAgICAgICAgKiBAcGFyYW0gbnVtUm93cyBOdW1iZXIgb2Ygcm93cyBpbiB0aGUgbWFwcGluZyBtYXRyaXhcbiAgICAgICAgICogQHBhcmFtIG51bUNvbHVtbnMgTnVtYmVyIG9mIGNvbHVtbnMgaW4gdGhlIG1hcHBpbmcgbWF0cml4XG4gICAgICAgICAqIEByZXR1cm4gdmFsdWUgb2YgdGhlIGdpdmVuIGJpdCBpbiB0aGUgbWFwcGluZyBtYXRyaXhcbiAgICAgICAgICovXG4gICAgICAgIHJlYWRNb2R1bGUocm93LCBjb2x1bW4sIG51bVJvd3MsIG51bUNvbHVtbnMpIHtcbiAgICAgICAgICAgIC8vIEFkanVzdCB0aGUgcm93IGFuZCBjb2x1bW4gaW5kaWNlcyBiYXNlZCBvbiBib3VuZGFyeSB3cmFwcGluZ1xuICAgICAgICAgICAgaWYgKHJvdyA8IDApIHtcbiAgICAgICAgICAgICAgICByb3cgKz0gbnVtUm93cztcbiAgICAgICAgICAgICAgICBjb2x1bW4gKz0gNCAtICgobnVtUm93cyArIDQpICYgMHgwNyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29sdW1uIDwgMCkge1xuICAgICAgICAgICAgICAgIGNvbHVtbiArPSBudW1Db2x1bW5zO1xuICAgICAgICAgICAgICAgIHJvdyArPSA0IC0gKChudW1Db2x1bW5zICsgNCkgJiAweDA3KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmVhZE1hcHBpbmdNYXRyaXguc2V0KGNvbHVtbiwgcm93KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1hcHBpbmdCaXRNYXRyaXguZ2V0KGNvbHVtbiwgcm93KTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogPHA+UmVhZHMgdGhlIDggYml0cyBvZiB0aGUgc3RhbmRhcmQgVXRhaC1zaGFwZWQgcGF0dGVybi48L3A+XG4gICAgICAgICAqXG4gICAgICAgICAqIDxwPlNlZSBJU08gMTYwMjI6MjAwNiwgNS44LjEgRmlndXJlIDY8L3A+XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSByb3cgQ3VycmVudCByb3cgaW4gdGhlIG1hcHBpbmcgbWF0cml4LCBhbmNob3JlZCBhdCB0aGUgOHRoIGJpdCAoTFNCKSBvZiB0aGUgcGF0dGVyblxuICAgICAgICAgKiBAcGFyYW0gY29sdW1uIEN1cnJlbnQgY29sdW1uIGluIHRoZSBtYXBwaW5nIG1hdHJpeCwgYW5jaG9yZWQgYXQgdGhlIDh0aCBiaXQgKExTQikgb2YgdGhlIHBhdHRlcm5cbiAgICAgICAgICogQHBhcmFtIG51bVJvd3MgTnVtYmVyIG9mIHJvd3MgaW4gdGhlIG1hcHBpbmcgbWF0cml4XG4gICAgICAgICAqIEBwYXJhbSBudW1Db2x1bW5zIE51bWJlciBvZiBjb2x1bW5zIGluIHRoZSBtYXBwaW5nIG1hdHJpeFxuICAgICAgICAgKiBAcmV0dXJuIGJ5dGUgZnJvbSB0aGUgdXRhaCBzaGFwZVxuICAgICAgICAgKi9cbiAgICAgICAgcmVhZFV0YWgocm93LCBjb2x1bW4sIG51bVJvd3MsIG51bUNvbHVtbnMpIHtcbiAgICAgICAgICAgIGxldCBjdXJyZW50Qnl0ZSA9IDA7XG4gICAgICAgICAgICBpZiAodGhpcy5yZWFkTW9kdWxlKHJvdyAtIDIsIGNvbHVtbiAtIDIsIG51bVJvd3MsIG51bUNvbHVtbnMpKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudEJ5dGUgfD0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnRCeXRlIDw8PSAxO1xuICAgICAgICAgICAgaWYgKHRoaXMucmVhZE1vZHVsZShyb3cgLSAyLCBjb2x1bW4gLSAxLCBudW1Sb3dzLCBudW1Db2x1bW5zKSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRCeXRlIHw9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50Qnl0ZSA8PD0gMTtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlYWRNb2R1bGUocm93IC0gMSwgY29sdW1uIC0gMiwgbnVtUm93cywgbnVtQ29sdW1ucykpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50Qnl0ZSB8PSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudEJ5dGUgPDw9IDE7XG4gICAgICAgICAgICBpZiAodGhpcy5yZWFkTW9kdWxlKHJvdyAtIDEsIGNvbHVtbiAtIDEsIG51bVJvd3MsIG51bUNvbHVtbnMpKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudEJ5dGUgfD0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnRCeXRlIDw8PSAxO1xuICAgICAgICAgICAgaWYgKHRoaXMucmVhZE1vZHVsZShyb3cgLSAxLCBjb2x1bW4sIG51bVJvd3MsIG51bUNvbHVtbnMpKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudEJ5dGUgfD0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnRCeXRlIDw8PSAxO1xuICAgICAgICAgICAgaWYgKHRoaXMucmVhZE1vZHVsZShyb3csIGNvbHVtbiAtIDIsIG51bVJvd3MsIG51bUNvbHVtbnMpKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudEJ5dGUgfD0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnRCeXRlIDw8PSAxO1xuICAgICAgICAgICAgaWYgKHRoaXMucmVhZE1vZHVsZShyb3csIGNvbHVtbiAtIDEsIG51bVJvd3MsIG51bUNvbHVtbnMpKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudEJ5dGUgfD0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnRCeXRlIDw8PSAxO1xuICAgICAgICAgICAgaWYgKHRoaXMucmVhZE1vZHVsZShyb3csIGNvbHVtbiwgbnVtUm93cywgbnVtQ29sdW1ucykpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50Qnl0ZSB8PSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRCeXRlO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiA8cD5SZWFkcyB0aGUgOCBiaXRzIG9mIHRoZSBzcGVjaWFsIGNvcm5lciBjb25kaXRpb24gMS48L3A+XG4gICAgICAgICAqXG4gICAgICAgICAqIDxwPlNlZSBJU08gMTYwMjI6MjAwNiwgRmlndXJlIEYuMzwvcD5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIG51bVJvd3MgTnVtYmVyIG9mIHJvd3MgaW4gdGhlIG1hcHBpbmcgbWF0cml4XG4gICAgICAgICAqIEBwYXJhbSBudW1Db2x1bW5zIE51bWJlciBvZiBjb2x1bW5zIGluIHRoZSBtYXBwaW5nIG1hdHJpeFxuICAgICAgICAgKiBAcmV0dXJuIGJ5dGUgZnJvbSB0aGUgQ29ybmVyIGNvbmRpdGlvbiAxXG4gICAgICAgICAqL1xuICAgICAgICByZWFkQ29ybmVyMShudW1Sb3dzLCBudW1Db2x1bW5zKSB7XG4gICAgICAgICAgICBsZXQgY3VycmVudEJ5dGUgPSAwO1xuICAgICAgICAgICAgaWYgKHRoaXMucmVhZE1vZHVsZShudW1Sb3dzIC0gMSwgMCwgbnVtUm93cywgbnVtQ29sdW1ucykpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50Qnl0ZSB8PSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudEJ5dGUgPDw9IDE7XG4gICAgICAgICAgICBpZiAodGhpcy5yZWFkTW9kdWxlKG51bVJvd3MgLSAxLCAxLCBudW1Sb3dzLCBudW1Db2x1bW5zKSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRCeXRlIHw9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50Qnl0ZSA8PD0gMTtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlYWRNb2R1bGUobnVtUm93cyAtIDEsIDIsIG51bVJvd3MsIG51bUNvbHVtbnMpKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudEJ5dGUgfD0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnRCeXRlIDw8PSAxO1xuICAgICAgICAgICAgaWYgKHRoaXMucmVhZE1vZHVsZSgwLCBudW1Db2x1bW5zIC0gMiwgbnVtUm93cywgbnVtQ29sdW1ucykpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50Qnl0ZSB8PSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudEJ5dGUgPDw9IDE7XG4gICAgICAgICAgICBpZiAodGhpcy5yZWFkTW9kdWxlKDAsIG51bUNvbHVtbnMgLSAxLCBudW1Sb3dzLCBudW1Db2x1bW5zKSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRCeXRlIHw9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50Qnl0ZSA8PD0gMTtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlYWRNb2R1bGUoMSwgbnVtQ29sdW1ucyAtIDEsIG51bVJvd3MsIG51bUNvbHVtbnMpKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudEJ5dGUgfD0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnRCeXRlIDw8PSAxO1xuICAgICAgICAgICAgaWYgKHRoaXMucmVhZE1vZHVsZSgyLCBudW1Db2x1bW5zIC0gMSwgbnVtUm93cywgbnVtQ29sdW1ucykpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50Qnl0ZSB8PSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudEJ5dGUgPDw9IDE7XG4gICAgICAgICAgICBpZiAodGhpcy5yZWFkTW9kdWxlKDMsIG51bUNvbHVtbnMgLSAxLCBudW1Sb3dzLCBudW1Db2x1bW5zKSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRCeXRlIHw9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY3VycmVudEJ5dGU7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIDxwPlJlYWRzIHRoZSA4IGJpdHMgb2YgdGhlIHNwZWNpYWwgY29ybmVyIGNvbmRpdGlvbiAyLjwvcD5cbiAgICAgICAgICpcbiAgICAgICAgICogPHA+U2VlIElTTyAxNjAyMjoyMDA2LCBGaWd1cmUgRi40PC9wPlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gbnVtUm93cyBOdW1iZXIgb2Ygcm93cyBpbiB0aGUgbWFwcGluZyBtYXRyaXhcbiAgICAgICAgICogQHBhcmFtIG51bUNvbHVtbnMgTnVtYmVyIG9mIGNvbHVtbnMgaW4gdGhlIG1hcHBpbmcgbWF0cml4XG4gICAgICAgICAqIEByZXR1cm4gYnl0ZSBmcm9tIHRoZSBDb3JuZXIgY29uZGl0aW9uIDJcbiAgICAgICAgICovXG4gICAgICAgIHJlYWRDb3JuZXIyKG51bVJvd3MsIG51bUNvbHVtbnMpIHtcbiAgICAgICAgICAgIGxldCBjdXJyZW50Qnl0ZSA9IDA7XG4gICAgICAgICAgICBpZiAodGhpcy5yZWFkTW9kdWxlKG51bVJvd3MgLSAzLCAwLCBudW1Sb3dzLCBudW1Db2x1bW5zKSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRCeXRlIHw9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50Qnl0ZSA8PD0gMTtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlYWRNb2R1bGUobnVtUm93cyAtIDIsIDAsIG51bVJvd3MsIG51bUNvbHVtbnMpKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudEJ5dGUgfD0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnRCeXRlIDw8PSAxO1xuICAgICAgICAgICAgaWYgKHRoaXMucmVhZE1vZHVsZShudW1Sb3dzIC0gMSwgMCwgbnVtUm93cywgbnVtQ29sdW1ucykpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50Qnl0ZSB8PSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudEJ5dGUgPDw9IDE7XG4gICAgICAgICAgICBpZiAodGhpcy5yZWFkTW9kdWxlKDAsIG51bUNvbHVtbnMgLSA0LCBudW1Sb3dzLCBudW1Db2x1bW5zKSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRCeXRlIHw9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50Qnl0ZSA8PD0gMTtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlYWRNb2R1bGUoMCwgbnVtQ29sdW1ucyAtIDMsIG51bVJvd3MsIG51bUNvbHVtbnMpKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudEJ5dGUgfD0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnRCeXRlIDw8PSAxO1xuICAgICAgICAgICAgaWYgKHRoaXMucmVhZE1vZHVsZSgwLCBudW1Db2x1bW5zIC0gMiwgbnVtUm93cywgbnVtQ29sdW1ucykpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50Qnl0ZSB8PSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudEJ5dGUgPDw9IDE7XG4gICAgICAgICAgICBpZiAodGhpcy5yZWFkTW9kdWxlKDAsIG51bUNvbHVtbnMgLSAxLCBudW1Sb3dzLCBudW1Db2x1bW5zKSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRCeXRlIHw9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50Qnl0ZSA8PD0gMTtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlYWRNb2R1bGUoMSwgbnVtQ29sdW1ucyAtIDEsIG51bVJvd3MsIG51bUNvbHVtbnMpKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudEJ5dGUgfD0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50Qnl0ZTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogPHA+UmVhZHMgdGhlIDggYml0cyBvZiB0aGUgc3BlY2lhbCBjb3JuZXIgY29uZGl0aW9uIDMuPC9wPlxuICAgICAgICAgKlxuICAgICAgICAgKiA8cD5TZWUgSVNPIDE2MDIyOjIwMDYsIEZpZ3VyZSBGLjU8L3A+XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBudW1Sb3dzIE51bWJlciBvZiByb3dzIGluIHRoZSBtYXBwaW5nIG1hdHJpeFxuICAgICAgICAgKiBAcGFyYW0gbnVtQ29sdW1ucyBOdW1iZXIgb2YgY29sdW1ucyBpbiB0aGUgbWFwcGluZyBtYXRyaXhcbiAgICAgICAgICogQHJldHVybiBieXRlIGZyb20gdGhlIENvcm5lciBjb25kaXRpb24gM1xuICAgICAgICAgKi9cbiAgICAgICAgcmVhZENvcm5lcjMobnVtUm93cywgbnVtQ29sdW1ucykge1xuICAgICAgICAgICAgbGV0IGN1cnJlbnRCeXRlID0gMDtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlYWRNb2R1bGUobnVtUm93cyAtIDEsIDAsIG51bVJvd3MsIG51bUNvbHVtbnMpKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudEJ5dGUgfD0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnRCeXRlIDw8PSAxO1xuICAgICAgICAgICAgaWYgKHRoaXMucmVhZE1vZHVsZShudW1Sb3dzIC0gMSwgbnVtQ29sdW1ucyAtIDEsIG51bVJvd3MsIG51bUNvbHVtbnMpKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudEJ5dGUgfD0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnRCeXRlIDw8PSAxO1xuICAgICAgICAgICAgaWYgKHRoaXMucmVhZE1vZHVsZSgwLCBudW1Db2x1bW5zIC0gMywgbnVtUm93cywgbnVtQ29sdW1ucykpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50Qnl0ZSB8PSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudEJ5dGUgPDw9IDE7XG4gICAgICAgICAgICBpZiAodGhpcy5yZWFkTW9kdWxlKDAsIG51bUNvbHVtbnMgLSAyLCBudW1Sb3dzLCBudW1Db2x1bW5zKSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRCeXRlIHw9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50Qnl0ZSA8PD0gMTtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlYWRNb2R1bGUoMCwgbnVtQ29sdW1ucyAtIDEsIG51bVJvd3MsIG51bUNvbHVtbnMpKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudEJ5dGUgfD0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnRCeXRlIDw8PSAxO1xuICAgICAgICAgICAgaWYgKHRoaXMucmVhZE1vZHVsZSgxLCBudW1Db2x1bW5zIC0gMywgbnVtUm93cywgbnVtQ29sdW1ucykpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50Qnl0ZSB8PSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudEJ5dGUgPDw9IDE7XG4gICAgICAgICAgICBpZiAodGhpcy5yZWFkTW9kdWxlKDEsIG51bUNvbHVtbnMgLSAyLCBudW1Sb3dzLCBudW1Db2x1bW5zKSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRCeXRlIHw9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50Qnl0ZSA8PD0gMTtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlYWRNb2R1bGUoMSwgbnVtQ29sdW1ucyAtIDEsIG51bVJvd3MsIG51bUNvbHVtbnMpKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudEJ5dGUgfD0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50Qnl0ZTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogPHA+UmVhZHMgdGhlIDggYml0cyBvZiB0aGUgc3BlY2lhbCBjb3JuZXIgY29uZGl0aW9uIDQuPC9wPlxuICAgICAgICAgKlxuICAgICAgICAgKiA8cD5TZWUgSVNPIDE2MDIyOjIwMDYsIEZpZ3VyZSBGLjY8L3A+XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBudW1Sb3dzIE51bWJlciBvZiByb3dzIGluIHRoZSBtYXBwaW5nIG1hdHJpeFxuICAgICAgICAgKiBAcGFyYW0gbnVtQ29sdW1ucyBOdW1iZXIgb2YgY29sdW1ucyBpbiB0aGUgbWFwcGluZyBtYXRyaXhcbiAgICAgICAgICogQHJldHVybiBieXRlIGZyb20gdGhlIENvcm5lciBjb25kaXRpb24gNFxuICAgICAgICAgKi9cbiAgICAgICAgcmVhZENvcm5lcjQobnVtUm93cywgbnVtQ29sdW1ucykge1xuICAgICAgICAgICAgbGV0IGN1cnJlbnRCeXRlID0gMDtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlYWRNb2R1bGUobnVtUm93cyAtIDMsIDAsIG51bVJvd3MsIG51bUNvbHVtbnMpKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudEJ5dGUgfD0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnRCeXRlIDw8PSAxO1xuICAgICAgICAgICAgaWYgKHRoaXMucmVhZE1vZHVsZShudW1Sb3dzIC0gMiwgMCwgbnVtUm93cywgbnVtQ29sdW1ucykpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50Qnl0ZSB8PSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudEJ5dGUgPDw9IDE7XG4gICAgICAgICAgICBpZiAodGhpcy5yZWFkTW9kdWxlKG51bVJvd3MgLSAxLCAwLCBudW1Sb3dzLCBudW1Db2x1bW5zKSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRCeXRlIHw9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50Qnl0ZSA8PD0gMTtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlYWRNb2R1bGUoMCwgbnVtQ29sdW1ucyAtIDIsIG51bVJvd3MsIG51bUNvbHVtbnMpKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudEJ5dGUgfD0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnRCeXRlIDw8PSAxO1xuICAgICAgICAgICAgaWYgKHRoaXMucmVhZE1vZHVsZSgwLCBudW1Db2x1bW5zIC0gMSwgbnVtUm93cywgbnVtQ29sdW1ucykpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50Qnl0ZSB8PSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudEJ5dGUgPDw9IDE7XG4gICAgICAgICAgICBpZiAodGhpcy5yZWFkTW9kdWxlKDEsIG51bUNvbHVtbnMgLSAxLCBudW1Sb3dzLCBudW1Db2x1bW5zKSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRCeXRlIHw9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50Qnl0ZSA8PD0gMTtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlYWRNb2R1bGUoMiwgbnVtQ29sdW1ucyAtIDEsIG51bVJvd3MsIG51bUNvbHVtbnMpKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudEJ5dGUgfD0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnRCeXRlIDw8PSAxO1xuICAgICAgICAgICAgaWYgKHRoaXMucmVhZE1vZHVsZSgzLCBudW1Db2x1bW5zIC0gMSwgbnVtUm93cywgbnVtQ29sdW1ucykpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50Qnl0ZSB8PSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRCeXRlO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiA8cD5FeHRyYWN0cyB0aGUgZGF0YSByZWdpb24gZnJvbSBhIHtAbGluayBCaXRNYXRyaXh9IHRoYXQgY29udGFpbnNcbiAgICAgICAgICogYWxpZ25tZW50IHBhdHRlcm5zLjwvcD5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGJpdE1hdHJpeCBPcmlnaW5hbCB7QGxpbmsgQml0TWF0cml4fSB3aXRoIGFsaWdubWVudCBwYXR0ZXJuc1xuICAgICAgICAgKiBAcmV0dXJuIEJpdE1hdHJpeCB0aGF0IGhhcyB0aGUgYWxpZ25tZW50IHBhdHRlcm5zIHJlbW92ZWRcbiAgICAgICAgICovXG4gICAgICAgIGV4dHJhY3REYXRhUmVnaW9uKGJpdE1hdHJpeCkge1xuICAgICAgICAgICAgY29uc3Qgc3ltYm9sU2l6ZVJvd3MgPSB0aGlzLnZlcnNpb24uZ2V0U3ltYm9sU2l6ZVJvd3MoKTtcbiAgICAgICAgICAgIGNvbnN0IHN5bWJvbFNpemVDb2x1bW5zID0gdGhpcy52ZXJzaW9uLmdldFN5bWJvbFNpemVDb2x1bW5zKCk7XG4gICAgICAgICAgICBpZiAoYml0TWF0cml4LmdldEhlaWdodCgpICE9PSBzeW1ib2xTaXplUm93cykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oJ0RpbWVuc2lvbiBvZiBiaXRNYXRyaXggbXVzdCBtYXRjaCB0aGUgdmVyc2lvbiBzaXplJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBkYXRhUmVnaW9uU2l6ZVJvd3MgPSB0aGlzLnZlcnNpb24uZ2V0RGF0YVJlZ2lvblNpemVSb3dzKCk7XG4gICAgICAgICAgICBjb25zdCBkYXRhUmVnaW9uU2l6ZUNvbHVtbnMgPSB0aGlzLnZlcnNpb24uZ2V0RGF0YVJlZ2lvblNpemVDb2x1bW5zKCk7XG4gICAgICAgICAgICBjb25zdCBudW1EYXRhUmVnaW9uc1JvdyA9IHN5bWJvbFNpemVSb3dzIC8gZGF0YVJlZ2lvblNpemVSb3dzIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IG51bURhdGFSZWdpb25zQ29sdW1uID0gc3ltYm9sU2l6ZUNvbHVtbnMgLyBkYXRhUmVnaW9uU2l6ZUNvbHVtbnMgfCAwO1xuICAgICAgICAgICAgY29uc3Qgc2l6ZURhdGFSZWdpb25Sb3cgPSBudW1EYXRhUmVnaW9uc1JvdyAqIGRhdGFSZWdpb25TaXplUm93cztcbiAgICAgICAgICAgIGNvbnN0IHNpemVEYXRhUmVnaW9uQ29sdW1uID0gbnVtRGF0YVJlZ2lvbnNDb2x1bW4gKiBkYXRhUmVnaW9uU2l6ZUNvbHVtbnM7XG4gICAgICAgICAgICBjb25zdCBiaXRNYXRyaXhXaXRob3V0QWxpZ25tZW50ID0gbmV3IEJpdE1hdHJpeChzaXplRGF0YVJlZ2lvbkNvbHVtbiwgc2l6ZURhdGFSZWdpb25Sb3cpO1xuICAgICAgICAgICAgZm9yIChsZXQgZGF0YVJlZ2lvblJvdyA9IDA7IGRhdGFSZWdpb25Sb3cgPCBudW1EYXRhUmVnaW9uc1JvdzsgKytkYXRhUmVnaW9uUm93KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YVJlZ2lvblJvd09mZnNldCA9IGRhdGFSZWdpb25Sb3cgKiBkYXRhUmVnaW9uU2l6ZVJvd3M7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgZGF0YVJlZ2lvbkNvbHVtbiA9IDA7IGRhdGFSZWdpb25Db2x1bW4gPCBudW1EYXRhUmVnaW9uc0NvbHVtbjsgKytkYXRhUmVnaW9uQ29sdW1uKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGFSZWdpb25Db2x1bW5PZmZzZXQgPSBkYXRhUmVnaW9uQ29sdW1uICogZGF0YVJlZ2lvblNpemVDb2x1bW5zO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGFSZWdpb25TaXplUm93czsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZWFkUm93T2Zmc2V0ID0gZGF0YVJlZ2lvblJvdyAqIChkYXRhUmVnaW9uU2l6ZVJvd3MgKyAyKSArIDEgKyBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgd3JpdGVSb3dPZmZzZXQgPSBkYXRhUmVnaW9uUm93T2Zmc2V0ICsgaTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgZGF0YVJlZ2lvblNpemVDb2x1bW5zOyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZWFkQ29sdW1uT2Zmc2V0ID0gZGF0YVJlZ2lvbkNvbHVtbiAqIChkYXRhUmVnaW9uU2l6ZUNvbHVtbnMgKyAyKSArIDEgKyBqO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiaXRNYXRyaXguZ2V0KHJlYWRDb2x1bW5PZmZzZXQsIHJlYWRSb3dPZmZzZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHdyaXRlQ29sdW1uT2Zmc2V0ID0gZGF0YVJlZ2lvbkNvbHVtbk9mZnNldCArIGo7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJpdE1hdHJpeFdpdGhvdXRBbGlnbm1lbnQuc2V0KHdyaXRlQ29sdW1uT2Zmc2V0LCB3cml0ZVJvd09mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGJpdE1hdHJpeFdpdGhvdXRBbGlnbm1lbnQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiA8cD5FbmNhcHN1bGF0ZXMgYSBibG9jayBvZiBkYXRhIHdpdGhpbiBhIERhdGEgTWF0cml4IENvZGUuIERhdGEgTWF0cml4IENvZGVzIG1heSBzcGxpdCB0aGVpciBkYXRhIGludG9cbiAgICAgKiBtdWx0aXBsZSBibG9ja3MsIGVhY2ggb2Ygd2hpY2ggaXMgYSB1bml0IG9mIGRhdGEgYW5kIGVycm9yLWNvcnJlY3Rpb24gY29kZXdvcmRzLiBFYWNoXG4gICAgICogaXMgcmVwcmVzZW50ZWQgYnkgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy48L3A+XG4gICAgICpcbiAgICAgKiBAYXV0aG9yIGJicm93bkBnb29nbGUuY29tIChCcmlhbiBCcm93bilcbiAgICAgKi9cbiAgICBjbGFzcyBEYXRhQmxvY2sge1xuICAgICAgICBjb25zdHJ1Y3RvcihudW1EYXRhQ29kZXdvcmRzLCBjb2Rld29yZHMpIHtcbiAgICAgICAgICAgIHRoaXMubnVtRGF0YUNvZGV3b3JkcyA9IG51bURhdGFDb2Rld29yZHM7XG4gICAgICAgICAgICB0aGlzLmNvZGV3b3JkcyA9IGNvZGV3b3JkcztcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogPHA+V2hlbiBEYXRhIE1hdHJpeCBDb2RlcyB1c2UgbXVsdGlwbGUgZGF0YSBibG9ja3MsIHRoZXkgYWN0dWFsbHkgaW50ZXJsZWF2ZSB0aGUgYnl0ZXMgb2YgZWFjaCBvZiB0aGVtLlxuICAgICAgICAgKiBUaGF0IGlzLCB0aGUgZmlyc3QgYnl0ZSBvZiBkYXRhIGJsb2NrIDEgdG8gbiBpcyB3cml0dGVuLCB0aGVuIHRoZSBzZWNvbmQgYnl0ZXMsIGFuZCBzbyBvbi4gVGhpc1xuICAgICAgICAgKiBtZXRob2Qgd2lsbCBzZXBhcmF0ZSB0aGUgZGF0YSBpbnRvIG9yaWdpbmFsIGJsb2Nrcy48L3A+XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSByYXdDb2Rld29yZHMgYnl0ZXMgYXMgcmVhZCBkaXJlY3RseSBmcm9tIHRoZSBEYXRhIE1hdHJpeCBDb2RlXG4gICAgICAgICAqIEBwYXJhbSB2ZXJzaW9uIHZlcnNpb24gb2YgdGhlIERhdGEgTWF0cml4IENvZGVcbiAgICAgICAgICogQHJldHVybiBEYXRhQmxvY2tzIGNvbnRhaW5pbmcgb3JpZ2luYWwgYnl0ZXMsIFwiZGUtaW50ZXJsZWF2ZWRcIiBmcm9tIHJlcHJlc2VudGF0aW9uIGluIHRoZVxuICAgICAgICAgKiAgICAgICAgIERhdGEgTWF0cml4IENvZGVcbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBnZXREYXRhQmxvY2tzKHJhd0NvZGV3b3JkcywgdmVyc2lvbikge1xuICAgICAgICAgICAgLy8gRmlndXJlIG91dCB0aGUgbnVtYmVyIGFuZCBzaXplIG9mIGRhdGEgYmxvY2tzIHVzZWQgYnkgdGhpcyB2ZXJzaW9uXG4gICAgICAgICAgICBjb25zdCBlY0Jsb2NrcyA9IHZlcnNpb24uZ2V0RUNCbG9ja3MoKTtcbiAgICAgICAgICAgIC8vIEZpcnN0IGNvdW50IHRoZSB0b3RhbCBudW1iZXIgb2YgZGF0YSBibG9ja3NcbiAgICAgICAgICAgIGxldCB0b3RhbEJsb2NrcyA9IDA7XG4gICAgICAgICAgICBjb25zdCBlY0Jsb2NrQXJyYXkgPSBlY0Jsb2Nrcy5nZXRFQ0Jsb2NrcygpO1xuICAgICAgICAgICAgZm9yIChsZXQgZWNCbG9jayBvZiBlY0Jsb2NrQXJyYXkpIHtcbiAgICAgICAgICAgICAgICB0b3RhbEJsb2NrcyArPSBlY0Jsb2NrLmdldENvdW50KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBOb3cgZXN0YWJsaXNoIERhdGFCbG9ja3Mgb2YgdGhlIGFwcHJvcHJpYXRlIHNpemUgYW5kIG51bWJlciBvZiBkYXRhIGNvZGV3b3Jkc1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IEFycmF5KHRvdGFsQmxvY2tzKTtcbiAgICAgICAgICAgIGxldCBudW1SZXN1bHRCbG9ja3MgPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgZWNCbG9jayBvZiBlY0Jsb2NrQXJyYXkpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVjQmxvY2suZ2V0Q291bnQoKTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG51bURhdGFDb2Rld29yZHMgPSBlY0Jsb2NrLmdldERhdGFDb2Rld29yZHMoKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbnVtQmxvY2tDb2Rld29yZHMgPSBlY0Jsb2Nrcy5nZXRFQ0NvZGV3b3JkcygpICsgbnVtRGF0YUNvZGV3b3JkcztcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W251bVJlc3VsdEJsb2NrcysrXSA9IG5ldyBEYXRhQmxvY2sobnVtRGF0YUNvZGV3b3JkcywgbmV3IFVpbnQ4QXJyYXkobnVtQmxvY2tDb2Rld29yZHMpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBbGwgYmxvY2tzIGhhdmUgdGhlIHNhbWUgYW1vdW50IG9mIGRhdGEsIGV4Y2VwdCB0aGF0IHRoZSBsYXN0IG5cbiAgICAgICAgICAgIC8vICh3aGVyZSBuIG1heSBiZSAwKSBoYXZlIDEgbGVzcyBieXRlLiBGaWd1cmUgb3V0IHdoZXJlIHRoZXNlIHN0YXJ0LlxuICAgICAgICAgICAgLy8gVE9ETyhiYnJvd24pOiBUaGVyZSBpcyBvbmx5IG9uZSBjYXNlIHdoZXJlIHRoZXJlIGlzIGEgZGlmZmVyZW5jZSBmb3IgRGF0YSBNYXRyaXggZm9yIHNpemUgMTQ0XG4gICAgICAgICAgICBjb25zdCBsb25nZXJCbG9ja3NUb3RhbENvZGV3b3JkcyA9IHJlc3VsdFswXS5jb2Rld29yZHMubGVuZ3RoO1xuICAgICAgICAgICAgLy8gaW50IHNob3J0ZXJCbG9ja3NUb3RhbENvZGV3b3JkcyA9IGxvbmdlckJsb2Nrc1RvdGFsQ29kZXdvcmRzIC0gMTtcbiAgICAgICAgICAgIGNvbnN0IGxvbmdlckJsb2Nrc051bURhdGFDb2Rld29yZHMgPSBsb25nZXJCbG9ja3NUb3RhbENvZGV3b3JkcyAtIGVjQmxvY2tzLmdldEVDQ29kZXdvcmRzKCk7XG4gICAgICAgICAgICBjb25zdCBzaG9ydGVyQmxvY2tzTnVtRGF0YUNvZGV3b3JkcyA9IGxvbmdlckJsb2Nrc051bURhdGFDb2Rld29yZHMgLSAxO1xuICAgICAgICAgICAgLy8gVGhlIGxhc3QgZWxlbWVudHMgb2YgcmVzdWx0IG1heSBiZSAxIGVsZW1lbnQgc2hvcnRlciBmb3IgMTQ0IG1hdHJpeFxuICAgICAgICAgICAgLy8gZmlyc3QgZmlsbCBvdXQgYXMgbWFueSBlbGVtZW50cyBhcyBhbGwgb2YgdGhlbSBoYXZlIG1pbnVzIDFcbiAgICAgICAgICAgIGxldCByYXdDb2Rld29yZHNPZmZzZXQgPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaG9ydGVyQmxvY2tzTnVtRGF0YUNvZGV3b3JkczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBudW1SZXN1bHRCbG9ja3M7IGorKykge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRbal0uY29kZXdvcmRzW2ldID0gcmF3Q29kZXdvcmRzW3Jhd0NvZGV3b3Jkc09mZnNldCsrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBGaWxsIG91dCB0aGUgbGFzdCBkYXRhIGJsb2NrIGluIHRoZSBsb25nZXIgb25lc1xuICAgICAgICAgICAgY29uc3Qgc3BlY2lhbFZlcnNpb24gPSB2ZXJzaW9uLmdldFZlcnNpb25OdW1iZXIoKSA9PT0gMjQ7XG4gICAgICAgICAgICBjb25zdCBudW1Mb25nZXJCbG9ja3MgPSBzcGVjaWFsVmVyc2lvbiA/IDggOiBudW1SZXN1bHRCbG9ja3M7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG51bUxvbmdlckJsb2NrczsgaisrKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2pdLmNvZGV3b3Jkc1tsb25nZXJCbG9ja3NOdW1EYXRhQ29kZXdvcmRzIC0gMV0gPSByYXdDb2Rld29yZHNbcmF3Q29kZXdvcmRzT2Zmc2V0KytdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTm93IGFkZCBpbiBlcnJvciBjb3JyZWN0aW9uIGJsb2Nrc1xuICAgICAgICAgICAgY29uc3QgbWF4ID0gcmVzdWx0WzBdLmNvZGV3b3Jkcy5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gbG9uZ2VyQmxvY2tzTnVtRGF0YUNvZGV3b3JkczsgaSA8IG1heDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBudW1SZXN1bHRCbG9ja3M7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBqT2Zmc2V0ID0gc3BlY2lhbFZlcnNpb24gPyAoaiArIDgpICUgbnVtUmVzdWx0QmxvY2tzIDogajtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaU9mZnNldCA9IHNwZWNpYWxWZXJzaW9uICYmIGpPZmZzZXQgPiA3ID8gaSAtIDEgOiBpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRbak9mZnNldF0uY29kZXdvcmRzW2lPZmZzZXRdID0gcmF3Q29kZXdvcmRzW3Jhd0NvZGV3b3Jkc09mZnNldCsrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmF3Q29kZXdvcmRzT2Zmc2V0ICE9PSByYXdDb2Rld29yZHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBnZXROdW1EYXRhQ29kZXdvcmRzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtRGF0YUNvZGV3b3JkcztcbiAgICAgICAgfVxuICAgICAgICBnZXRDb2Rld29yZHMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb2Rld29yZHM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKlxuICAgICAqIENvcHlyaWdodCAyMDA3IFpYaW5nIGF1dGhvcnNcbiAgICAgKlxuICAgICAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gICAgICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgICAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgICAqXG4gICAgICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAgICAgKlxuICAgICAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgICAgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICAgICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gICAgICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICAgICAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIDxwPlRoaXMgcHJvdmlkZXMgYW4gZWFzeSBhYnN0cmFjdGlvbiB0byByZWFkIGJpdHMgYXQgYSB0aW1lIGZyb20gYSBzZXF1ZW5jZSBvZiBieXRlcywgd2hlcmUgdGhlXG4gICAgICogbnVtYmVyIG9mIGJpdHMgcmVhZCBpcyBub3Qgb2Z0ZW4gYSBtdWx0aXBsZSBvZiA4LjwvcD5cbiAgICAgKlxuICAgICAqIDxwPlRoaXMgY2xhc3MgaXMgdGhyZWFkLXNhZmUgYnV0IG5vdCByZWVudHJhbnQgLS0gdW5sZXNzIHRoZSBjYWxsZXIgbW9kaWZpZXMgdGhlIGJ5dGVzIGFycmF5XG4gICAgICogaXQgcGFzc2VkIGluLCBpbiB3aGljaCBjYXNlIGFsbCBiZXRzIGFyZSBvZmYuPC9wPlxuICAgICAqXG4gICAgICogQGF1dGhvciBTZWFuIE93ZW5cbiAgICAgKi9cbiAgICBjbGFzcyBCaXRTb3VyY2Uge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIGJ5dGVzIGJ5dGVzIGZyb20gd2hpY2ggdGhpcyB3aWxsIHJlYWQgYml0cy4gQml0cyB3aWxsIGJlIHJlYWQgZnJvbSB0aGUgZmlyc3QgYnl0ZSBmaXJzdC5cbiAgICAgICAgICogQml0cyBhcmUgcmVhZCB3aXRoaW4gYSBieXRlIGZyb20gbW9zdC1zaWduaWZpY2FudCB0byBsZWFzdC1zaWduaWZpY2FudCBiaXQuXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdHJ1Y3RvcihieXRlcykge1xuICAgICAgICAgICAgdGhpcy5ieXRlcyA9IGJ5dGVzO1xuICAgICAgICAgICAgdGhpcy5ieXRlT2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIHRoaXMuYml0T2Zmc2V0ID0gMDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiBpbmRleCBvZiBuZXh0IGJpdCBpbiBjdXJyZW50IGJ5dGUgd2hpY2ggd291bGQgYmUgcmVhZCBieSB0aGUgbmV4dCBjYWxsIHRvIHtAbGluayAjcmVhZEJpdHMoaW50KX0uXG4gICAgICAgICAqL1xuICAgICAgICBnZXRCaXRPZmZzZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5iaXRPZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gaW5kZXggb2YgbmV4dCBieXRlIGluIGlucHV0IGJ5dGUgYXJyYXkgd2hpY2ggd291bGQgYmUgcmVhZCBieSB0aGUgbmV4dCBjYWxsIHRvIHtAbGluayAjcmVhZEJpdHMoaW50KX0uXG4gICAgICAgICAqL1xuICAgICAgICBnZXRCeXRlT2Zmc2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYnl0ZU9mZnNldDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIG51bUJpdHMgbnVtYmVyIG9mIGJpdHMgdG8gcmVhZFxuICAgICAgICAgKiBAcmV0dXJuIGludCByZXByZXNlbnRpbmcgdGhlIGJpdHMgcmVhZC4gVGhlIGJpdHMgd2lsbCBhcHBlYXIgYXMgdGhlIGxlYXN0LXNpZ25pZmljYW50XG4gICAgICAgICAqICAgICAgICAgYml0cyBvZiB0aGUgaW50XG4gICAgICAgICAqIEB0aHJvd3MgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uIGlmIG51bUJpdHMgaXNuJ3QgaW4gWzEsMzJdIG9yIG1vcmUgdGhhbiBpcyBhdmFpbGFibGVcbiAgICAgICAgICovXG4gICAgICAgIHJlYWRCaXRzKG51bUJpdHMgLyppbnQqLykge1xuICAgICAgICAgICAgaWYgKG51bUJpdHMgPCAxIHx8IG51bUJpdHMgPiAzMiB8fCBudW1CaXRzID4gdGhpcy5hdmFpbGFibGUoKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oJycgKyBudW1CaXRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCByZXN1bHQgPSAwO1xuICAgICAgICAgICAgbGV0IGJpdE9mZnNldCA9IHRoaXMuYml0T2Zmc2V0O1xuICAgICAgICAgICAgbGV0IGJ5dGVPZmZzZXQgPSB0aGlzLmJ5dGVPZmZzZXQ7XG4gICAgICAgICAgICBjb25zdCBieXRlcyA9IHRoaXMuYnl0ZXM7XG4gICAgICAgICAgICAvLyBGaXJzdCwgcmVhZCByZW1haW5kZXIgZnJvbSBjdXJyZW50IGJ5dGVcbiAgICAgICAgICAgIGlmIChiaXRPZmZzZXQgPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYml0c0xlZnQgPSA4IC0gYml0T2Zmc2V0O1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvUmVhZCA9IG51bUJpdHMgPCBiaXRzTGVmdCA/IG51bUJpdHMgOiBiaXRzTGVmdDtcbiAgICAgICAgICAgICAgICBjb25zdCBiaXRzVG9Ob3RSZWFkID0gYml0c0xlZnQgLSB0b1JlYWQ7XG4gICAgICAgICAgICAgICAgY29uc3QgbWFzayA9ICgweEZGID4+ICg4IC0gdG9SZWFkKSkgPDwgYml0c1RvTm90UmVhZDtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSAoYnl0ZXNbYnl0ZU9mZnNldF0gJiBtYXNrKSA+PiBiaXRzVG9Ob3RSZWFkO1xuICAgICAgICAgICAgICAgIG51bUJpdHMgLT0gdG9SZWFkO1xuICAgICAgICAgICAgICAgIGJpdE9mZnNldCArPSB0b1JlYWQ7XG4gICAgICAgICAgICAgICAgaWYgKGJpdE9mZnNldCA9PT0gOCkge1xuICAgICAgICAgICAgICAgICAgICBiaXRPZmZzZXQgPSAwO1xuICAgICAgICAgICAgICAgICAgICBieXRlT2Zmc2V0Kys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTmV4dCByZWFkIHdob2xlIGJ5dGVzXG4gICAgICAgICAgICBpZiAobnVtQml0cyA+IDApIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAobnVtQml0cyA+PSA4KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IChyZXN1bHQgPDwgOCkgfCAoYnl0ZXNbYnl0ZU9mZnNldF0gJiAweEZGKTtcbiAgICAgICAgICAgICAgICAgICAgYnl0ZU9mZnNldCsrO1xuICAgICAgICAgICAgICAgICAgICBudW1CaXRzIC09IDg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEZpbmFsbHkgcmVhZCBhIHBhcnRpYWwgYnl0ZVxuICAgICAgICAgICAgICAgIGlmIChudW1CaXRzID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBiaXRzVG9Ob3RSZWFkID0gOCAtIG51bUJpdHM7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1hc2sgPSAoMHhGRiA+PiBiaXRzVG9Ob3RSZWFkKSA8PCBiaXRzVG9Ob3RSZWFkO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSAocmVzdWx0IDw8IG51bUJpdHMpIHwgKChieXRlc1tieXRlT2Zmc2V0XSAmIG1hc2spID4+IGJpdHNUb05vdFJlYWQpO1xuICAgICAgICAgICAgICAgICAgICBiaXRPZmZzZXQgKz0gbnVtQml0cztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmJpdE9mZnNldCA9IGJpdE9mZnNldDtcbiAgICAgICAgICAgIHRoaXMuYnl0ZU9mZnNldCA9IGJ5dGVPZmZzZXQ7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIG51bWJlciBvZiBiaXRzIHRoYXQgY2FuIGJlIHJlYWQgc3VjY2Vzc2Z1bGx5XG4gICAgICAgICAqL1xuICAgICAgICBhdmFpbGFibGUoKSB7XG4gICAgICAgICAgICByZXR1cm4gOCAqICh0aGlzLmJ5dGVzLmxlbmd0aCAtIHRoaXMuYnl0ZU9mZnNldCkgLSB0aGlzLmJpdE9mZnNldDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBNb2RlO1xuICAgIChmdW5jdGlvbiAoTW9kZSkge1xuICAgICAgICBNb2RlW01vZGVbXCJQQURfRU5DT0RFXCJdID0gMF0gPSBcIlBBRF9FTkNPREVcIjtcbiAgICAgICAgTW9kZVtNb2RlW1wiQVNDSUlfRU5DT0RFXCJdID0gMV0gPSBcIkFTQ0lJX0VOQ09ERVwiO1xuICAgICAgICBNb2RlW01vZGVbXCJDNDBfRU5DT0RFXCJdID0gMl0gPSBcIkM0MF9FTkNPREVcIjtcbiAgICAgICAgTW9kZVtNb2RlW1wiVEVYVF9FTkNPREVcIl0gPSAzXSA9IFwiVEVYVF9FTkNPREVcIjtcbiAgICAgICAgTW9kZVtNb2RlW1wiQU5TSVgxMl9FTkNPREVcIl0gPSA0XSA9IFwiQU5TSVgxMl9FTkNPREVcIjtcbiAgICAgICAgTW9kZVtNb2RlW1wiRURJRkFDVF9FTkNPREVcIl0gPSA1XSA9IFwiRURJRkFDVF9FTkNPREVcIjtcbiAgICAgICAgTW9kZVtNb2RlW1wiQkFTRTI1Nl9FTkNPREVcIl0gPSA2XSA9IFwiQkFTRTI1Nl9FTkNPREVcIjtcbiAgICB9KShNb2RlIHx8IChNb2RlID0ge30pKTtcbiAgICAvKipcbiAgICAgKiA8cD5EYXRhIE1hdHJpeCBDb2RlcyBjYW4gZW5jb2RlIHRleHQgYXMgYml0cyBpbiBvbmUgb2Ygc2V2ZXJhbCBtb2RlcywgYW5kIGNhbiB1c2UgbXVsdGlwbGUgbW9kZXNcbiAgICAgKiBpbiBvbmUgRGF0YSBNYXRyaXggQ29kZS4gVGhpcyBjbGFzcyBkZWNvZGVzIHRoZSBiaXRzIGJhY2sgaW50byB0ZXh0LjwvcD5cbiAgICAgKlxuICAgICAqIDxwPlNlZSBJU08gMTYwMjI6MjAwNiwgNS4yLjEgLSA1LjIuOS4yPC9wPlxuICAgICAqXG4gICAgICogQGF1dGhvciBiYnJvd25AZ29vZ2xlLmNvbSAoQnJpYW4gQnJvd24pXG4gICAgICogQGF1dGhvciBTZWFuIE93ZW5cbiAgICAgKi9cbiAgICBjbGFzcyBEZWNvZGVkQml0U3RyZWFtUGFyc2VyIHtcbiAgICAgICAgc3RhdGljIGRlY29kZShieXRlcykge1xuICAgICAgICAgICAgY29uc3QgYml0cyA9IG5ldyBCaXRTb3VyY2UoYnl0ZXMpO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IFN0cmluZ0J1aWxkZXIoKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdFRyYWlsZXIgPSBuZXcgU3RyaW5nQnVpbGRlcigpO1xuICAgICAgICAgICAgY29uc3QgYnl0ZVNlZ21lbnRzID0gbmV3IEFycmF5KCk7XG4gICAgICAgICAgICBsZXQgbW9kZSA9IE1vZGUuQVNDSUlfRU5DT0RFO1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIGlmIChtb2RlID09PSBNb2RlLkFTQ0lJX0VOQ09ERSkge1xuICAgICAgICAgICAgICAgICAgICBtb2RlID0gdGhpcy5kZWNvZGVBc2NpaVNlZ21lbnQoYml0cywgcmVzdWx0LCByZXN1bHRUcmFpbGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAobW9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBNb2RlLkM0MF9FTkNPREU6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWNvZGVDNDBTZWdtZW50KGJpdHMsIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIE1vZGUuVEVYVF9FTkNPREU6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWNvZGVUZXh0U2VnbWVudChiaXRzLCByZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBNb2RlLkFOU0lYMTJfRU5DT0RFOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVjb2RlQW5zaVgxMlNlZ21lbnQoYml0cywgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgTW9kZS5FRElGQUNUX0VOQ09ERTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRlY29kZUVkaWZhY3RTZWdtZW50KGJpdHMsIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIE1vZGUuQkFTRTI1Nl9FTkNPREU6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWNvZGVCYXNlMjU2U2VnbWVudChiaXRzLCByZXN1bHQsIGJ5dGVTZWdtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtb2RlID0gTW9kZS5BU0NJSV9FTkNPREU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAobW9kZSAhPT0gTW9kZS5QQURfRU5DT0RFICYmIGJpdHMuYXZhaWxhYmxlKCkgPiAwKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHRUcmFpbGVyLmxlbmd0aCgpID4gMCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQocmVzdWx0VHJhaWxlci50b1N0cmluZygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgRGVjb2RlclJlc3VsdChieXRlcywgcmVzdWx0LnRvU3RyaW5nKCksIGJ5dGVTZWdtZW50cy5sZW5ndGggPT09IDAgPyBudWxsIDogYnl0ZVNlZ21lbnRzLCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogU2VlIElTTyAxNjAyMjoyMDA2LCA1LjIuMyBhbmQgQW5uZXggQywgVGFibGUgQy4yXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgZGVjb2RlQXNjaWlTZWdtZW50KGJpdHMsIHJlc3VsdCwgcmVzdWx0VHJhaWxlcikge1xuICAgICAgICAgICAgbGV0IHVwcGVyU2hpZnQgPSBmYWxzZTtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBsZXQgb25lQnl0ZSA9IGJpdHMucmVhZEJpdHMoOCk7XG4gICAgICAgICAgICAgICAgaWYgKG9uZUJ5dGUgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChvbmVCeXRlIDw9IDEyOCkgeyAvLyBBU0NJSSBkYXRhIChBU0NJSSB2YWx1ZSArIDEpXG4gICAgICAgICAgICAgICAgICAgIGlmICh1cHBlclNoaWZ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbmVCeXRlICs9IDEyODtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHVwcGVyU2hpZnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKFN0cmluZy5mcm9tQ2hhckNvZGUob25lQnl0ZSAtIDEpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE1vZGUuQVNDSUlfRU5DT0RFO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChvbmVCeXRlID09PSAxMjkpIHsgLy8gUGFkXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBNb2RlLlBBRF9FTkNPREU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9uZUJ5dGUgPD0gMjI5KSB7IC8vIDItZGlnaXQgZGF0YSAwMC05OSAoTnVtZXJpYyBWYWx1ZSArIDEzMClcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBvbmVCeXRlIC0gMTMwO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPCAxMCkgeyAvLyBwYWQgd2l0aCAnMCcgZm9yIHNpbmdsZSBkaWdpdCB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoJzAnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKCcnICsgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChvbmVCeXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDIzMDogLy8gTGF0Y2ggdG8gQzQwIGVuY29kYXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gTW9kZS5DNDBfRU5DT0RFO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyMzE6IC8vIExhdGNoIHRvIEJhc2UgMjU2IGVuY29kYXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gTW9kZS5CQVNFMjU2X0VOQ09ERTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjMyOiAvLyBGTkMxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZChTdHJpbmcuZnJvbUNoYXJDb2RlKDI5KSk7IC8vIHRyYW5zbGF0ZSBhcyBBU0NJSSAyOVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyMzM6IC8vIFN0cnVjdHVyZWQgQXBwZW5kXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDIzNDogLy8gUmVhZGVyIFByb2dyYW1taW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWdub3JlIHRoZXNlIHN5bWJvbHMgZm9yIG5vd1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRocm93IFJlYWRlckV4Y2VwdGlvbi5nZXRJbnN0YW5jZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyMzU6IC8vIFVwcGVyIFNoaWZ0IChzaGlmdCB0byBFeHRlbmRlZCBBU0NJSSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cHBlclNoaWZ0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjM2OiAvLyAwNSBNYWNyb1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoJ1spPlxcdTAwMUUwNVxcdTAwMUQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRUcmFpbGVyLmluc2VydCgwLCAnXFx1MDAxRVxcdTAwMDQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjM3OiAvLyAwNiBNYWNyb1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoJ1spPlxcdTAwMUUwNlxcdTAwMUQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRUcmFpbGVyLmluc2VydCgwLCAnXFx1MDAxRVxcdTAwMDQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjM4OiAvLyBMYXRjaCB0byBBTlNJIFgxMiBlbmNvZGF0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE1vZGUuQU5TSVgxMl9FTkNPREU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDIzOTogLy8gTGF0Y2ggdG8gVGV4dCBlbmNvZGF0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE1vZGUuVEVYVF9FTkNPREU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI0MDogLy8gTGF0Y2ggdG8gRURJRkFDVCBlbmNvZGF0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE1vZGUuRURJRkFDVF9FTkNPREU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI0MTogLy8gRUNJIENoYXJhY3RlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8oYmJyb3duKTogSSB0aGluayB3ZSBuZWVkIHRvIHN1cHBvcnQgRUNJXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhyb3cgUmVhZGVyRXhjZXB0aW9uLmdldEluc3RhbmNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWdub3JlIHRoaXMgc3ltYm9sIGZvciBub3dcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm90IHRvIGJlIHVzZWQgaW4gQVNDSUkgZW5jb2RhdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJ1dCB3b3JrIGFyb3VuZCBlbmNvZGVycyB0aGF0IGVuZCB3aXRoIDI1NCwgbGF0Y2ggYmFjayB0byBBU0NJSVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvbmVCeXRlICE9PSAyNTQgfHwgYml0cy5hdmFpbGFibGUoKSAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAoYml0cy5hdmFpbGFibGUoKSA+IDApO1xuICAgICAgICAgICAgcmV0dXJuIE1vZGUuQVNDSUlfRU5DT0RFO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZWUgSVNPIDE2MDIyOjIwMDYsIDUuMi41IGFuZCBBbm5leCBDLCBUYWJsZSBDLjFcbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBkZWNvZGVDNDBTZWdtZW50KGJpdHMsIHJlc3VsdCkge1xuICAgICAgICAgICAgLy8gVGhyZWUgQzQwIHZhbHVlcyBhcmUgZW5jb2RlZCBpbiBhIDE2LWJpdCB2YWx1ZSBhc1xuICAgICAgICAgICAgLy8gKDE2MDAgKiBDMSkgKyAoNDAgKiBDMikgKyBDMyArIDFcbiAgICAgICAgICAgIC8vIFRPRE8oYmJyb3duKTogVGhlIFVwcGVyIFNoaWZ0IHdpdGggQzQwIGRvZXNuJ3Qgd29yayBpbiB0aGUgNCB2YWx1ZSBzY2VuYXJpbyBhbGwgdGhlIHRpbWVcbiAgICAgICAgICAgIGxldCB1cHBlclNoaWZ0ID0gZmFsc2U7XG4gICAgICAgICAgICBjb25zdCBjVmFsdWVzID0gW107XG4gICAgICAgICAgICBsZXQgc2hpZnQgPSAwO1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIG9ubHkgb25lIGJ5dGUgbGVmdCB0aGVuIGl0IHdpbGwgYmUgZW5jb2RlZCBhcyBBU0NJSVxuICAgICAgICAgICAgICAgIGlmIChiaXRzLmF2YWlsYWJsZSgpID09PSA4KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgZmlyc3RCeXRlID0gYml0cy5yZWFkQml0cyg4KTtcbiAgICAgICAgICAgICAgICBpZiAoZmlyc3RCeXRlID09PSAyNTQpIHsgLy8gVW5sYXRjaCBjb2Rld29yZFxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMucGFyc2VUd29CeXRlcyhmaXJzdEJ5dGUsIGJpdHMucmVhZEJpdHMoOCksIGNWYWx1ZXMpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNWYWx1ZSA9IGNWYWx1ZXNbaV07XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoc2hpZnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY1ZhbHVlIDwgMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGlmdCA9IGNWYWx1ZSArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNWYWx1ZSA8IHRoaXMuQzQwX0JBU0lDX1NFVF9DSEFSUy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYzQwY2hhciA9IHRoaXMuQzQwX0JBU0lDX1NFVF9DSEFSU1tjVmFsdWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodXBwZXJTaGlmdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZChTdHJpbmcuZnJvbUNoYXJDb2RlKGM0MGNoYXIuY2hhckNvZGVBdCgwKSArIDEyOCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBwZXJTaGlmdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZChjNDBjaGFyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodXBwZXJTaGlmdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKFN0cmluZy5mcm9tQ2hhckNvZGUoY1ZhbHVlICsgMTI4KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwcGVyU2hpZnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoU3RyaW5nLmZyb21DaGFyQ29kZShjVmFsdWUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hpZnQgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjVmFsdWUgPCB0aGlzLkM0MF9TSElGVDJfU0VUX0NIQVJTLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjNDBjaGFyID0gdGhpcy5DNDBfU0hJRlQyX1NFVF9DSEFSU1tjVmFsdWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodXBwZXJTaGlmdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZChTdHJpbmcuZnJvbUNoYXJDb2RlKGM0MGNoYXIuY2hhckNvZGVBdCgwKSArIDEyOCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBwZXJTaGlmdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZChjNDBjaGFyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChjVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjc6IC8vIEZOQzFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKFN0cmluZy5mcm9tQ2hhckNvZGUoMjkpKTsgLy8gdHJhbnNsYXRlIGFzIEFTQ0lJIDI5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDMwOiAvLyBVcHBlciBTaGlmdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwcGVyU2hpZnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hpZnQgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1cHBlclNoaWZ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoU3RyaW5nLmZyb21DaGFyQ29kZShjVmFsdWUgKyAyMjQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBwZXJTaGlmdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZChTdHJpbmcuZnJvbUNoYXJDb2RlKGNWYWx1ZSArIDk2KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoaWZ0ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAoYml0cy5hdmFpbGFibGUoKSA+IDApO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZWUgSVNPIDE2MDIyOjIwMDYsIDUuMi42IGFuZCBBbm5leCBDLCBUYWJsZSBDLjJcbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBkZWNvZGVUZXh0U2VnbWVudChiaXRzLCByZXN1bHQpIHtcbiAgICAgICAgICAgIC8vIFRocmVlIFRleHQgdmFsdWVzIGFyZSBlbmNvZGVkIGluIGEgMTYtYml0IHZhbHVlIGFzXG4gICAgICAgICAgICAvLyAoMTYwMCAqIEMxKSArICg0MCAqIEMyKSArIEMzICsgMVxuICAgICAgICAgICAgLy8gVE9ETyhiYnJvd24pOiBUaGUgVXBwZXIgU2hpZnQgd2l0aCBUZXh0IGRvZXNuJ3Qgd29yayBpbiB0aGUgNCB2YWx1ZSBzY2VuYXJpbyBhbGwgdGhlIHRpbWVcbiAgICAgICAgICAgIGxldCB1cHBlclNoaWZ0ID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgY1ZhbHVlcyA9IFtdO1xuICAgICAgICAgICAgbGV0IHNoaWZ0ID0gMDtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBvbmx5IG9uZSBieXRlIGxlZnQgdGhlbiBpdCB3aWxsIGJlIGVuY29kZWQgYXMgQVNDSUlcbiAgICAgICAgICAgICAgICBpZiAoYml0cy5hdmFpbGFibGUoKSA9PT0gOCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGZpcnN0Qnl0ZSA9IGJpdHMucmVhZEJpdHMoOCk7XG4gICAgICAgICAgICAgICAgaWYgKGZpcnN0Qnl0ZSA9PT0gMjU0KSB7IC8vIFVubGF0Y2ggY29kZXdvcmRcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnBhcnNlVHdvQnl0ZXMoZmlyc3RCeXRlLCBiaXRzLnJlYWRCaXRzKDgpLCBjVmFsdWVzKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjVmFsdWUgPSBjVmFsdWVzW2ldO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHNoaWZ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNWYWx1ZSA8IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hpZnQgPSBjVmFsdWUgKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjVmFsdWUgPCB0aGlzLlRFWFRfQkFTSUNfU0VUX0NIQVJTLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZXh0Q2hhciA9IHRoaXMuVEVYVF9CQVNJQ19TRVRfQ0hBUlNbY1ZhbHVlXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVwcGVyU2hpZnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoU3RyaW5nLmZyb21DaGFyQ29kZSh0ZXh0Q2hhci5jaGFyQ29kZUF0KDApICsgMTI4KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cHBlclNoaWZ0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKHRleHRDaGFyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodXBwZXJTaGlmdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKFN0cmluZy5mcm9tQ2hhckNvZGUoY1ZhbHVlICsgMTI4KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwcGVyU2hpZnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoU3RyaW5nLmZyb21DaGFyQ29kZShjVmFsdWUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hpZnQgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNoaWZ0IDIgZm9yIFRleHQgaXMgdGhlIHNhbWUgZW5jb2RpbmcgYXMgQzQwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNWYWx1ZSA8IHRoaXMuVEVYVF9TSElGVDJfU0VUX0NIQVJTLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZXh0Q2hhciA9IHRoaXMuVEVYVF9TSElGVDJfU0VUX0NIQVJTW2NWYWx1ZV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1cHBlclNoaWZ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKFN0cmluZy5mcm9tQ2hhckNvZGUodGV4dENoYXIuY2hhckNvZGVBdCgwKSArIDEyOCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBwZXJTaGlmdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZCh0ZXh0Q2hhcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoY1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI3OiAvLyBGTkMxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZChTdHJpbmcuZnJvbUNoYXJDb2RlKDI5KSk7IC8vIHRyYW5zbGF0ZSBhcyBBU0NJSSAyOVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzMDogLy8gVXBwZXIgU2hpZnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cHBlclNoaWZ0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoaWZ0ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY1ZhbHVlIDwgdGhpcy5URVhUX1NISUZUM19TRVRfQ0hBUlMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRleHRDaGFyID0gdGhpcy5URVhUX1NISUZUM19TRVRfQ0hBUlNbY1ZhbHVlXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVwcGVyU2hpZnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoU3RyaW5nLmZyb21DaGFyQ29kZSh0ZXh0Q2hhci5jaGFyQ29kZUF0KDApICsgMTI4KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cHBlclNoaWZ0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKHRleHRDaGFyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGlmdCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlIChiaXRzLmF2YWlsYWJsZSgpID4gMCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNlZSBJU08gMTYwMjI6MjAwNiwgNS4yLjdcbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBkZWNvZGVBbnNpWDEyU2VnbWVudChiaXRzLCByZXN1bHQpIHtcbiAgICAgICAgICAgIC8vIFRocmVlIEFOU0kgWDEyIHZhbHVlcyBhcmUgZW5jb2RlZCBpbiBhIDE2LWJpdCB2YWx1ZSBhc1xuICAgICAgICAgICAgLy8gKDE2MDAgKiBDMSkgKyAoNDAgKiBDMikgKyBDMyArIDFcbiAgICAgICAgICAgIGNvbnN0IGNWYWx1ZXMgPSBbXTtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBvbmx5IG9uZSBieXRlIGxlZnQgdGhlbiBpdCB3aWxsIGJlIGVuY29kZWQgYXMgQVNDSUlcbiAgICAgICAgICAgICAgICBpZiAoYml0cy5hdmFpbGFibGUoKSA9PT0gOCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGZpcnN0Qnl0ZSA9IGJpdHMucmVhZEJpdHMoOCk7XG4gICAgICAgICAgICAgICAgaWYgKGZpcnN0Qnl0ZSA9PT0gMjU0KSB7IC8vIFVubGF0Y2ggY29kZXdvcmRcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnBhcnNlVHdvQnl0ZXMoZmlyc3RCeXRlLCBiaXRzLnJlYWRCaXRzKDgpLCBjVmFsdWVzKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjVmFsdWUgPSBjVmFsdWVzW2ldO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGNWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiAvLyBYMTIgc2VnbWVudCB0ZXJtaW5hdG9yIDxDUj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKCdcXHInKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTogLy8gWDEyIHNlZ21lbnQgc2VwYXJhdG9yICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKCcqJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6IC8vIFgxMiBzdWItZWxlbWVudCBzZXBhcmF0b3IgPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoJz4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzogLy8gc3BhY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKCcgJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjVmFsdWUgPCAxNCkgeyAvLyAwIC0gOVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKFN0cmluZy5mcm9tQ2hhckNvZGUoY1ZhbHVlICsgNDQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY1ZhbHVlIDwgNDApIHsgLy8gQSAtIFpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZChTdHJpbmcuZnJvbUNoYXJDb2RlKGNWYWx1ZSArIDUxKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAoYml0cy5hdmFpbGFibGUoKSA+IDApO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBwYXJzZVR3b0J5dGVzKGZpcnN0Qnl0ZSwgc2Vjb25kQnl0ZSwgcmVzdWx0KSB7XG4gICAgICAgICAgICBsZXQgZnVsbEJpdFZhbHVlID0gKGZpcnN0Qnl0ZSA8PCA4KSArIHNlY29uZEJ5dGUgLSAxO1xuICAgICAgICAgICAgbGV0IHRlbXAgPSBNYXRoLmZsb29yKGZ1bGxCaXRWYWx1ZSAvIDE2MDApO1xuICAgICAgICAgICAgcmVzdWx0WzBdID0gdGVtcDtcbiAgICAgICAgICAgIGZ1bGxCaXRWYWx1ZSAtPSB0ZW1wICogMTYwMDtcbiAgICAgICAgICAgIHRlbXAgPSBNYXRoLmZsb29yKGZ1bGxCaXRWYWx1ZSAvIDQwKTtcbiAgICAgICAgICAgIHJlc3VsdFsxXSA9IHRlbXA7XG4gICAgICAgICAgICByZXN1bHRbMl0gPSBmdWxsQml0VmFsdWUgLSB0ZW1wICogNDA7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNlZSBJU08gMTYwMjI6MjAwNiwgNS4yLjggYW5kIEFubmV4IEMgVGFibGUgQy4zXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgZGVjb2RlRWRpZmFjdFNlZ21lbnQoYml0cywgcmVzdWx0KSB7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgb25seSB0d28gb3IgbGVzcyBieXRlcyBsZWZ0IHRoZW4gaXQgd2lsbCBiZSBlbmNvZGVkIGFzIEFTQ0lJXG4gICAgICAgICAgICAgICAgaWYgKGJpdHMuYXZhaWxhYmxlKCkgPD0gMTYpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZWRpZmFjdFZhbHVlID0gYml0cy5yZWFkQml0cyg2KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIHRoZSB1bmxhdGNoIGNoYXJhY3RlclxuICAgICAgICAgICAgICAgICAgICBpZiAoZWRpZmFjdFZhbHVlID09PSAweDFGKSB7IC8vIDAxMTExMVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVhZCByZXN0IG9mIGJ5dGUsIHdoaWNoIHNob3VsZCBiZSAwLCBhbmQgc3RvcFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYml0c0xlZnQgPSA4IC0gYml0cy5nZXRCaXRPZmZzZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiaXRzTGVmdCAhPT0gOCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJpdHMucmVhZEJpdHMoYml0c0xlZnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICgoZWRpZmFjdFZhbHVlICYgMHgyMCkgPT09IDApIHsgLy8gbm8gMSBpbiB0aGUgbGVhZGluZyAoNnRoKSBiaXRcbiAgICAgICAgICAgICAgICAgICAgICAgIGVkaWZhY3RWYWx1ZSB8PSAweDQwOyAvLyBBZGQgYSBsZWFkaW5nIDAxIHRvIHRoZSA2IGJpdCBiaW5hcnkgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKFN0cmluZy5mcm9tQ2hhckNvZGUoZWRpZmFjdFZhbHVlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAoYml0cy5hdmFpbGFibGUoKSA+IDApO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZWUgSVNPIDE2MDIyOjIwMDYsIDUuMi45IGFuZCBBbm5leCBCLCBCLjJcbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBkZWNvZGVCYXNlMjU2U2VnbWVudChiaXRzLCByZXN1bHQsIGJ5dGVTZWdtZW50cykge1xuICAgICAgICAgICAgLy8gRmlndXJlIG91dCBob3cgbG9uZyB0aGUgQmFzZSAyNTYgU2VnbWVudCBpcy5cbiAgICAgICAgICAgIGxldCBjb2Rld29yZFBvc2l0aW9uID0gMSArIGJpdHMuZ2V0Qnl0ZU9mZnNldCgpOyAvLyBwb3NpdGlvbiBpcyAxLWluZGV4ZWRcbiAgICAgICAgICAgIGNvbnN0IGQxID0gdGhpcy51bnJhbmRvbWl6ZTI1NVN0YXRlKGJpdHMucmVhZEJpdHMoOCksIGNvZGV3b3JkUG9zaXRpb24rKyk7XG4gICAgICAgICAgICBsZXQgY291bnQ7XG4gICAgICAgICAgICBpZiAoZDEgPT09IDApIHsgLy8gUmVhZCB0aGUgcmVtYWluZGVyIG9mIHRoZSBzeW1ib2xcbiAgICAgICAgICAgICAgICBjb3VudCA9IGJpdHMuYXZhaWxhYmxlKCkgLyA4IHwgMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGQxIDwgMjUwKSB7XG4gICAgICAgICAgICAgICAgY291bnQgPSBkMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvdW50ID0gMjUwICogKGQxIC0gMjQ5KSArIHRoaXMudW5yYW5kb21pemUyNTVTdGF0ZShiaXRzLnJlYWRCaXRzKDgpLCBjb2Rld29yZFBvc2l0aW9uKyspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gV2UncmUgc2VlaW5nIE5lZ2F0aXZlQXJyYXlTaXplRXhjZXB0aW9uIGVycm9ycyBmcm9tIHVzZXJzLlxuICAgICAgICAgICAgaWYgKGNvdW50IDwgMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoY291bnQpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgLy8gSGF2ZSBzZWVuIHRoaXMgcGFydGljdWxhciBlcnJvciBpbiB0aGUgd2lsZCwgc3VjaCBhcyBhdFxuICAgICAgICAgICAgICAgIC8vIGh0dHA6Ly93d3cuYmNnZW4uY29tL2RlbW8vSURBdXRvbWF0aW9uU3RyZWFtaW5nRGF0YU1hdHJpeC5hc3B4P01PREU9MyZEPUZyZWQmUEZNVD0zJlBUPUYmWD0wLjMmTz0wJkxNPTAuMlxuICAgICAgICAgICAgICAgIGlmIChiaXRzLmF2YWlsYWJsZSgpIDwgOCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJ5dGVzW2ldID0gdGhpcy51bnJhbmRvbWl6ZTI1NVN0YXRlKGJpdHMucmVhZEJpdHMoOCksIGNvZGV3b3JkUG9zaXRpb24rKyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBieXRlU2VnbWVudHMucHVzaChieXRlcyk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoU3RyaW5nRW5jb2RpbmcuZGVjb2RlKGJ5dGVzLCBTdHJpbmdVdGlscy5JU084ODU5MSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKHVlZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsU3RhdGVFeGNlcHRpb24oJ1BsYXRmb3JtIGRvZXMgbm90IHN1cHBvcnQgcmVxdWlyZWQgZW5jb2Rpbmc6ICcgKyB1ZWUubWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNlZSBJU08gMTYwMjI6MjAwNiwgQW5uZXggQiwgQi4yXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgdW5yYW5kb21pemUyNTVTdGF0ZShyYW5kb21pemVkQmFzZTI1NkNvZGV3b3JkLCBiYXNlMjU2Q29kZXdvcmRQb3NpdGlvbikge1xuICAgICAgICAgICAgY29uc3QgcHNldWRvUmFuZG9tTnVtYmVyID0gKCgxNDkgKiBiYXNlMjU2Q29kZXdvcmRQb3NpdGlvbikgJSAyNTUpICsgMTtcbiAgICAgICAgICAgIGNvbnN0IHRlbXBWYXJpYWJsZSA9IHJhbmRvbWl6ZWRCYXNlMjU2Q29kZXdvcmQgLSBwc2V1ZG9SYW5kb21OdW1iZXI7XG4gICAgICAgICAgICByZXR1cm4gdGVtcFZhcmlhYmxlID49IDAgPyB0ZW1wVmFyaWFibGUgOiB0ZW1wVmFyaWFibGUgKyAyNTY7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VlIElTTyAxNjAyMjoyMDA2LCBBbm5leCBDIFRhYmxlIEMuMVxuICAgICAqIFRoZSBDNDAgQmFzaWMgQ2hhcmFjdGVyIFNldCAoKidzIHVzZWQgZm9yIHBsYWNlaG9sZGVycyBmb3IgdGhlIHNoaWZ0IHZhbHVlcylcbiAgICAgKi9cbiAgICBEZWNvZGVkQml0U3RyZWFtUGFyc2VyLkM0MF9CQVNJQ19TRVRfQ0hBUlMgPSBbXG4gICAgICAgICcqJywgJyonLCAnKicsICcgJywgJzAnLCAnMScsICcyJywgJzMnLCAnNCcsICc1JywgJzYnLCAnNycsICc4JywgJzknLFxuICAgICAgICAnQScsICdCJywgJ0MnLCAnRCcsICdFJywgJ0YnLCAnRycsICdIJywgJ0knLCAnSicsICdLJywgJ0wnLCAnTScsICdOJyxcbiAgICAgICAgJ08nLCAnUCcsICdRJywgJ1InLCAnUycsICdUJywgJ1UnLCAnVicsICdXJywgJ1gnLCAnWScsICdaJ1xuICAgIF07XG4gICAgRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5DNDBfU0hJRlQyX1NFVF9DSEFSUyA9IFtcbiAgICAgICAgJyEnLCAnXCInLCAnIycsICckJywgJyUnLCAnJicsICdcXCcnLCAnKCcsICcpJywgJyonLCAnKycsICcsJywgJy0nLCAnLicsXG4gICAgICAgICcvJywgJzonLCAnOycsICc8JywgJz0nLCAnPicsICc/JywgJ0AnLCAnWycsICdcXFxcJywgJ10nLCAnXicsICdfJ1xuICAgIF07XG4gICAgLyoqXG4gICAgICogU2VlIElTTyAxNjAyMjoyMDA2LCBBbm5leCBDIFRhYmxlIEMuMlxuICAgICAqIFRoZSBUZXh0IEJhc2ljIENoYXJhY3RlciBTZXQgKConcyB1c2VkIGZvciBwbGFjZWhvbGRlcnMgZm9yIHRoZSBzaGlmdCB2YWx1ZXMpXG4gICAgICovXG4gICAgRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5URVhUX0JBU0lDX1NFVF9DSEFSUyA9IFtcbiAgICAgICAgJyonLCAnKicsICcqJywgJyAnLCAnMCcsICcxJywgJzInLCAnMycsICc0JywgJzUnLCAnNicsICc3JywgJzgnLCAnOScsXG4gICAgICAgICdhJywgJ2InLCAnYycsICdkJywgJ2UnLCAnZicsICdnJywgJ2gnLCAnaScsICdqJywgJ2snLCAnbCcsICdtJywgJ24nLFxuICAgICAgICAnbycsICdwJywgJ3EnLCAncicsICdzJywgJ3QnLCAndScsICd2JywgJ3cnLCAneCcsICd5JywgJ3onXG4gICAgXTtcbiAgICAvLyBTaGlmdCAyIGZvciBUZXh0IGlzIHRoZSBzYW1lIGVuY29kaW5nIGFzIEM0MFxuICAgIERlY29kZWRCaXRTdHJlYW1QYXJzZXIuVEVYVF9TSElGVDJfU0VUX0NIQVJTID0gRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5DNDBfU0hJRlQyX1NFVF9DSEFSUztcbiAgICBEZWNvZGVkQml0U3RyZWFtUGFyc2VyLlRFWFRfU0hJRlQzX1NFVF9DSEFSUyA9IFtcbiAgICAgICAgJ2AnLCAnQScsICdCJywgJ0MnLCAnRCcsICdFJywgJ0YnLCAnRycsICdIJywgJ0knLCAnSicsICdLJywgJ0wnLCAnTScsICdOJyxcbiAgICAgICAgJ08nLCAnUCcsICdRJywgJ1InLCAnUycsICdUJywgJ1UnLCAnVicsICdXJywgJ1gnLCAnWScsICdaJywgJ3snLCAnfCcsICd9JywgJ34nLCBTdHJpbmcuZnJvbUNoYXJDb2RlKDEyNylcbiAgICBdO1xuXG4gICAgLypcbiAgICAgKiBDb3B5cmlnaHQgMjAwNyBaWGluZyBhdXRob3JzXG4gICAgICpcbiAgICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgICAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgICAgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgICAgKlxuICAgICAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gICAgICpcbiAgICAgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICAgICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgICAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICAgICAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgICAgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiA8cD5UaGUgbWFpbiBjbGFzcyB3aGljaCBpbXBsZW1lbnRzIERhdGEgTWF0cml4IENvZGUgZGVjb2RpbmcgLS0gYXMgb3Bwb3NlZCB0byBsb2NhdGluZyBhbmQgZXh0cmFjdGluZ1xuICAgICAqIHRoZSBEYXRhIE1hdHJpeCBDb2RlIGZyb20gYW4gaW1hZ2UuPC9wPlxuICAgICAqXG4gICAgICogQGF1dGhvciBiYnJvd25AZ29vZ2xlLmNvbSAoQnJpYW4gQnJvd24pXG4gICAgICovXG4gICAgY2xhc3MgRGVjb2RlciQxIHtcbiAgICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgICAgICB0aGlzLnJzRGVjb2RlciA9IG5ldyBSZWVkU29sb21vbkRlY29kZXIoR2VuZXJpY0dGLkRBVEFfTUFUUklYX0ZJRUxEXzI1Nik7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIDxwPkRlY29kZXMgYSBEYXRhIE1hdHJpeCBDb2RlIHJlcHJlc2VudGVkIGFzIGEge0BsaW5rIEJpdE1hdHJpeH0uIEEgMSBvciBcInRydWVcIiBpcyB0YWtlblxuICAgICAgICAgKiB0byBtZWFuIGEgYmxhY2sgbW9kdWxlLjwvcD5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGJpdHMgYm9vbGVhbnMgcmVwcmVzZW50aW5nIHdoaXRlL2JsYWNrIERhdGEgTWF0cml4IENvZGUgbW9kdWxlc1xuICAgICAgICAgKiBAcmV0dXJuIHRleHQgYW5kIGJ5dGVzIGVuY29kZWQgd2l0aGluIHRoZSBEYXRhIE1hdHJpeCBDb2RlXG4gICAgICAgICAqIEB0aHJvd3MgRm9ybWF0RXhjZXB0aW9uIGlmIHRoZSBEYXRhIE1hdHJpeCBDb2RlIGNhbm5vdCBiZSBkZWNvZGVkXG4gICAgICAgICAqIEB0aHJvd3MgQ2hlY2tzdW1FeGNlcHRpb24gaWYgZXJyb3IgY29ycmVjdGlvbiBmYWlsc1xuICAgICAgICAgKi9cbiAgICAgICAgZGVjb2RlKGJpdHMpIHtcbiAgICAgICAgICAgIC8vIENvbnN0cnVjdCBhIHBhcnNlciBhbmQgcmVhZCB2ZXJzaW9uLCBlcnJvci1jb3JyZWN0aW9uIGxldmVsXG4gICAgICAgICAgICBjb25zdCBwYXJzZXIgPSBuZXcgQml0TWF0cml4UGFyc2VyKGJpdHMpO1xuICAgICAgICAgICAgY29uc3QgdmVyc2lvbiA9IHBhcnNlci5nZXRWZXJzaW9uKCk7XG4gICAgICAgICAgICAvLyBSZWFkIGNvZGV3b3Jkc1xuICAgICAgICAgICAgY29uc3QgY29kZXdvcmRzID0gcGFyc2VyLnJlYWRDb2Rld29yZHMoKTtcbiAgICAgICAgICAgIC8vIFNlcGFyYXRlIGludG8gZGF0YSBibG9ja3NcbiAgICAgICAgICAgIGNvbnN0IGRhdGFCbG9ja3MgPSBEYXRhQmxvY2suZ2V0RGF0YUJsb2Nrcyhjb2Rld29yZHMsIHZlcnNpb24pO1xuICAgICAgICAgICAgLy8gQ291bnQgdG90YWwgbnVtYmVyIG9mIGRhdGEgYnl0ZXNcbiAgICAgICAgICAgIGxldCB0b3RhbEJ5dGVzID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IGRiIG9mIGRhdGFCbG9ja3MpIHtcbiAgICAgICAgICAgICAgICB0b3RhbEJ5dGVzICs9IGRiLmdldE51bURhdGFDb2Rld29yZHMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdEJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkodG90YWxCeXRlcyk7XG4gICAgICAgICAgICBjb25zdCBkYXRhQmxvY2tzQ291bnQgPSBkYXRhQmxvY2tzLmxlbmd0aDtcbiAgICAgICAgICAgIC8vIEVycm9yLWNvcnJlY3QgYW5kIGNvcHkgZGF0YSBibG9ja3MgdG9nZXRoZXIgaW50byBhIHN0cmVhbSBvZiBieXRlc1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBkYXRhQmxvY2tzQ291bnQ7IGorKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGFCbG9jayA9IGRhdGFCbG9ja3Nbal07XG4gICAgICAgICAgICAgICAgY29uc3QgY29kZXdvcmRCeXRlcyA9IGRhdGFCbG9jay5nZXRDb2Rld29yZHMoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBudW1EYXRhQ29kZXdvcmRzID0gZGF0YUJsb2NrLmdldE51bURhdGFDb2Rld29yZHMoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvcnJlY3RFcnJvcnMoY29kZXdvcmRCeXRlcywgbnVtRGF0YUNvZGV3b3Jkcyk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1EYXRhQ29kZXdvcmRzOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRGUtaW50ZXJsYWNlIGRhdGEgYmxvY2tzLlxuICAgICAgICAgICAgICAgICAgICByZXN1bHRCeXRlc1tpICogZGF0YUJsb2Nrc0NvdW50ICsgal0gPSBjb2Rld29yZEJ5dGVzW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIERlY29kZSB0aGUgY29udGVudHMgb2YgdGhhdCBzdHJlYW0gb2YgYnl0ZXNcbiAgICAgICAgICAgIHJldHVybiBEZWNvZGVkQml0U3RyZWFtUGFyc2VyLmRlY29kZShyZXN1bHRCeXRlcyk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIDxwPkdpdmVuIGRhdGEgYW5kIGVycm9yLWNvcnJlY3Rpb24gY29kZXdvcmRzIHJlY2VpdmVkLCBwb3NzaWJseSBjb3JydXB0ZWQgYnkgZXJyb3JzLCBhdHRlbXB0cyB0b1xuICAgICAgICAgKiBjb3JyZWN0IHRoZSBlcnJvcnMgaW4tcGxhY2UgdXNpbmcgUmVlZC1Tb2xvbW9uIGVycm9yIGNvcnJlY3Rpb24uPC9wPlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gY29kZXdvcmRCeXRlcyBkYXRhIGFuZCBlcnJvciBjb3JyZWN0aW9uIGNvZGV3b3Jkc1xuICAgICAgICAgKiBAcGFyYW0gbnVtRGF0YUNvZGV3b3JkcyBudW1iZXIgb2YgY29kZXdvcmRzIHRoYXQgYXJlIGRhdGEgYnl0ZXNcbiAgICAgICAgICogQHRocm93cyBDaGVja3N1bUV4Y2VwdGlvbiBpZiBlcnJvciBjb3JyZWN0aW9uIGZhaWxzXG4gICAgICAgICAqL1xuICAgICAgICBjb3JyZWN0RXJyb3JzKGNvZGV3b3JkQnl0ZXMsIG51bURhdGFDb2Rld29yZHMpIHtcbiAgICAgICAgICAgIC8vIGNvbnN0IG51bUNvZGV3b3JkcyA9IGNvZGV3b3JkQnl0ZXMubGVuZ3RoO1xuICAgICAgICAgICAgLy8gRmlyc3QgcmVhZCBpbnRvIGFuIGFycmF5IG9mIGludHNcbiAgICAgICAgICAgIGNvbnN0IGNvZGV3b3Jkc0ludHMgPSBuZXcgSW50MzJBcnJheShjb2Rld29yZEJ5dGVzKTtcbiAgICAgICAgICAgIC8vIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtQ29kZXdvcmRzOyBpKyspIHtcbiAgICAgICAgICAgIC8vICAgY29kZXdvcmRzSW50c1tpXSA9IGNvZGV3b3JkQnl0ZXNbaV0gJiAweEZGO1xuICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0aGlzLnJzRGVjb2Rlci5kZWNvZGUoY29kZXdvcmRzSW50cywgY29kZXdvcmRCeXRlcy5sZW5ndGggLSBudW1EYXRhQ29kZXdvcmRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChpZ25vcmVkIC8qIFJlZWRTb2xvbW9uRXhjZXB0aW9uICovKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IENoZWNrc3VtRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDb3B5IGJhY2sgaW50byBhcnJheSBvZiBieXRlcyAtLSBvbmx5IG5lZWQgdG8gd29ycnkgYWJvdXQgdGhlIGJ5dGVzIHRoYXQgd2VyZSBkYXRhXG4gICAgICAgICAgICAvLyBXZSBkb24ndCBjYXJlIGFib3V0IGVycm9ycyBpbiB0aGUgZXJyb3ItY29ycmVjdGlvbiBjb2Rld29yZHNcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtRGF0YUNvZGV3b3JkczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29kZXdvcmRCeXRlc1tpXSA9IGNvZGV3b3Jkc0ludHNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiA8cD5FbmNhcHN1bGF0ZXMgbG9naWMgdGhhdCBjYW4gZGV0ZWN0IGEgRGF0YSBNYXRyaXggQ29kZSBpbiBhbiBpbWFnZSwgZXZlbiBpZiB0aGUgRGF0YSBNYXRyaXggQ29kZVxuICAgICAqIGlzIHJvdGF0ZWQgb3Igc2tld2VkLCBvciBwYXJ0aWFsbHkgb2JzY3VyZWQuPC9wPlxuICAgICAqXG4gICAgICogQGF1dGhvciBTZWFuIE93ZW5cbiAgICAgKi9cbiAgICBjbGFzcyBEZXRlY3RvciQxIHtcbiAgICAgICAgY29uc3RydWN0b3IoaW1hZ2UpIHtcbiAgICAgICAgICAgIHRoaXMuaW1hZ2UgPSBpbWFnZTtcbiAgICAgICAgICAgIHRoaXMucmVjdGFuZ2xlRGV0ZWN0b3IgPSBuZXcgV2hpdGVSZWN0YW5nbGVEZXRlY3Rvcih0aGlzLmltYWdlKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogPHA+RGV0ZWN0cyBhIERhdGEgTWF0cml4IENvZGUgaW4gYW4gaW1hZ2UuPC9wPlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtAbGluayBEZXRlY3RvclJlc3VsdH0gZW5jYXBzdWxhdGluZyByZXN1bHRzIG9mIGRldGVjdGluZyBhIERhdGEgTWF0cml4IENvZGVcbiAgICAgICAgICogQHRocm93cyBOb3RGb3VuZEV4Y2VwdGlvbiBpZiBubyBEYXRhIE1hdHJpeCBDb2RlIGNhbiBiZSBmb3VuZFxuICAgICAgICAgKi9cbiAgICAgICAgZGV0ZWN0KCkge1xuICAgICAgICAgICAgY29uc3QgY29ybmVyUG9pbnRzID0gdGhpcy5yZWN0YW5nbGVEZXRlY3Rvci5kZXRlY3QoKTtcbiAgICAgICAgICAgIGxldCBwb2ludHMgPSB0aGlzLmRldGVjdFNvbGlkMShjb3JuZXJQb2ludHMpO1xuICAgICAgICAgICAgcG9pbnRzID0gdGhpcy5kZXRlY3RTb2xpZDIocG9pbnRzKTtcbiAgICAgICAgICAgIHBvaW50c1szXSA9IHRoaXMuY29ycmVjdFRvcFJpZ2h0KHBvaW50cyk7XG4gICAgICAgICAgICBpZiAoIXBvaW50c1szXSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9pbnRzID0gdGhpcy5zaGlmdFRvTW9kdWxlQ2VudGVyKHBvaW50cyk7XG4gICAgICAgICAgICBjb25zdCB0b3BMZWZ0ID0gcG9pbnRzWzBdO1xuICAgICAgICAgICAgY29uc3QgYm90dG9tTGVmdCA9IHBvaW50c1sxXTtcbiAgICAgICAgICAgIGNvbnN0IGJvdHRvbVJpZ2h0ID0gcG9pbnRzWzJdO1xuICAgICAgICAgICAgY29uc3QgdG9wUmlnaHQgPSBwb2ludHNbM107XG4gICAgICAgICAgICBsZXQgZGltZW5zaW9uVG9wID0gdGhpcy50cmFuc2l0aW9uc0JldHdlZW4odG9wTGVmdCwgdG9wUmlnaHQpICsgMTtcbiAgICAgICAgICAgIGxldCBkaW1lbnNpb25SaWdodCA9IHRoaXMudHJhbnNpdGlvbnNCZXR3ZWVuKGJvdHRvbVJpZ2h0LCB0b3BSaWdodCkgKyAxO1xuICAgICAgICAgICAgaWYgKChkaW1lbnNpb25Ub3AgJiAweDAxKSA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGRpbWVuc2lvblRvcCArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChkaW1lbnNpb25SaWdodCAmIDB4MDEpID09PSAxKSB7XG4gICAgICAgICAgICAgICAgZGltZW5zaW9uUmlnaHQgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICg0ICogZGltZW5zaW9uVG9wIDwgNyAqIGRpbWVuc2lvblJpZ2h0ICYmIDQgKiBkaW1lbnNpb25SaWdodCA8IDcgKiBkaW1lbnNpb25Ub3ApIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgbWF0cml4IGlzIHNxdWFyZVxuICAgICAgICAgICAgICAgIGRpbWVuc2lvblRvcCA9IGRpbWVuc2lvblJpZ2h0ID0gTWF0aC5tYXgoZGltZW5zaW9uVG9wLCBkaW1lbnNpb25SaWdodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgYml0cyA9IERldGVjdG9yJDEuc2FtcGxlR3JpZCh0aGlzLmltYWdlLCB0b3BMZWZ0LCBib3R0b21MZWZ0LCBib3R0b21SaWdodCwgdG9wUmlnaHQsIGRpbWVuc2lvblRvcCwgZGltZW5zaW9uUmlnaHQpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEZXRlY3RvclJlc3VsdChiaXRzLCBbdG9wTGVmdCwgYm90dG9tTGVmdCwgYm90dG9tUmlnaHQsIHRvcFJpZ2h0XSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIHNoaWZ0UG9pbnQocG9pbnQsIHRvLCBkaXYpIHtcbiAgICAgICAgICAgIGxldCB4ID0gKHRvLmdldFgoKSAtIHBvaW50LmdldFgoKSkgLyAoZGl2ICsgMSk7XG4gICAgICAgICAgICBsZXQgeSA9ICh0by5nZXRZKCkgLSBwb2ludC5nZXRZKCkpIC8gKGRpdiArIDEpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZXN1bHRQb2ludChwb2ludC5nZXRYKCkgKyB4LCBwb2ludC5nZXRZKCkgKyB5KTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgbW92ZUF3YXkocG9pbnQsIGZyb21YLCBmcm9tWSkge1xuICAgICAgICAgICAgbGV0IHggPSBwb2ludC5nZXRYKCk7XG4gICAgICAgICAgICBsZXQgeSA9IHBvaW50LmdldFkoKTtcbiAgICAgICAgICAgIGlmICh4IDwgZnJvbVgpIHtcbiAgICAgICAgICAgICAgICB4IC09IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB4ICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoeSA8IGZyb21ZKSB7XG4gICAgICAgICAgICAgICAgeSAtPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgeSArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZXN1bHRQb2ludCh4LCB5KTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogRGV0ZWN0IGEgc29saWQgc2lkZSB3aGljaCBoYXMgbWluaW11bSB0cmFuc2l0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgZGV0ZWN0U29saWQxKGNvcm5lclBvaW50cykge1xuICAgICAgICAgICAgLy8gMCAgMlxuICAgICAgICAgICAgLy8gMSAgM1xuICAgICAgICAgICAgbGV0IHBvaW50QSA9IGNvcm5lclBvaW50c1swXTtcbiAgICAgICAgICAgIGxldCBwb2ludEIgPSBjb3JuZXJQb2ludHNbMV07XG4gICAgICAgICAgICBsZXQgcG9pbnRDID0gY29ybmVyUG9pbnRzWzNdO1xuICAgICAgICAgICAgbGV0IHBvaW50RCA9IGNvcm5lclBvaW50c1syXTtcbiAgICAgICAgICAgIGxldCB0ckFCID0gdGhpcy50cmFuc2l0aW9uc0JldHdlZW4ocG9pbnRBLCBwb2ludEIpO1xuICAgICAgICAgICAgbGV0IHRyQkMgPSB0aGlzLnRyYW5zaXRpb25zQmV0d2Vlbihwb2ludEIsIHBvaW50Qyk7XG4gICAgICAgICAgICBsZXQgdHJDRCA9IHRoaXMudHJhbnNpdGlvbnNCZXR3ZWVuKHBvaW50QywgcG9pbnREKTtcbiAgICAgICAgICAgIGxldCB0ckRBID0gdGhpcy50cmFuc2l0aW9uc0JldHdlZW4ocG9pbnRELCBwb2ludEEpO1xuICAgICAgICAgICAgLy8gMC4uM1xuICAgICAgICAgICAgLy8gOiAgOlxuICAgICAgICAgICAgLy8gMS0tMlxuICAgICAgICAgICAgbGV0IG1pbiA9IHRyQUI7XG4gICAgICAgICAgICBsZXQgcG9pbnRzID0gW3BvaW50RCwgcG9pbnRBLCBwb2ludEIsIHBvaW50Q107XG4gICAgICAgICAgICBpZiAobWluID4gdHJCQykge1xuICAgICAgICAgICAgICAgIG1pbiA9IHRyQkM7XG4gICAgICAgICAgICAgICAgcG9pbnRzWzBdID0gcG9pbnRBO1xuICAgICAgICAgICAgICAgIHBvaW50c1sxXSA9IHBvaW50QjtcbiAgICAgICAgICAgICAgICBwb2ludHNbMl0gPSBwb2ludEM7XG4gICAgICAgICAgICAgICAgcG9pbnRzWzNdID0gcG9pbnREO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1pbiA+IHRyQ0QpIHtcbiAgICAgICAgICAgICAgICBtaW4gPSB0ckNEO1xuICAgICAgICAgICAgICAgIHBvaW50c1swXSA9IHBvaW50QjtcbiAgICAgICAgICAgICAgICBwb2ludHNbMV0gPSBwb2ludEM7XG4gICAgICAgICAgICAgICAgcG9pbnRzWzJdID0gcG9pbnREO1xuICAgICAgICAgICAgICAgIHBvaW50c1szXSA9IHBvaW50QTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtaW4gPiB0ckRBKSB7XG4gICAgICAgICAgICAgICAgcG9pbnRzWzBdID0gcG9pbnRDO1xuICAgICAgICAgICAgICAgIHBvaW50c1sxXSA9IHBvaW50RDtcbiAgICAgICAgICAgICAgICBwb2ludHNbMl0gPSBwb2ludEE7XG4gICAgICAgICAgICAgICAgcG9pbnRzWzNdID0gcG9pbnRCO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHBvaW50cztcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogRGV0ZWN0IGEgc2Vjb25kIHNvbGlkIHNpZGUgbmV4dCB0byBmaXJzdCBzb2xpZCBzaWRlLlxuICAgICAgICAgKi9cbiAgICAgICAgZGV0ZWN0U29saWQyKHBvaW50cykge1xuICAgICAgICAgICAgLy8gQS4uRFxuICAgICAgICAgICAgLy8gOiAgOlxuICAgICAgICAgICAgLy8gQi0tQ1xuICAgICAgICAgICAgbGV0IHBvaW50QSA9IHBvaW50c1swXTtcbiAgICAgICAgICAgIGxldCBwb2ludEIgPSBwb2ludHNbMV07XG4gICAgICAgICAgICBsZXQgcG9pbnRDID0gcG9pbnRzWzJdO1xuICAgICAgICAgICAgbGV0IHBvaW50RCA9IHBvaW50c1szXTtcbiAgICAgICAgICAgIC8vIFRyYW5zaXRpb24gZGV0ZWN0aW9uIG9uIHRoZSBlZGdlIGlzIG5vdCBzdGFibGUuXG4gICAgICAgICAgICAvLyBUbyBzYWZlbHkgZGV0ZWN0LCBzaGlmdCB0aGUgcG9pbnRzIHRvIHRoZSBtb2R1bGUgY2VudGVyLlxuICAgICAgICAgICAgbGV0IHRyID0gdGhpcy50cmFuc2l0aW9uc0JldHdlZW4ocG9pbnRBLCBwb2ludEQpO1xuICAgICAgICAgICAgbGV0IHBvaW50QnMgPSBEZXRlY3RvciQxLnNoaWZ0UG9pbnQocG9pbnRCLCBwb2ludEMsICh0ciArIDEpICogNCk7XG4gICAgICAgICAgICBsZXQgcG9pbnRDcyA9IERldGVjdG9yJDEuc2hpZnRQb2ludChwb2ludEMsIHBvaW50QiwgKHRyICsgMSkgKiA0KTtcbiAgICAgICAgICAgIGxldCB0ckJBID0gdGhpcy50cmFuc2l0aW9uc0JldHdlZW4ocG9pbnRCcywgcG9pbnRBKTtcbiAgICAgICAgICAgIGxldCB0ckNEID0gdGhpcy50cmFuc2l0aW9uc0JldHdlZW4ocG9pbnRDcywgcG9pbnREKTtcbiAgICAgICAgICAgIC8vIDAuLjNcbiAgICAgICAgICAgIC8vIHwgIDpcbiAgICAgICAgICAgIC8vIDEtLTJcbiAgICAgICAgICAgIGlmICh0ckJBIDwgdHJDRCkge1xuICAgICAgICAgICAgICAgIC8vIHNvbGlkIHNpZGVzOiBBLUItQ1xuICAgICAgICAgICAgICAgIHBvaW50c1swXSA9IHBvaW50QTtcbiAgICAgICAgICAgICAgICBwb2ludHNbMV0gPSBwb2ludEI7XG4gICAgICAgICAgICAgICAgcG9pbnRzWzJdID0gcG9pbnRDO1xuICAgICAgICAgICAgICAgIHBvaW50c1szXSA9IHBvaW50RDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHNvbGlkIHNpZGVzOiBCLUMtRFxuICAgICAgICAgICAgICAgIHBvaW50c1swXSA9IHBvaW50QjtcbiAgICAgICAgICAgICAgICBwb2ludHNbMV0gPSBwb2ludEM7XG4gICAgICAgICAgICAgICAgcG9pbnRzWzJdID0gcG9pbnREO1xuICAgICAgICAgICAgICAgIHBvaW50c1szXSA9IHBvaW50QTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwb2ludHM7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGN1bGF0ZXMgdGhlIGNvcm5lciBwb3NpdGlvbiBvZiB0aGUgd2hpdGUgdG9wIHJpZ2h0IG1vZHVsZS5cbiAgICAgICAgICovXG4gICAgICAgIGNvcnJlY3RUb3BSaWdodChwb2ludHMpIHtcbiAgICAgICAgICAgIC8vIEEuLkRcbiAgICAgICAgICAgIC8vIHwgIDpcbiAgICAgICAgICAgIC8vIEItLUNcbiAgICAgICAgICAgIGxldCBwb2ludEEgPSBwb2ludHNbMF07XG4gICAgICAgICAgICBsZXQgcG9pbnRCID0gcG9pbnRzWzFdO1xuICAgICAgICAgICAgbGV0IHBvaW50QyA9IHBvaW50c1syXTtcbiAgICAgICAgICAgIGxldCBwb2ludEQgPSBwb2ludHNbM107XG4gICAgICAgICAgICAvLyBzaGlmdCBwb2ludHMgZm9yIHNhZmUgdHJhbnNpdGlvbiBkZXRlY3Rpb24uXG4gICAgICAgICAgICBsZXQgdHJUb3AgPSB0aGlzLnRyYW5zaXRpb25zQmV0d2Vlbihwb2ludEEsIHBvaW50RCk7XG4gICAgICAgICAgICBsZXQgdHJSaWdodCA9IHRoaXMudHJhbnNpdGlvbnNCZXR3ZWVuKHBvaW50QiwgcG9pbnREKTtcbiAgICAgICAgICAgIGxldCBwb2ludEFzID0gRGV0ZWN0b3IkMS5zaGlmdFBvaW50KHBvaW50QSwgcG9pbnRCLCAodHJSaWdodCArIDEpICogNCk7XG4gICAgICAgICAgICBsZXQgcG9pbnRDcyA9IERldGVjdG9yJDEuc2hpZnRQb2ludChwb2ludEMsIHBvaW50QiwgKHRyVG9wICsgMSkgKiA0KTtcbiAgICAgICAgICAgIHRyVG9wID0gdGhpcy50cmFuc2l0aW9uc0JldHdlZW4ocG9pbnRBcywgcG9pbnREKTtcbiAgICAgICAgICAgIHRyUmlnaHQgPSB0aGlzLnRyYW5zaXRpb25zQmV0d2Vlbihwb2ludENzLCBwb2ludEQpO1xuICAgICAgICAgICAgbGV0IGNhbmRpZGF0ZTEgPSBuZXcgUmVzdWx0UG9pbnQocG9pbnRELmdldFgoKSArIChwb2ludEMuZ2V0WCgpIC0gcG9pbnRCLmdldFgoKSkgLyAodHJUb3AgKyAxKSwgcG9pbnRELmdldFkoKSArIChwb2ludEMuZ2V0WSgpIC0gcG9pbnRCLmdldFkoKSkgLyAodHJUb3AgKyAxKSk7XG4gICAgICAgICAgICBsZXQgY2FuZGlkYXRlMiA9IG5ldyBSZXN1bHRQb2ludChwb2ludEQuZ2V0WCgpICsgKHBvaW50QS5nZXRYKCkgLSBwb2ludEIuZ2V0WCgpKSAvICh0clJpZ2h0ICsgMSksIHBvaW50RC5nZXRZKCkgKyAocG9pbnRBLmdldFkoKSAtIHBvaW50Qi5nZXRZKCkpIC8gKHRyUmlnaHQgKyAxKSk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZChjYW5kaWRhdGUxKSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzVmFsaWQoY2FuZGlkYXRlMikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZTI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoY2FuZGlkYXRlMikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FuZGlkYXRlMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBzdW1jMSA9IHRoaXMudHJhbnNpdGlvbnNCZXR3ZWVuKHBvaW50QXMsIGNhbmRpZGF0ZTEpICsgdGhpcy50cmFuc2l0aW9uc0JldHdlZW4ocG9pbnRDcywgY2FuZGlkYXRlMSk7XG4gICAgICAgICAgICBsZXQgc3VtYzIgPSB0aGlzLnRyYW5zaXRpb25zQmV0d2Vlbihwb2ludEFzLCBjYW5kaWRhdGUyKSArIHRoaXMudHJhbnNpdGlvbnNCZXR3ZWVuKHBvaW50Q3MsIGNhbmRpZGF0ZTIpO1xuICAgICAgICAgICAgaWYgKHN1bWMxID4gc3VtYzIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FuZGlkYXRlMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYW5kaWRhdGUyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTaGlmdCB0aGUgZWRnZSBwb2ludHMgdG8gdGhlIG1vZHVsZSBjZW50ZXIuXG4gICAgICAgICAqL1xuICAgICAgICBzaGlmdFRvTW9kdWxlQ2VudGVyKHBvaW50cykge1xuICAgICAgICAgICAgLy8gQS4uRFxuICAgICAgICAgICAgLy8gfCAgOlxuICAgICAgICAgICAgLy8gQi0tQ1xuICAgICAgICAgICAgbGV0IHBvaW50QSA9IHBvaW50c1swXTtcbiAgICAgICAgICAgIGxldCBwb2ludEIgPSBwb2ludHNbMV07XG4gICAgICAgICAgICBsZXQgcG9pbnRDID0gcG9pbnRzWzJdO1xuICAgICAgICAgICAgbGV0IHBvaW50RCA9IHBvaW50c1szXTtcbiAgICAgICAgICAgIC8vIGNhbGN1bGF0ZSBwc2V1ZG8gZGltZW5zaW9uc1xuICAgICAgICAgICAgbGV0IGRpbUggPSB0aGlzLnRyYW5zaXRpb25zQmV0d2Vlbihwb2ludEEsIHBvaW50RCkgKyAxO1xuICAgICAgICAgICAgbGV0IGRpbVYgPSB0aGlzLnRyYW5zaXRpb25zQmV0d2Vlbihwb2ludEMsIHBvaW50RCkgKyAxO1xuICAgICAgICAgICAgLy8gc2hpZnQgcG9pbnRzIGZvciBzYWZlIGRpbWVuc2lvbiBkZXRlY3Rpb25cbiAgICAgICAgICAgIGxldCBwb2ludEFzID0gRGV0ZWN0b3IkMS5zaGlmdFBvaW50KHBvaW50QSwgcG9pbnRCLCBkaW1WICogNCk7XG4gICAgICAgICAgICBsZXQgcG9pbnRDcyA9IERldGVjdG9yJDEuc2hpZnRQb2ludChwb2ludEMsIHBvaW50QiwgZGltSCAqIDQpO1xuICAgICAgICAgICAgLy8gIGNhbGN1bGF0ZSBtb3JlIHByZWNpc2UgZGltZW5zaW9uc1xuICAgICAgICAgICAgZGltSCA9IHRoaXMudHJhbnNpdGlvbnNCZXR3ZWVuKHBvaW50QXMsIHBvaW50RCkgKyAxO1xuICAgICAgICAgICAgZGltViA9IHRoaXMudHJhbnNpdGlvbnNCZXR3ZWVuKHBvaW50Q3MsIHBvaW50RCkgKyAxO1xuICAgICAgICAgICAgaWYgKChkaW1IICYgMHgwMSkgPT09IDEpIHtcbiAgICAgICAgICAgICAgICBkaW1IICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKGRpbVYgJiAweDAxKSA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGRpbVYgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFdoaXRlUmVjdGFuZ2xlRGV0ZWN0b3IgcmV0dXJucyBwb2ludHMgaW5zaWRlIG9mIHRoZSByZWN0YW5nbGUuXG4gICAgICAgICAgICAvLyBJIHdhbnQgcG9pbnRzIG9uIHRoZSBlZGdlcy5cbiAgICAgICAgICAgIGxldCBjZW50ZXJYID0gKHBvaW50QS5nZXRYKCkgKyBwb2ludEIuZ2V0WCgpICsgcG9pbnRDLmdldFgoKSArIHBvaW50RC5nZXRYKCkpIC8gNDtcbiAgICAgICAgICAgIGxldCBjZW50ZXJZID0gKHBvaW50QS5nZXRZKCkgKyBwb2ludEIuZ2V0WSgpICsgcG9pbnRDLmdldFkoKSArIHBvaW50RC5nZXRZKCkpIC8gNDtcbiAgICAgICAgICAgIHBvaW50QSA9IERldGVjdG9yJDEubW92ZUF3YXkocG9pbnRBLCBjZW50ZXJYLCBjZW50ZXJZKTtcbiAgICAgICAgICAgIHBvaW50QiA9IERldGVjdG9yJDEubW92ZUF3YXkocG9pbnRCLCBjZW50ZXJYLCBjZW50ZXJZKTtcbiAgICAgICAgICAgIHBvaW50QyA9IERldGVjdG9yJDEubW92ZUF3YXkocG9pbnRDLCBjZW50ZXJYLCBjZW50ZXJZKTtcbiAgICAgICAgICAgIHBvaW50RCA9IERldGVjdG9yJDEubW92ZUF3YXkocG9pbnRELCBjZW50ZXJYLCBjZW50ZXJZKTtcbiAgICAgICAgICAgIGxldCBwb2ludEJzO1xuICAgICAgICAgICAgbGV0IHBvaW50RHM7XG4gICAgICAgICAgICAvLyBzaGlmdCBwb2ludHMgdG8gdGhlIGNlbnRlciBvZiBlYWNoIG1vZHVsZXNcbiAgICAgICAgICAgIHBvaW50QXMgPSBEZXRlY3RvciQxLnNoaWZ0UG9pbnQocG9pbnRBLCBwb2ludEIsIGRpbVYgKiA0KTtcbiAgICAgICAgICAgIHBvaW50QXMgPSBEZXRlY3RvciQxLnNoaWZ0UG9pbnQocG9pbnRBcywgcG9pbnRELCBkaW1IICogNCk7XG4gICAgICAgICAgICBwb2ludEJzID0gRGV0ZWN0b3IkMS5zaGlmdFBvaW50KHBvaW50QiwgcG9pbnRBLCBkaW1WICogNCk7XG4gICAgICAgICAgICBwb2ludEJzID0gRGV0ZWN0b3IkMS5zaGlmdFBvaW50KHBvaW50QnMsIHBvaW50QywgZGltSCAqIDQpO1xuICAgICAgICAgICAgcG9pbnRDcyA9IERldGVjdG9yJDEuc2hpZnRQb2ludChwb2ludEMsIHBvaW50RCwgZGltViAqIDQpO1xuICAgICAgICAgICAgcG9pbnRDcyA9IERldGVjdG9yJDEuc2hpZnRQb2ludChwb2ludENzLCBwb2ludEIsIGRpbUggKiA0KTtcbiAgICAgICAgICAgIHBvaW50RHMgPSBEZXRlY3RvciQxLnNoaWZ0UG9pbnQocG9pbnRELCBwb2ludEMsIGRpbVYgKiA0KTtcbiAgICAgICAgICAgIHBvaW50RHMgPSBEZXRlY3RvciQxLnNoaWZ0UG9pbnQocG9pbnREcywgcG9pbnRBLCBkaW1IICogNCk7XG4gICAgICAgICAgICByZXR1cm4gW3BvaW50QXMsIHBvaW50QnMsIHBvaW50Q3MsIHBvaW50RHNdO1xuICAgICAgICB9XG4gICAgICAgIGlzVmFsaWQocCkge1xuICAgICAgICAgICAgcmV0dXJuIHAuZ2V0WCgpID49IDAgJiYgcC5nZXRYKCkgPCB0aGlzLmltYWdlLmdldFdpZHRoKCkgJiYgcC5nZXRZKCkgPiAwICYmIHAuZ2V0WSgpIDwgdGhpcy5pbWFnZS5nZXRIZWlnaHQoKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgc2FtcGxlR3JpZChpbWFnZSwgdG9wTGVmdCwgYm90dG9tTGVmdCwgYm90dG9tUmlnaHQsIHRvcFJpZ2h0LCBkaW1lbnNpb25YLCBkaW1lbnNpb25ZKSB7XG4gICAgICAgICAgICBjb25zdCBzYW1wbGVyID0gR3JpZFNhbXBsZXJJbnN0YW5jZS5nZXRJbnN0YW5jZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHNhbXBsZXIuc2FtcGxlR3JpZChpbWFnZSwgZGltZW5zaW9uWCwgZGltZW5zaW9uWSwgMC41LCAwLjUsIGRpbWVuc2lvblggLSAwLjUsIDAuNSwgZGltZW5zaW9uWCAtIDAuNSwgZGltZW5zaW9uWSAtIDAuNSwgMC41LCBkaW1lbnNpb25ZIC0gMC41LCB0b3BMZWZ0LmdldFgoKSwgdG9wTGVmdC5nZXRZKCksIHRvcFJpZ2h0LmdldFgoKSwgdG9wUmlnaHQuZ2V0WSgpLCBib3R0b21SaWdodC5nZXRYKCksIGJvdHRvbVJpZ2h0LmdldFkoKSwgYm90dG9tTGVmdC5nZXRYKCksIGJvdHRvbUxlZnQuZ2V0WSgpKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ291bnRzIHRoZSBudW1iZXIgb2YgYmxhY2svd2hpdGUgdHJhbnNpdGlvbnMgYmV0d2VlbiB0d28gcG9pbnRzLCB1c2luZyBzb21ldGhpbmcgbGlrZSBCcmVzZW5oYW0ncyBhbGdvcml0aG0uXG4gICAgICAgICAqL1xuICAgICAgICB0cmFuc2l0aW9uc0JldHdlZW4oZnJvbSwgdG8pIHtcbiAgICAgICAgICAgIC8vIFNlZSBRUiBDb2RlIERldGVjdG9yLCBzaXplT2ZCbGFja1doaXRlQmxhY2tSdW4oKVxuICAgICAgICAgICAgbGV0IGZyb21YID0gTWF0aC50cnVuYyhmcm9tLmdldFgoKSk7XG4gICAgICAgICAgICBsZXQgZnJvbVkgPSBNYXRoLnRydW5jKGZyb20uZ2V0WSgpKTtcbiAgICAgICAgICAgIGxldCB0b1ggPSBNYXRoLnRydW5jKHRvLmdldFgoKSk7XG4gICAgICAgICAgICBsZXQgdG9ZID0gTWF0aC50cnVuYyh0by5nZXRZKCkpO1xuICAgICAgICAgICAgbGV0IHN0ZWVwID0gTWF0aC5hYnModG9ZIC0gZnJvbVkpID4gTWF0aC5hYnModG9YIC0gZnJvbVgpO1xuICAgICAgICAgICAgaWYgKHN0ZWVwKSB7XG4gICAgICAgICAgICAgICAgbGV0IHRlbXAgPSBmcm9tWDtcbiAgICAgICAgICAgICAgICBmcm9tWCA9IGZyb21ZO1xuICAgICAgICAgICAgICAgIGZyb21ZID0gdGVtcDtcbiAgICAgICAgICAgICAgICB0ZW1wID0gdG9YO1xuICAgICAgICAgICAgICAgIHRvWCA9IHRvWTtcbiAgICAgICAgICAgICAgICB0b1kgPSB0ZW1wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGR4ID0gTWF0aC5hYnModG9YIC0gZnJvbVgpO1xuICAgICAgICAgICAgbGV0IGR5ID0gTWF0aC5hYnModG9ZIC0gZnJvbVkpO1xuICAgICAgICAgICAgbGV0IGVycm9yID0gLWR4IC8gMjtcbiAgICAgICAgICAgIGxldCB5c3RlcCA9IGZyb21ZIDwgdG9ZID8gMSA6IC0xO1xuICAgICAgICAgICAgbGV0IHhzdGVwID0gZnJvbVggPCB0b1ggPyAxIDogLTE7XG4gICAgICAgICAgICBsZXQgdHJhbnNpdGlvbnMgPSAwO1xuICAgICAgICAgICAgbGV0IGluQmxhY2sgPSB0aGlzLmltYWdlLmdldChzdGVlcCA/IGZyb21ZIDogZnJvbVgsIHN0ZWVwID8gZnJvbVggOiBmcm9tWSk7XG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gZnJvbVgsIHkgPSBmcm9tWTsgeCAhPT0gdG9YOyB4ICs9IHhzdGVwKSB7XG4gICAgICAgICAgICAgICAgbGV0IGlzQmxhY2sgPSB0aGlzLmltYWdlLmdldChzdGVlcCA/IHkgOiB4LCBzdGVlcCA/IHggOiB5KTtcbiAgICAgICAgICAgICAgICBpZiAoaXNCbGFjayAhPT0gaW5CbGFjaykge1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aW9ucysrO1xuICAgICAgICAgICAgICAgICAgICBpbkJsYWNrID0gaXNCbGFjaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZXJyb3IgKz0gZHk7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoeSA9PT0gdG9ZKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB5ICs9IHlzdGVwO1xuICAgICAgICAgICAgICAgICAgICBlcnJvciAtPSBkeDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJhbnNpdGlvbnM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKlxuICAgICAqIENvcHlyaWdodCAyMDA3IFpYaW5nIGF1dGhvcnNcbiAgICAgKlxuICAgICAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gICAgICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgICAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgICAqXG4gICAgICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAgICAgKlxuICAgICAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgICAgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICAgICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gICAgICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICAgICAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIFRoaXMgaW1wbGVtZW50YXRpb24gY2FuIGRldGVjdCBhbmQgZGVjb2RlIERhdGEgTWF0cml4IGNvZGVzIGluIGFuIGltYWdlLlxuICAgICAqXG4gICAgICogQGF1dGhvciBiYnJvd25AZ29vZ2xlLmNvbSAoQnJpYW4gQnJvd24pXG4gICAgICovXG4gICAgY2xhc3MgRGF0YU1hdHJpeFJlYWRlciB7XG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgICAgdGhpcy5kZWNvZGVyID0gbmV3IERlY29kZXIkMSgpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMb2NhdGVzIGFuZCBkZWNvZGVzIGEgRGF0YSBNYXRyaXggY29kZSBpbiBhbiBpbWFnZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiBhIFN0cmluZyByZXByZXNlbnRpbmcgdGhlIGNvbnRlbnQgZW5jb2RlZCBieSB0aGUgRGF0YSBNYXRyaXggY29kZVxuICAgICAgICAgKiBAdGhyb3dzIE5vdEZvdW5kRXhjZXB0aW9uIGlmIGEgRGF0YSBNYXRyaXggY29kZSBjYW5ub3QgYmUgZm91bmRcbiAgICAgICAgICogQHRocm93cyBGb3JtYXRFeGNlcHRpb24gaWYgYSBEYXRhIE1hdHJpeCBjb2RlIGNhbm5vdCBiZSBkZWNvZGVkXG4gICAgICAgICAqIEB0aHJvd3MgQ2hlY2tzdW1FeGNlcHRpb24gaWYgZXJyb3IgY29ycmVjdGlvbiBmYWlsc1xuICAgICAgICAgKi9cbiAgICAgICAgLy8gQE92ZXJyaWRlXG4gICAgICAgIC8vIHB1YmxpYyBSZXN1bHQgZGVjb2RlKEJpbmFyeUJpdG1hcCBpbWFnZSkgdGhyb3dzIE5vdEZvdW5kRXhjZXB0aW9uLCBDaGVja3N1bUV4Y2VwdGlvbiwgRm9ybWF0RXhjZXB0aW9uIHtcbiAgICAgICAgLy8gICByZXR1cm4gZGVjb2RlKGltYWdlLCBudWxsKTtcbiAgICAgICAgLy8gfVxuICAgICAgICAvLyBAT3ZlcnJpZGVcbiAgICAgICAgZGVjb2RlKGltYWdlLCBoaW50cyA9IG51bGwpIHtcbiAgICAgICAgICAgIGxldCBkZWNvZGVyUmVzdWx0O1xuICAgICAgICAgICAgbGV0IHBvaW50cztcbiAgICAgICAgICAgIGlmIChoaW50cyAhPSBudWxsICYmIGhpbnRzLmhhcyhEZWNvZGVIaW50VHlwZSQxLlBVUkVfQkFSQ09ERSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBiaXRzID0gRGF0YU1hdHJpeFJlYWRlci5leHRyYWN0UHVyZUJpdHMoaW1hZ2UuZ2V0QmxhY2tNYXRyaXgoKSk7XG4gICAgICAgICAgICAgICAgZGVjb2RlclJlc3VsdCA9IHRoaXMuZGVjb2Rlci5kZWNvZGUoYml0cyk7XG4gICAgICAgICAgICAgICAgcG9pbnRzID0gRGF0YU1hdHJpeFJlYWRlci5OT19QT0lOVFM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkZXRlY3RvclJlc3VsdCA9IG5ldyBEZXRlY3RvciQxKGltYWdlLmdldEJsYWNrTWF0cml4KCkpLmRldGVjdCgpO1xuICAgICAgICAgICAgICAgIGRlY29kZXJSZXN1bHQgPSB0aGlzLmRlY29kZXIuZGVjb2RlKGRldGVjdG9yUmVzdWx0LmdldEJpdHMoKSk7XG4gICAgICAgICAgICAgICAgcG9pbnRzID0gZGV0ZWN0b3JSZXN1bHQuZ2V0UG9pbnRzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByYXdCeXRlcyA9IGRlY29kZXJSZXN1bHQuZ2V0UmF3Qnl0ZXMoKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBSZXN1bHQoZGVjb2RlclJlc3VsdC5nZXRUZXh0KCksIHJhd0J5dGVzLCA4ICogcmF3Qnl0ZXMubGVuZ3RoLCBwb2ludHMsIEJhcmNvZGVGb3JtYXQkMS5EQVRBX01BVFJJWCwgU3lzdGVtLmN1cnJlbnRUaW1lTWlsbGlzKCkpO1xuICAgICAgICAgICAgY29uc3QgYnl0ZVNlZ21lbnRzID0gZGVjb2RlclJlc3VsdC5nZXRCeXRlU2VnbWVudHMoKTtcbiAgICAgICAgICAgIGlmIChieXRlU2VnbWVudHMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXRNZXRhZGF0YShSZXN1bHRNZXRhZGF0YVR5cGUkMS5CWVRFX1NFR01FTlRTLCBieXRlU2VnbWVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZWNMZXZlbCA9IGRlY29kZXJSZXN1bHQuZ2V0RUNMZXZlbCgpO1xuICAgICAgICAgICAgaWYgKGVjTGV2ZWwgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXRNZXRhZGF0YShSZXN1bHRNZXRhZGF0YVR5cGUkMS5FUlJPUl9DT1JSRUNUSU9OX0xFVkVMLCBlY0xldmVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQE92ZXJyaWRlXG4gICAgICAgIHJlc2V0KCkge1xuICAgICAgICAgICAgLy8gZG8gbm90aGluZ1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIG1ldGhvZCBkZXRlY3RzIGEgY29kZSBpbiBhIFwicHVyZVwiIGltYWdlIC0tIHRoYXQgaXMsIHB1cmUgbW9ub2Nocm9tZSBpbWFnZVxuICAgICAgICAgKiB3aGljaCBjb250YWlucyBvbmx5IGFuIHVucm90YXRlZCwgdW5za2V3ZWQsIGltYWdlIG9mIGEgY29kZSwgd2l0aCBzb21lIHdoaXRlIGJvcmRlclxuICAgICAgICAgKiBhcm91bmQgaXQuIFRoaXMgaXMgYSBzcGVjaWFsaXplZCBtZXRob2QgdGhhdCB3b3JrcyBleGNlcHRpb25hbGx5IGZhc3QgaW4gdGhpcyBzcGVjaWFsXG4gICAgICAgICAqIGNhc2UuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBzZWUgY29tLmdvb2dsZS56eGluZy5xcmNvZGUuUVJDb2RlUmVhZGVyI2V4dHJhY3RQdXJlQml0cyhCaXRNYXRyaXgpXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgZXh0cmFjdFB1cmVCaXRzKGltYWdlKSB7XG4gICAgICAgICAgICBjb25zdCBsZWZ0VG9wQmxhY2sgPSBpbWFnZS5nZXRUb3BMZWZ0T25CaXQoKTtcbiAgICAgICAgICAgIGNvbnN0IHJpZ2h0Qm90dG9tQmxhY2sgPSBpbWFnZS5nZXRCb3R0b21SaWdodE9uQml0KCk7XG4gICAgICAgICAgICBpZiAobGVmdFRvcEJsYWNrID09IG51bGwgfHwgcmlnaHRCb3R0b21CbGFjayA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBtb2R1bGVTaXplID0gdGhpcy5tb2R1bGVTaXplKGxlZnRUb3BCbGFjaywgaW1hZ2UpO1xuICAgICAgICAgICAgbGV0IHRvcCA9IGxlZnRUb3BCbGFja1sxXTtcbiAgICAgICAgICAgIGNvbnN0IGJvdHRvbSA9IHJpZ2h0Qm90dG9tQmxhY2tbMV07XG4gICAgICAgICAgICBsZXQgbGVmdCA9IGxlZnRUb3BCbGFja1swXTtcbiAgICAgICAgICAgIGNvbnN0IHJpZ2h0ID0gcmlnaHRCb3R0b21CbGFja1swXTtcbiAgICAgICAgICAgIGNvbnN0IG1hdHJpeFdpZHRoID0gKHJpZ2h0IC0gbGVmdCArIDEpIC8gbW9kdWxlU2l6ZTtcbiAgICAgICAgICAgIGNvbnN0IG1hdHJpeEhlaWdodCA9IChib3R0b20gLSB0b3AgKyAxKSAvIG1vZHVsZVNpemU7XG4gICAgICAgICAgICBpZiAobWF0cml4V2lkdGggPD0gMCB8fCBtYXRyaXhIZWlnaHQgPD0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUHVzaCBpbiB0aGUgXCJib3JkZXJcIiBieSBoYWxmIHRoZSBtb2R1bGUgd2lkdGggc28gdGhhdCB3ZSBzdGFydFxuICAgICAgICAgICAgLy8gc2FtcGxpbmcgaW4gdGhlIG1pZGRsZSBvZiB0aGUgbW9kdWxlLiBKdXN0IGluIGNhc2UgdGhlIGltYWdlIGlzIGFcbiAgICAgICAgICAgIC8vIGxpdHRsZSBvZmYsIHRoaXMgd2lsbCBoZWxwIHJlY292ZXIuXG4gICAgICAgICAgICBjb25zdCBudWRnZSA9IG1vZHVsZVNpemUgLyAyO1xuICAgICAgICAgICAgdG9wICs9IG51ZGdlO1xuICAgICAgICAgICAgbGVmdCArPSBudWRnZTtcbiAgICAgICAgICAgIC8vIE5vdyBqdXN0IHJlYWQgb2ZmIHRoZSBiaXRzXG4gICAgICAgICAgICBjb25zdCBiaXRzID0gbmV3IEJpdE1hdHJpeChtYXRyaXhXaWR0aCwgbWF0cml4SGVpZ2h0KTtcbiAgICAgICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgbWF0cml4SGVpZ2h0OyB5KyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpT2Zmc2V0ID0gdG9wICsgeSAqIG1vZHVsZVNpemU7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCBtYXRyaXhXaWR0aDsgeCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbWFnZS5nZXQobGVmdCArIHggKiBtb2R1bGVTaXplLCBpT2Zmc2V0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYml0cy5zZXQoeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYml0cztcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgbW9kdWxlU2l6ZShsZWZ0VG9wQmxhY2ssIGltYWdlKSB7XG4gICAgICAgICAgICBjb25zdCB3aWR0aCA9IGltYWdlLmdldFdpZHRoKCk7XG4gICAgICAgICAgICBsZXQgeCA9IGxlZnRUb3BCbGFja1swXTtcbiAgICAgICAgICAgIGNvbnN0IHkgPSBsZWZ0VG9wQmxhY2tbMV07XG4gICAgICAgICAgICB3aGlsZSAoeCA8IHdpZHRoICYmIGltYWdlLmdldCh4LCB5KSkge1xuICAgICAgICAgICAgICAgIHgrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh4ID09PSB3aWR0aCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbW9kdWxlU2l6ZSA9IHggLSBsZWZ0VG9wQmxhY2tbMF07XG4gICAgICAgICAgICBpZiAobW9kdWxlU2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1vZHVsZVNpemU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgRGF0YU1hdHJpeFJlYWRlci5OT19QT0lOVFMgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIE1vdmluZyB0byBAenhpbmcvYnJvd3NlclxuICAgICAqXG4gICAgICogUVIgQ29kZSByZWFkZXIgdG8gdXNlIGZyb20gYnJvd3Nlci5cbiAgICAgKi9cbiAgICBjbGFzcyBCcm93c2VyRGF0YW1hdHJpeENvZGVSZWFkZXIgZXh0ZW5kcyBCcm93c2VyQ29kZVJlYWRlciB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIEJyb3dzZXJRUkNvZGVSZWFkZXIuXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbdGltZUJldHdlZW5TY2Fuc01pbGxpcz01MDBdIHRoZSB0aW1lIGRlbGF5IGJldHdlZW4gc3Vic2VxdWVudCBkZWNvZGUgdHJpZXNcbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0cnVjdG9yKHRpbWVCZXR3ZWVuU2NhbnNNaWxsaXMgPSA1MDApIHtcbiAgICAgICAgICAgIHN1cGVyKG5ldyBEYXRhTWF0cml4UmVhZGVyKCksIHRpbWVCZXR3ZWVuU2NhbnNNaWxsaXMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBDb3B5cmlnaHQgMjAwNyBaWGluZyBhdXRob3JzXG4gICAgICpcbiAgICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgICAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgICAgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgICAgKlxuICAgICAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gICAgICpcbiAgICAgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICAgICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgICAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICAgICAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgICAgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAgICAgKi9cbiAgICB2YXIgRXJyb3JDb3JyZWN0aW9uTGV2ZWxWYWx1ZXM7XG4gICAgKGZ1bmN0aW9uIChFcnJvckNvcnJlY3Rpb25MZXZlbFZhbHVlcykge1xuICAgICAgICBFcnJvckNvcnJlY3Rpb25MZXZlbFZhbHVlc1tFcnJvckNvcnJlY3Rpb25MZXZlbFZhbHVlc1tcIkxcIl0gPSAwXSA9IFwiTFwiO1xuICAgICAgICBFcnJvckNvcnJlY3Rpb25MZXZlbFZhbHVlc1tFcnJvckNvcnJlY3Rpb25MZXZlbFZhbHVlc1tcIk1cIl0gPSAxXSA9IFwiTVwiO1xuICAgICAgICBFcnJvckNvcnJlY3Rpb25MZXZlbFZhbHVlc1tFcnJvckNvcnJlY3Rpb25MZXZlbFZhbHVlc1tcIlFcIl0gPSAyXSA9IFwiUVwiO1xuICAgICAgICBFcnJvckNvcnJlY3Rpb25MZXZlbFZhbHVlc1tFcnJvckNvcnJlY3Rpb25MZXZlbFZhbHVlc1tcIkhcIl0gPSAzXSA9IFwiSFwiO1xuICAgIH0pKEVycm9yQ29ycmVjdGlvbkxldmVsVmFsdWVzIHx8IChFcnJvckNvcnJlY3Rpb25MZXZlbFZhbHVlcyA9IHt9KSk7XG4gICAgLyoqXG4gICAgICogPHA+U2VlIElTTyAxODAwNDoyMDA2LCA2LjUuMS4gVGhpcyBlbnVtIGVuY2Fwc3VsYXRlcyB0aGUgZm91ciBlcnJvciBjb3JyZWN0aW9uIGxldmVsc1xuICAgICAqIGRlZmluZWQgYnkgdGhlIFFSIGNvZGUgc3RhbmRhcmQuPC9wPlxuICAgICAqXG4gICAgICogQGF1dGhvciBTZWFuIE93ZW5cbiAgICAgKi9cbiAgICBjbGFzcyBFcnJvckNvcnJlY3Rpb25MZXZlbCB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHZhbHVlLCBzdHJpbmdWYWx1ZSwgYml0cyAvKmludCovKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLnN0cmluZ1ZhbHVlID0gc3RyaW5nVmFsdWU7XG4gICAgICAgICAgICB0aGlzLmJpdHMgPSBiaXRzO1xuICAgICAgICAgICAgRXJyb3JDb3JyZWN0aW9uTGV2ZWwuRk9SX0JJVFMuc2V0KGJpdHMsIHRoaXMpO1xuICAgICAgICAgICAgRXJyb3JDb3JyZWN0aW9uTGV2ZWwuRk9SX1ZBTFVFLnNldCh2YWx1ZSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0VmFsdWUoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBnZXRCaXRzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYml0cztcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgZnJvbVN0cmluZyhzKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdMJzogcmV0dXJuIEVycm9yQ29ycmVjdGlvbkxldmVsLkw7XG4gICAgICAgICAgICAgICAgY2FzZSAnTSc6IHJldHVybiBFcnJvckNvcnJlY3Rpb25MZXZlbC5NO1xuICAgICAgICAgICAgICAgIGNhc2UgJ1EnOiByZXR1cm4gRXJyb3JDb3JyZWN0aW9uTGV2ZWwuUTtcbiAgICAgICAgICAgICAgICBjYXNlICdIJzogcmV0dXJuIEVycm9yQ29ycmVjdGlvbkxldmVsLkg7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDogdGhyb3cgbmV3IEFyZ3VtZW50RXhjZXB0aW9uKHMgKyAnbm90IGF2YWlsYWJsZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRvU3RyaW5nKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RyaW5nVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZXF1YWxzKG8pIHtcbiAgICAgICAgICAgIGlmICghKG8gaW5zdGFuY2VvZiBFcnJvckNvcnJlY3Rpb25MZXZlbCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBvdGhlciA9IG87XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZSA9PT0gb3RoZXIudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSBiaXRzIGludCBjb250YWluaW5nIHRoZSB0d28gYml0cyBlbmNvZGluZyBhIFFSIENvZGUncyBlcnJvciBjb3JyZWN0aW9uIGxldmVsXG4gICAgICAgICAqIEByZXR1cm4gRXJyb3JDb3JyZWN0aW9uTGV2ZWwgcmVwcmVzZW50aW5nIHRoZSBlbmNvZGVkIGVycm9yIGNvcnJlY3Rpb24gbGV2ZWxcbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBmb3JCaXRzKGJpdHMgLyppbnQqLykge1xuICAgICAgICAgICAgaWYgKGJpdHMgPCAwIHx8IGJpdHMgPj0gRXJyb3JDb3JyZWN0aW9uTGV2ZWwuRk9SX0JJVFMuc2l6ZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBFcnJvckNvcnJlY3Rpb25MZXZlbC5GT1JfQklUUy5nZXQoYml0cyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgRXJyb3JDb3JyZWN0aW9uTGV2ZWwuRk9SX0JJVFMgPSBuZXcgTWFwKCk7XG4gICAgRXJyb3JDb3JyZWN0aW9uTGV2ZWwuRk9SX1ZBTFVFID0gbmV3IE1hcCgpO1xuICAgIC8qKiBMID0gfjclIGNvcnJlY3Rpb24gKi9cbiAgICBFcnJvckNvcnJlY3Rpb25MZXZlbC5MID0gbmV3IEVycm9yQ29ycmVjdGlvbkxldmVsKEVycm9yQ29ycmVjdGlvbkxldmVsVmFsdWVzLkwsICdMJywgMHgwMSk7XG4gICAgLyoqIE0gPSB+MTUlIGNvcnJlY3Rpb24gKi9cbiAgICBFcnJvckNvcnJlY3Rpb25MZXZlbC5NID0gbmV3IEVycm9yQ29ycmVjdGlvbkxldmVsKEVycm9yQ29ycmVjdGlvbkxldmVsVmFsdWVzLk0sICdNJywgMHgwMCk7XG4gICAgLyoqIFEgPSB+MjUlIGNvcnJlY3Rpb24gKi9cbiAgICBFcnJvckNvcnJlY3Rpb25MZXZlbC5RID0gbmV3IEVycm9yQ29ycmVjdGlvbkxldmVsKEVycm9yQ29ycmVjdGlvbkxldmVsVmFsdWVzLlEsICdRJywgMHgwMyk7XG4gICAgLyoqIEggPSB+MzAlIGNvcnJlY3Rpb24gKi9cbiAgICBFcnJvckNvcnJlY3Rpb25MZXZlbC5IID0gbmV3IEVycm9yQ29ycmVjdGlvbkxldmVsKEVycm9yQ29ycmVjdGlvbkxldmVsVmFsdWVzLkgsICdIJywgMHgwMik7XG5cbiAgICAvKlxuICAgICAqIENvcHlyaWdodCAyMDA3IFpYaW5nIGF1dGhvcnNcbiAgICAgKlxuICAgICAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gICAgICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgICAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgICAqXG4gICAgICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAgICAgKlxuICAgICAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgICAgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICAgICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gICAgICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICAgICAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIDxwPkVuY2Fwc3VsYXRlcyBhIFFSIENvZGUncyBmb3JtYXQgaW5mb3JtYXRpb24sIGluY2x1ZGluZyB0aGUgZGF0YSBtYXNrIHVzZWQgYW5kXG4gICAgICogZXJyb3IgY29ycmVjdGlvbiBsZXZlbC48L3A+XG4gICAgICpcbiAgICAgKiBAYXV0aG9yIFNlYW4gT3dlblxuICAgICAqIEBzZWUgRGF0YU1hc2tcbiAgICAgKiBAc2VlIEVycm9yQ29ycmVjdGlvbkxldmVsXG4gICAgICovXG4gICAgY2xhc3MgRm9ybWF0SW5mb3JtYXRpb24ge1xuICAgICAgICBjb25zdHJ1Y3Rvcihmb3JtYXRJbmZvIC8qaW50Ki8pIHtcbiAgICAgICAgICAgIC8vIEJpdHMgMyw0XG4gICAgICAgICAgICB0aGlzLmVycm9yQ29ycmVjdGlvbkxldmVsID0gRXJyb3JDb3JyZWN0aW9uTGV2ZWwuZm9yQml0cygoZm9ybWF0SW5mbyA+PiAzKSAmIDB4MDMpO1xuICAgICAgICAgICAgLy8gQm90dG9tIDMgYml0c1xuICAgICAgICAgICAgdGhpcy5kYXRhTWFzayA9IC8qKGJ5dGUpICovIChmb3JtYXRJbmZvICYgMHgwNyk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIG51bUJpdHNEaWZmZXJpbmcoYSAvKmludCovLCBiIC8qaW50Ki8pIHtcbiAgICAgICAgICAgIHJldHVybiBJbnRlZ2VyLmJpdENvdW50KGEgXiBiKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIG1hc2tlZEZvcm1hdEluZm8xIGZvcm1hdCBpbmZvIGluZGljYXRvciwgd2l0aCBtYXNrIHN0aWxsIGFwcGxpZWRcbiAgICAgICAgICogQHBhcmFtIG1hc2tlZEZvcm1hdEluZm8yIHNlY29uZCBjb3B5IG9mIHNhbWUgaW5mbzsgYm90aCBhcmUgY2hlY2tlZCBhdCB0aGUgc2FtZSB0aW1lXG4gICAgICAgICAqICB0byBlc3RhYmxpc2ggYmVzdCBtYXRjaFxuICAgICAgICAgKiBAcmV0dXJuIGluZm9ybWF0aW9uIGFib3V0IHRoZSBmb3JtYXQgaXQgc3BlY2lmaWVzLCBvciB7QGNvZGUgbnVsbH1cbiAgICAgICAgICogIGlmIGRvZXNuJ3Qgc2VlbSB0byBtYXRjaCBhbnkga25vd24gcGF0dGVyblxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGRlY29kZUZvcm1hdEluZm9ybWF0aW9uKG1hc2tlZEZvcm1hdEluZm8xIC8qaW50Ki8sIG1hc2tlZEZvcm1hdEluZm8yIC8qaW50Ki8pIHtcbiAgICAgICAgICAgIGNvbnN0IGZvcm1hdEluZm8gPSBGb3JtYXRJbmZvcm1hdGlvbi5kb0RlY29kZUZvcm1hdEluZm9ybWF0aW9uKG1hc2tlZEZvcm1hdEluZm8xLCBtYXNrZWRGb3JtYXRJbmZvMik7XG4gICAgICAgICAgICBpZiAoZm9ybWF0SW5mbyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmb3JtYXRJbmZvO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU2hvdWxkIHJldHVybiBudWxsLCBidXQsIHNvbWUgUVIgY29kZXMgYXBwYXJlbnRseVxuICAgICAgICAgICAgLy8gZG8gbm90IG1hc2sgdGhpcyBpbmZvLiBUcnkgYWdhaW4gYnkgYWN0dWFsbHkgbWFza2luZyB0aGUgcGF0dGVyblxuICAgICAgICAgICAgLy8gZmlyc3RcbiAgICAgICAgICAgIHJldHVybiBGb3JtYXRJbmZvcm1hdGlvbi5kb0RlY29kZUZvcm1hdEluZm9ybWF0aW9uKG1hc2tlZEZvcm1hdEluZm8xIF4gRm9ybWF0SW5mb3JtYXRpb24uRk9STUFUX0lORk9fTUFTS19RUiwgbWFza2VkRm9ybWF0SW5mbzIgXiBGb3JtYXRJbmZvcm1hdGlvbi5GT1JNQVRfSU5GT19NQVNLX1FSKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgZG9EZWNvZGVGb3JtYXRJbmZvcm1hdGlvbihtYXNrZWRGb3JtYXRJbmZvMSAvKmludCovLCBtYXNrZWRGb3JtYXRJbmZvMiAvKmludCovKSB7XG4gICAgICAgICAgICAvLyBGaW5kIHRoZSBpbnQgaW4gRk9STUFUX0lORk9fREVDT0RFX0xPT0tVUCB3aXRoIGZld2VzdCBiaXRzIGRpZmZlcmluZ1xuICAgICAgICAgICAgbGV0IGJlc3REaWZmZXJlbmNlID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XG4gICAgICAgICAgICBsZXQgYmVzdEZvcm1hdEluZm8gPSAwO1xuICAgICAgICAgICAgZm9yIChjb25zdCBkZWNvZGVJbmZvIG9mIEZvcm1hdEluZm9ybWF0aW9uLkZPUk1BVF9JTkZPX0RFQ09ERV9MT09LVVApIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXRJbmZvID0gZGVjb2RlSW5mb1swXTtcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0SW5mbyA9PT0gbWFza2VkRm9ybWF0SW5mbzEgfHwgdGFyZ2V0SW5mbyA9PT0gbWFza2VkRm9ybWF0SW5mbzIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRm91bmQgYW4gZXhhY3QgbWF0Y2hcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBGb3JtYXRJbmZvcm1hdGlvbihkZWNvZGVJbmZvWzFdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGJpdHNEaWZmZXJlbmNlID0gRm9ybWF0SW5mb3JtYXRpb24ubnVtQml0c0RpZmZlcmluZyhtYXNrZWRGb3JtYXRJbmZvMSwgdGFyZ2V0SW5mbyk7XG4gICAgICAgICAgICAgICAgaWYgKGJpdHNEaWZmZXJlbmNlIDwgYmVzdERpZmZlcmVuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgYmVzdEZvcm1hdEluZm8gPSBkZWNvZGVJbmZvWzFdO1xuICAgICAgICAgICAgICAgICAgICBiZXN0RGlmZmVyZW5jZSA9IGJpdHNEaWZmZXJlbmNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobWFza2VkRm9ybWF0SW5mbzEgIT09IG1hc2tlZEZvcm1hdEluZm8yKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGFsc28gdHJ5IHRoZSBvdGhlciBvcHRpb25cbiAgICAgICAgICAgICAgICAgICAgYml0c0RpZmZlcmVuY2UgPSBGb3JtYXRJbmZvcm1hdGlvbi5udW1CaXRzRGlmZmVyaW5nKG1hc2tlZEZvcm1hdEluZm8yLCB0YXJnZXRJbmZvKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJpdHNEaWZmZXJlbmNlIDwgYmVzdERpZmZlcmVuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RGb3JtYXRJbmZvID0gZGVjb2RlSW5mb1sxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3REaWZmZXJlbmNlID0gYml0c0RpZmZlcmVuY2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBIYW1taW5nIGRpc3RhbmNlIG9mIHRoZSAzMiBtYXNrZWQgY29kZXMgaXMgNywgYnkgY29uc3RydWN0aW9uLCBzbyA8PSAzIGJpdHNcbiAgICAgICAgICAgIC8vIGRpZmZlcmluZyBtZWFucyB3ZSBmb3VuZCBhIG1hdGNoXG4gICAgICAgICAgICBpZiAoYmVzdERpZmZlcmVuY2UgPD0gMykge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRm9ybWF0SW5mb3JtYXRpb24oYmVzdEZvcm1hdEluZm8pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0RXJyb3JDb3JyZWN0aW9uTGV2ZWwoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lcnJvckNvcnJlY3Rpb25MZXZlbDtcbiAgICAgICAgfVxuICAgICAgICBnZXREYXRhTWFzaygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGFNYXNrO1xuICAgICAgICB9XG4gICAgICAgIC8qQE92ZXJyaWRlKi9cbiAgICAgICAgaGFzaENvZGUoKSB7XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMuZXJyb3JDb3JyZWN0aW9uTGV2ZWwuZ2V0Qml0cygpIDw8IDMpIHwgdGhpcy5kYXRhTWFzaztcbiAgICAgICAgfVxuICAgICAgICAvKkBPdmVycmlkZSovXG4gICAgICAgIGVxdWFscyhvKSB7XG4gICAgICAgICAgICBpZiAoIShvIGluc3RhbmNlb2YgRm9ybWF0SW5mb3JtYXRpb24pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgb3RoZXIgPSBvO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3JDb3JyZWN0aW9uTGV2ZWwgPT09IG90aGVyLmVycm9yQ29ycmVjdGlvbkxldmVsICYmXG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhTWFzayA9PT0gb3RoZXIuZGF0YU1hc2s7XG4gICAgICAgIH1cbiAgICB9XG4gICAgRm9ybWF0SW5mb3JtYXRpb24uRk9STUFUX0lORk9fTUFTS19RUiA9IDB4NTQxMjtcbiAgICAvKipcbiAgICAgKiBTZWUgSVNPIDE4MDA0OjIwMDYsIEFubmV4IEMsIFRhYmxlIEMuMVxuICAgICAqL1xuICAgIEZvcm1hdEluZm9ybWF0aW9uLkZPUk1BVF9JTkZPX0RFQ09ERV9MT09LVVAgPSBbXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMHg1NDEyLCAweDAwXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMHg1MTI1LCAweDAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMHg1RTdDLCAweDAyXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMHg1QjRCLCAweDAzXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMHg0NUY5LCAweDA0XSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMHg0MENFLCAweDA1XSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMHg0Rjk3LCAweDA2XSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMHg0QUEwLCAweDA3XSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMHg3N0M0LCAweDA4XSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMHg3MkYzLCAweDA5XSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMHg3REFBLCAweDBBXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMHg3ODlELCAweDBCXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMHg2NjJGLCAweDBDXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMHg2MzE4LCAweDBEXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMHg2QzQxLCAweDBFXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMHg2OTc2LCAweDBGXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMHgxNjg5LCAweDEwXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMHgxM0JFLCAweDExXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMHgxQ0U3LCAweDEyXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMHgxOUQwLCAweDEzXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMHgwNzYyLCAweDE0XSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMHgwMjU1LCAweDE1XSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMHgwRDBDLCAweDE2XSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMHgwODNCLCAweDE3XSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMHgzNTVGLCAweDE4XSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMHgzMDY4LCAweDE5XSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMHgzRjMxLCAweDFBXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMHgzQTA2LCAweDFCXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMHgyNEI0LCAweDFDXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMHgyMTgzLCAweDFEXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMHgyRURBLCAweDFFXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMHgyQkVELCAweDFGXSksXG4gICAgXTtcblxuICAgIC8qKlxuICAgICAqIDxwPkVuY2Fwc3VsYXRlcyBhIHNldCBvZiBlcnJvci1jb3JyZWN0aW9uIGJsb2NrcyBpbiBvbmUgc3ltYm9sIHZlcnNpb24uIE1vc3QgdmVyc2lvbnMgd2lsbFxuICAgICAqIHVzZSBibG9ja3Mgb2YgZGlmZmVyaW5nIHNpemVzIHdpdGhpbiBvbmUgdmVyc2lvbiwgc28sIHRoaXMgZW5jYXBzdWxhdGVzIHRoZSBwYXJhbWV0ZXJzIGZvclxuICAgICAqIGVhY2ggc2V0IG9mIGJsb2Nrcy4gSXQgYWxzbyBob2xkcyB0aGUgbnVtYmVyIG9mIGVycm9yLWNvcnJlY3Rpb24gY29kZXdvcmRzIHBlciBibG9jayBzaW5jZSBpdFxuICAgICAqIHdpbGwgYmUgdGhlIHNhbWUgYWNyb3NzIGFsbCBibG9ja3Mgd2l0aGluIG9uZSB2ZXJzaW9uLjwvcD5cbiAgICAgKi9cbiAgICBjbGFzcyBFQ0Jsb2NrcyQxIHtcbiAgICAgICAgY29uc3RydWN0b3IoZWNDb2Rld29yZHNQZXJCbG9jayAvKmludCovLCAuLi5lY0Jsb2Nrcykge1xuICAgICAgICAgICAgdGhpcy5lY0NvZGV3b3Jkc1BlckJsb2NrID0gZWNDb2Rld29yZHNQZXJCbG9jaztcbiAgICAgICAgICAgIHRoaXMuZWNCbG9ja3MgPSBlY0Jsb2NrcztcbiAgICAgICAgfVxuICAgICAgICBnZXRFQ0NvZGV3b3Jkc1BlckJsb2NrKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWNDb2Rld29yZHNQZXJCbG9jaztcbiAgICAgICAgfVxuICAgICAgICBnZXROdW1CbG9ja3MoKSB7XG4gICAgICAgICAgICBsZXQgdG90YWwgPSAwO1xuICAgICAgICAgICAgY29uc3QgZWNCbG9ja3MgPSB0aGlzLmVjQmxvY2tzO1xuICAgICAgICAgICAgZm9yIChjb25zdCBlY0Jsb2NrIG9mIGVjQmxvY2tzKSB7XG4gICAgICAgICAgICAgICAgdG90YWwgKz0gZWNCbG9jay5nZXRDb3VudCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRvdGFsO1xuICAgICAgICB9XG4gICAgICAgIGdldFRvdGFsRUNDb2Rld29yZHMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lY0NvZGV3b3Jkc1BlckJsb2NrICogdGhpcy5nZXROdW1CbG9ja3MoKTtcbiAgICAgICAgfVxuICAgICAgICBnZXRFQ0Jsb2NrcygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVjQmxvY2tzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogPHA+RW5jYXBzdWxhdGVzIHRoZSBwYXJhbWV0ZXJzIGZvciBvbmUgZXJyb3ItY29ycmVjdGlvbiBibG9jayBpbiBvbmUgc3ltYm9sIHZlcnNpb24uXG4gICAgICogVGhpcyBpbmNsdWRlcyB0aGUgbnVtYmVyIG9mIGRhdGEgY29kZXdvcmRzLCBhbmQgdGhlIG51bWJlciBvZiB0aW1lcyBhIGJsb2NrIHdpdGggdGhlc2VcbiAgICAgKiBwYXJhbWV0ZXJzIGlzIHVzZWQgY29uc2VjdXRpdmVseSBpbiB0aGUgUVIgY29kZSB2ZXJzaW9uJ3MgZm9ybWF0LjwvcD5cbiAgICAgKi9cbiAgICBjbGFzcyBFQ0IkMSB7XG4gICAgICAgIGNvbnN0cnVjdG9yKGNvdW50IC8qaW50Ki8sIGRhdGFDb2Rld29yZHMgLyppbnQqLykge1xuICAgICAgICAgICAgdGhpcy5jb3VudCA9IGNvdW50O1xuICAgICAgICAgICAgdGhpcy5kYXRhQ29kZXdvcmRzID0gZGF0YUNvZGV3b3JkcztcbiAgICAgICAgfVxuICAgICAgICBnZXRDb3VudCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvdW50O1xuICAgICAgICB9XG4gICAgICAgIGdldERhdGFDb2Rld29yZHMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhQ29kZXdvcmRzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBDb3B5cmlnaHQgMjAwNyBaWGluZyBhdXRob3JzXG4gICAgICpcbiAgICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgICAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgICAgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgICAgKlxuICAgICAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gICAgICpcbiAgICAgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICAgICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgICAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICAgICAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgICAgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBTZWUgSVNPIDE4MDA0OjIwMDYgQW5uZXggRFxuICAgICAqXG4gICAgICogQGF1dGhvciBTZWFuIE93ZW5cbiAgICAgKi9cbiAgICBjbGFzcyBWZXJzaW9uJDEge1xuICAgICAgICBjb25zdHJ1Y3Rvcih2ZXJzaW9uTnVtYmVyIC8qaW50Ki8sIGFsaWdubWVudFBhdHRlcm5DZW50ZXJzLCAuLi5lY0Jsb2Nrcykge1xuICAgICAgICAgICAgdGhpcy52ZXJzaW9uTnVtYmVyID0gdmVyc2lvbk51bWJlcjtcbiAgICAgICAgICAgIHRoaXMuYWxpZ25tZW50UGF0dGVybkNlbnRlcnMgPSBhbGlnbm1lbnRQYXR0ZXJuQ2VudGVycztcbiAgICAgICAgICAgIHRoaXMuZWNCbG9ja3MgPSBlY0Jsb2NrcztcbiAgICAgICAgICAgIGxldCB0b3RhbCA9IDA7XG4gICAgICAgICAgICBjb25zdCBlY0NvZGV3b3JkcyA9IGVjQmxvY2tzWzBdLmdldEVDQ29kZXdvcmRzUGVyQmxvY2soKTtcbiAgICAgICAgICAgIGNvbnN0IGVjYkFycmF5ID0gZWNCbG9ja3NbMF0uZ2V0RUNCbG9ja3MoKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZWNCbG9jayBvZiBlY2JBcnJheSkge1xuICAgICAgICAgICAgICAgIHRvdGFsICs9IGVjQmxvY2suZ2V0Q291bnQoKSAqIChlY0Jsb2NrLmdldERhdGFDb2Rld29yZHMoKSArIGVjQ29kZXdvcmRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudG90YWxDb2Rld29yZHMgPSB0b3RhbDtcbiAgICAgICAgfVxuICAgICAgICBnZXRWZXJzaW9uTnVtYmVyKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmVyc2lvbk51bWJlcjtcbiAgICAgICAgfVxuICAgICAgICBnZXRBbGlnbm1lbnRQYXR0ZXJuQ2VudGVycygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFsaWdubWVudFBhdHRlcm5DZW50ZXJzO1xuICAgICAgICB9XG4gICAgICAgIGdldFRvdGFsQ29kZXdvcmRzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG90YWxDb2Rld29yZHM7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0RGltZW5zaW9uRm9yVmVyc2lvbigpIHtcbiAgICAgICAgICAgIHJldHVybiAxNyArIDQgKiB0aGlzLnZlcnNpb25OdW1iZXI7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0RUNCbG9ja3NGb3JMZXZlbChlY0xldmVsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lY0Jsb2Nrc1tlY0xldmVsLmdldFZhbHVlKCldO1xuICAgICAgICAgICAgLy8gVFlQRVNDUklQVFBPUlQ6IG9yaWdpbmFsIHdhcyB1c2luZyBvcmRpbmFsLCBhbmQgdXNpbmcgdGhlIG9yZGVyIG9mIGxldmVscyBhcyBkZWZpbmVkIGluIEVycm9yQ29ycmVjdGlvbkxldmVsIGVudW0gKExNUUgpXG4gICAgICAgICAgICAvLyBJIHdpbGwgdXNlIHRoZSBkaXJlY3QgdmFsdWUgZnJvbSBFcnJvckNvcnJlY3Rpb25MZXZlbFZhbHVlcyBlbnVtIHdoaWNoIGluIHR5cGVzY3JpcHQgZ29lcyB0byBhIG51bWJlclxuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiA8cD5EZWR1Y2VzIHZlcnNpb24gaW5mb3JtYXRpb24gcHVyZWx5IGZyb20gUVIgQ29kZSBkaW1lbnNpb25zLjwvcD5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGRpbWVuc2lvbiBkaW1lbnNpb24gaW4gbW9kdWxlc1xuICAgICAgICAgKiBAcmV0dXJuIFZlcnNpb24gZm9yIGEgUVIgQ29kZSBvZiB0aGF0IGRpbWVuc2lvblxuICAgICAgICAgKiBAdGhyb3dzIEZvcm1hdEV4Y2VwdGlvbiBpZiBkaW1lbnNpb24gaXMgbm90IDEgbW9kIDRcbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBnZXRQcm92aXNpb25hbFZlcnNpb25Gb3JEaW1lbnNpb24oZGltZW5zaW9uIC8qaW50Ki8pIHtcbiAgICAgICAgICAgIGlmIChkaW1lbnNpb24gJSA0ICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRWZXJzaW9uRm9yTnVtYmVyKChkaW1lbnNpb24gLSAxNykgLyA0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChpZ25vcmVkIC8qOiBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24qLykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgZ2V0VmVyc2lvbkZvck51bWJlcih2ZXJzaW9uTnVtYmVyIC8qaW50Ki8pIHtcbiAgICAgICAgICAgIGlmICh2ZXJzaW9uTnVtYmVyIDwgMSB8fCB2ZXJzaW9uTnVtYmVyID4gNDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gVmVyc2lvbiQxLlZFUlNJT05TW3ZlcnNpb25OdW1iZXIgLSAxXTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgZGVjb2RlVmVyc2lvbkluZm9ybWF0aW9uKHZlcnNpb25CaXRzIC8qaW50Ki8pIHtcbiAgICAgICAgICAgIGxldCBiZXN0RGlmZmVyZW5jZSA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSO1xuICAgICAgICAgICAgbGV0IGJlc3RWZXJzaW9uID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgVmVyc2lvbiQxLlZFUlNJT05fREVDT0RFX0lORk8ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXRWZXJzaW9uID0gVmVyc2lvbiQxLlZFUlNJT05fREVDT0RFX0lORk9baV07XG4gICAgICAgICAgICAgICAgLy8gRG8gdGhlIHZlcnNpb24gaW5mbyBiaXRzIG1hdGNoIGV4YWN0bHk/IGRvbmUuXG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldFZlcnNpb24gPT09IHZlcnNpb25CaXRzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBWZXJzaW9uJDEuZ2V0VmVyc2lvbkZvck51bWJlcihpICsgNyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSBzZWUgaWYgdGhpcyBpcyB0aGUgY2xvc2VzdCB0byBhIHJlYWwgdmVyc2lvbiBpbmZvIGJpdCBzdHJpbmdcbiAgICAgICAgICAgICAgICAvLyB3ZSBoYXZlIHNlZW4gc28gZmFyXG4gICAgICAgICAgICAgICAgY29uc3QgYml0c0RpZmZlcmVuY2UgPSBGb3JtYXRJbmZvcm1hdGlvbi5udW1CaXRzRGlmZmVyaW5nKHZlcnNpb25CaXRzLCB0YXJnZXRWZXJzaW9uKTtcbiAgICAgICAgICAgICAgICBpZiAoYml0c0RpZmZlcmVuY2UgPCBiZXN0RGlmZmVyZW5jZSkge1xuICAgICAgICAgICAgICAgICAgICBiZXN0VmVyc2lvbiA9IGkgKyA3O1xuICAgICAgICAgICAgICAgICAgICBiZXN0RGlmZmVyZW5jZSA9IGJpdHNEaWZmZXJlbmNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFdlIGNhbiB0b2xlcmF0ZSB1cCB0byAzIGJpdHMgb2YgZXJyb3Igc2luY2Ugbm8gdHdvIHZlcnNpb24gaW5mbyBjb2Rld29yZHMgd2lsbFxuICAgICAgICAgICAgLy8gZGlmZmVyIGluIGxlc3MgdGhhbiA4IGJpdHMuXG4gICAgICAgICAgICBpZiAoYmVzdERpZmZlcmVuY2UgPD0gMykge1xuICAgICAgICAgICAgICAgIHJldHVybiBWZXJzaW9uJDEuZ2V0VmVyc2lvbkZvck51bWJlcihiZXN0VmVyc2lvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiB3ZSBkaWRuJ3QgZmluZCBhIGNsb3NlIGVub3VnaCBtYXRjaCwgZmFpbFxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNlZSBJU08gMTgwMDQ6MjAwNiBBbm5leCBFXG4gICAgICAgICAqL1xuICAgICAgICBidWlsZEZ1bmN0aW9uUGF0dGVybigpIHtcbiAgICAgICAgICAgIGNvbnN0IGRpbWVuc2lvbiA9IHRoaXMuZ2V0RGltZW5zaW9uRm9yVmVyc2lvbigpO1xuICAgICAgICAgICAgY29uc3QgYml0TWF0cml4ID0gbmV3IEJpdE1hdHJpeChkaW1lbnNpb24pO1xuICAgICAgICAgICAgLy8gVG9wIGxlZnQgZmluZGVyIHBhdHRlcm4gKyBzZXBhcmF0b3IgKyBmb3JtYXRcbiAgICAgICAgICAgIGJpdE1hdHJpeC5zZXRSZWdpb24oMCwgMCwgOSwgOSk7XG4gICAgICAgICAgICAvLyBUb3AgcmlnaHQgZmluZGVyIHBhdHRlcm4gKyBzZXBhcmF0b3IgKyBmb3JtYXRcbiAgICAgICAgICAgIGJpdE1hdHJpeC5zZXRSZWdpb24oZGltZW5zaW9uIC0gOCwgMCwgOCwgOSk7XG4gICAgICAgICAgICAvLyBCb3R0b20gbGVmdCBmaW5kZXIgcGF0dGVybiArIHNlcGFyYXRvciArIGZvcm1hdFxuICAgICAgICAgICAgYml0TWF0cml4LnNldFJlZ2lvbigwLCBkaW1lbnNpb24gLSA4LCA5LCA4KTtcbiAgICAgICAgICAgIC8vIEFsaWdubWVudCBwYXR0ZXJuc1xuICAgICAgICAgICAgY29uc3QgbWF4ID0gdGhpcy5hbGlnbm1lbnRQYXR0ZXJuQ2VudGVycy5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IG1heDsgeCsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaSA9IHRoaXMuYWxpZ25tZW50UGF0dGVybkNlbnRlcnNbeF0gLSAyO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgbWF4OyB5KyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCh4ID09PSAwICYmICh5ID09PSAwIHx8IHkgPT09IG1heCAtIDEpKSB8fCAoeCA9PT0gbWF4IC0gMSAmJiB5ID09PSAwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm8gYWxpZ25tZW50IHBhdHRlcm5zIG5lYXIgdGhlIHRocmVlIGZpbmRlciBwYXR0ZXJuc1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYml0TWF0cml4LnNldFJlZ2lvbih0aGlzLmFsaWdubWVudFBhdHRlcm5DZW50ZXJzW3ldIC0gMiwgaSwgNSwgNSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVmVydGljYWwgdGltaW5nIHBhdHRlcm5cbiAgICAgICAgICAgIGJpdE1hdHJpeC5zZXRSZWdpb24oNiwgOSwgMSwgZGltZW5zaW9uIC0gMTcpO1xuICAgICAgICAgICAgLy8gSG9yaXpvbnRhbCB0aW1pbmcgcGF0dGVyblxuICAgICAgICAgICAgYml0TWF0cml4LnNldFJlZ2lvbig5LCA2LCBkaW1lbnNpb24gLSAxNywgMSk7XG4gICAgICAgICAgICBpZiAodGhpcy52ZXJzaW9uTnVtYmVyID4gNikge1xuICAgICAgICAgICAgICAgIC8vIFZlcnNpb24gaW5mbywgdG9wIHJpZ2h0XG4gICAgICAgICAgICAgICAgYml0TWF0cml4LnNldFJlZ2lvbihkaW1lbnNpb24gLSAxMSwgMCwgMywgNik7XG4gICAgICAgICAgICAgICAgLy8gVmVyc2lvbiBpbmZvLCBib3R0b20gbGVmdFxuICAgICAgICAgICAgICAgIGJpdE1hdHJpeC5zZXRSZWdpb24oMCwgZGltZW5zaW9uIC0gMTEsIDYsIDMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGJpdE1hdHJpeDtcbiAgICAgICAgfVxuICAgICAgICAvKkBPdmVycmlkZSovXG4gICAgICAgIHRvU3RyaW5nKCkge1xuICAgICAgICAgICAgcmV0dXJuICcnICsgdGhpcy52ZXJzaW9uTnVtYmVyO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAgICogU2VlIElTTyAxODAwNDoyMDA2IEFubmV4IEQuXG4gICAgICAgKiBFbGVtZW50IGkgcmVwcmVzZW50cyB0aGUgcmF3IHZlcnNpb24gYml0cyB0aGF0IHNwZWNpZnkgdmVyc2lvbiBpICsgN1xuICAgICAgICovXG4gICAgVmVyc2lvbiQxLlZFUlNJT05fREVDT0RFX0lORk8gPSBJbnQzMkFycmF5LmZyb20oW1xuICAgICAgICAweDA3Qzk0LCAweDA4NUJDLCAweDA5QTk5LCAweDBBNEQzLCAweDBCQkY2LFxuICAgICAgICAweDBDNzYyLCAweDBEODQ3LCAweDBFNjBELCAweDBGOTI4LCAweDEwQjc4LFxuICAgICAgICAweDExNDVELCAweDEyQTE3LCAweDEzNTMyLCAweDE0OUE2LCAweDE1NjgzLFxuICAgICAgICAweDE2OEM5LCAweDE3N0VDLCAweDE4RUM0LCAweDE5MUUxLCAweDFBRkFCLFxuICAgICAgICAweDFCMDhFLCAweDFDQzFBLCAweDFEMzNGLCAweDFFRDc1LCAweDFGMjUwLFxuICAgICAgICAweDIwOUQ1LCAweDIxNkYwLCAweDIyOEJBLCAweDIzNzlGLCAweDI0QjBCLFxuICAgICAgICAweDI1NDJFLCAweDI2QTY0LCAweDI3NTQxLCAweDI4QzY5XG4gICAgXSk7XG4gICAgLyoqXG4gICAgICAgKiBTZWUgSVNPIDE4MDA0OjIwMDYgNi41LjEgVGFibGUgOVxuICAgICAgICovXG4gICAgVmVyc2lvbiQxLlZFUlNJT05TID0gW1xuICAgICAgICBuZXcgVmVyc2lvbiQxKDEsIG5ldyBJbnQzMkFycmF5KDApLCBuZXcgRUNCbG9ja3MkMSg3LCBuZXcgRUNCJDEoMSwgMTkpKSwgbmV3IEVDQmxvY2tzJDEoMTAsIG5ldyBFQ0IkMSgxLCAxNikpLCBuZXcgRUNCbG9ja3MkMSgxMywgbmV3IEVDQiQxKDEsIDEzKSksIG5ldyBFQ0Jsb2NrcyQxKDE3LCBuZXcgRUNCJDEoMSwgOSkpKSxcbiAgICAgICAgbmV3IFZlcnNpb24kMSgyLCBJbnQzMkFycmF5LmZyb20oWzYsIDE4XSksIG5ldyBFQ0Jsb2NrcyQxKDEwLCBuZXcgRUNCJDEoMSwgMzQpKSwgbmV3IEVDQmxvY2tzJDEoMTYsIG5ldyBFQ0IkMSgxLCAyOCkpLCBuZXcgRUNCbG9ja3MkMSgyMiwgbmV3IEVDQiQxKDEsIDIyKSksIG5ldyBFQ0Jsb2NrcyQxKDI4LCBuZXcgRUNCJDEoMSwgMTYpKSksXG4gICAgICAgIG5ldyBWZXJzaW9uJDEoMywgSW50MzJBcnJheS5mcm9tKFs2LCAyMl0pLCBuZXcgRUNCbG9ja3MkMSgxNSwgbmV3IEVDQiQxKDEsIDU1KSksIG5ldyBFQ0Jsb2NrcyQxKDI2LCBuZXcgRUNCJDEoMSwgNDQpKSwgbmV3IEVDQmxvY2tzJDEoMTgsIG5ldyBFQ0IkMSgyLCAxNykpLCBuZXcgRUNCbG9ja3MkMSgyMiwgbmV3IEVDQiQxKDIsIDEzKSkpLFxuICAgICAgICBuZXcgVmVyc2lvbiQxKDQsIEludDMyQXJyYXkuZnJvbShbNiwgMjZdKSwgbmV3IEVDQmxvY2tzJDEoMjAsIG5ldyBFQ0IkMSgxLCA4MCkpLCBuZXcgRUNCbG9ja3MkMSgxOCwgbmV3IEVDQiQxKDIsIDMyKSksIG5ldyBFQ0Jsb2NrcyQxKDI2LCBuZXcgRUNCJDEoMiwgMjQpKSwgbmV3IEVDQmxvY2tzJDEoMTYsIG5ldyBFQ0IkMSg0LCA5KSkpLFxuICAgICAgICBuZXcgVmVyc2lvbiQxKDUsIEludDMyQXJyYXkuZnJvbShbNiwgMzBdKSwgbmV3IEVDQmxvY2tzJDEoMjYsIG5ldyBFQ0IkMSgxLCAxMDgpKSwgbmV3IEVDQmxvY2tzJDEoMjQsIG5ldyBFQ0IkMSgyLCA0MykpLCBuZXcgRUNCbG9ja3MkMSgxOCwgbmV3IEVDQiQxKDIsIDE1KSwgbmV3IEVDQiQxKDIsIDE2KSksIG5ldyBFQ0Jsb2NrcyQxKDIyLCBuZXcgRUNCJDEoMiwgMTEpLCBuZXcgRUNCJDEoMiwgMTIpKSksXG4gICAgICAgIG5ldyBWZXJzaW9uJDEoNiwgSW50MzJBcnJheS5mcm9tKFs2LCAzNF0pLCBuZXcgRUNCbG9ja3MkMSgxOCwgbmV3IEVDQiQxKDIsIDY4KSksIG5ldyBFQ0Jsb2NrcyQxKDE2LCBuZXcgRUNCJDEoNCwgMjcpKSwgbmV3IEVDQmxvY2tzJDEoMjQsIG5ldyBFQ0IkMSg0LCAxOSkpLCBuZXcgRUNCbG9ja3MkMSgyOCwgbmV3IEVDQiQxKDQsIDE1KSkpLFxuICAgICAgICBuZXcgVmVyc2lvbiQxKDcsIEludDMyQXJyYXkuZnJvbShbNiwgMjIsIDM4XSksIG5ldyBFQ0Jsb2NrcyQxKDIwLCBuZXcgRUNCJDEoMiwgNzgpKSwgbmV3IEVDQmxvY2tzJDEoMTgsIG5ldyBFQ0IkMSg0LCAzMSkpLCBuZXcgRUNCbG9ja3MkMSgxOCwgbmV3IEVDQiQxKDIsIDE0KSwgbmV3IEVDQiQxKDQsIDE1KSksIG5ldyBFQ0Jsb2NrcyQxKDI2LCBuZXcgRUNCJDEoNCwgMTMpLCBuZXcgRUNCJDEoMSwgMTQpKSksXG4gICAgICAgIG5ldyBWZXJzaW9uJDEoOCwgSW50MzJBcnJheS5mcm9tKFs2LCAyNCwgNDJdKSwgbmV3IEVDQmxvY2tzJDEoMjQsIG5ldyBFQ0IkMSgyLCA5NykpLCBuZXcgRUNCbG9ja3MkMSgyMiwgbmV3IEVDQiQxKDIsIDM4KSwgbmV3IEVDQiQxKDIsIDM5KSksIG5ldyBFQ0Jsb2NrcyQxKDIyLCBuZXcgRUNCJDEoNCwgMTgpLCBuZXcgRUNCJDEoMiwgMTkpKSwgbmV3IEVDQmxvY2tzJDEoMjYsIG5ldyBFQ0IkMSg0LCAxNCksIG5ldyBFQ0IkMSgyLCAxNSkpKSxcbiAgICAgICAgbmV3IFZlcnNpb24kMSg5LCBJbnQzMkFycmF5LmZyb20oWzYsIDI2LCA0Nl0pLCBuZXcgRUNCbG9ja3MkMSgzMCwgbmV3IEVDQiQxKDIsIDExNikpLCBuZXcgRUNCbG9ja3MkMSgyMiwgbmV3IEVDQiQxKDMsIDM2KSwgbmV3IEVDQiQxKDIsIDM3KSksIG5ldyBFQ0Jsb2NrcyQxKDIwLCBuZXcgRUNCJDEoNCwgMTYpLCBuZXcgRUNCJDEoNCwgMTcpKSwgbmV3IEVDQmxvY2tzJDEoMjQsIG5ldyBFQ0IkMSg0LCAxMiksIG5ldyBFQ0IkMSg0LCAxMykpKSxcbiAgICAgICAgbmV3IFZlcnNpb24kMSgxMCwgSW50MzJBcnJheS5mcm9tKFs2LCAyOCwgNTBdKSwgbmV3IEVDQmxvY2tzJDEoMTgsIG5ldyBFQ0IkMSgyLCA2OCksIG5ldyBFQ0IkMSgyLCA2OSkpLCBuZXcgRUNCbG9ja3MkMSgyNiwgbmV3IEVDQiQxKDQsIDQzKSwgbmV3IEVDQiQxKDEsIDQ0KSksIG5ldyBFQ0Jsb2NrcyQxKDI0LCBuZXcgRUNCJDEoNiwgMTkpLCBuZXcgRUNCJDEoMiwgMjApKSwgbmV3IEVDQmxvY2tzJDEoMjgsIG5ldyBFQ0IkMSg2LCAxNSksIG5ldyBFQ0IkMSgyLCAxNikpKSxcbiAgICAgICAgbmV3IFZlcnNpb24kMSgxMSwgSW50MzJBcnJheS5mcm9tKFs2LCAzMCwgNTRdKSwgbmV3IEVDQmxvY2tzJDEoMjAsIG5ldyBFQ0IkMSg0LCA4MSkpLCBuZXcgRUNCbG9ja3MkMSgzMCwgbmV3IEVDQiQxKDEsIDUwKSwgbmV3IEVDQiQxKDQsIDUxKSksIG5ldyBFQ0Jsb2NrcyQxKDI4LCBuZXcgRUNCJDEoNCwgMjIpLCBuZXcgRUNCJDEoNCwgMjMpKSwgbmV3IEVDQmxvY2tzJDEoMjQsIG5ldyBFQ0IkMSgzLCAxMiksIG5ldyBFQ0IkMSg4LCAxMykpKSxcbiAgICAgICAgbmV3IFZlcnNpb24kMSgxMiwgSW50MzJBcnJheS5mcm9tKFs2LCAzMiwgNThdKSwgbmV3IEVDQmxvY2tzJDEoMjQsIG5ldyBFQ0IkMSgyLCA5MiksIG5ldyBFQ0IkMSgyLCA5MykpLCBuZXcgRUNCbG9ja3MkMSgyMiwgbmV3IEVDQiQxKDYsIDM2KSwgbmV3IEVDQiQxKDIsIDM3KSksIG5ldyBFQ0Jsb2NrcyQxKDI2LCBuZXcgRUNCJDEoNCwgMjApLCBuZXcgRUNCJDEoNiwgMjEpKSwgbmV3IEVDQmxvY2tzJDEoMjgsIG5ldyBFQ0IkMSg3LCAxNCksIG5ldyBFQ0IkMSg0LCAxNSkpKSxcbiAgICAgICAgbmV3IFZlcnNpb24kMSgxMywgSW50MzJBcnJheS5mcm9tKFs2LCAzNCwgNjJdKSwgbmV3IEVDQmxvY2tzJDEoMjYsIG5ldyBFQ0IkMSg0LCAxMDcpKSwgbmV3IEVDQmxvY2tzJDEoMjIsIG5ldyBFQ0IkMSg4LCAzNyksIG5ldyBFQ0IkMSgxLCAzOCkpLCBuZXcgRUNCbG9ja3MkMSgyNCwgbmV3IEVDQiQxKDgsIDIwKSwgbmV3IEVDQiQxKDQsIDIxKSksIG5ldyBFQ0Jsb2NrcyQxKDIyLCBuZXcgRUNCJDEoMTIsIDExKSwgbmV3IEVDQiQxKDQsIDEyKSkpLFxuICAgICAgICBuZXcgVmVyc2lvbiQxKDE0LCBJbnQzMkFycmF5LmZyb20oWzYsIDI2LCA0NiwgNjZdKSwgbmV3IEVDQmxvY2tzJDEoMzAsIG5ldyBFQ0IkMSgzLCAxMTUpLCBuZXcgRUNCJDEoMSwgMTE2KSksIG5ldyBFQ0Jsb2NrcyQxKDI0LCBuZXcgRUNCJDEoNCwgNDApLCBuZXcgRUNCJDEoNSwgNDEpKSwgbmV3IEVDQmxvY2tzJDEoMjAsIG5ldyBFQ0IkMSgxMSwgMTYpLCBuZXcgRUNCJDEoNSwgMTcpKSwgbmV3IEVDQmxvY2tzJDEoMjQsIG5ldyBFQ0IkMSgxMSwgMTIpLCBuZXcgRUNCJDEoNSwgMTMpKSksXG4gICAgICAgIG5ldyBWZXJzaW9uJDEoMTUsIEludDMyQXJyYXkuZnJvbShbNiwgMjYsIDQ4LCA3MF0pLCBuZXcgRUNCbG9ja3MkMSgyMiwgbmV3IEVDQiQxKDUsIDg3KSwgbmV3IEVDQiQxKDEsIDg4KSksIG5ldyBFQ0Jsb2NrcyQxKDI0LCBuZXcgRUNCJDEoNSwgNDEpLCBuZXcgRUNCJDEoNSwgNDIpKSwgbmV3IEVDQmxvY2tzJDEoMzAsIG5ldyBFQ0IkMSg1LCAyNCksIG5ldyBFQ0IkMSg3LCAyNSkpLCBuZXcgRUNCbG9ja3MkMSgyNCwgbmV3IEVDQiQxKDExLCAxMiksIG5ldyBFQ0IkMSg3LCAxMykpKSxcbiAgICAgICAgbmV3IFZlcnNpb24kMSgxNiwgSW50MzJBcnJheS5mcm9tKFs2LCAyNiwgNTAsIDc0XSksIG5ldyBFQ0Jsb2NrcyQxKDI0LCBuZXcgRUNCJDEoNSwgOTgpLCBuZXcgRUNCJDEoMSwgOTkpKSwgbmV3IEVDQmxvY2tzJDEoMjgsIG5ldyBFQ0IkMSg3LCA0NSksIG5ldyBFQ0IkMSgzLCA0NikpLCBuZXcgRUNCbG9ja3MkMSgyNCwgbmV3IEVDQiQxKDE1LCAxOSksIG5ldyBFQ0IkMSgyLCAyMCkpLCBuZXcgRUNCbG9ja3MkMSgzMCwgbmV3IEVDQiQxKDMsIDE1KSwgbmV3IEVDQiQxKDEzLCAxNikpKSxcbiAgICAgICAgbmV3IFZlcnNpb24kMSgxNywgSW50MzJBcnJheS5mcm9tKFs2LCAzMCwgNTQsIDc4XSksIG5ldyBFQ0Jsb2NrcyQxKDI4LCBuZXcgRUNCJDEoMSwgMTA3KSwgbmV3IEVDQiQxKDUsIDEwOCkpLCBuZXcgRUNCbG9ja3MkMSgyOCwgbmV3IEVDQiQxKDEwLCA0NiksIG5ldyBFQ0IkMSgxLCA0NykpLCBuZXcgRUNCbG9ja3MkMSgyOCwgbmV3IEVDQiQxKDEsIDIyKSwgbmV3IEVDQiQxKDE1LCAyMykpLCBuZXcgRUNCbG9ja3MkMSgyOCwgbmV3IEVDQiQxKDIsIDE0KSwgbmV3IEVDQiQxKDE3LCAxNSkpKSxcbiAgICAgICAgbmV3IFZlcnNpb24kMSgxOCwgSW50MzJBcnJheS5mcm9tKFs2LCAzMCwgNTYsIDgyXSksIG5ldyBFQ0Jsb2NrcyQxKDMwLCBuZXcgRUNCJDEoNSwgMTIwKSwgbmV3IEVDQiQxKDEsIDEyMSkpLCBuZXcgRUNCbG9ja3MkMSgyNiwgbmV3IEVDQiQxKDksIDQzKSwgbmV3IEVDQiQxKDQsIDQ0KSksIG5ldyBFQ0Jsb2NrcyQxKDI4LCBuZXcgRUNCJDEoMTcsIDIyKSwgbmV3IEVDQiQxKDEsIDIzKSksIG5ldyBFQ0Jsb2NrcyQxKDI4LCBuZXcgRUNCJDEoMiwgMTQpLCBuZXcgRUNCJDEoMTksIDE1KSkpLFxuICAgICAgICBuZXcgVmVyc2lvbiQxKDE5LCBJbnQzMkFycmF5LmZyb20oWzYsIDMwLCA1OCwgODZdKSwgbmV3IEVDQmxvY2tzJDEoMjgsIG5ldyBFQ0IkMSgzLCAxMTMpLCBuZXcgRUNCJDEoNCwgMTE0KSksIG5ldyBFQ0Jsb2NrcyQxKDI2LCBuZXcgRUNCJDEoMywgNDQpLCBuZXcgRUNCJDEoMTEsIDQ1KSksIG5ldyBFQ0Jsb2NrcyQxKDI2LCBuZXcgRUNCJDEoMTcsIDIxKSwgbmV3IEVDQiQxKDQsIDIyKSksIG5ldyBFQ0Jsb2NrcyQxKDI2LCBuZXcgRUNCJDEoOSwgMTMpLCBuZXcgRUNCJDEoMTYsIDE0KSkpLFxuICAgICAgICBuZXcgVmVyc2lvbiQxKDIwLCBJbnQzMkFycmF5LmZyb20oWzYsIDM0LCA2MiwgOTBdKSwgbmV3IEVDQmxvY2tzJDEoMjgsIG5ldyBFQ0IkMSgzLCAxMDcpLCBuZXcgRUNCJDEoNSwgMTA4KSksIG5ldyBFQ0Jsb2NrcyQxKDI2LCBuZXcgRUNCJDEoMywgNDEpLCBuZXcgRUNCJDEoMTMsIDQyKSksIG5ldyBFQ0Jsb2NrcyQxKDMwLCBuZXcgRUNCJDEoMTUsIDI0KSwgbmV3IEVDQiQxKDUsIDI1KSksIG5ldyBFQ0Jsb2NrcyQxKDI4LCBuZXcgRUNCJDEoMTUsIDE1KSwgbmV3IEVDQiQxKDEwLCAxNikpKSxcbiAgICAgICAgbmV3IFZlcnNpb24kMSgyMSwgSW50MzJBcnJheS5mcm9tKFs2LCAyOCwgNTAsIDcyLCA5NF0pLCBuZXcgRUNCbG9ja3MkMSgyOCwgbmV3IEVDQiQxKDQsIDExNiksIG5ldyBFQ0IkMSg0LCAxMTcpKSwgbmV3IEVDQmxvY2tzJDEoMjYsIG5ldyBFQ0IkMSgxNywgNDIpKSwgbmV3IEVDQmxvY2tzJDEoMjgsIG5ldyBFQ0IkMSgxNywgMjIpLCBuZXcgRUNCJDEoNiwgMjMpKSwgbmV3IEVDQmxvY2tzJDEoMzAsIG5ldyBFQ0IkMSgxOSwgMTYpLCBuZXcgRUNCJDEoNiwgMTcpKSksXG4gICAgICAgIG5ldyBWZXJzaW9uJDEoMjIsIEludDMyQXJyYXkuZnJvbShbNiwgMjYsIDUwLCA3NCwgOThdKSwgbmV3IEVDQmxvY2tzJDEoMjgsIG5ldyBFQ0IkMSgyLCAxMTEpLCBuZXcgRUNCJDEoNywgMTEyKSksIG5ldyBFQ0Jsb2NrcyQxKDI4LCBuZXcgRUNCJDEoMTcsIDQ2KSksIG5ldyBFQ0Jsb2NrcyQxKDMwLCBuZXcgRUNCJDEoNywgMjQpLCBuZXcgRUNCJDEoMTYsIDI1KSksIG5ldyBFQ0Jsb2NrcyQxKDI0LCBuZXcgRUNCJDEoMzQsIDEzKSkpLFxuICAgICAgICBuZXcgVmVyc2lvbiQxKDIzLCBJbnQzMkFycmF5LmZyb20oWzYsIDMwLCA1NCwgNzgsIDEwMl0pLCBuZXcgRUNCbG9ja3MkMSgzMCwgbmV3IEVDQiQxKDQsIDEyMSksIG5ldyBFQ0IkMSg1LCAxMjIpKSwgbmV3IEVDQmxvY2tzJDEoMjgsIG5ldyBFQ0IkMSg0LCA0NyksIG5ldyBFQ0IkMSgxNCwgNDgpKSwgbmV3IEVDQmxvY2tzJDEoMzAsIG5ldyBFQ0IkMSgxMSwgMjQpLCBuZXcgRUNCJDEoMTQsIDI1KSksIG5ldyBFQ0Jsb2NrcyQxKDMwLCBuZXcgRUNCJDEoMTYsIDE1KSwgbmV3IEVDQiQxKDE0LCAxNikpKSxcbiAgICAgICAgbmV3IFZlcnNpb24kMSgyNCwgSW50MzJBcnJheS5mcm9tKFs2LCAyOCwgNTQsIDgwLCAxMDZdKSwgbmV3IEVDQmxvY2tzJDEoMzAsIG5ldyBFQ0IkMSg2LCAxMTcpLCBuZXcgRUNCJDEoNCwgMTE4KSksIG5ldyBFQ0Jsb2NrcyQxKDI4LCBuZXcgRUNCJDEoNiwgNDUpLCBuZXcgRUNCJDEoMTQsIDQ2KSksIG5ldyBFQ0Jsb2NrcyQxKDMwLCBuZXcgRUNCJDEoMTEsIDI0KSwgbmV3IEVDQiQxKDE2LCAyNSkpLCBuZXcgRUNCbG9ja3MkMSgzMCwgbmV3IEVDQiQxKDMwLCAxNiksIG5ldyBFQ0IkMSgyLCAxNykpKSxcbiAgICAgICAgbmV3IFZlcnNpb24kMSgyNSwgSW50MzJBcnJheS5mcm9tKFs2LCAzMiwgNTgsIDg0LCAxMTBdKSwgbmV3IEVDQmxvY2tzJDEoMjYsIG5ldyBFQ0IkMSg4LCAxMDYpLCBuZXcgRUNCJDEoNCwgMTA3KSksIG5ldyBFQ0Jsb2NrcyQxKDI4LCBuZXcgRUNCJDEoOCwgNDcpLCBuZXcgRUNCJDEoMTMsIDQ4KSksIG5ldyBFQ0Jsb2NrcyQxKDMwLCBuZXcgRUNCJDEoNywgMjQpLCBuZXcgRUNCJDEoMjIsIDI1KSksIG5ldyBFQ0Jsb2NrcyQxKDMwLCBuZXcgRUNCJDEoMjIsIDE1KSwgbmV3IEVDQiQxKDEzLCAxNikpKSxcbiAgICAgICAgbmV3IFZlcnNpb24kMSgyNiwgSW50MzJBcnJheS5mcm9tKFs2LCAzMCwgNTgsIDg2LCAxMTRdKSwgbmV3IEVDQmxvY2tzJDEoMjgsIG5ldyBFQ0IkMSgxMCwgMTE0KSwgbmV3IEVDQiQxKDIsIDExNSkpLCBuZXcgRUNCbG9ja3MkMSgyOCwgbmV3IEVDQiQxKDE5LCA0NiksIG5ldyBFQ0IkMSg0LCA0NykpLCBuZXcgRUNCbG9ja3MkMSgyOCwgbmV3IEVDQiQxKDI4LCAyMiksIG5ldyBFQ0IkMSg2LCAyMykpLCBuZXcgRUNCbG9ja3MkMSgzMCwgbmV3IEVDQiQxKDMzLCAxNiksIG5ldyBFQ0IkMSg0LCAxNykpKSxcbiAgICAgICAgbmV3IFZlcnNpb24kMSgyNywgSW50MzJBcnJheS5mcm9tKFs2LCAzNCwgNjIsIDkwLCAxMThdKSwgbmV3IEVDQmxvY2tzJDEoMzAsIG5ldyBFQ0IkMSg4LCAxMjIpLCBuZXcgRUNCJDEoNCwgMTIzKSksIG5ldyBFQ0Jsb2NrcyQxKDI4LCBuZXcgRUNCJDEoMjIsIDQ1KSwgbmV3IEVDQiQxKDMsIDQ2KSksIG5ldyBFQ0Jsb2NrcyQxKDMwLCBuZXcgRUNCJDEoOCwgMjMpLCBuZXcgRUNCJDEoMjYsIDI0KSksIG5ldyBFQ0Jsb2NrcyQxKDMwLCBuZXcgRUNCJDEoMTIsIDE1KSwgbmV3IEVDQiQxKDI4LCAxNikpKSxcbiAgICAgICAgbmV3IFZlcnNpb24kMSgyOCwgSW50MzJBcnJheS5mcm9tKFs2LCAyNiwgNTAsIDc0LCA5OCwgMTIyXSksIG5ldyBFQ0Jsb2NrcyQxKDMwLCBuZXcgRUNCJDEoMywgMTE3KSwgbmV3IEVDQiQxKDEwLCAxMTgpKSwgbmV3IEVDQmxvY2tzJDEoMjgsIG5ldyBFQ0IkMSgzLCA0NSksIG5ldyBFQ0IkMSgyMywgNDYpKSwgbmV3IEVDQmxvY2tzJDEoMzAsIG5ldyBFQ0IkMSg0LCAyNCksIG5ldyBFQ0IkMSgzMSwgMjUpKSwgbmV3IEVDQmxvY2tzJDEoMzAsIG5ldyBFQ0IkMSgxMSwgMTUpLCBuZXcgRUNCJDEoMzEsIDE2KSkpLFxuICAgICAgICBuZXcgVmVyc2lvbiQxKDI5LCBJbnQzMkFycmF5LmZyb20oWzYsIDMwLCA1NCwgNzgsIDEwMiwgMTI2XSksIG5ldyBFQ0Jsb2NrcyQxKDMwLCBuZXcgRUNCJDEoNywgMTE2KSwgbmV3IEVDQiQxKDcsIDExNykpLCBuZXcgRUNCbG9ja3MkMSgyOCwgbmV3IEVDQiQxKDIxLCA0NSksIG5ldyBFQ0IkMSg3LCA0NikpLCBuZXcgRUNCbG9ja3MkMSgzMCwgbmV3IEVDQiQxKDEsIDIzKSwgbmV3IEVDQiQxKDM3LCAyNCkpLCBuZXcgRUNCbG9ja3MkMSgzMCwgbmV3IEVDQiQxKDE5LCAxNSksIG5ldyBFQ0IkMSgyNiwgMTYpKSksXG4gICAgICAgIG5ldyBWZXJzaW9uJDEoMzAsIEludDMyQXJyYXkuZnJvbShbNiwgMjYsIDUyLCA3OCwgMTA0LCAxMzBdKSwgbmV3IEVDQmxvY2tzJDEoMzAsIG5ldyBFQ0IkMSg1LCAxMTUpLCBuZXcgRUNCJDEoMTAsIDExNikpLCBuZXcgRUNCbG9ja3MkMSgyOCwgbmV3IEVDQiQxKDE5LCA0NyksIG5ldyBFQ0IkMSgxMCwgNDgpKSwgbmV3IEVDQmxvY2tzJDEoMzAsIG5ldyBFQ0IkMSgxNSwgMjQpLCBuZXcgRUNCJDEoMjUsIDI1KSksIG5ldyBFQ0Jsb2NrcyQxKDMwLCBuZXcgRUNCJDEoMjMsIDE1KSwgbmV3IEVDQiQxKDI1LCAxNikpKSxcbiAgICAgICAgbmV3IFZlcnNpb24kMSgzMSwgSW50MzJBcnJheS5mcm9tKFs2LCAzMCwgNTYsIDgyLCAxMDgsIDEzNF0pLCBuZXcgRUNCbG9ja3MkMSgzMCwgbmV3IEVDQiQxKDEzLCAxMTUpLCBuZXcgRUNCJDEoMywgMTE2KSksIG5ldyBFQ0Jsb2NrcyQxKDI4LCBuZXcgRUNCJDEoMiwgNDYpLCBuZXcgRUNCJDEoMjksIDQ3KSksIG5ldyBFQ0Jsb2NrcyQxKDMwLCBuZXcgRUNCJDEoNDIsIDI0KSwgbmV3IEVDQiQxKDEsIDI1KSksIG5ldyBFQ0Jsb2NrcyQxKDMwLCBuZXcgRUNCJDEoMjMsIDE1KSwgbmV3IEVDQiQxKDI4LCAxNikpKSxcbiAgICAgICAgbmV3IFZlcnNpb24kMSgzMiwgSW50MzJBcnJheS5mcm9tKFs2LCAzNCwgNjAsIDg2LCAxMTIsIDEzOF0pLCBuZXcgRUNCbG9ja3MkMSgzMCwgbmV3IEVDQiQxKDE3LCAxMTUpKSwgbmV3IEVDQmxvY2tzJDEoMjgsIG5ldyBFQ0IkMSgxMCwgNDYpLCBuZXcgRUNCJDEoMjMsIDQ3KSksIG5ldyBFQ0Jsb2NrcyQxKDMwLCBuZXcgRUNCJDEoMTAsIDI0KSwgbmV3IEVDQiQxKDM1LCAyNSkpLCBuZXcgRUNCbG9ja3MkMSgzMCwgbmV3IEVDQiQxKDE5LCAxNSksIG5ldyBFQ0IkMSgzNSwgMTYpKSksXG4gICAgICAgIG5ldyBWZXJzaW9uJDEoMzMsIEludDMyQXJyYXkuZnJvbShbNiwgMzAsIDU4LCA4NiwgMTE0LCAxNDJdKSwgbmV3IEVDQmxvY2tzJDEoMzAsIG5ldyBFQ0IkMSgxNywgMTE1KSwgbmV3IEVDQiQxKDEsIDExNikpLCBuZXcgRUNCbG9ja3MkMSgyOCwgbmV3IEVDQiQxKDE0LCA0NiksIG5ldyBFQ0IkMSgyMSwgNDcpKSwgbmV3IEVDQmxvY2tzJDEoMzAsIG5ldyBFQ0IkMSgyOSwgMjQpLCBuZXcgRUNCJDEoMTksIDI1KSksIG5ldyBFQ0Jsb2NrcyQxKDMwLCBuZXcgRUNCJDEoMTEsIDE1KSwgbmV3IEVDQiQxKDQ2LCAxNikpKSxcbiAgICAgICAgbmV3IFZlcnNpb24kMSgzNCwgSW50MzJBcnJheS5mcm9tKFs2LCAzNCwgNjIsIDkwLCAxMTgsIDE0Nl0pLCBuZXcgRUNCbG9ja3MkMSgzMCwgbmV3IEVDQiQxKDEzLCAxMTUpLCBuZXcgRUNCJDEoNiwgMTE2KSksIG5ldyBFQ0Jsb2NrcyQxKDI4LCBuZXcgRUNCJDEoMTQsIDQ2KSwgbmV3IEVDQiQxKDIzLCA0NykpLCBuZXcgRUNCbG9ja3MkMSgzMCwgbmV3IEVDQiQxKDQ0LCAyNCksIG5ldyBFQ0IkMSg3LCAyNSkpLCBuZXcgRUNCbG9ja3MkMSgzMCwgbmV3IEVDQiQxKDU5LCAxNiksIG5ldyBFQ0IkMSgxLCAxNykpKSxcbiAgICAgICAgbmV3IFZlcnNpb24kMSgzNSwgSW50MzJBcnJheS5mcm9tKFs2LCAzMCwgNTQsIDc4LCAxMDIsIDEyNiwgMTUwXSksIG5ldyBFQ0Jsb2NrcyQxKDMwLCBuZXcgRUNCJDEoMTIsIDEyMSksIG5ldyBFQ0IkMSg3LCAxMjIpKSwgbmV3IEVDQmxvY2tzJDEoMjgsIG5ldyBFQ0IkMSgxMiwgNDcpLCBuZXcgRUNCJDEoMjYsIDQ4KSksIG5ldyBFQ0Jsb2NrcyQxKDMwLCBuZXcgRUNCJDEoMzksIDI0KSwgbmV3IEVDQiQxKDE0LCAyNSkpLCBuZXcgRUNCbG9ja3MkMSgzMCwgbmV3IEVDQiQxKDIyLCAxNSksIG5ldyBFQ0IkMSg0MSwgMTYpKSksXG4gICAgICAgIG5ldyBWZXJzaW9uJDEoMzYsIEludDMyQXJyYXkuZnJvbShbNiwgMjQsIDUwLCA3NiwgMTAyLCAxMjgsIDE1NF0pLCBuZXcgRUNCbG9ja3MkMSgzMCwgbmV3IEVDQiQxKDYsIDEyMSksIG5ldyBFQ0IkMSgxNCwgMTIyKSksIG5ldyBFQ0Jsb2NrcyQxKDI4LCBuZXcgRUNCJDEoNiwgNDcpLCBuZXcgRUNCJDEoMzQsIDQ4KSksIG5ldyBFQ0Jsb2NrcyQxKDMwLCBuZXcgRUNCJDEoNDYsIDI0KSwgbmV3IEVDQiQxKDEwLCAyNSkpLCBuZXcgRUNCbG9ja3MkMSgzMCwgbmV3IEVDQiQxKDIsIDE1KSwgbmV3IEVDQiQxKDY0LCAxNikpKSxcbiAgICAgICAgbmV3IFZlcnNpb24kMSgzNywgSW50MzJBcnJheS5mcm9tKFs2LCAyOCwgNTQsIDgwLCAxMDYsIDEzMiwgMTU4XSksIG5ldyBFQ0Jsb2NrcyQxKDMwLCBuZXcgRUNCJDEoMTcsIDEyMiksIG5ldyBFQ0IkMSg0LCAxMjMpKSwgbmV3IEVDQmxvY2tzJDEoMjgsIG5ldyBFQ0IkMSgyOSwgNDYpLCBuZXcgRUNCJDEoMTQsIDQ3KSksIG5ldyBFQ0Jsb2NrcyQxKDMwLCBuZXcgRUNCJDEoNDksIDI0KSwgbmV3IEVDQiQxKDEwLCAyNSkpLCBuZXcgRUNCbG9ja3MkMSgzMCwgbmV3IEVDQiQxKDI0LCAxNSksIG5ldyBFQ0IkMSg0NiwgMTYpKSksXG4gICAgICAgIG5ldyBWZXJzaW9uJDEoMzgsIEludDMyQXJyYXkuZnJvbShbNiwgMzIsIDU4LCA4NCwgMTEwLCAxMzYsIDE2Ml0pLCBuZXcgRUNCbG9ja3MkMSgzMCwgbmV3IEVDQiQxKDQsIDEyMiksIG5ldyBFQ0IkMSgxOCwgMTIzKSksIG5ldyBFQ0Jsb2NrcyQxKDI4LCBuZXcgRUNCJDEoMTMsIDQ2KSwgbmV3IEVDQiQxKDMyLCA0NykpLCBuZXcgRUNCbG9ja3MkMSgzMCwgbmV3IEVDQiQxKDQ4LCAyNCksIG5ldyBFQ0IkMSgxNCwgMjUpKSwgbmV3IEVDQmxvY2tzJDEoMzAsIG5ldyBFQ0IkMSg0MiwgMTUpLCBuZXcgRUNCJDEoMzIsIDE2KSkpLFxuICAgICAgICBuZXcgVmVyc2lvbiQxKDM5LCBJbnQzMkFycmF5LmZyb20oWzYsIDI2LCA1NCwgODIsIDExMCwgMTM4LCAxNjZdKSwgbmV3IEVDQmxvY2tzJDEoMzAsIG5ldyBFQ0IkMSgyMCwgMTE3KSwgbmV3IEVDQiQxKDQsIDExOCkpLCBuZXcgRUNCbG9ja3MkMSgyOCwgbmV3IEVDQiQxKDQwLCA0NyksIG5ldyBFQ0IkMSg3LCA0OCkpLCBuZXcgRUNCbG9ja3MkMSgzMCwgbmV3IEVDQiQxKDQzLCAyNCksIG5ldyBFQ0IkMSgyMiwgMjUpKSwgbmV3IEVDQmxvY2tzJDEoMzAsIG5ldyBFQ0IkMSgxMCwgMTUpLCBuZXcgRUNCJDEoNjcsIDE2KSkpLFxuICAgICAgICBuZXcgVmVyc2lvbiQxKDQwLCBJbnQzMkFycmF5LmZyb20oWzYsIDMwLCA1OCwgODYsIDExNCwgMTQyLCAxNzBdKSwgbmV3IEVDQmxvY2tzJDEoMzAsIG5ldyBFQ0IkMSgxOSwgMTE4KSwgbmV3IEVDQiQxKDYsIDExOSkpLCBuZXcgRUNCbG9ja3MkMSgyOCwgbmV3IEVDQiQxKDE4LCA0NyksIG5ldyBFQ0IkMSgzMSwgNDgpKSwgbmV3IEVDQmxvY2tzJDEoMzAsIG5ldyBFQ0IkMSgzNCwgMjQpLCBuZXcgRUNCJDEoMzQsIDI1KSksIG5ldyBFQ0Jsb2NrcyQxKDMwLCBuZXcgRUNCJDEoMjAsIDE1KSwgbmV3IEVDQiQxKDYxLCAxNikpKVxuICAgIF07XG5cbiAgICAvKlxuICAgICAqIENvcHlyaWdodCAyMDA3IFpYaW5nIGF1dGhvcnNcbiAgICAgKlxuICAgICAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gICAgICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgICAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgICAqXG4gICAgICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAgICAgKlxuICAgICAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgICAgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICAgICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gICAgICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICAgICAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICAgICAqL1xuICAgIHZhciBEYXRhTWFza1ZhbHVlcztcbiAgICAoZnVuY3Rpb24gKERhdGFNYXNrVmFsdWVzKSB7XG4gICAgICAgIERhdGFNYXNrVmFsdWVzW0RhdGFNYXNrVmFsdWVzW1wiREFUQV9NQVNLXzAwMFwiXSA9IDBdID0gXCJEQVRBX01BU0tfMDAwXCI7XG4gICAgICAgIERhdGFNYXNrVmFsdWVzW0RhdGFNYXNrVmFsdWVzW1wiREFUQV9NQVNLXzAwMVwiXSA9IDFdID0gXCJEQVRBX01BU0tfMDAxXCI7XG4gICAgICAgIERhdGFNYXNrVmFsdWVzW0RhdGFNYXNrVmFsdWVzW1wiREFUQV9NQVNLXzAxMFwiXSA9IDJdID0gXCJEQVRBX01BU0tfMDEwXCI7XG4gICAgICAgIERhdGFNYXNrVmFsdWVzW0RhdGFNYXNrVmFsdWVzW1wiREFUQV9NQVNLXzAxMVwiXSA9IDNdID0gXCJEQVRBX01BU0tfMDExXCI7XG4gICAgICAgIERhdGFNYXNrVmFsdWVzW0RhdGFNYXNrVmFsdWVzW1wiREFUQV9NQVNLXzEwMFwiXSA9IDRdID0gXCJEQVRBX01BU0tfMTAwXCI7XG4gICAgICAgIERhdGFNYXNrVmFsdWVzW0RhdGFNYXNrVmFsdWVzW1wiREFUQV9NQVNLXzEwMVwiXSA9IDVdID0gXCJEQVRBX01BU0tfMTAxXCI7XG4gICAgICAgIERhdGFNYXNrVmFsdWVzW0RhdGFNYXNrVmFsdWVzW1wiREFUQV9NQVNLXzExMFwiXSA9IDZdID0gXCJEQVRBX01BU0tfMTEwXCI7XG4gICAgICAgIERhdGFNYXNrVmFsdWVzW0RhdGFNYXNrVmFsdWVzW1wiREFUQV9NQVNLXzExMVwiXSA9IDddID0gXCJEQVRBX01BU0tfMTExXCI7XG4gICAgfSkoRGF0YU1hc2tWYWx1ZXMgfHwgKERhdGFNYXNrVmFsdWVzID0ge30pKTtcbiAgICAvKipcbiAgICAgKiA8cD5FbmNhcHN1bGF0ZXMgZGF0YSBtYXNrcyBmb3IgdGhlIGRhdGEgYml0cyBpbiBhIFFSIGNvZGUsIHBlciBJU08gMTgwMDQ6MjAwNiA2LjguIEltcGxlbWVudGF0aW9uc1xuICAgICAqIG9mIHRoaXMgY2xhc3MgY2FuIHVuLW1hc2sgYSByYXcgQml0TWF0cml4LiBGb3Igc2ltcGxpY2l0eSwgdGhleSB3aWxsIHVubWFzayB0aGUgZW50aXJlIEJpdE1hdHJpeCxcbiAgICAgKiBpbmNsdWRpbmcgYXJlYXMgdXNlZCBmb3IgZmluZGVyIHBhdHRlcm5zLCB0aW1pbmcgcGF0dGVybnMsIGV0Yy4gVGhlc2UgYXJlYXMgc2hvdWxkIGJlIHVudXNlZFxuICAgICAqIGFmdGVyIHRoZSBwb2ludCB0aGV5IGFyZSB1bm1hc2tlZCBhbnl3YXkuPC9wPlxuICAgICAqXG4gICAgICogPHA+Tm90ZSB0aGF0IHRoZSBkaWFncmFtIGluIHNlY3Rpb24gNi44LjEgaXMgbWlzbGVhZGluZyBzaW5jZSBpdCBpbmRpY2F0ZXMgdGhhdCBpIGlzIGNvbHVtbiBwb3NpdGlvblxuICAgICAqIGFuZCBqIGlzIHJvdyBwb3NpdGlvbi4gSW4gZmFjdCwgYXMgdGhlIHRleHQgc2F5cywgaSBpcyByb3cgcG9zaXRpb24gYW5kIGogaXMgY29sdW1uIHBvc2l0aW9uLjwvcD5cbiAgICAgKlxuICAgICAqIEBhdXRob3IgU2VhbiBPd2VuXG4gICAgICovXG4gICAgY2xhc3MgRGF0YU1hc2sge1xuICAgICAgICAvLyBTZWUgSVNPIDE4MDA0OjIwMDYgNi44LjFcbiAgICAgICAgY29uc3RydWN0b3IodmFsdWUsIGlzTWFza2VkKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLmlzTWFza2VkID0gaXNNYXNrZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRW5kIG9mIGVudW0gY29uc3RhbnRzLlxuICAgICAgICAvKipcbiAgICAgICAgICogPHA+SW1wbGVtZW50YXRpb25zIG9mIHRoaXMgbWV0aG9kIHJldmVyc2UgdGhlIGRhdGEgbWFza2luZyBwcm9jZXNzIGFwcGxpZWQgdG8gYSBRUiBDb2RlIGFuZFxuICAgICAgICAgKiBtYWtlIGl0cyBiaXRzIHJlYWR5IHRvIHJlYWQuPC9wPlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gYml0cyByZXByZXNlbnRhdGlvbiBvZiBRUiBDb2RlIGJpdHNcbiAgICAgICAgICogQHBhcmFtIGRpbWVuc2lvbiBkaW1lbnNpb24gb2YgUVIgQ29kZSwgcmVwcmVzZW50ZWQgYnkgYml0cywgYmVpbmcgdW5tYXNrZWRcbiAgICAgICAgICovXG4gICAgICAgIHVubWFza0JpdE1hdHJpeChiaXRzLCBkaW1lbnNpb24gLyppbnQqLykge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkaW1lbnNpb247IGkrKykge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgZGltZW5zaW9uOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNNYXNrZWQoaSwgaikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJpdHMuZmxpcChqLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBEYXRhTWFzay52YWx1ZXMgPSBuZXcgTWFwKFtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIDAwMDogbWFzayBiaXRzIGZvciB3aGljaCAoeCArIHkpIG1vZCAyID09IDBcbiAgICAgICAgICovXG4gICAgICAgIFtEYXRhTWFza1ZhbHVlcy5EQVRBX01BU0tfMDAwLCBuZXcgRGF0YU1hc2soRGF0YU1hc2tWYWx1ZXMuREFUQV9NQVNLXzAwMCwgKGkgLyppbnQqLywgaiAvKmludCovKSA9PiB7IHJldHVybiAoKGkgKyBqKSAmIDB4MDEpID09PSAwOyB9KV0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiAwMDE6IG1hc2sgYml0cyBmb3Igd2hpY2ggeCBtb2QgMiA9PSAwXG4gICAgICAgICAqL1xuICAgICAgICBbRGF0YU1hc2tWYWx1ZXMuREFUQV9NQVNLXzAwMSwgbmV3IERhdGFNYXNrKERhdGFNYXNrVmFsdWVzLkRBVEFfTUFTS18wMDEsIChpIC8qaW50Ki8sIGogLyppbnQqLykgPT4geyByZXR1cm4gKGkgJiAweDAxKSA9PT0gMDsgfSldLFxuICAgICAgICAvKipcbiAgICAgICAgICogMDEwOiBtYXNrIGJpdHMgZm9yIHdoaWNoIHkgbW9kIDMgPT0gMFxuICAgICAgICAgKi9cbiAgICAgICAgW0RhdGFNYXNrVmFsdWVzLkRBVEFfTUFTS18wMTAsIG5ldyBEYXRhTWFzayhEYXRhTWFza1ZhbHVlcy5EQVRBX01BU0tfMDEwLCAoaSAvKmludCovLCBqIC8qaW50Ki8pID0+IHsgcmV0dXJuIGogJSAzID09PSAwOyB9KV0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiAwMTE6IG1hc2sgYml0cyBmb3Igd2hpY2ggKHggKyB5KSBtb2QgMyA9PSAwXG4gICAgICAgICAqL1xuICAgICAgICBbRGF0YU1hc2tWYWx1ZXMuREFUQV9NQVNLXzAxMSwgbmV3IERhdGFNYXNrKERhdGFNYXNrVmFsdWVzLkRBVEFfTUFTS18wMTEsIChpIC8qaW50Ki8sIGogLyppbnQqLykgPT4geyByZXR1cm4gKGkgKyBqKSAlIDMgPT09IDA7IH0pXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIDEwMDogbWFzayBiaXRzIGZvciB3aGljaCAoeC8yICsgeS8zKSBtb2QgMiA9PSAwXG4gICAgICAgICAqL1xuICAgICAgICBbRGF0YU1hc2tWYWx1ZXMuREFUQV9NQVNLXzEwMCwgbmV3IERhdGFNYXNrKERhdGFNYXNrVmFsdWVzLkRBVEFfTUFTS18xMDAsIChpIC8qaW50Ki8sIGogLyppbnQqLykgPT4geyByZXR1cm4gKChNYXRoLmZsb29yKGkgLyAyKSArIE1hdGguZmxvb3IoaiAvIDMpKSAmIDB4MDEpID09PSAwOyB9KV0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiAxMDE6IG1hc2sgYml0cyBmb3Igd2hpY2ggeHkgbW9kIDIgKyB4eSBtb2QgMyA9PSAwXG4gICAgICAgICAqIGVxdWl2YWxlbnRseSwgc3VjaCB0aGF0IHh5IG1vZCA2ID09IDBcbiAgICAgICAgICovXG4gICAgICAgIFtEYXRhTWFza1ZhbHVlcy5EQVRBX01BU0tfMTAxLCBuZXcgRGF0YU1hc2soRGF0YU1hc2tWYWx1ZXMuREFUQV9NQVNLXzEwMSwgKGkgLyppbnQqLywgaiAvKmludCovKSA9PiB7IHJldHVybiAoaSAqIGopICUgNiA9PT0gMDsgfSldLFxuICAgICAgICAvKipcbiAgICAgICAgICogMTEwOiBtYXNrIGJpdHMgZm9yIHdoaWNoICh4eSBtb2QgMiArIHh5IG1vZCAzKSBtb2QgMiA9PSAwXG4gICAgICAgICAqIGVxdWl2YWxlbnRseSwgc3VjaCB0aGF0IHh5IG1vZCA2IDwgM1xuICAgICAgICAgKi9cbiAgICAgICAgW0RhdGFNYXNrVmFsdWVzLkRBVEFfTUFTS18xMTAsIG5ldyBEYXRhTWFzayhEYXRhTWFza1ZhbHVlcy5EQVRBX01BU0tfMTEwLCAoaSAvKmludCovLCBqIC8qaW50Ki8pID0+IHsgcmV0dXJuICgoaSAqIGopICUgNikgPCAzOyB9KV0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiAxMTE6IG1hc2sgYml0cyBmb3Igd2hpY2ggKCh4K3kpbW9kIDIgKyB4eSBtb2QgMykgbW9kIDIgPT0gMFxuICAgICAgICAgKiBlcXVpdmFsZW50bHksIHN1Y2ggdGhhdCAoeCArIHkgKyB4eSBtb2QgMykgbW9kIDIgPT0gMFxuICAgICAgICAgKi9cbiAgICAgICAgW0RhdGFNYXNrVmFsdWVzLkRBVEFfTUFTS18xMTEsIG5ldyBEYXRhTWFzayhEYXRhTWFza1ZhbHVlcy5EQVRBX01BU0tfMTExLCAoaSAvKmludCovLCBqIC8qaW50Ki8pID0+IHsgcmV0dXJuICgoaSArIGogKyAoKGkgKiBqKSAlIDMpKSAmIDB4MDEpID09PSAwOyB9KV0sXG4gICAgXSk7XG5cbiAgICAvKlxuICAgICAqIENvcHlyaWdodCAyMDA3IFpYaW5nIGF1dGhvcnNcbiAgICAgKlxuICAgICAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gICAgICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgICAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgICAqXG4gICAgICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAgICAgKlxuICAgICAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgICAgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICAgICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gICAgICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICAgICAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIEBhdXRob3IgU2VhbiBPd2VuXG4gICAgICovXG4gICAgY2xhc3MgQml0TWF0cml4UGFyc2VyJDEge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIGJpdE1hdHJpeCB7QGxpbmsgQml0TWF0cml4fSB0byBwYXJzZVxuICAgICAgICAgKiBAdGhyb3dzIEZvcm1hdEV4Y2VwdGlvbiBpZiBkaW1lbnNpb24gaXMgbm90ID49IDIxIGFuZCAxIG1vZCA0XG4gICAgICAgICAqL1xuICAgICAgICBjb25zdHJ1Y3RvcihiaXRNYXRyaXgpIHtcbiAgICAgICAgICAgIGNvbnN0IGRpbWVuc2lvbiA9IGJpdE1hdHJpeC5nZXRIZWlnaHQoKTtcbiAgICAgICAgICAgIGlmIChkaW1lbnNpb24gPCAyMSB8fCAoZGltZW5zaW9uICYgMHgwMykgIT09IDEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmJpdE1hdHJpeCA9IGJpdE1hdHJpeDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogPHA+UmVhZHMgZm9ybWF0IGluZm9ybWF0aW9uIGZyb20gb25lIG9mIGl0cyB0d28gbG9jYXRpb25zIHdpdGhpbiB0aGUgUVIgQ29kZS48L3A+XG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge0BsaW5rIEZvcm1hdEluZm9ybWF0aW9ufSBlbmNhcHN1bGF0aW5nIHRoZSBRUiBDb2RlJ3MgZm9ybWF0IGluZm9cbiAgICAgICAgICogQHRocm93cyBGb3JtYXRFeGNlcHRpb24gaWYgYm90aCBmb3JtYXQgaW5mb3JtYXRpb24gbG9jYXRpb25zIGNhbm5vdCBiZSBwYXJzZWQgYXNcbiAgICAgICAgICogdGhlIHZhbGlkIGVuY29kaW5nIG9mIGZvcm1hdCBpbmZvcm1hdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgcmVhZEZvcm1hdEluZm9ybWF0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucGFyc2VkRm9ybWF0SW5mbyAhPT0gbnVsbCAmJiB0aGlzLnBhcnNlZEZvcm1hdEluZm8gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlZEZvcm1hdEluZm87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSZWFkIHRvcC1sZWZ0IGZvcm1hdCBpbmZvIGJpdHNcbiAgICAgICAgICAgIGxldCBmb3JtYXRJbmZvQml0czEgPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA2OyBpKyspIHtcbiAgICAgICAgICAgICAgICBmb3JtYXRJbmZvQml0czEgPSB0aGlzLmNvcHlCaXQoaSwgOCwgZm9ybWF0SW5mb0JpdHMxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIC4uIGFuZCBza2lwIGEgYml0IGluIHRoZSB0aW1pbmcgcGF0dGVybiAuLi5cbiAgICAgICAgICAgIGZvcm1hdEluZm9CaXRzMSA9IHRoaXMuY29weUJpdCg3LCA4LCBmb3JtYXRJbmZvQml0czEpO1xuICAgICAgICAgICAgZm9ybWF0SW5mb0JpdHMxID0gdGhpcy5jb3B5Qml0KDgsIDgsIGZvcm1hdEluZm9CaXRzMSk7XG4gICAgICAgICAgICBmb3JtYXRJbmZvQml0czEgPSB0aGlzLmNvcHlCaXQoOCwgNywgZm9ybWF0SW5mb0JpdHMxKTtcbiAgICAgICAgICAgIC8vIC4uIGFuZCBza2lwIGEgYml0IGluIHRoZSB0aW1pbmcgcGF0dGVybiAuLi5cbiAgICAgICAgICAgIGZvciAobGV0IGogPSA1OyBqID49IDA7IGotLSkge1xuICAgICAgICAgICAgICAgIGZvcm1hdEluZm9CaXRzMSA9IHRoaXMuY29weUJpdCg4LCBqLCBmb3JtYXRJbmZvQml0czEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUmVhZCB0aGUgdG9wLXJpZ2h0L2JvdHRvbS1sZWZ0IHBhdHRlcm4gdG9vXG4gICAgICAgICAgICBjb25zdCBkaW1lbnNpb24gPSB0aGlzLmJpdE1hdHJpeC5nZXRIZWlnaHQoKTtcbiAgICAgICAgICAgIGxldCBmb3JtYXRJbmZvQml0czIgPSAwO1xuICAgICAgICAgICAgY29uc3Qgak1pbiA9IGRpbWVuc2lvbiAtIDc7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gZGltZW5zaW9uIC0gMTsgaiA+PSBqTWluOyBqLS0pIHtcbiAgICAgICAgICAgICAgICBmb3JtYXRJbmZvQml0czIgPSB0aGlzLmNvcHlCaXQoOCwgaiwgZm9ybWF0SW5mb0JpdHMyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBkaW1lbnNpb24gLSA4OyBpIDwgZGltZW5zaW9uOyBpKyspIHtcbiAgICAgICAgICAgICAgICBmb3JtYXRJbmZvQml0czIgPSB0aGlzLmNvcHlCaXQoaSwgOCwgZm9ybWF0SW5mb0JpdHMyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucGFyc2VkRm9ybWF0SW5mbyA9IEZvcm1hdEluZm9ybWF0aW9uLmRlY29kZUZvcm1hdEluZm9ybWF0aW9uKGZvcm1hdEluZm9CaXRzMSwgZm9ybWF0SW5mb0JpdHMyKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnBhcnNlZEZvcm1hdEluZm8gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZWRGb3JtYXRJbmZvO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiA8cD5SZWFkcyB2ZXJzaW9uIGluZm9ybWF0aW9uIGZyb20gb25lIG9mIGl0cyB0d28gbG9jYXRpb25zIHdpdGhpbiB0aGUgUVIgQ29kZS48L3A+XG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge0BsaW5rIFZlcnNpb259IGVuY2Fwc3VsYXRpbmcgdGhlIFFSIENvZGUncyB2ZXJzaW9uXG4gICAgICAgICAqIEB0aHJvd3MgRm9ybWF0RXhjZXB0aW9uIGlmIGJvdGggdmVyc2lvbiBpbmZvcm1hdGlvbiBsb2NhdGlvbnMgY2Fubm90IGJlIHBhcnNlZCBhc1xuICAgICAgICAgKiB0aGUgdmFsaWQgZW5jb2Rpbmcgb2YgdmVyc2lvbiBpbmZvcm1hdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgcmVhZFZlcnNpb24oKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wYXJzZWRWZXJzaW9uICE9PSBudWxsICYmIHRoaXMucGFyc2VkVmVyc2lvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VkVmVyc2lvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGRpbWVuc2lvbiA9IHRoaXMuYml0TWF0cml4LmdldEhlaWdodCgpO1xuICAgICAgICAgICAgY29uc3QgcHJvdmlzaW9uYWxWZXJzaW9uID0gTWF0aC5mbG9vcigoZGltZW5zaW9uIC0gMTcpIC8gNCk7XG4gICAgICAgICAgICBpZiAocHJvdmlzaW9uYWxWZXJzaW9uIDw9IDYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gVmVyc2lvbiQxLmdldFZlcnNpb25Gb3JOdW1iZXIocHJvdmlzaW9uYWxWZXJzaW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJlYWQgdG9wLXJpZ2h0IHZlcnNpb24gaW5mbzogMyB3aWRlIGJ5IDYgdGFsbFxuICAgICAgICAgICAgbGV0IHZlcnNpb25CaXRzID0gMDtcbiAgICAgICAgICAgIGNvbnN0IGlqTWluID0gZGltZW5zaW9uIC0gMTE7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gNTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gZGltZW5zaW9uIC0gOTsgaSA+PSBpak1pbjsgaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgIHZlcnNpb25CaXRzID0gdGhpcy5jb3B5Qml0KGksIGosIHZlcnNpb25CaXRzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgdGhlUGFyc2VkVmVyc2lvbiA9IFZlcnNpb24kMS5kZWNvZGVWZXJzaW9uSW5mb3JtYXRpb24odmVyc2lvbkJpdHMpO1xuICAgICAgICAgICAgaWYgKHRoZVBhcnNlZFZlcnNpb24gIT09IG51bGwgJiYgdGhlUGFyc2VkVmVyc2lvbi5nZXREaW1lbnNpb25Gb3JWZXJzaW9uKCkgPT09IGRpbWVuc2lvbikge1xuICAgICAgICAgICAgICAgIHRoaXMucGFyc2VkVmVyc2lvbiA9IHRoZVBhcnNlZFZlcnNpb247XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoZVBhcnNlZFZlcnNpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBIbW0sIGZhaWxlZC4gVHJ5IGJvdHRvbSBsZWZ0OiA2IHdpZGUgYnkgMyB0YWxsXG4gICAgICAgICAgICB2ZXJzaW9uQml0cyA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gNTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gZGltZW5zaW9uIC0gOTsgaiA+PSBpak1pbjsgai0tKSB7XG4gICAgICAgICAgICAgICAgICAgIHZlcnNpb25CaXRzID0gdGhpcy5jb3B5Qml0KGksIGosIHZlcnNpb25CaXRzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGVQYXJzZWRWZXJzaW9uID0gVmVyc2lvbiQxLmRlY29kZVZlcnNpb25JbmZvcm1hdGlvbih2ZXJzaW9uQml0cyk7XG4gICAgICAgICAgICBpZiAodGhlUGFyc2VkVmVyc2lvbiAhPT0gbnVsbCAmJiB0aGVQYXJzZWRWZXJzaW9uLmdldERpbWVuc2lvbkZvclZlcnNpb24oKSA9PT0gZGltZW5zaW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJzZWRWZXJzaW9uID0gdGhlUGFyc2VkVmVyc2lvbjtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhlUGFyc2VkVmVyc2lvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICBjb3B5Qml0KGkgLyppbnQqLywgaiAvKmludCovLCB2ZXJzaW9uQml0cyAvKmludCovKSB7XG4gICAgICAgICAgICBjb25zdCBiaXQgPSB0aGlzLmlzTWlycm9yID8gdGhpcy5iaXRNYXRyaXguZ2V0KGosIGkpIDogdGhpcy5iaXRNYXRyaXguZ2V0KGksIGopO1xuICAgICAgICAgICAgcmV0dXJuIGJpdCA/ICh2ZXJzaW9uQml0cyA8PCAxKSB8IDB4MSA6IHZlcnNpb25CaXRzIDw8IDE7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIDxwPlJlYWRzIHRoZSBiaXRzIGluIHRoZSB7QGxpbmsgQml0TWF0cml4fSByZXByZXNlbnRpbmcgdGhlIGZpbmRlciBwYXR0ZXJuIGluIHRoZVxuICAgICAgICAgKiBjb3JyZWN0IG9yZGVyIGluIG9yZGVyIHRvIHJlY29uc3RydWN0IHRoZSBjb2Rld29yZHMgYnl0ZXMgY29udGFpbmVkIHdpdGhpbiB0aGVcbiAgICAgICAgICogUVIgQ29kZS48L3A+XG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4gYnl0ZXMgZW5jb2RlZCB3aXRoaW4gdGhlIFFSIENvZGVcbiAgICAgICAgICogQHRocm93cyBGb3JtYXRFeGNlcHRpb24gaWYgdGhlIGV4YWN0IG51bWJlciBvZiBieXRlcyBleHBlY3RlZCBpcyBub3QgcmVhZFxuICAgICAgICAgKi9cbiAgICAgICAgcmVhZENvZGV3b3JkcygpIHtcbiAgICAgICAgICAgIGNvbnN0IGZvcm1hdEluZm8gPSB0aGlzLnJlYWRGb3JtYXRJbmZvcm1hdGlvbigpO1xuICAgICAgICAgICAgY29uc3QgdmVyc2lvbiA9IHRoaXMucmVhZFZlcnNpb24oKTtcbiAgICAgICAgICAgIC8vIEdldCB0aGUgZGF0YSBtYXNrIGZvciB0aGUgZm9ybWF0IHVzZWQgaW4gdGhpcyBRUiBDb2RlLiBUaGlzIHdpbGwgZXhjbHVkZVxuICAgICAgICAgICAgLy8gc29tZSBiaXRzIGZyb20gcmVhZGluZyBhcyB3ZSB3aW5kIHRocm91Z2ggdGhlIGJpdCBtYXRyaXguXG4gICAgICAgICAgICBjb25zdCBkYXRhTWFzayA9IERhdGFNYXNrLnZhbHVlcy5nZXQoZm9ybWF0SW5mby5nZXREYXRhTWFzaygpKTtcbiAgICAgICAgICAgIGNvbnN0IGRpbWVuc2lvbiA9IHRoaXMuYml0TWF0cml4LmdldEhlaWdodCgpO1xuICAgICAgICAgICAgZGF0YU1hc2sudW5tYXNrQml0TWF0cml4KHRoaXMuYml0TWF0cml4LCBkaW1lbnNpb24pO1xuICAgICAgICAgICAgY29uc3QgZnVuY3Rpb25QYXR0ZXJuID0gdmVyc2lvbi5idWlsZEZ1bmN0aW9uUGF0dGVybigpO1xuICAgICAgICAgICAgbGV0IHJlYWRpbmdVcCA9IHRydWU7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheSh2ZXJzaW9uLmdldFRvdGFsQ29kZXdvcmRzKCkpO1xuICAgICAgICAgICAgbGV0IHJlc3VsdE9mZnNldCA9IDA7XG4gICAgICAgICAgICBsZXQgY3VycmVudEJ5dGUgPSAwO1xuICAgICAgICAgICAgbGV0IGJpdHNSZWFkID0gMDtcbiAgICAgICAgICAgIC8vIFJlYWQgY29sdW1ucyBpbiBwYWlycywgZnJvbSByaWdodCB0byBsZWZ0XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gZGltZW5zaW9uIC0gMTsgaiA+IDA7IGogLT0gMikge1xuICAgICAgICAgICAgICAgIGlmIChqID09PSA2KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNraXAgd2hvbGUgY29sdW1uIHdpdGggdmVydGljYWwgYWxpZ25tZW50IHBhdHRlcm5cbiAgICAgICAgICAgICAgICAgICAgLy8gc2F2ZXMgdGltZSBhbmQgbWFrZXMgdGhlIG90aGVyIGNvZGUgcHJvY2VlZCBtb3JlIGNsZWFubHlcbiAgICAgICAgICAgICAgICAgICAgai0tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBSZWFkIGFsdGVybmF0aW5nbHkgZnJvbSBib3R0b20gdG8gdG9wIHRoZW4gdG9wIHRvIGJvdHRvbVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGNvdW50ID0gMDsgY291bnQgPCBkaW1lbnNpb247IGNvdW50KyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaSA9IHJlYWRpbmdVcCA/IGRpbWVuc2lvbiAtIDEgLSBjb3VudCA6IGNvdW50O1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBjb2wgPSAwOyBjb2wgPCAyOyBjb2wrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWdub3JlIGJpdHMgY292ZXJlZCBieSB0aGUgZnVuY3Rpb24gcGF0dGVyblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFmdW5jdGlvblBhdHRlcm4uZ2V0KGogLSBjb2wsIGkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVhZCBhIGJpdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJpdHNSZWFkKys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEJ5dGUgPDw9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYml0TWF0cml4LmdldChqIC0gY29sLCBpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Qnl0ZSB8PSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSd2ZSBtYWRlIGEgd2hvbGUgYnl0ZSwgc2F2ZSBpdCBvZmZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYml0c1JlYWQgPT09IDgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W3Jlc3VsdE9mZnNldCsrXSA9IC8qKGJ5dGUpICovIGN1cnJlbnRCeXRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiaXRzUmVhZCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRCeXRlID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVhZGluZ1VwID0gIXJlYWRpbmdVcDsgLy8gcmVhZGluZ1VwIF49IHRydWU7IC8vIHJlYWRpbmdVcCA9ICFyZWFkaW5nVXA7IC8vIHN3aXRjaCBkaXJlY3Rpb25zXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzdWx0T2Zmc2V0ICE9PSB2ZXJzaW9uLmdldFRvdGFsQ29kZXdvcmRzKCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXZlcnQgdGhlIG1hc2sgcmVtb3ZhbCBkb25lIHdoaWxlIHJlYWRpbmcgdGhlIGNvZGUgd29yZHMuIFRoZSBiaXQgbWF0cml4IHNob3VsZCByZXZlcnQgdG8gaXRzIG9yaWdpbmFsIHN0YXRlLlxuICAgICAgICAgKi9cbiAgICAgICAgcmVtYXNrKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucGFyc2VkRm9ybWF0SW5mbyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjsgLy8gV2UgaGF2ZSBubyBmb3JtYXQgaW5mb3JtYXRpb24sIGFuZCBoYXZlIG5vIGRhdGEgbWFza1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZGF0YU1hc2sgPSBEYXRhTWFzay52YWx1ZXNbdGhpcy5wYXJzZWRGb3JtYXRJbmZvLmdldERhdGFNYXNrKCldO1xuICAgICAgICAgICAgY29uc3QgZGltZW5zaW9uID0gdGhpcy5iaXRNYXRyaXguZ2V0SGVpZ2h0KCk7XG4gICAgICAgICAgICBkYXRhTWFzay51bm1hc2tCaXRNYXRyaXgodGhpcy5iaXRNYXRyaXgsIGRpbWVuc2lvbik7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByZXBhcmUgdGhlIHBhcnNlciBmb3IgYSBtaXJyb3JlZCBvcGVyYXRpb24uXG4gICAgICAgICAqIFRoaXMgZmxhZyBoYXMgZWZmZWN0IG9ubHkgb24gdGhlIHtAbGluayAjcmVhZEZvcm1hdEluZm9ybWF0aW9uKCl9IGFuZCB0aGVcbiAgICAgICAgICoge0BsaW5rICNyZWFkVmVyc2lvbigpfS4gQmVmb3JlIHByb2NlZWRpbmcgd2l0aCB7QGxpbmsgI3JlYWRDb2Rld29yZHMoKX0gdGhlXG4gICAgICAgICAqIHtAbGluayAjbWlycm9yKCl9IG1ldGhvZCBzaG91bGQgYmUgY2FsbGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gbWlycm9yIFdoZXRoZXIgdG8gcmVhZCB2ZXJzaW9uIGFuZCBmb3JtYXQgaW5mb3JtYXRpb24gbWlycm9yZWQuXG4gICAgICAgICAqL1xuICAgICAgICBzZXRNaXJyb3IoaXNNaXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMucGFyc2VkVmVyc2lvbiA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnBhcnNlZEZvcm1hdEluZm8gPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5pc01pcnJvciA9IGlzTWlycm9yO1xuICAgICAgICB9XG4gICAgICAgIC8qKiBNaXJyb3IgdGhlIGJpdCBtYXRyaXggaW4gb3JkZXIgdG8gYXR0ZW1wdCBhIHNlY29uZCByZWFkaW5nLiAqL1xuICAgICAgICBtaXJyb3IoKSB7XG4gICAgICAgICAgICBjb25zdCBiaXRNYXRyaXggPSB0aGlzLmJpdE1hdHJpeDtcbiAgICAgICAgICAgIGZvciAobGV0IHggPSAwLCB3aWR0aCA9IGJpdE1hdHJpeC5nZXRXaWR0aCgpOyB4IDwgd2lkdGg7IHgrKykge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHkgPSB4ICsgMSwgaGVpZ2h0ID0gYml0TWF0cml4LmdldEhlaWdodCgpOyB5IDwgaGVpZ2h0OyB5KyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJpdE1hdHJpeC5nZXQoeCwgeSkgIT09IGJpdE1hdHJpeC5nZXQoeSwgeCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJpdE1hdHJpeC5mbGlwKHksIHgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYml0TWF0cml4LmZsaXAoeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKlxuICAgICAqIENvcHlyaWdodCAyMDA3IFpYaW5nIGF1dGhvcnNcbiAgICAgKlxuICAgICAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gICAgICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgICAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgICAqXG4gICAgICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAgICAgKlxuICAgICAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgICAgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICAgICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gICAgICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICAgICAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIDxwPkVuY2Fwc3VsYXRlcyBhIGJsb2NrIG9mIGRhdGEgd2l0aGluIGEgUVIgQ29kZS4gUVIgQ29kZXMgbWF5IHNwbGl0IHRoZWlyIGRhdGEgaW50b1xuICAgICAqIG11bHRpcGxlIGJsb2NrcywgZWFjaCBvZiB3aGljaCBpcyBhIHVuaXQgb2YgZGF0YSBhbmQgZXJyb3ItY29ycmVjdGlvbiBjb2Rld29yZHMuIEVhY2hcbiAgICAgKiBpcyByZXByZXNlbnRlZCBieSBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLjwvcD5cbiAgICAgKlxuICAgICAqIEBhdXRob3IgU2VhbiBPd2VuXG4gICAgICovXG4gICAgY2xhc3MgRGF0YUJsb2NrJDEge1xuICAgICAgICBjb25zdHJ1Y3RvcihudW1EYXRhQ29kZXdvcmRzIC8qaW50Ki8sIGNvZGV3b3Jkcykge1xuICAgICAgICAgICAgdGhpcy5udW1EYXRhQ29kZXdvcmRzID0gbnVtRGF0YUNvZGV3b3JkcztcbiAgICAgICAgICAgIHRoaXMuY29kZXdvcmRzID0gY29kZXdvcmRzO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiA8cD5XaGVuIFFSIENvZGVzIHVzZSBtdWx0aXBsZSBkYXRhIGJsb2NrcywgdGhleSBhcmUgYWN0dWFsbHkgaW50ZXJsZWF2ZWQuXG4gICAgICAgICAqIFRoYXQgaXMsIHRoZSBmaXJzdCBieXRlIG9mIGRhdGEgYmxvY2sgMSB0byBuIGlzIHdyaXR0ZW4sIHRoZW4gdGhlIHNlY29uZCBieXRlcywgYW5kIHNvIG9uLiBUaGlzXG4gICAgICAgICAqIG1ldGhvZCB3aWxsIHNlcGFyYXRlIHRoZSBkYXRhIGludG8gb3JpZ2luYWwgYmxvY2tzLjwvcD5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHJhd0NvZGV3b3JkcyBieXRlcyBhcyByZWFkIGRpcmVjdGx5IGZyb20gdGhlIFFSIENvZGVcbiAgICAgICAgICogQHBhcmFtIHZlcnNpb24gdmVyc2lvbiBvZiB0aGUgUVIgQ29kZVxuICAgICAgICAgKiBAcGFyYW0gZWNMZXZlbCBlcnJvci1jb3JyZWN0aW9uIGxldmVsIG9mIHRoZSBRUiBDb2RlXG4gICAgICAgICAqIEByZXR1cm4gRGF0YUJsb2NrcyBjb250YWluaW5nIG9yaWdpbmFsIGJ5dGVzLCBcImRlLWludGVybGVhdmVkXCIgZnJvbSByZXByZXNlbnRhdGlvbiBpbiB0aGVcbiAgICAgICAgICogICAgICAgICBRUiBDb2RlXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgZ2V0RGF0YUJsb2NrcyhyYXdDb2Rld29yZHMsIHZlcnNpb24sIGVjTGV2ZWwpIHtcbiAgICAgICAgICAgIGlmIChyYXdDb2Rld29yZHMubGVuZ3RoICE9PSB2ZXJzaW9uLmdldFRvdGFsQ29kZXdvcmRzKCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBGaWd1cmUgb3V0IHRoZSBudW1iZXIgYW5kIHNpemUgb2YgZGF0YSBibG9ja3MgdXNlZCBieSB0aGlzIHZlcnNpb24gYW5kXG4gICAgICAgICAgICAvLyBlcnJvciBjb3JyZWN0aW9uIGxldmVsXG4gICAgICAgICAgICBjb25zdCBlY0Jsb2NrcyA9IHZlcnNpb24uZ2V0RUNCbG9ja3NGb3JMZXZlbChlY0xldmVsKTtcbiAgICAgICAgICAgIC8vIEZpcnN0IGNvdW50IHRoZSB0b3RhbCBudW1iZXIgb2YgZGF0YSBibG9ja3NcbiAgICAgICAgICAgIGxldCB0b3RhbEJsb2NrcyA9IDA7XG4gICAgICAgICAgICBjb25zdCBlY0Jsb2NrQXJyYXkgPSBlY0Jsb2Nrcy5nZXRFQ0Jsb2NrcygpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBlY0Jsb2NrIG9mIGVjQmxvY2tBcnJheSkge1xuICAgICAgICAgICAgICAgIHRvdGFsQmxvY2tzICs9IGVjQmxvY2suZ2V0Q291bnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE5vdyBlc3RhYmxpc2ggRGF0YUJsb2NrcyBvZiB0aGUgYXBwcm9wcmlhdGUgc2l6ZSBhbmQgbnVtYmVyIG9mIGRhdGEgY29kZXdvcmRzXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgQXJyYXkodG90YWxCbG9ja3MpO1xuICAgICAgICAgICAgbGV0IG51bVJlc3VsdEJsb2NrcyA9IDA7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGVjQmxvY2sgb2YgZWNCbG9ja0FycmF5KSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlY0Jsb2NrLmdldENvdW50KCk7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBudW1EYXRhQ29kZXdvcmRzID0gZWNCbG9jay5nZXREYXRhQ29kZXdvcmRzKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG51bUJsb2NrQ29kZXdvcmRzID0gZWNCbG9ja3MuZ2V0RUNDb2Rld29yZHNQZXJCbG9jaygpICsgbnVtRGF0YUNvZGV3b3JkcztcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W251bVJlc3VsdEJsb2NrcysrXSA9IG5ldyBEYXRhQmxvY2skMShudW1EYXRhQ29kZXdvcmRzLCBuZXcgVWludDhBcnJheShudW1CbG9ja0NvZGV3b3JkcykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEFsbCBibG9ja3MgaGF2ZSB0aGUgc2FtZSBhbW91bnQgb2YgZGF0YSwgZXhjZXB0IHRoYXQgdGhlIGxhc3QgblxuICAgICAgICAgICAgLy8gKHdoZXJlIG4gbWF5IGJlIDApIGhhdmUgMSBtb3JlIGJ5dGUuIEZpZ3VyZSBvdXQgd2hlcmUgdGhlc2Ugc3RhcnQuXG4gICAgICAgICAgICBjb25zdCBzaG9ydGVyQmxvY2tzVG90YWxDb2Rld29yZHMgPSByZXN1bHRbMF0uY29kZXdvcmRzLmxlbmd0aDtcbiAgICAgICAgICAgIGxldCBsb25nZXJCbG9ja3NTdGFydEF0ID0gcmVzdWx0Lmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAvLyBUWVBFU0NSSVBUUE9SVDogY2hlY2sgbGVuZ3RoIGlzIGNvcnJlY3QgaGVyZVxuICAgICAgICAgICAgd2hpbGUgKGxvbmdlckJsb2Nrc1N0YXJ0QXQgPj0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG51bUNvZGV3b3JkcyA9IHJlc3VsdFtsb25nZXJCbG9ja3NTdGFydEF0XS5jb2Rld29yZHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmIChudW1Db2Rld29yZHMgPT09IHNob3J0ZXJCbG9ja3NUb3RhbENvZGV3b3Jkcykge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbG9uZ2VyQmxvY2tzU3RhcnRBdC0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9uZ2VyQmxvY2tzU3RhcnRBdCsrO1xuICAgICAgICAgICAgY29uc3Qgc2hvcnRlckJsb2Nrc051bURhdGFDb2Rld29yZHMgPSBzaG9ydGVyQmxvY2tzVG90YWxDb2Rld29yZHMgLSBlY0Jsb2Nrcy5nZXRFQ0NvZGV3b3Jkc1BlckJsb2NrKCk7XG4gICAgICAgICAgICAvLyBUaGUgbGFzdCBlbGVtZW50cyBvZiByZXN1bHQgbWF5IGJlIDEgZWxlbWVudCBsb25nZXJcbiAgICAgICAgICAgIC8vIGZpcnN0IGZpbGwgb3V0IGFzIG1hbnkgZWxlbWVudHMgYXMgYWxsIG9mIHRoZW0gaGF2ZVxuICAgICAgICAgICAgbGV0IHJhd0NvZGV3b3Jkc09mZnNldCA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNob3J0ZXJCbG9ja3NOdW1EYXRhQ29kZXdvcmRzOyBpKyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG51bVJlc3VsdEJsb2NrczsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtqXS5jb2Rld29yZHNbaV0gPSByYXdDb2Rld29yZHNbcmF3Q29kZXdvcmRzT2Zmc2V0KytdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEZpbGwgb3V0IHRoZSBsYXN0IGRhdGEgYmxvY2sgaW4gdGhlIGxvbmdlciBvbmVzXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gbG9uZ2VyQmxvY2tzU3RhcnRBdDsgaiA8IG51bVJlc3VsdEJsb2NrczsgaisrKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2pdLmNvZGV3b3Jkc1tzaG9ydGVyQmxvY2tzTnVtRGF0YUNvZGV3b3Jkc10gPSByYXdDb2Rld29yZHNbcmF3Q29kZXdvcmRzT2Zmc2V0KytdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTm93IGFkZCBpbiBlcnJvciBjb3JyZWN0aW9uIGJsb2Nrc1xuICAgICAgICAgICAgY29uc3QgbWF4ID0gcmVzdWx0WzBdLmNvZGV3b3Jkcy5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gc2hvcnRlckJsb2Nrc051bURhdGFDb2Rld29yZHM7IGkgPCBtYXg7IGkrKykge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbnVtUmVzdWx0QmxvY2tzOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaU9mZnNldCA9IGogPCBsb25nZXJCbG9ja3NTdGFydEF0ID8gaSA6IGkgKyAxO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRbal0uY29kZXdvcmRzW2lPZmZzZXRdID0gcmF3Q29kZXdvcmRzW3Jhd0NvZGV3b3Jkc09mZnNldCsrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGdldE51bURhdGFDb2Rld29yZHMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW1EYXRhQ29kZXdvcmRzO1xuICAgICAgICB9XG4gICAgICAgIGdldENvZGV3b3JkcygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvZGV3b3JkcztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qXG4gICAgICogQ29weXJpZ2h0IDIwMDcgWlhpbmcgYXV0aG9yc1xuICAgICAqXG4gICAgICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgICAgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICAgICpcbiAgICAgKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICAgICAqXG4gICAgICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICAgICAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgICAgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgICAgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gICAgICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gICAgICovXG4gICAgdmFyIE1vZGVWYWx1ZXM7XG4gICAgKGZ1bmN0aW9uIChNb2RlVmFsdWVzKSB7XG4gICAgICAgIE1vZGVWYWx1ZXNbTW9kZVZhbHVlc1tcIlRFUk1JTkFUT1JcIl0gPSAwXSA9IFwiVEVSTUlOQVRPUlwiO1xuICAgICAgICBNb2RlVmFsdWVzW01vZGVWYWx1ZXNbXCJOVU1FUklDXCJdID0gMV0gPSBcIk5VTUVSSUNcIjtcbiAgICAgICAgTW9kZVZhbHVlc1tNb2RlVmFsdWVzW1wiQUxQSEFOVU1FUklDXCJdID0gMl0gPSBcIkFMUEhBTlVNRVJJQ1wiO1xuICAgICAgICBNb2RlVmFsdWVzW01vZGVWYWx1ZXNbXCJTVFJVQ1RVUkVEX0FQUEVORFwiXSA9IDNdID0gXCJTVFJVQ1RVUkVEX0FQUEVORFwiO1xuICAgICAgICBNb2RlVmFsdWVzW01vZGVWYWx1ZXNbXCJCWVRFXCJdID0gNF0gPSBcIkJZVEVcIjtcbiAgICAgICAgTW9kZVZhbHVlc1tNb2RlVmFsdWVzW1wiRUNJXCJdID0gNV0gPSBcIkVDSVwiO1xuICAgICAgICBNb2RlVmFsdWVzW01vZGVWYWx1ZXNbXCJLQU5KSVwiXSA9IDZdID0gXCJLQU5KSVwiO1xuICAgICAgICBNb2RlVmFsdWVzW01vZGVWYWx1ZXNbXCJGTkMxX0ZJUlNUX1BPU0lUSU9OXCJdID0gN10gPSBcIkZOQzFfRklSU1RfUE9TSVRJT05cIjtcbiAgICAgICAgTW9kZVZhbHVlc1tNb2RlVmFsdWVzW1wiRk5DMV9TRUNPTkRfUE9TSVRJT05cIl0gPSA4XSA9IFwiRk5DMV9TRUNPTkRfUE9TSVRJT05cIjtcbiAgICAgICAgLyoqIFNlZSBHQlQgMTgyODQtMjAwMDsgXCJIYW56aVwiIGlzIGEgdHJhbnNsaXRlcmF0aW9uIG9mIHRoaXMgbW9kZSBuYW1lLiAqL1xuICAgICAgICBNb2RlVmFsdWVzW01vZGVWYWx1ZXNbXCJIQU5aSVwiXSA9IDldID0gXCJIQU5aSVwiO1xuICAgIH0pKE1vZGVWYWx1ZXMgfHwgKE1vZGVWYWx1ZXMgPSB7fSkpO1xuICAgIC8qKlxuICAgICAqIDxwPlNlZSBJU08gMTgwMDQ6MjAwNiwgNi40LjEsIFRhYmxlcyAyIGFuZCAzLiBUaGlzIGVudW0gZW5jYXBzdWxhdGVzIHRoZSB2YXJpb3VzIG1vZGVzIGluIHdoaWNoXG4gICAgICogZGF0YSBjYW4gYmUgZW5jb2RlZCB0byBiaXRzIGluIHRoZSBRUiBjb2RlIHN0YW5kYXJkLjwvcD5cbiAgICAgKlxuICAgICAqIEBhdXRob3IgU2VhbiBPd2VuXG4gICAgICovXG4gICAgY2xhc3MgTW9kZSQxIHtcbiAgICAgICAgY29uc3RydWN0b3IodmFsdWUsIHN0cmluZ1ZhbHVlLCBjaGFyYWN0ZXJDb3VudEJpdHNGb3JWZXJzaW9ucywgYml0cyAvKmludCovKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLnN0cmluZ1ZhbHVlID0gc3RyaW5nVmFsdWU7XG4gICAgICAgICAgICB0aGlzLmNoYXJhY3RlckNvdW50Qml0c0ZvclZlcnNpb25zID0gY2hhcmFjdGVyQ291bnRCaXRzRm9yVmVyc2lvbnM7XG4gICAgICAgICAgICB0aGlzLmJpdHMgPSBiaXRzO1xuICAgICAgICAgICAgTW9kZSQxLkZPUl9CSVRTLnNldChiaXRzLCB0aGlzKTtcbiAgICAgICAgICAgIE1vZGUkMS5GT1JfVkFMVUUuc2V0KHZhbHVlLCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIGJpdHMgZm91ciBiaXRzIGVuY29kaW5nIGEgUVIgQ29kZSBkYXRhIG1vZGVcbiAgICAgICAgICogQHJldHVybiBNb2RlIGVuY29kZWQgYnkgdGhlc2UgYml0c1xuICAgICAgICAgKiBAdGhyb3dzIElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbiBpZiBiaXRzIGRvIG5vdCBjb3JyZXNwb25kIHRvIGEga25vd24gbW9kZVxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGZvckJpdHMoYml0cyAvKmludCovKSB7XG4gICAgICAgICAgICBjb25zdCBtb2RlID0gTW9kZSQxLkZPUl9CSVRTLmdldChiaXRzKTtcbiAgICAgICAgICAgIGlmICh1bmRlZmluZWQgPT09IG1vZGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbW9kZTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHZlcnNpb24gdmVyc2lvbiBpbiBxdWVzdGlvblxuICAgICAgICAgKiBAcmV0dXJuIG51bWJlciBvZiBiaXRzIHVzZWQsIGluIHRoaXMgUVIgQ29kZSBzeW1ib2wge0BsaW5rIFZlcnNpb259LCB0byBlbmNvZGUgdGhlXG4gICAgICAgICAqICAgICAgICAgY291bnQgb2YgY2hhcmFjdGVycyB0aGF0IHdpbGwgZm9sbG93IGVuY29kZWQgaW4gdGhpcyBNb2RlXG4gICAgICAgICAqL1xuICAgICAgICBnZXRDaGFyYWN0ZXJDb3VudEJpdHModmVyc2lvbikge1xuICAgICAgICAgICAgY29uc3QgdmVyc2lvbk51bWJlciA9IHZlcnNpb24uZ2V0VmVyc2lvbk51bWJlcigpO1xuICAgICAgICAgICAgbGV0IG9mZnNldDtcbiAgICAgICAgICAgIGlmICh2ZXJzaW9uTnVtYmVyIDw9IDkpIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmVyc2lvbk51bWJlciA8PSAyNikge1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hhcmFjdGVyQ291bnRCaXRzRm9yVmVyc2lvbnNbb2Zmc2V0XTtcbiAgICAgICAgfVxuICAgICAgICBnZXRWYWx1ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGdldEJpdHMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5iaXRzO1xuICAgICAgICB9XG4gICAgICAgIGVxdWFscyhvKSB7XG4gICAgICAgICAgICBpZiAoIShvIGluc3RhbmNlb2YgTW9kZSQxKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG90aGVyID0gbztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlID09PSBvdGhlci52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICB0b1N0cmluZygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0cmluZ1ZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIE1vZGUkMS5GT1JfQklUUyA9IG5ldyBNYXAoKTtcbiAgICBNb2RlJDEuRk9SX1ZBTFVFID0gbmV3IE1hcCgpO1xuICAgIE1vZGUkMS5URVJNSU5BVE9SID0gbmV3IE1vZGUkMShNb2RlVmFsdWVzLlRFUk1JTkFUT1IsICdURVJNSU5BVE9SJywgSW50MzJBcnJheS5mcm9tKFswLCAwLCAwXSksIDB4MDApOyAvLyBOb3QgcmVhbGx5IGEgbW9kZS4uLlxuICAgIE1vZGUkMS5OVU1FUklDID0gbmV3IE1vZGUkMShNb2RlVmFsdWVzLk5VTUVSSUMsICdOVU1FUklDJywgSW50MzJBcnJheS5mcm9tKFsxMCwgMTIsIDE0XSksIDB4MDEpO1xuICAgIE1vZGUkMS5BTFBIQU5VTUVSSUMgPSBuZXcgTW9kZSQxKE1vZGVWYWx1ZXMuQUxQSEFOVU1FUklDLCAnQUxQSEFOVU1FUklDJywgSW50MzJBcnJheS5mcm9tKFs5LCAxMSwgMTNdKSwgMHgwMik7XG4gICAgTW9kZSQxLlNUUlVDVFVSRURfQVBQRU5EID0gbmV3IE1vZGUkMShNb2RlVmFsdWVzLlNUUlVDVFVSRURfQVBQRU5ELCAnU1RSVUNUVVJFRF9BUFBFTkQnLCBJbnQzMkFycmF5LmZyb20oWzAsIDAsIDBdKSwgMHgwMyk7IC8vIE5vdCBzdXBwb3J0ZWRcbiAgICBNb2RlJDEuQllURSA9IG5ldyBNb2RlJDEoTW9kZVZhbHVlcy5CWVRFLCAnQllURScsIEludDMyQXJyYXkuZnJvbShbOCwgMTYsIDE2XSksIDB4MDQpO1xuICAgIE1vZGUkMS5FQ0kgPSBuZXcgTW9kZSQxKE1vZGVWYWx1ZXMuRUNJLCAnRUNJJywgSW50MzJBcnJheS5mcm9tKFswLCAwLCAwXSksIDB4MDcpOyAvLyBjaGFyYWN0ZXIgY291bnRzIGRvbid0IGFwcGx5XG4gICAgTW9kZSQxLktBTkpJID0gbmV3IE1vZGUkMShNb2RlVmFsdWVzLktBTkpJLCAnS0FOSkknLCBJbnQzMkFycmF5LmZyb20oWzgsIDEwLCAxMl0pLCAweDA4KTtcbiAgICBNb2RlJDEuRk5DMV9GSVJTVF9QT1NJVElPTiA9IG5ldyBNb2RlJDEoTW9kZVZhbHVlcy5GTkMxX0ZJUlNUX1BPU0lUSU9OLCAnRk5DMV9GSVJTVF9QT1NJVElPTicsIEludDMyQXJyYXkuZnJvbShbMCwgMCwgMF0pLCAweDA1KTtcbiAgICBNb2RlJDEuRk5DMV9TRUNPTkRfUE9TSVRJT04gPSBuZXcgTW9kZSQxKE1vZGVWYWx1ZXMuRk5DMV9TRUNPTkRfUE9TSVRJT04sICdGTkMxX1NFQ09ORF9QT1NJVElPTicsIEludDMyQXJyYXkuZnJvbShbMCwgMCwgMF0pLCAweDA5KTtcbiAgICAvKiogU2VlIEdCVCAxODI4NC0yMDAwOyBcIkhhbnppXCIgaXMgYSB0cmFuc2xpdGVyYXRpb24gb2YgdGhpcyBtb2RlIG5hbWUuICovXG4gICAgTW9kZSQxLkhBTlpJID0gbmV3IE1vZGUkMShNb2RlVmFsdWVzLkhBTlpJLCAnSEFOWkknLCBJbnQzMkFycmF5LmZyb20oWzgsIDEwLCAxMl0pLCAweDBEKTtcblxuICAgIC8qXG4gICAgICogQ29weXJpZ2h0IDIwMDcgWlhpbmcgYXV0aG9yc1xuICAgICAqXG4gICAgICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgICAgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICAgICpcbiAgICAgKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICAgICAqXG4gICAgICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICAgICAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgICAgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgICAgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gICAgICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gICAgICovXG4gICAgLyppbXBvcnQgamF2YS5pby5VbnN1cHBvcnRlZEVuY29kaW5nRXhjZXB0aW9uOyovXG4gICAgLyppbXBvcnQgamF2YS51dGlsLkFycmF5TGlzdDsqL1xuICAgIC8qaW1wb3J0IGphdmEudXRpbC5Db2xsZWN0aW9uOyovXG4gICAgLyppbXBvcnQgamF2YS51dGlsLkxpc3Q7Ki9cbiAgICAvKmltcG9ydCBqYXZhLnV0aWwuTWFwOyovXG4gICAgLyoqXG4gICAgICogPHA+UVIgQ29kZXMgY2FuIGVuY29kZSB0ZXh0IGFzIGJpdHMgaW4gb25lIG9mIHNldmVyYWwgbW9kZXMsIGFuZCBjYW4gdXNlIG11bHRpcGxlIG1vZGVzXG4gICAgICogaW4gb25lIFFSIENvZGUuIFRoaXMgY2xhc3MgZGVjb2RlcyB0aGUgYml0cyBiYWNrIGludG8gdGV4dC48L3A+XG4gICAgICpcbiAgICAgKiA8cD5TZWUgSVNPIDE4MDA0OjIwMDYsIDYuNC4zIC0gNi40Ljc8L3A+XG4gICAgICpcbiAgICAgKiBAYXV0aG9yIFNlYW4gT3dlblxuICAgICAqL1xuICAgIGNsYXNzIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMSB7XG4gICAgICAgIHN0YXRpYyBkZWNvZGUoYnl0ZXMsIHZlcnNpb24sIGVjTGV2ZWwsIGhpbnRzKSB7XG4gICAgICAgICAgICBjb25zdCBiaXRzID0gbmV3IEJpdFNvdXJjZShieXRlcyk7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gbmV3IFN0cmluZ0J1aWxkZXIoKTtcbiAgICAgICAgICAgIGNvbnN0IGJ5dGVTZWdtZW50cyA9IG5ldyBBcnJheSgpOyAvLyAxXG4gICAgICAgICAgICAvLyBUWVBFU0NSSVBUUE9SVDogSSBkbyBub3QgdXNlIGNvbnN0cnVjdG9yIHdpdGggc2l6ZSAxIGFzIGluIG9yaWdpbmFsIEphdmEgbWVhbnMgY2FwYWNpdHkgYW5kIHRoZSBhcnJheSBsZW5ndGggaXMgY2hlY2tlZCBiZWxvd1xuICAgICAgICAgICAgbGV0IHN5bWJvbFNlcXVlbmNlID0gLTE7XG4gICAgICAgICAgICBsZXQgcGFyaXR5RGF0YSA9IC0xO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBsZXQgY3VycmVudENoYXJhY3RlclNldEVDSSA9IG51bGw7XG4gICAgICAgICAgICAgICAgbGV0IGZjMUluRWZmZWN0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgbGV0IG1vZGU7XG4gICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICAvLyBXaGlsZSBzdGlsbCBhbm90aGVyIHNlZ21lbnQgdG8gcmVhZC4uLlxuICAgICAgICAgICAgICAgICAgICBpZiAoYml0cy5hdmFpbGFibGUoKSA8IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9LLCBhc3N1bWUgd2UncmUgZG9uZS4gUmVhbGx5LCBhIFRFUk1JTkFUT1IgbW9kZSBzaG91bGQgaGF2ZSBiZWVuIHJlY29yZGVkIGhlcmVcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGUgPSBNb2RlJDEuVEVSTUlOQVRPUjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1vZGVCaXRzID0gYml0cy5yZWFkQml0cyg0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGUgPSBNb2RlJDEuZm9yQml0cyhtb2RlQml0cyk7IC8vIG1vZGUgaXMgZW5jb2RlZCBieSA0IGJpdHNcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKG1vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgTW9kZSQxLlRFUk1JTkFUT1I6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIE1vZGUkMS5GTkMxX0ZJUlNUX1BPU0lUSU9OOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBNb2RlJDEuRk5DMV9TRUNPTkRfUE9TSVRJT046XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgZG8gbGl0dGxlIHdpdGggRk5DMSBleGNlcHQgYWx0ZXIgdGhlIHBhcnNlZCByZXN1bHQgYSBiaXQgYWNjb3JkaW5nIHRvIHRoZSBzcGVjXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmMxSW5FZmZlY3QgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBNb2RlJDEuU1RSVUNUVVJFRF9BUFBFTkQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJpdHMuYXZhaWxhYmxlKCkgPCAxNikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNlcXVlbmNlIG51bWJlciBhbmQgcGFyaXR5IGlzIGFkZGVkIGxhdGVyIHRvIHRoZSByZXN1bHQgbWV0YWRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZWFkIG5leHQgOCBiaXRzIChzeW1ib2wgc2VxdWVuY2UgIykgYW5kIDggYml0cyAoZGF0YTogcGFyaXR5KSwgdGhlbiBjb250aW51ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbFNlcXVlbmNlID0gYml0cy5yZWFkQml0cyg4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJpdHlEYXRhID0gYml0cy5yZWFkQml0cyg4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgTW9kZSQxLkVDSTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDb3VudCBkb2Vzbid0IGFwcGx5IHRvIEVDSVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQxLnBhcnNlRUNJVmFsdWUoYml0cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudENoYXJhY3RlclNldEVDSSA9IENoYXJhY3RlclNldEVDSS5nZXRDaGFyYWN0ZXJTZXRFQ0lCeVZhbHVlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudENoYXJhY3RlclNldEVDSSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBNb2RlJDEuSEFOWkk6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmlyc3QgaGFuZGxlIEhhbnppIG1vZGUgd2hpY2ggZG9lcyBub3Qgc3RhcnQgd2l0aCBjaGFyYWN0ZXIgY291bnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGluZXNlIG1vZGUgY29udGFpbnMgYSBzdWIgc2V0IGluZGljYXRvciByaWdodCBhZnRlciBtb2RlIGluZGljYXRvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHN1YnNldCA9IGJpdHMucmVhZEJpdHMoNCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY291bnRIYW56aSA9IGJpdHMucmVhZEJpdHMobW9kZS5nZXRDaGFyYWN0ZXJDb3VudEJpdHModmVyc2lvbikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdWJzZXQgPT09IERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMS5HQjIzMTJfU1VCU0VUKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMS5kZWNvZGVIYW56aVNlZ21lbnQoYml0cywgcmVzdWx0LCBjb3VudEhhbnppKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFwiTm9ybWFsXCIgUVIgY29kZSBtb2RlczpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBIb3cgbWFueSBjaGFyYWN0ZXJzIHdpbGwgZm9sbG93LCBlbmNvZGVkIGluIHRoaXMgbW9kZT9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb3VudCA9IGJpdHMucmVhZEJpdHMobW9kZS5nZXRDaGFyYWN0ZXJDb3VudEJpdHModmVyc2lvbikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAobW9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIE1vZGUkMS5OVU1FUklDOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQxLmRlY29kZU51bWVyaWNTZWdtZW50KGJpdHMsIHJlc3VsdCwgY291bnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgTW9kZSQxLkFMUEhBTlVNRVJJQzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMS5kZWNvZGVBbHBoYW51bWVyaWNTZWdtZW50KGJpdHMsIHJlc3VsdCwgY291bnQsIGZjMUluRWZmZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIE1vZGUkMS5CWVRFOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQxLmRlY29kZUJ5dGVTZWdtZW50KGJpdHMsIHJlc3VsdCwgY291bnQsIGN1cnJlbnRDaGFyYWN0ZXJTZXRFQ0ksIGJ5dGVTZWdtZW50cywgaGludHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgTW9kZSQxLktBTkpJOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQxLmRlY29kZUthbmppU2VnbWVudChiaXRzLCByZXN1bHQsIGNvdW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gd2hpbGUgKG1vZGUgIT09IE1vZGUkMS5URVJNSU5BVE9SKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChpYWUgLyo6IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbiovKSB7XG4gICAgICAgICAgICAgICAgLy8gZnJvbSByZWFkQml0cygpIGNhbGxzXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBEZWNvZGVyUmVzdWx0KGJ5dGVzLCByZXN1bHQudG9TdHJpbmcoKSwgYnl0ZVNlZ21lbnRzLmxlbmd0aCA9PT0gMCA/IG51bGwgOiBieXRlU2VnbWVudHMsIGVjTGV2ZWwgPT09IG51bGwgPyBudWxsIDogZWNMZXZlbC50b1N0cmluZygpLCBzeW1ib2xTZXF1ZW5jZSwgcGFyaXR5RGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNlZSBzcGVjaWZpY2F0aW9uIEdCVCAxODI4NC0yMDAwXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgZGVjb2RlSGFuemlTZWdtZW50KGJpdHMsIHJlc3VsdCwgY291bnQgLyppbnQqLykge1xuICAgICAgICAgICAgLy8gRG9uJ3QgY3Jhc2ggdHJ5aW5nIHRvIHJlYWQgbW9yZSBiaXRzIHRoYW4gd2UgaGF2ZSBhdmFpbGFibGUuXG4gICAgICAgICAgICBpZiAoY291bnQgKiAxMyA+IGJpdHMuYXZhaWxhYmxlKCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBFYWNoIGNoYXJhY3RlciB3aWxsIHJlcXVpcmUgMiBieXRlcy4gUmVhZCB0aGUgY2hhcmFjdGVycyBhcyAyLWJ5dGUgcGFpcnNcbiAgICAgICAgICAgIC8vIGFuZCBkZWNvZGUgYXMgR0IyMzEyIGFmdGVyd2FyZHNcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KDIgKiBjb3VudCk7XG4gICAgICAgICAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIHdoaWxlIChjb3VudCA+IDApIHtcbiAgICAgICAgICAgICAgICAvLyBFYWNoIDEzIGJpdHMgZW5jb2RlcyBhIDItYnl0ZSBjaGFyYWN0ZXJcbiAgICAgICAgICAgICAgICBjb25zdCB0d29CeXRlcyA9IGJpdHMucmVhZEJpdHMoMTMpO1xuICAgICAgICAgICAgICAgIGxldCBhc3NlbWJsZWRUd29CeXRlcyA9ICgoKHR3b0J5dGVzIC8gMHgwNjApIDw8IDgpICYgMHhGRkZGRkZGRikgfCAodHdvQnl0ZXMgJSAweDA2MCk7XG4gICAgICAgICAgICAgICAgaWYgKGFzc2VtYmxlZFR3b0J5dGVzIDwgMHgwMDNCRikge1xuICAgICAgICAgICAgICAgICAgICAvLyBJbiB0aGUgMHhBMUExIHRvIDB4QUFGRSByYW5nZVxuICAgICAgICAgICAgICAgICAgICBhc3NlbWJsZWRUd29CeXRlcyArPSAweDBBMUExO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSW4gdGhlIDB4QjBBMSB0byAweEZBRkUgcmFuZ2VcbiAgICAgICAgICAgICAgICAgICAgYXNzZW1ibGVkVHdvQnl0ZXMgKz0gMHgwQTZBMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnVmZmVyW29mZnNldF0gPSAvKihieXRlKSAqLyAoKGFzc2VtYmxlZFR3b0J5dGVzID4+IDgpICYgMHhGRik7XG4gICAgICAgICAgICAgICAgYnVmZmVyW29mZnNldCArIDFdID0gLyooYnl0ZSkgKi8gKGFzc2VtYmxlZFR3b0J5dGVzICYgMHhGRik7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IDI7XG4gICAgICAgICAgICAgICAgY291bnQtLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZChTdHJpbmdFbmNvZGluZy5kZWNvZGUoYnVmZmVyLCBTdHJpbmdVdGlscy5HQjIzMTIpKTtcbiAgICAgICAgICAgICAgICAvLyBUWVBFU0NSSVBUUE9SVDogVE9ETzogaW1wbGVtZW50IEdCMjMxMiBkZWNvZGUuIFN0cmluZ1ZpZXcgZnJvbSBNRE4gY291bGQgYmUgYSBzdGFydGluZyBwb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGlnbm9yZWQgLyo6IFVuc3VwcG9ydGVkRW5jb2RpbmdFeGNlcHRpb24qLykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb24oaWdub3JlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGRlY29kZUthbmppU2VnbWVudChiaXRzLCByZXN1bHQsIGNvdW50IC8qaW50Ki8pIHtcbiAgICAgICAgICAgIC8vIERvbid0IGNyYXNoIHRyeWluZyB0byByZWFkIG1vcmUgYml0cyB0aGFuIHdlIGhhdmUgYXZhaWxhYmxlLlxuICAgICAgICAgICAgaWYgKGNvdW50ICogMTMgPiBiaXRzLmF2YWlsYWJsZSgpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRWFjaCBjaGFyYWN0ZXIgd2lsbCByZXF1aXJlIDIgYnl0ZXMuIFJlYWQgdGhlIGNoYXJhY3RlcnMgYXMgMi1ieXRlIHBhaXJzXG4gICAgICAgICAgICAvLyBhbmQgZGVjb2RlIGFzIFNoaWZ0X0pJUyBhZnRlcndhcmRzXG4gICAgICAgICAgICBjb25zdCBidWZmZXIgPSBuZXcgVWludDhBcnJheSgyICogY291bnQpO1xuICAgICAgICAgICAgbGV0IG9mZnNldCA9IDA7XG4gICAgICAgICAgICB3aGlsZSAoY291bnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgLy8gRWFjaCAxMyBiaXRzIGVuY29kZXMgYSAyLWJ5dGUgY2hhcmFjdGVyXG4gICAgICAgICAgICAgICAgY29uc3QgdHdvQnl0ZXMgPSBiaXRzLnJlYWRCaXRzKDEzKTtcbiAgICAgICAgICAgICAgICBsZXQgYXNzZW1ibGVkVHdvQnl0ZXMgPSAoKCh0d29CeXRlcyAvIDB4MEMwKSA8PCA4KSAmIDB4RkZGRkZGRkYpIHwgKHR3b0J5dGVzICUgMHgwQzApO1xuICAgICAgICAgICAgICAgIGlmIChhc3NlbWJsZWRUd29CeXRlcyA8IDB4MDFGMDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSW4gdGhlIDB4ODE0MCB0byAweDlGRkMgcmFuZ2VcbiAgICAgICAgICAgICAgICAgICAgYXNzZW1ibGVkVHdvQnl0ZXMgKz0gMHgwODE0MDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEluIHRoZSAweEUwNDAgdG8gMHhFQkJGIHJhbmdlXG4gICAgICAgICAgICAgICAgICAgIGFzc2VtYmxlZFR3b0J5dGVzICs9IDB4MEMxNDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXRdID0gLyooYnl0ZSkgKi8gKGFzc2VtYmxlZFR3b0J5dGVzID4+IDgpO1xuICAgICAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQgKyAxXSA9IC8qKGJ5dGUpICovIGFzc2VtYmxlZFR3b0J5dGVzO1xuICAgICAgICAgICAgICAgIG9mZnNldCArPSAyO1xuICAgICAgICAgICAgICAgIGNvdW50LS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTaGlmdF9KSVMgbWF5IG5vdCBiZSBzdXBwb3J0ZWQgaW4gc29tZSBlbnZpcm9ubWVudHM6XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoU3RyaW5nRW5jb2RpbmcuZGVjb2RlKGJ1ZmZlciwgU3RyaW5nVXRpbHMuU0hJRlRfSklTKSk7XG4gICAgICAgICAgICAgICAgLy8gVFlQRVNDUklQVFBPUlQ6IFRPRE86IGltcGxlbWVudCBTSElGVF9KSVMgZGVjb2RlLiBTdHJpbmdWaWV3IGZyb20gTUROIGNvdWxkIGJlIGEgc3RhcnRpbmcgcG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChpZ25vcmVkIC8qOiBVbnN1cHBvcnRlZEVuY29kaW5nRXhjZXB0aW9uKi8pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uKGlnbm9yZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBkZWNvZGVCeXRlU2VnbWVudChiaXRzLCByZXN1bHQsIGNvdW50IC8qaW50Ki8sIGN1cnJlbnRDaGFyYWN0ZXJTZXRFQ0ksIGJ5dGVTZWdtZW50cywgaGludHMpIHtcbiAgICAgICAgICAgIC8vIERvbid0IGNyYXNoIHRyeWluZyB0byByZWFkIG1vcmUgYml0cyB0aGFuIHdlIGhhdmUgYXZhaWxhYmxlLlxuICAgICAgICAgICAgaWYgKDggKiBjb3VudCA+IGJpdHMuYXZhaWxhYmxlKCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZWFkQnl0ZXMgPSBuZXcgVWludDhBcnJheShjb3VudCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgICAgICAgICByZWFkQnl0ZXNbaV0gPSAvKihieXRlKSAqLyBiaXRzLnJlYWRCaXRzKDgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGVuY29kaW5nO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRDaGFyYWN0ZXJTZXRFQ0kgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgc3BlYyBpc24ndCBjbGVhciBvbiB0aGlzIG1vZGU7IHNlZVxuICAgICAgICAgICAgICAgIC8vIHNlY3Rpb24gNi40LjU6IHQgZG9lcyBub3Qgc2F5IHdoaWNoIGVuY29kaW5nIHRvIGFzc3VtaW5nXG4gICAgICAgICAgICAgICAgLy8gdXBvbiBkZWNvZGluZy4gSSBoYXZlIHNlZW4gSVNPLTg4NTktMSB1c2VkIGFzIHdlbGwgYXNcbiAgICAgICAgICAgICAgICAvLyBTaGlmdF9KSVMgLS0gd2l0aG91dCBhbnl0aGluZyBsaWtlIGFuIEVDSSBkZXNpZ25hdG9yIHRvXG4gICAgICAgICAgICAgICAgLy8gZ2l2ZSBhIGhpbnQuXG4gICAgICAgICAgICAgICAgZW5jb2RpbmcgPSBTdHJpbmdVdGlscy5ndWVzc0VuY29kaW5nKHJlYWRCeXRlcywgaGludHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZW5jb2RpbmcgPSBjdXJyZW50Q2hhcmFjdGVyU2V0RUNJLmdldE5hbWUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZChTdHJpbmdFbmNvZGluZy5kZWNvZGUocmVhZEJ5dGVzLCBlbmNvZGluZykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGlnbm9yZWQgLyo6IFVuc3VwcG9ydGVkRW5jb2RpbmdFeGNlcHRpb24qLykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb24oaWdub3JlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBieXRlU2VnbWVudHMucHVzaChyZWFkQnl0ZXMpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyB0b0FscGhhTnVtZXJpY0NoYXIodmFsdWUgLyppbnQqLykge1xuICAgICAgICAgICAgaWYgKHZhbHVlID49IERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMS5BTFBIQU5VTUVSSUNfQ0hBUlMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMS5BTFBIQU5VTUVSSUNfQ0hBUlNbdmFsdWVdO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBkZWNvZGVBbHBoYW51bWVyaWNTZWdtZW50KGJpdHMsIHJlc3VsdCwgY291bnQgLyppbnQqLywgZmMxSW5FZmZlY3QpIHtcbiAgICAgICAgICAgIC8vIFJlYWQgdHdvIGNoYXJhY3RlcnMgYXQgYSB0aW1lXG4gICAgICAgICAgICBjb25zdCBzdGFydCA9IHJlc3VsdC5sZW5ndGgoKTtcbiAgICAgICAgICAgIHdoaWxlIChjb3VudCA+IDEpIHtcbiAgICAgICAgICAgICAgICBpZiAoYml0cy5hdmFpbGFibGUoKSA8IDExKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dFR3b0NoYXJzQml0cyA9IGJpdHMucmVhZEJpdHMoMTEpO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQxLnRvQWxwaGFOdW1lcmljQ2hhcihNYXRoLmZsb29yKG5leHRUd29DaGFyc0JpdHMgLyA0NSkpKTtcbiAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMS50b0FscGhhTnVtZXJpY0NoYXIobmV4dFR3b0NoYXJzQml0cyAlIDQ1KSk7XG4gICAgICAgICAgICAgICAgY291bnQgLT0gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb3VudCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIC8vIHNwZWNpYWwgY2FzZTogb25lIGNoYXJhY3RlciBsZWZ0XG4gICAgICAgICAgICAgICAgaWYgKGJpdHMuYXZhaWxhYmxlKCkgPCA2KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZChEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDEudG9BbHBoYU51bWVyaWNDaGFyKGJpdHMucmVhZEJpdHMoNikpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNlZSBzZWN0aW9uIDYuNC44LjEsIDYuNC44LjJcbiAgICAgICAgICAgIGlmIChmYzFJbkVmZmVjdCkge1xuICAgICAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gbWFzc2FnZSB0aGUgcmVzdWx0IGEgYml0IGlmIGluIGFuIEZOQzEgbW9kZTpcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCByZXN1bHQubGVuZ3RoKCk7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0LmNoYXJBdChpKSA9PT0gJyUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSA8IHJlc3VsdC5sZW5ndGgoKSAtIDEgJiYgcmVzdWx0LmNoYXJBdChpICsgMSkgPT09ICclJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICUlIGlzIHJlbmRlcmVkIGFzICVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuZGVsZXRlQ2hhckF0KGkgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEluIGFscGhhIG1vZGUsICUgc2hvdWxkIGJlIGNvbnZlcnRlZCB0byBGTkMxIHNlcGFyYXRvciAweDFEXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnNldENoYXJBdChpLCBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4MUQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgZGVjb2RlTnVtZXJpY1NlZ21lbnQoYml0cywgcmVzdWx0LCBjb3VudCAvKmludCovKSB7XG4gICAgICAgICAgICAvLyBSZWFkIHRocmVlIGRpZ2l0cyBhdCBhIHRpbWVcbiAgICAgICAgICAgIHdoaWxlIChjb3VudCA+PSAzKSB7XG4gICAgICAgICAgICAgICAgLy8gRWFjaCAxMCBiaXRzIGVuY29kZXMgdGhyZWUgZGlnaXRzXG4gICAgICAgICAgICAgICAgaWYgKGJpdHMuYXZhaWxhYmxlKCkgPCAxMCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHRocmVlRGlnaXRzQml0cyA9IGJpdHMucmVhZEJpdHMoMTApO1xuICAgICAgICAgICAgICAgIGlmICh0aHJlZURpZ2l0c0JpdHMgPj0gMTAwMCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQxLnRvQWxwaGFOdW1lcmljQ2hhcihNYXRoLmZsb29yKHRocmVlRGlnaXRzQml0cyAvIDEwMCkpKTtcbiAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMS50b0FscGhhTnVtZXJpY0NoYXIoTWF0aC5mbG9vcih0aHJlZURpZ2l0c0JpdHMgLyAxMCkgJSAxMCkpO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQxLnRvQWxwaGFOdW1lcmljQ2hhcih0aHJlZURpZ2l0c0JpdHMgJSAxMCkpO1xuICAgICAgICAgICAgICAgIGNvdW50IC09IDM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY291bnQgPT09IDIpIHtcbiAgICAgICAgICAgICAgICAvLyBUd28gZGlnaXRzIGxlZnQgb3ZlciB0byByZWFkLCBlbmNvZGVkIGluIDcgYml0c1xuICAgICAgICAgICAgICAgIGlmIChiaXRzLmF2YWlsYWJsZSgpIDwgNykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHR3b0RpZ2l0c0JpdHMgPSBiaXRzLnJlYWRCaXRzKDcpO1xuICAgICAgICAgICAgICAgIGlmICh0d29EaWdpdHNCaXRzID49IDEwMCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQxLnRvQWxwaGFOdW1lcmljQ2hhcihNYXRoLmZsb29yKHR3b0RpZ2l0c0JpdHMgLyAxMCkpKTtcbiAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMS50b0FscGhhTnVtZXJpY0NoYXIodHdvRGlnaXRzQml0cyAlIDEwKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjb3VudCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIC8vIE9uZSBkaWdpdCBsZWZ0IG92ZXIgdG8gcmVhZFxuICAgICAgICAgICAgICAgIGlmIChiaXRzLmF2YWlsYWJsZSgpIDwgNCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGRpZ2l0Qml0cyA9IGJpdHMucmVhZEJpdHMoNCk7XG4gICAgICAgICAgICAgICAgaWYgKGRpZ2l0Qml0cyA+PSAxMCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQxLnRvQWxwaGFOdW1lcmljQ2hhcihkaWdpdEJpdHMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgcGFyc2VFQ0lWYWx1ZShiaXRzKSB7XG4gICAgICAgICAgICBjb25zdCBmaXJzdEJ5dGUgPSBiaXRzLnJlYWRCaXRzKDgpO1xuICAgICAgICAgICAgaWYgKChmaXJzdEJ5dGUgJiAweDgwKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIGp1c3Qgb25lIGJ5dGVcbiAgICAgICAgICAgICAgICByZXR1cm4gZmlyc3RCeXRlICYgMHg3RjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoZmlyc3RCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgICAgICAvLyB0d28gYnl0ZXNcbiAgICAgICAgICAgICAgICBjb25zdCBzZWNvbmRCeXRlID0gYml0cy5yZWFkQml0cyg4KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKCgoZmlyc3RCeXRlICYgMHgzRikgPDwgOCkgJiAweEZGRkZGRkZGKSB8IHNlY29uZEJ5dGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKGZpcnN0Qnl0ZSAmIDB4RTApID09PSAweEMwKSB7XG4gICAgICAgICAgICAgICAgLy8gdGhyZWUgYnl0ZXNcbiAgICAgICAgICAgICAgICBjb25zdCBzZWNvbmRUaGlyZEJ5dGVzID0gYml0cy5yZWFkQml0cygxNik7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgoKGZpcnN0Qnl0ZSAmIDB4MUYpIDw8IDE2KSAmIDB4RkZGRkZGRkYpIHwgc2Vjb25kVGhpcmRCeXRlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb24oKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZWUgSVNPIDE4MDA0OjIwMDYsIDYuNC40IFRhYmxlIDVcbiAgICAgKi9cbiAgICBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDEuQUxQSEFOVU1FUklDX0NIQVJTID0gJzAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWiAkJSorLS4vOic7XG4gICAgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQxLkdCMjMxMl9TVUJTRVQgPSAxO1xuICAgIC8vIGZ1bmN0aW9uIFVpbnQ4QXJyYXlUb1N0cmluZyhhOiBVaW50OEFycmF5KTogc3RyaW5nIHtcbiAgICAvLyAgICAgY29uc3QgQ0hVTktfU1ogPSAweDgwMDA7XG4gICAgLy8gICAgIGNvbnN0IGMgPSBuZXcgU3RyaW5nQnVpbGRlcigpO1xuICAgIC8vICAgICBmb3IgKGxldCBpID0gMCwgbGVuZ3RoID0gYS5sZW5ndGg7IGkgPCBsZW5ndGg7IGkgKz0gQ0hVTktfU1opIHtcbiAgICAvLyAgICAgICAgIGMuYXBwZW5kKFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgYS5zdWJhcnJheShpLCBpICsgQ0hVTktfU1opKSk7XG4gICAgLy8gICAgIH1cbiAgICAvLyAgICAgcmV0dXJuIGMudG9TdHJpbmcoKTtcbiAgICAvLyB9XG5cbiAgICAvKlxuICAgICAqIENvcHlyaWdodCAyMDEzIFpYaW5nIGF1dGhvcnNcbiAgICAgKlxuICAgICAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gICAgICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgICAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgICAqXG4gICAgICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAgICAgKlxuICAgICAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgICAgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICAgICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gICAgICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICAgICAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIE1ldGEtZGF0YSBjb250YWluZXIgZm9yIFFSIENvZGUgZGVjb2RpbmcuIEluc3RhbmNlcyBvZiB0aGlzIGNsYXNzIG1heSBiZSB1c2VkIHRvIGNvbnZleSBpbmZvcm1hdGlvbiBiYWNrIHRvIHRoZVxuICAgICAqIGRlY29kaW5nIGNhbGxlci4gQ2FsbGVycyBhcmUgZXhwZWN0ZWQgdG8gcHJvY2VzcyB0aGlzLlxuICAgICAqXG4gICAgICogQHNlZSBjb20uZ29vZ2xlLnp4aW5nLmNvbW1vbi5EZWNvZGVyUmVzdWx0I2dldE90aGVyKClcbiAgICAgKi9cbiAgICBjbGFzcyBRUkNvZGVEZWNvZGVyTWV0YURhdGEge1xuICAgICAgICBjb25zdHJ1Y3RvcihtaXJyb3JlZCkge1xuICAgICAgICAgICAgdGhpcy5taXJyb3JlZCA9IG1pcnJvcmVkO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHRydWUgaWYgdGhlIFFSIENvZGUgd2FzIG1pcnJvcmVkLlxuICAgICAgICAgKi9cbiAgICAgICAgaXNNaXJyb3JlZCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1pcnJvcmVkO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBcHBseSB0aGUgcmVzdWx0IHBvaW50cycgb3JkZXIgY29ycmVjdGlvbiBkdWUgdG8gbWlycm9yaW5nLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gcG9pbnRzIEFycmF5IG9mIHBvaW50cyB0byBhcHBseSBtaXJyb3IgY29ycmVjdGlvbiB0by5cbiAgICAgICAgICovXG4gICAgICAgIGFwcGx5TWlycm9yZWRDb3JyZWN0aW9uKHBvaW50cykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLm1pcnJvcmVkIHx8IHBvaW50cyA9PT0gbnVsbCB8fCBwb2ludHMubGVuZ3RoIDwgMykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGJvdHRvbUxlZnQgPSBwb2ludHNbMF07XG4gICAgICAgICAgICBwb2ludHNbMF0gPSBwb2ludHNbMl07XG4gICAgICAgICAgICBwb2ludHNbMl0gPSBib3R0b21MZWZ0O1xuICAgICAgICAgICAgLy8gTm8gbmVlZCB0byAnZml4JyB0b3AtbGVmdCBhbmQgYWxpZ25tZW50IHBhdHRlcm4uXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKlxuICAgICAqIENvcHlyaWdodCAyMDA3IFpYaW5nIGF1dGhvcnNcbiAgICAgKlxuICAgICAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gICAgICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgICAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgICAqXG4gICAgICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAgICAgKlxuICAgICAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgICAgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICAgICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gICAgICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICAgICAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICAgICAqL1xuICAgIC8qaW1wb3J0IGphdmEudXRpbC5NYXA7Ki9cbiAgICAvKipcbiAgICAgKiA8cD5UaGUgbWFpbiBjbGFzcyB3aGljaCBpbXBsZW1lbnRzIFFSIENvZGUgZGVjb2RpbmcgLS0gYXMgb3Bwb3NlZCB0byBsb2NhdGluZyBhbmQgZXh0cmFjdGluZ1xuICAgICAqIHRoZSBRUiBDb2RlIGZyb20gYW4gaW1hZ2UuPC9wPlxuICAgICAqXG4gICAgICogQGF1dGhvciBTZWFuIE93ZW5cbiAgICAgKi9cbiAgICBjbGFzcyBEZWNvZGVyJDIge1xuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgICAgIHRoaXMucnNEZWNvZGVyID0gbmV3IFJlZWRTb2xvbW9uRGVjb2RlcihHZW5lcmljR0YuUVJfQ09ERV9GSUVMRF8yNTYpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHB1YmxpYyBkZWNvZGUoaW1hZ2U6IGJvb2xlYW5bXVtdKTogRGVjb2RlclJlc3VsdCAvKnRocm93cyBDaGVja3N1bUV4Y2VwdGlvbiwgRm9ybWF0RXhjZXB0aW9uKi8ge1xuICAgICAgICAvLyAgIHJldHVybiBkZWNvZGUoaW1hZ2UsIG51bGwpXG4gICAgICAgIC8vIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIDxwPkNvbnZlbmllbmNlIG1ldGhvZCB0aGF0IGNhbiBkZWNvZGUgYSBRUiBDb2RlIHJlcHJlc2VudGVkIGFzIGEgMkQgYXJyYXkgb2YgYm9vbGVhbnMuXG4gICAgICAgICAqIFwidHJ1ZVwiIGlzIHRha2VuIHRvIG1lYW4gYSBibGFjayBtb2R1bGUuPC9wPlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gaW1hZ2UgYm9vbGVhbnMgcmVwcmVzZW50aW5nIHdoaXRlL2JsYWNrIFFSIENvZGUgbW9kdWxlc1xuICAgICAgICAgKiBAcGFyYW0gaGludHMgZGVjb2RpbmcgaGludHMgdGhhdCBzaG91bGQgYmUgdXNlZCB0byBpbmZsdWVuY2UgZGVjb2RpbmdcbiAgICAgICAgICogQHJldHVybiB0ZXh0IGFuZCBieXRlcyBlbmNvZGVkIHdpdGhpbiB0aGUgUVIgQ29kZVxuICAgICAgICAgKiBAdGhyb3dzIEZvcm1hdEV4Y2VwdGlvbiBpZiB0aGUgUVIgQ29kZSBjYW5ub3QgYmUgZGVjb2RlZFxuICAgICAgICAgKiBAdGhyb3dzIENoZWNrc3VtRXhjZXB0aW9uIGlmIGVycm9yIGNvcnJlY3Rpb24gZmFpbHNcbiAgICAgICAgICovXG4gICAgICAgIGRlY29kZUJvb2xlYW5BcnJheShpbWFnZSwgaGludHMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlY29kZUJpdE1hdHJpeChCaXRNYXRyaXgucGFyc2VGcm9tQm9vbGVhbkFycmF5KGltYWdlKSwgaGludHMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHB1YmxpYyBkZWNvZGVCaXRNYXRyaXgoYml0czogQml0TWF0cml4KTogRGVjb2RlclJlc3VsdCAvKnRocm93cyBDaGVja3N1bUV4Y2VwdGlvbiwgRm9ybWF0RXhjZXB0aW9uKi8ge1xuICAgICAgICAvLyAgIHJldHVybiBkZWNvZGUoYml0cywgbnVsbClcbiAgICAgICAgLy8gfVxuICAgICAgICAvKipcbiAgICAgICAgICogPHA+RGVjb2RlcyBhIFFSIENvZGUgcmVwcmVzZW50ZWQgYXMgYSB7QGxpbmsgQml0TWF0cml4fS4gQSAxIG9yIFwidHJ1ZVwiIGlzIHRha2VuIHRvIG1lYW4gYSBibGFjayBtb2R1bGUuPC9wPlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gYml0cyBib29sZWFucyByZXByZXNlbnRpbmcgd2hpdGUvYmxhY2sgUVIgQ29kZSBtb2R1bGVzXG4gICAgICAgICAqIEBwYXJhbSBoaW50cyBkZWNvZGluZyBoaW50cyB0aGF0IHNob3VsZCBiZSB1c2VkIHRvIGluZmx1ZW5jZSBkZWNvZGluZ1xuICAgICAgICAgKiBAcmV0dXJuIHRleHQgYW5kIGJ5dGVzIGVuY29kZWQgd2l0aGluIHRoZSBRUiBDb2RlXG4gICAgICAgICAqIEB0aHJvd3MgRm9ybWF0RXhjZXB0aW9uIGlmIHRoZSBRUiBDb2RlIGNhbm5vdCBiZSBkZWNvZGVkXG4gICAgICAgICAqIEB0aHJvd3MgQ2hlY2tzdW1FeGNlcHRpb24gaWYgZXJyb3IgY29ycmVjdGlvbiBmYWlsc1xuICAgICAgICAgKi9cbiAgICAgICAgZGVjb2RlQml0TWF0cml4KGJpdHMsIGhpbnRzKSB7XG4gICAgICAgICAgICAvLyBDb25zdHJ1Y3QgYSBwYXJzZXIgYW5kIHJlYWQgdmVyc2lvbiwgZXJyb3ItY29ycmVjdGlvbiBsZXZlbFxuICAgICAgICAgICAgY29uc3QgcGFyc2VyID0gbmV3IEJpdE1hdHJpeFBhcnNlciQxKGJpdHMpO1xuICAgICAgICAgICAgbGV0IGV4ID0gbnVsbDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlQml0TWF0cml4UGFyc2VyKHBhcnNlciwgaGludHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUgLyo6IEZvcm1hdEV4Y2VwdGlvbiwgQ2hlY2tzdW1FeGNlcHRpb24qLykge1xuICAgICAgICAgICAgICAgIGV4ID0gZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgLy8gUmV2ZXJ0IHRoZSBiaXQgbWF0cml4XG4gICAgICAgICAgICAgICAgcGFyc2VyLnJlbWFzaygpO1xuICAgICAgICAgICAgICAgIC8vIFdpbGwgYmUgYXR0ZW1wdGluZyBhIG1pcnJvcmVkIHJlYWRpbmcgb2YgdGhlIHZlcnNpb24gYW5kIGZvcm1hdCBpbmZvLlxuICAgICAgICAgICAgICAgIHBhcnNlci5zZXRNaXJyb3IodHJ1ZSk7XG4gICAgICAgICAgICAgICAgLy8gUHJlZW1wdGl2ZWx5IHJlYWQgdGhlIHZlcnNpb24uXG4gICAgICAgICAgICAgICAgcGFyc2VyLnJlYWRWZXJzaW9uKCk7XG4gICAgICAgICAgICAgICAgLy8gUHJlZW1wdGl2ZWx5IHJlYWQgdGhlIGZvcm1hdCBpbmZvcm1hdGlvbi5cbiAgICAgICAgICAgICAgICBwYXJzZXIucmVhZEZvcm1hdEluZm9ybWF0aW9uKCk7XG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgKiBTaW5jZSB3ZSdyZSBoZXJlLCB0aGlzIG1lYW5zIHdlIGhhdmUgc3VjY2Vzc2Z1bGx5IGRldGVjdGVkIHNvbWUga2luZFxuICAgICAgICAgICAgICAgICAqIG9mIHZlcnNpb24gYW5kIGZvcm1hdCBpbmZvcm1hdGlvbiB3aGVuIG1pcnJvcmVkLiBUaGlzIGlzIGEgZ29vZCBzaWduLFxuICAgICAgICAgICAgICAgICAqIHRoYXQgdGhlIFFSIGNvZGUgbWF5IGJlIG1pcnJvcmVkLCBhbmQgd2Ugc2hvdWxkIHRyeSBvbmNlIG1vcmUgd2l0aCBhXG4gICAgICAgICAgICAgICAgICogbWlycm9yZWQgY29udGVudC5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAvLyBQcmVwYXJlIGZvciBhIG1pcnJvcmVkIHJlYWRpbmcuXG4gICAgICAgICAgICAgICAgcGFyc2VyLm1pcnJvcigpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuZGVjb2RlQml0TWF0cml4UGFyc2VyKHBhcnNlciwgaGludHMpO1xuICAgICAgICAgICAgICAgIC8vIFN1Y2Nlc3MhIE5vdGlmeSB0aGUgY2FsbGVyIHRoYXQgdGhlIGNvZGUgd2FzIG1pcnJvcmVkLlxuICAgICAgICAgICAgICAgIHJlc3VsdC5zZXRPdGhlcihuZXcgUVJDb2RlRGVjb2Rlck1ldGFEYXRhKHRydWUpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUgLypGb3JtYXRFeGNlcHRpb24gfCBDaGVja3N1bUV4Y2VwdGlvbiovKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhyb3cgdGhlIGV4Y2VwdGlvbiBmcm9tIHRoZSBvcmlnaW5hbCByZWFkaW5nXG4gICAgICAgICAgICAgICAgaWYgKGV4ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGV4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGRlY29kZUJpdE1hdHJpeFBhcnNlcihwYXJzZXIsIGhpbnRzKSB7XG4gICAgICAgICAgICBjb25zdCB2ZXJzaW9uID0gcGFyc2VyLnJlYWRWZXJzaW9uKCk7XG4gICAgICAgICAgICBjb25zdCBlY0xldmVsID0gcGFyc2VyLnJlYWRGb3JtYXRJbmZvcm1hdGlvbigpLmdldEVycm9yQ29ycmVjdGlvbkxldmVsKCk7XG4gICAgICAgICAgICAvLyBSZWFkIGNvZGV3b3Jkc1xuICAgICAgICAgICAgY29uc3QgY29kZXdvcmRzID0gcGFyc2VyLnJlYWRDb2Rld29yZHMoKTtcbiAgICAgICAgICAgIC8vIFNlcGFyYXRlIGludG8gZGF0YSBibG9ja3NcbiAgICAgICAgICAgIGNvbnN0IGRhdGFCbG9ja3MgPSBEYXRhQmxvY2skMS5nZXREYXRhQmxvY2tzKGNvZGV3b3JkcywgdmVyc2lvbiwgZWNMZXZlbCk7XG4gICAgICAgICAgICAvLyBDb3VudCB0b3RhbCBudW1iZXIgb2YgZGF0YSBieXRlc1xuICAgICAgICAgICAgbGV0IHRvdGFsQnl0ZXMgPSAwO1xuICAgICAgICAgICAgZm9yIChjb25zdCBkYXRhQmxvY2sgb2YgZGF0YUJsb2Nrcykge1xuICAgICAgICAgICAgICAgIHRvdGFsQnl0ZXMgKz0gZGF0YUJsb2NrLmdldE51bURhdGFDb2Rld29yZHMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdEJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkodG90YWxCeXRlcyk7XG4gICAgICAgICAgICBsZXQgcmVzdWx0T2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIC8vIEVycm9yLWNvcnJlY3QgYW5kIGNvcHkgZGF0YSBibG9ja3MgdG9nZXRoZXIgaW50byBhIHN0cmVhbSBvZiBieXRlc1xuICAgICAgICAgICAgZm9yIChjb25zdCBkYXRhQmxvY2sgb2YgZGF0YUJsb2Nrcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvZGV3b3JkQnl0ZXMgPSBkYXRhQmxvY2suZ2V0Q29kZXdvcmRzKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgbnVtRGF0YUNvZGV3b3JkcyA9IGRhdGFCbG9jay5nZXROdW1EYXRhQ29kZXdvcmRzKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jb3JyZWN0RXJyb3JzKGNvZGV3b3JkQnl0ZXMsIG51bURhdGFDb2Rld29yZHMpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtRGF0YUNvZGV3b3JkczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdEJ5dGVzW3Jlc3VsdE9mZnNldCsrXSA9IGNvZGV3b3JkQnl0ZXNbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRGVjb2RlIHRoZSBjb250ZW50cyBvZiB0aGF0IHN0cmVhbSBvZiBieXRlc1xuICAgICAgICAgICAgcmV0dXJuIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMS5kZWNvZGUocmVzdWx0Qnl0ZXMsIHZlcnNpb24sIGVjTGV2ZWwsIGhpbnRzKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogPHA+R2l2ZW4gZGF0YSBhbmQgZXJyb3ItY29ycmVjdGlvbiBjb2Rld29yZHMgcmVjZWl2ZWQsIHBvc3NpYmx5IGNvcnJ1cHRlZCBieSBlcnJvcnMsIGF0dGVtcHRzIHRvXG4gICAgICAgICAqIGNvcnJlY3QgdGhlIGVycm9ycyBpbi1wbGFjZSB1c2luZyBSZWVkLVNvbG9tb24gZXJyb3IgY29ycmVjdGlvbi48L3A+XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBjb2Rld29yZEJ5dGVzIGRhdGEgYW5kIGVycm9yIGNvcnJlY3Rpb24gY29kZXdvcmRzXG4gICAgICAgICAqIEBwYXJhbSBudW1EYXRhQ29kZXdvcmRzIG51bWJlciBvZiBjb2Rld29yZHMgdGhhdCBhcmUgZGF0YSBieXRlc1xuICAgICAgICAgKiBAdGhyb3dzIENoZWNrc3VtRXhjZXB0aW9uIGlmIGVycm9yIGNvcnJlY3Rpb24gZmFpbHNcbiAgICAgICAgICovXG4gICAgICAgIGNvcnJlY3RFcnJvcnMoY29kZXdvcmRCeXRlcywgbnVtRGF0YUNvZGV3b3JkcyAvKmludCovKSB7XG4gICAgICAgICAgICAvLyBjb25zdCBudW1Db2Rld29yZHMgPSBjb2Rld29yZEJ5dGVzLmxlbmd0aDtcbiAgICAgICAgICAgIC8vIEZpcnN0IHJlYWQgaW50byBhbiBhcnJheSBvZiBpbnRzXG4gICAgICAgICAgICBjb25zdCBjb2Rld29yZHNJbnRzID0gbmV3IEludDMyQXJyYXkoY29kZXdvcmRCeXRlcyk7XG4gICAgICAgICAgICAvLyBUWVBFU0NSSVBUUE9SVDogbm90IHJlYWx5IG5lY2Vzc2FyeSB0byB0cmFuc2Zvcm0gdG8gaW50cz8gY291bGQgcmVkZXNpZ24gZXZlcnl0aGluZyB0byB3b3JrIHdpdGggdW5zaWduZWQgYnl0ZXM/XG4gICAgICAgICAgICAvLyBjb25zdCBjb2Rld29yZHNJbnRzID0gbmV3IEludDMyQXJyYXkobnVtQ29kZXdvcmRzKVxuICAgICAgICAgICAgLy8gZm9yIChsZXQgaSA9IDA7IGkgPCBudW1Db2Rld29yZHM7IGkrKykge1xuICAgICAgICAgICAgLy8gICBjb2Rld29yZHNJbnRzW2ldID0gY29kZXdvcmRCeXRlc1tpXSAmIDB4RkZcbiAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yc0RlY29kZXIuZGVjb2RlKGNvZGV3b3Jkc0ludHMsIGNvZGV3b3JkQnl0ZXMubGVuZ3RoIC0gbnVtRGF0YUNvZGV3b3Jkcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoaWdub3JlZCAvKjogUmVlZFNvbG9tb25FeGNlcHRpb24qLykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBDaGVja3N1bUV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ29weSBiYWNrIGludG8gYXJyYXkgb2YgYnl0ZXMgLS0gb25seSBuZWVkIHRvIHdvcnJ5IGFib3V0IHRoZSBieXRlcyB0aGF0IHdlcmUgZGF0YVxuICAgICAgICAgICAgLy8gV2UgZG9uJ3QgY2FyZSBhYm91dCBlcnJvcnMgaW4gdGhlIGVycm9yLWNvcnJlY3Rpb24gY29kZXdvcmRzXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bURhdGFDb2Rld29yZHM7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvZGV3b3JkQnl0ZXNbaV0gPSAvKihieXRlKSAqLyBjb2Rld29yZHNJbnRzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBDb3B5cmlnaHQgMjAwNyBaWGluZyBhdXRob3JzXG4gICAgICpcbiAgICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgICAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgICAgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgICAgKlxuICAgICAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gICAgICpcbiAgICAgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICAgICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgICAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICAgICAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgICAgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiA8cD5FbmNhcHN1bGF0ZXMgYW4gYWxpZ25tZW50IHBhdHRlcm4sIHdoaWNoIGFyZSB0aGUgc21hbGxlciBzcXVhcmUgcGF0dGVybnMgZm91bmQgaW5cbiAgICAgKiBhbGwgYnV0IHRoZSBzaW1wbGVzdCBRUiBDb2Rlcy48L3A+XG4gICAgICpcbiAgICAgKiBAYXV0aG9yIFNlYW4gT3dlblxuICAgICAqL1xuICAgIGNsYXNzIEFsaWdubWVudFBhdHRlcm4gZXh0ZW5kcyBSZXN1bHRQb2ludCB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHBvc1ggLypmbG9hdCovLCBwb3NZIC8qZmxvYXQqLywgZXN0aW1hdGVkTW9kdWxlU2l6ZSAvKmZsb2F0Ki8pIHtcbiAgICAgICAgICAgIHN1cGVyKHBvc1gsIHBvc1kpO1xuICAgICAgICAgICAgdGhpcy5lc3RpbWF0ZWRNb2R1bGVTaXplID0gZXN0aW1hdGVkTW9kdWxlU2l6ZTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogPHA+RGV0ZXJtaW5lcyBpZiB0aGlzIGFsaWdubWVudCBwYXR0ZXJuIFwiYWJvdXQgZXF1YWxzXCIgYW4gYWxpZ25tZW50IHBhdHRlcm4gYXQgdGhlIHN0YXRlZFxuICAgICAgICAgKiBwb3NpdGlvbiBhbmQgc2l6ZSAtLSBtZWFuaW5nLCBpdCBpcyBhdCBuZWFybHkgdGhlIHNhbWUgY2VudGVyIHdpdGggbmVhcmx5IHRoZSBzYW1lIHNpemUuPC9wPlxuICAgICAgICAgKi9cbiAgICAgICAgYWJvdXRFcXVhbHMobW9kdWxlU2l6ZSAvKmZsb2F0Ki8sIGkgLypmbG9hdCovLCBqIC8qZmxvYXQqLykge1xuICAgICAgICAgICAgaWYgKE1hdGguYWJzKGkgLSB0aGlzLmdldFkoKSkgPD0gbW9kdWxlU2l6ZSAmJiBNYXRoLmFicyhqIC0gdGhpcy5nZXRYKCkpIDw9IG1vZHVsZVNpemUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtb2R1bGVTaXplRGlmZiA9IE1hdGguYWJzKG1vZHVsZVNpemUgLSB0aGlzLmVzdGltYXRlZE1vZHVsZVNpemUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBtb2R1bGVTaXplRGlmZiA8PSAxLjAgfHwgbW9kdWxlU2l6ZURpZmYgPD0gdGhpcy5lc3RpbWF0ZWRNb2R1bGVTaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb21iaW5lcyB0aGlzIG9iamVjdCdzIGN1cnJlbnQgZXN0aW1hdGUgb2YgYSBmaW5kZXIgcGF0dGVybiBwb3NpdGlvbiBhbmQgbW9kdWxlIHNpemVcbiAgICAgICAgICogd2l0aCBhIG5ldyBlc3RpbWF0ZS4gSXQgcmV0dXJucyBhIG5ldyB7QGNvZGUgRmluZGVyUGF0dGVybn0gY29udGFpbmluZyBhbiBhdmVyYWdlIG9mIHRoZSB0d28uXG4gICAgICAgICAqL1xuICAgICAgICBjb21iaW5lRXN0aW1hdGUoaSAvKmZsb2F0Ki8sIGogLypmbG9hdCovLCBuZXdNb2R1bGVTaXplIC8qZmxvYXQqLykge1xuICAgICAgICAgICAgY29uc3QgY29tYmluZWRYID0gKHRoaXMuZ2V0WCgpICsgaikgLyAyLjA7XG4gICAgICAgICAgICBjb25zdCBjb21iaW5lZFkgPSAodGhpcy5nZXRZKCkgKyBpKSAvIDIuMDtcbiAgICAgICAgICAgIGNvbnN0IGNvbWJpbmVkTW9kdWxlU2l6ZSA9ICh0aGlzLmVzdGltYXRlZE1vZHVsZVNpemUgKyBuZXdNb2R1bGVTaXplKSAvIDIuMDtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQWxpZ25tZW50UGF0dGVybihjb21iaW5lZFgsIGNvbWJpbmVkWSwgY29tYmluZWRNb2R1bGVTaXplKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qXG4gICAgICogQ29weXJpZ2h0IDIwMDcgWlhpbmcgYXV0aG9yc1xuICAgICAqXG4gICAgICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgICAgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICAgICpcbiAgICAgKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICAgICAqXG4gICAgICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICAgICAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgICAgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgICAgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gICAgICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gICAgICovXG4gICAgLyppbXBvcnQgamF2YS51dGlsLkFycmF5TGlzdDsqL1xuICAgIC8qaW1wb3J0IGphdmEudXRpbC5MaXN0OyovXG4gICAgLyoqXG4gICAgICogPHA+VGhpcyBjbGFzcyBhdHRlbXB0cyB0byBmaW5kIGFsaWdubWVudCBwYXR0ZXJucyBpbiBhIFFSIENvZGUuIEFsaWdubWVudCBwYXR0ZXJucyBsb29rIGxpa2UgZmluZGVyXG4gICAgICogcGF0dGVybnMgYnV0IGFyZSBzbWFsbGVyIGFuZCBhcHBlYXIgYXQgcmVndWxhciBpbnRlcnZhbHMgdGhyb3VnaG91dCB0aGUgaW1hZ2UuPC9wPlxuICAgICAqXG4gICAgICogPHA+QXQgdGhlIG1vbWVudCB0aGlzIG9ubHkgbG9va3MgZm9yIHRoZSBib3R0b20tcmlnaHQgYWxpZ25tZW50IHBhdHRlcm4uPC9wPlxuICAgICAqXG4gICAgICogPHA+VGhpcyBpcyBtb3N0bHkgYSBzaW1wbGlmaWVkIGNvcHkgb2Yge0BsaW5rIEZpbmRlclBhdHRlcm5GaW5kZXJ9LiBJdCBpcyBjb3BpZWQsXG4gICAgICogcGFzdGVkIGFuZCBzdHJpcHBlZCBkb3duIGhlcmUgZm9yIG1heGltdW0gcGVyZm9ybWFuY2UgYnV0IGRvZXMgdW5mb3J0dW5hdGVseSBkdXBsaWNhdGVcbiAgICAgKiBzb21lIGNvZGUuPC9wPlxuICAgICAqXG4gICAgICogPHA+VGhpcyBjbGFzcyBpcyB0aHJlYWQtc2FmZSBidXQgbm90IHJlZW50cmFudC4gRWFjaCB0aHJlYWQgbXVzdCBhbGxvY2F0ZSBpdHMgb3duIG9iamVjdC48L3A+XG4gICAgICpcbiAgICAgKiBAYXV0aG9yIFNlYW4gT3dlblxuICAgICAqL1xuICAgIGNsYXNzIEFsaWdubWVudFBhdHRlcm5GaW5kZXIge1xuICAgICAgICAvKipcbiAgICAgICAgICogPHA+Q3JlYXRlcyBhIGZpbmRlciB0aGF0IHdpbGwgbG9vayBpbiBhIHBvcnRpb24gb2YgdGhlIHdob2xlIGltYWdlLjwvcD5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGltYWdlIGltYWdlIHRvIHNlYXJjaFxuICAgICAgICAgKiBAcGFyYW0gc3RhcnRYIGxlZnQgY29sdW1uIGZyb20gd2hpY2ggdG8gc3RhcnQgc2VhcmNoaW5nXG4gICAgICAgICAqIEBwYXJhbSBzdGFydFkgdG9wIHJvdyBmcm9tIHdoaWNoIHRvIHN0YXJ0IHNlYXJjaGluZ1xuICAgICAgICAgKiBAcGFyYW0gd2lkdGggd2lkdGggb2YgcmVnaW9uIHRvIHNlYXJjaFxuICAgICAgICAgKiBAcGFyYW0gaGVpZ2h0IGhlaWdodCBvZiByZWdpb24gdG8gc2VhcmNoXG4gICAgICAgICAqIEBwYXJhbSBtb2R1bGVTaXplIGVzdGltYXRlZCBtb2R1bGUgc2l6ZSBzbyBmYXJcbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0cnVjdG9yKGltYWdlLCBzdGFydFggLyppbnQqLywgc3RhcnRZIC8qaW50Ki8sIHdpZHRoIC8qaW50Ki8sIGhlaWdodCAvKmludCovLCBtb2R1bGVTaXplIC8qZmxvYXQqLywgcmVzdWx0UG9pbnRDYWxsYmFjaykge1xuICAgICAgICAgICAgdGhpcy5pbWFnZSA9IGltYWdlO1xuICAgICAgICAgICAgdGhpcy5zdGFydFggPSBzdGFydFg7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0WSA9IHN0YXJ0WTtcbiAgICAgICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICAgICAgdGhpcy5tb2R1bGVTaXplID0gbW9kdWxlU2l6ZTtcbiAgICAgICAgICAgIHRoaXMucmVzdWx0UG9pbnRDYWxsYmFjayA9IHJlc3VsdFBvaW50Q2FsbGJhY2s7XG4gICAgICAgICAgICB0aGlzLnBvc3NpYmxlQ2VudGVycyA9IFtdOyAvLyBuZXcgQXJyYXk8YW55Pig1KSlcbiAgICAgICAgICAgIC8vIFRZUEVTQ1JJUFRQT1JUOiBhcnJheSBpbml0aWFsaXphdGlvbiB3aXRob3V0IHNpemUgYXMgdGhlIGxlbmd0aCBpcyBjaGVja2VkIGJlbG93XG4gICAgICAgICAgICB0aGlzLmNyb3NzQ2hlY2tTdGF0ZUNvdW50ID0gbmV3IEludDMyQXJyYXkoMyk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIDxwPlRoaXMgbWV0aG9kIGF0dGVtcHRzIHRvIGZpbmQgdGhlIGJvdHRvbS1yaWdodCBhbGlnbm1lbnQgcGF0dGVybiBpbiB0aGUgaW1hZ2UuIEl0IGlzIGEgYml0IG1lc3N5IHNpbmNlXG4gICAgICAgICAqIGl0J3MgcHJldHR5IHBlcmZvcm1hbmNlLWNyaXRpY2FsIGFuZCBzbyBpcyB3cml0dGVuIHRvIGJlIGZhc3QgZm9yZW1vc3QuPC9wPlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtAbGluayBBbGlnbm1lbnRQYXR0ZXJufSBpZiBmb3VuZFxuICAgICAgICAgKiBAdGhyb3dzIE5vdEZvdW5kRXhjZXB0aW9uIGlmIG5vdCBmb3VuZFxuICAgICAgICAgKi9cbiAgICAgICAgZmluZCgpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0WCA9IHRoaXMuc3RhcnRYO1xuICAgICAgICAgICAgY29uc3QgaGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XG4gICAgICAgICAgICBjb25zdCB3aWR0aCA9IHRoaXMud2lkdGg7XG4gICAgICAgICAgICBjb25zdCBtYXhKID0gc3RhcnRYICsgd2lkdGg7XG4gICAgICAgICAgICBjb25zdCBtaWRkbGVJID0gdGhpcy5zdGFydFkgKyAoaGVpZ2h0IC8gMik7XG4gICAgICAgICAgICAvLyBXZSBhcmUgbG9va2luZyBmb3IgYmxhY2svd2hpdGUvYmxhY2sgbW9kdWxlcyBpbiAxOjE6MSByYXRpb1xuICAgICAgICAgICAgLy8gdGhpcyB0cmFja3MgdGhlIG51bWJlciBvZiBibGFjay93aGl0ZS9ibGFjayBtb2R1bGVzIHNlZW4gc28gZmFyXG4gICAgICAgICAgICBjb25zdCBzdGF0ZUNvdW50ID0gbmV3IEludDMyQXJyYXkoMyk7XG4gICAgICAgICAgICBjb25zdCBpbWFnZSA9IHRoaXMuaW1hZ2U7XG4gICAgICAgICAgICBmb3IgKGxldCBpR2VuID0gMDsgaUdlbiA8IGhlaWdodDsgaUdlbisrKSB7XG4gICAgICAgICAgICAgICAgLy8gU2VhcmNoIGZyb20gbWlkZGxlIG91dHdhcmRzXG4gICAgICAgICAgICAgICAgY29uc3QgaSA9IG1pZGRsZUkgKyAoKGlHZW4gJiAweDAxKSA9PT0gMCA/IE1hdGguZmxvb3IoKGlHZW4gKyAxKSAvIDIpIDogLU1hdGguZmxvb3IoKGlHZW4gKyAxKSAvIDIpKTtcbiAgICAgICAgICAgICAgICBzdGF0ZUNvdW50WzBdID0gMDtcbiAgICAgICAgICAgICAgICBzdGF0ZUNvdW50WzFdID0gMDtcbiAgICAgICAgICAgICAgICBzdGF0ZUNvdW50WzJdID0gMDtcbiAgICAgICAgICAgICAgICBsZXQgaiA9IHN0YXJ0WDtcbiAgICAgICAgICAgICAgICAvLyBCdXJuIG9mZiBsZWFkaW5nIHdoaXRlIHBpeGVscyBiZWZvcmUgYW55dGhpbmcgZWxzZTsgaWYgd2Ugc3RhcnQgaW4gdGhlIG1pZGRsZSBvZlxuICAgICAgICAgICAgICAgIC8vIGEgd2hpdGUgcnVuLCBpdCBkb2Vzbid0IG1ha2Ugc2Vuc2UgdG8gY291bnQgaXRzIGxlbmd0aCwgc2luY2Ugd2UgZG9uJ3Qga25vdyBpZiB0aGVcbiAgICAgICAgICAgICAgICAvLyB3aGl0ZSBydW4gY29udGludWVkIHRvIHRoZSBsZWZ0IG9mIHRoZSBzdGFydCBwb2ludFxuICAgICAgICAgICAgICAgIHdoaWxlIChqIDwgbWF4SiAmJiAhaW1hZ2UuZ2V0KGosIGkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGorKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGN1cnJlbnRTdGF0ZSA9IDA7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGogPCBtYXhKKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbWFnZS5nZXQoaiwgaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJsYWNrIHBpeGVsXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudFN0YXRlID09PSAxKSB7IC8vIENvdW50aW5nIGJsYWNrIHBpeGVsc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlQ291bnRbMV0rKztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgeyAvLyBDb3VudGluZyB3aGl0ZSBwaXhlbHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudFN0YXRlID09PSAyKSB7IC8vIEEgd2lubmVyP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5mb3VuZFBhdHRlcm5Dcm9zcyhzdGF0ZUNvdW50KSkgeyAvLyBZZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbmZpcm1lZCA9IHRoaXMuaGFuZGxlUG9zc2libGVDZW50ZXIoc3RhdGVDb3VudCwgaSwgaik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29uZmlybWVkICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbmZpcm1lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZUNvdW50WzBdID0gc3RhdGVDb3VudFsyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVDb3VudFsxXSA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlQ291bnRbMl0gPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50U3RhdGUgPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVDb3VudFsrK2N1cnJlbnRTdGF0ZV0rKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7IC8vIFdoaXRlIHBpeGVsXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudFN0YXRlID09PSAxKSB7IC8vIENvdW50aW5nIGJsYWNrIHBpeGVsc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTdGF0ZSsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVDb3VudFtjdXJyZW50U3RhdGVdKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaisrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5mb3VuZFBhdHRlcm5Dcm9zcyhzdGF0ZUNvdW50KSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb25maXJtZWQgPSB0aGlzLmhhbmRsZVBvc3NpYmxlQ2VudGVyKHN0YXRlQ291bnQsIGksIG1heEopO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29uZmlybWVkICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29uZmlybWVkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSG1tLCBub3RoaW5nIHdlIHNhdyB3YXMgb2JzZXJ2ZWQgYW5kIGNvbmZpcm1lZCB0d2ljZS4gSWYgd2UgaGFkXG4gICAgICAgICAgICAvLyBhbnkgZ3Vlc3MgYXQgYWxsLCByZXR1cm4gaXQuXG4gICAgICAgICAgICBpZiAodGhpcy5wb3NzaWJsZUNlbnRlcnMubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucG9zc2libGVDZW50ZXJzWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdpdmVuIGEgY291bnQgb2YgYmxhY2svd2hpdGUvYmxhY2sgcGl4ZWxzIGp1c3Qgc2VlbiBhbmQgYW4gZW5kIHBvc2l0aW9uLFxuICAgICAgICAgKiBmaWd1cmVzIHRoZSBsb2NhdGlvbiBvZiB0aGUgY2VudGVyIG9mIHRoaXMgYmxhY2svd2hpdGUvYmxhY2sgcnVuLlxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGNlbnRlckZyb21FbmQoc3RhdGVDb3VudCwgZW5kIC8qaW50Ki8pIHtcbiAgICAgICAgICAgIHJldHVybiAoZW5kIC0gc3RhdGVDb3VudFsyXSkgLSBzdGF0ZUNvdW50WzFdIC8gMi4wO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gc3RhdGVDb3VudCBjb3VudCBvZiBibGFjay93aGl0ZS9ibGFjayBwaXhlbHMganVzdCByZWFkXG4gICAgICAgICAqIEByZXR1cm4gdHJ1ZSBpZmYgdGhlIHByb3BvcnRpb25zIG9mIHRoZSBjb3VudHMgaXMgY2xvc2UgZW5vdWdoIHRvIHRoZSAxLzEvMSByYXRpb3NcbiAgICAgICAgICogICAgICAgICB1c2VkIGJ5IGFsaWdubWVudCBwYXR0ZXJucyB0byBiZSBjb25zaWRlcmVkIGEgbWF0Y2hcbiAgICAgICAgICovXG4gICAgICAgIGZvdW5kUGF0dGVybkNyb3NzKHN0YXRlQ291bnQpIHtcbiAgICAgICAgICAgIGNvbnN0IG1vZHVsZVNpemUgPSB0aGlzLm1vZHVsZVNpemU7XG4gICAgICAgICAgICBjb25zdCBtYXhWYXJpYW5jZSA9IG1vZHVsZVNpemUgLyAyLjA7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhtb2R1bGVTaXplIC0gc3RhdGVDb3VudFtpXSkgPj0gbWF4VmFyaWFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiA8cD5BZnRlciBhIGhvcml6b250YWwgc2NhbiBmaW5kcyBhIHBvdGVudGlhbCBhbGlnbm1lbnQgcGF0dGVybiwgdGhpcyBtZXRob2RcbiAgICAgICAgICogXCJjcm9zcy1jaGVja3NcIiBieSBzY2FubmluZyBkb3duIHZlcnRpY2FsbHkgdGhyb3VnaCB0aGUgY2VudGVyIG9mIHRoZSBwb3NzaWJsZVxuICAgICAgICAgKiBhbGlnbm1lbnQgcGF0dGVybiB0byBzZWUgaWYgdGhlIHNhbWUgcHJvcG9ydGlvbiBpcyBkZXRlY3RlZC48L3A+XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBzdGFydEkgcm93IHdoZXJlIGFuIGFsaWdubWVudCBwYXR0ZXJuIHdhcyBkZXRlY3RlZFxuICAgICAgICAgKiBAcGFyYW0gY2VudGVySiBjZW50ZXIgb2YgdGhlIHNlY3Rpb24gdGhhdCBhcHBlYXJzIHRvIGNyb3NzIGFuIGFsaWdubWVudCBwYXR0ZXJuXG4gICAgICAgICAqIEBwYXJhbSBtYXhDb3VudCBtYXhpbXVtIHJlYXNvbmFibGUgbnVtYmVyIG9mIG1vZHVsZXMgdGhhdCBzaG91bGQgYmVcbiAgICAgICAgICogb2JzZXJ2ZWQgaW4gYW55IHJlYWRpbmcgc3RhdGUsIGJhc2VkIG9uIHRoZSByZXN1bHRzIG9mIHRoZSBob3Jpem9udGFsIHNjYW5cbiAgICAgICAgICogQHJldHVybiB2ZXJ0aWNhbCBjZW50ZXIgb2YgYWxpZ25tZW50IHBhdHRlcm4sIG9yIHtAbGluayBGbG9hdCNOYU59IGlmIG5vdCBmb3VuZFxuICAgICAgICAgKi9cbiAgICAgICAgY3Jvc3NDaGVja1ZlcnRpY2FsKHN0YXJ0SSAvKmludCovLCBjZW50ZXJKIC8qaW50Ki8sIG1heENvdW50IC8qaW50Ki8sIG9yaWdpbmFsU3RhdGVDb3VudFRvdGFsIC8qaW50Ki8pIHtcbiAgICAgICAgICAgIGNvbnN0IGltYWdlID0gdGhpcy5pbWFnZTtcbiAgICAgICAgICAgIGNvbnN0IG1heEkgPSBpbWFnZS5nZXRIZWlnaHQoKTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXRlQ291bnQgPSB0aGlzLmNyb3NzQ2hlY2tTdGF0ZUNvdW50O1xuICAgICAgICAgICAgc3RhdGVDb3VudFswXSA9IDA7XG4gICAgICAgICAgICBzdGF0ZUNvdW50WzFdID0gMDtcbiAgICAgICAgICAgIHN0YXRlQ291bnRbMl0gPSAwO1xuICAgICAgICAgICAgLy8gU3RhcnQgY291bnRpbmcgdXAgZnJvbSBjZW50ZXJcbiAgICAgICAgICAgIGxldCBpID0gc3RhcnRJO1xuICAgICAgICAgICAgd2hpbGUgKGkgPj0gMCAmJiBpbWFnZS5nZXQoY2VudGVySiwgaSkgJiYgc3RhdGVDb3VudFsxXSA8PSBtYXhDb3VudCkge1xuICAgICAgICAgICAgICAgIHN0YXRlQ291bnRbMV0rKztcbiAgICAgICAgICAgICAgICBpLS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiBhbHJlYWR5IHRvbyBtYW55IG1vZHVsZXMgaW4gdGhpcyBzdGF0ZSBvciByYW4gb2ZmIHRoZSBlZGdlOlxuICAgICAgICAgICAgaWYgKGkgPCAwIHx8IHN0YXRlQ291bnRbMV0gPiBtYXhDb3VudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoaSA+PSAwICYmICFpbWFnZS5nZXQoY2VudGVySiwgaSkgJiYgc3RhdGVDb3VudFswXSA8PSBtYXhDb3VudCkge1xuICAgICAgICAgICAgICAgIHN0YXRlQ291bnRbMF0rKztcbiAgICAgICAgICAgICAgICBpLS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RhdGVDb3VudFswXSA+IG1heENvdW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE5vdyBhbHNvIGNvdW50IGRvd24gZnJvbSBjZW50ZXJcbiAgICAgICAgICAgIGkgPSBzdGFydEkgKyAxO1xuICAgICAgICAgICAgd2hpbGUgKGkgPCBtYXhJICYmIGltYWdlLmdldChjZW50ZXJKLCBpKSAmJiBzdGF0ZUNvdW50WzFdIDw9IG1heENvdW50KSB7XG4gICAgICAgICAgICAgICAgc3RhdGVDb3VudFsxXSsrO1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpID09PSBtYXhJIHx8IHN0YXRlQ291bnRbMV0gPiBtYXhDb3VudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoaSA8IG1heEkgJiYgIWltYWdlLmdldChjZW50ZXJKLCBpKSAmJiBzdGF0ZUNvdW50WzJdIDw9IG1heENvdW50KSB7XG4gICAgICAgICAgICAgICAgc3RhdGVDb3VudFsyXSsrO1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdGF0ZUNvdW50WzJdID4gbWF4Q291bnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc3RhdGVDb3VudFRvdGFsID0gc3RhdGVDb3VudFswXSArIHN0YXRlQ291bnRbMV0gKyBzdGF0ZUNvdW50WzJdO1xuICAgICAgICAgICAgaWYgKDUgKiBNYXRoLmFicyhzdGF0ZUNvdW50VG90YWwgLSBvcmlnaW5hbFN0YXRlQ291bnRUb3RhbCkgPj0gMiAqIG9yaWdpbmFsU3RhdGVDb3VudFRvdGFsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZvdW5kUGF0dGVybkNyb3NzKHN0YXRlQ291bnQpID8gQWxpZ25tZW50UGF0dGVybkZpbmRlci5jZW50ZXJGcm9tRW5kKHN0YXRlQ291bnQsIGkpIDogTmFOO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiA8cD5UaGlzIGlzIGNhbGxlZCB3aGVuIGEgaG9yaXpvbnRhbCBzY2FuIGZpbmRzIGEgcG9zc2libGUgYWxpZ25tZW50IHBhdHRlcm4uIEl0IHdpbGxcbiAgICAgICAgICogY3Jvc3MgY2hlY2sgd2l0aCBhIHZlcnRpY2FsIHNjYW4sIGFuZCBpZiBzdWNjZXNzZnVsLCB3aWxsIHNlZSBpZiB0aGlzIHBhdHRlcm4gaGFkIGJlZW5cbiAgICAgICAgICogZm91bmQgb24gYSBwcmV2aW91cyBob3Jpem9udGFsIHNjYW4uIElmIHNvLCB3ZSBjb25zaWRlciBpdCBjb25maXJtZWQgYW5kIGNvbmNsdWRlIHdlIGhhdmVcbiAgICAgICAgICogZm91bmQgdGhlIGFsaWdubWVudCBwYXR0ZXJuLjwvcD5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHN0YXRlQ291bnQgcmVhZGluZyBzdGF0ZSBtb2R1bGUgY291bnRzIGZyb20gaG9yaXpvbnRhbCBzY2FuXG4gICAgICAgICAqIEBwYXJhbSBpIHJvdyB3aGVyZSBhbGlnbm1lbnQgcGF0dGVybiBtYXkgYmUgZm91bmRcbiAgICAgICAgICogQHBhcmFtIGogZW5kIG9mIHBvc3NpYmxlIGFsaWdubWVudCBwYXR0ZXJuIGluIHJvd1xuICAgICAgICAgKiBAcmV0dXJuIHtAbGluayBBbGlnbm1lbnRQYXR0ZXJufSBpZiB3ZSBoYXZlIGZvdW5kIHRoZSBzYW1lIHBhdHRlcm4gdHdpY2UsIG9yIG51bGwgaWYgbm90XG4gICAgICAgICAqL1xuICAgICAgICBoYW5kbGVQb3NzaWJsZUNlbnRlcihzdGF0ZUNvdW50LCBpIC8qaW50Ki8sIGogLyppbnQqLykge1xuICAgICAgICAgICAgY29uc3Qgc3RhdGVDb3VudFRvdGFsID0gc3RhdGVDb3VudFswXSArIHN0YXRlQ291bnRbMV0gKyBzdGF0ZUNvdW50WzJdO1xuICAgICAgICAgICAgY29uc3QgY2VudGVySiA9IEFsaWdubWVudFBhdHRlcm5GaW5kZXIuY2VudGVyRnJvbUVuZChzdGF0ZUNvdW50LCBqKTtcbiAgICAgICAgICAgIGNvbnN0IGNlbnRlckkgPSB0aGlzLmNyb3NzQ2hlY2tWZXJ0aWNhbChpLCAvKihpbnQpICovIGNlbnRlckosIDIgKiBzdGF0ZUNvdW50WzFdLCBzdGF0ZUNvdW50VG90YWwpO1xuICAgICAgICAgICAgaWYgKCFpc05hTihjZW50ZXJJKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVzdGltYXRlZE1vZHVsZVNpemUgPSAoc3RhdGVDb3VudFswXSArIHN0YXRlQ291bnRbMV0gKyBzdGF0ZUNvdW50WzJdKSAvIDMuMDtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGNlbnRlciBvZiB0aGlzLnBvc3NpYmxlQ2VudGVycykge1xuICAgICAgICAgICAgICAgICAgICAvLyBMb29rIGZvciBhYm91dCB0aGUgc2FtZSBjZW50ZXIgYW5kIG1vZHVsZSBzaXplOlxuICAgICAgICAgICAgICAgICAgICBpZiAoY2VudGVyLmFib3V0RXF1YWxzKGVzdGltYXRlZE1vZHVsZVNpemUsIGNlbnRlckksIGNlbnRlckopKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2VudGVyLmNvbWJpbmVFc3RpbWF0ZShjZW50ZXJJLCBjZW50ZXJKLCBlc3RpbWF0ZWRNb2R1bGVTaXplKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBIYWRuJ3QgZm91bmQgdGhpcyBiZWZvcmU7IHNhdmUgaXRcbiAgICAgICAgICAgICAgICBjb25zdCBwb2ludCA9IG5ldyBBbGlnbm1lbnRQYXR0ZXJuKGNlbnRlckosIGNlbnRlckksIGVzdGltYXRlZE1vZHVsZVNpemUpO1xuICAgICAgICAgICAgICAgIHRoaXMucG9zc2libGVDZW50ZXJzLnB1c2gocG9pbnQpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlc3VsdFBvaW50Q2FsbGJhY2sgIT09IG51bGwgJiYgdGhpcy5yZXN1bHRQb2ludENhbGxiYWNrICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXN1bHRQb2ludENhbGxiYWNrLmZvdW5kUG9zc2libGVSZXN1bHRQb2ludChwb2ludCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKlxuICAgICAqIENvcHlyaWdodCAyMDA3IFpYaW5nIGF1dGhvcnNcbiAgICAgKlxuICAgICAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gICAgICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgICAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgICAqXG4gICAgICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAgICAgKlxuICAgICAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgICAgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICAgICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gICAgICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICAgICAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIDxwPkVuY2Fwc3VsYXRlcyBhIGZpbmRlciBwYXR0ZXJuLCB3aGljaCBhcmUgdGhlIHRocmVlIHNxdWFyZSBwYXR0ZXJucyBmb3VuZCBpblxuICAgICAqIHRoZSBjb3JuZXJzIG9mIFFSIENvZGVzLiBJdCBhbHNvIGVuY2Fwc3VsYXRlcyBhIGNvdW50IG9mIHNpbWlsYXIgZmluZGVyIHBhdHRlcm5zLFxuICAgICAqIGFzIGEgY29udmVuaWVuY2UgdG8gdGhlIGZpbmRlcidzIGJvb2trZWVwaW5nLjwvcD5cbiAgICAgKlxuICAgICAqIEBhdXRob3IgU2VhbiBPd2VuXG4gICAgICovXG4gICAgY2xhc3MgRmluZGVyUGF0dGVybiQxIGV4dGVuZHMgUmVzdWx0UG9pbnQge1xuICAgICAgICAvLyBGaW5kZXJQYXR0ZXJuKHBvc1g6IG51bWJlci8qZmxvYXQqLywgcG9zWTogbnVtYmVyLypmbG9hdCovLCBlc3RpbWF0ZWRNb2R1bGVTaXplOiBudW1iZXIvKmZsb2F0Ki8pIHtcbiAgICAgICAgLy8gICB0aGlzKHBvc1gsIHBvc1ksIGVzdGltYXRlZE1vZHVsZVNpemUsIDEpXG4gICAgICAgIC8vIH1cbiAgICAgICAgY29uc3RydWN0b3IocG9zWCAvKmZsb2F0Ki8sIHBvc1kgLypmbG9hdCovLCBlc3RpbWF0ZWRNb2R1bGVTaXplIC8qZmxvYXQqLywgY291bnQgLyppbnQqLykge1xuICAgICAgICAgICAgc3VwZXIocG9zWCwgcG9zWSk7XG4gICAgICAgICAgICB0aGlzLmVzdGltYXRlZE1vZHVsZVNpemUgPSBlc3RpbWF0ZWRNb2R1bGVTaXplO1xuICAgICAgICAgICAgdGhpcy5jb3VudCA9IGNvdW50O1xuICAgICAgICAgICAgaWYgKHVuZGVmaW5lZCA9PT0gY291bnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvdW50ID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBnZXRFc3RpbWF0ZWRNb2R1bGVTaXplKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXN0aW1hdGVkTW9kdWxlU2l6ZTtcbiAgICAgICAgfVxuICAgICAgICBnZXRDb3VudCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvdW50O1xuICAgICAgICB9XG4gICAgICAgIC8qXG4gICAgICAgIHZvaWQgaW5jcmVtZW50Q291bnQoKSB7XG4gICAgICAgICAgdGhpcy5jb3VudCsrXG4gICAgICAgIH1cbiAgICAgICAgICovXG4gICAgICAgIC8qKlxuICAgICAgICAgKiA8cD5EZXRlcm1pbmVzIGlmIHRoaXMgZmluZGVyIHBhdHRlcm4gXCJhYm91dCBlcXVhbHNcIiBhIGZpbmRlciBwYXR0ZXJuIGF0IHRoZSBzdGF0ZWRcbiAgICAgICAgICogcG9zaXRpb24gYW5kIHNpemUgLS0gbWVhbmluZywgaXQgaXMgYXQgbmVhcmx5IHRoZSBzYW1lIGNlbnRlciB3aXRoIG5lYXJseSB0aGUgc2FtZSBzaXplLjwvcD5cbiAgICAgICAgICovXG4gICAgICAgIGFib3V0RXF1YWxzKG1vZHVsZVNpemUgLypmbG9hdCovLCBpIC8qZmxvYXQqLywgaiAvKmZsb2F0Ki8pIHtcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyhpIC0gdGhpcy5nZXRZKCkpIDw9IG1vZHVsZVNpemUgJiYgTWF0aC5hYnMoaiAtIHRoaXMuZ2V0WCgpKSA8PSBtb2R1bGVTaXplKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbW9kdWxlU2l6ZURpZmYgPSBNYXRoLmFicyhtb2R1bGVTaXplIC0gdGhpcy5lc3RpbWF0ZWRNb2R1bGVTaXplKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbW9kdWxlU2l6ZURpZmYgPD0gMS4wIHx8IG1vZHVsZVNpemVEaWZmIDw9IHRoaXMuZXN0aW1hdGVkTW9kdWxlU2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ29tYmluZXMgdGhpcyBvYmplY3QncyBjdXJyZW50IGVzdGltYXRlIG9mIGEgZmluZGVyIHBhdHRlcm4gcG9zaXRpb24gYW5kIG1vZHVsZSBzaXplXG4gICAgICAgICAqIHdpdGggYSBuZXcgZXN0aW1hdGUuIEl0IHJldHVybnMgYSBuZXcge0Bjb2RlIEZpbmRlclBhdHRlcm59IGNvbnRhaW5pbmcgYSB3ZWlnaHRlZCBhdmVyYWdlXG4gICAgICAgICAqIGJhc2VkIG9uIGNvdW50LlxuICAgICAgICAgKi9cbiAgICAgICAgY29tYmluZUVzdGltYXRlKGkgLypmbG9hdCovLCBqIC8qZmxvYXQqLywgbmV3TW9kdWxlU2l6ZSAvKmZsb2F0Ki8pIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbWJpbmVkQ291bnQgPSB0aGlzLmNvdW50ICsgMTtcbiAgICAgICAgICAgIGNvbnN0IGNvbWJpbmVkWCA9ICh0aGlzLmNvdW50ICogdGhpcy5nZXRYKCkgKyBqKSAvIGNvbWJpbmVkQ291bnQ7XG4gICAgICAgICAgICBjb25zdCBjb21iaW5lZFkgPSAodGhpcy5jb3VudCAqIHRoaXMuZ2V0WSgpICsgaSkgLyBjb21iaW5lZENvdW50O1xuICAgICAgICAgICAgY29uc3QgY29tYmluZWRNb2R1bGVTaXplID0gKHRoaXMuY291bnQgKiB0aGlzLmVzdGltYXRlZE1vZHVsZVNpemUgKyBuZXdNb2R1bGVTaXplKSAvIGNvbWJpbmVkQ291bnQ7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZpbmRlclBhdHRlcm4kMShjb21iaW5lZFgsIGNvbWJpbmVkWSwgY29tYmluZWRNb2R1bGVTaXplLCBjb21iaW5lZENvdW50KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qXG4gICAgICogQ29weXJpZ2h0IDIwMDcgWlhpbmcgYXV0aG9yc1xuICAgICAqXG4gICAgICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgICAgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICAgICpcbiAgICAgKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICAgICAqXG4gICAgICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICAgICAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgICAgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgICAgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gICAgICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gICAgICovXG4gICAgLyoqXG4gICAgICogPHA+RW5jYXBzdWxhdGVzIGluZm9ybWF0aW9uIGFib3V0IGZpbmRlciBwYXR0ZXJucyBpbiBhbiBpbWFnZSwgaW5jbHVkaW5nIHRoZSBsb2NhdGlvbiBvZlxuICAgICAqIHRoZSB0aHJlZSBmaW5kZXIgcGF0dGVybnMsIGFuZCB0aGVpciBlc3RpbWF0ZWQgbW9kdWxlIHNpemUuPC9wPlxuICAgICAqXG4gICAgICogQGF1dGhvciBTZWFuIE93ZW5cbiAgICAgKi9cbiAgICBjbGFzcyBGaW5kZXJQYXR0ZXJuSW5mbyB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHBhdHRlcm5DZW50ZXJzKSB7XG4gICAgICAgICAgICB0aGlzLmJvdHRvbUxlZnQgPSBwYXR0ZXJuQ2VudGVyc1swXTtcbiAgICAgICAgICAgIHRoaXMudG9wTGVmdCA9IHBhdHRlcm5DZW50ZXJzWzFdO1xuICAgICAgICAgICAgdGhpcy50b3BSaWdodCA9IHBhdHRlcm5DZW50ZXJzWzJdO1xuICAgICAgICB9XG4gICAgICAgIGdldEJvdHRvbUxlZnQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ib3R0b21MZWZ0O1xuICAgICAgICB9XG4gICAgICAgIGdldFRvcExlZnQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b3BMZWZ0O1xuICAgICAgICB9XG4gICAgICAgIGdldFRvcFJpZ2h0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9wUmlnaHQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKlxuICAgICAqIENvcHlyaWdodCAyMDA3IFpYaW5nIGF1dGhvcnNcbiAgICAgKlxuICAgICAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gICAgICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgICAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgICAqXG4gICAgICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAgICAgKlxuICAgICAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgICAgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICAgICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gICAgICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICAgICAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICAgICAqL1xuICAgIC8qaW1wb3J0IGphdmEuaW8uU2VyaWFsaXphYmxlOyovXG4gICAgLyppbXBvcnQgamF2YS51dGlsLkFycmF5TGlzdDsqL1xuICAgIC8qaW1wb3J0IGphdmEudXRpbC5Db2xsZWN0aW9uczsqL1xuICAgIC8qaW1wb3J0IGphdmEudXRpbC5Db21wYXJhdG9yOyovXG4gICAgLyppbXBvcnQgamF2YS51dGlsLkxpc3Q7Ki9cbiAgICAvKmltcG9ydCBqYXZhLnV0aWwuTWFwOyovXG4gICAgLyoqXG4gICAgICogPHA+VGhpcyBjbGFzcyBhdHRlbXB0cyB0byBmaW5kIGZpbmRlciBwYXR0ZXJucyBpbiBhIFFSIENvZGUuIEZpbmRlciBwYXR0ZXJucyBhcmUgdGhlIHNxdWFyZVxuICAgICAqIG1hcmtlcnMgYXQgdGhyZWUgY29ybmVycyBvZiBhIFFSIENvZGUuPC9wPlxuICAgICAqXG4gICAgICogPHA+VGhpcyBjbGFzcyBpcyB0aHJlYWQtc2FmZSBidXQgbm90IHJlZW50cmFudC4gRWFjaCB0aHJlYWQgbXVzdCBhbGxvY2F0ZSBpdHMgb3duIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBhdXRob3IgU2VhbiBPd2VuXG4gICAgICovXG4gICAgY2xhc3MgRmluZGVyUGF0dGVybkZpbmRlciB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiA8cD5DcmVhdGVzIGEgZmluZGVyIHRoYXQgd2lsbCBzZWFyY2ggdGhlIGltYWdlIGZvciB0aHJlZSBmaW5kZXIgcGF0dGVybnMuPC9wPlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gaW1hZ2UgaW1hZ2UgdG8gc2VhcmNoXG4gICAgICAgICAqL1xuICAgICAgICAvLyBwdWJsaWMgY29uc3RydWN0b3IoaW1hZ2U6IEJpdE1hdHJpeCkge1xuICAgICAgICAvLyAgIHRoaXMoaW1hZ2UsIG51bGwpXG4gICAgICAgIC8vIH1cbiAgICAgICAgY29uc3RydWN0b3IoaW1hZ2UsIHJlc3VsdFBvaW50Q2FsbGJhY2spIHtcbiAgICAgICAgICAgIHRoaXMuaW1hZ2UgPSBpbWFnZTtcbiAgICAgICAgICAgIHRoaXMucmVzdWx0UG9pbnRDYWxsYmFjayA9IHJlc3VsdFBvaW50Q2FsbGJhY2s7XG4gICAgICAgICAgICB0aGlzLnBvc3NpYmxlQ2VudGVycyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5jcm9zc0NoZWNrU3RhdGVDb3VudCA9IG5ldyBJbnQzMkFycmF5KDUpO1xuICAgICAgICAgICAgdGhpcy5yZXN1bHRQb2ludENhbGxiYWNrID0gcmVzdWx0UG9pbnRDYWxsYmFjaztcbiAgICAgICAgfVxuICAgICAgICBnZXRJbWFnZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmltYWdlO1xuICAgICAgICB9XG4gICAgICAgIGdldFBvc3NpYmxlQ2VudGVycygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBvc3NpYmxlQ2VudGVycztcbiAgICAgICAgfVxuICAgICAgICBmaW5kKGhpbnRzKSB7XG4gICAgICAgICAgICBjb25zdCB0cnlIYXJkZXIgPSAoaGludHMgIT09IG51bGwgJiYgaGludHMgIT09IHVuZGVmaW5lZCkgJiYgdW5kZWZpbmVkICE9PSBoaW50cy5nZXQoRGVjb2RlSGludFR5cGUkMS5UUllfSEFSREVSKTtcbiAgICAgICAgICAgIGNvbnN0IHB1cmVCYXJjb2RlID0gKGhpbnRzICE9PSBudWxsICYmIGhpbnRzICE9PSB1bmRlZmluZWQpICYmIHVuZGVmaW5lZCAhPT0gaGludHMuZ2V0KERlY29kZUhpbnRUeXBlJDEuUFVSRV9CQVJDT0RFKTtcbiAgICAgICAgICAgIGNvbnN0IGltYWdlID0gdGhpcy5pbWFnZTtcbiAgICAgICAgICAgIGNvbnN0IG1heEkgPSBpbWFnZS5nZXRIZWlnaHQoKTtcbiAgICAgICAgICAgIGNvbnN0IG1heEogPSBpbWFnZS5nZXRXaWR0aCgpO1xuICAgICAgICAgICAgLy8gV2UgYXJlIGxvb2tpbmcgZm9yIGJsYWNrL3doaXRlL2JsYWNrL3doaXRlL2JsYWNrIG1vZHVsZXMgaW5cbiAgICAgICAgICAgIC8vIDE6MTozOjE6MSByYXRpbzsgdGhpcyB0cmFja3MgdGhlIG51bWJlciBvZiBzdWNoIG1vZHVsZXMgc2VlbiBzbyBmYXJcbiAgICAgICAgICAgIC8vIExldCdzIGFzc3VtZSB0aGF0IHRoZSBtYXhpbXVtIHZlcnNpb24gUVIgQ29kZSB3ZSBzdXBwb3J0IHRha2VzIHVwIDEvNCB0aGUgaGVpZ2h0IG9mIHRoZVxuICAgICAgICAgICAgLy8gaW1hZ2UsIGFuZCB0aGVuIGFjY291bnQgZm9yIHRoZSBjZW50ZXIgYmVpbmcgMyBtb2R1bGVzIGluIHNpemUuIFRoaXMgZ2l2ZXMgdGhlIHNtYWxsZXN0XG4gICAgICAgICAgICAvLyBudW1iZXIgb2YgcGl4ZWxzIHRoZSBjZW50ZXIgY291bGQgYmUsIHNvIHNraXAgdGhpcyBvZnRlbi4gV2hlbiB0cnlpbmcgaGFyZGVyLCBsb29rIGZvciBhbGxcbiAgICAgICAgICAgIC8vIFFSIHZlcnNpb25zIHJlZ2FyZGxlc3Mgb2YgaG93IGRlbnNlIHRoZXkgYXJlLlxuICAgICAgICAgICAgbGV0IGlTa2lwID0gTWF0aC5mbG9vcigoMyAqIG1heEkpIC8gKDQgKiBGaW5kZXJQYXR0ZXJuRmluZGVyLk1BWF9NT0RVTEVTKSk7XG4gICAgICAgICAgICBpZiAoaVNraXAgPCBGaW5kZXJQYXR0ZXJuRmluZGVyLk1JTl9TS0lQIHx8IHRyeUhhcmRlcikge1xuICAgICAgICAgICAgICAgIGlTa2lwID0gRmluZGVyUGF0dGVybkZpbmRlci5NSU5fU0tJUDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBkb25lID0gZmFsc2U7XG4gICAgICAgICAgICBjb25zdCBzdGF0ZUNvdW50ID0gbmV3IEludDMyQXJyYXkoNSk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gaVNraXAgLSAxOyBpIDwgbWF4SSAmJiAhZG9uZTsgaSArPSBpU2tpcCkge1xuICAgICAgICAgICAgICAgIC8vIEdldCBhIHJvdyBvZiBibGFjay93aGl0ZSB2YWx1ZXNcbiAgICAgICAgICAgICAgICBzdGF0ZUNvdW50WzBdID0gMDtcbiAgICAgICAgICAgICAgICBzdGF0ZUNvdW50WzFdID0gMDtcbiAgICAgICAgICAgICAgICBzdGF0ZUNvdW50WzJdID0gMDtcbiAgICAgICAgICAgICAgICBzdGF0ZUNvdW50WzNdID0gMDtcbiAgICAgICAgICAgICAgICBzdGF0ZUNvdW50WzRdID0gMDtcbiAgICAgICAgICAgICAgICBsZXQgY3VycmVudFN0YXRlID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG1heEo7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW1hZ2UuZ2V0KGosIGkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBCbGFjayBwaXhlbFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChjdXJyZW50U3RhdGUgJiAxKSA9PT0gMSkgeyAvLyBDb3VudGluZyB3aGl0ZSBwaXhlbHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50U3RhdGUrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlQ291bnRbY3VycmVudFN0YXRlXSsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgeyAvLyBXaGl0ZSBwaXhlbFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChjdXJyZW50U3RhdGUgJiAxKSA9PT0gMCkgeyAvLyBDb3VudGluZyBibGFjayBwaXhlbHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudFN0YXRlID09PSA0KSB7IC8vIEEgd2lubmVyP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoRmluZGVyUGF0dGVybkZpbmRlci5mb3VuZFBhdHRlcm5Dcm9zcyhzdGF0ZUNvdW50KSkgeyAvLyBZZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbmZpcm1lZCA9IHRoaXMuaGFuZGxlUG9zc2libGVDZW50ZXIoc3RhdGVDb3VudCwgaSwgaiwgcHVyZUJhcmNvZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmZpcm1lZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN0YXJ0IGV4YW1pbmluZyBldmVyeSBvdGhlciBsaW5lLiBDaGVja2luZyBlYWNoIGxpbmUgdHVybmVkIG91dCB0byBiZSB0b29cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBleHBlbnNpdmUgYW5kIGRpZG4ndCBpbXByb3ZlIHBlcmZvcm1hbmNlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlTa2lwID0gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5oYXNTa2lwcGVkID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUgPSB0aGlzLmhhdmVNdWx0aXBseUNvbmZpcm1lZENlbnRlcnMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJvd1NraXAgPSB0aGlzLmZpbmRSb3dTa2lwKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyb3dTa2lwID4gc3RhdGVDb3VudFsyXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2tpcCByb3dzIGJldHdlZW4gcm93IG9mIGxvd2VyIGNvbmZpcm1lZCBjZW50ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFuZCB0b3Agb2YgcHJlc3VtZWQgdGhpcmQgY29uZmlybWVkIGNlbnRlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYnV0IGJhY2sgdXAgYSBiaXQgdG8gZ2V0IGEgZnVsbCBjaGFuY2Ugb2YgZGV0ZWN0aW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpdCwgZW50aXJlIHdpZHRoIG9mIGNlbnRlciBvZiBmaW5kZXIgcGF0dGVyblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2tpcCBieSByb3dTa2lwLCBidXQgYmFjayBvZmYgYnkgc3RhdGVDb3VudFsyXSAoc2l6ZSBvZiBsYXN0IGNlbnRlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb2YgcGF0dGVybiB3ZSBzYXcpIHRvIGJlIGNvbnNlcnZhdGl2ZSwgYW5kIGFsc28gYmFjayBvZmYgYnkgaVNraXAgd2hpY2hcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlzIGFib3V0IHRvIGJlIHJlLWFkZGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpICs9IHJvd1NraXAgLSBzdGF0ZUNvdW50WzJdIC0gaVNraXA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqID0gbWF4SiAtIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZUNvdW50WzBdID0gc3RhdGVDb3VudFsyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZUNvdW50WzFdID0gc3RhdGVDb3VudFszXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZUNvdW50WzJdID0gc3RhdGVDb3VudFs0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZUNvdW50WzNdID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZUNvdW50WzRdID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50U3RhdGUgPSAzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2xlYXIgc3RhdGUgdG8gc3RhcnQgbG9va2luZyBhZ2FpblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFN0YXRlID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlQ291bnRbMF0gPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVDb3VudFsxXSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZUNvdW50WzJdID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlQ291bnRbM10gPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVDb3VudFs0XSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7IC8vIE5vLCBzaGlmdCBjb3VudHMgYmFjayBieSB0d29cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlQ291bnRbMF0gPSBzdGF0ZUNvdW50WzJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVDb3VudFsxXSA9IHN0YXRlQ291bnRbM107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZUNvdW50WzJdID0gc3RhdGVDb3VudFs0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlQ291bnRbM10gPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVDb3VudFs0XSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50U3RhdGUgPSAzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZUNvdW50WysrY3VycmVudFN0YXRlXSsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgeyAvLyBDb3VudGluZyB3aGl0ZSBwaXhlbHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZUNvdW50W2N1cnJlbnRTdGF0ZV0rKztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoRmluZGVyUGF0dGVybkZpbmRlci5mb3VuZFBhdHRlcm5Dcm9zcyhzdGF0ZUNvdW50KSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb25maXJtZWQgPSB0aGlzLmhhbmRsZVBvc3NpYmxlQ2VudGVyKHN0YXRlQ291bnQsIGksIG1heEosIHB1cmVCYXJjb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmZpcm1lZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaVNraXAgPSBzdGF0ZUNvdW50WzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaGFzU2tpcHBlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZvdW5kIGEgdGhpcmQgb25lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSA9IHRoaXMuaGF2ZU11bHRpcGx5Q29uZmlybWVkQ2VudGVycygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcGF0dGVybkluZm8gPSB0aGlzLnNlbGVjdEJlc3RQYXR0ZXJucygpO1xuICAgICAgICAgICAgUmVzdWx0UG9pbnQub3JkZXJCZXN0UGF0dGVybnMocGF0dGVybkluZm8pO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBGaW5kZXJQYXR0ZXJuSW5mbyhwYXR0ZXJuSW5mbyk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdpdmVuIGEgY291bnQgb2YgYmxhY2svd2hpdGUvYmxhY2svd2hpdGUvYmxhY2sgcGl4ZWxzIGp1c3Qgc2VlbiBhbmQgYW4gZW5kIHBvc2l0aW9uLFxuICAgICAgICAgKiBmaWd1cmVzIHRoZSBsb2NhdGlvbiBvZiB0aGUgY2VudGVyIG9mIHRoaXMgcnVuLlxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGNlbnRlckZyb21FbmQoc3RhdGVDb3VudCwgZW5kIC8qaW50Ki8pIHtcbiAgICAgICAgICAgIHJldHVybiAoZW5kIC0gc3RhdGVDb3VudFs0XSAtIHN0YXRlQ291bnRbM10pIC0gc3RhdGVDb3VudFsyXSAvIDIuMDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHN0YXRlQ291bnQgY291bnQgb2YgYmxhY2svd2hpdGUvYmxhY2svd2hpdGUvYmxhY2sgcGl4ZWxzIGp1c3QgcmVhZFxuICAgICAgICAgKiBAcmV0dXJuIHRydWUgaWZmIHRoZSBwcm9wb3J0aW9ucyBvZiB0aGUgY291bnRzIGlzIGNsb3NlIGVub3VnaCB0byB0aGUgMS8xLzMvMS8xIHJhdGlvc1xuICAgICAgICAgKiAgICAgICAgIHVzZWQgYnkgZmluZGVyIHBhdHRlcm5zIHRvIGJlIGNvbnNpZGVyZWQgYSBtYXRjaFxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGZvdW5kUGF0dGVybkNyb3NzKHN0YXRlQ291bnQpIHtcbiAgICAgICAgICAgIGxldCB0b3RhbE1vZHVsZVNpemUgPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA1OyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb3VudCA9IHN0YXRlQ291bnRbaV07XG4gICAgICAgICAgICAgICAgaWYgKGNvdW50ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdG90YWxNb2R1bGVTaXplICs9IGNvdW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRvdGFsTW9kdWxlU2l6ZSA8IDcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBtb2R1bGVTaXplID0gdG90YWxNb2R1bGVTaXplIC8gNy4wO1xuICAgICAgICAgICAgY29uc3QgbWF4VmFyaWFuY2UgPSBtb2R1bGVTaXplIC8gMi4wO1xuICAgICAgICAgICAgLy8gQWxsb3cgbGVzcyB0aGFuIDUwJSB2YXJpYW5jZSBmcm9tIDEtMS0zLTEtMSBwcm9wb3J0aW9uc1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguYWJzKG1vZHVsZVNpemUgLSBzdGF0ZUNvdW50WzBdKSA8IG1heFZhcmlhbmNlICYmXG4gICAgICAgICAgICAgICAgTWF0aC5hYnMobW9kdWxlU2l6ZSAtIHN0YXRlQ291bnRbMV0pIDwgbWF4VmFyaWFuY2UgJiZcbiAgICAgICAgICAgICAgICBNYXRoLmFicygzLjAgKiBtb2R1bGVTaXplIC0gc3RhdGVDb3VudFsyXSkgPCAzICogbWF4VmFyaWFuY2UgJiZcbiAgICAgICAgICAgICAgICBNYXRoLmFicyhtb2R1bGVTaXplIC0gc3RhdGVDb3VudFszXSkgPCBtYXhWYXJpYW5jZSAmJlxuICAgICAgICAgICAgICAgIE1hdGguYWJzKG1vZHVsZVNpemUgLSBzdGF0ZUNvdW50WzRdKSA8IG1heFZhcmlhbmNlO1xuICAgICAgICB9XG4gICAgICAgIGdldENyb3NzQ2hlY2tTdGF0ZUNvdW50KCkge1xuICAgICAgICAgICAgY29uc3QgY3Jvc3NDaGVja1N0YXRlQ291bnQgPSB0aGlzLmNyb3NzQ2hlY2tTdGF0ZUNvdW50O1xuICAgICAgICAgICAgY3Jvc3NDaGVja1N0YXRlQ291bnRbMF0gPSAwO1xuICAgICAgICAgICAgY3Jvc3NDaGVja1N0YXRlQ291bnRbMV0gPSAwO1xuICAgICAgICAgICAgY3Jvc3NDaGVja1N0YXRlQ291bnRbMl0gPSAwO1xuICAgICAgICAgICAgY3Jvc3NDaGVja1N0YXRlQ291bnRbM10gPSAwO1xuICAgICAgICAgICAgY3Jvc3NDaGVja1N0YXRlQ291bnRbNF0gPSAwO1xuICAgICAgICAgICAgcmV0dXJuIGNyb3NzQ2hlY2tTdGF0ZUNvdW50O1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZnRlciBhIHZlcnRpY2FsIGFuZCBob3Jpem9udGFsIHNjYW4gZmluZHMgYSBwb3RlbnRpYWwgZmluZGVyIHBhdHRlcm4sIHRoaXMgbWV0aG9kXG4gICAgICAgICAqIFwiY3Jvc3MtY3Jvc3MtY3Jvc3MtY2hlY2tzXCIgYnkgc2Nhbm5pbmcgZG93biBkaWFnb25hbGx5IHRocm91Z2ggdGhlIGNlbnRlciBvZiB0aGUgcG9zc2libGVcbiAgICAgICAgICogZmluZGVyIHBhdHRlcm4gdG8gc2VlIGlmIHRoZSBzYW1lIHByb3BvcnRpb24gaXMgZGV0ZWN0ZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBzdGFydEkgcm93IHdoZXJlIGEgZmluZGVyIHBhdHRlcm4gd2FzIGRldGVjdGVkXG4gICAgICAgICAqIEBwYXJhbSBjZW50ZXJKIGNlbnRlciBvZiB0aGUgc2VjdGlvbiB0aGF0IGFwcGVhcnMgdG8gY3Jvc3MgYSBmaW5kZXIgcGF0dGVyblxuICAgICAgICAgKiBAcGFyYW0gbWF4Q291bnQgbWF4aW11bSByZWFzb25hYmxlIG51bWJlciBvZiBtb2R1bGVzIHRoYXQgc2hvdWxkIGJlXG4gICAgICAgICAqICBvYnNlcnZlZCBpbiBhbnkgcmVhZGluZyBzdGF0ZSwgYmFzZWQgb24gdGhlIHJlc3VsdHMgb2YgdGhlIGhvcml6b250YWwgc2NhblxuICAgICAgICAgKiBAcGFyYW0gb3JpZ2luYWxTdGF0ZUNvdW50VG90YWwgVGhlIG9yaWdpbmFsIHN0YXRlIGNvdW50IHRvdGFsLlxuICAgICAgICAgKiBAcmV0dXJuIHRydWUgaWYgcHJvcG9ydGlvbnMgYXJlIHdpdGhpbmcgZXhwZWN0ZWQgbGltaXRzXG4gICAgICAgICAqL1xuICAgICAgICBjcm9zc0NoZWNrRGlhZ29uYWwoc3RhcnRJIC8qaW50Ki8sIGNlbnRlckogLyppbnQqLywgbWF4Q291bnQgLyppbnQqLywgb3JpZ2luYWxTdGF0ZUNvdW50VG90YWwgLyppbnQqLykge1xuICAgICAgICAgICAgY29uc3Qgc3RhdGVDb3VudCA9IHRoaXMuZ2V0Q3Jvc3NDaGVja1N0YXRlQ291bnQoKTtcbiAgICAgICAgICAgIC8vIFN0YXJ0IGNvdW50aW5nIHVwLCBsZWZ0IGZyb20gY2VudGVyIGZpbmRpbmcgYmxhY2sgY2VudGVyIG1hc3NcbiAgICAgICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgICAgIGNvbnN0IGltYWdlID0gdGhpcy5pbWFnZTtcbiAgICAgICAgICAgIHdoaWxlIChzdGFydEkgPj0gaSAmJiBjZW50ZXJKID49IGkgJiYgaW1hZ2UuZ2V0KGNlbnRlckogLSBpLCBzdGFydEkgLSBpKSkge1xuICAgICAgICAgICAgICAgIHN0YXRlQ291bnRbMl0rKztcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RhcnRJIDwgaSB8fCBjZW50ZXJKIDwgaSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENvbnRpbnVlIHVwLCBsZWZ0IGZpbmRpbmcgd2hpdGUgc3BhY2VcbiAgICAgICAgICAgIHdoaWxlIChzdGFydEkgPj0gaSAmJiBjZW50ZXJKID49IGkgJiYgIWltYWdlLmdldChjZW50ZXJKIC0gaSwgc3RhcnRJIC0gaSkgJiZcbiAgICAgICAgICAgICAgICBzdGF0ZUNvdW50WzFdIDw9IG1heENvdW50KSB7XG4gICAgICAgICAgICAgICAgc3RhdGVDb3VudFsxXSsrO1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIGFscmVhZHkgdG9vIG1hbnkgbW9kdWxlcyBpbiB0aGlzIHN0YXRlIG9yIHJhbiBvZmYgdGhlIGVkZ2U6XG4gICAgICAgICAgICBpZiAoc3RhcnRJIDwgaSB8fCBjZW50ZXJKIDwgaSB8fCBzdGF0ZUNvdW50WzFdID4gbWF4Q291bnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDb250aW51ZSB1cCwgbGVmdCBmaW5kaW5nIGJsYWNrIGJvcmRlclxuICAgICAgICAgICAgd2hpbGUgKHN0YXJ0SSA+PSBpICYmIGNlbnRlckogPj0gaSAmJiBpbWFnZS5nZXQoY2VudGVySiAtIGksIHN0YXJ0SSAtIGkpICYmXG4gICAgICAgICAgICAgICAgc3RhdGVDb3VudFswXSA8PSBtYXhDb3VudCkge1xuICAgICAgICAgICAgICAgIHN0YXRlQ291bnRbMF0rKztcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RhdGVDb3VudFswXSA+IG1heENvdW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbWF4SSA9IGltYWdlLmdldEhlaWdodCgpO1xuICAgICAgICAgICAgY29uc3QgbWF4SiA9IGltYWdlLmdldFdpZHRoKCk7XG4gICAgICAgICAgICAvLyBOb3cgYWxzbyBjb3VudCBkb3duLCByaWdodCBmcm9tIGNlbnRlclxuICAgICAgICAgICAgaSA9IDE7XG4gICAgICAgICAgICB3aGlsZSAoc3RhcnRJICsgaSA8IG1heEkgJiYgY2VudGVySiArIGkgPCBtYXhKICYmIGltYWdlLmdldChjZW50ZXJKICsgaSwgc3RhcnRJICsgaSkpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZUNvdW50WzJdKys7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUmFuIG9mZiB0aGUgZWRnZT9cbiAgICAgICAgICAgIGlmIChzdGFydEkgKyBpID49IG1heEkgfHwgY2VudGVySiArIGkgPj0gbWF4Sikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChzdGFydEkgKyBpIDwgbWF4SSAmJiBjZW50ZXJKICsgaSA8IG1heEogJiYgIWltYWdlLmdldChjZW50ZXJKICsgaSwgc3RhcnRJICsgaSkgJiZcbiAgICAgICAgICAgICAgICBzdGF0ZUNvdW50WzNdIDwgbWF4Q291bnQpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZUNvdW50WzNdKys7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0YXJ0SSArIGkgPj0gbWF4SSB8fCBjZW50ZXJKICsgaSA+PSBtYXhKIHx8IHN0YXRlQ291bnRbM10gPj0gbWF4Q291bnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoc3RhcnRJICsgaSA8IG1heEkgJiYgY2VudGVySiArIGkgPCBtYXhKICYmIGltYWdlLmdldChjZW50ZXJKICsgaSwgc3RhcnRJICsgaSkgJiZcbiAgICAgICAgICAgICAgICBzdGF0ZUNvdW50WzRdIDwgbWF4Q291bnQpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZUNvdW50WzRdKys7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0YXRlQ291bnRbNF0gPj0gbWF4Q291bnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiB3ZSBmb3VuZCBhIGZpbmRlci1wYXR0ZXJuLWxpa2Ugc2VjdGlvbiwgYnV0IGl0cyBzaXplIGlzIG1vcmUgdGhhbiAxMDAlIGRpZmZlcmVudCB0aGFuXG4gICAgICAgICAgICAvLyB0aGUgb3JpZ2luYWwsIGFzc3VtZSBpdCdzIGEgZmFsc2UgcG9zaXRpdmVcbiAgICAgICAgICAgIGNvbnN0IHN0YXRlQ291bnRUb3RhbCA9IHN0YXRlQ291bnRbMF0gKyBzdGF0ZUNvdW50WzFdICsgc3RhdGVDb3VudFsyXSArIHN0YXRlQ291bnRbM10gKyBzdGF0ZUNvdW50WzRdO1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguYWJzKHN0YXRlQ291bnRUb3RhbCAtIG9yaWdpbmFsU3RhdGVDb3VudFRvdGFsKSA8IDIgKiBvcmlnaW5hbFN0YXRlQ291bnRUb3RhbCAmJlxuICAgICAgICAgICAgICAgIEZpbmRlclBhdHRlcm5GaW5kZXIuZm91bmRQYXR0ZXJuQ3Jvc3Moc3RhdGVDb3VudCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIDxwPkFmdGVyIGEgaG9yaXpvbnRhbCBzY2FuIGZpbmRzIGEgcG90ZW50aWFsIGZpbmRlciBwYXR0ZXJuLCB0aGlzIG1ldGhvZFxuICAgICAgICAgKiBcImNyb3NzLWNoZWNrc1wiIGJ5IHNjYW5uaW5nIGRvd24gdmVydGljYWxseSB0aHJvdWdoIHRoZSBjZW50ZXIgb2YgdGhlIHBvc3NpYmxlXG4gICAgICAgICAqIGZpbmRlciBwYXR0ZXJuIHRvIHNlZSBpZiB0aGUgc2FtZSBwcm9wb3J0aW9uIGlzIGRldGVjdGVkLjwvcD5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHN0YXJ0SSByb3cgd2hlcmUgYSBmaW5kZXIgcGF0dGVybiB3YXMgZGV0ZWN0ZWRcbiAgICAgICAgICogQHBhcmFtIGNlbnRlckogY2VudGVyIG9mIHRoZSBzZWN0aW9uIHRoYXQgYXBwZWFycyB0byBjcm9zcyBhIGZpbmRlciBwYXR0ZXJuXG4gICAgICAgICAqIEBwYXJhbSBtYXhDb3VudCBtYXhpbXVtIHJlYXNvbmFibGUgbnVtYmVyIG9mIG1vZHVsZXMgdGhhdCBzaG91bGQgYmVcbiAgICAgICAgICogb2JzZXJ2ZWQgaW4gYW55IHJlYWRpbmcgc3RhdGUsIGJhc2VkIG9uIHRoZSByZXN1bHRzIG9mIHRoZSBob3Jpem9udGFsIHNjYW5cbiAgICAgICAgICogQHJldHVybiB2ZXJ0aWNhbCBjZW50ZXIgb2YgZmluZGVyIHBhdHRlcm4sIG9yIHtAbGluayBGbG9hdCNOYU59IGlmIG5vdCBmb3VuZFxuICAgICAgICAgKi9cbiAgICAgICAgY3Jvc3NDaGVja1ZlcnRpY2FsKHN0YXJ0SSAvKmludCovLCBjZW50ZXJKIC8qaW50Ki8sIG1heENvdW50IC8qaW50Ki8sIG9yaWdpbmFsU3RhdGVDb3VudFRvdGFsIC8qaW50Ki8pIHtcbiAgICAgICAgICAgIGNvbnN0IGltYWdlID0gdGhpcy5pbWFnZTtcbiAgICAgICAgICAgIGNvbnN0IG1heEkgPSBpbWFnZS5nZXRIZWlnaHQoKTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXRlQ291bnQgPSB0aGlzLmdldENyb3NzQ2hlY2tTdGF0ZUNvdW50KCk7XG4gICAgICAgICAgICAvLyBTdGFydCBjb3VudGluZyB1cCBmcm9tIGNlbnRlclxuICAgICAgICAgICAgbGV0IGkgPSBzdGFydEk7XG4gICAgICAgICAgICB3aGlsZSAoaSA+PSAwICYmIGltYWdlLmdldChjZW50ZXJKLCBpKSkge1xuICAgICAgICAgICAgICAgIHN0YXRlQ291bnRbMl0rKztcbiAgICAgICAgICAgICAgICBpLS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaSA8IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKGkgPj0gMCAmJiAhaW1hZ2UuZ2V0KGNlbnRlckosIGkpICYmIHN0YXRlQ291bnRbMV0gPD0gbWF4Q291bnQpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZUNvdW50WzFdKys7XG4gICAgICAgICAgICAgICAgaS0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgYWxyZWFkeSB0b28gbWFueSBtb2R1bGVzIGluIHRoaXMgc3RhdGUgb3IgcmFuIG9mZiB0aGUgZWRnZTpcbiAgICAgICAgICAgIGlmIChpIDwgMCB8fCBzdGF0ZUNvdW50WzFdID4gbWF4Q291bnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKGkgPj0gMCAmJiBpbWFnZS5nZXQoY2VudGVySiwgaSkgJiYgc3RhdGVDb3VudFswXSA8PSBtYXhDb3VudCkge1xuICAgICAgICAgICAgICAgIHN0YXRlQ291bnRbMF0rKztcbiAgICAgICAgICAgICAgICBpLS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RhdGVDb3VudFswXSA+IG1heENvdW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE5vdyBhbHNvIGNvdW50IGRvd24gZnJvbSBjZW50ZXJcbiAgICAgICAgICAgIGkgPSBzdGFydEkgKyAxO1xuICAgICAgICAgICAgd2hpbGUgKGkgPCBtYXhJICYmIGltYWdlLmdldChjZW50ZXJKLCBpKSkge1xuICAgICAgICAgICAgICAgIHN0YXRlQ291bnRbMl0rKztcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaSA9PT0gbWF4SSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoaSA8IG1heEkgJiYgIWltYWdlLmdldChjZW50ZXJKLCBpKSAmJiBzdGF0ZUNvdW50WzNdIDwgbWF4Q291bnQpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZUNvdW50WzNdKys7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGkgPT09IG1heEkgfHwgc3RhdGVDb3VudFszXSA+PSBtYXhDb3VudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoaSA8IG1heEkgJiYgaW1hZ2UuZ2V0KGNlbnRlckosIGkpICYmIHN0YXRlQ291bnRbNF0gPCBtYXhDb3VudCkge1xuICAgICAgICAgICAgICAgIHN0YXRlQ291bnRbNF0rKztcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RhdGVDb3VudFs0XSA+PSBtYXhDb3VudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiB3ZSBmb3VuZCBhIGZpbmRlci1wYXR0ZXJuLWxpa2Ugc2VjdGlvbiwgYnV0IGl0cyBzaXplIGlzIG1vcmUgdGhhbiA0MCUgZGlmZmVyZW50IHRoYW5cbiAgICAgICAgICAgIC8vIHRoZSBvcmlnaW5hbCwgYXNzdW1lIGl0J3MgYSBmYWxzZSBwb3NpdGl2ZVxuICAgICAgICAgICAgY29uc3Qgc3RhdGVDb3VudFRvdGFsID0gc3RhdGVDb3VudFswXSArIHN0YXRlQ291bnRbMV0gKyBzdGF0ZUNvdW50WzJdICsgc3RhdGVDb3VudFszXSArXG4gICAgICAgICAgICAgICAgc3RhdGVDb3VudFs0XTtcbiAgICAgICAgICAgIGlmICg1ICogTWF0aC5hYnMoc3RhdGVDb3VudFRvdGFsIC0gb3JpZ2luYWxTdGF0ZUNvdW50VG90YWwpID49IDIgKiBvcmlnaW5hbFN0YXRlQ291bnRUb3RhbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gRmluZGVyUGF0dGVybkZpbmRlci5mb3VuZFBhdHRlcm5Dcm9zcyhzdGF0ZUNvdW50KSA/IEZpbmRlclBhdHRlcm5GaW5kZXIuY2VudGVyRnJvbUVuZChzdGF0ZUNvdW50LCBpKSA6IE5hTjtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogPHA+TGlrZSB7QGxpbmsgI2Nyb3NzQ2hlY2tWZXJ0aWNhbChpbnQsIGludCwgaW50LCBpbnQpfSwgYW5kIGluIGZhY3QgaXMgYmFzaWNhbGx5IGlkZW50aWNhbCxcbiAgICAgICAgICogZXhjZXB0IGl0IHJlYWRzIGhvcml6b250YWxseSBpbnN0ZWFkIG9mIHZlcnRpY2FsbHkuIFRoaXMgaXMgdXNlZCB0byBjcm9zcy1jcm9zc1xuICAgICAgICAgKiBjaGVjayBhIHZlcnRpY2FsIGNyb3NzIGNoZWNrIGFuZCBsb2NhdGUgdGhlIHJlYWwgY2VudGVyIG9mIHRoZSBhbGlnbm1lbnQgcGF0dGVybi48L3A+XG4gICAgICAgICAqL1xuICAgICAgICBjcm9zc0NoZWNrSG9yaXpvbnRhbChzdGFydEogLyppbnQqLywgY2VudGVySSAvKmludCovLCBtYXhDb3VudCAvKmludCovLCBvcmlnaW5hbFN0YXRlQ291bnRUb3RhbCAvKmludCovKSB7XG4gICAgICAgICAgICBjb25zdCBpbWFnZSA9IHRoaXMuaW1hZ2U7XG4gICAgICAgICAgICBjb25zdCBtYXhKID0gaW1hZ2UuZ2V0V2lkdGgoKTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXRlQ291bnQgPSB0aGlzLmdldENyb3NzQ2hlY2tTdGF0ZUNvdW50KCk7XG4gICAgICAgICAgICBsZXQgaiA9IHN0YXJ0SjtcbiAgICAgICAgICAgIHdoaWxlIChqID49IDAgJiYgaW1hZ2UuZ2V0KGosIGNlbnRlckkpKSB7XG4gICAgICAgICAgICAgICAgc3RhdGVDb3VudFsyXSsrO1xuICAgICAgICAgICAgICAgIGotLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChqIDwgMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoaiA+PSAwICYmICFpbWFnZS5nZXQoaiwgY2VudGVySSkgJiYgc3RhdGVDb3VudFsxXSA8PSBtYXhDb3VudCkge1xuICAgICAgICAgICAgICAgIHN0YXRlQ291bnRbMV0rKztcbiAgICAgICAgICAgICAgICBqLS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaiA8IDAgfHwgc3RhdGVDb3VudFsxXSA+IG1heENvdW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChqID49IDAgJiYgaW1hZ2UuZ2V0KGosIGNlbnRlckkpICYmIHN0YXRlQ291bnRbMF0gPD0gbWF4Q291bnQpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZUNvdW50WzBdKys7XG4gICAgICAgICAgICAgICAgai0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0YXRlQ291bnRbMF0gPiBtYXhDb3VudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBqID0gc3RhcnRKICsgMTtcbiAgICAgICAgICAgIHdoaWxlIChqIDwgbWF4SiAmJiBpbWFnZS5nZXQoaiwgY2VudGVySSkpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZUNvdW50WzJdKys7XG4gICAgICAgICAgICAgICAgaisrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGogPT09IG1heEopIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKGogPCBtYXhKICYmICFpbWFnZS5nZXQoaiwgY2VudGVySSkgJiYgc3RhdGVDb3VudFszXSA8IG1heENvdW50KSB7XG4gICAgICAgICAgICAgICAgc3RhdGVDb3VudFszXSsrO1xuICAgICAgICAgICAgICAgIGorKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChqID09PSBtYXhKIHx8IHN0YXRlQ291bnRbM10gPj0gbWF4Q291bnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKGogPCBtYXhKICYmIGltYWdlLmdldChqLCBjZW50ZXJJKSAmJiBzdGF0ZUNvdW50WzRdIDwgbWF4Q291bnQpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZUNvdW50WzRdKys7XG4gICAgICAgICAgICAgICAgaisrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0YXRlQ291bnRbNF0gPj0gbWF4Q291bnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgd2UgZm91bmQgYSBmaW5kZXItcGF0dGVybi1saWtlIHNlY3Rpb24sIGJ1dCBpdHMgc2l6ZSBpcyBzaWduaWZpY2FudGx5IGRpZmZlcmVudCB0aGFuXG4gICAgICAgICAgICAvLyB0aGUgb3JpZ2luYWwsIGFzc3VtZSBpdCdzIGEgZmFsc2UgcG9zaXRpdmVcbiAgICAgICAgICAgIGNvbnN0IHN0YXRlQ291bnRUb3RhbCA9IHN0YXRlQ291bnRbMF0gKyBzdGF0ZUNvdW50WzFdICsgc3RhdGVDb3VudFsyXSArIHN0YXRlQ291bnRbM10gK1xuICAgICAgICAgICAgICAgIHN0YXRlQ291bnRbNF07XG4gICAgICAgICAgICBpZiAoNSAqIE1hdGguYWJzKHN0YXRlQ291bnRUb3RhbCAtIG9yaWdpbmFsU3RhdGVDb3VudFRvdGFsKSA+PSBvcmlnaW5hbFN0YXRlQ291bnRUb3RhbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gRmluZGVyUGF0dGVybkZpbmRlci5mb3VuZFBhdHRlcm5Dcm9zcyhzdGF0ZUNvdW50KSA/IEZpbmRlclBhdHRlcm5GaW5kZXIuY2VudGVyRnJvbUVuZChzdGF0ZUNvdW50LCBqKSA6IE5hTjtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogPHA+VGhpcyBpcyBjYWxsZWQgd2hlbiBhIGhvcml6b250YWwgc2NhbiBmaW5kcyBhIHBvc3NpYmxlIGFsaWdubWVudCBwYXR0ZXJuLiBJdCB3aWxsXG4gICAgICAgICAqIGNyb3NzIGNoZWNrIHdpdGggYSB2ZXJ0aWNhbCBzY2FuLCBhbmQgaWYgc3VjY2Vzc2Z1bCwgd2lsbCwgYWgsIGNyb3NzLWNyb3NzLWNoZWNrXG4gICAgICAgICAqIHdpdGggYW5vdGhlciBob3Jpem9udGFsIHNjYW4uIFRoaXMgaXMgbmVlZGVkIHByaW1hcmlseSB0byBsb2NhdGUgdGhlIHJlYWwgaG9yaXpvbnRhbFxuICAgICAgICAgKiBjZW50ZXIgb2YgdGhlIHBhdHRlcm4gaW4gY2FzZXMgb2YgZXh0cmVtZSBza2V3LlxuICAgICAgICAgKiBBbmQgdGhlbiB3ZSBjcm9zcy1jcm9zcy1jcm9zcyBjaGVjayB3aXRoIGFub3RoZXIgZGlhZ29uYWwgc2Nhbi48L3A+XG4gICAgICAgICAqXG4gICAgICAgICAqIDxwPklmIHRoYXQgc3VjY2VlZHMgdGhlIGZpbmRlciBwYXR0ZXJuIGxvY2F0aW9uIGlzIGFkZGVkIHRvIGEgbGlzdCB0aGF0IHRyYWNrc1xuICAgICAgICAgKiB0aGUgbnVtYmVyIG9mIHRpbWVzIGVhY2ggbG9jYXRpb24gaGFzIGJlZW4gbmVhcmx5LW1hdGNoZWQgYXMgYSBmaW5kZXIgcGF0dGVybi5cbiAgICAgICAgICogRWFjaCBhZGRpdGlvbmFsIGZpbmQgaXMgbW9yZSBldmlkZW5jZSB0aGF0IHRoZSBsb2NhdGlvbiBpcyBpbiBmYWN0IGEgZmluZGVyXG4gICAgICAgICAqIHBhdHRlcm4gY2VudGVyXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBzdGF0ZUNvdW50IHJlYWRpbmcgc3RhdGUgbW9kdWxlIGNvdW50cyBmcm9tIGhvcml6b250YWwgc2NhblxuICAgICAgICAgKiBAcGFyYW0gaSByb3cgd2hlcmUgZmluZGVyIHBhdHRlcm4gbWF5IGJlIGZvdW5kXG4gICAgICAgICAqIEBwYXJhbSBqIGVuZCBvZiBwb3NzaWJsZSBmaW5kZXIgcGF0dGVybiBpbiByb3dcbiAgICAgICAgICogQHBhcmFtIHB1cmVCYXJjb2RlIHRydWUgaWYgaW4gXCJwdXJlIGJhcmNvZGVcIiBtb2RlXG4gICAgICAgICAqIEByZXR1cm4gdHJ1ZSBpZiBhIGZpbmRlciBwYXR0ZXJuIGNhbmRpZGF0ZSB3YXMgZm91bmQgdGhpcyB0aW1lXG4gICAgICAgICAqL1xuICAgICAgICBoYW5kbGVQb3NzaWJsZUNlbnRlcihzdGF0ZUNvdW50LCBpIC8qaW50Ki8sIGogLyppbnQqLywgcHVyZUJhcmNvZGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXRlQ291bnRUb3RhbCA9IHN0YXRlQ291bnRbMF0gKyBzdGF0ZUNvdW50WzFdICsgc3RhdGVDb3VudFsyXSArIHN0YXRlQ291bnRbM10gK1xuICAgICAgICAgICAgICAgIHN0YXRlQ291bnRbNF07XG4gICAgICAgICAgICBsZXQgY2VudGVySiA9IEZpbmRlclBhdHRlcm5GaW5kZXIuY2VudGVyRnJvbUVuZChzdGF0ZUNvdW50LCBqKTtcbiAgICAgICAgICAgIGxldCBjZW50ZXJJID0gdGhpcy5jcm9zc0NoZWNrVmVydGljYWwoaSwgLyooaW50KSAqLyBNYXRoLmZsb29yKGNlbnRlckopLCBzdGF0ZUNvdW50WzJdLCBzdGF0ZUNvdW50VG90YWwpO1xuICAgICAgICAgICAgaWYgKCFpc05hTihjZW50ZXJJKSkge1xuICAgICAgICAgICAgICAgIC8vIFJlLWNyb3NzIGNoZWNrXG4gICAgICAgICAgICAgICAgY2VudGVySiA9IHRoaXMuY3Jvc3NDaGVja0hvcml6b250YWwoLyooaW50KSAqLyBNYXRoLmZsb29yKGNlbnRlckopLCAvKihpbnQpICovIE1hdGguZmxvb3IoY2VudGVySSksIHN0YXRlQ291bnRbMl0sIHN0YXRlQ291bnRUb3RhbCk7XG4gICAgICAgICAgICAgICAgaWYgKCFpc05hTihjZW50ZXJKKSAmJlxuICAgICAgICAgICAgICAgICAgICAoIXB1cmVCYXJjb2RlIHx8IHRoaXMuY3Jvc3NDaGVja0RpYWdvbmFsKC8qKGludCkgKi8gTWF0aC5mbG9vcihjZW50ZXJJKSwgLyooaW50KSAqLyBNYXRoLmZsb29yKGNlbnRlckopLCBzdGF0ZUNvdW50WzJdLCBzdGF0ZUNvdW50VG90YWwpKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlc3RpbWF0ZWRNb2R1bGVTaXplID0gc3RhdGVDb3VudFRvdGFsIC8gNy4wO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZm91bmQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcG9zc2libGVDZW50ZXJzID0gdGhpcy5wb3NzaWJsZUNlbnRlcnM7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGluZGV4ID0gMCwgbGVuZ3RoID0gcG9zc2libGVDZW50ZXJzLmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNlbnRlciA9IHBvc3NpYmxlQ2VudGVyc1tpbmRleF07XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBMb29rIGZvciBhYm91dCB0aGUgc2FtZSBjZW50ZXIgYW5kIG1vZHVsZSBzaXplOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNlbnRlci5hYm91dEVxdWFscyhlc3RpbWF0ZWRNb2R1bGVTaXplLCBjZW50ZXJJLCBjZW50ZXJKKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc3NpYmxlQ2VudGVyc1tpbmRleF0gPSBjZW50ZXIuY29tYmluZUVzdGltYXRlKGNlbnRlckksIGNlbnRlckosIGVzdGltYXRlZE1vZHVsZVNpemUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIWZvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwb2ludCA9IG5ldyBGaW5kZXJQYXR0ZXJuJDEoY2VudGVySiwgY2VudGVySSwgZXN0aW1hdGVkTW9kdWxlU2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NzaWJsZUNlbnRlcnMucHVzaChwb2ludCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5yZXN1bHRQb2ludENhbGxiYWNrICE9PSBudWxsICYmIHRoaXMucmVzdWx0UG9pbnRDYWxsYmFjayAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXN1bHRQb2ludENhbGxiYWNrLmZvdW5kUG9zc2libGVSZXN1bHRQb2ludChwb2ludCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIG51bWJlciBvZiByb3dzIHdlIGNvdWxkIHNhZmVseSBza2lwIGR1cmluZyBzY2FubmluZywgYmFzZWQgb24gdGhlIGZpcnN0XG4gICAgICAgICAqICAgICAgICAgdHdvIGZpbmRlciBwYXR0ZXJucyB0aGF0IGhhdmUgYmVlbiBsb2NhdGVkLiBJbiBzb21lIGNhc2VzIHRoZWlyIHBvc2l0aW9uIHdpbGxcbiAgICAgICAgICogICAgICAgICBhbGxvdyB1cyB0byBpbmZlciB0aGF0IHRoZSB0aGlyZCBwYXR0ZXJuIG11c3QgbGllIGJlbG93IGEgY2VydGFpbiBwb2ludCBmYXJ0aGVyXG4gICAgICAgICAqICAgICAgICAgZG93biBpbiB0aGUgaW1hZ2UuXG4gICAgICAgICAqL1xuICAgICAgICBmaW5kUm93U2tpcCgpIHtcbiAgICAgICAgICAgIGNvbnN0IG1heCA9IHRoaXMucG9zc2libGVDZW50ZXJzLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChtYXggPD0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGZpcnN0Q29uZmlybWVkQ2VudGVyID0gbnVsbDtcbiAgICAgICAgICAgIGZvciAoY29uc3QgY2VudGVyIG9mIHRoaXMucG9zc2libGVDZW50ZXJzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNlbnRlci5nZXRDb3VudCgpID49IEZpbmRlclBhdHRlcm5GaW5kZXIuQ0VOVEVSX1FVT1JVTSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmlyc3RDb25maXJtZWRDZW50ZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3RDb25maXJtZWRDZW50ZXIgPSBjZW50ZXI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBoYXZlIHR3byBjb25maXJtZWQgY2VudGVyc1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSG93IGZhciBkb3duIGNhbiB3ZSBza2lwIGJlZm9yZSByZXN1bWluZyBsb29raW5nIGZvciB0aGUgbmV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcGF0dGVybj8gSW4gdGhlIHdvcnN0IGNhc2UsIG9ubHkgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRpZmZlcmVuY2UgaW4gdGhlIHggLyB5IGNvb3JkaW5hdGVzIG9mIHRoZSB0d28gY2VudGVycy5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIGNhc2Ugd2hlcmUgeW91IGZpbmQgdG9wIGxlZnQgbGFzdC5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGFzU2tpcHBlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gLyooaW50KSAqLyBNYXRoLmZsb29yKChNYXRoLmFicyhmaXJzdENvbmZpcm1lZENlbnRlci5nZXRYKCkgLSBjZW50ZXIuZ2V0WCgpKSAtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5hYnMoZmlyc3RDb25maXJtZWRDZW50ZXIuZ2V0WSgpIC0gY2VudGVyLmdldFkoKSkpIC8gMik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB0cnVlIGlmZiB3ZSBoYXZlIGZvdW5kIGF0IGxlYXN0IDMgZmluZGVyIHBhdHRlcm5zIHRoYXQgaGF2ZSBiZWVuIGRldGVjdGVkXG4gICAgICAgICAqICAgICAgICAgYXQgbGVhc3Qge0BsaW5rICNDRU5URVJfUVVPUlVNfSB0aW1lcyBlYWNoLCBhbmQsIHRoZSBlc3RpbWF0ZWQgbW9kdWxlIHNpemUgb2YgdGhlXG4gICAgICAgICAqICAgICAgICAgY2FuZGlkYXRlcyBpcyBcInByZXR0eSBzaW1pbGFyXCJcbiAgICAgICAgICovXG4gICAgICAgIGhhdmVNdWx0aXBseUNvbmZpcm1lZENlbnRlcnMoKSB7XG4gICAgICAgICAgICBsZXQgY29uZmlybWVkQ291bnQgPSAwO1xuICAgICAgICAgICAgbGV0IHRvdGFsTW9kdWxlU2l6ZSA9IDAuMDtcbiAgICAgICAgICAgIGNvbnN0IG1heCA9IHRoaXMucG9zc2libGVDZW50ZXJzLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcGF0dGVybiBvZiB0aGlzLnBvc3NpYmxlQ2VudGVycykge1xuICAgICAgICAgICAgICAgIGlmIChwYXR0ZXJuLmdldENvdW50KCkgPj0gRmluZGVyUGF0dGVybkZpbmRlci5DRU5URVJfUVVPUlVNKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpcm1lZENvdW50Kys7XG4gICAgICAgICAgICAgICAgICAgIHRvdGFsTW9kdWxlU2l6ZSArPSBwYXR0ZXJuLmdldEVzdGltYXRlZE1vZHVsZVNpemUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29uZmlybWVkQ291bnQgPCAzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gT0ssIHdlIGhhdmUgYXQgbGVhc3QgMyBjb25maXJtZWQgY2VudGVycywgYnV0LCBpdCdzIHBvc3NpYmxlIHRoYXQgb25lIGlzIGEgXCJmYWxzZSBwb3NpdGl2ZVwiXG4gICAgICAgICAgICAvLyBhbmQgdGhhdCB3ZSBuZWVkIHRvIGtlZXAgbG9va2luZy4gV2UgZGV0ZWN0IHRoaXMgYnkgYXNraW5nIGlmIHRoZSBlc3RpbWF0ZWQgbW9kdWxlIHNpemVzXG4gICAgICAgICAgICAvLyB2YXJ5IHRvbyBtdWNoLiBXZSBhcmJpdHJhcmlseSBzYXkgdGhhdCB3aGVuIHRoZSB0b3RhbCBkZXZpYXRpb24gZnJvbSBhdmVyYWdlIGV4Y2VlZHNcbiAgICAgICAgICAgIC8vIDUlIG9mIHRoZSB0b3RhbCBtb2R1bGUgc2l6ZSBlc3RpbWF0ZXMsIGl0J3MgdG9vIG11Y2guXG4gICAgICAgICAgICBjb25zdCBhdmVyYWdlID0gdG90YWxNb2R1bGVTaXplIC8gbWF4O1xuICAgICAgICAgICAgbGV0IHRvdGFsRGV2aWF0aW9uID0gMC4wO1xuICAgICAgICAgICAgZm9yIChjb25zdCBwYXR0ZXJuIG9mIHRoaXMucG9zc2libGVDZW50ZXJzKSB7XG4gICAgICAgICAgICAgICAgdG90YWxEZXZpYXRpb24gKz0gTWF0aC5hYnMocGF0dGVybi5nZXRFc3RpbWF0ZWRNb2R1bGVTaXplKCkgLSBhdmVyYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0b3RhbERldmlhdGlvbiA8PSAwLjA1ICogdG90YWxNb2R1bGVTaXplO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHRoZSAzIGJlc3Qge0BsaW5rIEZpbmRlclBhdHRlcm59cyBmcm9tIG91ciBsaXN0IG9mIGNhbmRpZGF0ZXMuIFRoZSBcImJlc3RcIiBhcmVcbiAgICAgICAgICogICAgICAgICB0aG9zZSB0aGF0IGhhdmUgYmVlbiBkZXRlY3RlZCBhdCBsZWFzdCB7QGxpbmsgI0NFTlRFUl9RVU9SVU19IHRpbWVzLCBhbmQgd2hvc2UgbW9kdWxlXG4gICAgICAgICAqICAgICAgICAgc2l6ZSBkaWZmZXJzIGZyb20gdGhlIGF2ZXJhZ2UgYW1vbmcgdGhvc2UgcGF0dGVybnMgdGhlIGxlYXN0XG4gICAgICAgICAqIEB0aHJvd3MgTm90Rm91bmRFeGNlcHRpb24gaWYgMyBzdWNoIGZpbmRlciBwYXR0ZXJucyBkbyBub3QgZXhpc3RcbiAgICAgICAgICovXG4gICAgICAgIHNlbGVjdEJlc3RQYXR0ZXJucygpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0U2l6ZSA9IHRoaXMucG9zc2libGVDZW50ZXJzLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChzdGFydFNpemUgPCAzKSB7XG4gICAgICAgICAgICAgICAgLy8gQ291bGRuJ3QgZmluZCBlbm91Z2ggZmluZGVyIHBhdHRlcm5zXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwb3NzaWJsZUNlbnRlcnMgPSB0aGlzLnBvc3NpYmxlQ2VudGVycztcbiAgICAgICAgICAgIGxldCBhdmVyYWdlO1xuICAgICAgICAgICAgLy8gRmlsdGVyIG91dGxpZXIgcG9zc2liaWxpdGllcyB3aG9zZSBtb2R1bGUgc2l6ZSBpcyB0b28gZGlmZmVyZW50XG4gICAgICAgICAgICBpZiAoc3RhcnRTaXplID4gMykge1xuICAgICAgICAgICAgICAgIC8vIEJ1dCB3ZSBjYW4gb25seSBhZmZvcmQgdG8gZG8gc28gaWYgd2UgaGF2ZSBhdCBsZWFzdCA0IHBvc3NpYmlsaXRpZXMgdG8gY2hvb3NlIGZyb21cbiAgICAgICAgICAgICAgICBsZXQgdG90YWxNb2R1bGVTaXplID0gMC4wO1xuICAgICAgICAgICAgICAgIGxldCBzcXVhcmUgPSAwLjA7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBjZW50ZXIgb2YgdGhpcy5wb3NzaWJsZUNlbnRlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2l6ZSA9IGNlbnRlci5nZXRFc3RpbWF0ZWRNb2R1bGVTaXplKCk7XG4gICAgICAgICAgICAgICAgICAgIHRvdGFsTW9kdWxlU2l6ZSArPSBzaXplO1xuICAgICAgICAgICAgICAgICAgICBzcXVhcmUgKz0gc2l6ZSAqIHNpemU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGF2ZXJhZ2UgPSB0b3RhbE1vZHVsZVNpemUgLyBzdGFydFNpemU7XG4gICAgICAgICAgICAgICAgbGV0IHN0ZERldiA9IE1hdGguc3FydChzcXVhcmUgLyBzdGFydFNpemUgLSBhdmVyYWdlICogYXZlcmFnZSk7XG4gICAgICAgICAgICAgICAgcG9zc2libGVDZW50ZXJzLnNvcnQoXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogPHA+T3JkZXJzIGJ5IGZ1cnRoZXN0IGZyb20gYXZlcmFnZTwvcD5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAvLyBGdXJ0aGVzdEZyb21BdmVyYWdlQ29tcGFyYXRvciBpbXBsZW1lbnRzIENvbXBhcmF0b3I8RmluZGVyUGF0dGVybj5cbiAgICAgICAgICAgICAgICAoY2VudGVyMSwgY2VudGVyMikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkQSA9IE1hdGguYWJzKGNlbnRlcjIuZ2V0RXN0aW1hdGVkTW9kdWxlU2l6ZSgpIC0gYXZlcmFnZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRCID0gTWF0aC5hYnMoY2VudGVyMS5nZXRFc3RpbWF0ZWRNb2R1bGVTaXplKCkgLSBhdmVyYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRBIDwgZEIgPyAtMSA6IGRBID4gZEIgPyAxIDogMDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCBsaW1pdCA9IE1hdGgubWF4KDAuMiAqIGF2ZXJhZ2UsIHN0ZERldik7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb3NzaWJsZUNlbnRlcnMubGVuZ3RoICYmIHBvc3NpYmxlQ2VudGVycy5sZW5ndGggPiAzOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGF0dGVybiA9IHBvc3NpYmxlQ2VudGVyc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKHBhdHRlcm4uZ2V0RXN0aW1hdGVkTW9kdWxlU2l6ZSgpIC0gYXZlcmFnZSkgPiBsaW1pdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zc2libGVDZW50ZXJzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGktLTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwb3NzaWJsZUNlbnRlcnMubGVuZ3RoID4gMykge1xuICAgICAgICAgICAgICAgIC8vIFRocm93IGF3YXkgYWxsIGJ1dCB0aG9zZSBmaXJzdCBzaXplIGNhbmRpZGF0ZSBwb2ludHMgd2UgZm91bmQuXG4gICAgICAgICAgICAgICAgbGV0IHRvdGFsTW9kdWxlU2l6ZSA9IDAuMDtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHBvc3NpYmxlQ2VudGVyIG9mIHBvc3NpYmxlQ2VudGVycykge1xuICAgICAgICAgICAgICAgICAgICB0b3RhbE1vZHVsZVNpemUgKz0gcG9zc2libGVDZW50ZXIuZ2V0RXN0aW1hdGVkTW9kdWxlU2l6ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhdmVyYWdlID0gdG90YWxNb2R1bGVTaXplIC8gcG9zc2libGVDZW50ZXJzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBwb3NzaWJsZUNlbnRlcnMuc29ydChcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiA8cD5PcmRlcnMgYnkge0BsaW5rIEZpbmRlclBhdHRlcm4jZ2V0Q291bnQoKX0sIGRlc2NlbmRpbmcuPC9wPlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIC8vIENlbnRlckNvbXBhcmF0b3IgaW1wbGVtZW50cyBDb21wYXJhdG9yPEZpbmRlclBhdHRlcm4+XG4gICAgICAgICAgICAgICAgKGNlbnRlcjEsIGNlbnRlcjIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNlbnRlcjIuZ2V0Q291bnQoKSA9PT0gY2VudGVyMS5nZXRDb3VudCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkQSA9IE1hdGguYWJzKGNlbnRlcjIuZ2V0RXN0aW1hdGVkTW9kdWxlU2l6ZSgpIC0gYXZlcmFnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkQiA9IE1hdGguYWJzKGNlbnRlcjEuZ2V0RXN0aW1hdGVkTW9kdWxlU2l6ZSgpIC0gYXZlcmFnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZEEgPCBkQiA/IDEgOiBkQSA+IGRCID8gLTEgOiAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNlbnRlcjIuZ2V0Q291bnQoKSAtIGNlbnRlcjEuZ2V0Q291bnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHBvc3NpYmxlQ2VudGVycy5zcGxpY2UoMyk7IC8vIHRoaXMgaXMgbm90IHJlYWx5IG5lY2Vzc2FyeSBhcyB3ZSBvbmx5IHJldHVybiBmaXJzdCAzIGFueXdheVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICBwb3NzaWJsZUNlbnRlcnNbMF0sXG4gICAgICAgICAgICAgICAgcG9zc2libGVDZW50ZXJzWzFdLFxuICAgICAgICAgICAgICAgIHBvc3NpYmxlQ2VudGVyc1syXVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBGaW5kZXJQYXR0ZXJuRmluZGVyLkNFTlRFUl9RVU9SVU0gPSAyO1xuICAgIEZpbmRlclBhdHRlcm5GaW5kZXIuTUlOX1NLSVAgPSAzOyAvLyAxIHBpeGVsL21vZHVsZSB0aW1lcyAzIG1vZHVsZXMvY2VudGVyXG4gICAgRmluZGVyUGF0dGVybkZpbmRlci5NQVhfTU9EVUxFUyA9IDU3OyAvLyBzdXBwb3J0IHVwIHRvIHZlcnNpb24gMTAgZm9yIG1vYmlsZSBjbGllbnRzXG5cbiAgICAvKlxuICAgICAqIENvcHlyaWdodCAyMDA3IFpYaW5nIGF1dGhvcnNcbiAgICAgKlxuICAgICAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gICAgICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgICAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgICAqXG4gICAgICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAgICAgKlxuICAgICAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgICAgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICAgICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gICAgICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICAgICAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICAgICAqL1xuICAgIC8qaW1wb3J0IGphdmEudXRpbC5NYXA7Ki9cbiAgICAvKipcbiAgICAgKiA8cD5FbmNhcHN1bGF0ZXMgbG9naWMgdGhhdCBjYW4gZGV0ZWN0IGEgUVIgQ29kZSBpbiBhbiBpbWFnZSwgZXZlbiBpZiB0aGUgUVIgQ29kZVxuICAgICAqIGlzIHJvdGF0ZWQgb3Igc2tld2VkLCBvciBwYXJ0aWFsbHkgb2JzY3VyZWQuPC9wPlxuICAgICAqXG4gICAgICogQGF1dGhvciBTZWFuIE93ZW5cbiAgICAgKi9cbiAgICBjbGFzcyBEZXRlY3RvciQyIHtcbiAgICAgICAgY29uc3RydWN0b3IoaW1hZ2UpIHtcbiAgICAgICAgICAgIHRoaXMuaW1hZ2UgPSBpbWFnZTtcbiAgICAgICAgfVxuICAgICAgICBnZXRJbWFnZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmltYWdlO1xuICAgICAgICB9XG4gICAgICAgIGdldFJlc3VsdFBvaW50Q2FsbGJhY2soKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHRQb2ludENhbGxiYWNrO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiA8cD5EZXRlY3RzIGEgUVIgQ29kZSBpbiBhbiBpbWFnZS48L3A+XG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge0BsaW5rIERldGVjdG9yUmVzdWx0fSBlbmNhcHN1bGF0aW5nIHJlc3VsdHMgb2YgZGV0ZWN0aW5nIGEgUVIgQ29kZVxuICAgICAgICAgKiBAdGhyb3dzIE5vdEZvdW5kRXhjZXB0aW9uIGlmIFFSIENvZGUgY2Fubm90IGJlIGZvdW5kXG4gICAgICAgICAqIEB0aHJvd3MgRm9ybWF0RXhjZXB0aW9uIGlmIGEgUVIgQ29kZSBjYW5ub3QgYmUgZGVjb2RlZFxuICAgICAgICAgKi9cbiAgICAgICAgLy8gcHVibGljIGRldGVjdCgpOiBEZXRlY3RvclJlc3VsdCAvKnRocm93cyBOb3RGb3VuZEV4Y2VwdGlvbiwgRm9ybWF0RXhjZXB0aW9uKi8ge1xuICAgICAgICAvLyAgIHJldHVybiBkZXRlY3QobnVsbClcbiAgICAgICAgLy8gfVxuICAgICAgICAvKipcbiAgICAgICAgICogPHA+RGV0ZWN0cyBhIFFSIENvZGUgaW4gYW4gaW1hZ2UuPC9wPlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gaGludHMgb3B0aW9uYWwgaGludHMgdG8gZGV0ZWN0b3JcbiAgICAgICAgICogQHJldHVybiB7QGxpbmsgRGV0ZWN0b3JSZXN1bHR9IGVuY2Fwc3VsYXRpbmcgcmVzdWx0cyBvZiBkZXRlY3RpbmcgYSBRUiBDb2RlXG4gICAgICAgICAqIEB0aHJvd3MgTm90Rm91bmRFeGNlcHRpb24gaWYgUVIgQ29kZSBjYW5ub3QgYmUgZm91bmRcbiAgICAgICAgICogQHRocm93cyBGb3JtYXRFeGNlcHRpb24gaWYgYSBRUiBDb2RlIGNhbm5vdCBiZSBkZWNvZGVkXG4gICAgICAgICAqL1xuICAgICAgICBkZXRlY3QoaGludHMpIHtcbiAgICAgICAgICAgIHRoaXMucmVzdWx0UG9pbnRDYWxsYmFjayA9IChoaW50cyA9PT0gbnVsbCB8fCBoaW50cyA9PT0gdW5kZWZpbmVkKSA/IG51bGwgOlxuICAgICAgICAgICAgICAgIC8qKFJlc3VsdFBvaW50Q2FsbGJhY2spICovIGhpbnRzLmdldChEZWNvZGVIaW50VHlwZSQxLk5FRURfUkVTVUxUX1BPSU5UX0NBTExCQUNLKTtcbiAgICAgICAgICAgIGNvbnN0IGZpbmRlciA9IG5ldyBGaW5kZXJQYXR0ZXJuRmluZGVyKHRoaXMuaW1hZ2UsIHRoaXMucmVzdWx0UG9pbnRDYWxsYmFjayk7XG4gICAgICAgICAgICBjb25zdCBpbmZvID0gZmluZGVyLmZpbmQoaGludHMpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc0ZpbmRlclBhdHRlcm5JbmZvKGluZm8pO1xuICAgICAgICB9XG4gICAgICAgIHByb2Nlc3NGaW5kZXJQYXR0ZXJuSW5mbyhpbmZvKSB7XG4gICAgICAgICAgICBjb25zdCB0b3BMZWZ0ID0gaW5mby5nZXRUb3BMZWZ0KCk7XG4gICAgICAgICAgICBjb25zdCB0b3BSaWdodCA9IGluZm8uZ2V0VG9wUmlnaHQoKTtcbiAgICAgICAgICAgIGNvbnN0IGJvdHRvbUxlZnQgPSBpbmZvLmdldEJvdHRvbUxlZnQoKTtcbiAgICAgICAgICAgIGNvbnN0IG1vZHVsZVNpemUgPSB0aGlzLmNhbGN1bGF0ZU1vZHVsZVNpemUodG9wTGVmdCwgdG9wUmlnaHQsIGJvdHRvbUxlZnQpO1xuICAgICAgICAgICAgaWYgKG1vZHVsZVNpemUgPCAxLjApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oJ05vIHBhdHRlcm4gZm91bmQgaW4gcHJvY2Nlc3MgZmluZGVyLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZGltZW5zaW9uID0gRGV0ZWN0b3IkMi5jb21wdXRlRGltZW5zaW9uKHRvcExlZnQsIHRvcFJpZ2h0LCBib3R0b21MZWZ0LCBtb2R1bGVTaXplKTtcbiAgICAgICAgICAgIGNvbnN0IHByb3Zpc2lvbmFsVmVyc2lvbiA9IFZlcnNpb24kMS5nZXRQcm92aXNpb25hbFZlcnNpb25Gb3JEaW1lbnNpb24oZGltZW5zaW9uKTtcbiAgICAgICAgICAgIGNvbnN0IG1vZHVsZXNCZXR3ZWVuRlBDZW50ZXJzID0gcHJvdmlzaW9uYWxWZXJzaW9uLmdldERpbWVuc2lvbkZvclZlcnNpb24oKSAtIDc7XG4gICAgICAgICAgICBsZXQgYWxpZ25tZW50UGF0dGVybiA9IG51bGw7XG4gICAgICAgICAgICAvLyBBbnl0aGluZyBhYm92ZSB2ZXJzaW9uIDEgaGFzIGFuIGFsaWdubWVudCBwYXR0ZXJuXG4gICAgICAgICAgICBpZiAocHJvdmlzaW9uYWxWZXJzaW9uLmdldEFsaWdubWVudFBhdHRlcm5DZW50ZXJzKCkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIC8vIEd1ZXNzIHdoZXJlIGEgXCJib3R0b20gcmlnaHRcIiBmaW5kZXIgcGF0dGVybiB3b3VsZCBoYXZlIGJlZW5cbiAgICAgICAgICAgICAgICBjb25zdCBib3R0b21SaWdodFggPSB0b3BSaWdodC5nZXRYKCkgLSB0b3BMZWZ0LmdldFgoKSArIGJvdHRvbUxlZnQuZ2V0WCgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGJvdHRvbVJpZ2h0WSA9IHRvcFJpZ2h0LmdldFkoKSAtIHRvcExlZnQuZ2V0WSgpICsgYm90dG9tTGVmdC5nZXRZKCk7XG4gICAgICAgICAgICAgICAgLy8gRXN0aW1hdGUgdGhhdCBhbGlnbm1lbnQgcGF0dGVybiBpcyBjbG9zZXIgYnkgMyBtb2R1bGVzXG4gICAgICAgICAgICAgICAgLy8gZnJvbSBcImJvdHRvbSByaWdodFwiIHRvIGtub3duIHRvcCBsZWZ0IGxvY2F0aW9uXG4gICAgICAgICAgICAgICAgY29uc3QgY29ycmVjdGlvblRvVG9wTGVmdCA9IDEuMCAtIDMuMCAvIG1vZHVsZXNCZXR3ZWVuRlBDZW50ZXJzO1xuICAgICAgICAgICAgICAgIGNvbnN0IGVzdEFsaWdubWVudFggPSAvKihpbnQpICovIE1hdGguZmxvb3IodG9wTGVmdC5nZXRYKCkgKyBjb3JyZWN0aW9uVG9Ub3BMZWZ0ICogKGJvdHRvbVJpZ2h0WCAtIHRvcExlZnQuZ2V0WCgpKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgZXN0QWxpZ25tZW50WSA9IC8qKGludCkgKi8gTWF0aC5mbG9vcih0b3BMZWZ0LmdldFkoKSArIGNvcnJlY3Rpb25Ub1RvcExlZnQgKiAoYm90dG9tUmlnaHRZIC0gdG9wTGVmdC5nZXRZKCkpKTtcbiAgICAgICAgICAgICAgICAvLyBLaW5kIG9mIGFyYml0cmFyeSAtLSBleHBhbmQgc2VhcmNoIHJhZGl1cyBiZWZvcmUgZ2l2aW5nIHVwXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDQ7IGkgPD0gMTY7IGkgPDw9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsaWdubWVudFBhdHRlcm4gPSB0aGlzLmZpbmRBbGlnbm1lbnRJblJlZ2lvbihtb2R1bGVTaXplLCBlc3RBbGlnbm1lbnRYLCBlc3RBbGlnbm1lbnRZLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChyZSAvKk5vdEZvdW5kRXhjZXB0aW9uKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHJlIGluc3RhbmNlb2YgTm90Rm91bmRFeGNlcHRpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgcmU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0cnkgbmV4dCByb3VuZFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIElmIHdlIGRpZG4ndCBmaW5kIGFsaWdubWVudCBwYXR0ZXJuLi4uIHdlbGwgdHJ5IGFueXdheSB3aXRob3V0IGl0XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0cmFuc2Zvcm0gPSBEZXRlY3RvciQyLmNyZWF0ZVRyYW5zZm9ybSh0b3BMZWZ0LCB0b3BSaWdodCwgYm90dG9tTGVmdCwgYWxpZ25tZW50UGF0dGVybiwgZGltZW5zaW9uKTtcbiAgICAgICAgICAgIGNvbnN0IGJpdHMgPSBEZXRlY3RvciQyLnNhbXBsZUdyaWQodGhpcy5pbWFnZSwgdHJhbnNmb3JtLCBkaW1lbnNpb24pO1xuICAgICAgICAgICAgbGV0IHBvaW50cztcbiAgICAgICAgICAgIGlmIChhbGlnbm1lbnRQYXR0ZXJuID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcG9pbnRzID0gW2JvdHRvbUxlZnQsIHRvcExlZnQsIHRvcFJpZ2h0XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBvaW50cyA9IFtib3R0b21MZWZ0LCB0b3BMZWZ0LCB0b3BSaWdodCwgYWxpZ25tZW50UGF0dGVybl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IERldGVjdG9yUmVzdWx0KGJpdHMsIHBvaW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGNyZWF0ZVRyYW5zZm9ybSh0b3BMZWZ0LCB0b3BSaWdodCwgYm90dG9tTGVmdCwgYWxpZ25tZW50UGF0dGVybiwgZGltZW5zaW9uIC8qaW50Ki8pIHtcbiAgICAgICAgICAgIGNvbnN0IGRpbU1pbnVzVGhyZWUgPSBkaW1lbnNpb24gLSAzLjU7XG4gICAgICAgICAgICBsZXQgYm90dG9tUmlnaHRYOyAvKmZsb2F0Ki9cbiAgICAgICAgICAgIGxldCBib3R0b21SaWdodFk7IC8qZmxvYXQqL1xuICAgICAgICAgICAgbGV0IHNvdXJjZUJvdHRvbVJpZ2h0WDsgLypmbG9hdCovXG4gICAgICAgICAgICBsZXQgc291cmNlQm90dG9tUmlnaHRZOyAvKmZsb2F0Ki9cbiAgICAgICAgICAgIGlmIChhbGlnbm1lbnRQYXR0ZXJuICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgYm90dG9tUmlnaHRYID0gYWxpZ25tZW50UGF0dGVybi5nZXRYKCk7XG4gICAgICAgICAgICAgICAgYm90dG9tUmlnaHRZID0gYWxpZ25tZW50UGF0dGVybi5nZXRZKCk7XG4gICAgICAgICAgICAgICAgc291cmNlQm90dG9tUmlnaHRYID0gZGltTWludXNUaHJlZSAtIDMuMDtcbiAgICAgICAgICAgICAgICBzb3VyY2VCb3R0b21SaWdodFkgPSBzb3VyY2VCb3R0b21SaWdodFg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBEb24ndCBoYXZlIGFuIGFsaWdubWVudCBwYXR0ZXJuLCBqdXN0IG1ha2UgdXAgdGhlIGJvdHRvbS1yaWdodCBwb2ludFxuICAgICAgICAgICAgICAgIGJvdHRvbVJpZ2h0WCA9ICh0b3BSaWdodC5nZXRYKCkgLSB0b3BMZWZ0LmdldFgoKSkgKyBib3R0b21MZWZ0LmdldFgoKTtcbiAgICAgICAgICAgICAgICBib3R0b21SaWdodFkgPSAodG9wUmlnaHQuZ2V0WSgpIC0gdG9wTGVmdC5nZXRZKCkpICsgYm90dG9tTGVmdC5nZXRZKCk7XG4gICAgICAgICAgICAgICAgc291cmNlQm90dG9tUmlnaHRYID0gZGltTWludXNUaHJlZTtcbiAgICAgICAgICAgICAgICBzb3VyY2VCb3R0b21SaWdodFkgPSBkaW1NaW51c1RocmVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFBlcnNwZWN0aXZlVHJhbnNmb3JtLnF1YWRyaWxhdGVyYWxUb1F1YWRyaWxhdGVyYWwoMy41LCAzLjUsIGRpbU1pbnVzVGhyZWUsIDMuNSwgc291cmNlQm90dG9tUmlnaHRYLCBzb3VyY2VCb3R0b21SaWdodFksIDMuNSwgZGltTWludXNUaHJlZSwgdG9wTGVmdC5nZXRYKCksIHRvcExlZnQuZ2V0WSgpLCB0b3BSaWdodC5nZXRYKCksIHRvcFJpZ2h0LmdldFkoKSwgYm90dG9tUmlnaHRYLCBib3R0b21SaWdodFksIGJvdHRvbUxlZnQuZ2V0WCgpLCBib3R0b21MZWZ0LmdldFkoKSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIHNhbXBsZUdyaWQoaW1hZ2UsIHRyYW5zZm9ybSwgZGltZW5zaW9uIC8qaW50Ki8pIHtcbiAgICAgICAgICAgIGNvbnN0IHNhbXBsZXIgPSBHcmlkU2FtcGxlckluc3RhbmNlLmdldEluc3RhbmNlKCk7XG4gICAgICAgICAgICByZXR1cm4gc2FtcGxlci5zYW1wbGVHcmlkV2l0aFRyYW5zZm9ybShpbWFnZSwgZGltZW5zaW9uLCBkaW1lbnNpb24sIHRyYW5zZm9ybSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIDxwPkNvbXB1dGVzIHRoZSBkaW1lbnNpb24gKG51bWJlciBvZiBtb2R1bGVzIG9uIGEgc2l6ZSkgb2YgdGhlIFFSIENvZGUgYmFzZWQgb24gdGhlIHBvc2l0aW9uXG4gICAgICAgICAqIG9mIHRoZSBmaW5kZXIgcGF0dGVybnMgYW5kIGVzdGltYXRlZCBtb2R1bGUgc2l6ZS48L3A+XG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgY29tcHV0ZURpbWVuc2lvbih0b3BMZWZ0LCB0b3BSaWdodCwgYm90dG9tTGVmdCwgbW9kdWxlU2l6ZSAvKmZsb2F0Ki8pIHtcbiAgICAgICAgICAgIGNvbnN0IHRsdHJDZW50ZXJzRGltZW5zaW9uID0gTWF0aFV0aWxzLnJvdW5kKFJlc3VsdFBvaW50LmRpc3RhbmNlKHRvcExlZnQsIHRvcFJpZ2h0KSAvIG1vZHVsZVNpemUpO1xuICAgICAgICAgICAgY29uc3QgdGxibENlbnRlcnNEaW1lbnNpb24gPSBNYXRoVXRpbHMucm91bmQoUmVzdWx0UG9pbnQuZGlzdGFuY2UodG9wTGVmdCwgYm90dG9tTGVmdCkgLyBtb2R1bGVTaXplKTtcbiAgICAgICAgICAgIGxldCBkaW1lbnNpb24gPSBNYXRoLmZsb29yKCh0bHRyQ2VudGVyc0RpbWVuc2lvbiArIHRsYmxDZW50ZXJzRGltZW5zaW9uKSAvIDIpICsgNztcbiAgICAgICAgICAgIHN3aXRjaCAoZGltZW5zaW9uICYgMHgwMykgeyAvLyBtb2QgNFxuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgZGltZW5zaW9uKys7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIC8vIDE/IGRvIG5vdGhpbmdcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIGRpbWVuc2lvbi0tO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbignRGltZW5zaW9ucyBjb3VsZCBiZSBub3QgZm91bmQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGltZW5zaW9uO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiA8cD5Db21wdXRlcyBhbiBhdmVyYWdlIGVzdGltYXRlZCBtb2R1bGUgc2l6ZSBiYXNlZCBvbiBlc3RpbWF0ZWQgZGVyaXZlZCBmcm9tIHRoZSBwb3NpdGlvbnNcbiAgICAgICAgICogb2YgdGhlIHRocmVlIGZpbmRlciBwYXR0ZXJucy48L3A+XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB0b3BMZWZ0IGRldGVjdGVkIHRvcC1sZWZ0IGZpbmRlciBwYXR0ZXJuIGNlbnRlclxuICAgICAgICAgKiBAcGFyYW0gdG9wUmlnaHQgZGV0ZWN0ZWQgdG9wLXJpZ2h0IGZpbmRlciBwYXR0ZXJuIGNlbnRlclxuICAgICAgICAgKiBAcGFyYW0gYm90dG9tTGVmdCBkZXRlY3RlZCBib3R0b20tbGVmdCBmaW5kZXIgcGF0dGVybiBjZW50ZXJcbiAgICAgICAgICogQHJldHVybiBlc3RpbWF0ZWQgbW9kdWxlIHNpemVcbiAgICAgICAgICovXG4gICAgICAgIGNhbGN1bGF0ZU1vZHVsZVNpemUodG9wTGVmdCwgdG9wUmlnaHQsIGJvdHRvbUxlZnQpIHtcbiAgICAgICAgICAgIC8vIFRha2UgdGhlIGF2ZXJhZ2VcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5jYWxjdWxhdGVNb2R1bGVTaXplT25lV2F5KHRvcExlZnQsIHRvcFJpZ2h0KSArXG4gICAgICAgICAgICAgICAgdGhpcy5jYWxjdWxhdGVNb2R1bGVTaXplT25lV2F5KHRvcExlZnQsIGJvdHRvbUxlZnQpKSAvIDIuMDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogPHA+RXN0aW1hdGVzIG1vZHVsZSBzaXplIGJhc2VkIG9uIHR3byBmaW5kZXIgcGF0dGVybnMgLS0gaXQgdXNlc1xuICAgICAgICAgKiB7QGxpbmsgI3NpemVPZkJsYWNrV2hpdGVCbGFja1J1bkJvdGhXYXlzKGludCwgaW50LCBpbnQsIGludCl9IHRvIGZpZ3VyZSB0aGVcbiAgICAgICAgICogd2lkdGggb2YgZWFjaCwgbWVhc3VyaW5nIGFsb25nIHRoZSBheGlzIGJldHdlZW4gdGhlaXIgY2VudGVycy48L3A+XG4gICAgICAgICAqL1xuICAgICAgICBjYWxjdWxhdGVNb2R1bGVTaXplT25lV2F5KHBhdHRlcm4sIG90aGVyUGF0dGVybikge1xuICAgICAgICAgICAgY29uc3QgbW9kdWxlU2l6ZUVzdDEgPSB0aGlzLnNpemVPZkJsYWNrV2hpdGVCbGFja1J1bkJvdGhXYXlzKC8qKGludCkgKi8gTWF0aC5mbG9vcihwYXR0ZXJuLmdldFgoKSksIFxuICAgICAgICAgICAgLyooaW50KSAqLyBNYXRoLmZsb29yKHBhdHRlcm4uZ2V0WSgpKSwgXG4gICAgICAgICAgICAvKihpbnQpICovIE1hdGguZmxvb3Iob3RoZXJQYXR0ZXJuLmdldFgoKSksIFxuICAgICAgICAgICAgLyooaW50KSAqLyBNYXRoLmZsb29yKG90aGVyUGF0dGVybi5nZXRZKCkpKTtcbiAgICAgICAgICAgIGNvbnN0IG1vZHVsZVNpemVFc3QyID0gdGhpcy5zaXplT2ZCbGFja1doaXRlQmxhY2tSdW5Cb3RoV2F5cygvKihpbnQpICovIE1hdGguZmxvb3Iob3RoZXJQYXR0ZXJuLmdldFgoKSksIFxuICAgICAgICAgICAgLyooaW50KSAqLyBNYXRoLmZsb29yKG90aGVyUGF0dGVybi5nZXRZKCkpLCBcbiAgICAgICAgICAgIC8qKGludCkgKi8gTWF0aC5mbG9vcihwYXR0ZXJuLmdldFgoKSksIFxuICAgICAgICAgICAgLyooaW50KSAqLyBNYXRoLmZsb29yKHBhdHRlcm4uZ2V0WSgpKSk7XG4gICAgICAgICAgICBpZiAoaXNOYU4obW9kdWxlU2l6ZUVzdDEpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1vZHVsZVNpemVFc3QyIC8gNy4wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzTmFOKG1vZHVsZVNpemVFc3QyKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtb2R1bGVTaXplRXN0MSAvIDcuMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEF2ZXJhZ2UgdGhlbSwgYW5kIGRpdmlkZSBieSA3IHNpbmNlIHdlJ3ZlIGNvdW50ZWQgdGhlIHdpZHRoIG9mIDMgYmxhY2sgbW9kdWxlcyxcbiAgICAgICAgICAgIC8vIGFuZCAxIHdoaXRlIGFuZCAxIGJsYWNrIG1vZHVsZSBvbiBlaXRoZXIgc2lkZS4gRXJnbywgZGl2aWRlIHN1bSBieSAxNC5cbiAgICAgICAgICAgIHJldHVybiAobW9kdWxlU2l6ZUVzdDEgKyBtb2R1bGVTaXplRXN0MikgLyAxNC4wO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZWUge0BsaW5rICNzaXplT2ZCbGFja1doaXRlQmxhY2tSdW4oaW50LCBpbnQsIGludCwgaW50KX07IGNvbXB1dGVzIHRoZSB0b3RhbCB3aWR0aCBvZlxuICAgICAgICAgKiBhIGZpbmRlciBwYXR0ZXJuIGJ5IGxvb2tpbmcgZm9yIGEgYmxhY2std2hpdGUtYmxhY2sgcnVuIGZyb20gdGhlIGNlbnRlciBpbiB0aGUgZGlyZWN0aW9uXG4gICAgICAgICAqIG9mIGFub3RoZXIgcG9pbnQgKGFub3RoZXIgZmluZGVyIHBhdHRlcm4gY2VudGVyKSwgYW5kIGluIHRoZSBvcHBvc2l0ZSBkaXJlY3Rpb24gdG9vLlxuICAgICAgICAgKi9cbiAgICAgICAgc2l6ZU9mQmxhY2tXaGl0ZUJsYWNrUnVuQm90aFdheXMoZnJvbVggLyppbnQqLywgZnJvbVkgLyppbnQqLywgdG9YIC8qaW50Ki8sIHRvWSAvKmludCovKSB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5zaXplT2ZCbGFja1doaXRlQmxhY2tSdW4oZnJvbVgsIGZyb21ZLCB0b1gsIHRvWSk7XG4gICAgICAgICAgICAvLyBOb3cgY291bnQgb3RoZXIgd2F5IC0tIGRvbid0IHJ1biBvZmYgaW1hZ2UgdGhvdWdoIG9mIGNvdXJzZVxuICAgICAgICAgICAgbGV0IHNjYWxlID0gMS4wO1xuICAgICAgICAgICAgbGV0IG90aGVyVG9YID0gZnJvbVggLSAodG9YIC0gZnJvbVgpO1xuICAgICAgICAgICAgaWYgKG90aGVyVG9YIDwgMCkge1xuICAgICAgICAgICAgICAgIHNjYWxlID0gZnJvbVggLyAvKihmbG9hdCkgKi8gKGZyb21YIC0gb3RoZXJUb1gpO1xuICAgICAgICAgICAgICAgIG90aGVyVG9YID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG90aGVyVG9YID49IHRoaXMuaW1hZ2UuZ2V0V2lkdGgoKSkge1xuICAgICAgICAgICAgICAgIHNjYWxlID0gKHRoaXMuaW1hZ2UuZ2V0V2lkdGgoKSAtIDEgLSBmcm9tWCkgLyAvKihmbG9hdCkgKi8gKG90aGVyVG9YIC0gZnJvbVgpO1xuICAgICAgICAgICAgICAgIG90aGVyVG9YID0gdGhpcy5pbWFnZS5nZXRXaWR0aCgpIC0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBvdGhlclRvWSA9IC8qKGludCkgKi8gTWF0aC5mbG9vcihmcm9tWSAtICh0b1kgLSBmcm9tWSkgKiBzY2FsZSk7XG4gICAgICAgICAgICBzY2FsZSA9IDEuMDtcbiAgICAgICAgICAgIGlmIChvdGhlclRvWSA8IDApIHtcbiAgICAgICAgICAgICAgICBzY2FsZSA9IGZyb21ZIC8gLyooZmxvYXQpICovIChmcm9tWSAtIG90aGVyVG9ZKTtcbiAgICAgICAgICAgICAgICBvdGhlclRvWSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChvdGhlclRvWSA+PSB0aGlzLmltYWdlLmdldEhlaWdodCgpKSB7XG4gICAgICAgICAgICAgICAgc2NhbGUgPSAodGhpcy5pbWFnZS5nZXRIZWlnaHQoKSAtIDEgLSBmcm9tWSkgLyAvKihmbG9hdCkgKi8gKG90aGVyVG9ZIC0gZnJvbVkpO1xuICAgICAgICAgICAgICAgIG90aGVyVG9ZID0gdGhpcy5pbWFnZS5nZXRIZWlnaHQoKSAtIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdGhlclRvWCA9IC8qKGludCkgKi8gTWF0aC5mbG9vcihmcm9tWCArIChvdGhlclRvWCAtIGZyb21YKSAqIHNjYWxlKTtcbiAgICAgICAgICAgIHJlc3VsdCArPSB0aGlzLnNpemVPZkJsYWNrV2hpdGVCbGFja1J1bihmcm9tWCwgZnJvbVksIG90aGVyVG9YLCBvdGhlclRvWSk7XG4gICAgICAgICAgICAvLyBNaWRkbGUgcGl4ZWwgaXMgZG91YmxlLWNvdW50ZWQgdGhpcyB3YXk7IHN1YnRyYWN0IDFcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQgLSAxLjA7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIDxwPlRoaXMgbWV0aG9kIHRyYWNlcyBhIGxpbmUgZnJvbSBhIHBvaW50IGluIHRoZSBpbWFnZSwgaW4gdGhlIGRpcmVjdGlvbiB0b3dhcmRzIGFub3RoZXIgcG9pbnQuXG4gICAgICAgICAqIEl0IGJlZ2lucyBpbiBhIGJsYWNrIHJlZ2lvbiwgYW5kIGtlZXBzIGdvaW5nIHVudGlsIGl0IGZpbmRzIHdoaXRlLCB0aGVuIGJsYWNrLCB0aGVuIHdoaXRlIGFnYWluLlxuICAgICAgICAgKiBJdCByZXBvcnRzIHRoZSBkaXN0YW5jZSBmcm9tIHRoZSBzdGFydCB0byB0aGlzIHBvaW50LjwvcD5cbiAgICAgICAgICpcbiAgICAgICAgICogPHA+VGhpcyBpcyB1c2VkIHdoZW4gZmlndXJpbmcgb3V0IGhvdyB3aWRlIGEgZmluZGVyIHBhdHRlcm4gaXMsIHdoZW4gdGhlIGZpbmRlciBwYXR0ZXJuXG4gICAgICAgICAqIG1heSBiZSBza2V3ZWQgb3Igcm90YXRlZC48L3A+XG4gICAgICAgICAqL1xuICAgICAgICBzaXplT2ZCbGFja1doaXRlQmxhY2tSdW4oZnJvbVggLyppbnQqLywgZnJvbVkgLyppbnQqLywgdG9YIC8qaW50Ki8sIHRvWSAvKmludCovKSB7XG4gICAgICAgICAgICAvLyBNaWxkIHZhcmlhbnQgb2YgQnJlc2VuaGFtJ3MgYWxnb3JpdGhtXG4gICAgICAgICAgICAvLyBzZWUgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CcmVzZW5oYW0nc19saW5lX2FsZ29yaXRobVxuICAgICAgICAgICAgY29uc3Qgc3RlZXAgPSBNYXRoLmFicyh0b1kgLSBmcm9tWSkgPiBNYXRoLmFicyh0b1ggLSBmcm9tWCk7XG4gICAgICAgICAgICBpZiAoc3RlZXApIHtcbiAgICAgICAgICAgICAgICBsZXQgdGVtcCA9IGZyb21YO1xuICAgICAgICAgICAgICAgIGZyb21YID0gZnJvbVk7XG4gICAgICAgICAgICAgICAgZnJvbVkgPSB0ZW1wO1xuICAgICAgICAgICAgICAgIHRlbXAgPSB0b1g7XG4gICAgICAgICAgICAgICAgdG9YID0gdG9ZO1xuICAgICAgICAgICAgICAgIHRvWSA9IHRlbXA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBkeCA9IE1hdGguYWJzKHRvWCAtIGZyb21YKTtcbiAgICAgICAgICAgIGNvbnN0IGR5ID0gTWF0aC5hYnModG9ZIC0gZnJvbVkpO1xuICAgICAgICAgICAgbGV0IGVycm9yID0gLWR4IC8gMjtcbiAgICAgICAgICAgIGNvbnN0IHhzdGVwID0gZnJvbVggPCB0b1ggPyAxIDogLTE7XG4gICAgICAgICAgICBjb25zdCB5c3RlcCA9IGZyb21ZIDwgdG9ZID8gMSA6IC0xO1xuICAgICAgICAgICAgLy8gSW4gYmxhY2sgcGl4ZWxzLCBsb29raW5nIGZvciB3aGl0ZSwgZmlyc3Qgb3Igc2Vjb25kIHRpbWUuXG4gICAgICAgICAgICBsZXQgc3RhdGUgPSAwO1xuICAgICAgICAgICAgLy8gTG9vcCB1cCB1bnRpbCB4ID09IHRvWCwgYnV0IG5vdCBiZXlvbmRcbiAgICAgICAgICAgIGNvbnN0IHhMaW1pdCA9IHRvWCArIHhzdGVwO1xuICAgICAgICAgICAgZm9yIChsZXQgeCA9IGZyb21YLCB5ID0gZnJvbVk7IHggIT09IHhMaW1pdDsgeCArPSB4c3RlcCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlYWxYID0gc3RlZXAgPyB5IDogeDtcbiAgICAgICAgICAgICAgICBjb25zdCByZWFsWSA9IHN0ZWVwID8geCA6IHk7XG4gICAgICAgICAgICAgICAgLy8gRG9lcyBjdXJyZW50IHBpeGVsIG1lYW4gd2UgaGF2ZSBtb3ZlZCB3aGl0ZSB0byBibGFjayBvciB2aWNlIHZlcnNhP1xuICAgICAgICAgICAgICAgIC8vIFNjYW5uaW5nIGJsYWNrIGluIHN0YXRlIDAsMiBhbmQgd2hpdGUgaW4gc3RhdGUgMSwgc28gaWYgd2UgZmluZCB0aGUgd3JvbmdcbiAgICAgICAgICAgICAgICAvLyBjb2xvciwgYWR2YW5jZSB0byBuZXh0IHN0YXRlIG9yIGVuZCBpZiB3ZSBhcmUgaW4gc3RhdGUgMiBhbHJlYWR5XG4gICAgICAgICAgICAgICAgaWYgKChzdGF0ZSA9PT0gMSkgPT09IHRoaXMuaW1hZ2UuZ2V0KHJlYWxYLCByZWFsWSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gTWF0aFV0aWxzLmRpc3RhbmNlKHgsIHksIGZyb21YLCBmcm9tWSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3RhdGUrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZXJyb3IgKz0gZHk7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoeSA9PT0gdG9ZKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB5ICs9IHlzdGVwO1xuICAgICAgICAgICAgICAgICAgICBlcnJvciAtPSBkeDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBGb3VuZCBibGFjay13aGl0ZS1ibGFjazsgZ2l2ZSB0aGUgYmVuZWZpdCBvZiB0aGUgZG91YnQgdGhhdCB0aGUgbmV4dCBwaXhlbCBvdXRzaWRlIHRoZSBpbWFnZVxuICAgICAgICAgICAgLy8gaXMgXCJ3aGl0ZVwiIHNvIHRoaXMgbGFzdCBwb2ludCBhdCAodG9YK3hTdGVwLHRvWSkgaXMgdGhlIHJpZ2h0IGVuZGluZy4gVGhpcyBpcyByZWFsbHkgYVxuICAgICAgICAgICAgLy8gc21hbGwgYXBwcm94aW1hdGlvbjsgKHRvWCt4U3RlcCx0b1kreVN0ZXApIG1pZ2h0IGJlIHJlYWxseSBjb3JyZWN0LiBJZ25vcmUgdGhpcy5cbiAgICAgICAgICAgIGlmIChzdGF0ZSA9PT0gMikge1xuICAgICAgICAgICAgICAgIHJldHVybiBNYXRoVXRpbHMuZGlzdGFuY2UodG9YICsgeHN0ZXAsIHRvWSwgZnJvbVgsIGZyb21ZKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGVsc2Ugd2UgZGlkbid0IGZpbmQgZXZlbiBibGFjay13aGl0ZS1ibGFjazsgbm8gZXN0aW1hdGUgaXMgcmVhbGx5IHBvc3NpYmxlXG4gICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiA8cD5BdHRlbXB0cyB0byBsb2NhdGUgYW4gYWxpZ25tZW50IHBhdHRlcm4gaW4gYSBsaW1pdGVkIHJlZ2lvbiBvZiB0aGUgaW1hZ2UsIHdoaWNoIGlzXG4gICAgICAgICAqIGd1ZXNzZWQgdG8gY29udGFpbiBpdC4gVGhpcyBtZXRob2QgdXNlcyB7QGxpbmsgQWxpZ25tZW50UGF0dGVybn0uPC9wPlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gb3ZlcmFsbEVzdE1vZHVsZVNpemUgZXN0aW1hdGVkIG1vZHVsZSBzaXplIHNvIGZhclxuICAgICAgICAgKiBAcGFyYW0gZXN0QWxpZ25tZW50WCB4IGNvb3JkaW5hdGUgb2YgY2VudGVyIG9mIGFyZWEgcHJvYmFibHkgY29udGFpbmluZyBhbGlnbm1lbnQgcGF0dGVyblxuICAgICAgICAgKiBAcGFyYW0gZXN0QWxpZ25tZW50WSB5IGNvb3JkaW5hdGUgb2YgYWJvdmVcbiAgICAgICAgICogQHBhcmFtIGFsbG93YW5jZUZhY3RvciBudW1iZXIgb2YgcGl4ZWxzIGluIGFsbCBkaXJlY3Rpb25zIHRvIHNlYXJjaCBmcm9tIHRoZSBjZW50ZXJcbiAgICAgICAgICogQHJldHVybiB7QGxpbmsgQWxpZ25tZW50UGF0dGVybn0gaWYgZm91bmQsIG9yIG51bGwgb3RoZXJ3aXNlXG4gICAgICAgICAqIEB0aHJvd3MgTm90Rm91bmRFeGNlcHRpb24gaWYgYW4gdW5leHBlY3RlZCBlcnJvciBvY2N1cnMgZHVyaW5nIGRldGVjdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgZmluZEFsaWdubWVudEluUmVnaW9uKG92ZXJhbGxFc3RNb2R1bGVTaXplIC8qZmxvYXQqLywgZXN0QWxpZ25tZW50WCAvKmludCovLCBlc3RBbGlnbm1lbnRZIC8qaW50Ki8sIGFsbG93YW5jZUZhY3RvciAvKmZsb2F0Ki8pIHtcbiAgICAgICAgICAgIC8vIExvb2sgZm9yIGFuIGFsaWdubWVudCBwYXR0ZXJuICgzIG1vZHVsZXMgaW4gc2l6ZSkgYXJvdW5kIHdoZXJlIGl0XG4gICAgICAgICAgICAvLyBzaG91bGQgYmVcbiAgICAgICAgICAgIGNvbnN0IGFsbG93YW5jZSA9IC8qKGludCkgKi8gTWF0aC5mbG9vcihhbGxvd2FuY2VGYWN0b3IgKiBvdmVyYWxsRXN0TW9kdWxlU2l6ZSk7XG4gICAgICAgICAgICBjb25zdCBhbGlnbm1lbnRBcmVhTGVmdFggPSBNYXRoLm1heCgwLCBlc3RBbGlnbm1lbnRYIC0gYWxsb3dhbmNlKTtcbiAgICAgICAgICAgIGNvbnN0IGFsaWdubWVudEFyZWFSaWdodFggPSBNYXRoLm1pbih0aGlzLmltYWdlLmdldFdpZHRoKCkgLSAxLCBlc3RBbGlnbm1lbnRYICsgYWxsb3dhbmNlKTtcbiAgICAgICAgICAgIGlmIChhbGlnbm1lbnRBcmVhUmlnaHRYIC0gYWxpZ25tZW50QXJlYUxlZnRYIDwgb3ZlcmFsbEVzdE1vZHVsZVNpemUgKiAzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCdBbGlnbm1lbnQgdG9wIGV4Y2VlZHMgZXN0aW1hdGVkIG1vZHVsZSBzaXplLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYWxpZ25tZW50QXJlYVRvcFkgPSBNYXRoLm1heCgwLCBlc3RBbGlnbm1lbnRZIC0gYWxsb3dhbmNlKTtcbiAgICAgICAgICAgIGNvbnN0IGFsaWdubWVudEFyZWFCb3R0b21ZID0gTWF0aC5taW4odGhpcy5pbWFnZS5nZXRIZWlnaHQoKSAtIDEsIGVzdEFsaWdubWVudFkgKyBhbGxvd2FuY2UpO1xuICAgICAgICAgICAgaWYgKGFsaWdubWVudEFyZWFCb3R0b21ZIC0gYWxpZ25tZW50QXJlYVRvcFkgPCBvdmVyYWxsRXN0TW9kdWxlU2l6ZSAqIDMpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oJ0FsaWdubWVudCBib3R0b20gZXhjZWVkcyBlc3RpbWF0ZWQgbW9kdWxlIHNpemUuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhbGlnbm1lbnRGaW5kZXIgPSBuZXcgQWxpZ25tZW50UGF0dGVybkZpbmRlcih0aGlzLmltYWdlLCBhbGlnbm1lbnRBcmVhTGVmdFgsIGFsaWdubWVudEFyZWFUb3BZLCBhbGlnbm1lbnRBcmVhUmlnaHRYIC0gYWxpZ25tZW50QXJlYUxlZnRYLCBhbGlnbm1lbnRBcmVhQm90dG9tWSAtIGFsaWdubWVudEFyZWFUb3BZLCBvdmVyYWxsRXN0TW9kdWxlU2l6ZSwgdGhpcy5yZXN1bHRQb2ludENhbGxiYWNrKTtcbiAgICAgICAgICAgIHJldHVybiBhbGlnbm1lbnRGaW5kZXIuZmluZCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBDb3B5cmlnaHQgMjAwNyBaWGluZyBhdXRob3JzXG4gICAgICpcbiAgICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgICAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgICAgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgICAgKlxuICAgICAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gICAgICpcbiAgICAgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICAgICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgICAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICAgICAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgICAgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAgICAgKi9cbiAgICAvKmltcG9ydCBqYXZhLnV0aWwuTGlzdDsqL1xuICAgIC8qaW1wb3J0IGphdmEudXRpbC5NYXA7Ki9cbiAgICAvKipcbiAgICAgKiBUaGlzIGltcGxlbWVudGF0aW9uIGNhbiBkZXRlY3QgYW5kIGRlY29kZSBRUiBDb2RlcyBpbiBhbiBpbWFnZS5cbiAgICAgKlxuICAgICAqIEBhdXRob3IgU2VhbiBPd2VuXG4gICAgICovXG4gICAgY2xhc3MgUVJDb2RlUmVhZGVyIHtcbiAgICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgICAgICB0aGlzLmRlY29kZXIgPSBuZXcgRGVjb2RlciQyKCk7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0RGVjb2RlcigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlY29kZXI7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIExvY2F0ZXMgYW5kIGRlY29kZXMgYSBRUiBjb2RlIGluIGFuIGltYWdlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIGEgcmVwcmVzZW50aW5nOiBzdHJpbmcgdGhlIGNvbnRlbnQgZW5jb2RlZCBieSB0aGUgUVIgY29kZVxuICAgICAgICAgKiBAdGhyb3dzIE5vdEZvdW5kRXhjZXB0aW9uIGlmIGEgUVIgY29kZSBjYW5ub3QgYmUgZm91bmRcbiAgICAgICAgICogQHRocm93cyBGb3JtYXRFeGNlcHRpb24gaWYgYSBRUiBjb2RlIGNhbm5vdCBiZSBkZWNvZGVkXG4gICAgICAgICAqIEB0aHJvd3MgQ2hlY2tzdW1FeGNlcHRpb24gaWYgZXJyb3IgY29ycmVjdGlvbiBmYWlsc1xuICAgICAgICAgKi9cbiAgICAgICAgLypAT3ZlcnJpZGUqL1xuICAgICAgICAvLyBwdWJsaWMgZGVjb2RlKGltYWdlOiBCaW5hcnlCaXRtYXApOiBSZXN1bHQgLyp0aHJvd3MgTm90Rm91bmRFeGNlcHRpb24sIENoZWNrc3VtRXhjZXB0aW9uLCBGb3JtYXRFeGNlcHRpb24gKi8ge1xuICAgICAgICAvLyAgIHJldHVybiB0aGlzLmRlY29kZShpbWFnZSwgbnVsbClcbiAgICAgICAgLy8gfVxuICAgICAgICAvKkBPdmVycmlkZSovXG4gICAgICAgIGRlY29kZShpbWFnZSwgaGludHMpIHtcbiAgICAgICAgICAgIGxldCBkZWNvZGVyUmVzdWx0O1xuICAgICAgICAgICAgbGV0IHBvaW50cztcbiAgICAgICAgICAgIGlmIChoaW50cyAhPT0gdW5kZWZpbmVkICYmIGhpbnRzICE9PSBudWxsICYmIHVuZGVmaW5lZCAhPT0gaGludHMuZ2V0KERlY29kZUhpbnRUeXBlJDEuUFVSRV9CQVJDT0RFKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJpdHMgPSBRUkNvZGVSZWFkZXIuZXh0cmFjdFB1cmVCaXRzKGltYWdlLmdldEJsYWNrTWF0cml4KCkpO1xuICAgICAgICAgICAgICAgIGRlY29kZXJSZXN1bHQgPSB0aGlzLmRlY29kZXIuZGVjb2RlQml0TWF0cml4KGJpdHMsIGhpbnRzKTtcbiAgICAgICAgICAgICAgICBwb2ludHMgPSBRUkNvZGVSZWFkZXIuTk9fUE9JTlRTO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGV0ZWN0b3JSZXN1bHQgPSBuZXcgRGV0ZWN0b3IkMihpbWFnZS5nZXRCbGFja01hdHJpeCgpKS5kZXRlY3QoaGludHMpO1xuICAgICAgICAgICAgICAgIGRlY29kZXJSZXN1bHQgPSB0aGlzLmRlY29kZXIuZGVjb2RlQml0TWF0cml4KGRldGVjdG9yUmVzdWx0LmdldEJpdHMoKSwgaGludHMpO1xuICAgICAgICAgICAgICAgIHBvaW50cyA9IGRldGVjdG9yUmVzdWx0LmdldFBvaW50cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgdGhlIGNvZGUgd2FzIG1pcnJvcmVkOiBzd2FwIHRoZSBib3R0b20tbGVmdCBhbmQgdGhlIHRvcC1yaWdodCBwb2ludHMuXG4gICAgICAgICAgICBpZiAoZGVjb2RlclJlc3VsdC5nZXRPdGhlcigpIGluc3RhbmNlb2YgUVJDb2RlRGVjb2Rlck1ldGFEYXRhKSB7XG4gICAgICAgICAgICAgICAgZGVjb2RlclJlc3VsdC5nZXRPdGhlcigpLmFwcGx5TWlycm9yZWRDb3JyZWN0aW9uKHBvaW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgUmVzdWx0KGRlY29kZXJSZXN1bHQuZ2V0VGV4dCgpLCBkZWNvZGVyUmVzdWx0LmdldFJhd0J5dGVzKCksIHVuZGVmaW5lZCwgcG9pbnRzLCBCYXJjb2RlRm9ybWF0JDEuUVJfQ09ERSwgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIGNvbnN0IGJ5dGVTZWdtZW50cyA9IGRlY29kZXJSZXN1bHQuZ2V0Qnl0ZVNlZ21lbnRzKCk7XG4gICAgICAgICAgICBpZiAoYnl0ZVNlZ21lbnRzICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1dE1ldGFkYXRhKFJlc3VsdE1ldGFkYXRhVHlwZSQxLkJZVEVfU0VHTUVOVFMsIGJ5dGVTZWdtZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBlY0xldmVsID0gZGVjb2RlclJlc3VsdC5nZXRFQ0xldmVsKCk7XG4gICAgICAgICAgICBpZiAoZWNMZXZlbCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXRNZXRhZGF0YShSZXN1bHRNZXRhZGF0YVR5cGUkMS5FUlJPUl9DT1JSRUNUSU9OX0xFVkVMLCBlY0xldmVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkZWNvZGVyUmVzdWx0Lmhhc1N0cnVjdHVyZWRBcHBlbmQoKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXRNZXRhZGF0YShSZXN1bHRNZXRhZGF0YVR5cGUkMS5TVFJVQ1RVUkVEX0FQUEVORF9TRVFVRU5DRSwgZGVjb2RlclJlc3VsdC5nZXRTdHJ1Y3R1cmVkQXBwZW5kU2VxdWVuY2VOdW1iZXIoKSk7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1dE1ldGFkYXRhKFJlc3VsdE1ldGFkYXRhVHlwZSQxLlNUUlVDVFVSRURfQVBQRU5EX1BBUklUWSwgZGVjb2RlclJlc3VsdC5nZXRTdHJ1Y3R1cmVkQXBwZW5kUGFyaXR5KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICAvKkBPdmVycmlkZSovXG4gICAgICAgIHJlc2V0KCkge1xuICAgICAgICAgICAgLy8gZG8gbm90aGluZ1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIG1ldGhvZCBkZXRlY3RzIGEgY29kZSBpbiBhIFwicHVyZVwiIGltYWdlIC0tIHRoYXQgaXMsIHB1cmUgbW9ub2Nocm9tZSBpbWFnZVxuICAgICAgICAgKiB3aGljaCBjb250YWlucyBvbmx5IGFuIHVucm90YXRlZCwgdW5za2V3ZWQsIGltYWdlIG9mIGEgY29kZSwgd2l0aCBzb21lIHdoaXRlIGJvcmRlclxuICAgICAgICAgKiBhcm91bmQgaXQuIFRoaXMgaXMgYSBzcGVjaWFsaXplZCBtZXRob2QgdGhhdCB3b3JrcyBleGNlcHRpb25hbGx5IGZhc3QgaW4gdGhpcyBzcGVjaWFsXG4gICAgICAgICAqIGNhc2UuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBzZWUgY29tLmdvb2dsZS56eGluZy5kYXRhbWF0cml4LkRhdGFNYXRyaXhSZWFkZXIjZXh0cmFjdFB1cmVCaXRzKEJpdE1hdHJpeClcbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBleHRyYWN0UHVyZUJpdHMoaW1hZ2UpIHtcbiAgICAgICAgICAgIGNvbnN0IGxlZnRUb3BCbGFjayA9IGltYWdlLmdldFRvcExlZnRPbkJpdCgpO1xuICAgICAgICAgICAgY29uc3QgcmlnaHRCb3R0b21CbGFjayA9IGltYWdlLmdldEJvdHRvbVJpZ2h0T25CaXQoKTtcbiAgICAgICAgICAgIGlmIChsZWZ0VG9wQmxhY2sgPT09IG51bGwgfHwgcmlnaHRCb3R0b21CbGFjayA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbW9kdWxlU2l6ZSA9IHRoaXMubW9kdWxlU2l6ZShsZWZ0VG9wQmxhY2ssIGltYWdlKTtcbiAgICAgICAgICAgIGxldCB0b3AgPSBsZWZ0VG9wQmxhY2tbMV07XG4gICAgICAgICAgICBsZXQgYm90dG9tID0gcmlnaHRCb3R0b21CbGFja1sxXTtcbiAgICAgICAgICAgIGxldCBsZWZ0ID0gbGVmdFRvcEJsYWNrWzBdO1xuICAgICAgICAgICAgbGV0IHJpZ2h0ID0gcmlnaHRCb3R0b21CbGFja1swXTtcbiAgICAgICAgICAgIC8vIFNhbml0eSBjaGVjayFcbiAgICAgICAgICAgIGlmIChsZWZ0ID49IHJpZ2h0IHx8IHRvcCA+PSBib3R0b20pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChib3R0b20gLSB0b3AgIT09IHJpZ2h0IC0gbGVmdCkge1xuICAgICAgICAgICAgICAgIC8vIFNwZWNpYWwgY2FzZSwgd2hlcmUgYm90dG9tLXJpZ2h0IG1vZHVsZSB3YXNuJ3QgYmxhY2sgc28gd2UgZm91bmQgc29tZXRoaW5nIGVsc2UgaW4gdGhlIGxhc3Qgcm93XG4gICAgICAgICAgICAgICAgLy8gQXNzdW1lIGl0J3MgYSBzcXVhcmUsIHNvIHVzZSBoZWlnaHQgYXMgdGhlIHdpZHRoXG4gICAgICAgICAgICAgICAgcmlnaHQgPSBsZWZ0ICsgKGJvdHRvbSAtIHRvcCk7XG4gICAgICAgICAgICAgICAgaWYgKHJpZ2h0ID49IGltYWdlLmdldFdpZHRoKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQWJvcnQgaWYgdGhhdCB3b3VsZCBub3QgbWFrZSBzZW5zZSAtLSBvZmYgaW1hZ2VcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbWF0cml4V2lkdGggPSBNYXRoLnJvdW5kKChyaWdodCAtIGxlZnQgKyAxKSAvIG1vZHVsZVNpemUpO1xuICAgICAgICAgICAgY29uc3QgbWF0cml4SGVpZ2h0ID0gTWF0aC5yb3VuZCgoYm90dG9tIC0gdG9wICsgMSkgLyBtb2R1bGVTaXplKTtcbiAgICAgICAgICAgIGlmIChtYXRyaXhXaWR0aCA8PSAwIHx8IG1hdHJpeEhlaWdodCA8PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF0cml4SGVpZ2h0ICE9PSBtYXRyaXhXaWR0aCkge1xuICAgICAgICAgICAgICAgIC8vIE9ubHkgcG9zc2libHkgZGVjb2RlIHNxdWFyZSByZWdpb25zXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBQdXNoIGluIHRoZSBcImJvcmRlclwiIGJ5IGhhbGYgdGhlIG1vZHVsZSB3aWR0aCBzbyB0aGF0IHdlIHN0YXJ0XG4gICAgICAgICAgICAvLyBzYW1wbGluZyBpbiB0aGUgbWlkZGxlIG9mIHRoZSBtb2R1bGUuIEp1c3QgaW4gY2FzZSB0aGUgaW1hZ2UgaXMgYVxuICAgICAgICAgICAgLy8gbGl0dGxlIG9mZiwgdGhpcyB3aWxsIGhlbHAgcmVjb3Zlci5cbiAgICAgICAgICAgIGNvbnN0IG51ZGdlID0gLyooaW50KSAqLyBNYXRoLmZsb29yKG1vZHVsZVNpemUgLyAyLjApO1xuICAgICAgICAgICAgdG9wICs9IG51ZGdlO1xuICAgICAgICAgICAgbGVmdCArPSBudWRnZTtcbiAgICAgICAgICAgIC8vIEJ1dCBjYXJlZnVsIHRoYXQgdGhpcyBkb2VzIG5vdCBzYW1wbGUgb2ZmIHRoZSBlZGdlXG4gICAgICAgICAgICAvLyBcInJpZ2h0XCIgaXMgdGhlIGZhcnRoZXN0LXJpZ2h0IHZhbGlkIHBpeGVsIGxvY2F0aW9uIC0tIHJpZ2h0KzEgaXMgbm90IG5lY2Vzc2FyaWx5XG4gICAgICAgICAgICAvLyBUaGlzIGlzIHBvc2l0aXZlIGJ5IGhvdyBtdWNoIHRoZSBpbm5lciB4IGxvb3AgYmVsb3cgd291bGQgYmUgdG9vIGxhcmdlXG4gICAgICAgICAgICBjb25zdCBudWRnZWRUb29GYXJSaWdodCA9IGxlZnQgKyAvKihpbnQpICovIE1hdGguZmxvb3IoKG1hdHJpeFdpZHRoIC0gMSkgKiBtb2R1bGVTaXplKSAtIHJpZ2h0O1xuICAgICAgICAgICAgaWYgKG51ZGdlZFRvb0ZhclJpZ2h0ID4gMCkge1xuICAgICAgICAgICAgICAgIGlmIChudWRnZWRUb29GYXJSaWdodCA+IG51ZGdlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5laXRoZXIgd2F5IGZpdHM7IGFib3J0XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZWZ0IC09IG51ZGdlZFRvb0ZhclJpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU2VlIGxvZ2ljIGFib3ZlXG4gICAgICAgICAgICBjb25zdCBudWRnZWRUb29GYXJEb3duID0gdG9wICsgLyooaW50KSAqLyBNYXRoLmZsb29yKChtYXRyaXhIZWlnaHQgLSAxKSAqIG1vZHVsZVNpemUpIC0gYm90dG9tO1xuICAgICAgICAgICAgaWYgKG51ZGdlZFRvb0ZhckRvd24gPiAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKG51ZGdlZFRvb0ZhckRvd24gPiBudWRnZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBOZWl0aGVyIHdheSBmaXRzOyBhYm9ydFxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdG9wIC09IG51ZGdlZFRvb0ZhckRvd247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBOb3cganVzdCByZWFkIG9mZiB0aGUgYml0c1xuICAgICAgICAgICAgY29uc3QgYml0cyA9IG5ldyBCaXRNYXRyaXgobWF0cml4V2lkdGgsIG1hdHJpeEhlaWdodCk7XG4gICAgICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IG1hdHJpeEhlaWdodDsgeSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaU9mZnNldCA9IHRvcCArIC8qKGludCkgKi8gTWF0aC5mbG9vcih5ICogbW9kdWxlU2l6ZSk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCBtYXRyaXhXaWR0aDsgeCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbWFnZS5nZXQobGVmdCArIC8qKGludCkgKi8gTWF0aC5mbG9vcih4ICogbW9kdWxlU2l6ZSksIGlPZmZzZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiaXRzLnNldCh4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBiaXRzO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBtb2R1bGVTaXplKGxlZnRUb3BCbGFjaywgaW1hZ2UpIHtcbiAgICAgICAgICAgIGNvbnN0IGhlaWdodCA9IGltYWdlLmdldEhlaWdodCgpO1xuICAgICAgICAgICAgY29uc3Qgd2lkdGggPSBpbWFnZS5nZXRXaWR0aCgpO1xuICAgICAgICAgICAgbGV0IHggPSBsZWZ0VG9wQmxhY2tbMF07XG4gICAgICAgICAgICBsZXQgeSA9IGxlZnRUb3BCbGFja1sxXTtcbiAgICAgICAgICAgIGxldCBpbkJsYWNrID0gdHJ1ZTtcbiAgICAgICAgICAgIGxldCB0cmFuc2l0aW9ucyA9IDA7XG4gICAgICAgICAgICB3aGlsZSAoeCA8IHdpZHRoICYmIHkgPCBoZWlnaHQpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5CbGFjayAhPT0gaW1hZ2UuZ2V0KHgsIHkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgrK3RyYW5zaXRpb25zID09PSA1KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpbkJsYWNrID0gIWluQmxhY2s7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHgrKztcbiAgICAgICAgICAgICAgICB5Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoeCA9PT0gd2lkdGggfHwgeSA9PT0gaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKHggLSBsZWZ0VG9wQmxhY2tbMF0pIC8gNy4wO1xuICAgICAgICB9XG4gICAgfVxuICAgIFFSQ29kZVJlYWRlci5OT19QT0lOVFMgPSBuZXcgQXJyYXkoKTtcblxuICAgIC8qXG4gICAgKiBDb3B5cmlnaHQgMjAwOSBaWGluZyBhdXRob3JzXG4gICAgKlxuICAgICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgICAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgICAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgICpcbiAgICAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gICAgKlxuICAgICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICAgICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gICAgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gICAgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAgICAqL1xuICAgIC8qKlxuICAgICAqIEBhdXRob3IgU0lUQSBMYWIgKGtldmluLm9zdWxsaXZhbkBzaXRhLmFlcm8pXG4gICAgICogQGF1dGhvciBHdWVudGhlciBHcmF1XG4gICAgICovXG4gICAgLypwdWJsaWMgZmluYWwqLyBjbGFzcyBQREY0MTdDb21tb24ge1xuICAgICAgICBQREY0MTdDb21tb24oKSB7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSBtb2R1bGVCaXRDb3VudCB2YWx1ZXMgdG8gc3VtXG4gICAgICAgICAqIEByZXR1cm4gc3VtIG9mIHZhbHVlc1xuICAgICAgICAgKiBAZGVwcmVjYXRlZCBjYWxsIHtAbGluayBNYXRoVXRpbHMjc3VtKGludFtdKX1cbiAgICAgICAgICovXG4gICAgICAgIC8vIEBEZXByZWNhdGVkXG4gICAgICAgIHN0YXRpYyBnZXRCaXRDb3VudFN1bShtb2R1bGVCaXRDb3VudCkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGhVdGlscy5zdW0obW9kdWxlQml0Q291bnQpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyB0b0ludEFycmF5KGxpc3QpIHtcbiAgICAgICAgICAgIGlmIChsaXN0ID09IG51bGwgfHwgIWxpc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFBERjQxN0NvbW1vbi5FTVBUWV9JTlRfQVJSQVk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgSW50MzJBcnJheShsaXN0Lmxlbmd0aCk7XG4gICAgICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGludGVnZXIgb2YgbGlzdCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtpKytdID0gaW50ZWdlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSBzeW1ib2wgZW5jb2RlZCBzeW1ib2wgdG8gdHJhbnNsYXRlIHRvIGEgY29kZXdvcmRcbiAgICAgICAgICogQHJldHVybiB0aGUgY29kZXdvcmQgY29ycmVzcG9uZGluZyB0byB0aGUgc3ltYm9sLlxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGdldENvZGV3b3JkKHN5bWJvbCAvKmludCovKSB7XG4gICAgICAgICAgICBjb25zdCBpID0gQXJyYXlzLmJpbmFyeVNlYXJjaChQREY0MTdDb21tb24uU1lNQk9MX1RBQkxFLCBzeW1ib2wgJiAweDNGRkZGKTtcbiAgICAgICAgICAgIGlmIChpIDwgMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAoUERGNDE3Q29tbW9uLkNPREVXT1JEX1RBQkxFW2ldIC0gMSkgJSBQREY0MTdDb21tb24uTlVNQkVSX09GX0NPREVXT1JEUztcbiAgICAgICAgfVxuICAgIH1cbiAgICBQREY0MTdDb21tb24uTlVNQkVSX09GX0NPREVXT1JEUyA9IDkyOTtcbiAgICAvLyBNYXhpbXVtIENvZGV3b3JkcyAoRGF0YSArIEVycm9yKS5cbiAgICBQREY0MTdDb21tb24uTUFYX0NPREVXT1JEU19JTl9CQVJDT0RFID0gUERGNDE3Q29tbW9uLk5VTUJFUl9PRl9DT0RFV09SRFMgLSAxO1xuICAgIFBERjQxN0NvbW1vbi5NSU5fUk9XU19JTl9CQVJDT0RFID0gMztcbiAgICBQREY0MTdDb21tb24uTUFYX1JPV1NfSU5fQkFSQ09ERSA9IDkwO1xuICAgIC8vIE9uZSBsZWZ0IHJvdyBpbmRpY2F0aW9uIGNvbHVtbiArIG1heCAzMCBkYXRhIGNvbHVtbnMgKyBvbmUgcmlnaHQgcm93IGluZGljYXRvciBjb2x1bW5cbiAgICAvLyBwdWJsaWMgc3RhdGljIC8qZmluYWwqLyBNQVhfQ09ERVdPUkRTX0lOX1JPVzogLyppbnQqLyBudW1iZXIgPSAzMjtcbiAgICBQREY0MTdDb21tb24uTU9EVUxFU19JTl9DT0RFV09SRCA9IDE3O1xuICAgIFBERjQxN0NvbW1vbi5NT0RVTEVTX0lOX1NUT1BfUEFUVEVSTiA9IDE4O1xuICAgIFBERjQxN0NvbW1vbi5CQVJTX0lOX01PRFVMRSA9IDg7XG4gICAgUERGNDE3Q29tbW9uLkVNUFRZX0lOVF9BUlJBWSA9IG5ldyBJbnQzMkFycmF5KFtdKTtcbiAgICAvKipcbiAgICAgKiBUaGUgc29ydGVkIHRhYmxlIG9mIGFsbCBwb3NzaWJsZSBzeW1ib2xzLiBFeHRyYWN0ZWQgZnJvbSB0aGUgUERGNDE3XG4gICAgICogc3BlY2lmaWNhdGlvbi4gVGhlIGluZGV4IG9mIGEgc3ltYm9sIGluIHRoaXMgdGFibGUgY29ycmVzcG9uZHMgdG8gdGhlXG4gICAgICogaW5kZXggaW50byB0aGUgY29kZXdvcmQgdGFibGUuXG4gICAgICovXG4gICAgUERGNDE3Q29tbW9uLlNZTUJPTF9UQUJMRSA9IEludDMyQXJyYXkuZnJvbShbXG4gICAgICAgIDB4MTAyNWUsIDB4MTAyN2EsIDB4MTAyOWUsIDB4MTAyYmMsIDB4MTAyZjIsIDB4MTAyZjQsIDB4MTAzMmUsIDB4MTAzNGUsIDB4MTAzNWMsIDB4MTAzOTYsIDB4MTAzYTYsIDB4MTAzYWMsXG4gICAgICAgIDB4MTA0MjIsIDB4MTA0MjgsIDB4MTA0MzYsIDB4MTA0NDIsIDB4MTA0NDQsIDB4MTA0NDgsIDB4MTA0NTAsIDB4MTA0NWUsIDB4MTA0NjYsIDB4MTA0NmMsIDB4MTA0N2EsIDB4MTA0ODIsXG4gICAgICAgIDB4MTA0OWUsIDB4MTA0YTAsIDB4MTA0YmMsIDB4MTA0YzYsIDB4MTA0ZDgsIDB4MTA0ZWUsIDB4MTA0ZjIsIDB4MTA0ZjQsIDB4MTA1MDQsIDB4MTA1MDgsIDB4MTA1MTAsIDB4MTA1MWUsXG4gICAgICAgIDB4MTA1MjAsIDB4MTA1M2MsIDB4MTA1NDAsIDB4MTA1NzgsIDB4MTA1ODYsIDB4MTA1OGMsIDB4MTA1OTgsIDB4MTA1YjAsIDB4MTA1YmUsIDB4MTA1Y2UsIDB4MTA1ZGMsIDB4MTA1ZTIsXG4gICAgICAgIDB4MTA1ZTQsIDB4MTA1ZTgsIDB4MTA1ZjYsIDB4MTA2MmUsIDB4MTA2NGUsIDB4MTA2NWMsIDB4MTA2OGUsIDB4MTA2OWMsIDB4MTA2YjgsIDB4MTA2ZGUsIDB4MTA2ZmEsIDB4MTA3MTYsXG4gICAgICAgIDB4MTA3MjYsIDB4MTA3MmMsIDB4MTA3NDYsIDB4MTA3NGMsIDB4MTA3NTgsIDB4MTA3NmUsIDB4MTA3OTIsIDB4MTA3OTQsIDB4MTA3YTIsIDB4MTA3YTQsIDB4MTA3YTgsIDB4MTA3YjYsXG4gICAgICAgIDB4MTA4MjIsIDB4MTA4MjgsIDB4MTA4NDIsIDB4MTA4NDgsIDB4MTA4NTAsIDB4MTA4NWUsIDB4MTA4NjYsIDB4MTA4NmMsIDB4MTA4N2EsIDB4MTA4ODIsIDB4MTA4ODQsIDB4MTA4OTAsXG4gICAgICAgIDB4MTA4OWUsIDB4MTA4YTAsIDB4MTA4YmMsIDB4MTA4YzYsIDB4MTA4Y2MsIDB4MTA4ZDgsIDB4MTA4ZWUsIDB4MTA4ZjIsIDB4MTA4ZjQsIDB4MTA5MDIsIDB4MTA5MDgsIDB4MTA5MWUsXG4gICAgICAgIDB4MTA5MjAsIDB4MTA5M2MsIDB4MTA5NDAsIDB4MTA5NzgsIDB4MTA5ODYsIDB4MTA5OTgsIDB4MTA5YjAsIDB4MTA5YmUsIDB4MTA5Y2UsIDB4MTA5ZGMsIDB4MTA5ZTIsIDB4MTA5ZTQsXG4gICAgICAgIDB4MTA5ZTgsIDB4MTA5ZjYsIDB4MTBhMDgsIDB4MTBhMTAsIDB4MTBhMWUsIDB4MTBhMjAsIDB4MTBhM2MsIDB4MTBhNDAsIDB4MTBhNzgsIDB4MTBhZjAsIDB4MTBiMDYsIDB4MTBiMGMsXG4gICAgICAgIDB4MTBiMTgsIDB4MTBiMzAsIDB4MTBiM2UsIDB4MTBiNjAsIDB4MTBiN2MsIDB4MTBiOGUsIDB4MTBiOWMsIDB4MTBiYjgsIDB4MTBiYzIsIDB4MTBiYzQsIDB4MTBiYzgsIDB4MTBiZDAsXG4gICAgICAgIDB4MTBiZGUsIDB4MTBiZTYsIDB4MTBiZWMsIDB4MTBjMmUsIDB4MTBjNGUsIDB4MTBjNWMsIDB4MTBjNjIsIDB4MTBjNjQsIDB4MTBjNjgsIDB4MTBjNzYsIDB4MTBjOGUsIDB4MTBjOWMsXG4gICAgICAgIDB4MTBjYjgsIDB4MTBjYzIsIDB4MTBjYzQsIDB4MTBjYzgsIDB4MTBjZDAsIDB4MTBjZGUsIDB4MTBjZTYsIDB4MTBjZWMsIDB4MTBjZmEsIDB4MTBkMGUsIDB4MTBkMWMsIDB4MTBkMzgsXG4gICAgICAgIDB4MTBkNzAsIDB4MTBkN2UsIDB4MTBkODIsIDB4MTBkODQsIDB4MTBkODgsIDB4MTBkOTAsIDB4MTBkOWUsIDB4MTBkYTAsIDB4MTBkYmMsIDB4MTBkYzYsIDB4MTBkY2MsIDB4MTBkZDgsXG4gICAgICAgIDB4MTBkZWUsIDB4MTBkZjIsIDB4MTBkZjQsIDB4MTBlMTYsIDB4MTBlMjYsIDB4MTBlMmMsIDB4MTBlNDYsIDB4MTBlNTgsIDB4MTBlNmUsIDB4MTBlODYsIDB4MTBlOGMsIDB4MTBlOTgsXG4gICAgICAgIDB4MTBlYjAsIDB4MTBlYmUsIDB4MTBlY2UsIDB4MTBlZGMsIDB4MTBmMGEsIDB4MTBmMTIsIDB4MTBmMTQsIDB4MTBmMjIsIDB4MTBmMjgsIDB4MTBmMzYsIDB4MTBmNDIsIDB4MTBmNDQsXG4gICAgICAgIDB4MTBmNDgsIDB4MTBmNTAsIDB4MTBmNWUsIDB4MTBmNjYsIDB4MTBmNmMsIDB4MTBmYjIsIDB4MTBmYjQsIDB4MTEwMjIsIDB4MTEwMjgsIDB4MTEwNDIsIDB4MTEwNDgsIDB4MTEwNTAsXG4gICAgICAgIDB4MTEwNWUsIDB4MTEwN2EsIDB4MTEwODIsIDB4MTEwODQsIDB4MTEwOTAsIDB4MTEwOWUsIDB4MTEwYTAsIDB4MTEwYmMsIDB4MTEwYzYsIDB4MTEwY2MsIDB4MTEwZDgsIDB4MTEwZWUsXG4gICAgICAgIDB4MTEwZjIsIDB4MTEwZjQsIDB4MTExMDIsIDB4MTExMWUsIDB4MTExMjAsIDB4MTExM2MsIDB4MTExNDAsIDB4MTExNzgsIDB4MTExODYsIDB4MTExOTgsIDB4MTExYjAsIDB4MTExYmUsXG4gICAgICAgIDB4MTExY2UsIDB4MTExZGMsIDB4MTExZTIsIDB4MTExZTQsIDB4MTExZTgsIDB4MTExZjYsIDB4MTEyMDgsIDB4MTEyMWUsIDB4MTEyMjAsIDB4MTEyNzgsIDB4MTEyZjAsIDB4MTEzMGMsXG4gICAgICAgIDB4MTEzMzAsIDB4MTEzM2UsIDB4MTEzNjAsIDB4MTEzN2MsIDB4MTEzOGUsIDB4MTEzOWMsIDB4MTEzYjgsIDB4MTEzYzIsIDB4MTEzYzgsIDB4MTEzZDAsIDB4MTEzZGUsIDB4MTEzZTYsXG4gICAgICAgIDB4MTEzZWMsIDB4MTE0MDgsIDB4MTE0MTAsIDB4MTE0MWUsIDB4MTE0MjAsIDB4MTE0M2MsIDB4MTE0NDAsIDB4MTE0NzgsIDB4MTE0ZjAsIDB4MTE1ZTAsIDB4MTE2MGMsIDB4MTE2MTgsXG4gICAgICAgIDB4MTE2MzAsIDB4MTE2M2UsIDB4MTE2NjAsIDB4MTE2N2MsIDB4MTE2YzAsIDB4MTE2ZjgsIDB4MTE3MWMsIDB4MTE3MzgsIDB4MTE3NzAsIDB4MTE3N2UsIDB4MTE3ODIsIDB4MTE3ODQsXG4gICAgICAgIDB4MTE3ODgsIDB4MTE3OTAsIDB4MTE3OWUsIDB4MTE3YTAsIDB4MTE3YmMsIDB4MTE3YzYsIDB4MTE3Y2MsIDB4MTE3ZDgsIDB4MTE3ZWUsIDB4MTE4MmUsIDB4MTE4MzQsIDB4MTE4NGUsXG4gICAgICAgIDB4MTE4NWMsIDB4MTE4NjIsIDB4MTE4NjQsIDB4MTE4NjgsIDB4MTE4NzYsIDB4MTE4OGUsIDB4MTE4OWMsIDB4MTE4YjgsIDB4MTE4YzIsIDB4MTE4YzgsIDB4MTE4ZDAsIDB4MTE4ZGUsXG4gICAgICAgIDB4MTE4ZTYsIDB4MTE4ZWMsIDB4MTE4ZmEsIDB4MTE5MGUsIDB4MTE5MWMsIDB4MTE5MzgsIDB4MTE5NzAsIDB4MTE5N2UsIDB4MTE5ODIsIDB4MTE5ODQsIDB4MTE5OTAsIDB4MTE5OWUsXG4gICAgICAgIDB4MTE5YTAsIDB4MTE5YmMsIDB4MTE5YzYsIDB4MTE5Y2MsIDB4MTE5ZDgsIDB4MTE5ZWUsIDB4MTE5ZjIsIDB4MTE5ZjQsIDB4MTFhMGUsIDB4MTFhMWMsIDB4MTFhMzgsIDB4MTFhNzAsXG4gICAgICAgIDB4MTFhN2UsIDB4MTFhZTAsIDB4MTFhZmMsIDB4MTFiMDgsIDB4MTFiMTAsIDB4MTFiMWUsIDB4MTFiMjAsIDB4MTFiM2MsIDB4MTFiNDAsIDB4MTFiNzgsIDB4MTFiOGMsIDB4MTFiOTgsXG4gICAgICAgIDB4MTFiYjAsIDB4MTFiYmUsIDB4MTFiY2UsIDB4MTFiZGMsIDB4MTFiZTIsIDB4MTFiZTQsIDB4MTFiZTgsIDB4MTFiZjYsIDB4MTFjMTYsIDB4MTFjMjYsIDB4MTFjMmMsIDB4MTFjNDYsXG4gICAgICAgIDB4MTFjNGMsIDB4MTFjNTgsIDB4MTFjNmUsIDB4MTFjODYsIDB4MTFjOTgsIDB4MTFjYjAsIDB4MTFjYmUsIDB4MTFjY2UsIDB4MTFjZGMsIDB4MTFjZTIsIDB4MTFjZTQsIDB4MTFjZTgsXG4gICAgICAgIDB4MTFjZjYsIDB4MTFkMDYsIDB4MTFkMGMsIDB4MTFkMTgsIDB4MTFkMzAsIDB4MTFkM2UsIDB4MTFkNjAsIDB4MTFkN2MsIDB4MTFkOGUsIDB4MTFkOWMsIDB4MTFkYjgsIDB4MTFkYzQsXG4gICAgICAgIDB4MTFkYzgsIDB4MTFkZDAsIDB4MTFkZGUsIDB4MTFkZTYsIDB4MTFkZWMsIDB4MTFkZmEsIDB4MTFlMGEsIDB4MTFlMTIsIDB4MTFlMTQsIDB4MTFlMjIsIDB4MTFlMjQsIDB4MTFlMjgsXG4gICAgICAgIDB4MTFlMzYsIDB4MTFlNDIsIDB4MTFlNDQsIDB4MTFlNTAsIDB4MTFlNWUsIDB4MTFlNjYsIDB4MTFlNmMsIDB4MTFlODIsIDB4MTFlODQsIDB4MTFlODgsIDB4MTFlOTAsIDB4MTFlOWUsXG4gICAgICAgIDB4MTFlYTAsIDB4MTFlYmMsIDB4MTFlYzYsIDB4MTFlY2MsIDB4MTFlZDgsIDB4MTFlZWUsIDB4MTFmMWEsIDB4MTFmMmUsIDB4MTFmMzIsIDB4MTFmMzQsIDB4MTFmNGUsIDB4MTFmNWMsXG4gICAgICAgIDB4MTFmNjIsIDB4MTFmNjQsIDB4MTFmNjgsIDB4MTFmNzYsIDB4MTIwNDgsIDB4MTIwNWUsIDB4MTIwODIsIDB4MTIwODQsIDB4MTIwOTAsIDB4MTIwOWUsIDB4MTIwYTAsIDB4MTIwYmMsXG4gICAgICAgIDB4MTIwZDgsIDB4MTIwZjIsIDB4MTIwZjQsIDB4MTIxMDgsIDB4MTIxMWUsIDB4MTIxMjAsIDB4MTIxM2MsIDB4MTIxNDAsIDB4MTIxNzgsIDB4MTIxODYsIDB4MTIxOTgsIDB4MTIxYjAsXG4gICAgICAgIDB4MTIxYmUsIDB4MTIxZTIsIDB4MTIxZTQsIDB4MTIxZTgsIDB4MTIxZjYsIDB4MTIyMDQsIDB4MTIyMTAsIDB4MTIyMWUsIDB4MTIyMjAsIDB4MTIyNzgsIDB4MTIyZjAsIDB4MTIzMDYsXG4gICAgICAgIDB4MTIzMGMsIDB4MTIzMzAsIDB4MTIzM2UsIDB4MTIzNjAsIDB4MTIzN2MsIDB4MTIzOGUsIDB4MTIzOWMsIDB4MTIzYjgsIDB4MTIzYzIsIDB4MTIzYzgsIDB4MTIzZDAsIDB4MTIzZTYsXG4gICAgICAgIDB4MTIzZWMsIDB4MTI0MWUsIDB4MTI0MjAsIDB4MTI0M2MsIDB4MTI0ZjAsIDB4MTI1ZTAsIDB4MTI2MTgsIDB4MTI2M2UsIDB4MTI2NjAsIDB4MTI2N2MsIDB4MTI2YzAsIDB4MTI2ZjgsXG4gICAgICAgIDB4MTI3MzgsIDB4MTI3NzAsIDB4MTI3N2UsIDB4MTI3ODIsIDB4MTI3ODQsIDB4MTI3OTAsIDB4MTI3OWUsIDB4MTI3YTAsIDB4MTI3YmMsIDB4MTI3YzYsIDB4MTI3Y2MsIDB4MTI3ZDgsXG4gICAgICAgIDB4MTI3ZWUsIDB4MTI4MjAsIDB4MTI4M2MsIDB4MTI4NDAsIDB4MTI4NzgsIDB4MTI4ZjAsIDB4MTI5ZTAsIDB4MTJiYzAsIDB4MTJjMTgsIDB4MTJjMzAsIDB4MTJjM2UsIDB4MTJjNjAsXG4gICAgICAgIDB4MTJjN2MsIDB4MTJjYzAsIDB4MTJjZjgsIDB4MTJkZjAsIDB4MTJlMWMsIDB4MTJlMzgsIDB4MTJlNzAsIDB4MTJlN2UsIDB4MTJlZTAsIDB4MTJlZmMsIDB4MTJmMDQsIDB4MTJmMDgsXG4gICAgICAgIDB4MTJmMTAsIDB4MTJmMjAsIDB4MTJmM2MsIDB4MTJmNDAsIDB4MTJmNzgsIDB4MTJmODYsIDB4MTJmOGMsIDB4MTJmOTgsIDB4MTJmYjAsIDB4MTJmYmUsIDB4MTJmY2UsIDB4MTJmZGMsXG4gICAgICAgIDB4MTMwMmUsIDB4MTMwNGUsIDB4MTMwNWMsIDB4MTMwNjIsIDB4MTMwNjgsIDB4MTMwOGUsIDB4MTMwOWMsIDB4MTMwYjgsIDB4MTMwYzIsIDB4MTMwYzgsIDB4MTMwZDAsIDB4MTMwZGUsXG4gICAgICAgIDB4MTMwZWMsIDB4MTMwZmEsIDB4MTMxMGUsIDB4MTMxMzgsIDB4MTMxNzAsIDB4MTMxN2UsIDB4MTMxODIsIDB4MTMxODQsIDB4MTMxOTAsIDB4MTMxOWUsIDB4MTMxYTAsIDB4MTMxYmMsXG4gICAgICAgIDB4MTMxYzYsIDB4MTMxY2MsIDB4MTMxZDgsIDB4MTMxZjIsIDB4MTMxZjQsIDB4MTMyMGUsIDB4MTMyMWMsIDB4MTMyNzAsIDB4MTMyN2UsIDB4MTMyZTAsIDB4MTMyZmMsIDB4MTMzMDgsXG4gICAgICAgIDB4MTMzMWUsIDB4MTMzMjAsIDB4MTMzM2MsIDB4MTMzNDAsIDB4MTMzNzgsIDB4MTMzODYsIDB4MTMzOTgsIDB4MTMzYjAsIDB4MTMzYmUsIDB4MTMzY2UsIDB4MTMzZGMsIDB4MTMzZTIsXG4gICAgICAgIDB4MTMzZTQsIDB4MTMzZTgsIDB4MTMzZjYsIDB4MTM0MGUsIDB4MTM0MWMsIDB4MTM0MzgsIDB4MTM0NzAsIDB4MTM0N2UsIDB4MTM0ZTAsIDB4MTM0ZmMsIDB4MTM1YzAsIDB4MTM1ZjgsXG4gICAgICAgIDB4MTM2MDgsIDB4MTM2MTAsIDB4MTM2MWUsIDB4MTM2MjAsIDB4MTM2M2MsIDB4MTM2NDAsIDB4MTM2NzgsIDB4MTM2ZjAsIDB4MTM3MGMsIDB4MTM3MTgsIDB4MTM3MzAsIDB4MTM3M2UsXG4gICAgICAgIDB4MTM3NjAsIDB4MTM3N2MsIDB4MTM3OWMsIDB4MTM3YjgsIDB4MTM3YzIsIDB4MTM3YzQsIDB4MTM3YzgsIDB4MTM3ZDAsIDB4MTM3ZGUsIDB4MTM3ZTYsIDB4MTM3ZWMsIDB4MTM4MTYsXG4gICAgICAgIDB4MTM4MjYsIDB4MTM4MmMsIDB4MTM4NDYsIDB4MTM4NGMsIDB4MTM4NTgsIDB4MTM4NmUsIDB4MTM4NzQsIDB4MTM4ODYsIDB4MTM4OTgsIDB4MTM4YjAsIDB4MTM4YmUsIDB4MTM4Y2UsXG4gICAgICAgIDB4MTM4ZGMsIDB4MTM4ZTIsIDB4MTM4ZTQsIDB4MTM4ZTgsIDB4MTM5MDYsIDB4MTM5MGMsIDB4MTM5MzAsIDB4MTM5M2UsIDB4MTM5NjAsIDB4MTM5N2MsIDB4MTM5OGUsIDB4MTM5OWMsXG4gICAgICAgIDB4MTM5YjgsIDB4MTM5YzgsIDB4MTM5ZDAsIDB4MTM5ZGUsIDB4MTM5ZTYsIDB4MTM5ZWMsIDB4MTM5ZmEsIDB4MTNhMDYsIDB4MTNhMGMsIDB4MTNhMTgsIDB4MTNhMzAsIDB4MTNhM2UsXG4gICAgICAgIDB4MTNhNjAsIDB4MTNhN2MsIDB4MTNhYzAsIDB4MTNhZjgsIDB4MTNiMGUsIDB4MTNiMWMsIDB4MTNiMzgsIDB4MTNiNzAsIDB4MTNiN2UsIDB4MTNiODgsIDB4MTNiOTAsIDB4MTNiOWUsXG4gICAgICAgIDB4MTNiYTAsIDB4MTNiYmMsIDB4MTNiY2MsIDB4MTNiZDgsIDB4MTNiZWUsIDB4MTNiZjIsIDB4MTNiZjQsIDB4MTNjMTIsIDB4MTNjMTQsIDB4MTNjMjIsIDB4MTNjMjQsIDB4MTNjMjgsXG4gICAgICAgIDB4MTNjMzYsIDB4MTNjNDIsIDB4MTNjNDgsIDB4MTNjNTAsIDB4MTNjNWUsIDB4MTNjNjYsIDB4MTNjNmMsIDB4MTNjODIsIDB4MTNjODQsIDB4MTNjOTAsIDB4MTNjOWUsIDB4MTNjYTAsXG4gICAgICAgIDB4MTNjYmMsIDB4MTNjYzYsIDB4MTNjY2MsIDB4MTNjZDgsIDB4MTNjZWUsIDB4MTNkMDIsIDB4MTNkMDQsIDB4MTNkMDgsIDB4MTNkMTAsIDB4MTNkMWUsIDB4MTNkMjAsIDB4MTNkM2MsXG4gICAgICAgIDB4MTNkNDAsIDB4MTNkNzgsIDB4MTNkODYsIDB4MTNkOGMsIDB4MTNkOTgsIDB4MTNkYjAsIDB4MTNkYmUsIDB4MTNkY2UsIDB4MTNkZGMsIDB4MTNkZTQsIDB4MTNkZTgsIDB4MTNkZjYsXG4gICAgICAgIDB4MTNlMWEsIDB4MTNlMmUsIDB4MTNlMzIsIDB4MTNlMzQsIDB4MTNlNGUsIDB4MTNlNWMsIDB4MTNlNjIsIDB4MTNlNjQsIDB4MTNlNjgsIDB4MTNlNzYsIDB4MTNlOGUsIDB4MTNlOWMsXG4gICAgICAgIDB4MTNlYjgsIDB4MTNlYzIsIDB4MTNlYzQsIDB4MTNlYzgsIDB4MTNlZDAsIDB4MTNlZGUsIDB4MTNlZTYsIDB4MTNlZWMsIDB4MTNmMjYsIDB4MTNmMmMsIDB4MTNmM2EsIDB4MTNmNDYsXG4gICAgICAgIDB4MTNmNGMsIDB4MTNmNTgsIDB4MTNmNmUsIDB4MTNmNzIsIDB4MTNmNzQsIDB4MTQwODIsIDB4MTQwOWUsIDB4MTQwYTAsIDB4MTQwYmMsIDB4MTQxMDQsIDB4MTQxMDgsIDB4MTQxMTAsXG4gICAgICAgIDB4MTQxMWUsIDB4MTQxMjAsIDB4MTQxM2MsIDB4MTQxNDAsIDB4MTQxNzgsIDB4MTQxOGMsIDB4MTQxOTgsIDB4MTQxYjAsIDB4MTQxYmUsIDB4MTQxZTIsIDB4MTQxZTQsIDB4MTQxZTgsXG4gICAgICAgIDB4MTQyMDgsIDB4MTQyMTAsIDB4MTQyMWUsIDB4MTQyMjAsIDB4MTQyM2MsIDB4MTQyNDAsIDB4MTQyNzgsIDB4MTQyZjAsIDB4MTQzMDYsIDB4MTQzMGMsIDB4MTQzMTgsIDB4MTQzMzAsXG4gICAgICAgIDB4MTQzM2UsIDB4MTQzNjAsIDB4MTQzN2MsIDB4MTQzOGUsIDB4MTQzYzIsIDB4MTQzYzQsIDB4MTQzYzgsIDB4MTQzZDAsIDB4MTQzZTYsIDB4MTQzZWMsIDB4MTQ0MDgsIDB4MTQ0MTAsXG4gICAgICAgIDB4MTQ0MWUsIDB4MTQ0MjAsIDB4MTQ0M2MsIDB4MTQ0NDAsIDB4MTQ0NzgsIDB4MTQ0ZjAsIDB4MTQ1ZTAsIDB4MTQ2MGMsIDB4MTQ2MTgsIDB4MTQ2MzAsIDB4MTQ2M2UsIDB4MTQ2NjAsXG4gICAgICAgIDB4MTQ2N2MsIDB4MTQ2YzAsIDB4MTQ2ZjgsIDB4MTQ3MWMsIDB4MTQ3MzgsIDB4MTQ3NzAsIDB4MTQ3N2UsIDB4MTQ3ODIsIDB4MTQ3ODQsIDB4MTQ3ODgsIDB4MTQ3OTAsIDB4MTQ3YTAsXG4gICAgICAgIDB4MTQ3YmMsIDB4MTQ3YzYsIDB4MTQ3Y2MsIDB4MTQ3ZDgsIDB4MTQ3ZWUsIDB4MTQ4MTAsIDB4MTQ4MjAsIDB4MTQ4M2MsIDB4MTQ4NDAsIDB4MTQ4NzgsIDB4MTQ4ZjAsIDB4MTQ5ZTAsXG4gICAgICAgIDB4MTRiYzAsIDB4MTRjMzAsIDB4MTRjM2UsIDB4MTRjNjAsIDB4MTRjN2MsIDB4MTRjYzAsIDB4MTRjZjgsIDB4MTRkZjAsIDB4MTRlMzgsIDB4MTRlNzAsIDB4MTRlN2UsIDB4MTRlZTAsXG4gICAgICAgIDB4MTRlZmMsIDB4MTRmMDQsIDB4MTRmMDgsIDB4MTRmMTAsIDB4MTRmMWUsIDB4MTRmMjAsIDB4MTRmM2MsIDB4MTRmNDAsIDB4MTRmNzgsIDB4MTRmODYsIDB4MTRmOGMsIDB4MTRmOTgsXG4gICAgICAgIDB4MTRmYjAsIDB4MTRmY2UsIDB4MTRmZGMsIDB4MTUwMjAsIDB4MTUwNDAsIDB4MTUwNzgsIDB4MTUwZjAsIDB4MTUxZTAsIDB4MTUzYzAsIDB4MTU4NjAsIDB4MTU4N2MsIDB4MTU4YzAsXG4gICAgICAgIDB4MTU4ZjgsIDB4MTU5ZjAsIDB4MTViZTAsIDB4MTVjNzAsIDB4MTVjN2UsIDB4MTVjZTAsIDB4MTVjZmMsIDB4MTVkYzAsIDB4MTVkZjgsIDB4MTVlMDgsIDB4MTVlMTAsIDB4MTVlMjAsXG4gICAgICAgIDB4MTVlNDAsIDB4MTVlNzgsIDB4MTVlZjAsIDB4MTVmMGMsIDB4MTVmMTgsIDB4MTVmMzAsIDB4MTVmNjAsIDB4MTVmN2MsIDB4MTVmOGUsIDB4MTVmOWMsIDB4MTVmYjgsIDB4MTYwNGUsXG4gICAgICAgIDB4MTYwNWMsIDB4MTYwOGUsIDB4MTYwOWMsIDB4MTYwYjgsIDB4MTYwYzIsIDB4MTYwYzQsIDB4MTYwYzgsIDB4MTYwZGUsIDB4MTYxMGUsIDB4MTYxMWMsIDB4MTYxMzgsIDB4MTYxNzAsXG4gICAgICAgIDB4MTYxN2UsIDB4MTYxODQsIDB4MTYxODgsIDB4MTYxOTAsIDB4MTYxOWUsIDB4MTYxYTAsIDB4MTYxYmMsIDB4MTYxYzYsIDB4MTYxY2MsIDB4MTYxZDgsIDB4MTYxZjIsIDB4MTYxZjQsXG4gICAgICAgIDB4MTYyMGUsIDB4MTYyMWMsIDB4MTYyMzgsIDB4MTYyNzAsIDB4MTYyN2UsIDB4MTYyZTAsIDB4MTYyZmMsIDB4MTYzMDQsIDB4MTYzMDgsIDB4MTYzMTAsIDB4MTYzMWUsIDB4MTYzMjAsXG4gICAgICAgIDB4MTYzM2MsIDB4MTYzNDAsIDB4MTYzNzgsIDB4MTYzODYsIDB4MTYzOGMsIDB4MTYzOTgsIDB4MTYzYjAsIDB4MTYzYmUsIDB4MTYzY2UsIDB4MTYzZGMsIDB4MTYzZTIsIDB4MTYzZTQsXG4gICAgICAgIDB4MTYzZTgsIDB4MTYzZjYsIDB4MTY0MGUsIDB4MTY0MWMsIDB4MTY0MzgsIDB4MTY0NzAsIDB4MTY0N2UsIDB4MTY0ZTAsIDB4MTY0ZmMsIDB4MTY1YzAsIDB4MTY1ZjgsIDB4MTY2MTAsXG4gICAgICAgIDB4MTY2MWUsIDB4MTY2MjAsIDB4MTY2M2MsIDB4MTY2NDAsIDB4MTY2NzgsIDB4MTY2ZjAsIDB4MTY3MTgsIDB4MTY3MzAsIDB4MTY3M2UsIDB4MTY3NjAsIDB4MTY3N2MsIDB4MTY3OGUsXG4gICAgICAgIDB4MTY3OWMsIDB4MTY3YjgsIDB4MTY3YzIsIDB4MTY3YzQsIDB4MTY3YzgsIDB4MTY3ZDAsIDB4MTY3ZGUsIDB4MTY3ZTYsIDB4MTY3ZWMsIDB4MTY4MWMsIDB4MTY4MzgsIDB4MTY4NzAsXG4gICAgICAgIDB4MTY4ZTAsIDB4MTY4ZmMsIDB4MTY5YzAsIDB4MTY5ZjgsIDB4MTZiZjAsIDB4MTZjMTAsIDB4MTZjMWUsIDB4MTZjMjAsIDB4MTZjM2MsIDB4MTZjNDAsIDB4MTZjNzgsIDB4MTZjZjAsXG4gICAgICAgIDB4MTZkZTAsIDB4MTZlMTgsIDB4MTZlMzAsIDB4MTZlM2UsIDB4MTZlNjAsIDB4MTZlN2MsIDB4MTZlYzAsIDB4MTZlZjgsIDB4MTZmMWMsIDB4MTZmMzgsIDB4MTZmNzAsIDB4MTZmN2UsXG4gICAgICAgIDB4MTZmODQsIDB4MTZmODgsIDB4MTZmOTAsIDB4MTZmOWUsIDB4MTZmYTAsIDB4MTZmYmMsIDB4MTZmYzYsIDB4MTZmY2MsIDB4MTZmZDgsIDB4MTcwMjYsIDB4MTcwMmMsIDB4MTcwNDYsXG4gICAgICAgIDB4MTcwNGMsIDB4MTcwNTgsIDB4MTcwNmUsIDB4MTcwODYsIDB4MTcwOGMsIDB4MTcwOTgsIDB4MTcwYjAsIDB4MTcwYmUsIDB4MTcwY2UsIDB4MTcwZGMsIDB4MTcwZTgsIDB4MTcxMDYsXG4gICAgICAgIDB4MTcxMGMsIDB4MTcxMTgsIDB4MTcxMzAsIDB4MTcxM2UsIDB4MTcxNjAsIDB4MTcxN2MsIDB4MTcxOGUsIDB4MTcxOWMsIDB4MTcxYjgsIDB4MTcxYzIsIDB4MTcxYzQsIDB4MTcxYzgsXG4gICAgICAgIDB4MTcxZDAsIDB4MTcxZGUsIDB4MTcxZTYsIDB4MTcxZWMsIDB4MTcxZmEsIDB4MTcyMDYsIDB4MTcyMGMsIDB4MTcyMTgsIDB4MTcyMzAsIDB4MTcyM2UsIDB4MTcyNjAsIDB4MTcyN2MsXG4gICAgICAgIDB4MTcyYzAsIDB4MTcyZjgsIDB4MTczMGUsIDB4MTczMWMsIDB4MTczMzgsIDB4MTczNzAsIDB4MTczN2UsIDB4MTczODgsIDB4MTczOTAsIDB4MTczOWUsIDB4MTczYTAsIDB4MTczYmMsXG4gICAgICAgIDB4MTczY2MsIDB4MTczZDgsIDB4MTczZWUsIDB4MTczZjIsIDB4MTczZjQsIDB4MTc0MGMsIDB4MTc0MTgsIDB4MTc0MzAsIDB4MTc0M2UsIDB4MTc0NjAsIDB4MTc0N2MsIDB4MTc0YzAsXG4gICAgICAgIDB4MTc0ZjgsIDB4MTc1ZjAsIDB4MTc2MGUsIDB4MTc2MWMsIDB4MTc2MzgsIDB4MTc2NzAsIDB4MTc2N2UsIDB4MTc2ZTAsIDB4MTc2ZmMsIDB4MTc3MDgsIDB4MTc3MTAsIDB4MTc3MWUsXG4gICAgICAgIDB4MTc3MjAsIDB4MTc3M2MsIDB4MTc3NDAsIDB4MTc3NzgsIDB4MTc3OTgsIDB4MTc3YjAsIDB4MTc3YmUsIDB4MTc3ZGMsIDB4MTc3ZTIsIDB4MTc3ZTQsIDB4MTc3ZTgsIDB4MTc4MjIsXG4gICAgICAgIDB4MTc4MjQsIDB4MTc4MjgsIDB4MTc4MzYsIDB4MTc4NDIsIDB4MTc4NDQsIDB4MTc4NDgsIDB4MTc4NTAsIDB4MTc4NWUsIDB4MTc4NjYsIDB4MTc4NmMsIDB4MTc4ODIsIDB4MTc4ODQsXG4gICAgICAgIDB4MTc4ODgsIDB4MTc4OTAsIDB4MTc4OWUsIDB4MTc4YTAsIDB4MTc4YmMsIDB4MTc4YzYsIDB4MTc4Y2MsIDB4MTc4ZDgsIDB4MTc4ZWUsIDB4MTc4ZjIsIDB4MTc4ZjQsIDB4MTc5MDIsXG4gICAgICAgIDB4MTc5MDQsIDB4MTc5MDgsIDB4MTc5MTAsIDB4MTc5MWUsIDB4MTc5MjAsIDB4MTc5M2MsIDB4MTc5NDAsIDB4MTc5NzgsIDB4MTc5ODYsIDB4MTc5OGMsIDB4MTc5OTgsIDB4MTc5YjAsXG4gICAgICAgIDB4MTc5YmUsIDB4MTc5Y2UsIDB4MTc5ZGMsIDB4MTc5ZTIsIDB4MTc5ZTQsIDB4MTc5ZTgsIDB4MTc5ZjYsIDB4MTdhMDQsIDB4MTdhMDgsIDB4MTdhMTAsIDB4MTdhMWUsIDB4MTdhMjAsXG4gICAgICAgIDB4MTdhM2MsIDB4MTdhNDAsIDB4MTdhNzgsIDB4MTdhZjAsIDB4MTdiMDYsIDB4MTdiMGMsIDB4MTdiMTgsIDB4MTdiMzAsIDB4MTdiM2UsIDB4MTdiNjAsIDB4MTdiN2MsIDB4MTdiOGUsXG4gICAgICAgIDB4MTdiOWMsIDB4MTdiYjgsIDB4MTdiYzQsIDB4MTdiYzgsIDB4MTdiZDAsIDB4MTdiZGUsIDB4MTdiZTYsIDB4MTdiZWMsIDB4MTdjMmUsIDB4MTdjMzIsIDB4MTdjMzQsIDB4MTdjNGUsXG4gICAgICAgIDB4MTdjNWMsIDB4MTdjNjIsIDB4MTdjNjQsIDB4MTdjNjgsIDB4MTdjNzYsIDB4MTdjOGUsIDB4MTdjOWMsIDB4MTdjYjgsIDB4MTdjYzIsIDB4MTdjYzQsIDB4MTdjYzgsIDB4MTdjZDAsXG4gICAgICAgIDB4MTdjZGUsIDB4MTdjZTYsIDB4MTdjZWMsIDB4MTdkMGUsIDB4MTdkMWMsIDB4MTdkMzgsIDB4MTdkNzAsIDB4MTdkODIsIDB4MTdkODQsIDB4MTdkODgsIDB4MTdkOTAsIDB4MTdkOWUsXG4gICAgICAgIDB4MTdkYTAsIDB4MTdkYmMsIDB4MTdkYzYsIDB4MTdkY2MsIDB4MTdkZDgsIDB4MTdkZWUsIDB4MTdlMjYsIDB4MTdlMmMsIDB4MTdlM2EsIDB4MTdlNDYsIDB4MTdlNGMsIDB4MTdlNTgsXG4gICAgICAgIDB4MTdlNmUsIDB4MTdlNzIsIDB4MTdlNzQsIDB4MTdlODYsIDB4MTdlOGMsIDB4MTdlOTgsIDB4MTdlYjAsIDB4MTdlY2UsIDB4MTdlZGMsIDB4MTdlZTIsIDB4MTdlZTQsIDB4MTdlZTgsXG4gICAgICAgIDB4MTdlZjYsIDB4MTgxM2EsIDB4MTgxNzIsIDB4MTgxNzQsIDB4MTgyMTYsIDB4MTgyMjYsIDB4MTgyM2EsIDB4MTgyNGMsIDB4MTgyNTgsIDB4MTgyNmUsIDB4MTgyNzIsIDB4MTgyNzQsXG4gICAgICAgIDB4MTgyOTgsIDB4MTgyYmUsIDB4MTgyZTIsIDB4MTgyZTQsIDB4MTgyZTgsIDB4MTgyZjYsIDB4MTgzNWUsIDB4MTgzN2EsIDB4MTgzYWUsIDB4MTgzZDYsIDB4MTg0MTYsIDB4MTg0MjYsXG4gICAgICAgIDB4MTg0MmMsIDB4MTg0M2EsIDB4MTg0NDYsIDB4MTg0NTgsIDB4MTg0NmUsIDB4MTg0NzIsIDB4MTg0NzQsIDB4MTg0ODYsIDB4MTg0YjAsIDB4MTg0YmUsIDB4MTg0Y2UsIDB4MTg0ZGMsXG4gICAgICAgIDB4MTg0ZTIsIDB4MTg0ZTQsIDB4MTg0ZTgsIDB4MTg0ZjYsIDB4MTg1MDYsIDB4MTg1MGMsIDB4MTg1MTgsIDB4MTg1MzAsIDB4MTg1M2UsIDB4MTg1NjAsIDB4MTg1N2MsIDB4MTg1OGUsXG4gICAgICAgIDB4MTg1OWMsIDB4MTg1YjgsIDB4MTg1YzIsIDB4MTg1YzQsIDB4MTg1YzgsIDB4MTg1ZDAsIDB4MTg1ZGUsIDB4MTg1ZTYsIDB4MTg1ZWMsIDB4MTg1ZmEsIDB4MTg2MTIsIDB4MTg2MTQsXG4gICAgICAgIDB4MTg2MjIsIDB4MTg2MjgsIDB4MTg2MzYsIDB4MTg2NDIsIDB4MTg2NTAsIDB4MTg2NWUsIDB4MTg2N2EsIDB4MTg2ODIsIDB4MTg2ODQsIDB4MTg2ODgsIDB4MTg2OTAsIDB4MTg2OWUsXG4gICAgICAgIDB4MTg2YTAsIDB4MTg2YmMsIDB4MTg2YzYsIDB4MTg2Y2MsIDB4MTg2ZDgsIDB4MTg2ZWUsIDB4MTg2ZjIsIDB4MTg2ZjQsIDB4MTg3MmUsIDB4MTg3NGUsIDB4MTg3NWMsIDB4MTg3OTYsXG4gICAgICAgIDB4MTg3YTYsIDB4MTg3YWMsIDB4MTg3ZDIsIDB4MTg3ZDQsIDB4MTg4MjYsIDB4MTg4MmMsIDB4MTg4M2EsIDB4MTg4NDYsIDB4MTg4NGMsIDB4MTg4NTgsIDB4MTg4NmUsIDB4MTg4NzIsXG4gICAgICAgIDB4MTg4NzQsIDB4MTg4ODYsIDB4MTg4OTgsIDB4MTg4YjAsIDB4MTg4YmUsIDB4MTg4Y2UsIDB4MTg4ZGMsIDB4MTg4ZTIsIDB4MTg4ZTQsIDB4MTg4ZTgsIDB4MTg4ZjYsIDB4MTg5MGMsXG4gICAgICAgIDB4MTg5MzAsIDB4MTg5M2UsIDB4MTg5NjAsIDB4MTg5N2MsIDB4MTg5OGUsIDB4MTg5YjgsIDB4MTg5YzIsIDB4MTg5YzgsIDB4MTg5ZDAsIDB4MTg5ZGUsIDB4MTg5ZTYsIDB4MTg5ZWMsXG4gICAgICAgIDB4MTg5ZmEsIDB4MThhMTgsIDB4MThhMzAsIDB4MThhM2UsIDB4MThhNjAsIDB4MThhN2MsIDB4MThhYzAsIDB4MThhZjgsIDB4MThiMWMsIDB4MThiMzgsIDB4MThiNzAsIDB4MThiN2UsXG4gICAgICAgIDB4MThiODIsIDB4MThiODQsIDB4MThiODgsIDB4MThiOTAsIDB4MThiOWUsIDB4MThiYTAsIDB4MThiYmMsIDB4MThiYzYsIDB4MThiY2MsIDB4MThiZDgsIDB4MThiZWUsIDB4MThiZjIsXG4gICAgICAgIDB4MThiZjQsIDB4MThjMjIsIDB4MThjMjQsIDB4MThjMjgsIDB4MThjMzYsIDB4MThjNDIsIDB4MThjNDgsIDB4MThjNTAsIDB4MThjNWUsIDB4MThjNjYsIDB4MThjN2EsIDB4MThjODIsXG4gICAgICAgIDB4MThjODQsIDB4MThjOTAsIDB4MThjOWUsIDB4MThjYTAsIDB4MThjYmMsIDB4MThjY2MsIDB4MThjZjIsIDB4MThjZjQsIDB4MThkMDQsIDB4MThkMDgsIDB4MThkMTAsIDB4MThkMWUsXG4gICAgICAgIDB4MThkMjAsIDB4MThkM2MsIDB4MThkNDAsIDB4MThkNzgsIDB4MThkODYsIDB4MThkOTgsIDB4MThkY2UsIDB4MThkZTIsIDB4MThkZTQsIDB4MThkZTgsIDB4MThlMmUsIDB4MThlMzIsXG4gICAgICAgIDB4MThlMzQsIDB4MThlNGUsIDB4MThlNWMsIDB4MThlNjIsIDB4MThlNjQsIDB4MThlNjgsIDB4MThlOGUsIDB4MThlOWMsIDB4MThlYjgsIDB4MThlYzIsIDB4MThlYzQsIDB4MThlYzgsXG4gICAgICAgIDB4MThlZDAsIDB4MThlZmEsIDB4MThmMTYsIDB4MThmMjYsIDB4MThmMmMsIDB4MThmNDYsIDB4MThmNGMsIDB4MThmNTgsIDB4MThmNmUsIDB4MThmOGEsIDB4MThmOTIsIDB4MThmOTQsXG4gICAgICAgIDB4MThmYTIsIDB4MThmYTQsIDB4MThmYTgsIDB4MThmYjYsIDB4MTkwMmMsIDB4MTkwM2EsIDB4MTkwNDYsIDB4MTkwNGMsIDB4MTkwNTgsIDB4MTkwNzIsIDB4MTkwNzQsIDB4MTkwODYsXG4gICAgICAgIDB4MTkwOTgsIDB4MTkwYjAsIDB4MTkwYmUsIDB4MTkwY2UsIDB4MTkwZGMsIDB4MTkwZTIsIDB4MTkwZTgsIDB4MTkwZjYsIDB4MTkxMDYsIDB4MTkxMGMsIDB4MTkxMzAsIDB4MTkxM2UsXG4gICAgICAgIDB4MTkxNjAsIDB4MTkxN2MsIDB4MTkxOGUsIDB4MTkxOWMsIDB4MTkxYjgsIDB4MTkxYzIsIDB4MTkxYzgsIDB4MTkxZDAsIDB4MTkxZGUsIDB4MTkxZTYsIDB4MTkxZWMsIDB4MTkxZmEsXG4gICAgICAgIDB4MTkyMTgsIDB4MTkyM2UsIDB4MTkyNjAsIDB4MTkyN2MsIDB4MTkyYzAsIDB4MTkyZjgsIDB4MTkzMzgsIDB4MTkzNzAsIDB4MTkzN2UsIDB4MTkzODIsIDB4MTkzODQsIDB4MTkzOTAsXG4gICAgICAgIDB4MTkzOWUsIDB4MTkzYTAsIDB4MTkzYmMsIDB4MTkzYzYsIDB4MTkzY2MsIDB4MTkzZDgsIDB4MTkzZWUsIDB4MTkzZjIsIDB4MTkzZjQsIDB4MTk0MzAsIDB4MTk0M2UsIDB4MTk0NjAsXG4gICAgICAgIDB4MTk0N2MsIDB4MTk0YzAsIDB4MTk0ZjgsIDB4MTk1ZjAsIDB4MTk2MzgsIDB4MTk2NzAsIDB4MTk2N2UsIDB4MTk2ZTAsIDB4MTk2ZmMsIDB4MTk3MDIsIDB4MTk3MDQsIDB4MTk3MDgsXG4gICAgICAgIDB4MTk3MTAsIDB4MTk3MjAsIDB4MTk3M2MsIDB4MTk3NDAsIDB4MTk3NzgsIDB4MTk3ODYsIDB4MTk3OGMsIDB4MTk3OTgsIDB4MTk3YjAsIDB4MTk3YmUsIDB4MTk3Y2UsIDB4MTk3ZGMsXG4gICAgICAgIDB4MTk3ZTIsIDB4MTk3ZTQsIDB4MTk3ZTgsIDB4MTk4MjIsIDB4MTk4MjQsIDB4MTk4NDIsIDB4MTk4NDgsIDB4MTk4NTAsIDB4MTk4NWUsIDB4MTk4NjYsIDB4MTk4N2EsIDB4MTk4ODIsXG4gICAgICAgIDB4MTk4ODQsIDB4MTk4OTAsIDB4MTk4OWUsIDB4MTk4YTAsIDB4MTk4YmMsIDB4MTk4Y2MsIDB4MTk4ZjIsIDB4MTk4ZjQsIDB4MTk5MDIsIDB4MTk5MDgsIDB4MTk5MWUsIDB4MTk5MjAsXG4gICAgICAgIDB4MTk5M2MsIDB4MTk5NDAsIDB4MTk5NzgsIDB4MTk5ODYsIDB4MTk5OTgsIDB4MTk5Y2UsIDB4MTk5ZTIsIDB4MTk5ZTQsIDB4MTk5ZTgsIDB4MTlhMDgsIDB4MTlhMTAsIDB4MTlhMWUsXG4gICAgICAgIDB4MTlhMjAsIDB4MTlhM2MsIDB4MTlhNDAsIDB4MTlhNzgsIDB4MTlhZjAsIDB4MTliMTgsIDB4MTliM2UsIDB4MTliNjAsIDB4MTliOWMsIDB4MTliYzIsIDB4MTliYzQsIDB4MTliYzgsXG4gICAgICAgIDB4MTliZDAsIDB4MTliZTYsIDB4MTljMmUsIDB4MTljMzQsIDB4MTljNGUsIDB4MTljNWMsIDB4MTljNjIsIDB4MTljNjQsIDB4MTljNjgsIDB4MTljOGUsIDB4MTljOWMsIDB4MTljYjgsXG4gICAgICAgIDB4MTljYzIsIDB4MTljYzgsIDB4MTljZDAsIDB4MTljZTYsIDB4MTljZmEsIDB4MTlkMGUsIDB4MTlkMWMsIDB4MTlkMzgsIDB4MTlkNzAsIDB4MTlkN2UsIDB4MTlkODIsIDB4MTlkODQsXG4gICAgICAgIDB4MTlkODgsIDB4MTlkOTAsIDB4MTlkYTAsIDB4MTlkY2MsIDB4MTlkZjIsIDB4MTlkZjQsIDB4MTllMTYsIDB4MTllMjYsIDB4MTllMmMsIDB4MTllNDYsIDB4MTllNGMsIDB4MTllNTgsXG4gICAgICAgIDB4MTllNzQsIDB4MTllODYsIDB4MTllOGMsIDB4MTllOTgsIDB4MTllYjAsIDB4MTllYmUsIDB4MTllY2UsIDB4MTllZTIsIDB4MTllZTQsIDB4MTllZTgsIDB4MTlmMGEsIDB4MTlmMTIsXG4gICAgICAgIDB4MTlmMTQsIDB4MTlmMjIsIDB4MTlmMjQsIDB4MTlmMjgsIDB4MTlmNDIsIDB4MTlmNDQsIDB4MTlmNDgsIDB4MTlmNTAsIDB4MTlmNWUsIDB4MTlmNmMsIDB4MTlmOWEsIDB4MTlmYWUsXG4gICAgICAgIDB4MTlmYjIsIDB4MTlmYjQsIDB4MWEwNDYsIDB4MWEwNGMsIDB4MWEwNzIsIDB4MWEwNzQsIDB4MWEwODYsIDB4MWEwOGMsIDB4MWEwOTgsIDB4MWEwYjAsIDB4MWEwYmUsIDB4MWEwZTIsXG4gICAgICAgIDB4MWEwZTQsIDB4MWEwZTgsIDB4MWEwZjYsIDB4MWExMDYsIDB4MWExMGMsIDB4MWExMTgsIDB4MWExMzAsIDB4MWExM2UsIDB4MWExNjAsIDB4MWExN2MsIDB4MWExOGUsIDB4MWExOWMsXG4gICAgICAgIDB4MWExYjgsIDB4MWExYzIsIDB4MWExYzQsIDB4MWExYzgsIDB4MWExZDAsIDB4MWExZGUsIDB4MWExZTYsIDB4MWExZWMsIDB4MWEyMTgsIDB4MWEyMzAsIDB4MWEyM2UsIDB4MWEyNjAsXG4gICAgICAgIDB4MWEyN2MsIDB4MWEyYzAsIDB4MWEyZjgsIDB4MWEzMWMsIDB4MWEzMzgsIDB4MWEzNzAsIDB4MWEzN2UsIDB4MWEzODIsIDB4MWEzODQsIDB4MWEzODgsIDB4MWEzOTAsIDB4MWEzOWUsXG4gICAgICAgIDB4MWEzYTAsIDB4MWEzYmMsIDB4MWEzYzYsIDB4MWEzY2MsIDB4MWEzZDgsIDB4MWEzZWUsIDB4MWEzZjIsIDB4MWEzZjQsIDB4MWE0MTgsIDB4MWE0MzAsIDB4MWE0M2UsIDB4MWE0NjAsXG4gICAgICAgIDB4MWE0N2MsIDB4MWE0YzAsIDB4MWE0ZjgsIDB4MWE1ZjAsIDB4MWE2MWMsIDB4MWE2MzgsIDB4MWE2NzAsIDB4MWE2N2UsIDB4MWE2ZTAsIDB4MWE2ZmMsIDB4MWE3MDIsIDB4MWE3MDQsXG4gICAgICAgIDB4MWE3MDgsIDB4MWE3MTAsIDB4MWE3MWUsIDB4MWE3MjAsIDB4MWE3M2MsIDB4MWE3NDAsIDB4MWE3NzgsIDB4MWE3ODYsIDB4MWE3OGMsIDB4MWE3OTgsIDB4MWE3YjAsIDB4MWE3YmUsXG4gICAgICAgIDB4MWE3Y2UsIDB4MWE3ZGMsIDB4MWE3ZTIsIDB4MWE3ZTQsIDB4MWE3ZTgsIDB4MWE4MzAsIDB4MWE4NjAsIDB4MWE4N2MsIDB4MWE4YzAsIDB4MWE4ZjgsIDB4MWE5ZjAsIDB4MWFiZTAsXG4gICAgICAgIDB4MWFjNzAsIDB4MWFjN2UsIDB4MWFjZTAsIDB4MWFjZmMsIDB4MWFkYzAsIDB4MWFkZjgsIDB4MWFlMDQsIDB4MWFlMDgsIDB4MWFlMTAsIDB4MWFlMjAsIDB4MWFlM2MsIDB4MWFlNDAsXG4gICAgICAgIDB4MWFlNzgsIDB4MWFlZjAsIDB4MWFmMDYsIDB4MWFmMGMsIDB4MWFmMTgsIDB4MWFmMzAsIDB4MWFmM2UsIDB4MWFmNjAsIDB4MWFmN2MsIDB4MWFmOGUsIDB4MWFmOWMsIDB4MWFmYjgsXG4gICAgICAgIDB4MWFmYzQsIDB4MWFmYzgsIDB4MWFmZDAsIDB4MWFmZGUsIDB4MWIwNDIsIDB4MWIwNWUsIDB4MWIwN2EsIDB4MWIwODIsIDB4MWIwODQsIDB4MWIwODgsIDB4MWIwOTAsIDB4MWIwOWUsXG4gICAgICAgIDB4MWIwYTAsIDB4MWIwYmMsIDB4MWIwY2MsIDB4MWIwZjIsIDB4MWIwZjQsIDB4MWIxMDIsIDB4MWIxMDQsIDB4MWIxMDgsIDB4MWIxMTAsIDB4MWIxMWUsIDB4MWIxMjAsIDB4MWIxM2MsXG4gICAgICAgIDB4MWIxNDAsIDB4MWIxNzgsIDB4MWIxODYsIDB4MWIxOTgsIDB4MWIxY2UsIDB4MWIxZTIsIDB4MWIxZTQsIDB4MWIxZTgsIDB4MWIyMDQsIDB4MWIyMDgsIDB4MWIyMTAsIDB4MWIyMWUsXG4gICAgICAgIDB4MWIyMjAsIDB4MWIyM2MsIDB4MWIyNDAsIDB4MWIyNzgsIDB4MWIyZjAsIDB4MWIzMGMsIDB4MWIzM2UsIDB4MWIzNjAsIDB4MWIzOWMsIDB4MWIzYzIsIDB4MWIzYzQsIDB4MWIzYzgsXG4gICAgICAgIDB4MWIzZDAsIDB4MWIzZTYsIDB4MWI0MTAsIDB4MWI0MWUsIDB4MWI0MjAsIDB4MWI0M2MsIDB4MWI0NDAsIDB4MWI0NzgsIDB4MWI0ZjAsIDB4MWI1ZTAsIDB4MWI2MTgsIDB4MWI2NjAsXG4gICAgICAgIDB4MWI2N2MsIDB4MWI2YzAsIDB4MWI3MzgsIDB4MWI3ODIsIDB4MWI3ODQsIDB4MWI3ODgsIDB4MWI3OTAsIDB4MWI3OWUsIDB4MWI3YTAsIDB4MWI3Y2MsIDB4MWI4MmUsIDB4MWI4NGUsXG4gICAgICAgIDB4MWI4NWMsIDB4MWI4OGUsIDB4MWI4OWMsIDB4MWI4YjgsIDB4MWI4YzIsIDB4MWI4YzQsIDB4MWI4YzgsIDB4MWI4ZDAsIDB4MWI4ZTYsIDB4MWI4ZmEsIDB4MWI5MGUsIDB4MWI5MWMsXG4gICAgICAgIDB4MWI5MzgsIDB4MWI5NzAsIDB4MWI5N2UsIDB4MWI5ODIsIDB4MWI5ODQsIDB4MWI5ODgsIDB4MWI5OTAsIDB4MWI5OWUsIDB4MWI5YTAsIDB4MWI5Y2MsIDB4MWI5ZjIsIDB4MWI5ZjQsXG4gICAgICAgIDB4MWJhMGUsIDB4MWJhMWMsIDB4MWJhMzgsIDB4MWJhNzAsIDB4MWJhN2UsIDB4MWJhZTAsIDB4MWJhZmMsIDB4MWJiMDgsIDB4MWJiMTAsIDB4MWJiMjAsIDB4MWJiM2MsIDB4MWJiNDAsXG4gICAgICAgIDB4MWJiOTgsIDB4MWJiY2UsIDB4MWJiZTIsIDB4MWJiZTQsIDB4MWJiZTgsIDB4MWJjMTYsIDB4MWJjMjYsIDB4MWJjMmMsIDB4MWJjNDYsIDB4MWJjNGMsIDB4MWJjNTgsIDB4MWJjNzIsXG4gICAgICAgIDB4MWJjNzQsIDB4MWJjODYsIDB4MWJjOGMsIDB4MWJjOTgsIDB4MWJjYjAsIDB4MWJjYmUsIDB4MWJjY2UsIDB4MWJjZTIsIDB4MWJjZTQsIDB4MWJjZTgsIDB4MWJkMDYsIDB4MWJkMGMsXG4gICAgICAgIDB4MWJkMTgsIDB4MWJkMzAsIDB4MWJkM2UsIDB4MWJkNjAsIDB4MWJkN2MsIDB4MWJkOWMsIDB4MWJkYzIsIDB4MWJkYzQsIDB4MWJkYzgsIDB4MWJkZDAsIDB4MWJkZTYsIDB4MWJkZmEsXG4gICAgICAgIDB4MWJlMTIsIDB4MWJlMTQsIDB4MWJlMjIsIDB4MWJlMjQsIDB4MWJlMjgsIDB4MWJlNDIsIDB4MWJlNDQsIDB4MWJlNDgsIDB4MWJlNTAsIDB4MWJlNWUsIDB4MWJlNjYsIDB4MWJlODIsXG4gICAgICAgIDB4MWJlODQsIDB4MWJlODgsIDB4MWJlOTAsIDB4MWJlOWUsIDB4MWJlYTAsIDB4MWJlYmMsIDB4MWJlY2MsIDB4MWJlZjQsIDB4MWJmMWEsIDB4MWJmMmUsIDB4MWJmMzIsIDB4MWJmMzQsXG4gICAgICAgIDB4MWJmNGUsIDB4MWJmNWMsIDB4MWJmNjIsIDB4MWJmNjQsIDB4MWJmNjgsIDB4MWMwOWEsIDB4MWMwYjIsIDB4MWMwYjQsIDB4MWMxMWEsIDB4MWMxMzIsIDB4MWMxMzQsIDB4MWMxNjIsXG4gICAgICAgIDB4MWMxNjQsIDB4MWMxNjgsIDB4MWMxNzYsIDB4MWMxYmEsIDB4MWMyMWEsIDB4MWMyMzIsIDB4MWMyMzQsIDB4MWMyNGUsIDB4MWMyNWMsIDB4MWMyNjIsIDB4MWMyNjQsIDB4MWMyNjgsXG4gICAgICAgIDB4MWMyNzYsIDB4MWMyOGUsIDB4MWMyYzIsIDB4MWMyYzQsIDB4MWMyYzgsIDB4MWMyZDAsIDB4MWMyZGUsIDB4MWMyZTYsIDB4MWMyZWMsIDB4MWMyZmEsIDB4MWMzMTYsIDB4MWMzMjYsXG4gICAgICAgIDB4MWMzM2EsIDB4MWMzNDYsIDB4MWMzNGMsIDB4MWMzNzIsIDB4MWMzNzQsIDB4MWM0MWEsIDB4MWM0MmUsIDB4MWM0MzIsIDB4MWM0MzQsIDB4MWM0NGUsIDB4MWM0NWMsIDB4MWM0NjIsXG4gICAgICAgIDB4MWM0NjQsIDB4MWM0NjgsIDB4MWM0NzYsIDB4MWM0OGUsIDB4MWM0OWMsIDB4MWM0YjgsIDB4MWM0YzIsIDB4MWM0YzgsIDB4MWM0ZDAsIDB4MWM0ZGUsIDB4MWM0ZTYsIDB4MWM0ZWMsXG4gICAgICAgIDB4MWM0ZmEsIDB4MWM1MWMsIDB4MWM1MzgsIDB4MWM1NzAsIDB4MWM1N2UsIDB4MWM1ODIsIDB4MWM1ODQsIDB4MWM1ODgsIDB4MWM1OTAsIDB4MWM1OWUsIDB4MWM1YTAsIDB4MWM1YmMsXG4gICAgICAgIDB4MWM1YzYsIDB4MWM1Y2MsIDB4MWM1ZDgsIDB4MWM1ZWUsIDB4MWM1ZjIsIDB4MWM1ZjQsIDB4MWM2MTYsIDB4MWM2MjYsIDB4MWM2MmMsIDB4MWM2M2EsIDB4MWM2NDYsIDB4MWM2NGMsXG4gICAgICAgIDB4MWM2NTgsIDB4MWM2NmUsIDB4MWM2NzIsIDB4MWM2NzQsIDB4MWM2ODYsIDB4MWM2OGMsIDB4MWM2OTgsIDB4MWM2YjAsIDB4MWM2YmUsIDB4MWM2Y2UsIDB4MWM2ZGMsIDB4MWM2ZTIsXG4gICAgICAgIDB4MWM2ZTQsIDB4MWM2ZTgsIDB4MWM3MTIsIDB4MWM3MTQsIDB4MWM3MjIsIDB4MWM3MjgsIDB4MWM3MzYsIDB4MWM3NDIsIDB4MWM3NDQsIDB4MWM3NDgsIDB4MWM3NTAsIDB4MWM3NWUsXG4gICAgICAgIDB4MWM3NjYsIDB4MWM3NmMsIDB4MWM3N2EsIDB4MWM3YWUsIDB4MWM3ZDYsIDB4MWM3ZWEsIDB4MWM4MWEsIDB4MWM4MmUsIDB4MWM4MzIsIDB4MWM4MzQsIDB4MWM4NGUsIDB4MWM4NWMsXG4gICAgICAgIDB4MWM4NjIsIDB4MWM4NjQsIDB4MWM4NjgsIDB4MWM4NzYsIDB4MWM4OGUsIDB4MWM4OWMsIDB4MWM4YjgsIDB4MWM4YzIsIDB4MWM4YzgsIDB4MWM4ZDAsIDB4MWM4ZGUsIDB4MWM4ZTYsXG4gICAgICAgIDB4MWM4ZWMsIDB4MWM4ZmEsIDB4MWM5MGUsIDB4MWM5MzgsIDB4MWM5NzAsIDB4MWM5N2UsIDB4MWM5ODIsIDB4MWM5ODQsIDB4MWM5OTAsIDB4MWM5OWUsIDB4MWM5YTAsIDB4MWM5YmMsXG4gICAgICAgIDB4MWM5YzYsIDB4MWM5Y2MsIDB4MWM5ZDgsIDB4MWM5ZWUsIDB4MWM5ZjIsIDB4MWM5ZjQsIDB4MWNhMzgsIDB4MWNhNzAsIDB4MWNhN2UsIDB4MWNhZTAsIDB4MWNhZmMsIDB4MWNiMDIsXG4gICAgICAgIDB4MWNiMDQsIDB4MWNiMDgsIDB4MWNiMTAsIDB4MWNiMjAsIDB4MWNiM2MsIDB4MWNiNDAsIDB4MWNiNzgsIDB4MWNiODYsIDB4MWNiOGMsIDB4MWNiOTgsIDB4MWNiYjAsIDB4MWNiYmUsXG4gICAgICAgIDB4MWNiY2UsIDB4MWNiZGMsIDB4MWNiZTIsIDB4MWNiZTQsIDB4MWNiZTgsIDB4MWNiZjYsIDB4MWNjMTYsIDB4MWNjMjYsIDB4MWNjMmMsIDB4MWNjM2EsIDB4MWNjNDYsIDB4MWNjNTgsXG4gICAgICAgIDB4MWNjNzIsIDB4MWNjNzQsIDB4MWNjODYsIDB4MWNjYjAsIDB4MWNjYmUsIDB4MWNjY2UsIDB4MWNjZTIsIDB4MWNjZTQsIDB4MWNjZTgsIDB4MWNkMDYsIDB4MWNkMGMsIDB4MWNkMTgsXG4gICAgICAgIDB4MWNkMzAsIDB4MWNkM2UsIDB4MWNkNjAsIDB4MWNkN2MsIDB4MWNkOWMsIDB4MWNkYzIsIDB4MWNkYzQsIDB4MWNkYzgsIDB4MWNkZDAsIDB4MWNkZGUsIDB4MWNkZTYsIDB4MWNkZmEsXG4gICAgICAgIDB4MWNlMjIsIDB4MWNlMjgsIDB4MWNlNDIsIDB4MWNlNTAsIDB4MWNlNWUsIDB4MWNlNjYsIDB4MWNlN2EsIDB4MWNlODIsIDB4MWNlODQsIDB4MWNlODgsIDB4MWNlOTAsIDB4MWNlOWUsXG4gICAgICAgIDB4MWNlYTAsIDB4MWNlYmMsIDB4MWNlY2MsIDB4MWNlZjIsIDB4MWNlZjQsIDB4MWNmMmUsIDB4MWNmMzIsIDB4MWNmMzQsIDB4MWNmNGUsIDB4MWNmNWMsIDB4MWNmNjIsIDB4MWNmNjQsXG4gICAgICAgIDB4MWNmNjgsIDB4MWNmOTYsIDB4MWNmYTYsIDB4MWNmYWMsIDB4MWNmY2EsIDB4MWNmZDIsIDB4MWNmZDQsIDB4MWQwMmUsIDB4MWQwMzIsIDB4MWQwMzQsIDB4MWQwNGUsIDB4MWQwNWMsXG4gICAgICAgIDB4MWQwNjIsIDB4MWQwNjQsIDB4MWQwNjgsIDB4MWQwNzYsIDB4MWQwOGUsIDB4MWQwOWMsIDB4MWQwYjgsIDB4MWQwYzIsIDB4MWQwYzQsIDB4MWQwYzgsIDB4MWQwZDAsIDB4MWQwZGUsXG4gICAgICAgIDB4MWQwZTYsIDB4MWQwZWMsIDB4MWQwZmEsIDB4MWQxMWMsIDB4MWQxMzgsIDB4MWQxNzAsIDB4MWQxN2UsIDB4MWQxODIsIDB4MWQxODQsIDB4MWQxODgsIDB4MWQxOTAsIDB4MWQxOWUsXG4gICAgICAgIDB4MWQxYTAsIDB4MWQxYmMsIDB4MWQxYzYsIDB4MWQxY2MsIDB4MWQxZDgsIDB4MWQxZWUsIDB4MWQxZjIsIDB4MWQxZjQsIDB4MWQyMWMsIDB4MWQyMzgsIDB4MWQyNzAsIDB4MWQyN2UsXG4gICAgICAgIDB4MWQyZTAsIDB4MWQyZmMsIDB4MWQzMDIsIDB4MWQzMDQsIDB4MWQzMDgsIDB4MWQzMTAsIDB4MWQzMWUsIDB4MWQzMjAsIDB4MWQzM2MsIDB4MWQzNDAsIDB4MWQzNzgsIDB4MWQzODYsXG4gICAgICAgIDB4MWQzOGMsIDB4MWQzOTgsIDB4MWQzYjAsIDB4MWQzYmUsIDB4MWQzY2UsIDB4MWQzZGMsIDB4MWQzZTIsIDB4MWQzZTQsIDB4MWQzZTgsIDB4MWQzZjYsIDB4MWQ0NzAsIDB4MWQ0N2UsXG4gICAgICAgIDB4MWQ0ZTAsIDB4MWQ0ZmMsIDB4MWQ1YzAsIDB4MWQ1ZjgsIDB4MWQ2MDQsIDB4MWQ2MDgsIDB4MWQ2MTAsIDB4MWQ2MjAsIDB4MWQ2NDAsIDB4MWQ2NzgsIDB4MWQ2ZjAsIDB4MWQ3MDYsXG4gICAgICAgIDB4MWQ3MGMsIDB4MWQ3MTgsIDB4MWQ3MzAsIDB4MWQ3M2UsIDB4MWQ3NjAsIDB4MWQ3N2MsIDB4MWQ3OGUsIDB4MWQ3OWMsIDB4MWQ3YjgsIDB4MWQ3YzIsIDB4MWQ3YzQsIDB4MWQ3YzgsXG4gICAgICAgIDB4MWQ3ZDAsIDB4MWQ3ZGUsIDB4MWQ3ZTYsIDB4MWQ3ZWMsIDB4MWQ4MjYsIDB4MWQ4MmMsIDB4MWQ4M2EsIDB4MWQ4NDYsIDB4MWQ4NGMsIDB4MWQ4NTgsIDB4MWQ4NzIsIDB4MWQ4NzQsXG4gICAgICAgIDB4MWQ4ODYsIDB4MWQ4OGMsIDB4MWQ4OTgsIDB4MWQ4YjAsIDB4MWQ4YmUsIDB4MWQ4Y2UsIDB4MWQ4ZTIsIDB4MWQ4ZTQsIDB4MWQ4ZTgsIDB4MWQ4ZjYsIDB4MWQ5MGMsIDB4MWQ5MTgsXG4gICAgICAgIDB4MWQ5MzAsIDB4MWQ5M2UsIDB4MWQ5NjAsIDB4MWQ5N2MsIDB4MWQ5OWMsIDB4MWQ5YzIsIDB4MWQ5YzQsIDB4MWQ5YzgsIDB4MWQ5ZDAsIDB4MWQ5ZTYsIDB4MWQ5ZmEsIDB4MWRhMGMsXG4gICAgICAgIDB4MWRhMTgsIDB4MWRhMzAsIDB4MWRhM2UsIDB4MWRhNjAsIDB4MWRhN2MsIDB4MWRhYzAsIDB4MWRhZjgsIDB4MWRiMzgsIDB4MWRiODIsIDB4MWRiODQsIDB4MWRiODgsIDB4MWRiOTAsXG4gICAgICAgIDB4MWRiOWUsIDB4MWRiYTAsIDB4MWRiY2MsIDB4MWRiZjIsIDB4MWRiZjQsIDB4MWRjMjIsIDB4MWRjNDIsIDB4MWRjNDQsIDB4MWRjNDgsIDB4MWRjNTAsIDB4MWRjNWUsIDB4MWRjNjYsXG4gICAgICAgIDB4MWRjN2EsIDB4MWRjODIsIDB4MWRjODQsIDB4MWRjODgsIDB4MWRjOTAsIDB4MWRjOWUsIDB4MWRjYTAsIDB4MWRjYmMsIDB4MWRjY2MsIDB4MWRjZjIsIDB4MWRjZjQsIDB4MWRkMDQsXG4gICAgICAgIDB4MWRkMDgsIDB4MWRkMTAsIDB4MWRkMWUsIDB4MWRkMjAsIDB4MWRkM2MsIDB4MWRkNDAsIDB4MWRkNzgsIDB4MWRkODYsIDB4MWRkOTgsIDB4MWRkY2UsIDB4MWRkZTIsIDB4MWRkZTQsXG4gICAgICAgIDB4MWRkZTgsIDB4MWRlMmUsIDB4MWRlMzIsIDB4MWRlMzQsIDB4MWRlNGUsIDB4MWRlNWMsIDB4MWRlNjIsIDB4MWRlNjQsIDB4MWRlNjgsIDB4MWRlOGUsIDB4MWRlOWMsIDB4MWRlYjgsXG4gICAgICAgIDB4MWRlYzIsIDB4MWRlYzQsIDB4MWRlYzgsIDB4MWRlZDAsIDB4MWRlZTYsIDB4MWRlZmEsIDB4MWRmMTYsIDB4MWRmMjYsIDB4MWRmMmMsIDB4MWRmNDYsIDB4MWRmNGMsIDB4MWRmNTgsXG4gICAgICAgIDB4MWRmNzIsIDB4MWRmNzQsIDB4MWRmOGEsIDB4MWRmOTIsIDB4MWRmOTQsIDB4MWRmYTIsIDB4MWRmYTQsIDB4MWRmYTgsIDB4MWUwOGEsIDB4MWUwOTIsIDB4MWUwOTQsIDB4MWUwYTIsXG4gICAgICAgIDB4MWUwYTQsIDB4MWUwYTgsIDB4MWUwYjYsIDB4MWUwZGEsIDB4MWUxMGEsIDB4MWUxMTIsIDB4MWUxMTQsIDB4MWUxMjIsIDB4MWUxMjQsIDB4MWUxMjgsIDB4MWUxMzYsIDB4MWUxNDIsXG4gICAgICAgIDB4MWUxNDQsIDB4MWUxNDgsIDB4MWUxNTAsIDB4MWUxNjYsIDB4MWUxNmMsIDB4MWUxN2EsIDB4MWUxOWEsIDB4MWUxYjIsIDB4MWUxYjQsIDB4MWUyMGEsIDB4MWUyMTIsIDB4MWUyMTQsXG4gICAgICAgIDB4MWUyMjIsIDB4MWUyMjQsIDB4MWUyMjgsIDB4MWUyMzYsIDB4MWUyNDIsIDB4MWUyNDgsIDB4MWUyNTAsIDB4MWUyNWUsIDB4MWUyNjYsIDB4MWUyNmMsIDB4MWUyN2EsIDB4MWUyODIsXG4gICAgICAgIDB4MWUyODQsIDB4MWUyODgsIDB4MWUyOTAsIDB4MWUyYTAsIDB4MWUyYmMsIDB4MWUyYzYsIDB4MWUyY2MsIDB4MWUyZDgsIDB4MWUyZWUsIDB4MWUyZjIsIDB4MWUyZjQsIDB4MWUzMWEsXG4gICAgICAgIDB4MWUzMzIsIDB4MWUzMzQsIDB4MWUzNWMsIDB4MWUzNjIsIDB4MWUzNjQsIDB4MWUzNjgsIDB4MWUzYmEsIDB4MWU0MGEsIDB4MWU0MTIsIDB4MWU0MTQsIDB4MWU0MjIsIDB4MWU0MjgsXG4gICAgICAgIDB4MWU0MzYsIDB4MWU0NDIsIDB4MWU0NDgsIDB4MWU0NTAsIDB4MWU0NWUsIDB4MWU0NjYsIDB4MWU0NmMsIDB4MWU0N2EsIDB4MWU0ODIsIDB4MWU0ODQsIDB4MWU0OTAsIDB4MWU0OWUsXG4gICAgICAgIDB4MWU0YTAsIDB4MWU0YmMsIDB4MWU0YzYsIDB4MWU0Y2MsIDB4MWU0ZDgsIDB4MWU0ZWUsIDB4MWU0ZjIsIDB4MWU0ZjQsIDB4MWU1MDIsIDB4MWU1MDQsIDB4MWU1MDgsIDB4MWU1MTAsXG4gICAgICAgIDB4MWU1MWUsIDB4MWU1MjAsIDB4MWU1M2MsIDB4MWU1NDAsIDB4MWU1NzgsIDB4MWU1ODYsIDB4MWU1OGMsIDB4MWU1OTgsIDB4MWU1YjAsIDB4MWU1YmUsIDB4MWU1Y2UsIDB4MWU1ZGMsXG4gICAgICAgIDB4MWU1ZTIsIDB4MWU1ZTQsIDB4MWU1ZTgsIDB4MWU1ZjYsIDB4MWU2MWEsIDB4MWU2MmUsIDB4MWU2MzIsIDB4MWU2MzQsIDB4MWU2NGUsIDB4MWU2NWMsIDB4MWU2NjIsIDB4MWU2NjgsXG4gICAgICAgIDB4MWU2OGUsIDB4MWU2OWMsIDB4MWU2YjgsIDB4MWU2YzIsIDB4MWU2YzQsIDB4MWU2YzgsIDB4MWU2ZDAsIDB4MWU2ZTYsIDB4MWU2ZmEsIDB4MWU3MTYsIDB4MWU3MjYsIDB4MWU3MmMsXG4gICAgICAgIDB4MWU3M2EsIDB4MWU3NDYsIDB4MWU3NGMsIDB4MWU3NTgsIDB4MWU3NzIsIDB4MWU3NzQsIDB4MWU3OTIsIDB4MWU3OTQsIDB4MWU3YTIsIDB4MWU3YTQsIDB4MWU3YTgsIDB4MWU3YjYsXG4gICAgICAgIDB4MWU4MTIsIDB4MWU4MTQsIDB4MWU4MjIsIDB4MWU4MjQsIDB4MWU4MjgsIDB4MWU4MzYsIDB4MWU4NDIsIDB4MWU4NDQsIDB4MWU4NDgsIDB4MWU4NTAsIDB4MWU4NWUsIDB4MWU4NjYsXG4gICAgICAgIDB4MWU4NmMsIDB4MWU4N2EsIDB4MWU4ODIsIDB4MWU4ODQsIDB4MWU4ODgsIDB4MWU4OTAsIDB4MWU4OWUsIDB4MWU4YTAsIDB4MWU4YmMsIDB4MWU4YzYsIDB4MWU4Y2MsIDB4MWU4ZDgsXG4gICAgICAgIDB4MWU4ZWUsIDB4MWU4ZjIsIDB4MWU4ZjQsIDB4MWU5MDIsIDB4MWU5MDQsIDB4MWU5MDgsIDB4MWU5MTAsIDB4MWU5MjAsIDB4MWU5M2MsIDB4MWU5NDAsIDB4MWU5NzgsIDB4MWU5ODYsXG4gICAgICAgIDB4MWU5OGMsIDB4MWU5OTgsIDB4MWU5YjAsIDB4MWU5YmUsIDB4MWU5Y2UsIDB4MWU5ZGMsIDB4MWU5ZTIsIDB4MWU5ZTQsIDB4MWU5ZTgsIDB4MWU5ZjYsIDB4MWVhMDQsIDB4MWVhMDgsXG4gICAgICAgIDB4MWVhMTAsIDB4MWVhMjAsIDB4MWVhNDAsIDB4MWVhNzgsIDB4MWVhZjAsIDB4MWViMDYsIDB4MWViMGMsIDB4MWViMTgsIDB4MWViMzAsIDB4MWViM2UsIDB4MWViNjAsIDB4MWViN2MsXG4gICAgICAgIDB4MWViOGUsIDB4MWViOWMsIDB4MWViYjgsIDB4MWViYzIsIDB4MWViYzQsIDB4MWViYzgsIDB4MWViZDAsIDB4MWViZGUsIDB4MWViZTYsIDB4MWViZWMsIDB4MWVjMWEsIDB4MWVjMmUsXG4gICAgICAgIDB4MWVjMzIsIDB4MWVjMzQsIDB4MWVjNGUsIDB4MWVjNWMsIDB4MWVjNjIsIDB4MWVjNjQsIDB4MWVjNjgsIDB4MWVjOGUsIDB4MWVjOWMsIDB4MWVjYjgsIDB4MWVjYzIsIDB4MWVjYzQsXG4gICAgICAgIDB4MWVjYzgsIDB4MWVjZDAsIDB4MWVjZTYsIDB4MWVjZmEsIDB4MWVkMGUsIDB4MWVkMWMsIDB4MWVkMzgsIDB4MWVkNzAsIDB4MWVkN2UsIDB4MWVkODIsIDB4MWVkODQsIDB4MWVkODgsXG4gICAgICAgIDB4MWVkOTAsIDB4MWVkOWUsIDB4MWVkYTAsIDB4MWVkY2MsIDB4MWVkZjIsIDB4MWVkZjQsIDB4MWVlMTYsIDB4MWVlMjYsIDB4MWVlMmMsIDB4MWVlM2EsIDB4MWVlNDYsIDB4MWVlNGMsXG4gICAgICAgIDB4MWVlNTgsIDB4MWVlNmUsIDB4MWVlNzIsIDB4MWVlNzQsIDB4MWVlODYsIDB4MWVlOGMsIDB4MWVlOTgsIDB4MWVlYjAsIDB4MWVlYmUsIDB4MWVlY2UsIDB4MWVlZGMsIDB4MWVlZTIsXG4gICAgICAgIDB4MWVlZTQsIDB4MWVlZTgsIDB4MWVmMTIsIDB4MWVmMjIsIDB4MWVmMjQsIDB4MWVmMjgsIDB4MWVmMzYsIDB4MWVmNDIsIDB4MWVmNDQsIDB4MWVmNDgsIDB4MWVmNTAsIDB4MWVmNWUsXG4gICAgICAgIDB4MWVmNjYsIDB4MWVmNmMsIDB4MWVmN2EsIDB4MWVmYWUsIDB4MWVmYjIsIDB4MWVmYjQsIDB4MWVmZDYsIDB4MWYwOTYsIDB4MWYwYTYsIDB4MWYwYWMsIDB4MWYwYmEsIDB4MWYwY2EsXG4gICAgICAgIDB4MWYwZDIsIDB4MWYwZDQsIDB4MWYxMTYsIDB4MWYxMjYsIDB4MWYxMmMsIDB4MWYxM2EsIDB4MWYxNDYsIDB4MWYxNGMsIDB4MWYxNTgsIDB4MWYxNmUsIDB4MWYxNzIsIDB4MWYxNzQsXG4gICAgICAgIDB4MWYxOGEsIDB4MWYxOTIsIDB4MWYxOTQsIDB4MWYxYTIsIDB4MWYxYTQsIDB4MWYxYTgsIDB4MWYxZGEsIDB4MWYyMTYsIDB4MWYyMjYsIDB4MWYyMmMsIDB4MWYyM2EsIDB4MWYyNDYsXG4gICAgICAgIDB4MWYyNTgsIDB4MWYyNmUsIDB4MWYyNzIsIDB4MWYyNzQsIDB4MWYyODYsIDB4MWYyOGMsIDB4MWYyOTgsIDB4MWYyYjAsIDB4MWYyYmUsIDB4MWYyY2UsIDB4MWYyZGMsIDB4MWYyZTIsXG4gICAgICAgIDB4MWYyZTQsIDB4MWYyZTgsIDB4MWYyZjYsIDB4MWYzMGEsIDB4MWYzMTIsIDB4MWYzMTQsIDB4MWYzMjIsIDB4MWYzMjgsIDB4MWYzNDIsIDB4MWYzNDQsIDB4MWYzNDgsIDB4MWYzNTAsXG4gICAgICAgIDB4MWYzNWUsIDB4MWYzNjYsIDB4MWYzN2EsIDB4MWYzOWEsIDB4MWYzYWUsIDB4MWYzYjIsIDB4MWYzYjQsIDB4MWY0MTYsIDB4MWY0MjYsIDB4MWY0MmMsIDB4MWY0M2EsIDB4MWY0NDYsXG4gICAgICAgIDB4MWY0NGMsIDB4MWY0NTgsIDB4MWY0NmUsIDB4MWY0NzIsIDB4MWY0NzQsIDB4MWY0ODYsIDB4MWY0OGMsIDB4MWY0OTgsIDB4MWY0YjAsIDB4MWY0YmUsIDB4MWY0Y2UsIDB4MWY0ZGMsXG4gICAgICAgIDB4MWY0ZTIsIDB4MWY0ZTQsIDB4MWY0ZTgsIDB4MWY0ZjYsIDB4MWY1MDYsIDB4MWY1MGMsIDB4MWY1MTgsIDB4MWY1MzAsIDB4MWY1M2UsIDB4MWY1NjAsIDB4MWY1N2MsIDB4MWY1OGUsXG4gICAgICAgIDB4MWY1OWMsIDB4MWY1YjgsIDB4MWY1YzIsIDB4MWY1YzQsIDB4MWY1YzgsIDB4MWY1ZDAsIDB4MWY1ZGUsIDB4MWY1ZTYsIDB4MWY1ZWMsIDB4MWY1ZmEsIDB4MWY2MGEsIDB4MWY2MTIsXG4gICAgICAgIDB4MWY2MTQsIDB4MWY2MjIsIDB4MWY2MjQsIDB4MWY2MjgsIDB4MWY2MzYsIDB4MWY2NDIsIDB4MWY2NDQsIDB4MWY2NDgsIDB4MWY2NTAsIDB4MWY2NWUsIDB4MWY2NjYsIDB4MWY2N2EsXG4gICAgICAgIDB4MWY2ODIsIDB4MWY2ODQsIDB4MWY2ODgsIDB4MWY2OTAsIDB4MWY2OWUsIDB4MWY2YTAsIDB4MWY2YmMsIDB4MWY2Y2MsIDB4MWY2ZjIsIDB4MWY2ZjQsIDB4MWY3MWEsIDB4MWY3MmUsXG4gICAgICAgIDB4MWY3MzIsIDB4MWY3MzQsIDB4MWY3NGUsIDB4MWY3NWMsIDB4MWY3NjIsIDB4MWY3NjQsIDB4MWY3NjgsIDB4MWY3NzYsIDB4MWY3OTYsIDB4MWY3YTYsIDB4MWY3YWMsIDB4MWY3YmEsXG4gICAgICAgIDB4MWY3ZDIsIDB4MWY3ZDQsIDB4MWY4OWEsIDB4MWY4YWUsIDB4MWY4YjIsIDB4MWY4YjQsIDB4MWY4ZDYsIDB4MWY4ZWEsIDB4MWY5MWEsIDB4MWY5MmUsIDB4MWY5MzIsIDB4MWY5MzQsXG4gICAgICAgIDB4MWY5NGUsIDB4MWY5NWMsIDB4MWY5NjIsIDB4MWY5NjQsIDB4MWY5NjgsIDB4MWY5NzYsIDB4MWY5OTYsIDB4MWY5YTYsIDB4MWY5YWMsIDB4MWY5YmEsIDB4MWY5Y2EsIDB4MWY5ZDIsXG4gICAgICAgIDB4MWY5ZDQsIDB4MWZhMWEsIDB4MWZhMmUsIDB4MWZhMzIsIDB4MWZhMzQsIDB4MWZhNGUsIDB4MWZhNWMsIDB4MWZhNjIsIDB4MWZhNjQsIDB4MWZhNjgsIDB4MWZhNzYsIDB4MWZhOGUsXG4gICAgICAgIDB4MWZhOWMsIDB4MWZhYjgsIDB4MWZhYzIsIDB4MWZhYzQsIDB4MWZhYzgsIDB4MWZhZDAsIDB4MWZhZGUsIDB4MWZhZTYsIDB4MWZhZWMsIDB4MWZiMTYsIDB4MWZiMjYsIDB4MWZiMmMsXG4gICAgICAgIDB4MWZiM2EsIDB4MWZiNDYsIDB4MWZiNGMsIDB4MWZiNTgsIDB4MWZiNmUsIDB4MWZiNzIsIDB4MWZiNzQsIDB4MWZiOGEsIDB4MWZiOTIsIDB4MWZiOTQsIDB4MWZiYTIsIDB4MWZiYTQsXG4gICAgICAgIDB4MWZiYTgsIDB4MWZiYjYsIDB4MWZiZGFcbiAgICBdKTtcbiAgICAvKipcbiAgICAgKiBUaGlzIHRhYmxlIGNvbnRhaW5zIHRvIGNvZGV3b3JkcyBmb3IgYWxsIHN5bWJvbHMuXG4gICAgICovXG4gICAgUERGNDE3Q29tbW9uLkNPREVXT1JEX1RBQkxFID0gSW50MzJBcnJheS5mcm9tKFtcbiAgICAgICAgMjYyNywgMTgxOSwgMjYyMiwgMjYyMSwgMTgxMywgMTgxMiwgMjcyOSwgMjcyNCwgMjcyMywgMjc3OSwgMjc3NCwgMjc3MywgOTAyLCA4OTYsIDkwOCwgODY4LCA4NjUsIDg2MSwgODU5LCAyNTExLFxuICAgICAgICA4NzMsIDg3MSwgMTc4MCwgODM1LCAyNDkzLCA4MjUsIDI0OTEsIDg0MiwgODM3LCA4NDQsIDE3NjQsIDE3NjIsIDgxMSwgODEwLCA4MDksIDI0ODMsIDgwNywgMjQ4MiwgODA2LCAyNDgwLCA4MTUsXG4gICAgICAgIDgxNCwgODEzLCA4MTIsIDI0ODQsIDgxNywgODE2LCAxNzQ1LCAxNzQ0LCAxNzQyLCAxNzQ2LCAyNjU1LCAyNjM3LCAyNjM1LCAyNjI2LCAyNjI1LCAyNjIzLCAyNjI4LCAxODIwLCAyNzUyLFxuICAgICAgICAyNzM5LCAyNzM3LCAyNzI4LCAyNzI3LCAyNzI1LCAyNzMwLCAyNzg1LCAyNzgzLCAyNzc4LCAyNzc3LCAyNzc1LCAyNzgwLCA3ODcsIDc4MSwgNzQ3LCA3MzksIDczNiwgMjQxMywgNzU0LCA3NTIsXG4gICAgICAgIDE3MTksIDY5MiwgNjg5LCA2ODEsIDIzNzEsIDY3OCwgMjM2OSwgNzAwLCA2OTcsIDY5NCwgNzAzLCAxNjg4LCAxNjg2LCA2NDIsIDYzOCwgMjM0MywgNjMxLCAyMzQxLCA2MjcsIDIzMzgsIDY1MSxcbiAgICAgICAgNjQ2LCA2NDMsIDIzNDUsIDY1NCwgNjUyLCAxNjUyLCAxNjUwLCAxNjQ3LCAxNjU0LCA2MDEsIDU5OSwgMjMyMiwgNTk2LCAyMzIxLCA1OTQsIDIzMTksIDIzMTcsIDYxMSwgNjEwLCA2MDgsIDYwNixcbiAgICAgICAgMjMyNCwgNjAzLCAyMzIzLCA2MTUsIDYxNCwgNjEyLCAxNjE3LCAxNjE2LCAxNjE0LCAxNjEyLCA2MTYsIDE2MTksIDE2MTgsIDI1NzUsIDI1MzgsIDI1MzYsIDkwNSwgOTAxLCA4OTgsIDkwOSxcbiAgICAgICAgMjUwOSwgMjUwNywgMjUwNCwgODcwLCA4NjcsIDg2NCwgODYwLCAyNTEyLCA4NzUsIDg3MiwgMTc4MSwgMjQ5MCwgMjQ4OSwgMjQ4NywgMjQ4NSwgMTc0OCwgODM2LCA4MzQsIDgzMiwgODMwLFxuICAgICAgICAyNDk0LCA4MjcsIDI0OTIsIDg0MywgODQxLCA4MzksIDg0NSwgMTc2NSwgMTc2MywgMjcwMSwgMjY3NiwgMjY3NCwgMjY1MywgMjY0OCwgMjY1NiwgMjYzNCwgMjYzMywgMjYzMSwgMjYyOSxcbiAgICAgICAgMTgyMSwgMjYzOCwgMjYzNiwgMjc3MCwgMjc2MywgMjc2MSwgMjc1MCwgMjc0NSwgMjc1MywgMjczNiwgMjczNSwgMjczMywgMjczMSwgMTg0OCwgMjc0MCwgMjczOCwgMjc4NiwgMjc4NCwgNTkxLFxuICAgICAgICA1ODgsIDU3NiwgNTY5LCA1NjYsIDIyOTYsIDE1OTAsIDUzNywgNTM0LCA1MjYsIDIyNzYsIDUyMiwgMjI3NCwgNTQ1LCA1NDIsIDUzOSwgNTQ4LCAxNTcyLCAxNTcwLCA0ODEsIDIyNDUsIDQ2NixcbiAgICAgICAgMjI0MiwgNDYyLCAyMjM5LCA0OTIsIDQ4NSwgNDgyLCAyMjQ5LCA0OTYsIDQ5NCwgMTUzNCwgMTUzMSwgMTUyOCwgMTUzOCwgNDEzLCAyMTk2LCA0MDYsIDIxOTEsIDIxODgsIDQyNSwgNDE5LFxuICAgICAgICAyMjAyLCA0MTUsIDIxOTksIDQzMiwgNDMwLCA0MjcsIDE0NzIsIDE0NjcsIDE0NjQsIDQzMywgMTQ3NiwgMTQ3NCwgMzY4LCAzNjcsIDIxNjAsIDM2NSwgMjE1OSwgMzYyLCAyMTU3LCAyMTU1LFxuICAgICAgICAyMTUyLCAzNzgsIDM3NywgMzc1LCAyMTY2LCAzNzIsIDIxNjUsIDM2OSwgMjE2MiwgMzgzLCAzODEsIDM3OSwgMjE2OCwgMTQxOSwgMTQxOCwgMTQxNiwgMTQxNCwgMzg1LCAxNDExLCAzODQsXG4gICAgICAgIDE0MjMsIDE0MjIsIDE0MjAsIDE0MjQsIDI0NjEsIDgwMiwgMjQ0MSwgMjQzOSwgNzkwLCA3ODYsIDc4MywgNzk0LCAyNDA5LCAyNDA2LCAyNDAzLCA3NTAsIDc0MiwgNzM4LCAyNDE0LCA3NTYsXG4gICAgICAgIDc1MywgMTcyMCwgMjM2NywgMjM2NSwgMjM2MiwgMjM1OSwgMTY2MywgNjkzLCA2OTEsIDY4NCwgMjM3MywgNjgwLCAyMzcwLCA3MDIsIDY5OSwgNjk2LCA3MDQsIDE2OTAsIDE2ODcsIDIzMzcsXG4gICAgICAgIDIzMzYsIDIzMzQsIDIzMzIsIDE2MjQsIDIzMjksIDE2MjIsIDY0MCwgNjM3LCAyMzQ0LCA2MzQsIDIzNDIsIDYzMCwgMjM0MCwgNjUwLCA2NDgsIDY0NSwgMjM0NiwgNjU1LCA2NTMsIDE2NTMsXG4gICAgICAgIDE2NTEsIDE2NDksIDE2NTUsIDI2MTIsIDI1OTcsIDI1OTUsIDI1NzEsIDI1NjgsIDI1NjUsIDI1NzYsIDI1MzQsIDI1MjksIDI1MjYsIDE3ODcsIDI1NDAsIDI1MzcsIDkwNywgOTA0LCA5MDAsXG4gICAgICAgIDkxMCwgMjUwMywgMjUwMiwgMjUwMCwgMjQ5OCwgMTc2OCwgMjQ5NSwgMTc2NywgMjUxMCwgMjUwOCwgMjUwNiwgODY5LCA4NjYsIDg2MywgMjUxMywgODc2LCA4NzQsIDE3ODIsIDI3MjAsIDI3MTMsXG4gICAgICAgIDI3MTEsIDI2OTcsIDI2OTQsIDI2OTEsIDI3MDIsIDI2NzIsIDI2NzAsIDI2NjQsIDE4MjgsIDI2NzgsIDI2NzUsIDI2NDcsIDI2NDYsIDI2NDQsIDI2NDIsIDE4MjMsIDI2MzksIDE4MjIsIDI2NTQsXG4gICAgICAgIDI2NTIsIDI2NTAsIDI2NTcsIDI3NzEsIDE4NTUsIDI3NjUsIDI3NjIsIDE4NTAsIDE4NDksIDI3NTEsIDI3NDksIDI3NDcsIDI3NTQsIDM1MywgMjE0OCwgMzQ0LCAzNDIsIDMzNiwgMjE0MixcbiAgICAgICAgMzMyLCAyMTQwLCAzNDUsIDEzNzUsIDEzNzMsIDMwNiwgMjEzMCwgMjk5LCAyMTI4LCAyOTUsIDIxMjUsIDMxOSwgMzE0LCAzMTEsIDIxMzIsIDEzNTQsIDEzNTIsIDEzNDksIDEzNTYsIDI2MixcbiAgICAgICAgMjU3LCAyMTAxLCAyNTMsIDIwOTYsIDIwOTMsIDI3NCwgMjczLCAyNjcsIDIxMDcsIDI2MywgMjEwNCwgMjgwLCAyNzgsIDI3NSwgMTMxNiwgMTMxMSwgMTMwOCwgMTMyMCwgMTMxOCwgMjA1MixcbiAgICAgICAgMjAyLCAyMDUwLCAyMDQ0LCAyMDQwLCAyMTksIDIwNjMsIDIxMiwgMjA2MCwgMjA4LCAyMDU1LCAyMjQsIDIyMSwgMjA2NiwgMTI2MCwgMTI1OCwgMTI1MiwgMjMxLCAxMjQ4LCAyMjksIDEyNjYsXG4gICAgICAgIDEyNjQsIDEyNjEsIDEyNjgsIDE1NSwgMTk5OCwgMTUzLCAxOTk2LCAxOTk0LCAxOTkxLCAxOTg4LCAxNjUsIDE2NCwgMjAwNywgMTYyLCAyMDA2LCAxNTksIDIwMDMsIDIwMDAsIDE3MiwgMTcxLFxuICAgICAgICAxNjksIDIwMTIsIDE2NiwgMjAxMCwgMTE4NiwgMTE4NCwgMTE4MiwgMTE3OSwgMTc1LCAxMTc2LCAxNzMsIDExOTIsIDExOTEsIDExODksIDExODcsIDE3NiwgMTE5NCwgMTE5MywgMjMxMyxcbiAgICAgICAgMjMwNywgMjMwNSwgNTkyLCA1ODksIDIyOTQsIDIyOTIsIDIyODksIDU3OCwgNTcyLCA1NjgsIDIyOTcsIDU4MCwgMTU5MSwgMjI3MiwgMjI2NywgMjI2NCwgMTU0NywgNTM4LCA1MzYsIDUyOSxcbiAgICAgICAgMjI3OCwgNTI1LCAyMjc1LCA1NDcsIDU0NCwgNTQxLCAxNTc0LCAxNTcxLCAyMjM3LCAyMjM1LCAyMjI5LCAxNDkzLCAyMjI1LCAxNDg5LCA0NzgsIDIyNDcsIDQ3MCwgMjI0NCwgNDY1LCAyMjQxLFxuICAgICAgICA0OTMsIDQ4OCwgNDg0LCAyMjUwLCA0OTgsIDQ5NSwgMTUzNiwgMTUzMywgMTUzMCwgMTUzOSwgMjE4NywgMjE4NiwgMjE4NCwgMjE4MiwgMTQzMiwgMjE3OSwgMTQzMCwgMjE3NiwgMTQyNywgNDE0LFxuICAgICAgICA0MTIsIDIxOTcsIDQwOSwgMjE5NSwgNDA1LCAyMTkzLCAyMTkwLCA0MjYsIDQyNCwgNDIxLCAyMjAzLCA0MTgsIDIyMDEsIDQzMSwgNDI5LCAxNDczLCAxNDcxLCAxNDY5LCAxNDY2LCA0MzQsXG4gICAgICAgIDE0NzcsIDE0NzUsIDI0NzgsIDI0NzIsIDI0NzAsIDI0NTksIDI0NTcsIDI0NTQsIDI0NjIsIDgwMywgMjQzNywgMjQzMiwgMjQyOSwgMTcyNiwgMjQ0MywgMjQ0MCwgNzkyLCA3ODksIDc4NSxcbiAgICAgICAgMjQwMSwgMjM5OSwgMjM5MywgMTcwMiwgMjM4OSwgMTY5OSwgMjQxMSwgMjQwOCwgMjQwNSwgNzQ1LCA3NDEsIDI0MTUsIDc1OCwgNzU1LCAxNzIxLCAyMzU4LCAyMzU3LCAyMzU1LCAyMzUzLFxuICAgICAgICAxNjYxLCAyMzUwLCAxNjYwLCAyMzQ3LCAxNjU3LCAyMzY4LCAyMzY2LCAyMzY0LCAyMzYxLCAxNjY2LCA2OTAsIDY4NywgMjM3NCwgNjgzLCAyMzcyLCA3MDEsIDY5OCwgNzA1LCAxNjkxLCAxNjg5LFxuICAgICAgICAyNjE5LCAyNjE3LCAyNjEwLCAyNjA4LCAyNjA1LCAyNjEzLCAyNTkzLCAyNTg4LCAyNTg1LCAxODAzLCAyNTk5LCAyNTk2LCAyNTYzLCAyNTYxLCAyNTU1LCAxNzk3LCAyNTUxLCAxNzk1LCAyNTczLFxuICAgICAgICAyNTcwLCAyNTY3LCAyNTc3LCAyNTI1LCAyNTI0LCAyNTIyLCAyNTIwLCAxNzg2LCAyNTE3LCAxNzg1LCAyNTE0LCAxNzgzLCAyNTM1LCAyNTMzLCAyNTMxLCAyNTI4LCAxNzg4LCAyNTQxLCAyNTM5LFxuICAgICAgICA5MDYsIDkwMywgOTExLCAyNzIxLCAxODQ0LCAyNzE1LCAyNzEyLCAxODM4LCAxODM2LCAyNjk5LCAyNjk2LCAyNjkzLCAyNzAzLCAxODI3LCAxODI2LCAxODI0LCAyNjczLCAyNjcxLCAyNjY5LFxuICAgICAgICAyNjY2LCAxODI5LCAyNjc5LCAyNjc3LCAxODU4LCAxODU3LCAyNzcyLCAxODU0LCAxODUzLCAxODUxLCAxODU2LCAyNzY2LCAyNzY0LCAxNDMsIDE5ODcsIDEzOSwgMTk4NiwgMTM1LCAxMzMsXG4gICAgICAgIDEzMSwgMTk4NCwgMTI4LCAxOTgzLCAxMjUsIDE5ODEsIDEzOCwgMTM3LCAxMzYsIDE5ODUsIDExMzMsIDExMzIsIDExMzAsIDExMiwgMTEwLCAxOTc0LCAxMDcsIDE5NzMsIDEwNCwgMTk3MSxcbiAgICAgICAgMTk2OSwgMTIyLCAxMjEsIDExOSwgMTE3LCAxOTc3LCAxMTQsIDE5NzYsIDEyNCwgMTExNSwgMTExNCwgMTExMiwgMTExMCwgMTExNywgMTExNiwgODQsIDgzLCAxOTUzLCA4MSwgMTk1MiwgNzgsXG4gICAgICAgIDE5NTAsIDE5NDgsIDE5NDUsIDk0LCA5MywgOTEsIDE5NTksIDg4LCAxOTU4LCA4NSwgMTk1NSwgOTksIDk3LCA5NSwgMTk2MSwgMTA4NiwgMTA4NSwgMTA4MywgMTA4MSwgMTA3OCwgMTAwLFxuICAgICAgICAxMDkwLCAxMDg5LCAxMDg3LCAxMDkxLCA0OSwgNDcsIDE5MTcsIDQ0LCAxOTE1LCAxOTEzLCAxOTEwLCAxOTA3LCA1OSwgMTkyNiwgNTYsIDE5MjUsIDUzLCAxOTIyLCAxOTE5LCA2NiwgNjQsXG4gICAgICAgIDE5MzEsIDYxLCAxOTI5LCAxMDQyLCAxMDQwLCAxMDM4LCA3MSwgMTAzNSwgNzAsIDEwMzIsIDY4LCAxMDQ4LCAxMDQ3LCAxMDQ1LCAxMDQzLCAxMDUwLCAxMDQ5LCAxMiwgMTAsIDE4NjksIDE4NjcsXG4gICAgICAgIDE4NjQsIDE4NjEsIDIxLCAxODgwLCAxOSwgMTg3NywgMTg3NCwgMTg3MSwgMjgsIDE4ODgsIDI1LCAxODg2LCAyMiwgMTg4MywgOTgyLCA5ODAsIDk3NywgOTc0LCAzMiwgMzAsIDk5MSwgOTg5LFxuICAgICAgICA5ODcsIDk4NCwgMzQsIDk5NSwgOTk0LCA5OTIsIDIxNTEsIDIxNTAsIDIxNDcsIDIxNDYsIDIxNDQsIDM1NiwgMzU1LCAzNTQsIDIxNDksIDIxMzksIDIxMzgsIDIxMzYsIDIxMzQsIDEzNTksXG4gICAgICAgIDM0MywgMzQxLCAzMzgsIDIxNDMsIDMzNSwgMjE0MSwgMzQ4LCAzNDcsIDM0NiwgMTM3NiwgMTM3NCwgMjEyNCwgMjEyMywgMjEyMSwgMjExOSwgMTMyNiwgMjExNiwgMTMyNCwgMzEwLCAzMDgsXG4gICAgICAgIDMwNSwgMjEzMSwgMzAyLCAyMTI5LCAyOTgsIDIxMjcsIDMyMCwgMzE4LCAzMTYsIDMxMywgMjEzMywgMzIyLCAzMjEsIDEzNTUsIDEzNTMsIDEzNTEsIDEzNTcsIDIwOTIsIDIwOTEsIDIwODksXG4gICAgICAgIDIwODcsIDEyNzYsIDIwODQsIDEyNzQsIDIwODEsIDEyNzEsIDI1OSwgMjEwMiwgMjU2LCAyMTAwLCAyNTIsIDIwOTgsIDIwOTUsIDI3MiwgMjY5LCAyMTA4LCAyNjYsIDIxMDYsIDI4MSwgMjc5LFxuICAgICAgICAyNzcsIDEzMTcsIDEzMTUsIDEzMTMsIDEzMTAsIDI4MiwgMTMyMSwgMTMxOSwgMjAzOSwgMjAzNywgMjAzNSwgMjAzMiwgMTIwMywgMjAyOSwgMTIwMCwgMTE5NywgMjA3LCAyMDUzLCAyMDUsXG4gICAgICAgIDIwNTEsIDIwMSwgMjA0OSwgMjA0NiwgMjA0MywgMjIwLCAyMTgsIDIwNjQsIDIxNSwgMjA2MiwgMjExLCAyMDU5LCAyMjgsIDIyNiwgMjIzLCAyMDY5LCAxMjU5LCAxMjU3LCAxMjU0LCAyMzIsXG4gICAgICAgIDEyNTEsIDIzMCwgMTI2NywgMTI2NSwgMTI2MywgMjMxNiwgMjMxNSwgMjMxMiwgMjMxMSwgMjMwOSwgMjMxNCwgMjMwNCwgMjMwMywgMjMwMSwgMjI5OSwgMTU5MywgMjMwOCwgMjMwNiwgNTkwLFxuICAgICAgICAyMjg4LCAyMjg3LCAyMjg1LCAyMjgzLCAxNTc4LCAyMjgwLCAxNTc3LCAyMjk1LCAyMjkzLCAyMjkxLCA1NzksIDU3NywgNTc0LCA1NzEsIDIyOTgsIDU4MiwgNTgxLCAxNTkyLCAyMjYzLCAyMjYyLFxuICAgICAgICAyMjYwLCAyMjU4LCAxNTQ1LCAyMjU1LCAxNTQ0LCAyMjUyLCAxNTQxLCAyMjczLCAyMjcxLCAyMjY5LCAyMjY2LCAxNTUwLCA1MzUsIDUzMiwgMjI3OSwgNTI4LCAyMjc3LCA1NDYsIDU0MywgNTQ5LFxuICAgICAgICAxNTc1LCAxNTczLCAyMjI0LCAyMjIyLCAyMjIwLCAxNDg2LCAyMjE3LCAxNDg1LCAyMjE0LCAxNDgyLCAxNDc5LCAyMjM4LCAyMjM2LCAyMjM0LCAyMjMxLCAxNDk2LCAyMjI4LCAxNDkyLCA0ODAsXG4gICAgICAgIDQ3NywgMjI0OCwgNDczLCAyMjQ2LCA0NjksIDIyNDMsIDQ5MCwgNDg3LCAyMjUxLCA0OTcsIDE1MzcsIDE1MzUsIDE1MzIsIDI0NzcsIDI0NzYsIDI0NzQsIDI0NzksIDI0NjksIDI0NjgsIDI0NjYsXG4gICAgICAgIDI0NjQsIDE3MzAsIDI0NzMsIDI0NzEsIDI0NTMsIDI0NTIsIDI0NTAsIDI0NDgsIDE3MjksIDI0NDUsIDE3MjgsIDI0NjAsIDI0NTgsIDI0NTYsIDI0NjMsIDgwNSwgODA0LCAyNDI4LCAyNDI3LFxuICAgICAgICAyNDI1LCAyNDIzLCAxNzI1LCAyNDIwLCAxNzI0LCAyNDE3LCAxNzIyLCAyNDM4LCAyNDM2LCAyNDM0LCAyNDMxLCAxNzI3LCAyNDQ0LCAyNDQyLCA3OTMsIDc5MSwgNzg4LCA3OTUsIDIzODgsXG4gICAgICAgIDIzODYsIDIzODQsIDE2OTcsIDIzODEsIDE2OTYsIDIzNzgsIDE2OTQsIDE2OTIsIDI0MDIsIDI0MDAsIDIzOTgsIDIzOTUsIDE3MDMsIDIzOTIsIDE3MDEsIDI0MTIsIDI0MTAsIDI0MDcsIDc1MSxcbiAgICAgICAgNzQ4LCA3NDQsIDI0MTYsIDc1OSwgNzU3LCAxODA3LCAyNjIwLCAyNjE4LCAxODA2LCAxODA1LCAyNjExLCAyNjA5LCAyNjA3LCAyNjE0LCAxODAyLCAxODAxLCAxNzk5LCAyNTk0LCAyNTkyLFxuICAgICAgICAyNTkwLCAyNTg3LCAxODA0LCAyNjAwLCAyNTk4LCAxNzk0LCAxNzkzLCAxNzkxLCAxNzg5LCAyNTY0LCAyNTYyLCAyNTYwLCAyNTU3LCAxNzk4LCAyNTU0LCAxNzk2LCAyNTc0LCAyNTcyLCAyNTY5LFxuICAgICAgICAyNTc4LCAxODQ3LCAxODQ2LCAyNzIyLCAxODQzLCAxODQyLCAxODQwLCAxODQ1LCAyNzE2LCAyNzE0LCAxODM1LCAxODM0LCAxODMyLCAxODMwLCAxODM5LCAxODM3LCAyNzAwLCAyNjk4LCAyNjk1LFxuICAgICAgICAyNzA0LCAxODE3LCAxODExLCAxODEwLCA4OTcsIDg2MiwgMTc3NywgODI5LCA4MjYsIDgzOCwgMTc2MCwgMTc1OCwgODA4LCAyNDgxLCAxNzQxLCAxNzQwLCAxNzM4LCAxNzQzLCAyNjI0LCAxODE4LFxuICAgICAgICAyNzI2LCAyNzc2LCA3ODIsIDc0MCwgNzM3LCAxNzE1LCA2ODYsIDY3OSwgNjk1LCAxNjgyLCAxNjgwLCA2MzksIDYyOCwgMjMzOSwgNjQ3LCA2NDQsIDE2NDUsIDE2NDMsIDE2NDAsIDE2NDgsXG4gICAgICAgIDYwMiwgNjAwLCA1OTcsIDU5NSwgMjMyMCwgNTkzLCAyMzE4LCA2MDksIDYwNywgNjA0LCAxNjExLCAxNjEwLCAxNjA4LCAxNjA2LCA2MTMsIDE2MTUsIDE2MTMsIDIzMjgsIDkyNiwgOTI0LCA4OTIsXG4gICAgICAgIDg4NiwgODk5LCA4NTcsIDg1MCwgMjUwNSwgMTc3OCwgODI0LCA4MjMsIDgyMSwgODE5LCAyNDg4LCA4MTgsIDI0ODYsIDgzMywgODMxLCA4MjgsIDg0MCwgMTc2MSwgMTc1OSwgMjY0OSwgMjYzMixcbiAgICAgICAgMjYzMCwgMjc0NiwgMjczNCwgMjczMiwgMjc4MiwgMjc4MSwgNTcwLCA1NjcsIDE1ODcsIDUzMSwgNTI3LCA1MjMsIDU0MCwgMTU2NiwgMTU2NCwgNDc2LCA0NjcsIDQ2MywgMjI0MCwgNDg2LFxuICAgICAgICA0ODMsIDE1MjQsIDE1MjEsIDE1MTgsIDE1MjksIDQxMSwgNDAzLCAyMTkyLCAzOTksIDIxODksIDQyMywgNDE2LCAxNDYyLCAxNDU3LCAxNDU0LCA0MjgsIDE0NjgsIDE0NjUsIDIyMTAsIDM2NixcbiAgICAgICAgMzYzLCAyMTU4LCAzNjAsIDIxNTYsIDM1NywgMjE1MywgMzc2LCAzNzMsIDM3MCwgMjE2MywgMTQxMCwgMTQwOSwgMTQwNywgMTQwNSwgMzgyLCAxNDAyLCAzODAsIDE0MTcsIDE0MTUsIDE0MTIsXG4gICAgICAgIDE0MjEsIDIxNzUsIDIxNzQsIDc3NywgNzc0LCA3NzEsIDc4NCwgNzMyLCA3MjUsIDcyMiwgMjQwNCwgNzQzLCAxNzE2LCA2NzYsIDY3NCwgNjY4LCAyMzYzLCA2NjUsIDIzNjAsIDY4NSwgMTY4NCxcbiAgICAgICAgMTY4MSwgNjI2LCA2MjQsIDYyMiwgMjMzNSwgNjIwLCAyMzMzLCA2MTcsIDIzMzAsIDY0MSwgNjM1LCA2NDksIDE2NDYsIDE2NDQsIDE2NDIsIDI1NjYsIDkyOCwgOTI1LCAyNTMwLCAyNTI3LFxuICAgICAgICA4OTQsIDg5MSwgODg4LCAyNTAxLCAyNDk5LCAyNDk2LCA4NTgsIDg1NiwgODU0LCA4NTEsIDE3NzksIDI2OTIsIDI2NjgsIDI2NjUsIDI2NDUsIDI2NDMsIDI2NDAsIDI2NTEsIDI3NjgsIDI3NTksXG4gICAgICAgIDI3NTcsIDI3NDQsIDI3NDMsIDI3NDEsIDI3NDgsIDM1MiwgMTM4MiwgMzQwLCAzMzcsIDMzMywgMTM3MSwgMTM2OSwgMzA3LCAzMDAsIDI5NiwgMjEyNiwgMzE1LCAzMTIsIDEzNDcsIDEzNDIsXG4gICAgICAgIDEzNTAsIDI2MSwgMjU4LCAyNTAsIDIwOTcsIDI0NiwgMjA5NCwgMjcxLCAyNjgsIDI2NCwgMTMwNiwgMTMwMSwgMTI5OCwgMjc2LCAxMzEyLCAxMzA5LCAyMTE1LCAyMDMsIDIwNDgsIDE5NSxcbiAgICAgICAgMjA0NSwgMTkxLCAyMDQxLCAyMTMsIDIwOSwgMjA1NiwgMTI0NiwgMTI0NCwgMTIzOCwgMjI1LCAxMjM0LCAyMjIsIDEyNTYsIDEyNTMsIDEyNDksIDEyNjIsIDIwODAsIDIwNzksIDE1NCwgMTk5NyxcbiAgICAgICAgMTUwLCAxOTk1LCAxNDcsIDE5OTIsIDE5ODksIDE2MywgMTYwLCAyMDA0LCAxNTYsIDIwMDEsIDExNzUsIDExNzQsIDExNzIsIDExNzAsIDExNjcsIDE3MCwgMTE2NCwgMTY3LCAxMTg1LCAxMTgzLFxuICAgICAgICAxMTgwLCAxMTc3LCAxNzQsIDExOTAsIDExODgsIDIwMjUsIDIwMjQsIDIwMjIsIDU4NywgNTg2LCA1NjQsIDU1OSwgNTU2LCAyMjkwLCA1NzMsIDE1ODgsIDUyMCwgNTE4LCA1MTIsIDIyNjgsXG4gICAgICAgIDUwOCwgMjI2NSwgNTMwLCAxNTY4LCAxNTY1LCA0NjEsIDQ1NywgMjIzMywgNDUwLCAyMjMwLCA0NDYsIDIyMjYsIDQ3OSwgNDcxLCA0ODksIDE1MjYsIDE1MjMsIDE1MjAsIDM5NywgMzk1LFxuICAgICAgICAyMTg1LCAzOTIsIDIxODMsIDM4OSwgMjE4MCwgMjE3NywgNDEwLCAyMTk0LCA0MDIsIDQyMiwgMTQ2MywgMTQ2MSwgMTQ1OSwgMTQ1NiwgMTQ3MCwgMjQ1NSwgNzk5LCAyNDMzLCAyNDMwLCA3NzksXG4gICAgICAgIDc3NiwgNzczLCAyMzk3LCAyMzk0LCAyMzkwLCA3MzQsIDcyOCwgNzI0LCA3NDYsIDE3MTcsIDIzNTYsIDIzNTQsIDIzNTEsIDIzNDgsIDE2NTgsIDY3NywgNjc1LCA2NzMsIDY3MCwgNjY3LCA2ODgsXG4gICAgICAgIDE2ODUsIDE2ODMsIDI2MDYsIDI1ODksIDI1ODYsIDI1NTksIDI1NTYsIDI1NTIsIDkyNywgMjUyMywgMjUyMSwgMjUxOCwgMjUxNSwgMTc4NCwgMjUzMiwgODk1LCA4OTMsIDg5MCwgMjcxOCxcbiAgICAgICAgMjcwOSwgMjcwNywgMjY4OSwgMjY4NywgMjY4NCwgMjY2MywgMjY2MiwgMjY2MCwgMjY1OCwgMTgyNSwgMjY2NywgMjc2OSwgMTg1MiwgMjc2MCwgMjc1OCwgMTQyLCAxNDEsIDExMzksIDExMzgsXG4gICAgICAgIDEzNCwgMTMyLCAxMjksIDEyNiwgMTk4MiwgMTEyOSwgMTEyOCwgMTEyNiwgMTEzMSwgMTEzLCAxMTEsIDEwOCwgMTA1LCAxOTcyLCAxMDEsIDE5NzAsIDEyMCwgMTE4LCAxMTUsIDExMDksIDExMDgsXG4gICAgICAgIDExMDYsIDExMDQsIDEyMywgMTExMywgMTExMSwgODIsIDc5LCAxOTUxLCA3NSwgMTk0OSwgNzIsIDE5NDYsIDkyLCA4OSwgODYsIDE5NTYsIDEwNzcsIDEwNzYsIDEwNzQsIDEwNzIsIDk4LFxuICAgICAgICAxMDY5LCA5NiwgMTA4NCwgMTA4MiwgMTA3OSwgMTA4OCwgMTk2OCwgMTk2NywgNDgsIDQ1LCAxOTE2LCA0MiwgMTkxNCwgMzksIDE5MTEsIDE5MDgsIDYwLCA1NywgNTQsIDE5MjMsIDUwLCAxOTIwLFxuICAgICAgICAxMDMxLCAxMDMwLCAxMDI4LCAxMDI2LCA2NywgMTAyMywgNjUsIDEwMjAsIDYyLCAxMDQxLCAxMDM5LCAxMDM2LCAxMDMzLCA2OSwgMTA0NiwgMTA0NCwgMTk0NCwgMTk0MywgMTk0MSwgMTEsIDksXG4gICAgICAgIDE4NjgsIDcsIDE4NjUsIDE4NjIsIDE4NTksIDIwLCAxODc4LCAxNiwgMTg3NSwgMTMsIDE4NzIsIDk3MCwgOTY4LCA5NjYsIDk2MywgMjksIDk2MCwgMjYsIDIzLCA5ODMsIDk4MSwgOTc4LCA5NzUsXG4gICAgICAgIDMzLCA5NzEsIDMxLCA5OTAsIDk4OCwgOTg1LCAxOTA2LCAxOTA0LCAxOTAyLCA5OTMsIDM1MSwgMjE0NSwgMTM4MywgMzMxLCAzMzAsIDMyOCwgMzI2LCAyMTM3LCAzMjMsIDIxMzUsIDMzOSxcbiAgICAgICAgMTM3MiwgMTM3MCwgMjk0LCAyOTMsIDI5MSwgMjg5LCAyMTIyLCAyODYsIDIxMjAsIDI4MywgMjExNywgMzA5LCAzMDMsIDMxNywgMTM0OCwgMTM0NiwgMTM0NCwgMjQ1LCAyNDQsIDI0MiwgMjA5MCxcbiAgICAgICAgMjM5LCAyMDg4LCAyMzYsIDIwODUsIDIwODIsIDI2MCwgMjA5OSwgMjQ5LCAyNzAsIDEzMDcsIDEzMDUsIDEzMDMsIDEzMDAsIDEzMTQsIDE4OSwgMjAzOCwgMTg2LCAyMDM2LCAxODMsIDIwMzMsXG4gICAgICAgIDIwMzAsIDIwMjYsIDIwNiwgMTk4LCAyMDQ3LCAxOTQsIDIxNiwgMTI0NywgMTI0NSwgMTI0MywgMTI0MCwgMjI3LCAxMjM3LCAxMjU1LCAyMzEwLCAyMzAyLCAyMzAwLCAyMjg2LCAyMjg0LFxuICAgICAgICAyMjgxLCA1NjUsIDU2MywgNTYxLCA1NTgsIDU3NSwgMTU4OSwgMjI2MSwgMjI1OSwgMjI1NiwgMjI1MywgMTU0MiwgNTIxLCA1MTksIDUxNywgNTE0LCAyMjcwLCA1MTEsIDUzMywgMTU2OSxcbiAgICAgICAgMTU2NywgMjIyMywgMjIyMSwgMjIxOCwgMjIxNSwgMTQ4MywgMjIxMSwgMTQ4MCwgNDU5LCA0NTYsIDQ1MywgMjIzMiwgNDQ5LCA0NzQsIDQ5MSwgMTUyNywgMTUyNSwgMTUyMiwgMjQ3NSwgMjQ2NyxcbiAgICAgICAgMjQ2NSwgMjQ1MSwgMjQ0OSwgMjQ0NiwgODAxLCA4MDAsIDI0MjYsIDI0MjQsIDI0MjEsIDI0MTgsIDE3MjMsIDI0MzUsIDc4MCwgNzc4LCA3NzUsIDIzODcsIDIzODUsIDIzODIsIDIzNzksXG4gICAgICAgIDE2OTUsIDIzNzUsIDE2OTMsIDIzOTYsIDczNSwgNzMzLCA3MzAsIDcyNywgNzQ5LCAxNzE4LCAyNjE2LCAyNjE1LCAyNjA0LCAyNjAzLCAyNjAxLCAyNTg0LCAyNTgzLCAyNTgxLCAyNTc5LFxuICAgICAgICAxODAwLCAyNTkxLCAyNTUwLCAyNTQ5LCAyNTQ3LCAyNTQ1LCAxNzkyLCAyNTQyLCAxNzkwLCAyNTU4LCA5MjksIDI3MTksIDE4NDEsIDI3MTAsIDI3MDgsIDE4MzMsIDE4MzEsIDI2OTAsIDI2ODgsXG4gICAgICAgIDI2ODYsIDE4MTUsIDE4MDksIDE4MDgsIDE3NzQsIDE3NTYsIDE3NTQsIDE3MzcsIDE3MzYsIDE3MzQsIDE3MzksIDE4MTYsIDE3MTEsIDE2NzYsIDE2NzQsIDYzMywgNjI5LCAxNjM4LCAxNjM2LFxuICAgICAgICAxNjMzLCAxNjQxLCA1OTgsIDE2MDUsIDE2MDQsIDE2MDIsIDE2MDAsIDYwNSwgMTYwOSwgMTYwNywgMjMyNywgODg3LCA4NTMsIDE3NzUsIDgyMiwgODIwLCAxNzU3LCAxNzU1LCAxNTg0LCA1MjQsXG4gICAgICAgIDE1NjAsIDE1NTgsIDQ2OCwgNDY0LCAxNTE0LCAxNTExLCAxNTA4LCAxNTE5LCA0MDgsIDQwNCwgNDAwLCAxNDUyLCAxNDQ3LCAxNDQ0LCA0MTcsIDE0NTgsIDE0NTUsIDIyMDgsIDM2NCwgMzYxLFxuICAgICAgICAzNTgsIDIxNTQsIDE0MDEsIDE0MDAsIDEzOTgsIDEzOTYsIDM3NCwgMTM5MywgMzcxLCAxNDA4LCAxNDA2LCAxNDAzLCAxNDEzLCAyMTczLCAyMTcyLCA3NzIsIDcyNiwgNzIzLCAxNzEyLCA2NzIsXG4gICAgICAgIDY2OSwgNjY2LCA2ODIsIDE2NzgsIDE2NzUsIDYyNSwgNjIzLCA2MjEsIDYxOCwgMjMzMSwgNjM2LCA2MzIsIDE2MzksIDE2MzcsIDE2MzUsIDkyMCwgOTE4LCA4ODQsIDg4MCwgODg5LCA4NDksXG4gICAgICAgIDg0OCwgODQ3LCA4NDYsIDI0OTcsIDg1NSwgODUyLCAxNzc2LCAyNjQxLCAyNzQyLCAyNzg3LCAxMzgwLCAzMzQsIDEzNjcsIDEzNjUsIDMwMSwgMjk3LCAxMzQwLCAxMzM4LCAxMzM1LCAxMzQzLFxuICAgICAgICAyNTUsIDI1MSwgMjQ3LCAxMjk2LCAxMjkxLCAxMjg4LCAyNjUsIDEzMDIsIDEyOTksIDIxMTMsIDIwNCwgMTk2LCAxOTIsIDIwNDIsIDEyMzIsIDEyMzAsIDEyMjQsIDIxNCwgMTIyMCwgMjEwLFxuICAgICAgICAxMjQyLCAxMjM5LCAxMjM1LCAxMjUwLCAyMDc3LCAyMDc1LCAxNTEsIDE0OCwgMTk5MywgMTQ0LCAxOTkwLCAxMTYzLCAxMTYyLCAxMTYwLCAxMTU4LCAxMTU1LCAxNjEsIDExNTIsIDE1NyxcbiAgICAgICAgMTE3MywgMTE3MSwgMTE2OCwgMTE2NSwgMTY4LCAxMTgxLCAxMTc4LCAyMDIxLCAyMDIwLCAyMDE4LCAyMDIzLCA1ODUsIDU2MCwgNTU3LCAxNTg1LCA1MTYsIDUwOSwgMTU2MiwgMTU1OSwgNDU4LFxuICAgICAgICA0NDcsIDIyMjcsIDQ3MiwgMTUxNiwgMTUxMywgMTUxMCwgMzk4LCAzOTYsIDM5MywgMzkwLCAyMTgxLCAzODYsIDIxNzgsIDQwNywgMTQ1MywgMTQ1MSwgMTQ0OSwgMTQ0NiwgNDIwLCAxNDYwLFxuICAgICAgICAyMjA5LCA3NjksIDc2NCwgNzIwLCA3MTIsIDIzOTEsIDcyOSwgMTcxMywgNjY0LCA2NjMsIDY2MSwgNjU5LCAyMzUyLCA2NTYsIDIzNDksIDY3MSwgMTY3OSwgMTY3NywgMjU1MywgOTIyLCA5MTksXG4gICAgICAgIDI1MTksIDI1MTYsIDg4NSwgODgzLCA4ODEsIDI2ODUsIDI2NjEsIDI2NTksIDI3NjcsIDI3NTYsIDI3NTUsIDE0MCwgMTEzNywgMTEzNiwgMTMwLCAxMjcsIDExMjUsIDExMjQsIDExMjIsIDExMjcsXG4gICAgICAgIDEwOSwgMTA2LCAxMDIsIDExMDMsIDExMDIsIDExMDAsIDEwOTgsIDExNiwgMTEwNywgMTEwNSwgMTk4MCwgODAsIDc2LCA3MywgMTk0NywgMTA2OCwgMTA2NywgMTA2NSwgMTA2MywgOTAsIDEwNjAsXG4gICAgICAgIDg3LCAxMDc1LCAxMDczLCAxMDcwLCAxMDgwLCAxOTY2LCAxOTY1LCA0NiwgNDMsIDQwLCAxOTEyLCAzNiwgMTkwOSwgMTAxOSwgMTAxOCwgMTAxNiwgMTAxNCwgNTgsIDEwMTEsIDU1LCAxMDA4LFxuICAgICAgICA1MSwgMTAyOSwgMTAyNywgMTAyNCwgMTAyMSwgNjMsIDEwMzcsIDEwMzQsIDE5NDAsIDE5MzksIDE5MzcsIDE5NDIsIDgsIDE4NjYsIDQsIDE4NjMsIDEsIDE4NjAsIDk1NiwgOTU0LCA5NTIsXG4gICAgICAgIDk0OSwgOTQ2LCAxNywgMTQsIDk2OSwgOTY3LCA5NjQsIDk2MSwgMjcsIDk1NywgMjQsIDk3OSwgOTc2LCA5NzIsIDE5MDEsIDE5MDAsIDE4OTgsIDE4OTYsIDk4NiwgMTkwNSwgMTkwMywgMzUwLFxuICAgICAgICAzNDksIDEzODEsIDMyOSwgMzI3LCAzMjQsIDEzNjgsIDEzNjYsIDI5MiwgMjkwLCAyODcsIDI4NCwgMjExOCwgMzA0LCAxMzQxLCAxMzM5LCAxMzM3LCAxMzQ1LCAyNDMsIDI0MCwgMjM3LCAyMDg2LFxuICAgICAgICAyMzMsIDIwODMsIDI1NCwgMTI5NywgMTI5NSwgMTI5MywgMTI5MCwgMTMwNCwgMjExNCwgMTkwLCAxODcsIDE4NCwgMjAzNCwgMTgwLCAyMDMxLCAxNzcsIDIwMjcsIDE5OSwgMTIzMywgMTIzMSxcbiAgICAgICAgMTIyOSwgMTIyNiwgMjE3LCAxMjIzLCAxMjQxLCAyMDc4LCAyMDc2LCA1ODQsIDU1NSwgNTU0LCA1NTIsIDU1MCwgMjI4MiwgNTYyLCAxNTg2LCA1MDcsIDUwNiwgNTA0LCA1MDIsIDIyNTcsIDQ5OSxcbiAgICAgICAgMjI1NCwgNTE1LCAxNTYzLCAxNTYxLCA0NDUsIDQ0MywgNDQxLCAyMjE5LCA0MzgsIDIyMTYsIDQzNSwgMjIxMiwgNDYwLCA0NTQsIDQ3NSwgMTUxNywgMTUxNSwgMTUxMiwgMjQ0NywgNzk4LFxuICAgICAgICA3OTcsIDI0MjIsIDI0MTksIDc3MCwgNzY4LCA3NjYsIDIzODMsIDIzODAsIDIzNzYsIDcyMSwgNzE5LCA3MTcsIDcxNCwgNzMxLCAxNzE0LCAyNjAyLCAyNTgyLCAyNTgwLCAyNTQ4LCAyNTQ2LFxuICAgICAgICAyNTQzLCA5MjMsIDkyMSwgMjcxNywgMjcwNiwgMjcwNSwgMjY4MywgMjY4MiwgMjY4MCwgMTc3MSwgMTc1MiwgMTc1MCwgMTczMywgMTczMiwgMTczMSwgMTczNSwgMTgxNCwgMTcwNywgMTY3MCxcbiAgICAgICAgMTY2OCwgMTYzMSwgMTYyOSwgMTYyNiwgMTYzNCwgMTU5OSwgMTU5OCwgMTU5NiwgMTU5NCwgMTYwMywgMTYwMSwgMjMyNiwgMTc3MiwgMTc1MywgMTc1MSwgMTU4MSwgMTU1NCwgMTU1MiwgMTUwNCxcbiAgICAgICAgMTUwMSwgMTQ5OCwgMTUwOSwgMTQ0MiwgMTQzNywgMTQzNCwgNDAxLCAxNDQ4LCAxNDQ1LCAyMjA2LCAxMzkyLCAxMzkxLCAxMzg5LCAxMzg3LCAxMzg0LCAzNTksIDEzOTksIDEzOTcsIDEzOTQsXG4gICAgICAgIDE0MDQsIDIxNzEsIDIxNzAsIDE3MDgsIDE2NzIsIDE2NjksIDYxOSwgMTYzMiwgMTYzMCwgMTYyOCwgMTc3MywgMTM3OCwgMTM2MywgMTM2MSwgMTMzMywgMTMyOCwgMTMzNiwgMTI4NiwgMTI4MSxcbiAgICAgICAgMTI3OCwgMjQ4LCAxMjkyLCAxMjg5LCAyMTExLCAxMjE4LCAxMjE2LCAxMjEwLCAxOTcsIDEyMDYsIDE5MywgMTIyOCwgMTIyNSwgMTIyMSwgMTIzNiwgMjA3MywgMjA3MSwgMTE1MSwgMTE1MCxcbiAgICAgICAgMTE0OCwgMTE0NiwgMTUyLCAxMTQzLCAxNDksIDExNDAsIDE0NSwgMTE2MSwgMTE1OSwgMTE1NiwgMTE1MywgMTU4LCAxMTY5LCAxMTY2LCAyMDE3LCAyMDE2LCAyMDE0LCAyMDE5LCAxNTgyLFxuICAgICAgICA1MTAsIDE1NTYsIDE1NTMsIDQ1MiwgNDQ4LCAxNTA2LCAxNTAwLCAzOTQsIDM5MSwgMzg3LCAxNDQzLCAxNDQxLCAxNDM5LCAxNDM2LCAxNDUwLCAyMjA3LCA3NjUsIDcxNiwgNzEzLCAxNzA5LFxuICAgICAgICA2NjIsIDY2MCwgNjU3LCAxNjczLCAxNjcxLCA5MTYsIDkxNCwgODc5LCA4NzgsIDg3NywgODgyLCAxMTM1LCAxMTM0LCAxMTIxLCAxMTIwLCAxMTE4LCAxMTIzLCAxMDk3LCAxMDk2LCAxMDk0LFxuICAgICAgICAxMDkyLCAxMDMsIDExMDEsIDEwOTksIDE5NzksIDEwNTksIDEwNTgsIDEwNTYsIDEwNTQsIDc3LCAxMDUxLCA3NCwgMTA2NiwgMTA2NCwgMTA2MSwgMTA3MSwgMTk2NCwgMTk2MywgMTAwNyxcbiAgICAgICAgMTAwNiwgMTAwNCwgMTAwMiwgOTk5LCA0MSwgOTk2LCAzNywgMTAxNywgMTAxNSwgMTAxMiwgMTAwOSwgNTIsIDEwMjUsIDEwMjIsIDE5MzYsIDE5MzUsIDE5MzMsIDE5MzgsIDk0MiwgOTQwLFxuICAgICAgICA5MzgsIDkzNSwgOTMyLCA1LCAyLCA5NTUsIDk1MywgOTUwLCA5NDcsIDE4LCA5NDMsIDE1LCA5NjUsIDk2MiwgOTU4LCAxODk1LCAxODk0LCAxODkyLCAxODkwLCA5NzMsIDE4OTksIDE4OTcsXG4gICAgICAgIDEzNzksIDMyNSwgMTM2NCwgMTM2MiwgMjg4LCAyODUsIDEzMzQsIDEzMzIsIDEzMzAsIDI0MSwgMjM4LCAyMzQsIDEyODcsIDEyODUsIDEyODMsIDEyODAsIDEyOTQsIDIxMTIsIDE4OCwgMTg1LFxuICAgICAgICAxODEsIDE3OCwgMjAyOCwgMTIxOSwgMTIxNywgMTIxNSwgMTIxMiwgMjAwLCAxMjA5LCAxMjI3LCAyMDc0LCAyMDcyLCA1ODMsIDU1MywgNTUxLCAxNTgzLCA1MDUsIDUwMywgNTAwLCA1MTMsXG4gICAgICAgIDE1NTcsIDE1NTUsIDQ0NCwgNDQyLCA0MzksIDQzNiwgMjIxMywgNDU1LCA0NTEsIDE1MDcsIDE1MDUsIDE1MDIsIDc5NiwgNzYzLCA3NjIsIDc2MCwgNzY3LCA3MTEsIDcxMCwgNzA4LCA3MDYsXG4gICAgICAgIDIzNzcsIDcxOCwgNzE1LCAxNzEwLCAyNTQ0LCA5MTcsIDkxNSwgMjY4MSwgMTYyNywgMTU5NywgMTU5NSwgMjMyNSwgMTc2OSwgMTc0OSwgMTc0NywgMTQ5OSwgMTQzOCwgMTQzNSwgMjIwNCxcbiAgICAgICAgMTM5MCwgMTM4OCwgMTM4NSwgMTM5NSwgMjE2OSwgMjE2NywgMTcwNCwgMTY2NSwgMTY2MiwgMTYyNSwgMTYyMywgMTYyMCwgMTc3MCwgMTMyOSwgMTI4MiwgMTI3OSwgMjEwOSwgMTIxNCwgMTIwNyxcbiAgICAgICAgMTIyMiwgMjA2OCwgMjA2NSwgMTE0OSwgMTE0NywgMTE0NCwgMTE0MSwgMTQ2LCAxMTU3LCAxMTU0LCAyMDEzLCAyMDExLCAyMDA4LCAyMDE1LCAxNTc5LCAxNTQ5LCAxNTQ2LCAxNDk1LCAxNDg3LFxuICAgICAgICAxNDMzLCAxNDMxLCAxNDI4LCAxNDI1LCAzODgsIDE0NDAsIDIyMDUsIDE3MDUsIDY1OCwgMTY2NywgMTY2NCwgMTExOSwgMTA5NSwgMTA5MywgMTk3OCwgMTA1NywgMTA1NSwgMTA1MiwgMTA2MixcbiAgICAgICAgMTk2MiwgMTk2MCwgMTAwNSwgMTAwMywgMTAwMCwgOTk3LCAzOCwgMTAxMywgMTAxMCwgMTkzMiwgMTkzMCwgMTkyNywgMTkzNCwgOTQxLCA5MzksIDkzNiwgOTMzLCA2LCA5MzAsIDMsIDk1MSxcbiAgICAgICAgOTQ4LCA5NDQsIDE4ODksIDE4ODcsIDE4ODQsIDE4ODEsIDk1OSwgMTg5MywgMTg5MSwgMzUsIDEzNzcsIDEzNjAsIDEzNTgsIDEzMjcsIDEzMjUsIDEzMjIsIDEzMzEsIDEyNzcsIDEyNzUsXG4gICAgICAgIDEyNzIsIDEyNjksIDIzNSwgMTI4NCwgMjExMCwgMTIwNSwgMTIwNCwgMTIwMSwgMTE5OCwgMTgyLCAxMTk1LCAxNzksIDEyMTMsIDIwNzAsIDIwNjcsIDE1ODAsIDUwMSwgMTU1MSwgMTU0OCxcbiAgICAgICAgNDQwLCA0MzcsIDE0OTcsIDE0OTQsIDE0OTAsIDE1MDMsIDc2MSwgNzA5LCA3MDcsIDE3MDYsIDkxMywgOTEyLCAyMTk4LCAxMzg2LCAyMTY0LCAyMTYxLCAxNjIxLCAxNzY2LCAyMTAzLCAxMjA4LFxuICAgICAgICAyMDU4LCAyMDU0LCAxMTQ1LCAxMTQyLCAyMDA1LCAyMDAyLCAxOTk5LCAyMDA5LCAxNDg4LCAxNDI5LCAxNDI2LCAyMjAwLCAxNjk4LCAxNjU5LCAxNjU2LCAxOTc1LCAxMDUzLCAxOTU3LCAxOTU0LFxuICAgICAgICAxMDAxLCA5OTgsIDE5MjQsIDE5MjEsIDE5MTgsIDE5MjgsIDkzNywgOTM0LCA5MzEsIDE4NzksIDE4NzYsIDE4NzMsIDE4NzAsIDk0NSwgMTg4NSwgMTg4MiwgMTMyMywgMTI3MywgMTI3MCxcbiAgICAgICAgMjEwNSwgMTIwMiwgMTE5OSwgMTE5NiwgMTIxMSwgMjA2MSwgMjA1NywgMTU3NiwgMTU0MywgMTU0MCwgMTQ4NCwgMTQ4MSwgMTQ3OCwgMTQ5MSwgMTcwMFxuICAgIF0pO1xuXG4gICAgLypcbiAgICAqIENvcHlyaWdodCAyMDA3IFpYaW5nIGF1dGhvcnNcbiAgICAqXG4gICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICAgKlxuICAgICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAgICAqXG4gICAgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICAgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICAgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgICAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgICAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICAgICovXG4gICAgLy8gaW1wb3J0IGphdmEudXRpbC5MaXN0O1xuICAgIC8qKlxuICAgICAqIEBhdXRob3IgR3VlbnRoZXIgR3JhdVxuICAgICAqL1xuICAgIC8qcHVibGljIGZpbmFsKi8gY2xhc3MgUERGNDE3RGV0ZWN0b3JSZXN1bHQge1xuICAgICAgICBjb25zdHJ1Y3RvcihiaXRzLCBwb2ludHMpIHtcbiAgICAgICAgICAgIHRoaXMuYml0cyA9IGJpdHM7XG4gICAgICAgICAgICB0aGlzLnBvaW50cyA9IHBvaW50cztcbiAgICAgICAgfVxuICAgICAgICBnZXRCaXRzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYml0cztcbiAgICAgICAgfVxuICAgICAgICBnZXRQb2ludHMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wb2ludHM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKlxuICAgICogQ29weXJpZ2h0IDIwMDkgWlhpbmcgYXV0aG9yc1xuICAgICpcbiAgICAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gICAgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICAgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgICAqXG4gICAgKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICAgICpcbiAgICAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgICAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgICAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICAgICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICAgICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gICAgKi9cbiAgICAvLyBpbXBvcnQgamF2YS51dGlsLkFycmF5TGlzdDtcbiAgICAvLyBpbXBvcnQgamF2YS51dGlsLkFycmF5cztcbiAgICAvLyBpbXBvcnQgamF2YS51dGlsLkxpc3Q7XG4gICAgLy8gaW1wb3J0IGphdmEudXRpbC5NYXA7XG4gICAgLyoqXG4gICAgICogPHA+RW5jYXBzdWxhdGVzIGxvZ2ljIHRoYXQgY2FuIGRldGVjdCBhIFBERjQxNyBDb2RlIGluIGFuIGltYWdlLCBldmVuIGlmIHRoZVxuICAgICAqIFBERjQxNyBDb2RlIGlzIHJvdGF0ZWQgb3Igc2tld2VkLCBvciBwYXJ0aWFsbHkgb2JzY3VyZWQuPC9wPlxuICAgICAqXG4gICAgICogQGF1dGhvciBTSVRBIExhYiAoa2V2aW4ub3N1bGxpdmFuQHNpdGEuYWVybylcbiAgICAgKiBAYXV0aG9yIGRzd2l0a2luQGdvb2dsZS5jb20gKERhbmllbCBTd2l0a2luKVxuICAgICAqIEBhdXRob3IgR3VlbnRoZXIgR3JhdVxuICAgICAqL1xuICAgIC8qcHVibGljKi8gLypmaW5hbCovIGNsYXNzIERldGVjdG9yJDMge1xuICAgICAgICAvKipcbiAgICAgICAgICogPHA+RGV0ZWN0cyBhIFBERjQxNyBDb2RlIGluIGFuIGltYWdlLiBPbmx5IGNoZWNrcyAwIGFuZCAxODAgZGVncmVlIHJvdGF0aW9ucy48L3A+XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBpbWFnZSBiYXJjb2RlIGltYWdlIHRvIGRlY29kZVxuICAgICAgICAgKiBAcGFyYW0gaGludHMgb3B0aW9uYWwgaGludHMgdG8gZGV0ZWN0b3JcbiAgICAgICAgICogQHBhcmFtIG11bHRpcGxlIGlmIHRydWUsIHRoZW4gdGhlIGltYWdlIGlzIHNlYXJjaGVkIGZvciBtdWx0aXBsZSBjb2Rlcy4gSWYgZmFsc2UsIHRoZW4gYXQgbW9zdCBvbmUgY29kZSB3aWxsXG4gICAgICAgICAqIGJlIGZvdW5kIGFuZCByZXR1cm5lZFxuICAgICAgICAgKiBAcmV0dXJuIHtAbGluayBQREY0MTdEZXRlY3RvclJlc3VsdH0gZW5jYXBzdWxhdGluZyByZXN1bHRzIG9mIGRldGVjdGluZyBhIFBERjQxNyBjb2RlXG4gICAgICAgICAqIEB0aHJvd3MgTm90Rm91bmRFeGNlcHRpb24gaWYgbm8gUERGNDE3IENvZGUgY2FuIGJlIGZvdW5kXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgZGV0ZWN0TXVsdGlwbGUoaW1hZ2UsIGhpbnRzLCBtdWx0aXBsZSkge1xuICAgICAgICAgICAgLy8gVE9ETyBkZXRlY3Rpb24gaW1wcm92ZW1lbnQsIHRyeUhhcmRlciBjb3VsZCB0cnkgc2V2ZXJhbCBkaWZmZXJlbnQgbHVtaW5hbmNlIHRocmVzaG9sZHMvYmxhY2twb2ludHMgb3IgZXZlblxuICAgICAgICAgICAgLy8gZGlmZmVyZW50IGJpbmFyaXplcnNcbiAgICAgICAgICAgIC8vIGJvb2xlYW4gdHJ5SGFyZGVyID0gaGludHMgIT0gbnVsbCAmJiBoaW50cy5jb250YWluc0tleShEZWNvZGVIaW50VHlwZS5UUllfSEFSREVSKTtcbiAgICAgICAgICAgIGxldCBiaXRNYXRyaXggPSBpbWFnZS5nZXRCbGFja01hdHJpeCgpO1xuICAgICAgICAgICAgbGV0IGJhcmNvZGVDb29yZGluYXRlcyA9IERldGVjdG9yJDMuZGV0ZWN0KG11bHRpcGxlLCBiaXRNYXRyaXgpO1xuICAgICAgICAgICAgaWYgKCFiYXJjb2RlQ29vcmRpbmF0ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgYml0TWF0cml4ID0gYml0TWF0cml4LmNsb25lKCk7XG4gICAgICAgICAgICAgICAgYml0TWF0cml4LnJvdGF0ZTE4MCgpO1xuICAgICAgICAgICAgICAgIGJhcmNvZGVDb29yZGluYXRlcyA9IERldGVjdG9yJDMuZGV0ZWN0KG11bHRpcGxlLCBiaXRNYXRyaXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQREY0MTdEZXRlY3RvclJlc3VsdChiaXRNYXRyaXgsIGJhcmNvZGVDb29yZGluYXRlcyk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERldGVjdHMgUERGNDE3IGNvZGVzIGluIGFuIGltYWdlLiBPbmx5IGNoZWNrcyAwIGRlZ3JlZSByb3RhdGlvblxuICAgICAgICAgKiBAcGFyYW0gbXVsdGlwbGUgaWYgdHJ1ZSwgdGhlbiB0aGUgaW1hZ2UgaXMgc2VhcmNoZWQgZm9yIG11bHRpcGxlIGNvZGVzLiBJZiBmYWxzZSwgdGhlbiBhdCBtb3N0IG9uZSBjb2RlIHdpbGxcbiAgICAgICAgICogYmUgZm91bmQgYW5kIHJldHVybmVkXG4gICAgICAgICAqIEBwYXJhbSBiaXRNYXRyaXggYml0IG1hdHJpeCB0byBkZXRlY3QgYmFyY29kZXMgaW5cbiAgICAgICAgICogQHJldHVybiBMaXN0IG9mIFJlc3VsdFBvaW50IGFycmF5cyBjb250YWluaW5nIHRoZSBjb29yZGluYXRlcyBvZiBmb3VuZCBiYXJjb2Rlc1xuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGRldGVjdChtdWx0aXBsZSwgYml0TWF0cml4KSB7XG4gICAgICAgICAgICBjb25zdCBiYXJjb2RlQ29vcmRpbmF0ZXMgPSBuZXcgQXJyYXkoKTtcbiAgICAgICAgICAgIGxldCByb3cgPSAwO1xuICAgICAgICAgICAgbGV0IGNvbHVtbiA9IDA7XG4gICAgICAgICAgICBsZXQgZm91bmRCYXJjb2RlSW5Sb3cgPSBmYWxzZTtcbiAgICAgICAgICAgIHdoaWxlIChyb3cgPCBiaXRNYXRyaXguZ2V0SGVpZ2h0KCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2ZXJ0aWNlcyA9IERldGVjdG9yJDMuZmluZFZlcnRpY2VzKGJpdE1hdHJpeCwgcm93LCBjb2x1bW4pO1xuICAgICAgICAgICAgICAgIGlmICh2ZXJ0aWNlc1swXSA9PSBudWxsICYmIHZlcnRpY2VzWzNdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFmb3VuZEJhcmNvZGVJblJvdykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UgZGlkbid0IGZpbmQgYW55IGJhcmNvZGUgc28gdGhhdCdzIHRoZSBlbmQgb2Ygc2VhcmNoaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBkaWRuJ3QgZmluZCBhIGJhcmNvZGUgc3RhcnRpbmcgYXQgdGhlIGdpdmVuIGNvbHVtbiBhbmQgcm93LiBUcnkgYWdhaW4gZnJvbSB0aGUgZmlyc3QgY29sdW1uIGFuZCBzbGlnaHRseVxuICAgICAgICAgICAgICAgICAgICAvLyBiZWxvdyB0aGUgbG93ZXN0IGJhcmNvZGUgd2UgZm91bmQgc28gZmFyLlxuICAgICAgICAgICAgICAgICAgICBmb3VuZEJhcmNvZGVJblJvdyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBjb2x1bW4gPSAwO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGJhcmNvZGVDb29yZGluYXRlIG9mIGJhcmNvZGVDb29yZGluYXRlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJhcmNvZGVDb29yZGluYXRlWzFdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3cgPSBNYXRoLnRydW5jKE1hdGgubWF4KHJvdywgYmFyY29kZUNvb3JkaW5hdGVbMV0uZ2V0WSgpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYmFyY29kZUNvb3JkaW5hdGVbM10gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdyA9IE1hdGgubWF4KHJvdywgTWF0aC50cnVuYyhiYXJjb2RlQ29vcmRpbmF0ZVszXS5nZXRZKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByb3cgKz0gRGV0ZWN0b3IkMy5ST1dfU1RFUDtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvdW5kQmFyY29kZUluUm93ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBiYXJjb2RlQ29vcmRpbmF0ZXMucHVzaCh2ZXJ0aWNlcyk7XG4gICAgICAgICAgICAgICAgaWYgKCFtdWx0aXBsZSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gaWYgd2UgZGlkbid0IGZpbmQgYSByaWdodCByb3cgaW5kaWNhdG9yIGNvbHVtbiwgdGhlbiBjb250aW51ZSB0aGUgc2VhcmNoIGZvciB0aGUgbmV4dCBiYXJjb2RlIGFmdGVyIHRoZVxuICAgICAgICAgICAgICAgIC8vIHN0YXJ0IHBhdHRlcm4gb2YgdGhlIGJhcmNvZGUganVzdCBmb3VuZC5cbiAgICAgICAgICAgICAgICBpZiAodmVydGljZXNbMl0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjb2x1bW4gPSBNYXRoLnRydW5jKHZlcnRpY2VzWzJdLmdldFgoKSk7XG4gICAgICAgICAgICAgICAgICAgIHJvdyA9IE1hdGgudHJ1bmModmVydGljZXNbMl0uZ2V0WSgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbiA9IE1hdGgudHJ1bmModmVydGljZXNbNF0uZ2V0WCgpKTtcbiAgICAgICAgICAgICAgICAgICAgcm93ID0gTWF0aC50cnVuYyh2ZXJ0aWNlc1s0XS5nZXRZKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBiYXJjb2RlQ29vcmRpbmF0ZXM7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIExvY2F0ZSB0aGUgdmVydGljZXMgYW5kIHRoZSBjb2Rld29yZHMgYXJlYSBvZiBhIGJsYWNrIGJsb2IgdXNpbmcgdGhlIFN0YXJ0XG4gICAgICAgICAqIGFuZCBTdG9wIHBhdHRlcm5zIGFzIGxvY2F0b3JzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gbWF0cml4IHRoZSBzY2FubmVkIGJhcmNvZGUgaW1hZ2UuXG4gICAgICAgICAqIEByZXR1cm4gYW4gYXJyYXkgY29udGFpbmluZyB0aGUgdmVydGljZXM6XG4gICAgICAgICAqICAgICAgICAgICB2ZXJ0aWNlc1swXSB4LCB5IHRvcCBsZWZ0IGJhcmNvZGVcbiAgICAgICAgICogICAgICAgICAgIHZlcnRpY2VzWzFdIHgsIHkgYm90dG9tIGxlZnQgYmFyY29kZVxuICAgICAgICAgKiAgICAgICAgICAgdmVydGljZXNbMl0geCwgeSB0b3AgcmlnaHQgYmFyY29kZVxuICAgICAgICAgKiAgICAgICAgICAgdmVydGljZXNbM10geCwgeSBib3R0b20gcmlnaHQgYmFyY29kZVxuICAgICAgICAgKiAgICAgICAgICAgdmVydGljZXNbNF0geCwgeSB0b3AgbGVmdCBjb2Rld29yZCBhcmVhXG4gICAgICAgICAqICAgICAgICAgICB2ZXJ0aWNlc1s1XSB4LCB5IGJvdHRvbSBsZWZ0IGNvZGV3b3JkIGFyZWFcbiAgICAgICAgICogICAgICAgICAgIHZlcnRpY2VzWzZdIHgsIHkgdG9wIHJpZ2h0IGNvZGV3b3JkIGFyZWFcbiAgICAgICAgICogICAgICAgICAgIHZlcnRpY2VzWzddIHgsIHkgYm90dG9tIHJpZ2h0IGNvZGV3b3JkIGFyZWFcbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBmaW5kVmVydGljZXMobWF0cml4LCBzdGFydFJvdywgc3RhcnRDb2x1bW4pIHtcbiAgICAgICAgICAgIGNvbnN0IGhlaWdodCA9IG1hdHJpeC5nZXRIZWlnaHQoKTtcbiAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gbWF0cml4LmdldFdpZHRoKCk7XG4gICAgICAgICAgICAvLyBjb25zdCByZXN1bHQgPSBuZXcgUmVzdWx0UG9pbnRbOF07XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgQXJyYXkoOCk7XG4gICAgICAgICAgICBEZXRlY3RvciQzLmNvcHlUb1Jlc3VsdChyZXN1bHQsIERldGVjdG9yJDMuZmluZFJvd3NXaXRoUGF0dGVybihtYXRyaXgsIGhlaWdodCwgd2lkdGgsIHN0YXJ0Um93LCBzdGFydENvbHVtbiwgRGV0ZWN0b3IkMy5TVEFSVF9QQVRURVJOKSwgRGV0ZWN0b3IkMy5JTkRFWEVTX1NUQVJUX1BBVFRFUk4pO1xuICAgICAgICAgICAgaWYgKHJlc3VsdFs0XSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgc3RhcnRDb2x1bW4gPSBNYXRoLnRydW5jKHJlc3VsdFs0XS5nZXRYKCkpO1xuICAgICAgICAgICAgICAgIHN0YXJ0Um93ID0gTWF0aC50cnVuYyhyZXN1bHRbNF0uZ2V0WSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIERldGVjdG9yJDMuY29weVRvUmVzdWx0KHJlc3VsdCwgRGV0ZWN0b3IkMy5maW5kUm93c1dpdGhQYXR0ZXJuKG1hdHJpeCwgaGVpZ2h0LCB3aWR0aCwgc3RhcnRSb3csIHN0YXJ0Q29sdW1uLCBEZXRlY3RvciQzLlNUT1BfUEFUVEVSTiksIERldGVjdG9yJDMuSU5ERVhFU19TVE9QX1BBVFRFUk4pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgY29weVRvUmVzdWx0KHJlc3VsdCwgdG1wUmVzdWx0LCBkZXN0aW5hdGlvbkluZGV4ZXMpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGVzdGluYXRpb25JbmRleGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2Rlc3RpbmF0aW9uSW5kZXhlc1tpXV0gPSB0bXBSZXN1bHRbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGZpbmRSb3dzV2l0aFBhdHRlcm4obWF0cml4LCBoZWlnaHQsIHdpZHRoLCBzdGFydFJvdywgc3RhcnRDb2x1bW4sIHBhdHRlcm4pIHtcbiAgICAgICAgICAgIC8vIGNvbnN0IHJlc3VsdCA9IG5ldyBSZXN1bHRQb2ludFs0XTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBBcnJheSg0KTtcbiAgICAgICAgICAgIGxldCBmb3VuZCA9IGZhbHNlO1xuICAgICAgICAgICAgY29uc3QgY291bnRlcnMgPSBuZXcgSW50MzJBcnJheShwYXR0ZXJuLmxlbmd0aCk7XG4gICAgICAgICAgICBmb3IgKDsgc3RhcnRSb3cgPCBoZWlnaHQ7IHN0YXJ0Um93ICs9IERldGVjdG9yJDMuUk9XX1NURVApIHtcbiAgICAgICAgICAgICAgICBsZXQgbG9jID0gRGV0ZWN0b3IkMy5maW5kR3VhcmRQYXR0ZXJuKG1hdHJpeCwgc3RhcnRDb2x1bW4sIHN0YXJ0Um93LCB3aWR0aCwgZmFsc2UsIHBhdHRlcm4sIGNvdW50ZXJzKTtcbiAgICAgICAgICAgICAgICBpZiAobG9jICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0YXJ0Um93ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJldmlvdXNSb3dMb2MgPSBEZXRlY3RvciQzLmZpbmRHdWFyZFBhdHRlcm4obWF0cml4LCBzdGFydENvbHVtbiwgLS1zdGFydFJvdywgd2lkdGgsIGZhbHNlLCBwYXR0ZXJuLCBjb3VudGVycyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJldmlvdXNSb3dMb2MgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvYyA9IHByZXZpb3VzUm93TG9jO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRSb3crKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXN1bHRbMF0gPSBuZXcgUmVzdWx0UG9pbnQobG9jWzBdLCBzdGFydFJvdyk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFsxXSA9IG5ldyBSZXN1bHRQb2ludChsb2NbMV0sIHN0YXJ0Um93KTtcbiAgICAgICAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgc3RvcFJvdyA9IHN0YXJ0Um93ICsgMTtcbiAgICAgICAgICAgIC8vIExhc3Qgcm93IG9mIHRoZSBjdXJyZW50IHN5bWJvbCB0aGF0IGNvbnRhaW5zIHBhdHRlcm5cbiAgICAgICAgICAgIGlmIChmb3VuZCkge1xuICAgICAgICAgICAgICAgIGxldCBza2lwcGVkUm93Q291bnQgPSAwO1xuICAgICAgICAgICAgICAgIGxldCBwcmV2aW91c1Jvd0xvYyA9IEludDMyQXJyYXkuZnJvbShbTWF0aC50cnVuYyhyZXN1bHRbMF0uZ2V0WCgpKSwgTWF0aC50cnVuYyhyZXN1bHRbMV0uZ2V0WCgpKV0pO1xuICAgICAgICAgICAgICAgIGZvciAoOyBzdG9wUm93IDwgaGVpZ2h0OyBzdG9wUm93KyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbG9jID0gRGV0ZWN0b3IkMy5maW5kR3VhcmRQYXR0ZXJuKG1hdHJpeCwgcHJldmlvdXNSb3dMb2NbMF0sIHN0b3BSb3csIHdpZHRoLCBmYWxzZSwgcGF0dGVybiwgY291bnRlcnMpO1xuICAgICAgICAgICAgICAgICAgICAvLyBhIGZvdW5kIHBhdHRlcm4gaXMgb25seSBjb25zaWRlcmVkIHRvIGJlbG9uZyB0byB0aGUgc2FtZSBiYXJjb2RlIGlmIHRoZSBzdGFydCBhbmQgZW5kIHBvc2l0aW9uc1xuICAgICAgICAgICAgICAgICAgICAvLyBkb24ndCBkaWZmZXIgdG9vIG11Y2guIFBhdHRlcm4gZHJpZnQgc2hvdWxkIGJlIG5vdCBiaWdnZXIgdGhhbiB0d28gZm9yIGNvbnNlY3V0aXZlIHJvd3MuIFdpdGhcbiAgICAgICAgICAgICAgICAgICAgLy8gYSBoaWdoZXIgbnVtYmVyIG9mIHNraXBwZWQgcm93cyBkcmlmdCBjb3VsZCBiZSBsYXJnZXIuIFRvIGtlZXAgaXQgc2ltcGxlIGZvciBub3csIHdlIGFsbG93IGEgc2xpZ2h0bHlcbiAgICAgICAgICAgICAgICAgICAgLy8gbGFyZ2VyIGRyaWZ0IGFuZCBkb24ndCBjaGVjayBmb3Igc2tpcHBlZCByb3dzLlxuICAgICAgICAgICAgICAgICAgICBpZiAobG9jICE9IG51bGwgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIE1hdGguYWJzKHByZXZpb3VzUm93TG9jWzBdIC0gbG9jWzBdKSA8IERldGVjdG9yJDMuTUFYX1BBVFRFUk5fRFJJRlQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIE1hdGguYWJzKHByZXZpb3VzUm93TG9jWzFdIC0gbG9jWzFdKSA8IERldGVjdG9yJDMuTUFYX1BBVFRFUk5fRFJJRlQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXZpb3VzUm93TG9jID0gbG9jO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2tpcHBlZFJvd0NvdW50ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChza2lwcGVkUm93Q291bnQgPiBEZXRlY3RvciQzLlNLSVBQRURfUk9XX0NPVU5UX01BWCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2tpcHBlZFJvd0NvdW50Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RvcFJvdyAtPSBza2lwcGVkUm93Q291bnQgKyAxO1xuICAgICAgICAgICAgICAgIHJlc3VsdFsyXSA9IG5ldyBSZXN1bHRQb2ludChwcmV2aW91c1Jvd0xvY1swXSwgc3RvcFJvdyk7XG4gICAgICAgICAgICAgICAgcmVzdWx0WzNdID0gbmV3IFJlc3VsdFBvaW50KHByZXZpb3VzUm93TG9jWzFdLCBzdG9wUm93KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdG9wUm93IC0gc3RhcnRSb3cgPCBEZXRlY3RvciQzLkJBUkNPREVfTUlOX0hFSUdIVCkge1xuICAgICAgICAgICAgICAgIEFycmF5cy5maWxsKHJlc3VsdCwgbnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gbWF0cml4IHJvdyBvZiBibGFjay93aGl0ZSB2YWx1ZXMgdG8gc2VhcmNoXG4gICAgICAgICAqIEBwYXJhbSBjb2x1bW4geCBwb3NpdGlvbiB0byBzdGFydCBzZWFyY2hcbiAgICAgICAgICogQHBhcmFtIHJvdyB5IHBvc2l0aW9uIHRvIHN0YXJ0IHNlYXJjaFxuICAgICAgICAgKiBAcGFyYW0gd2lkdGggdGhlIG51bWJlciBvZiBwaXhlbHMgdG8gc2VhcmNoIG9uIHRoaXMgcm93XG4gICAgICAgICAqIEBwYXJhbSBwYXR0ZXJuIHBhdHRlcm4gb2YgY291bnRzIG9mIG51bWJlciBvZiBibGFjayBhbmQgd2hpdGUgcGl4ZWxzIHRoYXQgYXJlXG4gICAgICAgICAqICAgICAgICAgICAgICAgICBiZWluZyBzZWFyY2hlZCBmb3IgYXMgYSBwYXR0ZXJuXG4gICAgICAgICAqIEBwYXJhbSBjb3VudGVycyBhcnJheSBvZiBjb3VudGVycywgYXMgbG9uZyBhcyBwYXR0ZXJuLCB0byByZS11c2VcbiAgICAgICAgICogQHJldHVybiBzdGFydC9lbmQgaG9yaXpvbnRhbCBvZmZzZXQgb2YgZ3VhcmQgcGF0dGVybiwgYXMgYW4gYXJyYXkgb2YgdHdvIGludHMuXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgZmluZEd1YXJkUGF0dGVybihtYXRyaXgsIGNvbHVtbiwgcm93LCB3aWR0aCwgd2hpdGVGaXJzdCwgcGF0dGVybiwgY291bnRlcnMpIHtcbiAgICAgICAgICAgIEFycmF5cy5maWxsV2l0aGluKGNvdW50ZXJzLCAwLCBjb3VudGVycy5sZW5ndGgsIDApO1xuICAgICAgICAgICAgbGV0IHBhdHRlcm5TdGFydCA9IGNvbHVtbjtcbiAgICAgICAgICAgIGxldCBwaXhlbERyaWZ0ID0gMDtcbiAgICAgICAgICAgIC8vIGlmIHRoZXJlIGFyZSBibGFjayBwaXhlbHMgbGVmdCBvZiB0aGUgY3VycmVudCBwaXhlbCBzaGlmdCB0byB0aGUgbGVmdCwgYnV0IG9ubHkgZm9yIE1BWF9QSVhFTF9EUklGVCBwaXhlbHNcbiAgICAgICAgICAgIHdoaWxlIChtYXRyaXguZ2V0KHBhdHRlcm5TdGFydCwgcm93KSAmJiBwYXR0ZXJuU3RhcnQgPiAwICYmIHBpeGVsRHJpZnQrKyA8IERldGVjdG9yJDMuTUFYX1BJWEVMX0RSSUZUKSB7XG4gICAgICAgICAgICAgICAgcGF0dGVyblN0YXJ0LS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgeCA9IHBhdHRlcm5TdGFydDtcbiAgICAgICAgICAgIGxldCBjb3VudGVyUG9zaXRpb24gPSAwO1xuICAgICAgICAgICAgbGV0IHBhdHRlcm5MZW5ndGggPSBwYXR0ZXJuLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAobGV0IGlzV2hpdGUgPSB3aGl0ZUZpcnN0OyB4IDwgd2lkdGg7IHgrKykge1xuICAgICAgICAgICAgICAgIGxldCBwaXhlbCA9IG1hdHJpeC5nZXQoeCwgcm93KTtcbiAgICAgICAgICAgICAgICBpZiAocGl4ZWwgIT09IGlzV2hpdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY291bnRlcnNbY291bnRlclBvc2l0aW9uXSsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvdW50ZXJQb3NpdGlvbiA9PT0gcGF0dGVybkxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChEZXRlY3RvciQzLnBhdHRlcm5NYXRjaFZhcmlhbmNlKGNvdW50ZXJzLCBwYXR0ZXJuLCBEZXRlY3RvciQzLk1BWF9JTkRJVklEVUFMX1ZBUklBTkNFKSA8IERldGVjdG9yJDMuTUFYX0FWR19WQVJJQU5DRSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgSW50MzJBcnJheShbcGF0dGVyblN0YXJ0LCB4XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuU3RhcnQgKz0gY291bnRlcnNbMF0gKyBjb3VudGVyc1sxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIFN5c3RlbS5hcnJheWNvcHkoY291bnRlcnMsIDIsIGNvdW50ZXJzLCAwLCBjb3VudGVyUG9zaXRpb24gLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJzW2NvdW50ZXJQb3NpdGlvbiAtIDFdID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJzW2NvdW50ZXJQb3NpdGlvbl0gPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlclBvc2l0aW9uLS07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyUG9zaXRpb24rKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb3VudGVyc1tjb3VudGVyUG9zaXRpb25dID0gMTtcbiAgICAgICAgICAgICAgICAgICAgaXNXaGl0ZSA9ICFpc1doaXRlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb3VudGVyUG9zaXRpb24gPT09IHBhdHRlcm5MZW5ndGggLSAxICYmXG4gICAgICAgICAgICAgICAgRGV0ZWN0b3IkMy5wYXR0ZXJuTWF0Y2hWYXJpYW5jZShjb3VudGVycywgcGF0dGVybiwgRGV0ZWN0b3IkMy5NQVhfSU5ESVZJRFVBTF9WQVJJQU5DRSkgPCBEZXRlY3RvciQzLk1BWF9BVkdfVkFSSUFOQ0UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEludDMyQXJyYXkoW3BhdHRlcm5TdGFydCwgeCAtIDFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXRlcm1pbmVzIGhvdyBjbG9zZWx5IGEgc2V0IG9mIG9ic2VydmVkIGNvdW50cyBvZiBydW5zIG9mIGJsYWNrL3doaXRlXG4gICAgICAgICAqIHZhbHVlcyBtYXRjaGVzIGEgZ2l2ZW4gdGFyZ2V0IHBhdHRlcm4uIFRoaXMgaXMgcmVwb3J0ZWQgYXMgdGhlIHJhdGlvIG9mXG4gICAgICAgICAqIHRoZSB0b3RhbCB2YXJpYW5jZSBmcm9tIHRoZSBleHBlY3RlZCBwYXR0ZXJuIHByb3BvcnRpb25zIGFjcm9zcyBhbGxcbiAgICAgICAgICogcGF0dGVybiBlbGVtZW50cywgdG8gdGhlIGxlbmd0aCBvZiB0aGUgcGF0dGVybi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGNvdW50ZXJzIG9ic2VydmVkIGNvdW50ZXJzXG4gICAgICAgICAqIEBwYXJhbSBwYXR0ZXJuIGV4cGVjdGVkIHBhdHRlcm5cbiAgICAgICAgICogQHBhcmFtIG1heEluZGl2aWR1YWxWYXJpYW5jZSBUaGUgbW9zdCBhbnkgY291bnRlciBjYW4gZGlmZmVyIGJlZm9yZSB3ZSBnaXZlIHVwXG4gICAgICAgICAqIEByZXR1cm4gcmF0aW8gb2YgdG90YWwgdmFyaWFuY2UgYmV0d2VlbiBjb3VudGVycyBhbmQgcGF0dGVybiBjb21wYXJlZCB0byB0b3RhbCBwYXR0ZXJuIHNpemVcbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBwYXR0ZXJuTWF0Y2hWYXJpYW5jZShjb3VudGVycywgcGF0dGVybiwgbWF4SW5kaXZpZHVhbFZhcmlhbmNlKSB7XG4gICAgICAgICAgICBsZXQgbnVtQ291bnRlcnMgPSBjb3VudGVycy5sZW5ndGg7XG4gICAgICAgICAgICBsZXQgdG90YWwgPSAwO1xuICAgICAgICAgICAgbGV0IHBhdHRlcm5MZW5ndGggPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1Db3VudGVyczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdG90YWwgKz0gY291bnRlcnNbaV07XG4gICAgICAgICAgICAgICAgcGF0dGVybkxlbmd0aCArPSBwYXR0ZXJuW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRvdGFsIDwgcGF0dGVybkxlbmd0aCkge1xuICAgICAgICAgICAgICAgIC8vIElmIHdlIGRvbid0IGV2ZW4gaGF2ZSBvbmUgcGl4ZWwgcGVyIHVuaXQgb2YgYmFyIHdpZHRoLCBhc3N1bWUgdGhpc1xuICAgICAgICAgICAgICAgIC8vIGlzIHRvbyBzbWFsbCB0byByZWxpYWJseSBtYXRjaCwgc28gZmFpbDpcbiAgICAgICAgICAgICAgICByZXR1cm4gLypGbG9hdC5QT1NJVElWRV9JTkZJTklUWSovIEluZmluaXR5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gV2UncmUgZ29pbmcgdG8gZmFrZSBmbG9hdGluZy1wb2ludCBtYXRoIGluIGludGVnZXJzLiBXZSBqdXN0IG5lZWQgdG8gdXNlIG1vcmUgYml0cy5cbiAgICAgICAgICAgIC8vIFNjYWxlIHVwIHBhdHRlcm5MZW5ndGggc28gdGhhdCBpbnRlcm1lZGlhdGUgdmFsdWVzIGJlbG93IGxpa2Ugc2NhbGVkQ291bnRlciB3aWxsIGhhdmVcbiAgICAgICAgICAgIC8vIG1vcmUgXCJzaWduaWZpY2FudCBkaWdpdHNcIi5cbiAgICAgICAgICAgIGxldCB1bml0QmFyV2lkdGggPSB0b3RhbCAvIHBhdHRlcm5MZW5ndGg7XG4gICAgICAgICAgICBtYXhJbmRpdmlkdWFsVmFyaWFuY2UgKj0gdW5pdEJhcldpZHRoO1xuICAgICAgICAgICAgbGV0IHRvdGFsVmFyaWFuY2UgPSAwLjA7XG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IG51bUNvdW50ZXJzOyB4KyspIHtcbiAgICAgICAgICAgICAgICBsZXQgY291bnRlciA9IGNvdW50ZXJzW3hdO1xuICAgICAgICAgICAgICAgIGxldCBzY2FsZWRQYXR0ZXJuID0gcGF0dGVyblt4XSAqIHVuaXRCYXJXaWR0aDtcbiAgICAgICAgICAgICAgICBsZXQgdmFyaWFuY2UgPSBjb3VudGVyID4gc2NhbGVkUGF0dGVybiA/IGNvdW50ZXIgLSBzY2FsZWRQYXR0ZXJuIDogc2NhbGVkUGF0dGVybiAtIGNvdW50ZXI7XG4gICAgICAgICAgICAgICAgaWYgKHZhcmlhbmNlID4gbWF4SW5kaXZpZHVhbFZhcmlhbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAvKkZsb2F0LlBPU0lUSVZFX0lORklOSVRZKi8gSW5maW5pdHk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRvdGFsVmFyaWFuY2UgKz0gdmFyaWFuY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdG90YWxWYXJpYW5jZSAvIHRvdGFsO1xuICAgICAgICB9XG4gICAgfVxuICAgIERldGVjdG9yJDMuSU5ERVhFU19TVEFSVF9QQVRURVJOID0gSW50MzJBcnJheS5mcm9tKFswLCA0LCAxLCA1XSk7XG4gICAgRGV0ZWN0b3IkMy5JTkRFWEVTX1NUT1BfUEFUVEVSTiA9IEludDMyQXJyYXkuZnJvbShbNiwgMiwgNywgM10pO1xuICAgIERldGVjdG9yJDMuTUFYX0FWR19WQVJJQU5DRSA9IDAuNDI7XG4gICAgRGV0ZWN0b3IkMy5NQVhfSU5ESVZJRFVBTF9WQVJJQU5DRSA9IDAuODtcbiAgICAvLyBCIFMgQiBTIEIgUyBCIFMgQmFyL1NwYWNlIHBhdHRlcm5cbiAgICAvLyAxMTExMTExMSAwIDEgMCAxIDAgMSAwMDBcbiAgICBEZXRlY3RvciQzLlNUQVJUX1BBVFRFUk4gPSBJbnQzMkFycmF5LmZyb20oWzgsIDEsIDEsIDEsIDEsIDEsIDEsIDNdKTtcbiAgICAvLyAxMTExMTExIDAgMSAwMDAgMSAwIDEgMDAgMVxuICAgIERldGVjdG9yJDMuU1RPUF9QQVRURVJOID0gSW50MzJBcnJheS5mcm9tKFs3LCAxLCAxLCAzLCAxLCAxLCAxLCAyLCAxXSk7XG4gICAgRGV0ZWN0b3IkMy5NQVhfUElYRUxfRFJJRlQgPSAzO1xuICAgIERldGVjdG9yJDMuTUFYX1BBVFRFUk5fRFJJRlQgPSA1O1xuICAgIC8vIGlmIHdlIHNldCB0aGUgdmFsdWUgdG9vIGxvdywgdGhlbiB3ZSBkb24ndCBkZXRlY3QgdGhlIGNvcnJlY3QgaGVpZ2h0IG9mIHRoZSBiYXIgaWYgdGhlIHN0YXJ0IHBhdHRlcm5zIGFyZSBkYW1hZ2VkLlxuICAgIC8vIGlmIHdlIHNldCB0aGUgdmFsdWUgdG9vIGhpZ2gsIHRoZW4gd2UgbWlnaHQgZGV0ZWN0IHRoZSBzdGFydCBwYXR0ZXJuIGZyb20gYSBuZWlnaGJvciBiYXJjb2RlLlxuICAgIERldGVjdG9yJDMuU0tJUFBFRF9ST1dfQ09VTlRfTUFYID0gMjU7XG4gICAgLy8gQSBQREY0NzEgYmFyY29kZSBzaG91bGQgaGF2ZSBhdCBsZWFzdCAzIHJvd3MsIHdpdGggZWFjaCByb3cgYmVpbmcgPj0gMyB0aW1lcyB0aGUgbW9kdWxlIHdpZHRoLiBUaGVyZWZvcmUgaXQgc2hvdWxkIGJlIGF0IGxlYXN0XG4gICAgLy8gOSBwaXhlbHMgdGFsbC4gVG8gYmUgY29uc2VydmF0aXZlLCB3ZSB1c2UgYWJvdXQgaGFsZiB0aGUgc2l6ZSB0byBlbnN1cmUgd2UgZG9uJ3QgbWlzcyBpdC5cbiAgICBEZXRlY3RvciQzLlJPV19TVEVQID0gNTtcbiAgICBEZXRlY3RvciQzLkJBUkNPREVfTUlOX0hFSUdIVCA9IDEwO1xuXG4gICAgLypcbiAgICAqIENvcHlyaWdodCAyMDEyIFpYaW5nIGF1dGhvcnNcbiAgICAqXG4gICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICAgKlxuICAgICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAgICAqXG4gICAgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICAgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICAgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgICAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgICAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICAgICovXG4gICAgLyoqXG4gICAgICogQGF1dGhvciBTZWFuIE93ZW5cbiAgICAgKiBAc2VlIGNvbS5nb29nbGUuenhpbmcuY29tbW9uLnJlZWRzb2xvbW9uLkdlbmVyaWNHRlBvbHlcbiAgICAgKi9cbiAgICAvKmZpbmFsKi8gY2xhc3MgTW9kdWx1c1BvbHkge1xuICAgICAgICBjb25zdHJ1Y3RvcihmaWVsZCwgY29lZmZpY2llbnRzKSB7XG4gICAgICAgICAgICBpZiAoY29lZmZpY2llbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZmllbGQgPSBmaWVsZDtcbiAgICAgICAgICAgIGxldCBjb2VmZmljaWVudHNMZW5ndGggPSAvKmludCovIGNvZWZmaWNpZW50cy5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoY29lZmZpY2llbnRzTGVuZ3RoID4gMSAmJiBjb2VmZmljaWVudHNbMF0gPT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBMZWFkaW5nIHRlcm0gbXVzdCBiZSBub24temVybyBmb3IgYW55dGhpbmcgZXhjZXB0IHRoZSBjb25zdGFudCBwb2x5bm9taWFsIFwiMFwiXG4gICAgICAgICAgICAgICAgbGV0IGZpcnN0Tm9uWmVybyA9IC8qaW50Ki8gMTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoZmlyc3ROb25aZXJvIDwgY29lZmZpY2llbnRzTGVuZ3RoICYmIGNvZWZmaWNpZW50c1tmaXJzdE5vblplcm9dID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0Tm9uWmVybysrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZmlyc3ROb25aZXJvID09PSBjb2VmZmljaWVudHNMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb2VmZmljaWVudHMgPSBuZXcgSW50MzJBcnJheShbMF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb2VmZmljaWVudHMgPSBuZXcgSW50MzJBcnJheShjb2VmZmljaWVudHNMZW5ndGggLSBmaXJzdE5vblplcm8pO1xuICAgICAgICAgICAgICAgICAgICBTeXN0ZW0uYXJyYXljb3B5KGNvZWZmaWNpZW50cywgZmlyc3ROb25aZXJvLCB0aGlzLmNvZWZmaWNpZW50cywgMCwgdGhpcy5jb2VmZmljaWVudHMubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvZWZmaWNpZW50cyA9IGNvZWZmaWNpZW50cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBnZXRDb2VmZmljaWVudHMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb2VmZmljaWVudHM7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gZGVncmVlIG9mIHRoaXMgcG9seW5vbWlhbFxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0RGVncmVlKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29lZmZpY2llbnRzLmxlbmd0aCAtIDE7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gdHJ1ZSBpZmYgdGhpcyBwb2x5bm9taWFsIGlzIHRoZSBtb25vbWlhbCBcIjBcIlxuICAgICAgICAgKi9cbiAgICAgICAgaXNaZXJvKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29lZmZpY2llbnRzWzBdID09PSAwO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIGNvZWZmaWNpZW50IG9mIHheZGVncmVlIHRlcm0gaW4gdGhpcyBwb2x5bm9taWFsXG4gICAgICAgICAqL1xuICAgICAgICBnZXRDb2VmZmljaWVudChkZWdyZWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvZWZmaWNpZW50c1t0aGlzLmNvZWZmaWNpZW50cy5sZW5ndGggLSAxIC0gZGVncmVlXTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiBldmFsdWF0aW9uIG9mIHRoaXMgcG9seW5vbWlhbCBhdCBhIGdpdmVuIHBvaW50XG4gICAgICAgICAqL1xuICAgICAgICBldmFsdWF0ZUF0KGEpIHtcbiAgICAgICAgICAgIGlmIChhID09PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gSnVzdCByZXR1cm4gdGhlIHheMCBjb2VmZmljaWVudFxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldENvZWZmaWNpZW50KDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGEgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAvLyBKdXN0IHRoZSBzdW0gb2YgdGhlIGNvZWZmaWNpZW50c1xuICAgICAgICAgICAgICAgIGxldCBzdW0gPSAvKmludCovIDA7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgY29lZmZpY2llbnQgLyppbnQqLyBvZiB0aGlzLmNvZWZmaWNpZW50cykge1xuICAgICAgICAgICAgICAgICAgICBzdW0gPSB0aGlzLmZpZWxkLmFkZChzdW0sIGNvZWZmaWNpZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1bTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCByZXN1bHQgPSAvKmludCovIHRoaXMuY29lZmZpY2llbnRzWzBdO1xuICAgICAgICAgICAgbGV0IHNpemUgPSAvKmludCovIHRoaXMuY29lZmZpY2llbnRzLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgLyppbnQqLyA9IDE7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLmZpZWxkLmFkZCh0aGlzLmZpZWxkLm11bHRpcGx5KGEsIHJlc3VsdCksIHRoaXMuY29lZmZpY2llbnRzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgYWRkKG90aGVyKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuZmllbGQuZXF1YWxzKG90aGVyLmZpZWxkKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oJ01vZHVsdXNQb2x5cyBkbyBub3QgaGF2ZSBzYW1lIE1vZHVsdXNHRiBmaWVsZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuaXNaZXJvKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3RoZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3RoZXIuaXNaZXJvKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBzbWFsbGVyQ29lZmZpY2llbnRzID0gdGhpcy5jb2VmZmljaWVudHM7XG4gICAgICAgICAgICBsZXQgbGFyZ2VyQ29lZmZpY2llbnRzID0gb3RoZXIuY29lZmZpY2llbnRzO1xuICAgICAgICAgICAgaWYgKHNtYWxsZXJDb2VmZmljaWVudHMubGVuZ3RoID4gbGFyZ2VyQ29lZmZpY2llbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGxldCB0ZW1wID0gc21hbGxlckNvZWZmaWNpZW50cztcbiAgICAgICAgICAgICAgICBzbWFsbGVyQ29lZmZpY2llbnRzID0gbGFyZ2VyQ29lZmZpY2llbnRzO1xuICAgICAgICAgICAgICAgIGxhcmdlckNvZWZmaWNpZW50cyA9IHRlbXA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgc3VtRGlmZiA9IG5ldyBJbnQzMkFycmF5KGxhcmdlckNvZWZmaWNpZW50cy5sZW5ndGgpO1xuICAgICAgICAgICAgbGV0IGxlbmd0aERpZmYgPSAvKmludCovIGxhcmdlckNvZWZmaWNpZW50cy5sZW5ndGggLSBzbWFsbGVyQ29lZmZpY2llbnRzLmxlbmd0aDtcbiAgICAgICAgICAgIC8vIENvcHkgaGlnaC1vcmRlciB0ZXJtcyBvbmx5IGZvdW5kIGluIGhpZ2hlci1kZWdyZWUgcG9seW5vbWlhbCdzIGNvZWZmaWNpZW50c1xuICAgICAgICAgICAgU3lzdGVtLmFycmF5Y29weShsYXJnZXJDb2VmZmljaWVudHMsIDAsIHN1bURpZmYsIDAsIGxlbmd0aERpZmYpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSAvKmludCovID0gbGVuZ3RoRGlmZjsgaSA8IGxhcmdlckNvZWZmaWNpZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHN1bURpZmZbaV0gPSB0aGlzLmZpZWxkLmFkZChzbWFsbGVyQ29lZmZpY2llbnRzW2kgLSBsZW5ndGhEaWZmXSwgbGFyZ2VyQ29lZmZpY2llbnRzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgTW9kdWx1c1BvbHkodGhpcy5maWVsZCwgc3VtRGlmZik7XG4gICAgICAgIH1cbiAgICAgICAgc3VidHJhY3Qob3RoZXIpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5maWVsZC5lcXVhbHMob3RoZXIuZmllbGQpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignTW9kdWx1c1BvbHlzIGRvIG5vdCBoYXZlIHNhbWUgTW9kdWx1c0dGIGZpZWxkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3RoZXIuaXNaZXJvKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZChvdGhlci5uZWdhdGl2ZSgpKTtcbiAgICAgICAgfVxuICAgICAgICBtdWx0aXBseShvdGhlcikge1xuICAgICAgICAgICAgaWYgKG90aGVyIGluc3RhbmNlb2YgTW9kdWx1c1BvbHkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5tdWx0aXBseU90aGVyKG90aGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLm11bHRpcGx5U2NhbGFyKG90aGVyKTtcbiAgICAgICAgfVxuICAgICAgICBtdWx0aXBseU90aGVyKG90aGVyKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuZmllbGQuZXF1YWxzKG90aGVyLmZpZWxkKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oJ01vZHVsdXNQb2x5cyBkbyBub3QgaGF2ZSBzYW1lIE1vZHVsdXNHRiBmaWVsZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuaXNaZXJvKCkgfHwgb3RoZXIuaXNaZXJvKCkpIHtcbiAgICAgICAgICAgICAgICAvLyByZXR1cm4gdGhpcy5maWVsZC5nZXRaZXJvKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBNb2R1bHVzUG9seSh0aGlzLmZpZWxkLCBuZXcgSW50MzJBcnJheShbMF0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBhQ29lZmZpY2llbnRzID0gdGhpcy5jb2VmZmljaWVudHM7XG4gICAgICAgICAgICBsZXQgYUxlbmd0aCA9IC8qaW50Ki8gYUNvZWZmaWNpZW50cy5sZW5ndGg7XG4gICAgICAgICAgICBsZXQgYkNvZWZmaWNpZW50cyA9IG90aGVyLmNvZWZmaWNpZW50cztcbiAgICAgICAgICAgIGxldCBiTGVuZ3RoID0gLyppbnQqLyBiQ29lZmZpY2llbnRzLmxlbmd0aDtcbiAgICAgICAgICAgIGxldCBwcm9kdWN0ID0gbmV3IEludDMyQXJyYXkoYUxlbmd0aCArIGJMZW5ndGggLSAxKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgLyppbnQqLyA9IDA7IGkgPCBhTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgYUNvZWZmID0gLyppbnQqLyBhQ29lZmZpY2llbnRzW2ldO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogLyppbnQqLyA9IDA7IGogPCBiTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvZHVjdFtpICsgal0gPSB0aGlzLmZpZWxkLmFkZChwcm9kdWN0W2kgKyBqXSwgdGhpcy5maWVsZC5tdWx0aXBseShhQ29lZmYsIGJDb2VmZmljaWVudHNbal0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IE1vZHVsdXNQb2x5KHRoaXMuZmllbGQsIHByb2R1Y3QpO1xuICAgICAgICB9XG4gICAgICAgIG5lZ2F0aXZlKCkge1xuICAgICAgICAgICAgbGV0IHNpemUgPSAvKmludCovIHRoaXMuY29lZmZpY2llbnRzLmxlbmd0aDtcbiAgICAgICAgICAgIGxldCBuZWdhdGl2ZUNvZWZmaWNpZW50cyA9IG5ldyBJbnQzMkFycmF5KHNpemUpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSAvKmludCovID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgICAgICAgICAgICAgIG5lZ2F0aXZlQ29lZmZpY2llbnRzW2ldID0gdGhpcy5maWVsZC5zdWJ0cmFjdCgwLCB0aGlzLmNvZWZmaWNpZW50c1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IE1vZHVsdXNQb2x5KHRoaXMuZmllbGQsIG5lZ2F0aXZlQ29lZmZpY2llbnRzKTtcbiAgICAgICAgfVxuICAgICAgICBtdWx0aXBseVNjYWxhcihzY2FsYXIpIHtcbiAgICAgICAgICAgIGlmIChzY2FsYXIgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IE1vZHVsdXNQb2x5KHRoaXMuZmllbGQsIG5ldyBJbnQzMkFycmF5KFswXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNjYWxhciA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHNpemUgPSAvKmludCovIHRoaXMuY29lZmZpY2llbnRzLmxlbmd0aDtcbiAgICAgICAgICAgIGxldCBwcm9kdWN0ID0gbmV3IEludDMyQXJyYXkoc2l6ZSk7XG4gICAgICAgICAgICBmb3IgKGxldCBpIC8qaW50Ki8gPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcHJvZHVjdFtpXSA9IHRoaXMuZmllbGQubXVsdGlwbHkodGhpcy5jb2VmZmljaWVudHNbaV0sIHNjYWxhcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IE1vZHVsdXNQb2x5KHRoaXMuZmllbGQsIHByb2R1Y3QpO1xuICAgICAgICB9XG4gICAgICAgIG11bHRpcGx5QnlNb25vbWlhbChkZWdyZWUsIGNvZWZmaWNpZW50KSB7XG4gICAgICAgICAgICBpZiAoZGVncmVlIDwgMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb2VmZmljaWVudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTW9kdWx1c1BvbHkodGhpcy5maWVsZCwgbmV3IEludDMyQXJyYXkoWzBdKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgc2l6ZSA9IC8qaW50Ki8gdGhpcy5jb2VmZmljaWVudHMubGVuZ3RoO1xuICAgICAgICAgICAgbGV0IHByb2R1Y3QgPSBuZXcgSW50MzJBcnJheShzaXplICsgZGVncmVlKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgLyppbnQqLyA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgICAgICAgICAgICBwcm9kdWN0W2ldID0gdGhpcy5maWVsZC5tdWx0aXBseSh0aGlzLmNvZWZmaWNpZW50c1tpXSwgY29lZmZpY2llbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBNb2R1bHVzUG9seSh0aGlzLmZpZWxkLCBwcm9kdWN0KTtcbiAgICAgICAgfVxuICAgICAgICAvKlxuICAgICAgICBNb2R1bHVzUG9seVtdIGRpdmlkZShvdGhlcjogTW9kdWx1c1BvbHkpIHtcbiAgICAgICAgICBpZiAoIWZpZWxkLmVxdWFscyhvdGhlci5maWVsZCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oXCJNb2R1bHVzUG9seXMgZG8gbm90IGhhdmUgc2FtZSBNb2R1bHVzR0YgZmllbGRcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvdGhlci5pc1plcm8oKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbihcIkRpdmlkZSBieSAwXCIpO1xuICAgICAgICAgIH1cbiAgICAgIFxuICAgICAgICAgIGxldCBxdW90aWVudDogTW9kdWx1c1BvbHkgPSBmaWVsZC5nZXRaZXJvKCk7XG4gICAgICAgICAgbGV0IHJlbWFpbmRlcjogTW9kdWx1c1BvbHkgPSB0aGlzO1xuICAgICAgXG4gICAgICAgICAgbGV0IGRlbm9taW5hdG9yTGVhZGluZ1Rlcm06IC8qaW50LyBudW1iZXIgPSBvdGhlci5nZXRDb2VmZmljaWVudChvdGhlci5nZXREZWdyZWUoKSk7XG4gICAgICAgICAgbGV0IGludmVyc2VEZW5vbWluYXRvckxlYWRpbmdUZXJtOiAvKmludC8gbnVtYmVyID0gZmllbGQuaW52ZXJzZShkZW5vbWluYXRvckxlYWRpbmdUZXJtKTtcbiAgICAgIFxuICAgICAgICAgIHdoaWxlIChyZW1haW5kZXIuZ2V0RGVncmVlKCkgPj0gb3RoZXIuZ2V0RGVncmVlKCkgJiYgIXJlbWFpbmRlci5pc1plcm8oKSkge1xuICAgICAgICAgICAgbGV0IGRlZ3JlZURpZmZlcmVuY2U6IC8qaW50LyBudW1iZXIgPSByZW1haW5kZXIuZ2V0RGVncmVlKCkgLSBvdGhlci5nZXREZWdyZWUoKTtcbiAgICAgICAgICAgIGxldCBzY2FsZTogLyppbnQvIG51bWJlciA9IGZpZWxkLm11bHRpcGx5KHJlbWFpbmRlci5nZXRDb2VmZmljaWVudChyZW1haW5kZXIuZ2V0RGVncmVlKCkpLCBpbnZlcnNlRGVub21pbmF0b3JMZWFkaW5nVGVybSk7XG4gICAgICAgICAgICBsZXQgdGVybTogTW9kdWx1c1BvbHkgPSBvdGhlci5tdWx0aXBseUJ5TW9ub21pYWwoZGVncmVlRGlmZmVyZW5jZSwgc2NhbGUpO1xuICAgICAgICAgICAgbGV0IGl0ZXJhdGlvblF1b3RpZW50OiBNb2R1bHVzUG9seSA9IGZpZWxkLmJ1aWxkTW9ub21pYWwoZGVncmVlRGlmZmVyZW5jZSwgc2NhbGUpO1xuICAgICAgICAgICAgcXVvdGllbnQgPSBxdW90aWVudC5hZGQoaXRlcmF0aW9uUXVvdGllbnQpO1xuICAgICAgICAgICAgcmVtYWluZGVyID0gcmVtYWluZGVyLnN1YnRyYWN0KHRlcm0pO1xuICAgICAgICAgIH1cbiAgICAgIFxuICAgICAgICAgIHJldHVybiBuZXcgTW9kdWx1c1BvbHlbXSB7IHF1b3RpZW50LCByZW1haW5kZXIgfTtcbiAgICAgICAgfVxuICAgICAgICAqL1xuICAgICAgICAvLyBAT3ZlcnJpZGVcbiAgICAgICAgdG9TdHJpbmcoKSB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gbmV3IFN0cmluZ0J1aWxkZXIoIC8qOCAqIHRoaXMuZ2V0RGVncmVlKCkqLyk7IC8vIGR5bmFtaWMgc3RyaW5nIHNpemUgaW4gSlNcbiAgICAgICAgICAgIGZvciAobGV0IGRlZ3JlZSAvKmludCovID0gdGhpcy5nZXREZWdyZWUoKTsgZGVncmVlID49IDA7IGRlZ3JlZS0tKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNvZWZmaWNpZW50ID0gLyppbnQqLyB0aGlzLmdldENvZWZmaWNpZW50KGRlZ3JlZSk7XG4gICAgICAgICAgICAgICAgaWYgKGNvZWZmaWNpZW50ICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2VmZmljaWVudCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoJyAtICcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29lZmZpY2llbnQgPSAtY29lZmZpY2llbnQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCgpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoJyArICcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZWdyZWUgPT09IDAgfHwgY29lZmZpY2llbnQgIT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoY29lZmZpY2llbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZWdyZWUgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZWdyZWUgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKCd4Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKCd4XicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoZGVncmVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNsYXNzIE1vZHVsdXNCYXNlIHtcbiAgICAgICAgYWRkKGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiAoYSArIGIpICUgdGhpcy5tb2R1bHVzO1xuICAgICAgICB9XG4gICAgICAgIHN1YnRyYWN0KGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5tb2R1bHVzICsgYSAtIGIpICUgdGhpcy5tb2R1bHVzO1xuICAgICAgICB9XG4gICAgICAgIGV4cChhKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5leHBUYWJsZVthXTtcbiAgICAgICAgfVxuICAgICAgICBsb2coYSkge1xuICAgICAgICAgICAgaWYgKGEgPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2dUYWJsZVthXTtcbiAgICAgICAgfVxuICAgICAgICBpbnZlcnNlKGEpIHtcbiAgICAgICAgICAgIGlmIChhID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyaXRobWV0aWNFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmV4cFRhYmxlW3RoaXMubW9kdWx1cyAtIHRoaXMubG9nVGFibGVbYV0gLSAxXTtcbiAgICAgICAgfVxuICAgICAgICBtdWx0aXBseShhLCBiKSB7XG4gICAgICAgICAgICBpZiAoYSA9PT0gMCB8fCBiID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5leHBUYWJsZVsodGhpcy5sb2dUYWJsZVthXSArIHRoaXMubG9nVGFibGVbYl0pICUgKHRoaXMubW9kdWx1cyAtIDEpXTtcbiAgICAgICAgfVxuICAgICAgICBnZXRTaXplKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubW9kdWx1cztcbiAgICAgICAgfVxuICAgICAgICBlcXVhbHMobykge1xuICAgICAgICAgICAgcmV0dXJuIG8gPT09IHRoaXM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKlxuICAgICAqIENvcHlyaWdodCAyMDEyIFpYaW5nIGF1dGhvcnNcbiAgICAgKlxuICAgICAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gICAgICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgICAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgICAqXG4gICAgICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAgICAgKlxuICAgICAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgICAgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICAgICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gICAgICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICAgICAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIDxwPkEgZmllbGQgYmFzZWQgb24gcG93ZXJzIG9mIGEgZ2VuZXJhdG9yIGludGVnZXIsIG1vZHVsbyBzb21lIG1vZHVsdXMuPC9wPlxuICAgICAqXG4gICAgICogQGF1dGhvciBTZWFuIE93ZW5cbiAgICAgKiBAc2VlIGNvbS5nb29nbGUuenhpbmcuY29tbW9uLnJlZWRzb2xvbW9uLkdlbmVyaWNHRlxuICAgICAqL1xuICAgIC8qcHVibGljIGZpbmFsKi8gY2xhc3MgTW9kdWx1c0dGIGV4dGVuZHMgTW9kdWx1c0Jhc2Uge1xuICAgICAgICAvLyBwcml2YXRlIC8qZmluYWwqLyBtb2R1bHVzOiAvKmludCovIG51bWJlcjtcbiAgICAgICAgY29uc3RydWN0b3IobW9kdWx1cywgZ2VuZXJhdG9yKSB7XG4gICAgICAgICAgICBzdXBlcigpO1xuICAgICAgICAgICAgdGhpcy5tb2R1bHVzID0gbW9kdWx1cztcbiAgICAgICAgICAgIHRoaXMuZXhwVGFibGUgPSBuZXcgSW50MzJBcnJheShtb2R1bHVzKTtcbiAgICAgICAgICAgIHRoaXMubG9nVGFibGUgPSBuZXcgSW50MzJBcnJheShtb2R1bHVzKTtcbiAgICAgICAgICAgIGxldCB4ID0gLyppbnQqLyAxO1xuICAgICAgICAgICAgZm9yIChsZXQgaSAvKmludCovID0gMDsgaSA8IG1vZHVsdXM7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuZXhwVGFibGVbaV0gPSB4O1xuICAgICAgICAgICAgICAgIHggPSAoeCAqIGdlbmVyYXRvcikgJSBtb2R1bHVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgaSAvKmludCovID0gMDsgaSA8IG1vZHVsdXMgLSAxOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ1RhYmxlW3RoaXMuZXhwVGFibGVbaV1dID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGxvZ1RhYmxlWzBdID09IDAgYnV0IHRoaXMgc2hvdWxkIG5ldmVyIGJlIHVzZWRcbiAgICAgICAgICAgIHRoaXMuemVybyA9IG5ldyBNb2R1bHVzUG9seSh0aGlzLCBuZXcgSW50MzJBcnJheShbMF0pKTtcbiAgICAgICAgICAgIHRoaXMub25lID0gbmV3IE1vZHVsdXNQb2x5KHRoaXMsIG5ldyBJbnQzMkFycmF5KFsxXSkpO1xuICAgICAgICB9XG4gICAgICAgIGdldFplcm8oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy56ZXJvO1xuICAgICAgICB9XG4gICAgICAgIGdldE9uZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9uZTtcbiAgICAgICAgfVxuICAgICAgICBidWlsZE1vbm9taWFsKGRlZ3JlZSwgY29lZmZpY2llbnQpIHtcbiAgICAgICAgICAgIGlmIChkZWdyZWUgPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvZWZmaWNpZW50ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuemVybztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBjb2VmZmljaWVudHMgPSBuZXcgSW50MzJBcnJheShkZWdyZWUgKyAxKTtcbiAgICAgICAgICAgIGNvZWZmaWNpZW50c1swXSA9IGNvZWZmaWNpZW50O1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBNb2R1bHVzUG9seSh0aGlzLCBjb2VmZmljaWVudHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIE1vZHVsdXNHRi5QREY0MTdfR0YgPSBuZXcgTW9kdWx1c0dGKFBERjQxN0NvbW1vbi5OVU1CRVJfT0ZfQ09ERVdPUkRTLCAzKTtcblxuICAgIC8qXG4gICAgKiBDb3B5cmlnaHQgMjAxMiBaWGluZyBhdXRob3JzXG4gICAgKlxuICAgICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgICAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgICAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgICpcbiAgICAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gICAgKlxuICAgICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICAgICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gICAgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gICAgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAgICAqL1xuICAgIC8qKlxuICAgICAqIDxwPlBERjQxNyBlcnJvciBjb3JyZWN0aW9uIGltcGxlbWVudGF0aW9uLjwvcD5cbiAgICAgKlxuICAgICAqIDxwPlRoaXMgPGEgaHJlZj1cImh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUmVlZCVFMiU4MCU5M1NvbG9tb25fZXJyb3JfY29ycmVjdGlvbiNFeGFtcGxlXCI+ZXhhbXBsZTwvYT5cbiAgICAgKiBpcyBxdWl0ZSB1c2VmdWwgaW4gdW5kZXJzdGFuZGluZyB0aGUgYWxnb3JpdGhtLjwvcD5cbiAgICAgKlxuICAgICAqIEBhdXRob3IgU2VhbiBPd2VuXG4gICAgICogQHNlZSBjb20uZ29vZ2xlLnp4aW5nLmNvbW1vbi5yZWVkc29sb21vbi5SZWVkU29sb21vbkRlY29kZXJcbiAgICAgKi9cbiAgICAvKnB1YmxpYyBmaW5hbCovIGNsYXNzIEVycm9yQ29ycmVjdGlvbiB7XG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgICAgdGhpcy5maWVsZCA9IE1vZHVsdXNHRi5QREY0MTdfR0Y7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSByZWNlaXZlZCByZWNlaXZlZCBjb2Rld29yZHNcbiAgICAgICAgICogQHBhcmFtIG51bUVDQ29kZXdvcmRzIG51bWJlciBvZiB0aG9zZSBjb2Rld29yZHMgdXNlZCBmb3IgRUNcbiAgICAgICAgICogQHBhcmFtIGVyYXN1cmVzIGxvY2F0aW9uIG9mIGVyYXN1cmVzXG4gICAgICAgICAqIEByZXR1cm4gbnVtYmVyIG9mIGVycm9yc1xuICAgICAgICAgKiBAdGhyb3dzIENoZWNrc3VtRXhjZXB0aW9uIGlmIGVycm9ycyBjYW5ub3QgYmUgY29ycmVjdGVkLCBtYXliZSBiZWNhdXNlIG9mIHRvbyBtYW55IGVycm9yc1xuICAgICAgICAgKi9cbiAgICAgICAgZGVjb2RlKHJlY2VpdmVkLCBudW1FQ0NvZGV3b3JkcywgZXJhc3VyZXMpIHtcbiAgICAgICAgICAgIGxldCBwb2x5ID0gbmV3IE1vZHVsdXNQb2x5KHRoaXMuZmllbGQsIHJlY2VpdmVkKTtcbiAgICAgICAgICAgIGxldCBTID0gbmV3IEludDMyQXJyYXkobnVtRUNDb2Rld29yZHMpO1xuICAgICAgICAgICAgbGV0IGVycm9yID0gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKGxldCBpIC8qaW50Ki8gPSBudW1FQ0NvZGV3b3JkczsgaSA+IDA7IGktLSkge1xuICAgICAgICAgICAgICAgIGxldCBldmFsdWF0aW9uID0gcG9seS5ldmFsdWF0ZUF0KHRoaXMuZmllbGQuZXhwKGkpKTtcbiAgICAgICAgICAgICAgICBTW251bUVDQ29kZXdvcmRzIC0gaV0gPSBldmFsdWF0aW9uO1xuICAgICAgICAgICAgICAgIGlmIChldmFsdWF0aW9uICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQga25vd25FcnJvcnMgPSB0aGlzLmZpZWxkLmdldE9uZSgpO1xuICAgICAgICAgICAgaWYgKGVyYXN1cmVzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGVyYXN1cmUgb2YgZXJhc3VyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGIgPSB0aGlzLmZpZWxkLmV4cChyZWNlaXZlZC5sZW5ndGggLSAxIC0gZXJhc3VyZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFkZCAoMSAtIGJ4KSB0ZXJtOlxuICAgICAgICAgICAgICAgICAgICBsZXQgdGVybSA9IG5ldyBNb2R1bHVzUG9seSh0aGlzLmZpZWxkLCBuZXcgSW50MzJBcnJheShbdGhpcy5maWVsZC5zdWJ0cmFjdCgwLCBiKSwgMV0pKTtcbiAgICAgICAgICAgICAgICAgICAga25vd25FcnJvcnMgPSBrbm93bkVycm9ycy5tdWx0aXBseSh0ZXJtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgc3luZHJvbWUgPSBuZXcgTW9kdWx1c1BvbHkodGhpcy5maWVsZCwgUyk7XG4gICAgICAgICAgICAvLyBzeW5kcm9tZSA9IHN5bmRyb21lLm11bHRpcGx5KGtub3duRXJyb3JzKTtcbiAgICAgICAgICAgIGxldCBzaWdtYU9tZWdhID0gdGhpcy5ydW5FdWNsaWRlYW5BbGdvcml0aG0odGhpcy5maWVsZC5idWlsZE1vbm9taWFsKG51bUVDQ29kZXdvcmRzLCAxKSwgc3luZHJvbWUsIG51bUVDQ29kZXdvcmRzKTtcbiAgICAgICAgICAgIGxldCBzaWdtYSA9IHNpZ21hT21lZ2FbMF07XG4gICAgICAgICAgICBsZXQgb21lZ2EgPSBzaWdtYU9tZWdhWzFdO1xuICAgICAgICAgICAgLy8gc2lnbWEgPSBzaWdtYS5tdWx0aXBseShrbm93bkVycm9ycyk7XG4gICAgICAgICAgICBsZXQgZXJyb3JMb2NhdGlvbnMgPSB0aGlzLmZpbmRFcnJvckxvY2F0aW9ucyhzaWdtYSk7XG4gICAgICAgICAgICBsZXQgZXJyb3JNYWduaXR1ZGVzID0gdGhpcy5maW5kRXJyb3JNYWduaXR1ZGVzKG9tZWdhLCBzaWdtYSwgZXJyb3JMb2NhdGlvbnMpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSAvKmludCovID0gMDsgaSA8IGVycm9yTG9jYXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHBvc2l0aW9uID0gcmVjZWl2ZWQubGVuZ3RoIC0gMSAtIHRoaXMuZmllbGQubG9nKGVycm9yTG9jYXRpb25zW2ldKTtcbiAgICAgICAgICAgICAgICBpZiAocG9zaXRpb24gPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IENoZWNrc3VtRXhjZXB0aW9uLmdldENoZWNrc3VtSW5zdGFuY2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVjZWl2ZWRbcG9zaXRpb25dID0gdGhpcy5maWVsZC5zdWJ0cmFjdChyZWNlaXZlZFtwb3NpdGlvbl0sIGVycm9yTWFnbml0dWRlc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZXJyb3JMb2NhdGlvbnMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gTW9kdWx1c1BvbHlcbiAgICAgICAgICogQHBhcmFtIGFcbiAgICAgICAgICogQHBhcmFtIE1vZHVsdXNQb2x5XG4gICAgICAgICAqIEBwYXJhbSBiXG4gICAgICAgICAqIEBwYXJhbSBpbnRcbiAgICAgICAgICogQHBhcmFtIFJcbiAgICAgICAgICogQHRocm93cyBDaGVja3N1bUV4Y2VwdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgcnVuRXVjbGlkZWFuQWxnb3JpdGhtKGEsIGIsIFIpIHtcbiAgICAgICAgICAgIC8vIEFzc3VtZSBhJ3MgZGVncmVlIGlzID49IGInc1xuICAgICAgICAgICAgaWYgKGEuZ2V0RGVncmVlKCkgPCBiLmdldERlZ3JlZSgpKSB7XG4gICAgICAgICAgICAgICAgbGV0IHRlbXAgPSBhO1xuICAgICAgICAgICAgICAgIGEgPSBiO1xuICAgICAgICAgICAgICAgIGIgPSB0ZW1wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHJMYXN0ID0gYTtcbiAgICAgICAgICAgIGxldCByID0gYjtcbiAgICAgICAgICAgIGxldCB0TGFzdCA9IHRoaXMuZmllbGQuZ2V0WmVybygpO1xuICAgICAgICAgICAgbGV0IHQgPSB0aGlzLmZpZWxkLmdldE9uZSgpO1xuICAgICAgICAgICAgLy8gUnVuIEV1Y2xpZGVhbiBhbGdvcml0aG0gdW50aWwgcidzIGRlZ3JlZSBpcyBsZXNzIHRoYW4gUi8yXG4gICAgICAgICAgICB3aGlsZSAoci5nZXREZWdyZWUoKSA+PSBNYXRoLnJvdW5kKFIgLyAyKSkge1xuICAgICAgICAgICAgICAgIGxldCByTGFzdExhc3QgPSByTGFzdDtcbiAgICAgICAgICAgICAgICBsZXQgdExhc3RMYXN0ID0gdExhc3Q7XG4gICAgICAgICAgICAgICAgckxhc3QgPSByO1xuICAgICAgICAgICAgICAgIHRMYXN0ID0gdDtcbiAgICAgICAgICAgICAgICAvLyBEaXZpZGUgckxhc3RMYXN0IGJ5IHJMYXN0LCB3aXRoIHF1b3RpZW50IGluIHEgYW5kIHJlbWFpbmRlciBpbiByXG4gICAgICAgICAgICAgICAgaWYgKHJMYXN0LmlzWmVybygpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE9vcHMsIEV1Y2xpZGVhbiBhbGdvcml0aG0gYWxyZWFkeSB0ZXJtaW5hdGVkP1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBDaGVja3N1bUV4Y2VwdGlvbi5nZXRDaGVja3N1bUluc3RhbmNlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHIgPSByTGFzdExhc3Q7XG4gICAgICAgICAgICAgICAgbGV0IHEgPSB0aGlzLmZpZWxkLmdldFplcm8oKTtcbiAgICAgICAgICAgICAgICBsZXQgZGVub21pbmF0b3JMZWFkaW5nVGVybSA9IHJMYXN0LmdldENvZWZmaWNpZW50KHJMYXN0LmdldERlZ3JlZSgpKTtcbiAgICAgICAgICAgICAgICBsZXQgZGx0SW52ZXJzZSA9IHRoaXMuZmllbGQuaW52ZXJzZShkZW5vbWluYXRvckxlYWRpbmdUZXJtKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoci5nZXREZWdyZWUoKSA+PSByTGFzdC5nZXREZWdyZWUoKSAmJiAhci5pc1plcm8oKSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZGVncmVlRGlmZiA9IHIuZ2V0RGVncmVlKCkgLSByTGFzdC5nZXREZWdyZWUoKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNjYWxlID0gdGhpcy5maWVsZC5tdWx0aXBseShyLmdldENvZWZmaWNpZW50KHIuZ2V0RGVncmVlKCkpLCBkbHRJbnZlcnNlKTtcbiAgICAgICAgICAgICAgICAgICAgcSA9IHEuYWRkKHRoaXMuZmllbGQuYnVpbGRNb25vbWlhbChkZWdyZWVEaWZmLCBzY2FsZSkpO1xuICAgICAgICAgICAgICAgICAgICByID0gci5zdWJ0cmFjdChyTGFzdC5tdWx0aXBseUJ5TW9ub21pYWwoZGVncmVlRGlmZiwgc2NhbGUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdCA9IHEubXVsdGlwbHkodExhc3QpLnN1YnRyYWN0KHRMYXN0TGFzdCkubmVnYXRpdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBzaWdtYVRpbGRlQXRaZXJvID0gdC5nZXRDb2VmZmljaWVudCgwKTtcbiAgICAgICAgICAgIGlmIChzaWdtYVRpbGRlQXRaZXJvID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgQ2hlY2tzdW1FeGNlcHRpb24uZ2V0Q2hlY2tzdW1JbnN0YW5jZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGludmVyc2UgPSB0aGlzLmZpZWxkLmludmVyc2Uoc2lnbWFUaWxkZUF0WmVybyk7XG4gICAgICAgICAgICBsZXQgc2lnbWEgPSB0Lm11bHRpcGx5KGludmVyc2UpO1xuICAgICAgICAgICAgbGV0IG9tZWdhID0gci5tdWx0aXBseShpbnZlcnNlKTtcbiAgICAgICAgICAgIHJldHVybiBbc2lnbWEsIG9tZWdhXTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGVycm9yTG9jYXRvclxuICAgICAgICAgKiBAdGhyb3dzIENoZWNrc3VtRXhjZXB0aW9uXG4gICAgICAgICAqL1xuICAgICAgICBmaW5kRXJyb3JMb2NhdGlvbnMoZXJyb3JMb2NhdG9yKSB7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIGEgZGlyZWN0IGFwcGxpY2F0aW9uIG9mIENoaWVuJ3Mgc2VhcmNoXG4gICAgICAgICAgICBsZXQgbnVtRXJyb3JzID0gZXJyb3JMb2NhdG9yLmdldERlZ3JlZSgpO1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IG5ldyBJbnQzMkFycmF5KG51bUVycm9ycyk7XG4gICAgICAgICAgICBsZXQgZSA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCBpIC8qaW50Ki8gPSAxOyBpIDwgdGhpcy5maWVsZC5nZXRTaXplKCkgJiYgZSA8IG51bUVycm9yczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yTG9jYXRvci5ldmFsdWF0ZUF0KGkpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtlXSA9IHRoaXMuZmllbGQuaW52ZXJzZShpKTtcbiAgICAgICAgICAgICAgICAgICAgZSsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlICE9PSBudW1FcnJvcnMpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBDaGVja3N1bUV4Y2VwdGlvbi5nZXRDaGVja3N1bUluc3RhbmNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGZpbmRFcnJvck1hZ25pdHVkZXMoZXJyb3JFdmFsdWF0b3IsIGVycm9yTG9jYXRvciwgZXJyb3JMb2NhdGlvbnMpIHtcbiAgICAgICAgICAgIGxldCBlcnJvckxvY2F0b3JEZWdyZWUgPSBlcnJvckxvY2F0b3IuZ2V0RGVncmVlKCk7XG4gICAgICAgICAgICBsZXQgZm9ybWFsRGVyaXZhdGl2ZUNvZWZmaWNpZW50cyA9IG5ldyBJbnQzMkFycmF5KGVycm9yTG9jYXRvckRlZ3JlZSk7XG4gICAgICAgICAgICBmb3IgKGxldCBpIC8qaW50Ki8gPSAxOyBpIDw9IGVycm9yTG9jYXRvckRlZ3JlZTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZm9ybWFsRGVyaXZhdGl2ZUNvZWZmaWNpZW50c1tlcnJvckxvY2F0b3JEZWdyZWUgLSBpXSA9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmllbGQubXVsdGlwbHkoaSwgZXJyb3JMb2NhdG9yLmdldENvZWZmaWNpZW50KGkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBmb3JtYWxEZXJpdmF0aXZlID0gbmV3IE1vZHVsdXNQb2x5KHRoaXMuZmllbGQsIGZvcm1hbERlcml2YXRpdmVDb2VmZmljaWVudHMpO1xuICAgICAgICAgICAgLy8gVGhpcyBpcyBkaXJlY3RseSBhcHBseWluZyBGb3JuZXkncyBGb3JtdWxhXG4gICAgICAgICAgICBsZXQgcyA9IGVycm9yTG9jYXRpb25zLmxlbmd0aDtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBuZXcgSW50MzJBcnJheShzKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgLyppbnQqLyA9IDA7IGkgPCBzOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgeGlJbnZlcnNlID0gdGhpcy5maWVsZC5pbnZlcnNlKGVycm9yTG9jYXRpb25zW2ldKTtcbiAgICAgICAgICAgICAgICBsZXQgbnVtZXJhdG9yID0gdGhpcy5maWVsZC5zdWJ0cmFjdCgwLCBlcnJvckV2YWx1YXRvci5ldmFsdWF0ZUF0KHhpSW52ZXJzZSkpO1xuICAgICAgICAgICAgICAgIGxldCBkZW5vbWluYXRvciA9IHRoaXMuZmllbGQuaW52ZXJzZShmb3JtYWxEZXJpdmF0aXZlLmV2YWx1YXRlQXQoeGlJbnZlcnNlKSk7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2ldID0gdGhpcy5maWVsZC5tdWx0aXBseShudW1lcmF0b3IsIGRlbm9taW5hdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKlxuICAgICogQ29weXJpZ2h0IDIwMTMgWlhpbmcgYXV0aG9yc1xuICAgICpcbiAgICAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gICAgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICAgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgICAqXG4gICAgKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICAgICpcbiAgICAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgICAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgICAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICAgICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICAgICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gICAgKi9cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIEd1ZW50aGVyIEdyYXVcbiAgICAgKi9cbiAgICAvKmZpbmFsKi8gY2xhc3MgQm91bmRpbmdCb3gge1xuICAgICAgICBjb25zdHJ1Y3RvcihpbWFnZSwgdG9wTGVmdCwgYm90dG9tTGVmdCwgdG9wUmlnaHQsIGJvdHRvbVJpZ2h0KSB7XG4gICAgICAgICAgICBpZiAoaW1hZ2UgaW5zdGFuY2VvZiBCb3VuZGluZ0JveCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29uc3RydWN0b3JfMihpbWFnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnN0cnVjdG9yXzEoaW1hZ2UsIHRvcExlZnQsIGJvdHRvbUxlZnQsIHRvcFJpZ2h0LCBib3R0b21SaWdodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBpbWFnZVxuICAgICAgICAgKiBAcGFyYW0gdG9wTGVmdFxuICAgICAgICAgKiBAcGFyYW0gYm90dG9tTGVmdFxuICAgICAgICAgKiBAcGFyYW0gdG9wUmlnaHRcbiAgICAgICAgICogQHBhcmFtIGJvdHRvbVJpZ2h0XG4gICAgICAgICAqXG4gICAgICAgICAqIEB0aHJvd3MgTm90Rm91bmRFeGNlcHRpb25cbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0cnVjdG9yXzEoaW1hZ2UsIHRvcExlZnQsIGJvdHRvbUxlZnQsIHRvcFJpZ2h0LCBib3R0b21SaWdodCkge1xuICAgICAgICAgICAgY29uc3QgbGVmdFVuc3BlY2lmaWVkID0gdG9wTGVmdCA9PSBudWxsIHx8IGJvdHRvbUxlZnQgPT0gbnVsbDtcbiAgICAgICAgICAgIGNvbnN0IHJpZ2h0VW5zcGVjaWZpZWQgPSB0b3BSaWdodCA9PSBudWxsIHx8IGJvdHRvbVJpZ2h0ID09IG51bGw7XG4gICAgICAgICAgICBpZiAobGVmdFVuc3BlY2lmaWVkICYmIHJpZ2h0VW5zcGVjaWZpZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsZWZ0VW5zcGVjaWZpZWQpIHtcbiAgICAgICAgICAgICAgICB0b3BMZWZ0ID0gbmV3IFJlc3VsdFBvaW50KDAsIHRvcFJpZ2h0LmdldFkoKSk7XG4gICAgICAgICAgICAgICAgYm90dG9tTGVmdCA9IG5ldyBSZXN1bHRQb2ludCgwLCBib3R0b21SaWdodC5nZXRZKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocmlnaHRVbnNwZWNpZmllZCkge1xuICAgICAgICAgICAgICAgIHRvcFJpZ2h0ID0gbmV3IFJlc3VsdFBvaW50KGltYWdlLmdldFdpZHRoKCkgLSAxLCB0b3BMZWZ0LmdldFkoKSk7XG4gICAgICAgICAgICAgICAgYm90dG9tUmlnaHQgPSBuZXcgUmVzdWx0UG9pbnQoaW1hZ2UuZ2V0V2lkdGgoKSAtIDEsIGJvdHRvbUxlZnQuZ2V0WSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaW1hZ2UgPSBpbWFnZTtcbiAgICAgICAgICAgIHRoaXMudG9wTGVmdCA9IHRvcExlZnQ7XG4gICAgICAgICAgICB0aGlzLmJvdHRvbUxlZnQgPSBib3R0b21MZWZ0O1xuICAgICAgICAgICAgdGhpcy50b3BSaWdodCA9IHRvcFJpZ2h0O1xuICAgICAgICAgICAgdGhpcy5ib3R0b21SaWdodCA9IGJvdHRvbVJpZ2h0O1xuICAgICAgICAgICAgdGhpcy5taW5YID0gTWF0aC50cnVuYyhNYXRoLm1pbih0b3BMZWZ0LmdldFgoKSwgYm90dG9tTGVmdC5nZXRYKCkpKTtcbiAgICAgICAgICAgIHRoaXMubWF4WCA9IE1hdGgudHJ1bmMoTWF0aC5tYXgodG9wUmlnaHQuZ2V0WCgpLCBib3R0b21SaWdodC5nZXRYKCkpKTtcbiAgICAgICAgICAgIHRoaXMubWluWSA9IE1hdGgudHJ1bmMoTWF0aC5taW4odG9wTGVmdC5nZXRZKCksIHRvcFJpZ2h0LmdldFkoKSkpO1xuICAgICAgICAgICAgdGhpcy5tYXhZID0gTWF0aC50cnVuYyhNYXRoLm1heChib3R0b21MZWZ0LmdldFkoKSwgYm90dG9tUmlnaHQuZ2V0WSgpKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3RydWN0b3JfMihib3VuZGluZ0JveCkge1xuICAgICAgICAgICAgdGhpcy5pbWFnZSA9IGJvdW5kaW5nQm94LmltYWdlO1xuICAgICAgICAgICAgdGhpcy50b3BMZWZ0ID0gYm91bmRpbmdCb3guZ2V0VG9wTGVmdCgpO1xuICAgICAgICAgICAgdGhpcy5ib3R0b21MZWZ0ID0gYm91bmRpbmdCb3guZ2V0Qm90dG9tTGVmdCgpO1xuICAgICAgICAgICAgdGhpcy50b3BSaWdodCA9IGJvdW5kaW5nQm94LmdldFRvcFJpZ2h0KCk7XG4gICAgICAgICAgICB0aGlzLmJvdHRvbVJpZ2h0ID0gYm91bmRpbmdCb3guZ2V0Qm90dG9tUmlnaHQoKTtcbiAgICAgICAgICAgIHRoaXMubWluWCA9IGJvdW5kaW5nQm94LmdldE1pblgoKTtcbiAgICAgICAgICAgIHRoaXMubWF4WCA9IGJvdW5kaW5nQm94LmdldE1heFgoKTtcbiAgICAgICAgICAgIHRoaXMubWluWSA9IGJvdW5kaW5nQm94LmdldE1pblkoKTtcbiAgICAgICAgICAgIHRoaXMubWF4WSA9IGJvdW5kaW5nQm94LmdldE1heFkoKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHRocm93cyBOb3RGb3VuZEV4Y2VwdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIG1lcmdlKGxlZnRCb3gsIHJpZ2h0Qm94KSB7XG4gICAgICAgICAgICBpZiAobGVmdEJveCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJpZ2h0Qm94O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJpZ2h0Qm94ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGVmdEJveDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgQm91bmRpbmdCb3gobGVmdEJveC5pbWFnZSwgbGVmdEJveC50b3BMZWZ0LCBsZWZ0Qm94LmJvdHRvbUxlZnQsIHJpZ2h0Qm94LnRvcFJpZ2h0LCByaWdodEJveC5ib3R0b21SaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0aHJvd3MgTm90Rm91bmRFeGNlcHRpb25cbiAgICAgICAgICovXG4gICAgICAgIGFkZE1pc3NpbmdSb3dzKG1pc3NpbmdTdGFydFJvd3MsIG1pc3NpbmdFbmRSb3dzLCBpc0xlZnQpIHtcbiAgICAgICAgICAgIGxldCBuZXdUb3BMZWZ0ID0gdGhpcy50b3BMZWZ0O1xuICAgICAgICAgICAgbGV0IG5ld0JvdHRvbUxlZnQgPSB0aGlzLmJvdHRvbUxlZnQ7XG4gICAgICAgICAgICBsZXQgbmV3VG9wUmlnaHQgPSB0aGlzLnRvcFJpZ2h0O1xuICAgICAgICAgICAgbGV0IG5ld0JvdHRvbVJpZ2h0ID0gdGhpcy5ib3R0b21SaWdodDtcbiAgICAgICAgICAgIGlmIChtaXNzaW5nU3RhcnRSb3dzID4gMCkge1xuICAgICAgICAgICAgICAgIGxldCB0b3AgPSBpc0xlZnQgPyB0aGlzLnRvcExlZnQgOiB0aGlzLnRvcFJpZ2h0O1xuICAgICAgICAgICAgICAgIGxldCBuZXdNaW5ZID0gTWF0aC50cnVuYyh0b3AuZ2V0WSgpIC0gbWlzc2luZ1N0YXJ0Um93cyk7XG4gICAgICAgICAgICAgICAgaWYgKG5ld01pblkgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld01pblkgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgbmV3VG9wID0gbmV3IFJlc3VsdFBvaW50KHRvcC5nZXRYKCksIG5ld01pblkpO1xuICAgICAgICAgICAgICAgIGlmIChpc0xlZnQpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3VG9wTGVmdCA9IG5ld1RvcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1RvcFJpZ2h0ID0gbmV3VG9wO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtaXNzaW5nRW5kUm93cyA+IDApIHtcbiAgICAgICAgICAgICAgICBsZXQgYm90dG9tID0gaXNMZWZ0ID8gdGhpcy5ib3R0b21MZWZ0IDogdGhpcy5ib3R0b21SaWdodDtcbiAgICAgICAgICAgICAgICBsZXQgbmV3TWF4WSA9IE1hdGgudHJ1bmMoYm90dG9tLmdldFkoKSArIG1pc3NpbmdFbmRSb3dzKTtcbiAgICAgICAgICAgICAgICBpZiAobmV3TWF4WSA+PSB0aGlzLmltYWdlLmdldEhlaWdodCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld01heFkgPSB0aGlzLmltYWdlLmdldEhlaWdodCgpIC0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IG5ld0JvdHRvbSA9IG5ldyBSZXN1bHRQb2ludChib3R0b20uZ2V0WCgpLCBuZXdNYXhZKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNMZWZ0KSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld0JvdHRvbUxlZnQgPSBuZXdCb3R0b207XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBuZXdCb3R0b21SaWdodCA9IG5ld0JvdHRvbTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJvdW5kaW5nQm94KHRoaXMuaW1hZ2UsIG5ld1RvcExlZnQsIG5ld0JvdHRvbUxlZnQsIG5ld1RvcFJpZ2h0LCBuZXdCb3R0b21SaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0TWluWCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1pblg7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0TWF4WCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1heFg7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0TWluWSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1pblk7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0TWF4WSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1heFk7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0VG9wTGVmdCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvcExlZnQ7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0VG9wUmlnaHQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b3BSaWdodDtcbiAgICAgICAgfVxuICAgICAgICBnZXRCb3R0b21MZWZ0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYm90dG9tTGVmdDtcbiAgICAgICAgfVxuICAgICAgICBnZXRCb3R0b21SaWdodCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJvdHRvbVJpZ2h0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBDb3B5cmlnaHQgMjAxMyBaWGluZyBhdXRob3JzXG4gICAgICpcbiAgICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgICAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgICAgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgICAgKlxuICAgICAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gICAgICpcbiAgICAgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICAgICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgICAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICAgICAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgICAgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAgICAgKi9cbiAgICAvLyBwYWNrYWdlIGNvbS5nb29nbGUuenhpbmcucGRmNDE3LmRlY29kZXI7XG4gICAgLyoqXG4gICAgICogQGF1dGhvciBHdWVudGhlciBHcmF1XG4gICAgICovXG4gICAgLypmaW5hbCovIGNsYXNzIEJhcmNvZGVNZXRhZGF0YSB7XG4gICAgICAgIGNvbnN0cnVjdG9yKGNvbHVtbkNvdW50LCByb3dDb3VudFVwcGVyUGFydCwgcm93Q291bnRMb3dlclBhcnQsIGVycm9yQ29ycmVjdGlvbkxldmVsKSB7XG4gICAgICAgICAgICB0aGlzLmNvbHVtbkNvdW50ID0gY29sdW1uQ291bnQ7XG4gICAgICAgICAgICB0aGlzLmVycm9yQ29ycmVjdGlvbkxldmVsID0gZXJyb3JDb3JyZWN0aW9uTGV2ZWw7XG4gICAgICAgICAgICB0aGlzLnJvd0NvdW50VXBwZXJQYXJ0ID0gcm93Q291bnRVcHBlclBhcnQ7XG4gICAgICAgICAgICB0aGlzLnJvd0NvdW50TG93ZXJQYXJ0ID0gcm93Q291bnRMb3dlclBhcnQ7XG4gICAgICAgICAgICB0aGlzLnJvd0NvdW50ID0gcm93Q291bnRVcHBlclBhcnQgKyByb3dDb3VudExvd2VyUGFydDtcbiAgICAgICAgfVxuICAgICAgICBnZXRDb2x1bW5Db3VudCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbHVtbkNvdW50O1xuICAgICAgICB9XG4gICAgICAgIGdldEVycm9yQ29ycmVjdGlvbkxldmVsKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3JDb3JyZWN0aW9uTGV2ZWw7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0Um93Q291bnQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yb3dDb3VudDtcbiAgICAgICAgfVxuICAgICAgICBnZXRSb3dDb3VudFVwcGVyUGFydCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJvd0NvdW50VXBwZXJQYXJ0O1xuICAgICAgICB9XG4gICAgICAgIGdldFJvd0NvdW50TG93ZXJQYXJ0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucm93Q291bnRMb3dlclBhcnQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBKYXZhIEZvcm1hdHRlciBjbGFzcyBwb2x5ZmlsbCB0aGF0IHdvcmtzIGluIHRoZSBKUyB3YXkuXG4gICAgICovXG4gICAgY2xhc3MgRm9ybWF0dGVyIHtcbiAgICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlciA9ICcnO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKlxuICAgICAgICAgKiBAc2VlIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xMzQzOTcxMS80MzY3NjgzXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBzdHJcbiAgICAgICAgICogQHBhcmFtIGFyclxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGZvcm0oc3RyLCBhcnIpIHtcbiAgICAgICAgICAgIGxldCBpID0gLTE7XG4gICAgICAgICAgICBmdW5jdGlvbiBjYWxsYmFjayhleHAsIHAwLCBwMSwgcDIsIHAzLCBwNCkge1xuICAgICAgICAgICAgICAgIGlmIChleHAgPT09ICclJScpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnJSc7XG4gICAgICAgICAgICAgICAgaWYgKGFyclsrK2ldID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgZXhwID0gcDIgPyBwYXJzZUludChwMi5zdWJzdHIoMSkpIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGxldCBiYXNlID0gcDMgPyBwYXJzZUludChwMy5zdWJzdHIoMSkpIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGxldCB2YWw7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChwNCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdzJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IGFycltpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdjJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IGFycltpXVswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdmJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IHBhcnNlRmxvYXQoYXJyW2ldKS50b0ZpeGVkKGV4cCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAncCc6XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSBwYXJzZUZsb2F0KGFycltpXSkudG9QcmVjaXNpb24oZXhwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IHBhcnNlRmxvYXQoYXJyW2ldKS50b0V4cG9uZW50aWFsKGV4cCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAneCc6XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSBwYXJzZUludChhcnJbaV0pLnRvU3RyaW5nKGJhc2UgPyBiYXNlIDogMTYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2QnOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gcGFyc2VGbG9hdChwYXJzZUludChhcnJbaV0sIGJhc2UgPyBiYXNlIDogMTApLnRvUHJlY2lzaW9uKGV4cCkpLnRvRml4ZWQoMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFsID0gdHlwZW9mIHZhbCA9PT0gJ29iamVjdCcgPyBKU09OLnN0cmluZ2lmeSh2YWwpIDogKCt2YWwpLnRvU3RyaW5nKGJhc2UpO1xuICAgICAgICAgICAgICAgIGxldCBzaXplID0gcGFyc2VJbnQocDEpOyAvKiBwYWRkaW5nIHNpemUgKi9cbiAgICAgICAgICAgICAgICBsZXQgY2ggPSBwMSAmJiAocDFbMF0gKyAnJykgPT09ICcwJyA/ICcwJyA6ICcgJzsgLyogaXNudWxsPyAqL1xuICAgICAgICAgICAgICAgIHdoaWxlICh2YWwubGVuZ3RoIDwgc2l6ZSlcbiAgICAgICAgICAgICAgICAgICAgdmFsID0gcDAgIT09IHVuZGVmaW5lZCA/IHZhbCArIGNoIDogY2ggKyB2YWw7IC8qIGlzbWludXM/ICovXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCByZWdleCA9IC8lKC0pPygwP1swLTldKyk/KFsuXVswLTldKyk/KFsjXVswLTldKyk/KFtzY2ZwZXhkJV0pL2c7XG4gICAgICAgICAgICByZXR1cm4gc3RyLnJlcGxhY2UocmVnZXgsIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGFwcGVuZCBUaGUgbmV3IHN0cmluZyB0byBhcHBlbmQuXG4gICAgICAgICAqIEBwYXJhbSBhcmdzIEFyZ3VtZXRzIHZhbHVlcyB0byBiZSBmb3JtYXRlZC5cbiAgICAgICAgICovXG4gICAgICAgIGZvcm1hdChhcHBlbmQsIC4uLmFyZ3MpIHtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyICs9IEZvcm1hdHRlci5mb3JtKGFwcGVuZCwgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIEZvcm1hdHRlciBzdHJpbmcgdmFsdWUuXG4gICAgICAgICAqL1xuICAgICAgICB0b1N0cmluZygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlcjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qXG4gICAgICogQ29weXJpZ2h0IDIwMTMgWlhpbmcgYXV0aG9yc1xuICAgICAqXG4gICAgICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgICAgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICAgICpcbiAgICAgKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICAgICAqXG4gICAgICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICAgICAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgICAgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgICAgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gICAgICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gICAgICovXG4gICAgLyoqXG4gICAgICogQGF1dGhvciBHdWVudGhlciBHcmF1XG4gICAgICovXG4gICAgY2xhc3MgRGV0ZWN0aW9uUmVzdWx0Q29sdW1uIHtcbiAgICAgICAgY29uc3RydWN0b3IoYm91bmRpbmdCb3gpIHtcbiAgICAgICAgICAgIHRoaXMuYm91bmRpbmdCb3ggPSBuZXcgQm91bmRpbmdCb3goYm91bmRpbmdCb3gpO1xuICAgICAgICAgICAgLy8gdGhpcy5jb2Rld29yZHMgPSBuZXcgQ29kZXdvcmRbYm91bmRpbmdCb3guZ2V0TWF4WSgpIC0gYm91bmRpbmdCb3guZ2V0TWluWSgpICsgMV07XG4gICAgICAgICAgICB0aGlzLmNvZGV3b3JkcyA9IG5ldyBBcnJheShib3VuZGluZ0JveC5nZXRNYXhZKCkgLSBib3VuZGluZ0JveC5nZXRNaW5ZKCkgKyAxKTtcbiAgICAgICAgfVxuICAgICAgICAvKmZpbmFsKi8gZ2V0Q29kZXdvcmROZWFyYnkoaW1hZ2VSb3cpIHtcbiAgICAgICAgICAgIGxldCBjb2Rld29yZCA9IHRoaXMuZ2V0Q29kZXdvcmQoaW1hZ2VSb3cpO1xuICAgICAgICAgICAgaWYgKGNvZGV3b3JkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29kZXdvcmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IERldGVjdGlvblJlc3VsdENvbHVtbi5NQVhfTkVBUkJZX0RJU1RBTkNFOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgbmVhckltYWdlUm93ID0gdGhpcy5pbWFnZVJvd1RvQ29kZXdvcmRJbmRleChpbWFnZVJvdykgLSBpO1xuICAgICAgICAgICAgICAgIGlmIChuZWFySW1hZ2VSb3cgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICBjb2Rld29yZCA9IHRoaXMuY29kZXdvcmRzW25lYXJJbWFnZVJvd107XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2Rld29yZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29kZXdvcmQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbmVhckltYWdlUm93ID0gdGhpcy5pbWFnZVJvd1RvQ29kZXdvcmRJbmRleChpbWFnZVJvdykgKyBpO1xuICAgICAgICAgICAgICAgIGlmIChuZWFySW1hZ2VSb3cgPCB0aGlzLmNvZGV3b3Jkcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZXdvcmQgPSB0aGlzLmNvZGV3b3Jkc1tuZWFySW1hZ2VSb3ddO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29kZXdvcmQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvZGV3b3JkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLypmaW5hbCBpbnQqLyBpbWFnZVJvd1RvQ29kZXdvcmRJbmRleChpbWFnZVJvdykge1xuICAgICAgICAgICAgcmV0dXJuIGltYWdlUm93IC0gdGhpcy5ib3VuZGluZ0JveC5nZXRNaW5ZKCk7XG4gICAgICAgIH1cbiAgICAgICAgLypmaW5hbCB2b2lkKi8gc2V0Q29kZXdvcmQoaW1hZ2VSb3csIGNvZGV3b3JkKSB7XG4gICAgICAgICAgICB0aGlzLmNvZGV3b3Jkc1t0aGlzLmltYWdlUm93VG9Db2Rld29yZEluZGV4KGltYWdlUm93KV0gPSBjb2Rld29yZDtcbiAgICAgICAgfVxuICAgICAgICAvKmZpbmFsKi8gZ2V0Q29kZXdvcmQoaW1hZ2VSb3cpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvZGV3b3Jkc1t0aGlzLmltYWdlUm93VG9Db2Rld29yZEluZGV4KGltYWdlUm93KV07XG4gICAgICAgIH1cbiAgICAgICAgLypmaW5hbCovIGdldEJvdW5kaW5nQm94KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYm91bmRpbmdCb3g7XG4gICAgICAgIH1cbiAgICAgICAgLypmaW5hbCovIGdldENvZGV3b3JkcygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvZGV3b3JkcztcbiAgICAgICAgfVxuICAgICAgICAvLyBAT3ZlcnJpZGVcbiAgICAgICAgdG9TdHJpbmcoKSB7XG4gICAgICAgICAgICBjb25zdCBmb3JtYXR0ZXIgPSBuZXcgRm9ybWF0dGVyKCk7XG4gICAgICAgICAgICBsZXQgcm93ID0gMDtcbiAgICAgICAgICAgIGZvciAoY29uc3QgY29kZXdvcmQgb2YgdGhpcy5jb2Rld29yZHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29kZXdvcmQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBmb3JtYXR0ZXIuZm9ybWF0KCclM2Q6ICAgIHwgICAlbicsIHJvdysrKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvcm1hdHRlci5mb3JtYXQoJyUzZDogJTNkfCUzZCVuJywgcm93KyssIGNvZGV3b3JkLmdldFJvd051bWJlcigpLCBjb2Rld29yZC5nZXRWYWx1ZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmb3JtYXR0ZXIudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBEZXRlY3Rpb25SZXN1bHRDb2x1bW4uTUFYX05FQVJCWV9ESVNUQU5DRSA9IDU7XG5cbiAgICAvKlxuICAgICAqIENvcHlyaWdodCAyMDEzIFpYaW5nIGF1dGhvcnNcbiAgICAgKlxuICAgICAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gICAgICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgICAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgICAqXG4gICAgICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAgICAgKlxuICAgICAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgICAgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICAgICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gICAgICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICAgICAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICAgICAqL1xuICAgIC8vIGltcG9ydCBqYXZhLnV0aWwuQXJyYXlMaXN0O1xuICAgIC8vIGltcG9ydCBqYXZhLnV0aWwuQ29sbGVjdGlvbjtcbiAgICAvLyBpbXBvcnQgamF2YS51dGlsLkhhc2hNYXA7XG4gICAgLy8gaW1wb3J0IGphdmEudXRpbC5NYXA7XG4gICAgLy8gaW1wb3J0IGphdmEudXRpbC5NYXAuRW50cnk7XG4gICAgLyoqXG4gICAgICogQGF1dGhvciBHdWVudGhlciBHcmF1XG4gICAgICovXG4gICAgLypmaW5hbCovIGNsYXNzIEJhcmNvZGVWYWx1ZSB7XG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgICAgdGhpcy52YWx1ZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZCBhbiBvY2N1cnJlbmNlIG9mIGEgdmFsdWVcbiAgICAgICAgICovXG4gICAgICAgIHNldFZhbHVlKHZhbHVlKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IE1hdGgudHJ1bmModmFsdWUpO1xuICAgICAgICAgICAgbGV0IGNvbmZpZGVuY2UgPSB0aGlzLnZhbHVlcy5nZXQodmFsdWUpO1xuICAgICAgICAgICAgaWYgKGNvbmZpZGVuY2UgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbmZpZGVuY2UgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uZmlkZW5jZSsrO1xuICAgICAgICAgICAgdGhpcy52YWx1ZXMuc2V0KHZhbHVlLCBjb25maWRlbmNlKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogRGV0ZXJtaW5lcyB0aGUgbWF4aW11bSBvY2N1cnJlbmNlIG9mIGEgc2V0IHZhbHVlIGFuZCByZXR1cm5zIGFsbCB2YWx1ZXMgd2hpY2ggd2VyZSBzZXQgd2l0aCB0aGlzIG9jY3VycmVuY2UuXG4gICAgICAgICAqIEByZXR1cm4gYW4gYXJyYXkgb2YgaW50LCBjb250YWluaW5nIHRoZSB2YWx1ZXMgd2l0aCB0aGUgaGlnaGVzdCBvY2N1cnJlbmNlLCBvciBudWxsLCBpZiBubyB2YWx1ZSB3YXMgc2V0XG4gICAgICAgICAqL1xuICAgICAgICBnZXRWYWx1ZSgpIHtcbiAgICAgICAgICAgIGxldCBtYXhDb25maWRlbmNlID0gLTE7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gbmV3IEFycmF5KCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiB0aGlzLnZhbHVlcy5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlbnRyeSA9IHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0S2V5OiAoKSA9PiBrZXksXG4gICAgICAgICAgICAgICAgICAgIGdldFZhbHVlOiAoKSA9PiB2YWx1ZSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmIChlbnRyeS5nZXRWYWx1ZSgpID4gbWF4Q29uZmlkZW5jZSkge1xuICAgICAgICAgICAgICAgICAgICBtYXhDb25maWRlbmNlID0gZW50cnkuZ2V0VmFsdWUoKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gW107XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGVudHJ5LmdldEtleSgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZW50cnkuZ2V0VmFsdWUoKSA9PT0gbWF4Q29uZmlkZW5jZSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChlbnRyeS5nZXRLZXkoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFBERjQxN0NvbW1vbi50b0ludEFycmF5KHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0Q29uZmlkZW5jZSh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVzLmdldCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKlxuICAgICAqIENvcHlyaWdodCAyMDEzIFpYaW5nIGF1dGhvcnNcbiAgICAgKlxuICAgICAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gICAgICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgICAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgICAqXG4gICAgICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAgICAgKlxuICAgICAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgICAgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICAgICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gICAgICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICAgICAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIEBhdXRob3IgR3VlbnRoZXIgR3JhdVxuICAgICAqL1xuICAgIC8qZmluYWwqLyBjbGFzcyBEZXRlY3Rpb25SZXN1bHRSb3dJbmRpY2F0b3JDb2x1bW4gZXh0ZW5kcyBEZXRlY3Rpb25SZXN1bHRDb2x1bW4ge1xuICAgICAgICBjb25zdHJ1Y3Rvcihib3VuZGluZ0JveCwgaXNMZWZ0KSB7XG4gICAgICAgICAgICBzdXBlcihib3VuZGluZ0JveCk7XG4gICAgICAgICAgICB0aGlzLl9pc0xlZnQgPSBpc0xlZnQ7XG4gICAgICAgIH1cbiAgICAgICAgc2V0Um93TnVtYmVycygpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGNvZGV3b3JkIC8qQ29kZXdvcmQqLyBvZiB0aGlzLmdldENvZGV3b3JkcygpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvZGV3b3JkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZXdvcmQuc2V0Um93TnVtYmVyQXNSb3dJbmRpY2F0b3JDb2x1bW4oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETyBpbXBsZW1lbnQgcHJvcGVybHlcbiAgICAgICAgLy8gVE9ETyBtYXliZSB3ZSBzaG91bGQgYWRkIG1pc3NpbmcgY29kZXdvcmRzIHRvIHN0b3JlIHRoZSBjb3JyZWN0IHJvdyBudW1iZXIgdG8gbWFrZVxuICAgICAgICAvLyBmaW5kaW5nIHJvdyBudW1iZXJzIGZvciBvdGhlciBjb2x1bW5zIGVhc2llclxuICAgICAgICAvLyB1c2Ugcm93IGhlaWdodCBjb3VudCB0byBtYWtlIGRldGVjdGlvbiBvZiBpbnZhbGlkIHJvdyBudW1iZXJzIG1vcmUgcmVsaWFibGVcbiAgICAgICAgYWRqdXN0Q29tcGxldGVJbmRpY2F0b3JDb2x1bW5Sb3dOdW1iZXJzKGJhcmNvZGVNZXRhZGF0YSkge1xuICAgICAgICAgICAgbGV0IGNvZGV3b3JkcyA9IHRoaXMuZ2V0Q29kZXdvcmRzKCk7XG4gICAgICAgICAgICB0aGlzLnNldFJvd051bWJlcnMoKTtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlSW5jb3JyZWN0Q29kZXdvcmRzKGNvZGV3b3JkcywgYmFyY29kZU1ldGFkYXRhKTtcbiAgICAgICAgICAgIGxldCBib3VuZGluZ0JveCA9IHRoaXMuZ2V0Qm91bmRpbmdCb3goKTtcbiAgICAgICAgICAgIGxldCB0b3AgPSB0aGlzLl9pc0xlZnQgPyBib3VuZGluZ0JveC5nZXRUb3BMZWZ0KCkgOiBib3VuZGluZ0JveC5nZXRUb3BSaWdodCgpO1xuICAgICAgICAgICAgbGV0IGJvdHRvbSA9IHRoaXMuX2lzTGVmdCA/IGJvdW5kaW5nQm94LmdldEJvdHRvbUxlZnQoKSA6IGJvdW5kaW5nQm94LmdldEJvdHRvbVJpZ2h0KCk7XG4gICAgICAgICAgICBsZXQgZmlyc3RSb3cgPSB0aGlzLmltYWdlUm93VG9Db2Rld29yZEluZGV4KE1hdGgudHJ1bmModG9wLmdldFkoKSkpO1xuICAgICAgICAgICAgbGV0IGxhc3RSb3cgPSB0aGlzLmltYWdlUm93VG9Db2Rld29yZEluZGV4KE1hdGgudHJ1bmMoYm90dG9tLmdldFkoKSkpO1xuICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBiZSBjYXJlZnVsIHVzaW5nIHRoZSBhdmVyYWdlIHJvdyBoZWlnaHQuIEJhcmNvZGUgY291bGQgYmUgc2tld2VkIHNvIHRoYXQgd2UgaGF2ZSBzbWFsbGVyIGFuZFxuICAgICAgICAgICAgLy8gdGFsbGVyIHJvd3NcbiAgICAgICAgICAgIC8vIGZsb2F0IGF2ZXJhZ2VSb3dIZWlnaHQgPSAobGFzdFJvdyAtIGZpcnN0Um93KSAvIC8qKGZsb2F0KSovIGJhcmNvZGVNZXRhZGF0YS5nZXRSb3dDb3VudCgpO1xuICAgICAgICAgICAgbGV0IGJhcmNvZGVSb3cgPSAtMTtcbiAgICAgICAgICAgIGxldCBtYXhSb3dIZWlnaHQgPSAxO1xuICAgICAgICAgICAgbGV0IGN1cnJlbnRSb3dIZWlnaHQgPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgY29kZXdvcmRzUm93IC8qaW50Ki8gPSBmaXJzdFJvdzsgY29kZXdvcmRzUm93IDwgbGFzdFJvdzsgY29kZXdvcmRzUm93KyspIHtcbiAgICAgICAgICAgICAgICBpZiAoY29kZXdvcmRzW2NvZGV3b3Jkc1Jvd10gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGNvZGV3b3JkID0gY29kZXdvcmRzW2NvZGV3b3Jkc1Jvd107XG4gICAgICAgICAgICAgICAgLy8gICAgICBmbG9hdCBleHBlY3RlZFJvd051bWJlciA9IChjb2Rld29yZHNSb3cgLSBmaXJzdFJvdykgLyBhdmVyYWdlUm93SGVpZ2h0O1xuICAgICAgICAgICAgICAgIC8vICAgICAgaWYgKE1hdGguYWJzKGNvZGV3b3JkLmdldFJvd051bWJlcigpIC0gZXhwZWN0ZWRSb3dOdW1iZXIpID4gMikge1xuICAgICAgICAgICAgICAgIC8vICAgICAgICBTaW1wbGVMb2cubG9nKExFVkVMLldBUk5JTkcsXG4gICAgICAgICAgICAgICAgLy8gICAgICAgICAgICBcIlJlbW92aW5nIGNvZGV3b3JkLCByb3dOdW1iZXJTa2V3IHRvbyBoaWdoLCBjb2Rld29yZFtcIiArIGNvZGV3b3Jkc1JvdyArIFwiXTogRXhwZWN0ZWQgUm93OiBcIiArXG4gICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgZXhwZWN0ZWRSb3dOdW1iZXIgKyBcIiwgUmVhbFJvdzogXCIgKyBjb2Rld29yZC5nZXRSb3dOdW1iZXIoKSArIFwiLCB2YWx1ZTogXCIgKyBjb2Rld29yZC5nZXRWYWx1ZSgpKTtcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgY29kZXdvcmRzW2NvZGV3b3Jkc1Jvd10gPSBudWxsO1xuICAgICAgICAgICAgICAgIC8vICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCByb3dEaWZmZXJlbmNlID0gY29kZXdvcmQuZ2V0Um93TnVtYmVyKCkgLSBiYXJjb2RlUm93O1xuICAgICAgICAgICAgICAgIC8vIFRPRE8gaW1wcm92ZSBoYW5kbGluZyB3aXRoIGNhc2Ugd2hlcmUgZmlyc3Qgcm93IGluZGljYXRvciBkb2Vzbid0IHN0YXJ0IHdpdGggMFxuICAgICAgICAgICAgICAgIGlmIChyb3dEaWZmZXJlbmNlID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRSb3dIZWlnaHQrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocm93RGlmZmVyZW5jZSA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBtYXhSb3dIZWlnaHQgPSBNYXRoLm1heChtYXhSb3dIZWlnaHQsIGN1cnJlbnRSb3dIZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Um93SGVpZ2h0ID0gMTtcbiAgICAgICAgICAgICAgICAgICAgYmFyY29kZVJvdyA9IGNvZGV3b3JkLmdldFJvd051bWJlcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyb3dEaWZmZXJlbmNlIDwgMCB8fFxuICAgICAgICAgICAgICAgICAgICBjb2Rld29yZC5nZXRSb3dOdW1iZXIoKSA+PSBiYXJjb2RlTWV0YWRhdGEuZ2V0Um93Q291bnQoKSB8fFxuICAgICAgICAgICAgICAgICAgICByb3dEaWZmZXJlbmNlID4gY29kZXdvcmRzUm93KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGV3b3Jkc1tjb2Rld29yZHNSb3ddID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjaGVja2VkUm93cztcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1heFJvd0hlaWdodCA+IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrZWRSb3dzID0gKG1heFJvd0hlaWdodCAtIDIpICogcm93RGlmZmVyZW5jZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrZWRSb3dzID0gcm93RGlmZmVyZW5jZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsZXQgY2xvc2VQcmV2aW91c0NvZGV3b3JkRm91bmQgPSBjaGVja2VkUm93cyA+PSBjb2Rld29yZHNSb3c7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgLyppbnQqLyA9IDE7IGkgPD0gY2hlY2tlZFJvd3MgJiYgIWNsb3NlUHJldmlvdXNDb2Rld29yZEZvdW5kOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZXJlIG11c3QgYmUgKGhlaWdodCAqIHJvd0RpZmZlcmVuY2UpIG51bWJlciBvZiBjb2Rld29yZHMgbWlzc2luZy4gRm9yIG5vdyB3ZSBhc3N1bWUgaGVpZ2h0ID0gMS5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgc2hvdWxkIGhvcGVmdWxseSBnZXQgcmlkIG9mIG1vc3QgcHJvYmxlbXMgYWxyZWFkeS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNsb3NlUHJldmlvdXNDb2Rld29yZEZvdW5kID0gY29kZXdvcmRzW2NvZGV3b3Jkc1JvdyAtIGldICE9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNsb3NlUHJldmlvdXNDb2Rld29yZEZvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2Rld29yZHNbY29kZXdvcmRzUm93XSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiYXJjb2RlUm93ID0gY29kZXdvcmQuZ2V0Um93TnVtYmVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Um93SGVpZ2h0ID0gMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHJldHVybiAoaW50KSAoYXZlcmFnZVJvd0hlaWdodCArIDAuNSk7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0Um93SGVpZ2h0cygpIHtcbiAgICAgICAgICAgIGxldCBiYXJjb2RlTWV0YWRhdGEgPSB0aGlzLmdldEJhcmNvZGVNZXRhZGF0YSgpO1xuICAgICAgICAgICAgaWYgKGJhcmNvZGVNZXRhZGF0YSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmFkanVzdEluY29tcGxldGVJbmRpY2F0b3JDb2x1bW5Sb3dOdW1iZXJzKGJhcmNvZGVNZXRhZGF0YSk7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gbmV3IEludDMyQXJyYXkoYmFyY29kZU1ldGFkYXRhLmdldFJvd0NvdW50KCkpO1xuICAgICAgICAgICAgZm9yIChsZXQgY29kZXdvcmQgLypDb2Rld29yZCovIG9mIHRoaXMuZ2V0Q29kZXdvcmRzKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29kZXdvcmQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcm93TnVtYmVyID0gY29kZXdvcmQuZ2V0Um93TnVtYmVyKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyb3dOdW1iZXIgPj0gcmVzdWx0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgaGF2ZSBtb3JlIHJvd3MgdGhhbiB0aGUgYmFyY29kZSBtZXRhZGF0YSBhbGxvd3MgZm9yLCBpZ25vcmUgdGhlbS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtyb3dOdW1iZXJdKys7XG4gICAgICAgICAgICAgICAgfSAvLyBlbHNlIHRocm93IGV4Y2VwdGlvbj9cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETyBtYXliZSB3ZSBzaG91bGQgYWRkIG1pc3NpbmcgY29kZXdvcmRzIHRvIHN0b3JlIHRoZSBjb3JyZWN0IHJvdyBudW1iZXIgdG8gbWFrZVxuICAgICAgICAvLyBmaW5kaW5nIHJvdyBudW1iZXJzIGZvciBvdGhlciBjb2x1bW5zIGVhc2llclxuICAgICAgICAvLyB1c2Ugcm93IGhlaWdodCBjb3VudCB0byBtYWtlIGRldGVjdGlvbiBvZiBpbnZhbGlkIHJvdyBudW1iZXJzIG1vcmUgcmVsaWFibGVcbiAgICAgICAgYWRqdXN0SW5jb21wbGV0ZUluZGljYXRvckNvbHVtblJvd051bWJlcnMoYmFyY29kZU1ldGFkYXRhKSB7XG4gICAgICAgICAgICBsZXQgYm91bmRpbmdCb3ggPSB0aGlzLmdldEJvdW5kaW5nQm94KCk7XG4gICAgICAgICAgICBsZXQgdG9wID0gdGhpcy5faXNMZWZ0ID8gYm91bmRpbmdCb3guZ2V0VG9wTGVmdCgpIDogYm91bmRpbmdCb3guZ2V0VG9wUmlnaHQoKTtcbiAgICAgICAgICAgIGxldCBib3R0b20gPSB0aGlzLl9pc0xlZnQgPyBib3VuZGluZ0JveC5nZXRCb3R0b21MZWZ0KCkgOiBib3VuZGluZ0JveC5nZXRCb3R0b21SaWdodCgpO1xuICAgICAgICAgICAgbGV0IGZpcnN0Um93ID0gdGhpcy5pbWFnZVJvd1RvQ29kZXdvcmRJbmRleChNYXRoLnRydW5jKHRvcC5nZXRZKCkpKTtcbiAgICAgICAgICAgIGxldCBsYXN0Um93ID0gdGhpcy5pbWFnZVJvd1RvQ29kZXdvcmRJbmRleChNYXRoLnRydW5jKGJvdHRvbS5nZXRZKCkpKTtcbiAgICAgICAgICAgIC8vIGZsb2F0IGF2ZXJhZ2VSb3dIZWlnaHQgPSAobGFzdFJvdyAtIGZpcnN0Um93KSAvIC8qKGZsb2F0KSovIGJhcmNvZGVNZXRhZGF0YS5nZXRSb3dDb3VudCgpO1xuICAgICAgICAgICAgbGV0IGNvZGV3b3JkcyA9IHRoaXMuZ2V0Q29kZXdvcmRzKCk7XG4gICAgICAgICAgICBsZXQgYmFyY29kZVJvdyA9IC0xO1xuICAgICAgICAgICAgZm9yIChsZXQgY29kZXdvcmRzUm93IC8qaW50Ki8gPSBmaXJzdFJvdzsgY29kZXdvcmRzUm93IDwgbGFzdFJvdzsgY29kZXdvcmRzUm93KyspIHtcbiAgICAgICAgICAgICAgICBpZiAoY29kZXdvcmRzW2NvZGV3b3Jkc1Jvd10gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGNvZGV3b3JkID0gY29kZXdvcmRzW2NvZGV3b3Jkc1Jvd107XG4gICAgICAgICAgICAgICAgY29kZXdvcmQuc2V0Um93TnVtYmVyQXNSb3dJbmRpY2F0b3JDb2x1bW4oKTtcbiAgICAgICAgICAgICAgICBsZXQgcm93RGlmZmVyZW5jZSA9IGNvZGV3b3JkLmdldFJvd051bWJlcigpIC0gYmFyY29kZVJvdztcbiAgICAgICAgICAgICAgICAvLyBUT0RPIGltcHJvdmUgaGFuZGxpbmcgd2l0aCBjYXNlIHdoZXJlIGZpcnN0IHJvdyBpbmRpY2F0b3IgZG9lc24ndCBzdGFydCB3aXRoIDBcbiAgICAgICAgICAgICAgICBpZiAocm93RGlmZmVyZW5jZSA9PT0gMCkgO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJvd0RpZmZlcmVuY2UgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgYmFyY29kZVJvdyA9IGNvZGV3b3JkLmdldFJvd051bWJlcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjb2Rld29yZC5nZXRSb3dOdW1iZXIoKSA+PSBiYXJjb2RlTWV0YWRhdGEuZ2V0Um93Q291bnQoKSkge1xuICAgICAgICAgICAgICAgICAgICBjb2Rld29yZHNbY29kZXdvcmRzUm93XSA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBiYXJjb2RlUm93ID0gY29kZXdvcmQuZ2V0Um93TnVtYmVyKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gcmV0dXJuIChpbnQpIChhdmVyYWdlUm93SGVpZ2h0ICsgMC41KTtcbiAgICAgICAgfVxuICAgICAgICBnZXRCYXJjb2RlTWV0YWRhdGEoKSB7XG4gICAgICAgICAgICBsZXQgY29kZXdvcmRzID0gdGhpcy5nZXRDb2Rld29yZHMoKTtcbiAgICAgICAgICAgIGxldCBiYXJjb2RlQ29sdW1uQ291bnQgPSBuZXcgQmFyY29kZVZhbHVlKCk7XG4gICAgICAgICAgICBsZXQgYmFyY29kZVJvd0NvdW50VXBwZXJQYXJ0ID0gbmV3IEJhcmNvZGVWYWx1ZSgpO1xuICAgICAgICAgICAgbGV0IGJhcmNvZGVSb3dDb3VudExvd2VyUGFydCA9IG5ldyBCYXJjb2RlVmFsdWUoKTtcbiAgICAgICAgICAgIGxldCBiYXJjb2RlRUNMZXZlbCA9IG5ldyBCYXJjb2RlVmFsdWUoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGNvZGV3b3JkIC8qQ29kZXdvcmQqLyBvZiBjb2Rld29yZHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29kZXdvcmQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29kZXdvcmQuc2V0Um93TnVtYmVyQXNSb3dJbmRpY2F0b3JDb2x1bW4oKTtcbiAgICAgICAgICAgICAgICBsZXQgcm93SW5kaWNhdG9yVmFsdWUgPSBjb2Rld29yZC5nZXRWYWx1ZSgpICUgMzA7XG4gICAgICAgICAgICAgICAgbGV0IGNvZGV3b3JkUm93TnVtYmVyID0gY29kZXdvcmQuZ2V0Um93TnVtYmVyKCk7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9pc0xlZnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZXdvcmRSb3dOdW1iZXIgKz0gMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3dpdGNoIChjb2Rld29yZFJvd051bWJlciAlIDMpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgYmFyY29kZVJvd0NvdW50VXBwZXJQYXJ0LnNldFZhbHVlKHJvd0luZGljYXRvclZhbHVlICogMyArIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhcmNvZGVFQ0xldmVsLnNldFZhbHVlKHJvd0luZGljYXRvclZhbHVlIC8gMyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBiYXJjb2RlUm93Q291bnRMb3dlclBhcnQuc2V0VmFsdWUocm93SW5kaWNhdG9yVmFsdWUgJSAzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBiYXJjb2RlQ29sdW1uQ291bnQuc2V0VmFsdWUocm93SW5kaWNhdG9yVmFsdWUgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE1heWJlIHdlIHNob3VsZCBjaGVjayBpZiB3ZSBoYXZlIGFtYmlndW91cyB2YWx1ZXM/XG4gICAgICAgICAgICBpZiAoKGJhcmNvZGVDb2x1bW5Db3VudC5nZXRWYWx1ZSgpLmxlbmd0aCA9PT0gMCkgfHxcbiAgICAgICAgICAgICAgICAoYmFyY29kZVJvd0NvdW50VXBwZXJQYXJ0LmdldFZhbHVlKCkubGVuZ3RoID09PSAwKSB8fFxuICAgICAgICAgICAgICAgIChiYXJjb2RlUm93Q291bnRMb3dlclBhcnQuZ2V0VmFsdWUoKS5sZW5ndGggPT09IDApIHx8XG4gICAgICAgICAgICAgICAgKGJhcmNvZGVFQ0xldmVsLmdldFZhbHVlKCkubGVuZ3RoID09PSAwKSB8fFxuICAgICAgICAgICAgICAgIGJhcmNvZGVDb2x1bW5Db3VudC5nZXRWYWx1ZSgpWzBdIDwgMSB8fFxuICAgICAgICAgICAgICAgIGJhcmNvZGVSb3dDb3VudFVwcGVyUGFydC5nZXRWYWx1ZSgpWzBdICsgYmFyY29kZVJvd0NvdW50TG93ZXJQYXJ0LmdldFZhbHVlKClbMF0gPCBQREY0MTdDb21tb24uTUlOX1JPV1NfSU5fQkFSQ09ERSB8fFxuICAgICAgICAgICAgICAgIGJhcmNvZGVSb3dDb3VudFVwcGVyUGFydC5nZXRWYWx1ZSgpWzBdICsgYmFyY29kZVJvd0NvdW50TG93ZXJQYXJ0LmdldFZhbHVlKClbMF0gPiBQREY0MTdDb21tb24uTUFYX1JPV1NfSU5fQkFSQ09ERSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGJhcmNvZGVNZXRhZGF0YSA9IG5ldyBCYXJjb2RlTWV0YWRhdGEoYmFyY29kZUNvbHVtbkNvdW50LmdldFZhbHVlKClbMF0sIGJhcmNvZGVSb3dDb3VudFVwcGVyUGFydC5nZXRWYWx1ZSgpWzBdLCBiYXJjb2RlUm93Q291bnRMb3dlclBhcnQuZ2V0VmFsdWUoKVswXSwgYmFyY29kZUVDTGV2ZWwuZ2V0VmFsdWUoKVswXSk7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUluY29ycmVjdENvZGV3b3Jkcyhjb2Rld29yZHMsIGJhcmNvZGVNZXRhZGF0YSk7XG4gICAgICAgICAgICByZXR1cm4gYmFyY29kZU1ldGFkYXRhO1xuICAgICAgICB9XG4gICAgICAgIHJlbW92ZUluY29ycmVjdENvZGV3b3Jkcyhjb2Rld29yZHMsIGJhcmNvZGVNZXRhZGF0YSkge1xuICAgICAgICAgICAgLy8gUmVtb3ZlIGNvZGV3b3JkcyB3aGljaCBkbyBub3QgbWF0Y2ggdGhlIG1ldGFkYXRhXG4gICAgICAgICAgICAvLyBUT0RPIE1heWJlIHdlIHNob3VsZCBrZWVwIHRoZSBpbmNvcnJlY3QgY29kZXdvcmRzIGZvciB0aGUgc3RhcnQgYW5kIGVuZCBwb3NpdGlvbnM/XG4gICAgICAgICAgICBmb3IgKGxldCBjb2Rld29yZFJvdyAvKmludCovID0gMDsgY29kZXdvcmRSb3cgPCBjb2Rld29yZHMubGVuZ3RoOyBjb2Rld29yZFJvdysrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNvZGV3b3JkID0gY29kZXdvcmRzW2NvZGV3b3JkUm93XTtcbiAgICAgICAgICAgICAgICBpZiAoY29kZXdvcmRzW2NvZGV3b3JkUm93XSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgcm93SW5kaWNhdG9yVmFsdWUgPSBjb2Rld29yZC5nZXRWYWx1ZSgpICUgMzA7XG4gICAgICAgICAgICAgICAgbGV0IGNvZGV3b3JkUm93TnVtYmVyID0gY29kZXdvcmQuZ2V0Um93TnVtYmVyKCk7XG4gICAgICAgICAgICAgICAgaWYgKGNvZGV3b3JkUm93TnVtYmVyID4gYmFyY29kZU1ldGFkYXRhLmdldFJvd0NvdW50KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZXdvcmRzW2NvZGV3b3JkUm93XSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2lzTGVmdCkge1xuICAgICAgICAgICAgICAgICAgICBjb2Rld29yZFJvd051bWJlciArPSAyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGNvZGV3b3JkUm93TnVtYmVyICUgMykge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocm93SW5kaWNhdG9yVmFsdWUgKiAzICsgMSAhPT0gYmFyY29kZU1ldGFkYXRhLmdldFJvd0NvdW50VXBwZXJQYXJ0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2Rld29yZHNbY29kZXdvcmRSb3ddID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoTWF0aC50cnVuYyhyb3dJbmRpY2F0b3JWYWx1ZSAvIDMpICE9PSBiYXJjb2RlTWV0YWRhdGEuZ2V0RXJyb3JDb3JyZWN0aW9uTGV2ZWwoKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvd0luZGljYXRvclZhbHVlICUgMyAhPT0gYmFyY29kZU1ldGFkYXRhLmdldFJvd0NvdW50TG93ZXJQYXJ0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2Rld29yZHNbY29kZXdvcmRSb3ddID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocm93SW5kaWNhdG9yVmFsdWUgKyAxICE9PSBiYXJjb2RlTWV0YWRhdGEuZ2V0Q29sdW1uQ291bnQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGV3b3Jkc1tjb2Rld29yZFJvd10gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlzTGVmdCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pc0xlZnQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQE92ZXJyaWRlXG4gICAgICAgIHRvU3RyaW5nKCkge1xuICAgICAgICAgICAgcmV0dXJuICdJc0xlZnQ6ICcgKyB0aGlzLl9pc0xlZnQgKyAnXFxuJyArIHN1cGVyLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKlxuICAgICAqIENvcHlyaWdodCAyMDEzIFpYaW5nIGF1dGhvcnNcbiAgICAgKlxuICAgICAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gICAgICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgICAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgICAqXG4gICAgICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAgICAgKlxuICAgICAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgICAgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICAgICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gICAgICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICAgICAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIEBhdXRob3IgR3VlbnRoZXIgR3JhdVxuICAgICAqL1xuICAgIC8qZmluYWwqLyBjbGFzcyBEZXRlY3Rpb25SZXN1bHQge1xuICAgICAgICBjb25zdHJ1Y3RvcihiYXJjb2RlTWV0YWRhdGEsIGJvdW5kaW5nQm94KSB7XG4gICAgICAgICAgICAvKmZpbmFsKi8gdGhpcy5BREpVU1RfUk9XX05VTUJFUl9TS0lQID0gMjtcbiAgICAgICAgICAgIHRoaXMuYmFyY29kZU1ldGFkYXRhID0gYmFyY29kZU1ldGFkYXRhO1xuICAgICAgICAgICAgdGhpcy5iYXJjb2RlQ29sdW1uQ291bnQgPSBiYXJjb2RlTWV0YWRhdGEuZ2V0Q29sdW1uQ291bnQoKTtcbiAgICAgICAgICAgIHRoaXMuYm91bmRpbmdCb3ggPSBib3VuZGluZ0JveDtcbiAgICAgICAgICAgIC8vIHRoaXMuZGV0ZWN0aW9uUmVzdWx0Q29sdW1ucyA9IG5ldyBEZXRlY3Rpb25SZXN1bHRDb2x1bW5bdGhpcy5iYXJjb2RlQ29sdW1uQ291bnQgKyAyXTtcbiAgICAgICAgICAgIHRoaXMuZGV0ZWN0aW9uUmVzdWx0Q29sdW1ucyA9IG5ldyBBcnJheSh0aGlzLmJhcmNvZGVDb2x1bW5Db3VudCArIDIpO1xuICAgICAgICB9XG4gICAgICAgIGdldERldGVjdGlvblJlc3VsdENvbHVtbnMoKSB7XG4gICAgICAgICAgICB0aGlzLmFkanVzdEluZGljYXRvckNvbHVtblJvd051bWJlcnModGhpcy5kZXRlY3Rpb25SZXN1bHRDb2x1bW5zWzBdKTtcbiAgICAgICAgICAgIHRoaXMuYWRqdXN0SW5kaWNhdG9yQ29sdW1uUm93TnVtYmVycyh0aGlzLmRldGVjdGlvblJlc3VsdENvbHVtbnNbdGhpcy5iYXJjb2RlQ29sdW1uQ291bnQgKyAxXSk7XG4gICAgICAgICAgICBsZXQgdW5hZGp1c3RlZENvZGV3b3JkQ291bnQgPSBQREY0MTdDb21tb24uTUFYX0NPREVXT1JEU19JTl9CQVJDT0RFO1xuICAgICAgICAgICAgbGV0IHByZXZpb3VzVW5hZGp1c3RlZENvdW50O1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIHByZXZpb3VzVW5hZGp1c3RlZENvdW50ID0gdW5hZGp1c3RlZENvZGV3b3JkQ291bnQ7XG4gICAgICAgICAgICAgICAgdW5hZGp1c3RlZENvZGV3b3JkQ291bnQgPSB0aGlzLmFkanVzdFJvd051bWJlcnNBbmRHZXRDb3VudCgpO1xuICAgICAgICAgICAgfSB3aGlsZSAodW5hZGp1c3RlZENvZGV3b3JkQ291bnQgPiAwICYmIHVuYWRqdXN0ZWRDb2Rld29yZENvdW50IDwgcHJldmlvdXNVbmFkanVzdGVkQ291bnQpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGV0ZWN0aW9uUmVzdWx0Q29sdW1ucztcbiAgICAgICAgfVxuICAgICAgICBhZGp1c3RJbmRpY2F0b3JDb2x1bW5Sb3dOdW1iZXJzKGRldGVjdGlvblJlc3VsdENvbHVtbikge1xuICAgICAgICAgICAgaWYgKGRldGVjdGlvblJlc3VsdENvbHVtbiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZGV0ZWN0aW9uUmVzdWx0Q29sdW1uXG4gICAgICAgICAgICAgICAgICAgIC5hZGp1c3RDb21wbGV0ZUluZGljYXRvckNvbHVtblJvd051bWJlcnModGhpcy5iYXJjb2RlTWV0YWRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE8gZW5zdXJlIHRoYXQgbm8gZGV0ZWN0ZWQgY29kZXdvcmRzIHdpdGggdW5rbm93biByb3cgbnVtYmVyIGFyZSBsZWZ0XG4gICAgICAgIC8vIHdlIHNob3VsZCBiZSBhYmxlIHRvIGVzdGltYXRlIHRoZSByb3cgaGVpZ2h0IGFuZCB1c2UgaXQgYXMgYSBoaW50IGZvciB0aGUgcm93IG51bWJlclxuICAgICAgICAvLyB3ZSBzaG91bGQgYWxzbyBmaWxsIHRoZSByb3dzIHRvcCB0byBib3R0b20gYW5kIGJvdHRvbSB0byB0b3BcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gbnVtYmVyIG9mIGNvZGV3b3JkcyB3aGljaCBkb24ndCBoYXZlIGEgdmFsaWQgcm93IG51bWJlci4gTm90ZSB0aGF0IHRoZSBjb3VudCBpcyBub3QgYWNjdXJhdGUgYXMgY29kZXdvcmRzXG4gICAgICAgICAqIHdpbGwgYmUgY291bnRlZCBzZXZlcmFsIHRpbWVzLiBJdCBqdXN0IHNlcnZlcyBhcyBhbiBpbmRpY2F0b3IgdG8gc2VlIHdoZW4gd2UgY2FuIHN0b3AgYWRqdXN0aW5nIHJvdyBudW1iZXJzXG4gICAgICAgICAqL1xuICAgICAgICBhZGp1c3RSb3dOdW1iZXJzQW5kR2V0Q291bnQoKSB7XG4gICAgICAgICAgICBsZXQgdW5hZGp1c3RlZENvdW50ID0gdGhpcy5hZGp1c3RSb3dOdW1iZXJzQnlSb3coKTtcbiAgICAgICAgICAgIGlmICh1bmFkanVzdGVkQ291bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGJhcmNvZGVDb2x1bW4gLyppbnQqLyA9IDE7IGJhcmNvZGVDb2x1bW4gPCB0aGlzLmJhcmNvZGVDb2x1bW5Db3VudCArIDE7IGJhcmNvZGVDb2x1bW4rKykge1xuICAgICAgICAgICAgICAgIGxldCBjb2Rld29yZHMgPSB0aGlzLmRldGVjdGlvblJlc3VsdENvbHVtbnNbYmFyY29kZUNvbHVtbl0uZ2V0Q29kZXdvcmRzKCk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgY29kZXdvcmRzUm93IC8qaW50Ki8gPSAwOyBjb2Rld29yZHNSb3cgPCBjb2Rld29yZHMubGVuZ3RoOyBjb2Rld29yZHNSb3crKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29kZXdvcmRzW2NvZGV3b3Jkc1Jvd10gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjb2Rld29yZHNbY29kZXdvcmRzUm93XS5oYXNWYWxpZFJvd051bWJlcigpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFkanVzdFJvd051bWJlcnMoYmFyY29kZUNvbHVtbiwgY29kZXdvcmRzUm93LCBjb2Rld29yZHMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHVuYWRqdXN0ZWRDb3VudDtcbiAgICAgICAgfVxuICAgICAgICBhZGp1c3RSb3dOdW1iZXJzQnlSb3coKSB7XG4gICAgICAgICAgICB0aGlzLmFkanVzdFJvd051bWJlcnNGcm9tQm90aFJJKCk7XG4gICAgICAgICAgICAvLyBUT0RPIHdlIHNob3VsZCBvbmx5IGRvIGZ1bGwgcm93IGFkanVzdG1lbnRzIGlmIHJvdyBudW1iZXJzIG9mIGxlZnQgYW5kIHJpZ2h0IHJvdyBpbmRpY2F0b3IgY29sdW1uIG1hdGNoLlxuICAgICAgICAgICAgLy8gTWF5YmUgaXQncyBldmVuIGJldHRlciB0byBjYWxjdWxhdGVkIHRoZSBoZWlnaHQgKHJvd3M6IGQpIGFuZCBkaXZpZGUgaXQgYnkgdGhlIG51bWJlciBvZiBiYXJjb2RlXG4gICAgICAgICAgICAvLyByb3dzLiBUaGlzLCB0b2dldGhlciB3aXRoIHRoZSBMUkkgYW5kIFJSSSByb3cgbnVtYmVycyBzaG91bGQgYWxsb3cgdXMgdG8gZ2V0IGEgZ29vZCBlc3RpbWF0ZSB3aGVyZSBhIHJvd1xuICAgICAgICAgICAgLy8gbnVtYmVyIHN0YXJ0cyBhbmQgZW5kcy5cbiAgICAgICAgICAgIGxldCB1bmFkanVzdGVkQ291bnQgPSB0aGlzLmFkanVzdFJvd051bWJlcnNGcm9tTFJJKCk7XG4gICAgICAgICAgICByZXR1cm4gdW5hZGp1c3RlZENvdW50ICsgdGhpcy5hZGp1c3RSb3dOdW1iZXJzRnJvbVJSSSgpO1xuICAgICAgICB9XG4gICAgICAgIGFkanVzdFJvd051bWJlcnNGcm9tQm90aFJJKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZGV0ZWN0aW9uUmVzdWx0Q29sdW1uc1swXSA9PSBudWxsIHx8IHRoaXMuZGV0ZWN0aW9uUmVzdWx0Q29sdW1uc1t0aGlzLmJhcmNvZGVDb2x1bW5Db3VudCArIDFdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgTFJJY29kZXdvcmRzID0gdGhpcy5kZXRlY3Rpb25SZXN1bHRDb2x1bW5zWzBdLmdldENvZGV3b3JkcygpO1xuICAgICAgICAgICAgbGV0IFJSSWNvZGV3b3JkcyA9IHRoaXMuZGV0ZWN0aW9uUmVzdWx0Q29sdW1uc1t0aGlzLmJhcmNvZGVDb2x1bW5Db3VudCArIDFdLmdldENvZGV3b3JkcygpO1xuICAgICAgICAgICAgZm9yIChsZXQgY29kZXdvcmRzUm93IC8qaW50Ki8gPSAwOyBjb2Rld29yZHNSb3cgPCBMUkljb2Rld29yZHMubGVuZ3RoOyBjb2Rld29yZHNSb3crKykge1xuICAgICAgICAgICAgICAgIGlmIChMUkljb2Rld29yZHNbY29kZXdvcmRzUm93XSAhPSBudWxsICYmXG4gICAgICAgICAgICAgICAgICAgIFJSSWNvZGV3b3Jkc1tjb2Rld29yZHNSb3ddICE9IG51bGwgJiZcbiAgICAgICAgICAgICAgICAgICAgTFJJY29kZXdvcmRzW2NvZGV3b3Jkc1Jvd10uZ2V0Um93TnVtYmVyKCkgPT09IFJSSWNvZGV3b3Jkc1tjb2Rld29yZHNSb3ddLmdldFJvd051bWJlcigpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGJhcmNvZGVDb2x1bW4gLyppbnQqLyA9IDE7IGJhcmNvZGVDb2x1bW4gPD0gdGhpcy5iYXJjb2RlQ29sdW1uQ291bnQ7IGJhcmNvZGVDb2x1bW4rKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNvZGV3b3JkID0gdGhpcy5kZXRlY3Rpb25SZXN1bHRDb2x1bW5zW2JhcmNvZGVDb2x1bW5dLmdldENvZGV3b3JkcygpW2NvZGV3b3Jkc1Jvd107XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29kZXdvcmQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZXdvcmQuc2V0Um93TnVtYmVyKExSSWNvZGV3b3Jkc1tjb2Rld29yZHNSb3ddLmdldFJvd051bWJlcigpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY29kZXdvcmQuaGFzVmFsaWRSb3dOdW1iZXIoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGV0ZWN0aW9uUmVzdWx0Q29sdW1uc1tiYXJjb2RlQ29sdW1uXS5nZXRDb2Rld29yZHMoKVtjb2Rld29yZHNSb3ddID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhZGp1c3RSb3dOdW1iZXJzRnJvbVJSSSgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRldGVjdGlvblJlc3VsdENvbHVtbnNbdGhpcy5iYXJjb2RlQ29sdW1uQ291bnQgKyAxXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgdW5hZGp1c3RlZENvdW50ID0gMDtcbiAgICAgICAgICAgIGxldCBjb2Rld29yZHMgPSB0aGlzLmRldGVjdGlvblJlc3VsdENvbHVtbnNbdGhpcy5iYXJjb2RlQ29sdW1uQ291bnQgKyAxXS5nZXRDb2Rld29yZHMoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGNvZGV3b3Jkc1JvdyAvKmludCovID0gMDsgY29kZXdvcmRzUm93IDwgY29kZXdvcmRzLmxlbmd0aDsgY29kZXdvcmRzUm93KyspIHtcbiAgICAgICAgICAgICAgICBpZiAoY29kZXdvcmRzW2NvZGV3b3Jkc1Jvd10gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IHJvd0luZGljYXRvclJvd051bWJlciA9IGNvZGV3b3Jkc1tjb2Rld29yZHNSb3ddLmdldFJvd051bWJlcigpO1xuICAgICAgICAgICAgICAgIGxldCBpbnZhbGlkUm93Q291bnRzID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBiYXJjb2RlQ29sdW1uIC8qaW50Ki8gPSB0aGlzLmJhcmNvZGVDb2x1bW5Db3VudCArIDE7IGJhcmNvZGVDb2x1bW4gPiAwICYmIGludmFsaWRSb3dDb3VudHMgPCB0aGlzLkFESlVTVF9ST1dfTlVNQkVSX1NLSVA7IGJhcmNvZGVDb2x1bW4tLSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgY29kZXdvcmQgPSB0aGlzLmRldGVjdGlvblJlc3VsdENvbHVtbnNbYmFyY29kZUNvbHVtbl0uZ2V0Q29kZXdvcmRzKClbY29kZXdvcmRzUm93XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGV3b3JkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludmFsaWRSb3dDb3VudHMgPSBEZXRlY3Rpb25SZXN1bHQuYWRqdXN0Um93TnVtYmVySWZWYWxpZChyb3dJbmRpY2F0b3JSb3dOdW1iZXIsIGludmFsaWRSb3dDb3VudHMsIGNvZGV3b3JkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY29kZXdvcmQuaGFzVmFsaWRSb3dOdW1iZXIoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuYWRqdXN0ZWRDb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHVuYWRqdXN0ZWRDb3VudDtcbiAgICAgICAgfVxuICAgICAgICBhZGp1c3RSb3dOdW1iZXJzRnJvbUxSSSgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRldGVjdGlvblJlc3VsdENvbHVtbnNbMF0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHVuYWRqdXN0ZWRDb3VudCA9IDA7XG4gICAgICAgICAgICBsZXQgY29kZXdvcmRzID0gdGhpcy5kZXRlY3Rpb25SZXN1bHRDb2x1bW5zWzBdLmdldENvZGV3b3JkcygpO1xuICAgICAgICAgICAgZm9yIChsZXQgY29kZXdvcmRzUm93IC8qaW50Ki8gPSAwOyBjb2Rld29yZHNSb3cgPCBjb2Rld29yZHMubGVuZ3RoOyBjb2Rld29yZHNSb3crKykge1xuICAgICAgICAgICAgICAgIGlmIChjb2Rld29yZHNbY29kZXdvcmRzUm93XSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgcm93SW5kaWNhdG9yUm93TnVtYmVyID0gY29kZXdvcmRzW2NvZGV3b3Jkc1Jvd10uZ2V0Um93TnVtYmVyKCk7XG4gICAgICAgICAgICAgICAgbGV0IGludmFsaWRSb3dDb3VudHMgPSAwO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGJhcmNvZGVDb2x1bW4gLyppbnQqLyA9IDE7IGJhcmNvZGVDb2x1bW4gPCB0aGlzLmJhcmNvZGVDb2x1bW5Db3VudCArIDEgJiYgaW52YWxpZFJvd0NvdW50cyA8IHRoaXMuQURKVVNUX1JPV19OVU1CRVJfU0tJUDsgYmFyY29kZUNvbHVtbisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjb2Rld29yZCA9IHRoaXMuZGV0ZWN0aW9uUmVzdWx0Q29sdW1uc1tiYXJjb2RlQ29sdW1uXS5nZXRDb2Rld29yZHMoKVtjb2Rld29yZHNSb3ddO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29kZXdvcmQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW52YWxpZFJvd0NvdW50cyA9IERldGVjdGlvblJlc3VsdC5hZGp1c3RSb3dOdW1iZXJJZlZhbGlkKHJvd0luZGljYXRvclJvd051bWJlciwgaW52YWxpZFJvd0NvdW50cywgY29kZXdvcmQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjb2Rld29yZC5oYXNWYWxpZFJvd051bWJlcigpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5hZGp1c3RlZENvdW50Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdW5hZGp1c3RlZENvdW50O1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBhZGp1c3RSb3dOdW1iZXJJZlZhbGlkKHJvd0luZGljYXRvclJvd051bWJlciwgaW52YWxpZFJvd0NvdW50cywgY29kZXdvcmQpIHtcbiAgICAgICAgICAgIGlmIChjb2Rld29yZCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGludmFsaWRSb3dDb3VudHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWNvZGV3b3JkLmhhc1ZhbGlkUm93TnVtYmVyKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29kZXdvcmQuaXNWYWxpZFJvd051bWJlcihyb3dJbmRpY2F0b3JSb3dOdW1iZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGV3b3JkLnNldFJvd051bWJlcihyb3dJbmRpY2F0b3JSb3dOdW1iZXIpO1xuICAgICAgICAgICAgICAgICAgICBpbnZhbGlkUm93Q291bnRzID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICsraW52YWxpZFJvd0NvdW50cztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaW52YWxpZFJvd0NvdW50cztcbiAgICAgICAgfVxuICAgICAgICBhZGp1c3RSb3dOdW1iZXJzKGJhcmNvZGVDb2x1bW4sIGNvZGV3b3Jkc1JvdywgY29kZXdvcmRzKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuZGV0ZWN0aW9uUmVzdWx0Q29sdW1uc1tiYXJjb2RlQ29sdW1uIC0gMV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgY29kZXdvcmQgPSBjb2Rld29yZHNbY29kZXdvcmRzUm93XTtcbiAgICAgICAgICAgIGxldCBwcmV2aW91c0NvbHVtbkNvZGV3b3JkcyA9IHRoaXMuZGV0ZWN0aW9uUmVzdWx0Q29sdW1uc1tiYXJjb2RlQ29sdW1uIC0gMV0uZ2V0Q29kZXdvcmRzKCk7XG4gICAgICAgICAgICBsZXQgbmV4dENvbHVtbkNvZGV3b3JkcyA9IHByZXZpb3VzQ29sdW1uQ29kZXdvcmRzO1xuICAgICAgICAgICAgaWYgKHRoaXMuZGV0ZWN0aW9uUmVzdWx0Q29sdW1uc1tiYXJjb2RlQ29sdW1uICsgMV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG5leHRDb2x1bW5Db2Rld29yZHMgPSB0aGlzLmRldGVjdGlvblJlc3VsdENvbHVtbnNbYmFyY29kZUNvbHVtbiArIDFdLmdldENvZGV3b3JkcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gbGV0IG90aGVyQ29kZXdvcmRzOiBDb2Rld29yZFtdID0gbmV3IENvZGV3b3JkWzE0XTtcbiAgICAgICAgICAgIGxldCBvdGhlckNvZGV3b3JkcyA9IG5ldyBBcnJheSgxNCk7XG4gICAgICAgICAgICBvdGhlckNvZGV3b3Jkc1syXSA9IHByZXZpb3VzQ29sdW1uQ29kZXdvcmRzW2NvZGV3b3Jkc1Jvd107XG4gICAgICAgICAgICBvdGhlckNvZGV3b3Jkc1szXSA9IG5leHRDb2x1bW5Db2Rld29yZHNbY29kZXdvcmRzUm93XTtcbiAgICAgICAgICAgIGlmIChjb2Rld29yZHNSb3cgPiAwKSB7XG4gICAgICAgICAgICAgICAgb3RoZXJDb2Rld29yZHNbMF0gPSBjb2Rld29yZHNbY29kZXdvcmRzUm93IC0gMV07XG4gICAgICAgICAgICAgICAgb3RoZXJDb2Rld29yZHNbNF0gPSBwcmV2aW91c0NvbHVtbkNvZGV3b3Jkc1tjb2Rld29yZHNSb3cgLSAxXTtcbiAgICAgICAgICAgICAgICBvdGhlckNvZGV3b3Jkc1s1XSA9IG5leHRDb2x1bW5Db2Rld29yZHNbY29kZXdvcmRzUm93IC0gMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29kZXdvcmRzUm93ID4gMSkge1xuICAgICAgICAgICAgICAgIG90aGVyQ29kZXdvcmRzWzhdID0gY29kZXdvcmRzW2NvZGV3b3Jkc1JvdyAtIDJdO1xuICAgICAgICAgICAgICAgIG90aGVyQ29kZXdvcmRzWzEwXSA9IHByZXZpb3VzQ29sdW1uQ29kZXdvcmRzW2NvZGV3b3Jkc1JvdyAtIDJdO1xuICAgICAgICAgICAgICAgIG90aGVyQ29kZXdvcmRzWzExXSA9IG5leHRDb2x1bW5Db2Rld29yZHNbY29kZXdvcmRzUm93IC0gMl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29kZXdvcmRzUm93IDwgY29kZXdvcmRzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICBvdGhlckNvZGV3b3Jkc1sxXSA9IGNvZGV3b3Jkc1tjb2Rld29yZHNSb3cgKyAxXTtcbiAgICAgICAgICAgICAgICBvdGhlckNvZGV3b3Jkc1s2XSA9IHByZXZpb3VzQ29sdW1uQ29kZXdvcmRzW2NvZGV3b3Jkc1JvdyArIDFdO1xuICAgICAgICAgICAgICAgIG90aGVyQ29kZXdvcmRzWzddID0gbmV4dENvbHVtbkNvZGV3b3Jkc1tjb2Rld29yZHNSb3cgKyAxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb2Rld29yZHNSb3cgPCBjb2Rld29yZHMubGVuZ3RoIC0gMikge1xuICAgICAgICAgICAgICAgIG90aGVyQ29kZXdvcmRzWzldID0gY29kZXdvcmRzW2NvZGV3b3Jkc1JvdyArIDJdO1xuICAgICAgICAgICAgICAgIG90aGVyQ29kZXdvcmRzWzEyXSA9IHByZXZpb3VzQ29sdW1uQ29kZXdvcmRzW2NvZGV3b3Jkc1JvdyArIDJdO1xuICAgICAgICAgICAgICAgIG90aGVyQ29kZXdvcmRzWzEzXSA9IG5leHRDb2x1bW5Db2Rld29yZHNbY29kZXdvcmRzUm93ICsgMl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBvdGhlckNvZGV3b3JkIG9mIG90aGVyQ29kZXdvcmRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKERldGVjdGlvblJlc3VsdC5hZGp1c3RSb3dOdW1iZXIoY29kZXdvcmQsIG90aGVyQ29kZXdvcmQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gdHJ1ZSwgaWYgcm93IG51bWJlciB3YXMgYWRqdXN0ZWQsIGZhbHNlIG90aGVyd2lzZVxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGFkanVzdFJvd051bWJlcihjb2Rld29yZCwgb3RoZXJDb2Rld29yZCkge1xuICAgICAgICAgICAgaWYgKG90aGVyQ29kZXdvcmQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvdGhlckNvZGV3b3JkLmhhc1ZhbGlkUm93TnVtYmVyKCkgJiYgb3RoZXJDb2Rld29yZC5nZXRCdWNrZXQoKSA9PT0gY29kZXdvcmQuZ2V0QnVja2V0KCkpIHtcbiAgICAgICAgICAgICAgICBjb2Rld29yZC5zZXRSb3dOdW1iZXIob3RoZXJDb2Rld29yZC5nZXRSb3dOdW1iZXIoKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0QmFyY29kZUNvbHVtbkNvdW50KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmFyY29kZUNvbHVtbkNvdW50O1xuICAgICAgICB9XG4gICAgICAgIGdldEJhcmNvZGVSb3dDb3VudCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJhcmNvZGVNZXRhZGF0YS5nZXRSb3dDb3VudCgpO1xuICAgICAgICB9XG4gICAgICAgIGdldEJhcmNvZGVFQ0xldmVsKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmFyY29kZU1ldGFkYXRhLmdldEVycm9yQ29ycmVjdGlvbkxldmVsKCk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0Qm91bmRpbmdCb3goYm91bmRpbmdCb3gpIHtcbiAgICAgICAgICAgIHRoaXMuYm91bmRpbmdCb3ggPSBib3VuZGluZ0JveDtcbiAgICAgICAgfVxuICAgICAgICBnZXRCb3VuZGluZ0JveCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJvdW5kaW5nQm94O1xuICAgICAgICB9XG4gICAgICAgIHNldERldGVjdGlvblJlc3VsdENvbHVtbihiYXJjb2RlQ29sdW1uLCBkZXRlY3Rpb25SZXN1bHRDb2x1bW4pIHtcbiAgICAgICAgICAgIHRoaXMuZGV0ZWN0aW9uUmVzdWx0Q29sdW1uc1tiYXJjb2RlQ29sdW1uXSA9IGRldGVjdGlvblJlc3VsdENvbHVtbjtcbiAgICAgICAgfVxuICAgICAgICBnZXREZXRlY3Rpb25SZXN1bHRDb2x1bW4oYmFyY29kZUNvbHVtbikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGV0ZWN0aW9uUmVzdWx0Q29sdW1uc1tiYXJjb2RlQ29sdW1uXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBAT3ZlcnJpZGVcbiAgICAgICAgdG9TdHJpbmcoKSB7XG4gICAgICAgICAgICBsZXQgcm93SW5kaWNhdG9yQ29sdW1uID0gdGhpcy5kZXRlY3Rpb25SZXN1bHRDb2x1bW5zWzBdO1xuICAgICAgICAgICAgaWYgKHJvd0luZGljYXRvckNvbHVtbiA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcm93SW5kaWNhdG9yQ29sdW1uID0gdGhpcy5kZXRlY3Rpb25SZXN1bHRDb2x1bW5zW3RoaXMuYmFyY29kZUNvbHVtbkNvdW50ICsgMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0cnkgKFxuICAgICAgICAgICAgbGV0IGZvcm1hdHRlciA9IG5ldyBGb3JtYXR0ZXIoKTtcbiAgICAgICAgICAgIC8vICkge1xuICAgICAgICAgICAgZm9yIChsZXQgY29kZXdvcmRzUm93IC8qaW50Ki8gPSAwOyBjb2Rld29yZHNSb3cgPCByb3dJbmRpY2F0b3JDb2x1bW4uZ2V0Q29kZXdvcmRzKCkubGVuZ3RoOyBjb2Rld29yZHNSb3crKykge1xuICAgICAgICAgICAgICAgIGZvcm1hdHRlci5mb3JtYXQoJ0NXICUzZDonLCBjb2Rld29yZHNSb3cpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGJhcmNvZGVDb2x1bW4gLyppbnQqLyA9IDA7IGJhcmNvZGVDb2x1bW4gPCB0aGlzLmJhcmNvZGVDb2x1bW5Db3VudCArIDI7IGJhcmNvZGVDb2x1bW4rKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5kZXRlY3Rpb25SZXN1bHRDb2x1bW5zW2JhcmNvZGVDb2x1bW5dID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1hdHRlci5mb3JtYXQoJyAgICB8ICAgJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsZXQgY29kZXdvcmQgPSB0aGlzLmRldGVjdGlvblJlc3VsdENvbHVtbnNbYmFyY29kZUNvbHVtbl0uZ2V0Q29kZXdvcmRzKClbY29kZXdvcmRzUm93XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGV3b3JkID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1hdHRlci5mb3JtYXQoJyAgICB8ICAgJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmb3JtYXR0ZXIuZm9ybWF0KCcgJTNkfCUzZCcsIGNvZGV3b3JkLmdldFJvd051bWJlcigpLCBjb2Rld29yZC5nZXRWYWx1ZSgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9ybWF0dGVyLmZvcm1hdCgnJW4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmb3JtYXR0ZXIudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIC8vIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qXG4gICAgICogQ29weXJpZ2h0IDIwMTMgWlhpbmcgYXV0aG9yc1xuICAgICAqXG4gICAgICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgICAgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICAgICpcbiAgICAgKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICAgICAqXG4gICAgICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICAgICAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgICAgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgICAgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gICAgICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gICAgICovXG4gICAgLy8gcGFja2FnZSBjb20uZ29vZ2xlLnp4aW5nLnBkZjQxNy5kZWNvZGVyO1xuICAgIC8qKlxuICAgICAqIEBhdXRob3IgR3VlbnRoZXIgR3JhdVxuICAgICAqL1xuICAgIC8qZmluYWwqLyBjbGFzcyBDb2Rld29yZCB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHN0YXJ0WCwgZW5kWCwgYnVja2V0LCB2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5yb3dOdW1iZXIgPSBDb2Rld29yZC5CQVJDT0RFX1JPV19VTktOT1dOO1xuICAgICAgICAgICAgdGhpcy5zdGFydFggPSBNYXRoLnRydW5jKHN0YXJ0WCk7XG4gICAgICAgICAgICB0aGlzLmVuZFggPSBNYXRoLnRydW5jKGVuZFgpO1xuICAgICAgICAgICAgdGhpcy5idWNrZXQgPSBNYXRoLnRydW5jKGJ1Y2tldCk7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gTWF0aC50cnVuYyh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaGFzVmFsaWRSb3dOdW1iZXIoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkUm93TnVtYmVyKHRoaXMucm93TnVtYmVyKTtcbiAgICAgICAgfVxuICAgICAgICBpc1ZhbGlkUm93TnVtYmVyKHJvd051bWJlcikge1xuICAgICAgICAgICAgcmV0dXJuIHJvd051bWJlciAhPT0gQ29kZXdvcmQuQkFSQ09ERV9ST1dfVU5LTk9XTiAmJiB0aGlzLmJ1Y2tldCA9PT0gKHJvd051bWJlciAlIDMpICogMztcbiAgICAgICAgfVxuICAgICAgICBzZXRSb3dOdW1iZXJBc1Jvd0luZGljYXRvckNvbHVtbigpIHtcbiAgICAgICAgICAgIHRoaXMucm93TnVtYmVyID0gTWF0aC50cnVuYygoTWF0aC50cnVuYyh0aGlzLnZhbHVlIC8gMzApKSAqIDMgKyBNYXRoLnRydW5jKHRoaXMuYnVja2V0IC8gMykpO1xuICAgICAgICB9XG4gICAgICAgIGdldFdpZHRoKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5kWCAtIHRoaXMuc3RhcnRYO1xuICAgICAgICB9XG4gICAgICAgIGdldFN0YXJ0WCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YXJ0WDtcbiAgICAgICAgfVxuICAgICAgICBnZXRFbmRYKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5kWDtcbiAgICAgICAgfVxuICAgICAgICBnZXRCdWNrZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5idWNrZXQ7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0VmFsdWUoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBnZXRSb3dOdW1iZXIoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yb3dOdW1iZXI7XG4gICAgICAgIH1cbiAgICAgICAgc2V0Um93TnVtYmVyKHJvd051bWJlcikge1xuICAgICAgICAgICAgdGhpcy5yb3dOdW1iZXIgPSByb3dOdW1iZXI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gICBAT3ZlcnJpZGVcbiAgICAgICAgdG9TdHJpbmcoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yb3dOdW1iZXIgKyAnfCcgKyB0aGlzLnZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIENvZGV3b3JkLkJBUkNPREVfUk9XX1VOS05PV04gPSAtMTtcblxuICAgIC8qXG4gICAgKiBDb3B5cmlnaHQgMjAxMyBaWGluZyBhdXRob3JzXG4gICAgKlxuICAgICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgICAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgICAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgICpcbiAgICAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gICAgKlxuICAgICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICAgICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gICAgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gICAgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAgICAqL1xuICAgIC8qKlxuICAgICAqIEBhdXRob3IgR3VlbnRoZXIgR3JhdVxuICAgICAqIEBhdXRob3IgY3JlYXRhbGUgR21iSCAoY2hyaXN0b3BoLnNjaHVsekBjcmVhdGFsZS5kZSlcbiAgICAgKi9cbiAgICAvKmZpbmFsKi8gY2xhc3MgUERGNDE3Q29kZXdvcmREZWNvZGVyIHtcbiAgICAgICAgLyogQG5vdGVcbiAgICAgICAgICogdGhpcyBhY3Rpb24gaGF2ZSB0byBiZSBwZXJmb3JtZWQgYmVmb3JlIGZpcnN0IHVzZSBvZiBjbGFzc1xuICAgICAgICAgKiAtIHN0YXRpYyBjb25zdHJ1Y3RvclxuICAgICAgICAgKiB3b3JraW5nIHdpdGggMzJiaXQgZmxvYXQgKGJhc2VkIGZyb20gSmF2YSBsb2dpYylcbiAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGluaXRpYWxpemUoKSB7XG4gICAgICAgICAgICAvLyBQcmUtY29tcHV0ZXMgdGhlIHN5bWJvbCByYXRpbyB0YWJsZS5cbiAgICAgICAgICAgIGZvciAoIC8qaW50Ki9sZXQgaSA9IDA7IGkgPCBQREY0MTdDb21tb24uU1lNQk9MX1RBQkxFLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGN1cnJlbnRTeW1ib2wgPSBQREY0MTdDb21tb24uU1lNQk9MX1RBQkxFW2ldO1xuICAgICAgICAgICAgICAgIGxldCBjdXJyZW50Qml0ID0gY3VycmVudFN5bWJvbCAmIDB4MTtcbiAgICAgICAgICAgICAgICBmb3IgKCAvKmludCovbGV0IGogPSAwOyBqIDwgUERGNDE3Q29tbW9uLkJBUlNfSU5fTU9EVUxFOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNpemUgPSAwLjA7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICgoY3VycmVudFN5bWJvbCAmIDB4MSkgPT09IGN1cnJlbnRCaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpemUgKz0gMS4wO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFN5bWJvbCA+Pj0gMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Qml0ID0gY3VycmVudFN5bWJvbCAmIDB4MTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFQREY0MTdDb2Rld29yZERlY29kZXIuUkFUSU9TX1RBQkxFW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBQREY0MTdDb2Rld29yZERlY29kZXIuUkFUSU9TX1RBQkxFW2ldID0gbmV3IEFycmF5KFBERjQxN0NvbW1vbi5CQVJTX0lOX01PRFVMRSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgUERGNDE3Q29kZXdvcmREZWNvZGVyLlJBVElPU19UQUJMRVtpXVtQREY0MTdDb21tb24uQkFSU19JTl9NT0RVTEUgLSBqIC0gMV0gPSBNYXRoLmZyb3VuZChzaXplIC8gUERGNDE3Q29tbW9uLk1PRFVMRVNfSU5fQ09ERVdPUkQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYlN5bWJvbFRhYmxlUmVhZHkgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBnZXREZWNvZGVkVmFsdWUobW9kdWxlQml0Q291bnQpIHtcbiAgICAgICAgICAgIGxldCBkZWNvZGVkVmFsdWUgPSBQREY0MTdDb2Rld29yZERlY29kZXIuZ2V0RGVjb2RlZENvZGV3b3JkVmFsdWUoUERGNDE3Q29kZXdvcmREZWNvZGVyLnNhbXBsZUJpdENvdW50cyhtb2R1bGVCaXRDb3VudCkpO1xuICAgICAgICAgICAgaWYgKGRlY29kZWRWYWx1ZSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVjb2RlZFZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFBERjQxN0NvZGV3b3JkRGVjb2Rlci5nZXRDbG9zZXN0RGVjb2RlZFZhbHVlKG1vZHVsZUJpdENvdW50KTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgc2FtcGxlQml0Q291bnRzKG1vZHVsZUJpdENvdW50KSB7XG4gICAgICAgICAgICBsZXQgYml0Q291bnRTdW0gPSBNYXRoVXRpbHMuc3VtKG1vZHVsZUJpdENvdW50KTtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBuZXcgSW50MzJBcnJheShQREY0MTdDb21tb24uQkFSU19JTl9NT0RVTEUpO1xuICAgICAgICAgICAgbGV0IGJpdENvdW50SW5kZXggPSAwO1xuICAgICAgICAgICAgbGV0IHN1bVByZXZpb3VzQml0cyA9IDA7XG4gICAgICAgICAgICBmb3IgKCAvKmludCovbGV0IGkgPSAwOyBpIDwgUERGNDE3Q29tbW9uLk1PRFVMRVNfSU5fQ09ERVdPUkQ7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBzYW1wbGVJbmRleCA9IGJpdENvdW50U3VtIC8gKDIgKiBQREY0MTdDb21tb24uTU9EVUxFU19JTl9DT0RFV09SRCkgK1xuICAgICAgICAgICAgICAgICAgICAoaSAqIGJpdENvdW50U3VtKSAvIFBERjQxN0NvbW1vbi5NT0RVTEVTX0lOX0NPREVXT1JEO1xuICAgICAgICAgICAgICAgIGlmIChzdW1QcmV2aW91c0JpdHMgKyBtb2R1bGVCaXRDb3VudFtiaXRDb3VudEluZGV4XSA8PSBzYW1wbGVJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBzdW1QcmV2aW91c0JpdHMgKz0gbW9kdWxlQml0Q291bnRbYml0Q291bnRJbmRleF07XG4gICAgICAgICAgICAgICAgICAgIGJpdENvdW50SW5kZXgrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0W2JpdENvdW50SW5kZXhdKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBnZXREZWNvZGVkQ29kZXdvcmRWYWx1ZShtb2R1bGVCaXRDb3VudCkge1xuICAgICAgICAgICAgbGV0IGRlY29kZWRWYWx1ZSA9IFBERjQxN0NvZGV3b3JkRGVjb2Rlci5nZXRCaXRWYWx1ZShtb2R1bGVCaXRDb3VudCk7XG4gICAgICAgICAgICByZXR1cm4gUERGNDE3Q29tbW9uLmdldENvZGV3b3JkKGRlY29kZWRWYWx1ZSkgPT09IC0xID8gLTEgOiBkZWNvZGVkVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGdldEJpdFZhbHVlKG1vZHVsZUJpdENvdW50KSB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gLypsb25nKi8gMDtcbiAgICAgICAgICAgIGZvciAobGV0IC8qaW50Ki8gaSA9IDA7IGkgPCBtb2R1bGVCaXRDb3VudC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGZvciAoIC8qaW50Ki9sZXQgYml0ID0gMDsgYml0IDwgbW9kdWxlQml0Q291bnRbaV07IGJpdCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IChyZXN1bHQgPDwgMSkgfCAoaSAlIDIgPT09IDAgPyAxIDogMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIE1hdGgudHJ1bmMocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyB3b3JraW5nIHdpdGggMzJiaXQgZmxvYXQgKGFzIGluIEphdmEpXG4gICAgICAgIHN0YXRpYyBnZXRDbG9zZXN0RGVjb2RlZFZhbHVlKG1vZHVsZUJpdENvdW50KSB7XG4gICAgICAgICAgICBsZXQgYml0Q291bnRTdW0gPSBNYXRoVXRpbHMuc3VtKG1vZHVsZUJpdENvdW50KTtcbiAgICAgICAgICAgIGxldCBiaXRDb3VudFJhdGlvcyA9IG5ldyBBcnJheShQREY0MTdDb21tb24uQkFSU19JTl9NT0RVTEUpO1xuICAgICAgICAgICAgaWYgKGJpdENvdW50U3VtID4gMSkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IC8qaW50Ki8gaSA9IDA7IGkgPCBiaXRDb3VudFJhdGlvcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBiaXRDb3VudFJhdGlvc1tpXSA9IE1hdGguZnJvdW5kKG1vZHVsZUJpdENvdW50W2ldIC8gYml0Q291bnRTdW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBiZXN0TWF0Y2hFcnJvciA9IEZsb2F0Lk1BWF9WQUxVRTtcbiAgICAgICAgICAgIGxldCBiZXN0TWF0Y2ggPSAtMTtcbiAgICAgICAgICAgIGlmICghdGhpcy5iU3ltYm9sVGFibGVSZWFkeSkge1xuICAgICAgICAgICAgICAgIFBERjQxN0NvZGV3b3JkRGVjb2Rlci5pbml0aWFsaXplKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKCAvKmludCovbGV0IGogPSAwOyBqIDwgUERGNDE3Q29kZXdvcmREZWNvZGVyLlJBVElPU19UQUJMRS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIGxldCBlcnJvciA9IDAuMDtcbiAgICAgICAgICAgICAgICBsZXQgcmF0aW9UYWJsZVJvdyA9IFBERjQxN0NvZGV3b3JkRGVjb2Rlci5SQVRJT1NfVEFCTEVbal07XG4gICAgICAgICAgICAgICAgZm9yICggLyppbnQqL2xldCBrID0gMDsgayA8IFBERjQxN0NvbW1vbi5CQVJTX0lOX01PRFVMRTsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkaWZmID0gTWF0aC5mcm91bmQocmF0aW9UYWJsZVJvd1trXSAtIGJpdENvdW50UmF0aW9zW2tdKTtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IgKz0gTWF0aC5mcm91bmQoZGlmZiAqIGRpZmYpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IgPj0gYmVzdE1hdGNoRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChlcnJvciA8IGJlc3RNYXRjaEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaEVycm9yID0gZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaCA9IFBERjQxN0NvbW1vbi5TWU1CT0xfVEFCTEVbal07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGJlc3RNYXRjaDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBmbGFnIHRoYXQgdGhlIHRhYmxlIGlzIHJlYWR5IGZvciB1c2VcbiAgICBQREY0MTdDb2Rld29yZERlY29kZXIuYlN5bWJvbFRhYmxlUmVhZHkgPSBmYWxzZTtcbiAgICBQREY0MTdDb2Rld29yZERlY29kZXIuUkFUSU9TX1RBQkxFID0gbmV3IEFycmF5KFBERjQxN0NvbW1vbi5TWU1CT0xfVEFCTEUubGVuZ3RoKS5tYXAoeCA9PiB4ID0gbmV3IEFycmF5KFBERjQxN0NvbW1vbi5CQVJTX0lOX01PRFVMRSkpO1xuXG4gICAgLypcbiAgICAgKiBDb3B5cmlnaHQgMjAxMyBaWGluZyBhdXRob3JzXG4gICAgICpcbiAgICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgICAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgICAgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgICAgKlxuICAgICAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gICAgICpcbiAgICAgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICAgICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgICAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICAgICAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgICAgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAgICAgKi9cbiAgICAvLyBwYWNrYWdlIGNvbS5nb29nbGUuenhpbmcucGRmNDE3O1xuICAgIC8qKlxuICAgICAqIEBhdXRob3IgR3VlbnRoZXIgR3JhdVxuICAgICAqL1xuICAgIC8qcHVibGljIGZpbmFsKi8gY2xhc3MgUERGNDE3UmVzdWx0TWV0YWRhdGEge1xuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgICAgIHRoaXMuc2VnbWVudENvdW50ID0gLTE7XG4gICAgICAgICAgICB0aGlzLmZpbGVTaXplID0gLTE7XG4gICAgICAgICAgICB0aGlzLnRpbWVzdGFtcCA9IC0xO1xuICAgICAgICAgICAgdGhpcy5jaGVja3N1bSA9IC0xO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgU2VnbWVudCBJRCByZXByZXNlbnRzIHRoZSBzZWdtZW50IG9mIHRoZSB3aG9sZSBmaWxlIGRpc3RyaWJ1dGVkIG92ZXIgZGlmZmVyZW50IHN5bWJvbHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4gRmlsZSBzZWdtZW50IGluZGV4XG4gICAgICAgICAqL1xuICAgICAgICBnZXRTZWdtZW50SW5kZXgoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZWdtZW50SW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgc2V0U2VnbWVudEluZGV4KHNlZ21lbnRJbmRleCkge1xuICAgICAgICAgICAgdGhpcy5zZWdtZW50SW5kZXggPSBzZWdtZW50SW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElzIHRoZSBzYW1lIGZvciBlYWNoIHJlbGF0ZWQgUERGNDE3IHN5bWJvbFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIEZpbGUgSURcbiAgICAgICAgICovXG4gICAgICAgIGdldEZpbGVJZCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbGVJZDtcbiAgICAgICAgfVxuICAgICAgICBzZXRGaWxlSWQoZmlsZUlkKSB7XG4gICAgICAgICAgICB0aGlzLmZpbGVJZCA9IGZpbGVJZDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiBhbHdheXMgbnVsbFxuICAgICAgICAgKiBAZGVwcmVjYXRlZCB1c2UgZGVkaWNhdGVkIGFscmVhZHkgcGFyc2VkIGZpZWxkc1xuICAgICAgICAgKi9cbiAgICAgICAgLy8gICBARGVwcmVjYXRlZFxuICAgICAgICBnZXRPcHRpb25hbERhdGEoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25hbERhdGE7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSBvcHRpb25hbERhdGEgb2xkIG9wdGlvbmFsIGRhdGEgZm9ybWF0IGFzIGludCBhcnJheVxuICAgICAgICAgKiBAZGVwcmVjYXRlZCBwYXJzZSBhbmQgdXNlIG5ldyBmaWVsZHNcbiAgICAgICAgICovXG4gICAgICAgIC8vICAgQERlcHJlY2F0ZWRcbiAgICAgICAgc2V0T3B0aW9uYWxEYXRhKG9wdGlvbmFsRGF0YSkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25hbERhdGEgPSBvcHRpb25hbERhdGE7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gdHJ1ZSBpZiBpdCBpcyB0aGUgbGFzdCBzZWdtZW50XG4gICAgICAgICAqL1xuICAgICAgICBpc0xhc3RTZWdtZW50KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGFzdFNlZ21lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgc2V0TGFzdFNlZ21lbnQobGFzdFNlZ21lbnQpIHtcbiAgICAgICAgICAgIHRoaXMubGFzdFNlZ21lbnQgPSBsYXN0U2VnbWVudDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiBjb3VudCBvZiBzZWdtZW50cywgLTEgaWYgbm90IHNldFxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0U2VnbWVudENvdW50KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VnbWVudENvdW50O1xuICAgICAgICB9XG4gICAgICAgIHNldFNlZ21lbnRDb3VudChzZWdtZW50Q291bnQgLyppbnQqLykge1xuICAgICAgICAgICAgdGhpcy5zZWdtZW50Q291bnQgPSBzZWdtZW50Q291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0U2VuZGVyKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VuZGVyIHx8IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgc2V0U2VuZGVyKHNlbmRlcikge1xuICAgICAgICAgICAgdGhpcy5zZW5kZXIgPSBzZW5kZXI7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0QWRkcmVzc2VlKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkcmVzc2VlIHx8IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgc2V0QWRkcmVzc2VlKGFkZHJlc3NlZSkge1xuICAgICAgICAgICAgdGhpcy5hZGRyZXNzZWUgPSBhZGRyZXNzZWU7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpbGVuYW1lIG9mIHRoZSBlbmNvZGVkIGZpbGVcbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiBmaWxlbmFtZVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0RmlsZU5hbWUoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maWxlTmFtZTtcbiAgICAgICAgfVxuICAgICAgICBzZXRGaWxlTmFtZShmaWxlTmFtZSkge1xuICAgICAgICAgICAgdGhpcy5maWxlTmFtZSA9IGZpbGVOYW1lO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBmaWxlc2l6ZSBpbiBieXRlcyBvZiB0aGUgZW5jb2RlZCBmaWxlXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4gZmlsZXNpemUgaW4gYnl0ZXMsIC0xIGlmIG5vdCBzZXRcbiAgICAgICAgICovXG4gICAgICAgIGdldEZpbGVTaXplKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmlsZVNpemU7XG4gICAgICAgIH1cbiAgICAgICAgc2V0RmlsZVNpemUoZmlsZVNpemUgLypsb25nKi8pIHtcbiAgICAgICAgICAgIHRoaXMuZmlsZVNpemUgPSBmaWxlU2l6ZTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogMTYtYml0IENSQyBjaGVja3N1bSB1c2luZyBDQ0lUVC0xNlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIGNyYyBjaGVja3N1bSwgLTEgaWYgbm90IHNldFxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0Q2hlY2tzdW0oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jaGVja3N1bTtcbiAgICAgICAgfVxuICAgICAgICBzZXRDaGVja3N1bShjaGVja3N1bSAvKmludCovKSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrc3VtID0gY2hlY2tzdW07XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHVuaXggZXBvY2sgdGltZXN0YW1wLCBlbGFwc2VkIHNlY29uZHMgc2luY2UgMTk3MC0wMS0wMVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIGVsYXBzZWQgc2Vjb25kcywgLTEgaWYgbm90IHNldFxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0VGltZXN0YW1wKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudGltZXN0YW1wO1xuICAgICAgICB9XG4gICAgICAgIHNldFRpbWVzdGFtcCh0aW1lc3RhbXAgLypsb25nKi8pIHtcbiAgICAgICAgICAgIHRoaXMudGltZXN0YW1wID0gdGltZXN0YW1wO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUG9ueWZpbGwgZm9yIEphdmEncyBMb25nIGNsYXNzLlxuICAgICAqL1xuICAgIGNsYXNzIExvbmcge1xuICAgICAgICAvKipcbiAgICAgICAgICogUGFyc2VzIGEgc3RyaW5nIHRvIGEgbnVtYmVyLCBzaW5jZSBKUyBoYXMgbm8gcmVhbGx5IEludDY0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gbnVtIE51bWVyaWMgc3RyaW5nLlxuICAgICAgICAgKiBAcGFyYW0gcmFkaXggRGVzdGluYXRpb24gcmFkaXguXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgcGFyc2VMb25nKG51bSwgcmFkaXggPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUludChudW0sIHJhZGl4KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEN1c3RvbSBFcnJvciBjbGFzcyBvZiB0eXBlIEV4Y2VwdGlvbi5cbiAgICAgKi9cbiAgICBjbGFzcyBOdWxsUG9pbnRlckV4Y2VwdGlvbiBleHRlbmRzIEV4Y2VwdGlvbiB7XG4gICAgfVxuICAgIE51bGxQb2ludGVyRXhjZXB0aW9uLmtpbmQgPSAnTnVsbFBvaW50ZXJFeGNlcHRpb24nO1xuXG4gICAgLypcbiAgICAgKiBDb3B5cmlnaHQgKGMpIDE5OTQsIDIwMDQsIE9yYWNsZSBhbmQvb3IgaXRzIGFmZmlsaWF0ZXMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gICAgICogRE8gTk9UIEFMVEVSIE9SIFJFTU9WRSBDT1BZUklHSFQgTk9USUNFUyBPUiBUSElTIEZJTEUgSEVBREVSLlxuICAgICAqXG4gICAgICogVGhpcyBjb2RlIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICAgKiB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMiBvbmx5LCBhc1xuICAgICAqIHB1Ymxpc2hlZCBieSB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLiAgT3JhY2xlIGRlc2lnbmF0ZXMgdGhpc1xuICAgICAqIHBhcnRpY3VsYXIgZmlsZSBhcyBzdWJqZWN0IHRvIHRoZSBcIkNsYXNzcGF0aFwiIGV4Y2VwdGlvbiBhcyBwcm92aWRlZFxuICAgICAqIGJ5IE9yYWNsZSBpbiB0aGUgTElDRU5TRSBmaWxlIHRoYXQgYWNjb21wYW5pZWQgdGhpcyBjb2RlLlxuICAgICAqXG4gICAgICogVGhpcyBjb2RlIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUXG4gICAgICogQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZIG9yXG4gICAgICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgICogdmVyc2lvbiAyIGZvciBtb3JlIGRldGFpbHMgKGEgY29weSBpcyBpbmNsdWRlZCBpbiB0aGUgTElDRU5TRSBmaWxlIHRoYXRcbiAgICAgKiBhY2NvbXBhbmllZCB0aGlzIGNvZGUpLlxuICAgICAqXG4gICAgICogWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvblxuICAgICAqIDIgYWxvbmcgd2l0aCB0aGlzIHdvcms7IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbixcbiAgICAgKiBJbmMuLCA1MSBGcmFua2xpbiBTdCwgRmlmdGggRmxvb3IsIEJvc3RvbiwgTUEgMDIxMTAtMTMwMSBVU0EuXG4gICAgICpcbiAgICAgKiBQbGVhc2UgY29udGFjdCBPcmFjbGUsIDUwMCBPcmFjbGUgUGFya3dheSwgUmVkd29vZCBTaG9yZXMsIENBIDk0MDY1IFVTQVxuICAgICAqIG9yIHZpc2l0IHd3dy5vcmFjbGUuY29tIGlmIHlvdSBuZWVkIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gb3IgaGF2ZSBhbnlcbiAgICAgKiBxdWVzdGlvbnMuXG4gICAgICovXG4gICAgLy8gcGFja2FnZSBqYXZhLmlvO1xuICAgIC8qKlxuICAgICAqIFRoaXMgYWJzdHJhY3QgY2xhc3MgaXMgdGhlIHN1cGVyY2xhc3Mgb2YgYWxsIGNsYXNzZXMgcmVwcmVzZW50aW5nXG4gICAgICogYW4gb3V0cHV0IHN0cmVhbSBvZiBieXRlcy4gQW4gb3V0cHV0IHN0cmVhbSBhY2NlcHRzIG91dHB1dCBieXRlc1xuICAgICAqIGFuZCBzZW5kcyB0aGVtIHRvIHNvbWUgc2luay5cbiAgICAgKiA8cD5cbiAgICAgKiBBcHBsaWNhdGlvbnMgdGhhdCBuZWVkIHRvIGRlZmluZSBhIHN1YmNsYXNzIG9mXG4gICAgICogPGNvZGU+T3V0cHV0U3RyZWFtPC9jb2RlPiBtdXN0IGFsd2F5cyBwcm92aWRlIGF0IGxlYXN0IGEgbWV0aG9kXG4gICAgICogdGhhdCB3cml0ZXMgb25lIGJ5dGUgb2Ygb3V0cHV0LlxuICAgICAqXG4gICAgICogQGF1dGhvciAgQXJ0aHVyIHZhbiBIb2ZmXG4gICAgICogQHNlZSAgICAgamF2YS5pby5CdWZmZXJlZE91dHB1dFN0cmVhbVxuICAgICAqIEBzZWUgICAgIGphdmEuaW8uQnl0ZUFycmF5T3V0cHV0U3RyZWFtXG4gICAgICogQHNlZSAgICAgamF2YS5pby5EYXRhT3V0cHV0U3RyZWFtXG4gICAgICogQHNlZSAgICAgamF2YS5pby5GaWx0ZXJPdXRwdXRTdHJlYW1cbiAgICAgKiBAc2VlICAgICBqYXZhLmlvLklucHV0U3RyZWFtXG4gICAgICogQHNlZSAgICAgamF2YS5pby5PdXRwdXRTdHJlYW0jd3JpdGUoaW50KVxuICAgICAqIEBzaW5jZSAgIEpESzEuMFxuICAgICAqL1xuICAgIC8qcHVibGljKi8gY2xhc3MgT3V0cHV0U3RyZWFtIC8qaW1wbGVtZW50cyBDbG9zZWFibGUsIEZsdXNoYWJsZSovIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdyaXRlcyA8Y29kZT5iLmxlbmd0aDwvY29kZT4gYnl0ZXMgZnJvbSB0aGUgc3BlY2lmaWVkIGJ5dGUgYXJyYXlcbiAgICAgICAgICogdG8gdGhpcyBvdXRwdXQgc3RyZWFtLiBUaGUgZ2VuZXJhbCBjb250cmFjdCBmb3IgPGNvZGU+d3JpdGUoYik8L2NvZGU+XG4gICAgICAgICAqIGlzIHRoYXQgaXQgc2hvdWxkIGhhdmUgZXhhY3RseSB0aGUgc2FtZSBlZmZlY3QgYXMgdGhlIGNhbGxcbiAgICAgICAgICogPGNvZGU+d3JpdGUoYiwgMCwgYi5sZW5ndGgpPC9jb2RlPi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtICAgICAgYiAgIHRoZSBkYXRhLlxuICAgICAgICAgKiBAZXhjZXB0aW9uICBJT0V4Y2VwdGlvbiAgaWYgYW4gSS9PIGVycm9yIG9jY3Vycy5cbiAgICAgICAgICogQHNlZSAgICAgICAgamF2YS5pby5PdXRwdXRTdHJlYW0jd3JpdGUoYnl0ZVtdLCBpbnQsIGludClcbiAgICAgICAgICovXG4gICAgICAgIHdyaXRlQnl0ZXMoYikge1xuICAgICAgICAgICAgdGhpcy53cml0ZUJ5dGVzT2Zmc2V0KGIsIDAsIGIubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogV3JpdGVzIDxjb2RlPmxlbjwvY29kZT4gYnl0ZXMgZnJvbSB0aGUgc3BlY2lmaWVkIGJ5dGUgYXJyYXlcbiAgICAgICAgICogc3RhcnRpbmcgYXQgb2Zmc2V0IDxjb2RlPm9mZjwvY29kZT4gdG8gdGhpcyBvdXRwdXQgc3RyZWFtLlxuICAgICAgICAgKiBUaGUgZ2VuZXJhbCBjb250cmFjdCBmb3IgPGNvZGU+d3JpdGUoYiwgb2ZmLCBsZW4pPC9jb2RlPiBpcyB0aGF0XG4gICAgICAgICAqIHNvbWUgb2YgdGhlIGJ5dGVzIGluIHRoZSBhcnJheSA8Y29kZT5iPC9jb2RlPiBhcmUgd3JpdHRlbiB0byB0aGVcbiAgICAgICAgICogb3V0cHV0IHN0cmVhbSBpbiBvcmRlcjsgZWxlbWVudCA8Y29kZT5iW29mZl08L2NvZGU+IGlzIHRoZSBmaXJzdFxuICAgICAgICAgKiBieXRlIHdyaXR0ZW4gYW5kIDxjb2RlPmJbb2ZmK2xlbi0xXTwvY29kZT4gaXMgdGhlIGxhc3QgYnl0ZSB3cml0dGVuXG4gICAgICAgICAqIGJ5IHRoaXMgb3BlcmF0aW9uLlxuICAgICAgICAgKiA8cD5cbiAgICAgICAgICogVGhlIDxjb2RlPndyaXRlPC9jb2RlPiBtZXRob2Qgb2YgPGNvZGU+T3V0cHV0U3RyZWFtPC9jb2RlPiBjYWxsc1xuICAgICAgICAgKiB0aGUgd3JpdGUgbWV0aG9kIG9mIG9uZSBhcmd1bWVudCBvbiBlYWNoIG9mIHRoZSBieXRlcyB0byBiZVxuICAgICAgICAgKiB3cml0dGVuIG91dC4gU3ViY2xhc3NlcyBhcmUgZW5jb3VyYWdlZCB0byBvdmVycmlkZSB0aGlzIG1ldGhvZCBhbmRcbiAgICAgICAgICogcHJvdmlkZSBhIG1vcmUgZWZmaWNpZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgICAgKiA8cD5cbiAgICAgICAgICogSWYgPGNvZGU+YjwvY29kZT4gaXMgPGNvZGU+bnVsbDwvY29kZT4sIGFcbiAgICAgICAgICogPGNvZGU+TnVsbFBvaW50ZXJFeGNlcHRpb248L2NvZGU+IGlzIHRocm93bi5cbiAgICAgICAgICogPHA+XG4gICAgICAgICAqIElmIDxjb2RlPm9mZjwvY29kZT4gaXMgbmVnYXRpdmUsIG9yIDxjb2RlPmxlbjwvY29kZT4gaXMgbmVnYXRpdmUsIG9yXG4gICAgICAgICAqIDxjb2RlPm9mZitsZW48L2NvZGU+IGlzIGdyZWF0ZXIgdGhhbiB0aGUgbGVuZ3RoIG9mIHRoZSBhcnJheVxuICAgICAgICAgKiA8Y29kZT5iPC9jb2RlPiwgdGhlbiBhbiA8dHQ+SW5kZXhPdXRPZkJvdW5kc0V4Y2VwdGlvbjwvdHQ+IGlzIHRocm93bi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtICAgICAgYiAgICAgdGhlIGRhdGEuXG4gICAgICAgICAqIEBwYXJhbSAgICAgIG9mZiAgIHRoZSBzdGFydCBvZmZzZXQgaW4gdGhlIGRhdGEuXG4gICAgICAgICAqIEBwYXJhbSAgICAgIGxlbiAgIHRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gd3JpdGUuXG4gICAgICAgICAqIEBleGNlcHRpb24gIElPRXhjZXB0aW9uICBpZiBhbiBJL08gZXJyb3Igb2NjdXJzLiBJbiBwYXJ0aWN1bGFyLFxuICAgICAgICAgKiAgICAgICAgICAgICBhbiA8Y29kZT5JT0V4Y2VwdGlvbjwvY29kZT4gaXMgdGhyb3duIGlmIHRoZSBvdXRwdXRcbiAgICAgICAgICogICAgICAgICAgICAgc3RyZWFtIGlzIGNsb3NlZC5cbiAgICAgICAgICovXG4gICAgICAgIHdyaXRlQnl0ZXNPZmZzZXQoYiwgb2ZmLCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChiID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTnVsbFBvaW50ZXJFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKChvZmYgPCAwKSB8fCAob2ZmID4gYi5sZW5ndGgpIHx8IChsZW4gPCAwKSB8fFxuICAgICAgICAgICAgICAgICgob2ZmICsgbGVuKSA+IGIubGVuZ3RoKSB8fCAoKG9mZiArIGxlbikgPCAwKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbmRleE91dE9mQm91bmRzRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChsZW4gPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy53cml0ZShiW29mZiArIGldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogRmx1c2hlcyB0aGlzIG91dHB1dCBzdHJlYW0gYW5kIGZvcmNlcyBhbnkgYnVmZmVyZWQgb3V0cHV0IGJ5dGVzXG4gICAgICAgICAqIHRvIGJlIHdyaXR0ZW4gb3V0LiBUaGUgZ2VuZXJhbCBjb250cmFjdCBvZiA8Y29kZT5mbHVzaDwvY29kZT4gaXNcbiAgICAgICAgICogdGhhdCBjYWxsaW5nIGl0IGlzIGFuIGluZGljYXRpb24gdGhhdCwgaWYgYW55IGJ5dGVzIHByZXZpb3VzbHlcbiAgICAgICAgICogd3JpdHRlbiBoYXZlIGJlZW4gYnVmZmVyZWQgYnkgdGhlIGltcGxlbWVudGF0aW9uIG9mIHRoZSBvdXRwdXRcbiAgICAgICAgICogc3RyZWFtLCBzdWNoIGJ5dGVzIHNob3VsZCBpbW1lZGlhdGVseSBiZSB3cml0dGVuIHRvIHRoZWlyXG4gICAgICAgICAqIGludGVuZGVkIGRlc3RpbmF0aW9uLlxuICAgICAgICAgKiA8cD5cbiAgICAgICAgICogSWYgdGhlIGludGVuZGVkIGRlc3RpbmF0aW9uIG9mIHRoaXMgc3RyZWFtIGlzIGFuIGFic3RyYWN0aW9uIHByb3ZpZGVkIGJ5XG4gICAgICAgICAqIHRoZSB1bmRlcmx5aW5nIG9wZXJhdGluZyBzeXN0ZW0sIGZvciBleGFtcGxlIGEgZmlsZSwgdGhlbiBmbHVzaGluZyB0aGVcbiAgICAgICAgICogc3RyZWFtIGd1YXJhbnRlZXMgb25seSB0aGF0IGJ5dGVzIHByZXZpb3VzbHkgd3JpdHRlbiB0byB0aGUgc3RyZWFtIGFyZVxuICAgICAgICAgKiBwYXNzZWQgdG8gdGhlIG9wZXJhdGluZyBzeXN0ZW0gZm9yIHdyaXRpbmc7IGl0IGRvZXMgbm90IGd1YXJhbnRlZSB0aGF0XG4gICAgICAgICAqIHRoZXkgYXJlIGFjdHVhbGx5IHdyaXR0ZW4gdG8gYSBwaHlzaWNhbCBkZXZpY2Ugc3VjaCBhcyBhIGRpc2sgZHJpdmUuXG4gICAgICAgICAqIDxwPlxuICAgICAgICAgKiBUaGUgPGNvZGU+Zmx1c2g8L2NvZGU+IG1ldGhvZCBvZiA8Y29kZT5PdXRwdXRTdHJlYW08L2NvZGU+IGRvZXMgbm90aGluZy5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4Y2VwdGlvbiAgSU9FeGNlcHRpb24gIGlmIGFuIEkvTyBlcnJvciBvY2N1cnMuXG4gICAgICAgICAqL1xuICAgICAgICBmbHVzaCgpIHtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ2xvc2VzIHRoaXMgb3V0cHV0IHN0cmVhbSBhbmQgcmVsZWFzZXMgYW55IHN5c3RlbSByZXNvdXJjZXNcbiAgICAgICAgICogYXNzb2NpYXRlZCB3aXRoIHRoaXMgc3RyZWFtLiBUaGUgZ2VuZXJhbCBjb250cmFjdCBvZiA8Y29kZT5jbG9zZTwvY29kZT5cbiAgICAgICAgICogaXMgdGhhdCBpdCBjbG9zZXMgdGhlIG91dHB1dCBzdHJlYW0uIEEgY2xvc2VkIHN0cmVhbSBjYW5ub3QgcGVyZm9ybVxuICAgICAgICAgKiBvdXRwdXQgb3BlcmF0aW9ucyBhbmQgY2Fubm90IGJlIHJlb3BlbmVkLlxuICAgICAgICAgKiA8cD5cbiAgICAgICAgICogVGhlIDxjb2RlPmNsb3NlPC9jb2RlPiBtZXRob2Qgb2YgPGNvZGU+T3V0cHV0U3RyZWFtPC9jb2RlPiBkb2VzIG5vdGhpbmcuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGNlcHRpb24gIElPRXhjZXB0aW9uICBpZiBhbiBJL08gZXJyb3Igb2NjdXJzLlxuICAgICAgICAgKi9cbiAgICAgICAgY2xvc2UoKSB7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDdXN0b20gRXJyb3IgY2xhc3Mgb2YgdHlwZSBFeGNlcHRpb24uXG4gICAgICovXG4gICAgY2xhc3MgT3V0T2ZNZW1vcnlFcnJvciBleHRlbmRzIEV4Y2VwdGlvbiB7XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBDb3B5cmlnaHQgKGMpIDE5OTQsIDIwMTAsIE9yYWNsZSBhbmQvb3IgaXRzIGFmZmlsaWF0ZXMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gICAgICogRE8gTk9UIEFMVEVSIE9SIFJFTU9WRSBDT1BZUklHSFQgTk9USUNFUyBPUiBUSElTIEZJTEUgSEVBREVSLlxuICAgICAqXG4gICAgICogVGhpcyBjb2RlIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICAgKiB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMiBvbmx5LCBhc1xuICAgICAqIHB1Ymxpc2hlZCBieSB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLiAgT3JhY2xlIGRlc2lnbmF0ZXMgdGhpc1xuICAgICAqIHBhcnRpY3VsYXIgZmlsZSBhcyBzdWJqZWN0IHRvIHRoZSBcIkNsYXNzcGF0aFwiIGV4Y2VwdGlvbiBhcyBwcm92aWRlZFxuICAgICAqIGJ5IE9yYWNsZSBpbiB0aGUgTElDRU5TRSBmaWxlIHRoYXQgYWNjb21wYW5pZWQgdGhpcyBjb2RlLlxuICAgICAqXG4gICAgICogVGhpcyBjb2RlIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUXG4gICAgICogQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZIG9yXG4gICAgICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgICogdmVyc2lvbiAyIGZvciBtb3JlIGRldGFpbHMgKGEgY29weSBpcyBpbmNsdWRlZCBpbiB0aGUgTElDRU5TRSBmaWxlIHRoYXRcbiAgICAgKiBhY2NvbXBhbmllZCB0aGlzIGNvZGUpLlxuICAgICAqXG4gICAgICogWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvblxuICAgICAqIDIgYWxvbmcgd2l0aCB0aGlzIHdvcms7IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbixcbiAgICAgKiBJbmMuLCA1MSBGcmFua2xpbiBTdCwgRmlmdGggRmxvb3IsIEJvc3RvbiwgTUEgMDIxMTAtMTMwMSBVU0EuXG4gICAgICpcbiAgICAgKiBQbGVhc2UgY29udGFjdCBPcmFjbGUsIDUwMCBPcmFjbGUgUGFya3dheSwgUmVkd29vZCBTaG9yZXMsIENBIDk0MDY1IFVTQVxuICAgICAqIG9yIHZpc2l0IHd3dy5vcmFjbGUuY29tIGlmIHlvdSBuZWVkIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gb3IgaGF2ZSBhbnlcbiAgICAgKiBxdWVzdGlvbnMuXG4gICAgICovXG4gICAgLyoqXG4gICAgICogVGhpcyBjbGFzcyBpbXBsZW1lbnRzIGFuIG91dHB1dCBzdHJlYW0gaW4gd2hpY2ggdGhlIGRhdGEgaXNcbiAgICAgKiB3cml0dGVuIGludG8gYSBieXRlIGFycmF5LiBUaGUgYnVmZmVyIGF1dG9tYXRpY2FsbHkgZ3Jvd3MgYXMgZGF0YVxuICAgICAqIGlzIHdyaXR0ZW4gdG8gaXQuXG4gICAgICogVGhlIGRhdGEgY2FuIGJlIHJldHJpZXZlZCB1c2luZyA8Y29kZT50b0J5dGVBcnJheSgpPC9jb2RlPiBhbmRcbiAgICAgKiA8Y29kZT50b1N0cmluZygpPC9jb2RlPi5cbiAgICAgKiA8cD5cbiAgICAgKiBDbG9zaW5nIGEgPHR0PkJ5dGVBcnJheU91dHB1dFN0cmVhbTwvdHQ+IGhhcyBubyBlZmZlY3QuIFRoZSBtZXRob2RzIGluXG4gICAgICogdGhpcyBjbGFzcyBjYW4gYmUgY2FsbGVkIGFmdGVyIHRoZSBzdHJlYW0gaGFzIGJlZW4gY2xvc2VkIHdpdGhvdXRcbiAgICAgKiBnZW5lcmF0aW5nIGFuIDx0dD5JT0V4Y2VwdGlvbjwvdHQ+LlxuICAgICAqXG4gICAgICogQGF1dGhvciAgQXJ0aHVyIHZhbiBIb2ZmXG4gICAgICogQHNpbmNlICAgSkRLMS4wXG4gICAgICovXG4gICAgLypwdWJsaWMqLyBjbGFzcyBCeXRlQXJyYXlPdXRwdXRTdHJlYW0gZXh0ZW5kcyBPdXRwdXRTdHJlYW0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIG5ldyBieXRlIGFycmF5IG91dHB1dCBzdHJlYW0uIFRoZSBidWZmZXIgY2FwYWNpdHkgaXNcbiAgICAgICAgICogaW5pdGlhbGx5IDMyIGJ5dGVzLCB0aG91Z2ggaXRzIHNpemUgaW5jcmVhc2VzIGlmIG5lY2Vzc2FyeS5cbiAgICAgICAgICovXG4gICAgICAgIC8vIHB1YmxpYyBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgLy8gICAgIHRoaXMoMzIpO1xuICAgICAgICAvLyB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgbmV3IGJ5dGUgYXJyYXkgb3V0cHV0IHN0cmVhbSwgd2l0aCBhIGJ1ZmZlciBjYXBhY2l0eSBvZlxuICAgICAgICAgKiB0aGUgc3BlY2lmaWVkIHNpemUsIGluIGJ5dGVzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gICBzaXplICAgdGhlIGluaXRpYWwgc2l6ZS5cbiAgICAgICAgICogQGV4Y2VwdGlvbiAgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uIGlmIHNpemUgaXMgbmVnYXRpdmUuXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdHJ1Y3RvcihzaXplID0gMzIpIHtcbiAgICAgICAgICAgIHN1cGVyKCk7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRoZSBudW1iZXIgb2YgdmFsaWQgYnl0ZXMgaW4gdGhlIGJ1ZmZlci5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5jb3VudCA9IDA7XG4gICAgICAgICAgICBpZiAoc2l6ZSA8IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCdOZWdhdGl2ZSBpbml0aWFsIHNpemU6ICdcbiAgICAgICAgICAgICAgICAgICAgKyBzaXplKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYnVmID0gbmV3IFVpbnQ4QXJyYXkoc2l6ZSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluY3JlYXNlcyB0aGUgY2FwYWNpdHkgaWYgbmVjZXNzYXJ5IHRvIGVuc3VyZSB0aGF0IGl0IGNhbiBob2xkXG4gICAgICAgICAqIGF0IGxlYXN0IHRoZSBudW1iZXIgb2YgZWxlbWVudHMgc3BlY2lmaWVkIGJ5IHRoZSBtaW5pbXVtXG4gICAgICAgICAqIGNhcGFjaXR5IGFyZ3VtZW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gbWluQ2FwYWNpdHkgdGhlIGRlc2lyZWQgbWluaW11bSBjYXBhY2l0eVxuICAgICAgICAgKiBAdGhyb3dzIE91dE9mTWVtb3J5RXJyb3IgaWYge0Bjb2RlIG1pbkNhcGFjaXR5IDwgMH0uICBUaGlzIGlzXG4gICAgICAgICAqIGludGVycHJldGVkIGFzIGEgcmVxdWVzdCBmb3IgdGhlIHVuc2F0aXNmaWFibHkgbGFyZ2UgY2FwYWNpdHlcbiAgICAgICAgICoge0Bjb2RlIChsb25nKSBJbnRlZ2VyLk1BWF9WQUxVRSArIChtaW5DYXBhY2l0eSAtIEludGVnZXIuTUFYX1ZBTFVFKX0uXG4gICAgICAgICAqL1xuICAgICAgICBlbnN1cmVDYXBhY2l0eShtaW5DYXBhY2l0eSkge1xuICAgICAgICAgICAgLy8gb3ZlcmZsb3ctY29uc2Npb3VzIGNvZGVcbiAgICAgICAgICAgIGlmIChtaW5DYXBhY2l0eSAtIHRoaXMuYnVmLmxlbmd0aCA+IDApXG4gICAgICAgICAgICAgICAgdGhpcy5ncm93KG1pbkNhcGFjaXR5KTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogSW5jcmVhc2VzIHRoZSBjYXBhY2l0eSB0byBlbnN1cmUgdGhhdCBpdCBjYW4gaG9sZCBhdCBsZWFzdCB0aGVcbiAgICAgICAgICogbnVtYmVyIG9mIGVsZW1lbnRzIHNwZWNpZmllZCBieSB0aGUgbWluaW11bSBjYXBhY2l0eSBhcmd1bWVudC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIG1pbkNhcGFjaXR5IHRoZSBkZXNpcmVkIG1pbmltdW0gY2FwYWNpdHlcbiAgICAgICAgICovXG4gICAgICAgIGdyb3cobWluQ2FwYWNpdHkpIHtcbiAgICAgICAgICAgIC8vIG92ZXJmbG93LWNvbnNjaW91cyBjb2RlXG4gICAgICAgICAgICBsZXQgb2xkQ2FwYWNpdHkgPSB0aGlzLmJ1Zi5sZW5ndGg7XG4gICAgICAgICAgICBsZXQgbmV3Q2FwYWNpdHkgPSBvbGRDYXBhY2l0eSA8PCAxO1xuICAgICAgICAgICAgaWYgKG5ld0NhcGFjaXR5IC0gbWluQ2FwYWNpdHkgPCAwKVxuICAgICAgICAgICAgICAgIG5ld0NhcGFjaXR5ID0gbWluQ2FwYWNpdHk7XG4gICAgICAgICAgICBpZiAobmV3Q2FwYWNpdHkgPCAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1pbkNhcGFjaXR5IDwgMCkgLy8gb3ZlcmZsb3dcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE91dE9mTWVtb3J5RXJyb3IoKTtcbiAgICAgICAgICAgICAgICBuZXdDYXBhY2l0eSA9IEludGVnZXIuTUFYX1ZBTFVFO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5idWYgPSBBcnJheXMuY29weU9mVWludDhBcnJheSh0aGlzLmJ1ZiwgbmV3Q2FwYWNpdHkpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXcml0ZXMgdGhlIHNwZWNpZmllZCBieXRlIHRvIHRoaXMgYnl0ZSBhcnJheSBvdXRwdXQgc3RyZWFtLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gICBiICAgdGhlIGJ5dGUgdG8gYmUgd3JpdHRlbi5cbiAgICAgICAgICovXG4gICAgICAgIHdyaXRlKGIpIHtcbiAgICAgICAgICAgIHRoaXMuZW5zdXJlQ2FwYWNpdHkodGhpcy5jb3VudCArIDEpO1xuICAgICAgICAgICAgdGhpcy5idWZbdGhpcy5jb3VudF0gPSAvKihieXRlKSovIGI7XG4gICAgICAgICAgICB0aGlzLmNvdW50ICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdyaXRlcyA8Y29kZT5sZW48L2NvZGU+IGJ5dGVzIGZyb20gdGhlIHNwZWNpZmllZCBieXRlIGFycmF5XG4gICAgICAgICAqIHN0YXJ0aW5nIGF0IG9mZnNldCA8Y29kZT5vZmY8L2NvZGU+IHRvIHRoaXMgYnl0ZSBhcnJheSBvdXRwdXQgc3RyZWFtLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gICBiICAgICB0aGUgZGF0YS5cbiAgICAgICAgICogQHBhcmFtICAgb2ZmICAgdGhlIHN0YXJ0IG9mZnNldCBpbiB0aGUgZGF0YS5cbiAgICAgICAgICogQHBhcmFtICAgbGVuICAgdGhlIG51bWJlciBvZiBieXRlcyB0byB3cml0ZS5cbiAgICAgICAgICovXG4gICAgICAgIHdyaXRlQnl0ZXNPZmZzZXQoYiwgb2ZmLCBsZW4pIHtcbiAgICAgICAgICAgIGlmICgob2ZmIDwgMCkgfHwgKG9mZiA+IGIubGVuZ3RoKSB8fCAobGVuIDwgMCkgfHxcbiAgICAgICAgICAgICAgICAoKG9mZiArIGxlbikgLSBiLmxlbmd0aCA+IDApKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEluZGV4T3V0T2ZCb3VuZHNFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZW5zdXJlQ2FwYWNpdHkodGhpcy5jb3VudCArIGxlbik7XG4gICAgICAgICAgICBTeXN0ZW0uYXJyYXljb3B5KGIsIG9mZiwgdGhpcy5idWYsIHRoaXMuY291bnQsIGxlbik7XG4gICAgICAgICAgICB0aGlzLmNvdW50ICs9IGxlbjtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogV3JpdGVzIHRoZSBjb21wbGV0ZSBjb250ZW50cyBvZiB0aGlzIGJ5dGUgYXJyYXkgb3V0cHV0IHN0cmVhbSB0b1xuICAgICAgICAgKiB0aGUgc3BlY2lmaWVkIG91dHB1dCBzdHJlYW0gYXJndW1lbnQsIGFzIGlmIGJ5IGNhbGxpbmcgdGhlIG91dHB1dFxuICAgICAgICAgKiBzdHJlYW0ncyB3cml0ZSBtZXRob2QgdXNpbmcgPGNvZGU+b3V0LndyaXRlKGJ1ZiwgMCwgY291bnQpPC9jb2RlPi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtICAgICAgb3V0ICAgdGhlIG91dHB1dCBzdHJlYW0gdG8gd2hpY2ggdG8gd3JpdGUgdGhlIGRhdGEuXG4gICAgICAgICAqIEBleGNlcHRpb24gIElPRXhjZXB0aW9uICBpZiBhbiBJL08gZXJyb3Igb2NjdXJzLlxuICAgICAgICAgKi9cbiAgICAgICAgd3JpdGVUbyhvdXQpIHtcbiAgICAgICAgICAgIG91dC53cml0ZUJ5dGVzT2Zmc2V0KHRoaXMuYnVmLCAwLCB0aGlzLmNvdW50KTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUmVzZXRzIHRoZSA8Y29kZT5jb3VudDwvY29kZT4gZmllbGQgb2YgdGhpcyBieXRlIGFycmF5IG91dHB1dFxuICAgICAgICAgKiBzdHJlYW0gdG8gemVybywgc28gdGhhdCBhbGwgY3VycmVudGx5IGFjY3VtdWxhdGVkIG91dHB1dCBpbiB0aGVcbiAgICAgICAgICogb3V0cHV0IHN0cmVhbSBpcyBkaXNjYXJkZWQuIFRoZSBvdXRwdXQgc3RyZWFtIGNhbiBiZSB1c2VkIGFnYWluLFxuICAgICAgICAgKiByZXVzaW5nIHRoZSBhbHJlYWR5IGFsbG9jYXRlZCBidWZmZXIgc3BhY2UuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBzZWUgICAgIGphdmEuaW8uQnl0ZUFycmF5SW5wdXRTdHJlYW0jY291bnRcbiAgICAgICAgICovXG4gICAgICAgIHJlc2V0KCkge1xuICAgICAgICAgICAgdGhpcy5jb3VudCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBuZXdseSBhbGxvY2F0ZWQgYnl0ZSBhcnJheS4gSXRzIHNpemUgaXMgdGhlIGN1cnJlbnRcbiAgICAgICAgICogc2l6ZSBvZiB0aGlzIG91dHB1dCBzdHJlYW0gYW5kIHRoZSB2YWxpZCBjb250ZW50cyBvZiB0aGUgYnVmZmVyXG4gICAgICAgICAqIGhhdmUgYmVlbiBjb3BpZWQgaW50byBpdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiAgdGhlIGN1cnJlbnQgY29udGVudHMgb2YgdGhpcyBvdXRwdXQgc3RyZWFtLCBhcyBhIGJ5dGUgYXJyYXkuXG4gICAgICAgICAqIEBzZWUgICAgIGphdmEuaW8uQnl0ZUFycmF5T3V0cHV0U3RyZWFtI3NpemUoKVxuICAgICAgICAgKi9cbiAgICAgICAgdG9CeXRlQXJyYXkoKSB7XG4gICAgICAgICAgICByZXR1cm4gQXJyYXlzLmNvcHlPZlVpbnQ4QXJyYXkodGhpcy5idWYsIHRoaXMuY291bnQpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHNpemUgb2YgdGhlIGJ1ZmZlci5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiAgdGhlIHZhbHVlIG9mIHRoZSA8Y29kZT5jb3VudDwvY29kZT4gZmllbGQsIHdoaWNoIGlzIHRoZSBudW1iZXJcbiAgICAgICAgICogICAgICAgICAgb2YgdmFsaWQgYnl0ZXMgaW4gdGhpcyBvdXRwdXQgc3RyZWFtLlxuICAgICAgICAgKiBAc2VlICAgICBqYXZhLmlvLkJ5dGVBcnJheU91dHB1dFN0cmVhbSNjb3VudFxuICAgICAgICAgKi9cbiAgICAgICAgc2l6ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvdW50O1xuICAgICAgICB9XG4gICAgICAgIHRvU3RyaW5nKHBhcmFtKSB7XG4gICAgICAgICAgICBpZiAoIXBhcmFtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9TdHJpbmdfdm9pZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXJhbSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50b1N0cmluZ19zdHJpbmcocGFyYW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9TdHJpbmdfbnVtYmVyKHBhcmFtKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ29udmVydHMgdGhlIGJ1ZmZlcidzIGNvbnRlbnRzIGludG8gYSBzdHJpbmcgZGVjb2RpbmcgYnl0ZXMgdXNpbmcgdGhlXG4gICAgICAgICAqIHBsYXRmb3JtJ3MgZGVmYXVsdCBjaGFyYWN0ZXIgc2V0LiBUaGUgbGVuZ3RoIG9mIHRoZSBuZXcgPHR0PlN0cmluZzwvdHQ+XG4gICAgICAgICAqIGlzIGEgZnVuY3Rpb24gb2YgdGhlIGNoYXJhY3RlciBzZXQsIGFuZCBoZW5jZSBtYXkgbm90IGJlIGVxdWFsIHRvIHRoZVxuICAgICAgICAgKiBzaXplIG9mIHRoZSBidWZmZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIDxwPiBUaGlzIG1ldGhvZCBhbHdheXMgcmVwbGFjZXMgbWFsZm9ybWVkLWlucHV0IGFuZCB1bm1hcHBhYmxlLWNoYXJhY3RlclxuICAgICAgICAgKiBzZXF1ZW5jZXMgd2l0aCB0aGUgZGVmYXVsdCByZXBsYWNlbWVudCBzdHJpbmcgZm9yIHRoZSBwbGF0Zm9ybSdzXG4gICAgICAgICAqIGRlZmF1bHQgY2hhcmFjdGVyIHNldC4gVGhlIHtAbGlua3BsYWluIGphdmEubmlvLmNoYXJzZXQuQ2hhcnNldERlY29kZXJ9XG4gICAgICAgICAqIGNsYXNzIHNob3VsZCBiZSB1c2VkIHdoZW4gbW9yZSBjb250cm9sIG92ZXIgdGhlIGRlY29kaW5nIHByb2Nlc3MgaXNcbiAgICAgICAgICogcmVxdWlyZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4gU3RyaW5nIGRlY29kZWQgZnJvbSB0aGUgYnVmZmVyJ3MgY29udGVudHMuXG4gICAgICAgICAqIEBzaW5jZSAgSkRLMS4xXG4gICAgICAgICAqL1xuICAgICAgICB0b1N0cmluZ192b2lkKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTdHJpbmcodGhpcy5idWYgLyosIDAsIHRoaXMuY291bnQqLykudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ29udmVydHMgdGhlIGJ1ZmZlcidzIGNvbnRlbnRzIGludG8gYSBzdHJpbmcgYnkgZGVjb2RpbmcgdGhlIGJ5dGVzIHVzaW5nXG4gICAgICAgICAqIHRoZSBzcGVjaWZpZWQge0BsaW5rIGphdmEubmlvLmNoYXJzZXQuQ2hhcnNldCBjaGFyc2V0TmFtZX0uIFRoZSBsZW5ndGggb2ZcbiAgICAgICAgICogdGhlIG5ldyA8dHQ+U3RyaW5nPC90dD4gaXMgYSBmdW5jdGlvbiBvZiB0aGUgY2hhcnNldCwgYW5kIGhlbmNlIG1heSBub3QgYmVcbiAgICAgICAgICogZXF1YWwgdG8gdGhlIGxlbmd0aCBvZiB0aGUgYnl0ZSBhcnJheS5cbiAgICAgICAgICpcbiAgICAgICAgICogPHA+IFRoaXMgbWV0aG9kIGFsd2F5cyByZXBsYWNlcyBtYWxmb3JtZWQtaW5wdXQgYW5kIHVubWFwcGFibGUtY2hhcmFjdGVyXG4gICAgICAgICAqIHNlcXVlbmNlcyB3aXRoIHRoaXMgY2hhcnNldCdzIGRlZmF1bHQgcmVwbGFjZW1lbnQgc3RyaW5nLiBUaGUge0BsaW5rXG4gICAgICAgICAqIGphdmEubmlvLmNoYXJzZXQuQ2hhcnNldERlY29kZXJ9IGNsYXNzIHNob3VsZCBiZSB1c2VkIHdoZW4gbW9yZSBjb250cm9sXG4gICAgICAgICAqIG92ZXIgdGhlIGRlY29kaW5nIHByb2Nlc3MgaXMgcmVxdWlyZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSAgY2hhcnNldE5hbWUgIHRoZSBuYW1lIG9mIGEgc3VwcG9ydGVkXG4gICAgICAgICAqICAgICAgICAgICAgICB7QGxpbmtwbGFpbiBqYXZhLm5pby5jaGFyc2V0LkNoYXJzZXQgPC9jb2RlPmNoYXJzZXQ8Y29kZT59XG4gICAgICAgICAqIEByZXR1cm4gU3RyaW5nIGRlY29kZWQgZnJvbSB0aGUgYnVmZmVyJ3MgY29udGVudHMuXG4gICAgICAgICAqIEBleGNlcHRpb24gIFVuc3VwcG9ydGVkRW5jb2RpbmdFeGNlcHRpb25cbiAgICAgICAgICogICAgICAgICAgICAgSWYgdGhlIG5hbWVkIGNoYXJzZXQgaXMgbm90IHN1cHBvcnRlZFxuICAgICAgICAgKiBAc2luY2UgICBKREsxLjFcbiAgICAgICAgICovXG4gICAgICAgIHRvU3RyaW5nX3N0cmluZyhjaGFyc2V0TmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTdHJpbmcodGhpcy5idWYgLyosIDAsIHRoaXMuY291bnQsIGNoYXJzZXROYW1lKi8pLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBuZXdseSBhbGxvY2F0ZWQgc3RyaW5nLiBJdHMgc2l6ZSBpcyB0aGUgY3VycmVudCBzaXplIG9mXG4gICAgICAgICAqIHRoZSBvdXRwdXQgc3RyZWFtIGFuZCB0aGUgdmFsaWQgY29udGVudHMgb2YgdGhlIGJ1ZmZlciBoYXZlIGJlZW5cbiAgICAgICAgICogY29waWVkIGludG8gaXQuIEVhY2ggY2hhcmFjdGVyIDxpPmM8L2k+IGluIHRoZSByZXN1bHRpbmcgc3RyaW5nIGlzXG4gICAgICAgICAqIGNvbnN0cnVjdGVkIGZyb20gdGhlIGNvcnJlc3BvbmRpbmcgZWxlbWVudCA8aT5iPC9pPiBpbiB0aGUgYnl0ZVxuICAgICAgICAgKiBhcnJheSBzdWNoIHRoYXQ6XG4gICAgICAgICAqIDxibG9ja3F1b3RlPjxwcmU+XG4gICAgICAgICAqICAgICBjID09IChjaGFyKSgoKGhpYnl0ZSAmYW1wOyAweGZmKSAmbHQ7Jmx0OyA4KSB8IChiICZhbXA7IDB4ZmYpKVxuICAgICAgICAgKiA8L3ByZT48L2Jsb2NrcXVvdGU+XG4gICAgICAgICAqXG4gICAgICAgICAqIEBkZXByZWNhdGVkIFRoaXMgbWV0aG9kIGRvZXMgbm90IHByb3Blcmx5IGNvbnZlcnQgYnl0ZXMgaW50byBjaGFyYWN0ZXJzLlxuICAgICAgICAgKiBBcyBvZiBKREsmbmJzcDsxLjEsIHRoZSBwcmVmZXJyZWQgd2F5IHRvIGRvIHRoaXMgaXMgdmlhIHRoZVxuICAgICAgICAgKiA8Y29kZT50b1N0cmluZyhTdHJpbmcgZW5jKTwvY29kZT4gbWV0aG9kLCB3aGljaCB0YWtlcyBhbiBlbmNvZGluZy1uYW1lXG4gICAgICAgICAqIGFyZ3VtZW50LCBvciB0aGUgPGNvZGU+dG9TdHJpbmcoKTwvY29kZT4gbWV0aG9kLCB3aGljaCB1c2VzIHRoZVxuICAgICAgICAgKiBwbGF0Zm9ybSdzIGRlZmF1bHQgY2hhcmFjdGVyIGVuY29kaW5nLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gICAgICBoaWJ5dGUgICAgdGhlIGhpZ2ggYnl0ZSBvZiBlYWNoIHJlc3VsdGluZyBVbmljb2RlIGNoYXJhY3Rlci5cbiAgICAgICAgICogQHJldHVybiAgICAgdGhlIGN1cnJlbnQgY29udGVudHMgb2YgdGhlIG91dHB1dCBzdHJlYW0sIGFzIGEgc3RyaW5nLlxuICAgICAgICAgKiBAc2VlICAgICAgICBqYXZhLmlvLkJ5dGVBcnJheU91dHB1dFN0cmVhbSNzaXplKClcbiAgICAgICAgICogQHNlZSAgICAgICAgamF2YS5pby5CeXRlQXJyYXlPdXRwdXRTdHJlYW0jdG9TdHJpbmcoU3RyaW5nKVxuICAgICAgICAgKiBAc2VlICAgICAgICBqYXZhLmlvLkJ5dGVBcnJheU91dHB1dFN0cmVhbSN0b1N0cmluZygpXG4gICAgICAgICAqL1xuICAgICAgICAvLyBARGVwcmVjYXRlZFxuICAgICAgICB0b1N0cmluZ19udW1iZXIoaGlieXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFN0cmluZyh0aGlzLmJ1ZiAvKiwgaGlieXRlLCAwLCB0aGlzLmNvdW50Ki8pLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENsb3NpbmcgYSA8dHQ+Qnl0ZUFycmF5T3V0cHV0U3RyZWFtPC90dD4gaGFzIG5vIGVmZmVjdC4gVGhlIG1ldGhvZHMgaW5cbiAgICAgICAgICogdGhpcyBjbGFzcyBjYW4gYmUgY2FsbGVkIGFmdGVyIHRoZSBzdHJlYW0gaGFzIGJlZW4gY2xvc2VkIHdpdGhvdXRcbiAgICAgICAgICogZ2VuZXJhdGluZyBhbiA8dHQ+SU9FeGNlcHRpb248L3R0Pi5cbiAgICAgICAgICogPHA+XG4gICAgICAgICAqXG4gICAgICAgICAqIEB0aHJvd3MgSU9FeGNlcHRpb25cbiAgICAgICAgICovXG4gICAgICAgIGNsb3NlKCkge1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBDb3B5cmlnaHQgMjAwOSBaWGluZyBhdXRob3JzXG4gICAgICpcbiAgICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgICAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgICAgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgICAgKlxuICAgICAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gICAgICpcbiAgICAgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICAgICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgICAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICAgICAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgICAgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAgICAgKi9cbiAgICAvKnByaXZhdGUqLyB2YXIgTW9kZSQyO1xuICAgIChmdW5jdGlvbiAoTW9kZSkge1xuICAgICAgICBNb2RlW01vZGVbXCJBTFBIQVwiXSA9IDBdID0gXCJBTFBIQVwiO1xuICAgICAgICBNb2RlW01vZGVbXCJMT1dFUlwiXSA9IDFdID0gXCJMT1dFUlwiO1xuICAgICAgICBNb2RlW01vZGVbXCJNSVhFRFwiXSA9IDJdID0gXCJNSVhFRFwiO1xuICAgICAgICBNb2RlW01vZGVbXCJQVU5DVFwiXSA9IDNdID0gXCJQVU5DVFwiO1xuICAgICAgICBNb2RlW01vZGVbXCJBTFBIQV9TSElGVFwiXSA9IDRdID0gXCJBTFBIQV9TSElGVFwiO1xuICAgICAgICBNb2RlW01vZGVbXCJQVU5DVF9TSElGVFwiXSA9IDVdID0gXCJQVU5DVF9TSElGVFwiO1xuICAgIH0pKE1vZGUkMiB8fCAoTW9kZSQyID0ge30pKTtcbiAgICAvKipcbiAgICAgKiBJbmRpcmVjdGx5IGFjY2VzcyB0aGUgZ2xvYmFsIEJpZ0ludCBjb25zdHJ1Y3RvciwgaXRcbiAgICAgKiBhbGxvd3MgYnJvd3NlcnMgdGhhdCBkb2Vzbid0IHN1cHBvcnQgQmlnSW50IHRvIHJ1blxuICAgICAqIHRoZSBsaWJyYXJ5IHdpdGhvdXQgYnJlYWtpbmcgZHVlIHRvIFwidW5kZWZpbmVkIEJpZ0ludFwiXG4gICAgICogZXJyb3JzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEJpZ0ludENvbnN0cnVjdG9yKCkge1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB3aW5kb3dbJ0JpZ0ludCddIHx8IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2xvYmFsWydCaWdJbnQnXSB8fCBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiBzZWxmWydCaWdJbnQnXSB8fCBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuXFwndCBzZWFyY2ggZ2xvYmFscyBmb3IgQmlnSW50IScpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIHN0b3JlIHRoZSBCaWdJbnQgY29uc3RydWN0b3IuXG4gICAgICovXG4gICAgbGV0IEJpZ0ludGVnZXI7XG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBjcmVhdGVzIGEgYmlnaW50IHZhbHVlLiBJdCBhbGxvd3MgYnJvd3NlcnNcbiAgICAgKiB0aGF0IGRvZXNuJ3Qgc3VwcG9ydCBCaWdJbnQgdG8gcnVuIHRoZSByZXN0IG9mIHRoZSBsaWJyYXJ5XG4gICAgICogYnkgbm90IGRpcmVjdGx5IGFjY2Vzc2luZyB0aGUgQmlnSW50IGNvbnN0cnVjdG9yLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUJpZ0ludChudW0pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBCaWdJbnRlZ2VyID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgQmlnSW50ZWdlciA9IGdldEJpZ0ludENvbnN0cnVjdG9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEJpZ0ludGVnZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQmlnSW50IGlzIG5vdCBzdXBwb3J0ZWQhJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEJpZ0ludGVnZXIobnVtKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0RVhQOTAwKCkge1xuICAgICAgICAvLyBpbiBKYXZhIC0gYXJyYXkgd2l0aCBsZW5ndGggPSAxNlxuICAgICAgICBsZXQgRVhQOTAwID0gW107XG4gICAgICAgIEVYUDkwMFswXSA9IGNyZWF0ZUJpZ0ludCgxKTtcbiAgICAgICAgbGV0IG5pbmVIdW5kcmVkID0gY3JlYXRlQmlnSW50KDkwMCk7XG4gICAgICAgIEVYUDkwMFsxXSA9IG5pbmVIdW5kcmVkO1xuICAgICAgICAvLyBpbiBKYXZhIC0gYXJyYXkgd2l0aCBsZW5ndGggPSAxNlxuICAgICAgICBmb3IgKGxldCBpIC8qaW50Ki8gPSAyOyBpIDwgMTY7IGkrKykge1xuICAgICAgICAgICAgRVhQOTAwW2ldID0gRVhQOTAwW2kgLSAxXSAqIG5pbmVIdW5kcmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBFWFA5MDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIDxwPlRoaXMgY2xhc3MgY29udGFpbnMgdGhlIG1ldGhvZHMgZm9yIGRlY29kaW5nIHRoZSBQREY0MTcgY29kZXdvcmRzLjwvcD5cbiAgICAgKlxuICAgICAqIEBhdXRob3IgU0lUQSBMYWIgKGtldmluLm9zdWxsaXZhbkBzaXRhLmFlcm8pXG4gICAgICogQGF1dGhvciBHdWVudGhlciBHcmF1XG4gICAgICovXG4gICAgLypmaW5hbCovIGNsYXNzIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMiB7XG4gICAgICAgIC8vICAgcHJpdmF0ZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyKCkge1xuICAgICAgICAvLyB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gY29kZXdvcmRzXG4gICAgICAgICAqIEBwYXJhbSBlY0xldmVsXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0aHJvd3MgRm9ybWF0RXhjZXB0aW9uXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgZGVjb2RlKGNvZGV3b3JkcywgZWNMZXZlbCkge1xuICAgICAgICAgICAgLy8gcGFzcyBlbmNvZGluZyB0byByZXN1bHQgKHdpbGwgYmUgdXNlZCBmb3IgZGVjb2RlIHN5bWJvbHMgaW4gYnl0ZSBtb2RlKVxuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IG5ldyBTdHJpbmdCdWlsZGVyKCcnKTtcbiAgICAgICAgICAgIC8vIGxldCBlbmNvZGluZzogQ2hhcnNldCA9IFN0YW5kYXJkQ2hhcnNldHMuSVNPXzg4NTlfMTtcbiAgICAgICAgICAgIGxldCBlbmNvZGluZyA9IENoYXJhY3RlclNldEVDSS5JU084ODU5XzE7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBub3RlIHRoZSBuZXh0IGNvbW1hbmQgaXMgc3BlY2lmaWMgZnJvbSB0aGlzIFR5cGVTY3JpcHQgbGlicmFyeVxuICAgICAgICAgICAgICogYmVjYXVzZSBUUyBjYW4ndCBwcm9wZXJseSBjYXN0IHNvbWUgdmFsdWVzIHRvIGNoYXIgYW5kXG4gICAgICAgICAgICAgKiBjb252ZXJ0IGl0IHRvIHN0cmluZyBsYXRlciBjb3JyZWN0bHkgZHVlIHRvIGVuY29kaW5nXG4gICAgICAgICAgICAgKiBkaWZmZXJlbmNlcyBmcm9tIEphdmEgdmVyc2lvbi4gQXMgcmVwb3J0ZWQgaGVyZTpcbiAgICAgICAgICAgICAqIGh0dHBzOi8vZ2l0aHViLmNvbS96eGluZy1qcy9saWJyYXJ5L3B1bGwvMjY0L2ZpbGVzI3IzODI4MzE1OTNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgcmVzdWx0LmVuYWJsZURlY29kaW5nKGVuY29kaW5nKTtcbiAgICAgICAgICAgIC8vIEdldCBjb21wYWN0aW9uIG1vZGVcbiAgICAgICAgICAgIGxldCBjb2RlSW5kZXggPSAxO1xuICAgICAgICAgICAgbGV0IGNvZGUgPSBjb2Rld29yZHNbY29kZUluZGV4KytdO1xuICAgICAgICAgICAgbGV0IHJlc3VsdE1ldGFkYXRhID0gbmV3IFBERjQxN1Jlc3VsdE1ldGFkYXRhKCk7XG4gICAgICAgICAgICB3aGlsZSAoY29kZUluZGV4IDwgY29kZXdvcmRzWzBdKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChjb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLlRFWFRfQ09NUEFDVElPTl9NT0RFX0xBVENIOlxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZUluZGV4ID0gRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLnRleHRDb21wYWN0aW9uKGNvZGV3b3JkcywgY29kZUluZGV4LCByZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLkJZVEVfQ09NUEFDVElPTl9NT0RFX0xBVENIOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5CWVRFX0NPTVBBQ1RJT05fTU9ERV9MQVRDSF82OlxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZUluZGV4ID0gRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLmJ5dGVDb21wYWN0aW9uKGNvZGUsIGNvZGV3b3JkcywgZW5jb2RpbmcsIGNvZGVJbmRleCwgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5NT0RFX1NISUZUX1RPX0JZVEVfQ09NUEFDVElPTl9NT0RFOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZCgvKihjaGFyKSovIGNvZGV3b3Jkc1tjb2RlSW5kZXgrK10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLk5VTUVSSUNfQ09NUEFDVElPTl9NT0RFX0xBVENIOlxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZUluZGV4ID0gRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLm51bWVyaWNDb21wYWN0aW9uKGNvZGV3b3JkcywgY29kZUluZGV4LCByZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLkVDSV9DSEFSU0VUOlxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNoYXJzZXRFQ0kgPSBDaGFyYWN0ZXJTZXRFQ0kuZ2V0Q2hhcmFjdGVyU2V0RUNJQnlWYWx1ZShjb2Rld29yZHNbY29kZUluZGV4KytdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVuY29kaW5nID0gQ2hhcnNldC5mb3JOYW1lKGNoYXJzZXRFQ0kuZ2V0TmFtZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5FQ0lfR0VORVJBTF9QVVJQT1NFOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2FuJ3QgZG8gYW55dGhpbmcgd2l0aCBnZW5lcmljIEVDSTsgc2tpcCBpdHMgMiBjaGFyYWN0ZXJzXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlSW5kZXggKz0gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5FQ0lfVVNFUl9ERUZJTkVEOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2FuJ3QgZG8gYW55dGhpbmcgd2l0aCB1c2VyIEVDSTsgc2tpcCBpdHMgMSBjaGFyYWN0ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLkJFR0lOX01BQ1JPX1BERjQxN19DT05UUk9MX0JMT0NLOlxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZUluZGV4ID0gRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLmRlY29kZU1hY3JvQmxvY2soY29kZXdvcmRzLCBjb2RlSW5kZXgsIHJlc3VsdE1ldGFkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5CRUdJTl9NQUNST19QREY0MTdfT1BUSU9OQUxfRklFTEQ6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLk1BQ1JPX1BERjQxN19URVJNSU5BVE9SOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2hvdWxkIG5vdCBzZWUgdGhlc2Ugb3V0c2lkZSBhIG1hY3JvIGJsb2NrXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBEZWZhdWx0IHRvIHRleHQgY29tcGFjdGlvbi4gRHVyaW5nIHRlc3RpbmcgbnVtZXJvdXMgYmFyY29kZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFwcGVhcmVkIHRvIGJlIG1pc3NpbmcgdGhlIHN0YXJ0aW5nIG1vZGUuIEluIHRoZXNlIGNhc2VzIGRlZmF1bHRpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRvIHRleHQgY29tcGFjdGlvbiBzZWVtcyB0byB3b3JrLlxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZUluZGV4LS07XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlSW5kZXggPSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIudGV4dENvbXBhY3Rpb24oY29kZXdvcmRzLCBjb2RlSW5kZXgsIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNvZGVJbmRleCA8IGNvZGV3b3Jkcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZSA9IGNvZGV3b3Jkc1tjb2RlSW5kZXgrK107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBGb3JtYXRFeGNlcHRpb24uZ2V0Rm9ybWF0SW5zdGFuY2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCgpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRm9ybWF0RXhjZXB0aW9uLmdldEZvcm1hdEluc3RhbmNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZGVjb2RlclJlc3VsdCA9IG5ldyBEZWNvZGVyUmVzdWx0KG51bGwsIHJlc3VsdC50b1N0cmluZygpLCBudWxsLCBlY0xldmVsKTtcbiAgICAgICAgICAgIGRlY29kZXJSZXN1bHQuc2V0T3RoZXIocmVzdWx0TWV0YWRhdGEpO1xuICAgICAgICAgICAgcmV0dXJuIGRlY29kZXJSZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBpbnRcbiAgICAgICAgICogQHBhcmFtIHBhcmFtMVxuICAgICAgICAgKiBAcGFyYW0gY29kZXdvcmRzXG4gICAgICAgICAqIEBwYXJhbSBpbnRcbiAgICAgICAgICogQHBhcmFtIGNvZGVJbmRleFxuICAgICAgICAgKiBAcGFyYW0gUERGNDE3UmVzdWx0TWV0YWRhdGFcbiAgICAgICAgICogQHBhcmFtIHJlc3VsdE1ldGFkYXRhXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0aHJvd3MgRm9ybWF0RXhjZXB0aW9uXG4gICAgICAgICAqL1xuICAgICAgICAvLyBAU3VwcHJlc3NXYXJuaW5ncyhcImRlcHJlY2F0aW9uXCIpXG4gICAgICAgIHN0YXRpYyBkZWNvZGVNYWNyb0Jsb2NrKGNvZGV3b3JkcywgY29kZUluZGV4LCByZXN1bHRNZXRhZGF0YSkge1xuICAgICAgICAgICAgaWYgKGNvZGVJbmRleCArIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5OVU1CRVJfT0ZfU0VRVUVOQ0VfQ09ERVdPUkRTID4gY29kZXdvcmRzWzBdKSB7XG4gICAgICAgICAgICAgICAgLy8gd2UgbXVzdCBoYXZlIGF0IGxlYXN0IHR3byBieXRlcyBsZWZ0IGZvciB0aGUgc2VnbWVudCBpbmRleFxuICAgICAgICAgICAgICAgIHRocm93IEZvcm1hdEV4Y2VwdGlvbi5nZXRGb3JtYXRJbnN0YW5jZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHNlZ21lbnRJbmRleEFycmF5ID0gbmV3IEludDMyQXJyYXkoRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLk5VTUJFUl9PRl9TRVFVRU5DRV9DT0RFV09SRFMpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSAvKmludCovID0gMDsgaSA8IERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5OVU1CRVJfT0ZfU0VRVUVOQ0VfQ09ERVdPUkRTOyBpKyssIGNvZGVJbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgc2VnbWVudEluZGV4QXJyYXlbaV0gPSBjb2Rld29yZHNbY29kZUluZGV4XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdE1ldGFkYXRhLnNldFNlZ21lbnRJbmRleChJbnRlZ2VyLnBhcnNlSW50KERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5kZWNvZGVCYXNlOTAwdG9CYXNlMTAoc2VnbWVudEluZGV4QXJyYXksIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5OVU1CRVJfT0ZfU0VRVUVOQ0VfQ09ERVdPUkRTKSkpO1xuICAgICAgICAgICAgbGV0IGZpbGVJZCA9IG5ldyBTdHJpbmdCdWlsZGVyKCk7XG4gICAgICAgICAgICBjb2RlSW5kZXggPSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIudGV4dENvbXBhY3Rpb24oY29kZXdvcmRzLCBjb2RlSW5kZXgsIGZpbGVJZCk7XG4gICAgICAgICAgICByZXN1bHRNZXRhZGF0YS5zZXRGaWxlSWQoZmlsZUlkLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgbGV0IG9wdGlvbmFsRmllbGRzU3RhcnQgPSAtMTtcbiAgICAgICAgICAgIGlmIChjb2Rld29yZHNbY29kZUluZGV4XSA9PT0gRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLkJFR0lOX01BQ1JPX1BERjQxN19PUFRJT05BTF9GSUVMRCkge1xuICAgICAgICAgICAgICAgIG9wdGlvbmFsRmllbGRzU3RhcnQgPSBjb2RlSW5kZXggKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKGNvZGVJbmRleCA8IGNvZGV3b3Jkc1swXSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoY29kZXdvcmRzW2NvZGVJbmRleF0pIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuQkVHSU5fTUFDUk9fUERGNDE3X09QVElPTkFMX0ZJRUxEOlxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZUluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGNvZGV3b3Jkc1tjb2RlSW5kZXhdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuTUFDUk9fUERGNDE3X09QVElPTkFMX0ZJRUxEX0ZJTEVfTkFNRTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGZpbGVOYW1lID0gbmV3IFN0cmluZ0J1aWxkZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZUluZGV4ID0gRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLnRleHRDb21wYWN0aW9uKGNvZGV3b3JkcywgY29kZUluZGV4ICsgMSwgZmlsZU5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRNZXRhZGF0YS5zZXRGaWxlTmFtZShmaWxlTmFtZS50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuTUFDUk9fUERGNDE3X09QVElPTkFMX0ZJRUxEX1NFTkRFUjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHNlbmRlciA9IG5ldyBTdHJpbmdCdWlsZGVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVJbmRleCA9IERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi50ZXh0Q29tcGFjdGlvbihjb2Rld29yZHMsIGNvZGVJbmRleCArIDEsIHNlbmRlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdE1ldGFkYXRhLnNldFNlbmRlcihzZW5kZXIudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLk1BQ1JPX1BERjQxN19PUFRJT05BTF9GSUVMRF9BRERSRVNTRUU6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBhZGRyZXNzZWUgPSBuZXcgU3RyaW5nQnVpbGRlcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlSW5kZXggPSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIudGV4dENvbXBhY3Rpb24oY29kZXdvcmRzLCBjb2RlSW5kZXggKyAxLCBhZGRyZXNzZWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRNZXRhZGF0YS5zZXRBZGRyZXNzZWUoYWRkcmVzc2VlLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5NQUNST19QREY0MTdfT1BUSU9OQUxfRklFTERfU0VHTUVOVF9DT1VOVDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHNlZ21lbnRDb3VudCA9IG5ldyBTdHJpbmdCdWlsZGVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVJbmRleCA9IERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5udW1lcmljQ29tcGFjdGlvbihjb2Rld29yZHMsIGNvZGVJbmRleCArIDEsIHNlZ21lbnRDb3VudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdE1ldGFkYXRhLnNldFNlZ21lbnRDb3VudChJbnRlZ2VyLnBhcnNlSW50KHNlZ21lbnRDb3VudC50b1N0cmluZygpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLk1BQ1JPX1BERjQxN19PUFRJT05BTF9GSUVMRF9USU1FX1NUQU1QOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgdGltZXN0YW1wID0gbmV3IFN0cmluZ0J1aWxkZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZUluZGV4ID0gRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLm51bWVyaWNDb21wYWN0aW9uKGNvZGV3b3JkcywgY29kZUluZGV4ICsgMSwgdGltZXN0YW1wKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0TWV0YWRhdGEuc2V0VGltZXN0YW1wKExvbmcucGFyc2VMb25nKHRpbWVzdGFtcC50b1N0cmluZygpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLk1BQ1JPX1BERjQxN19PUFRJT05BTF9GSUVMRF9DSEVDS1NVTTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNoZWNrc3VtID0gbmV3IFN0cmluZ0J1aWxkZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZUluZGV4ID0gRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLm51bWVyaWNDb21wYWN0aW9uKGNvZGV3b3JkcywgY29kZUluZGV4ICsgMSwgY2hlY2tzdW0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRNZXRhZGF0YS5zZXRDaGVja3N1bShJbnRlZ2VyLnBhcnNlSW50KGNoZWNrc3VtLnRvU3RyaW5nKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuTUFDUk9fUERGNDE3X09QVElPTkFMX0ZJRUxEX0ZJTEVfU0laRTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGZpbGVTaXplID0gbmV3IFN0cmluZ0J1aWxkZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZUluZGV4ID0gRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLm51bWVyaWNDb21wYWN0aW9uKGNvZGV3b3JkcywgY29kZUluZGV4ICsgMSwgZmlsZVNpemUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRNZXRhZGF0YS5zZXRGaWxlU2l6ZShMb25nLnBhcnNlTG9uZyhmaWxlU2l6ZS50b1N0cmluZygpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEZvcm1hdEV4Y2VwdGlvbi5nZXRGb3JtYXRJbnN0YW5jZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLk1BQ1JPX1BERjQxN19URVJNSU5BVE9SOlxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZUluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRNZXRhZGF0YS5zZXRMYXN0U2VnbWVudCh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRm9ybWF0RXhjZXB0aW9uLmdldEZvcm1hdEluc3RhbmNlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY29weSBvcHRpb25hbCBmaWVsZHMgdG8gYWRkaXRpb25hbCBvcHRpb25zXG4gICAgICAgICAgICBpZiAob3B0aW9uYWxGaWVsZHNTdGFydCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBsZXQgb3B0aW9uYWxGaWVsZHNMZW5ndGggPSBjb2RlSW5kZXggLSBvcHRpb25hbEZpZWxkc1N0YXJ0O1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHRNZXRhZGF0YS5pc0xhc3RTZWdtZW50KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZG8gbm90IGluY2x1ZGUgdGVybWluYXRvclxuICAgICAgICAgICAgICAgICAgICBvcHRpb25hbEZpZWxkc0xlbmd0aC0tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHRNZXRhZGF0YS5zZXRPcHRpb25hbERhdGEoQXJyYXlzLmNvcHlPZlJhbmdlKGNvZGV3b3Jkcywgb3B0aW9uYWxGaWVsZHNTdGFydCwgb3B0aW9uYWxGaWVsZHNTdGFydCArIG9wdGlvbmFsRmllbGRzTGVuZ3RoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY29kZUluZGV4O1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUZXh0IENvbXBhY3Rpb24gbW9kZSAoc2VlIDUuNC4xLjUpIHBlcm1pdHMgYWxsIHByaW50YWJsZSBBU0NJSSBjaGFyYWN0ZXJzIHRvIGJlXG4gICAgICAgICAqIGVuY29kZWQsIGkuZS4gdmFsdWVzIDMyIC0gMTI2IGluY2x1c2l2ZSBpbiBhY2NvcmRhbmNlIHdpdGggSVNPL0lFQyA2NDYgKElSViksIGFzXG4gICAgICAgICAqIHdlbGwgYXMgc2VsZWN0ZWQgY29udHJvbCBjaGFyYWN0ZXJzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gY29kZXdvcmRzIFRoZSBhcnJheSBvZiBjb2Rld29yZHMgKGRhdGEgKyBlcnJvcilcbiAgICAgICAgICogQHBhcmFtIGNvZGVJbmRleCBUaGUgY3VycmVudCBpbmRleCBpbnRvIHRoZSBjb2Rld29yZCBhcnJheS5cbiAgICAgICAgICogQHBhcmFtIHJlc3VsdCAgICBUaGUgZGVjb2RlZCBkYXRhIGlzIGFwcGVuZGVkIHRvIHRoZSByZXN1bHQuXG4gICAgICAgICAqIEByZXR1cm4gVGhlIG5leHQgaW5kZXggaW50byB0aGUgY29kZXdvcmQgYXJyYXkuXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgdGV4dENvbXBhY3Rpb24oY29kZXdvcmRzLCBjb2RlSW5kZXgsIHJlc3VsdCkge1xuICAgICAgICAgICAgLy8gMiBjaGFyYWN0ZXIgcGVyIGNvZGV3b3JkXG4gICAgICAgICAgICBsZXQgdGV4dENvbXBhY3Rpb25EYXRhID0gbmV3IEludDMyQXJyYXkoKGNvZGV3b3Jkc1swXSAtIGNvZGVJbmRleCkgKiAyKTtcbiAgICAgICAgICAgIC8vIFVzZWQgdG8gaG9sZCB0aGUgYnl0ZSBjb21wYWN0aW9uIHZhbHVlIGlmIHRoZXJlIGlzIGEgbW9kZSBzaGlmdFxuICAgICAgICAgICAgbGV0IGJ5dGVDb21wYWN0aW9uRGF0YSA9IG5ldyBJbnQzMkFycmF5KChjb2Rld29yZHNbMF0gLSBjb2RlSW5kZXgpICogMik7XG4gICAgICAgICAgICBsZXQgaW5kZXggPSAwO1xuICAgICAgICAgICAgbGV0IGVuZCA9IGZhbHNlO1xuICAgICAgICAgICAgd2hpbGUgKChjb2RlSW5kZXggPCBjb2Rld29yZHNbMF0pICYmICFlbmQpIHtcbiAgICAgICAgICAgICAgICBsZXQgY29kZSA9IGNvZGV3b3Jkc1tjb2RlSW5kZXgrK107XG4gICAgICAgICAgICAgICAgaWYgKGNvZGUgPCBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuVEVYVF9DT01QQUNUSU9OX01PREVfTEFUQ0gpIHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dENvbXBhY3Rpb25EYXRhW2luZGV4XSA9IGNvZGUgLyAzMDtcbiAgICAgICAgICAgICAgICAgICAgdGV4dENvbXBhY3Rpb25EYXRhW2luZGV4ICsgMV0gPSBjb2RlICUgMzA7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ICs9IDI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLlRFWFRfQ09NUEFDVElPTl9NT0RFX0xBVENIOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlaW5pdGlhbGl6ZSB0ZXh0IGNvbXBhY3Rpb24gbW9kZSB0byBhbHBoYSBzdWIgbW9kZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHRDb21wYWN0aW9uRGF0YVtpbmRleCsrXSA9IERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5URVhUX0NPTVBBQ1RJT05fTU9ERV9MQVRDSDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLkJZVEVfQ09NUEFDVElPTl9NT0RFX0xBVENIOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuQllURV9DT01QQUNUSU9OX01PREVfTEFUQ0hfNjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLk5VTUVSSUNfQ09NUEFDVElPTl9NT0RFX0xBVENIOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuQkVHSU5fTUFDUk9fUERGNDE3X0NPTlRST0xfQkxPQ0s6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5CRUdJTl9NQUNST19QREY0MTdfT1BUSU9OQUxfRklFTEQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5NQUNST19QREY0MTdfVEVSTUlOQVRPUjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlSW5kZXgtLTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuTU9ERV9TSElGVF9UT19CWVRFX0NPTVBBQ1RJT05fTU9ERTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgTW9kZSBTaGlmdCBjb2Rld29yZCA5MTMgc2hhbGwgY2F1c2UgYSB0ZW1wb3JhcnlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzd2l0Y2ggZnJvbSBUZXh0IENvbXBhY3Rpb24gbW9kZSB0byBCeXRlIENvbXBhY3Rpb24gbW9kZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIHN3aXRjaCBzaGFsbCBiZSBpbiBlZmZlY3QgZm9yIG9ubHkgdGhlIG5leHQgY29kZXdvcmQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWZ0ZXIgd2hpY2ggdGhlIG1vZGUgc2hhbGwgcmV2ZXJ0IHRvIHRoZSBwcmV2YWlsaW5nIHN1Yi1tb2RlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb2YgdGhlIFRleHQgQ29tcGFjdGlvbiBtb2RlLiBDb2Rld29yZCA5MTMgaXMgb25seSBhdmFpbGFibGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbiBUZXh0IENvbXBhY3Rpb24gbW9kZTsgaXRzIHVzZSBpcyBkZXNjcmliZWQgaW4gNS40LjIuNC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0Q29tcGFjdGlvbkRhdGFbaW5kZXhdID0gRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLk1PREVfU0hJRlRfVE9fQllURV9DT01QQUNUSU9OX01PREU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZSA9IGNvZGV3b3Jkc1tjb2RlSW5kZXgrK107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnl0ZUNvbXBhY3Rpb25EYXRhW2luZGV4XSA9IGNvZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5kZWNvZGVUZXh0Q29tcGFjdGlvbih0ZXh0Q29tcGFjdGlvbkRhdGEsIGJ5dGVDb21wYWN0aW9uRGF0YSwgaW5kZXgsIHJlc3VsdCk7XG4gICAgICAgICAgICByZXR1cm4gY29kZUluZGV4O1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgVGV4dCBDb21wYWN0aW9uIG1vZGUgaW5jbHVkZXMgYWxsIHRoZSBwcmludGFibGUgQVNDSUkgY2hhcmFjdGVyc1xuICAgICAgICAgKiAoaS5lLiB2YWx1ZXMgZnJvbSAzMiB0byAxMjYpIGFuZCB0aHJlZSBBU0NJSSBjb250cm9sIGNoYXJhY3RlcnM6IEhUIG9yIHRhYlxuICAgICAgICAgKiAoOTogZSksIExGIG9yIGxpbmUgZmVlZCAoMTA6IGUpLCBhbmQgQ1Igb3IgY2FycmlhZ2VcbiAgICAgICAgICogcmV0dXJuICgxMzogZSkuIFRoZSBUZXh0IENvbXBhY3Rpb24gbW9kZSBhbHNvIGluY2x1ZGVzIHZhcmlvdXMgbGF0Y2hcbiAgICAgICAgICogYW5kIHNoaWZ0IGNoYXJhY3RlcnMgd2hpY2ggYXJlIHVzZWQgZXhjbHVzaXZlbHkgd2l0aGluIHRoZSBtb2RlLiBUaGUgVGV4dFxuICAgICAgICAgKiBDb21wYWN0aW9uIG1vZGUgZW5jb2RlcyB1cCB0byAyIGNoYXJhY3RlcnMgcGVyIGNvZGV3b3JkLiBUaGUgY29tcGFjdGlvbiBydWxlc1xuICAgICAgICAgKiBmb3IgY29udmVydGluZyBkYXRhIGludG8gUERGNDE3IGNvZGV3b3JkcyBhcmUgZGVmaW5lZCBpbiA1LjQuMi4yLiBUaGUgc3ViLW1vZGVcbiAgICAgICAgICogc3dpdGNoZXMgYXJlIGRlZmluZWQgaW4gNS40LjIuMy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHRleHRDb21wYWN0aW9uRGF0YSBUaGUgdGV4dCBjb21wYWN0aW9uIGRhdGEuXG4gICAgICAgICAqIEBwYXJhbSBieXRlQ29tcGFjdGlvbkRhdGEgVGhlIGJ5dGUgY29tcGFjdGlvbiBkYXRhIGlmIHRoZXJlXG4gICAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgd2FzIGEgbW9kZSBzaGlmdC5cbiAgICAgICAgICogQHBhcmFtIGxlbmd0aCAgICAgICAgICAgICBUaGUgc2l6ZSBvZiB0aGUgdGV4dCBjb21wYWN0aW9uIGFuZCBieXRlIGNvbXBhY3Rpb24gZGF0YS5cbiAgICAgICAgICogQHBhcmFtIHJlc3VsdCAgICAgICAgICAgICBUaGUgZGVjb2RlZCBkYXRhIGlzIGFwcGVuZGVkIHRvIHRoZSByZXN1bHQuXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgZGVjb2RlVGV4dENvbXBhY3Rpb24odGV4dENvbXBhY3Rpb25EYXRhLCBieXRlQ29tcGFjdGlvbkRhdGEsIGxlbmd0aCwgcmVzdWx0KSB7XG4gICAgICAgICAgICAvLyBCZWdpbm5pbmcgZnJvbSBhbiBpbml0aWFsIHN0YXRlIG9mIHRoZSBBbHBoYSBzdWItbW9kZVxuICAgICAgICAgICAgLy8gVGhlIGRlZmF1bHQgY29tcGFjdGlvbiBtb2RlIGZvciBQREY0MTcgaW4gZWZmZWN0IGF0IHRoZSBzdGFydCBvZiBlYWNoIHN5bWJvbCBzaGFsbCBhbHdheXMgYmUgVGV4dFxuICAgICAgICAgICAgLy8gQ29tcGFjdGlvbiBtb2RlIEFscGhhIHN1Yi1tb2RlIChhbHBoYWJldGljOiB1cHBlcmNhc2UpLiBBIGxhdGNoIGNvZGV3b3JkIGZyb20gYW5vdGhlciBtb2RlIHRvIHRoZSBUZXh0XG4gICAgICAgICAgICAvLyBDb21wYWN0aW9uIG1vZGUgc2hhbGwgYWx3YXlzIHN3aXRjaCB0byB0aGUgVGV4dCBDb21wYWN0aW9uIEFscGhhIHN1Yi1tb2RlLlxuICAgICAgICAgICAgbGV0IHN1Yk1vZGUgPSBNb2RlJDIuQUxQSEE7XG4gICAgICAgICAgICBsZXQgcHJpb3JUb1NoaWZ0TW9kZSA9IE1vZGUkMi5BTFBIQTtcbiAgICAgICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgICAgIHdoaWxlIChpIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbGV0IHN1Yk1vZGVDaCA9IHRleHRDb21wYWN0aW9uRGF0YVtpXTtcbiAgICAgICAgICAgICAgICBsZXQgY2ggPSAvKmNoYXIqLyAnJztcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHN1Yk1vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBNb2RlJDIuQUxQSEE6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBbHBoYSAoYWxwaGFiZXRpYzogdXBwZXJjYXNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN1Yk1vZGVDaCA8IDI2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXBwZXIgY2FzZSBBbHBoYSBDaGFyYWN0ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOb3RlOiA2NSA9ICdBJyBBU0NJSSAtPiB0aGVyZSBpcyBieXRlIGNvZGUgb2Ygc3ltYm9sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2ggPSAvKihjaGFyKSgnQScgKyBzdWJNb2RlQ2gpICovIFN0cmluZy5mcm9tQ2hhckNvZGUoNjUgKyBzdWJNb2RlQ2gpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChzdWJNb2RlQ2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyNjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoID0gJyAnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLkxMOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViTW9kZSA9IE1vZGUkMi5MT1dFUjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5NTDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Yk1vZGUgPSBNb2RlJDIuTUlYRUQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuUFM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTaGlmdCB0byBwdW5jdHVhdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJpb3JUb1NoaWZ0TW9kZSA9IHN1Yk1vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJNb2RlID0gTW9kZSQyLlBVTkNUX1NISUZUO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLk1PREVfU0hJRlRfVE9fQllURV9DT01QQUNUSU9OX01PREU6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKC8qKGNoYXIpKi8gYnl0ZUNvbXBhY3Rpb25EYXRhW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5URVhUX0NPTVBBQ1RJT05fTU9ERV9MQVRDSDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Yk1vZGUgPSBNb2RlJDIuQUxQSEE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBNb2RlJDIuTE9XRVI6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBMb3dlciAoYWxwaGFiZXRpYzogbG93ZXJjYXNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN1Yk1vZGVDaCA8IDI2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2ggPSAvKihjaGFyKSgnYScgKyBzdWJNb2RlQ2gpKi8gU3RyaW5nLmZyb21DaGFyQ29kZSg5NyArIHN1Yk1vZGVDaCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHN1Yk1vZGVDaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI2OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2ggPSAnICc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuQVM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTaGlmdCB0byBhbHBoYVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJpb3JUb1NoaWZ0TW9kZSA9IHN1Yk1vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJNb2RlID0gTW9kZSQyLkFMUEhBX1NISUZUO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLk1MOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViTW9kZSA9IE1vZGUkMi5NSVhFRDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5QUzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNoaWZ0IHRvIHB1bmN0dWF0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmlvclRvU2hpZnRNb2RlID0gc3ViTW9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Yk1vZGUgPSBNb2RlJDIuUFVOQ1RfU0hJRlQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuTU9ERV9TSElGVF9UT19CWVRFX0NPTVBBQ1RJT05fTU9ERTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gRG9lcyB0aGlzIG5lZWQgdG8gdXNlIHRoZSBjdXJyZW50IGNoYXJhY3RlciBlbmNvZGluZz8gU2VlIG90aGVyIG9jY3VycmVuY2VzIGJlbG93XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKC8qKGNoYXIpKi8gYnl0ZUNvbXBhY3Rpb25EYXRhW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5URVhUX0NPTVBBQ1RJT05fTU9ERV9MQVRDSDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Yk1vZGUgPSBNb2RlJDIuQUxQSEE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBNb2RlJDIuTUlYRUQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBNaXhlZCAocHVuY3R1YXRpb246IGUpXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3ViTW9kZUNoIDwgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLlBMKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2ggPSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuTUlYRURfQ0hBUlNbc3ViTW9kZUNoXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoc3ViTW9kZUNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLlBMOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViTW9kZSA9IE1vZGUkMi5QVU5DVDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI2OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2ggPSAnICc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuTEw6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJNb2RlID0gTW9kZSQyLkxPV0VSO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLkFMOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViTW9kZSA9IE1vZGUkMi5BTFBIQTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5QUzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNoaWZ0IHRvIHB1bmN0dWF0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmlvclRvU2hpZnRNb2RlID0gc3ViTW9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Yk1vZGUgPSBNb2RlJDIuUFVOQ1RfU0hJRlQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuTU9ERV9TSElGVF9UT19CWVRFX0NPTVBBQ1RJT05fTU9ERTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoLyooY2hhcikqLyBieXRlQ29tcGFjdGlvbkRhdGFbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLlRFWFRfQ09NUEFDVElPTl9NT0RFX0xBVENIOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViTW9kZSA9IE1vZGUkMi5BTFBIQTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIE1vZGUkMi5QVU5DVDpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFB1bmN0dWF0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3ViTW9kZUNoIDwgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLlBBTCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoID0gRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLlBVTkNUX0NIQVJTW3N1Yk1vZGVDaF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHN1Yk1vZGVDaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5QQUw6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJNb2RlID0gTW9kZSQyLkFMUEhBO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLk1PREVfU0hJRlRfVE9fQllURV9DT01QQUNUSU9OX01PREU6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKC8qKGNoYXIpKi8gYnl0ZUNvbXBhY3Rpb25EYXRhW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5URVhUX0NPTVBBQ1RJT05fTU9ERV9MQVRDSDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Yk1vZGUgPSBNb2RlJDIuQUxQSEE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBNb2RlJDIuQUxQSEFfU0hJRlQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXN0b3JlIHN1Yi1tb2RlXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJNb2RlID0gcHJpb3JUb1NoaWZ0TW9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdWJNb2RlQ2ggPCAyNikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoID0gLyooY2hhcikoJ0EnICsgc3ViTW9kZUNoKSovIFN0cmluZy5mcm9tQ2hhckNvZGUoNjUgKyBzdWJNb2RlQ2gpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChzdWJNb2RlQ2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyNjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoID0gJyAnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLlRFWFRfQ09NUEFDVElPTl9NT0RFX0xBVENIOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViTW9kZSA9IE1vZGUkMi5BTFBIQTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIE1vZGUkMi5QVU5DVF9TSElGVDpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlc3RvcmUgc3ViLW1vZGVcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1Yk1vZGUgPSBwcmlvclRvU2hpZnRNb2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN1Yk1vZGVDaCA8IERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5QQUwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaCA9IERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5QVU5DVF9DSEFSU1tzdWJNb2RlQ2hdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChzdWJNb2RlQ2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuUEFMOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViTW9kZSA9IE1vZGUkMi5BTFBIQTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5NT0RFX1NISUZUX1RPX0JZVEVfQ09NUEFDVElPTl9NT0RFOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUFMgYmVmb3JlIFNoaWZ0LXRvLUJ5dGUgaXMgdXNlZCBhcyBhIHBhZGRpbmcgY2hhcmFjdGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2VlIDUuNC4yLjQgb2YgdGhlIHNwZWNpZmljYXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoLyooY2hhcikqLyBieXRlQ29tcGFjdGlvbkRhdGFbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLlRFWFRfQ09NUEFDVElPTl9NT0RFX0xBVENIOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViTW9kZSA9IE1vZGUkMi5BTFBIQTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBpZiAoY2ggIT09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoY2ggIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFwcGVuZCBkZWNvZGVkIGNoYXJhY3RlciB0byByZXN1bHRcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZChjaCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQnl0ZSBDb21wYWN0aW9uIG1vZGUgKHNlZSA1LjQuMykgcGVybWl0cyBhbGwgMjU2IHBvc3NpYmxlIDgtYml0IGJ5dGUgdmFsdWVzIHRvIGJlIGVuY29kZWQuXG4gICAgICAgICAqIFRoaXMgaW5jbHVkZXMgYWxsIEFTQ0lJIGNoYXJhY3RlcnMgdmFsdWUgMCB0byAxMjcgaW5jbHVzaXZlIGFuZCBwcm92aWRlcyBmb3IgaW50ZXJuYXRpb25hbFxuICAgICAgICAgKiBjaGFyYWN0ZXIgc2V0IHN1cHBvcnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBtb2RlICAgICAgVGhlIGJ5dGUgY29tcGFjdGlvbiBtb2RlIGkuZS4gOTAxIG9yIDkyNFxuICAgICAgICAgKiBAcGFyYW0gY29kZXdvcmRzIFRoZSBhcnJheSBvZiBjb2Rld29yZHMgKGRhdGEgKyBlcnJvcilcbiAgICAgICAgICogQHBhcmFtIGVuY29kaW5nICBDdXJyZW50bHkgYWN0aXZlIGNoYXJhY3RlciBlbmNvZGluZ1xuICAgICAgICAgKiBAcGFyYW0gY29kZUluZGV4IFRoZSBjdXJyZW50IGluZGV4IGludG8gdGhlIGNvZGV3b3JkIGFycmF5LlxuICAgICAgICAgKiBAcGFyYW0gcmVzdWx0ICAgIFRoZSBkZWNvZGVkIGRhdGEgaXMgYXBwZW5kZWQgdG8gdGhlIHJlc3VsdC5cbiAgICAgICAgICogQHJldHVybiBUaGUgbmV4dCBpbmRleCBpbnRvIHRoZSBjb2Rld29yZCBhcnJheS5cbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyAvKmludCovIGJ5dGVDb21wYWN0aW9uKG1vZGUsIGNvZGV3b3JkcywgZW5jb2RpbmcsIGNvZGVJbmRleCwgcmVzdWx0KSB7XG4gICAgICAgICAgICBsZXQgZGVjb2RlZEJ5dGVzID0gbmV3IEJ5dGVBcnJheU91dHB1dFN0cmVhbSgpO1xuICAgICAgICAgICAgbGV0IGNvdW50ID0gMDtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IC8qbG9uZyovIDA7XG4gICAgICAgICAgICBsZXQgZW5kID0gZmFsc2U7XG4gICAgICAgICAgICBzd2l0Y2ggKG1vZGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5CWVRFX0NPTVBBQ1RJT05fTU9ERV9MQVRDSDpcbiAgICAgICAgICAgICAgICAgICAgLy8gVG90YWwgbnVtYmVyIG9mIEJ5dGUgQ29tcGFjdGlvbiBjaGFyYWN0ZXJzIHRvIGJlIGVuY29kZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gaXMgbm90IGEgbXVsdGlwbGUgb2YgNlxuICAgICAgICAgICAgICAgICAgICBsZXQgYnl0ZUNvbXBhY3RlZENvZGV3b3JkcyA9IG5ldyBJbnQzMkFycmF5KDYpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgbmV4dENvZGUgPSBjb2Rld29yZHNbY29kZUluZGV4KytdO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoKGNvZGVJbmRleCA8IGNvZGV3b3Jkc1swXSkgJiYgIWVuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnl0ZUNvbXBhY3RlZENvZGV3b3Jkc1tjb3VudCsrXSA9IG5leHRDb2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQmFzZSA5MDBcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gOTAwICogdmFsdWUgKyBuZXh0Q29kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHRDb2RlID0gY29kZXdvcmRzW2NvZGVJbmRleCsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHBlcmhhcHMgaXQgc2hvdWxkIGJlIG9rIHRvIGNoZWNrIG9ubHkgbmV4dENvZGUgPj0gVEVYVF9DT01QQUNUSU9OX01PREVfTEFUQ0hcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAobmV4dENvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5URVhUX0NPTVBBQ1RJT05fTU9ERV9MQVRDSDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5CWVRFX0NPTVBBQ1RJT05fTU9ERV9MQVRDSDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5OVU1FUklDX0NPTVBBQ1RJT05fTU9ERV9MQVRDSDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5CWVRFX0NPTVBBQ1RJT05fTU9ERV9MQVRDSF82OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLkJFR0lOX01BQ1JPX1BERjQxN19DT05UUk9MX0JMT0NLOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLkJFR0lOX01BQ1JPX1BERjQxN19PUFRJT05BTF9GSUVMRDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5NQUNST19QREY0MTdfVEVSTUlOQVRPUjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZUluZGV4LS07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoY291bnQgJSA1ID09PSAwKSAmJiAoY291bnQgPiAwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGVjb2RlIGV2ZXJ5IDUgY29kZXdvcmRzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDb252ZXJ0IHRvIEJhc2UgMjU2XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqIC8qaW50Ki8gPSAwOyBqIDwgNjsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogQG5vdGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBKYXZhU2NyaXB0IHN0b3JlcyBudW1iZXJzIGFzIDY0IGJpdHMgZmxvYXRpbmcgcG9pbnQgbnVtYmVycywgYnV0IGFsbCBiaXR3aXNlIG9wZXJhdGlvbnMgYXJlIHBlcmZvcm1lZCBvbiAzMiBiaXRzIGJpbmFyeSBudW1iZXJzLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIFNvIHRoZSBuZXh0IGJpdHdpc2Ugb3BlcmF0aW9uIGNvdWxkIG5vdCBiZSBkb25lIHdpdGggc2ltcGxlIG51bWJlcnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNvZGVkQnl0ZXMud3JpdGUoLyooYnl0ZSkqLyBOdW1iZXIoY3JlYXRlQmlnSW50KHZhbHVlKSA+PiBjcmVhdGVCaWdJbnQoOCAqICg1IC0gaikpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIGVuZCBvZiBhbGwgY29kZXdvcmRzIGlzIHJlYWNoZWQgdGhlIGxhc3QgY29kZXdvcmQgbmVlZHMgdG8gYmUgYWRkZWRcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGVJbmRleCA9PT0gY29kZXdvcmRzWzBdICYmIG5leHRDb2RlIDwgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLlRFWFRfQ09NUEFDVElPTl9NT0RFX0xBVENIKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBieXRlQ29tcGFjdGVkQ29kZXdvcmRzW2NvdW50KytdID0gbmV4dENvZGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgQnl0ZSBDb21wYWN0aW9uIG1vZGUgaXMgaW52b2tlZCB3aXRoIGNvZGV3b3JkIDkwMSxcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGxhc3QgZ3JvdXAgb2YgY29kZXdvcmRzIGlzIGludGVycHJldGVkIGRpcmVjdGx5XG4gICAgICAgICAgICAgICAgICAgIC8vIGFzIG9uZSBieXRlIHBlciBjb2Rld29yZCwgd2l0aG91dCBjb21wYWN0aW9uLlxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpIC8qaW50Ki8gPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVjb2RlZEJ5dGVzLndyaXRlKC8qKGJ5dGUpKi8gYnl0ZUNvbXBhY3RlZENvZGV3b3Jkc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuQllURV9DT01QQUNUSU9OX01PREVfTEFUQ0hfNjpcbiAgICAgICAgICAgICAgICAgICAgLy8gVG90YWwgbnVtYmVyIG9mIEJ5dGUgQ29tcGFjdGlvbiBjaGFyYWN0ZXJzIHRvIGJlIGVuY29kZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gaXMgYW4gaW50ZWdlciBtdWx0aXBsZSBvZiA2XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChjb2RlSW5kZXggPCBjb2Rld29yZHNbMF0gJiYgIWVuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNvZGUgPSBjb2Rld29yZHNbY29kZUluZGV4KytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGUgPCBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuVEVYVF9DT01QQUNUSU9OX01PREVfTEFUQ0gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJhc2UgOTAwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSA5MDAgKiB2YWx1ZSArIGNvZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuVEVYVF9DT01QQUNUSU9OX01PREVfTEFUQ0g6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLkJZVEVfQ09NUEFDVElPTl9NT0RFX0xBVENIOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5OVU1FUklDX0NPTVBBQ1RJT05fTU9ERV9MQVRDSDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuQllURV9DT01QQUNUSU9OX01PREVfTEFUQ0hfNjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuQkVHSU5fTUFDUk9fUERGNDE3X0NPTlRST0xfQkxPQ0s6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLkJFR0lOX01BQ1JPX1BERjQxN19PUFRJT05BTF9GSUVMRDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuTUFDUk9fUERGNDE3X1RFUk1JTkFUT1I6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlSW5kZXgtLTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGNvdW50ICUgNSA9PT0gMCkgJiYgKGNvdW50ID4gMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEZWNvZGUgZXZlcnkgNSBjb2Rld29yZHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDb252ZXJ0IHRvIEJhc2UgMjU2XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogQG5vdGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBKYXZhU2NyaXB0IHN0b3JlcyBudW1iZXJzIGFzIDY0IGJpdHMgZmxvYXRpbmcgcG9pbnQgbnVtYmVycywgYnV0IGFsbCBiaXR3aXNlIG9wZXJhdGlvbnMgYXJlIHBlcmZvcm1lZCBvbiAzMiBiaXRzIGJpbmFyeSBudW1iZXJzLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIFNvIHRoZSBuZXh0IGJpdHdpc2Ugb3BlcmF0aW9uIGNvdWxkIG5vdCBiZSBkb25lIHdpdGggc2ltcGxlIG51bWJlcnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogLyppbnQqLyA9IDA7IGogPCA2OyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjb2RlZEJ5dGVzLndyaXRlKC8qKGJ5dGUpKi8gTnVtYmVyKGNyZWF0ZUJpZ0ludCh2YWx1ZSkgPj4gY3JlYXRlQmlnSW50KDggKiAoNSAtIGopKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY291bnQgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LmFwcGVuZChTdHJpbmdFbmNvZGluZy5kZWNvZGUoZGVjb2RlZEJ5dGVzLnRvQnl0ZUFycmF5KCksIGVuY29kaW5nKSk7XG4gICAgICAgICAgICByZXR1cm4gY29kZUluZGV4O1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOdW1lcmljIENvbXBhY3Rpb24gbW9kZSAoc2VlIDUuNC40KSBwZXJtaXRzIGVmZmljaWVudCBlbmNvZGluZyBvZiBudW1lcmljIGRhdGEgc3RyaW5ncy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGNvZGV3b3JkcyBUaGUgYXJyYXkgb2YgY29kZXdvcmRzIChkYXRhICsgZXJyb3IpXG4gICAgICAgICAqIEBwYXJhbSBjb2RlSW5kZXggVGhlIGN1cnJlbnQgaW5kZXggaW50byB0aGUgY29kZXdvcmQgYXJyYXkuXG4gICAgICAgICAqIEBwYXJhbSByZXN1bHQgICAgVGhlIGRlY29kZWQgZGF0YSBpcyBhcHBlbmRlZCB0byB0aGUgcmVzdWx0LlxuICAgICAgICAgKiBAcmV0dXJuIFRoZSBuZXh0IGluZGV4IGludG8gdGhlIGNvZGV3b3JkIGFycmF5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAdGhyb3dzIEZvcm1hdEV4Y2VwdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIG51bWVyaWNDb21wYWN0aW9uKGNvZGV3b3JkcywgY29kZUluZGV4IC8qaW50Ki8sIHJlc3VsdCkge1xuICAgICAgICAgICAgbGV0IGNvdW50ID0gMDtcbiAgICAgICAgICAgIGxldCBlbmQgPSBmYWxzZTtcbiAgICAgICAgICAgIGxldCBudW1lcmljQ29kZXdvcmRzID0gbmV3IEludDMyQXJyYXkoRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLk1BWF9OVU1FUklDX0NPREVXT1JEUyk7XG4gICAgICAgICAgICB3aGlsZSAoY29kZUluZGV4IDwgY29kZXdvcmRzWzBdICYmICFlbmQpIHtcbiAgICAgICAgICAgICAgICBsZXQgY29kZSA9IGNvZGV3b3Jkc1tjb2RlSW5kZXgrK107XG4gICAgICAgICAgICAgICAgaWYgKGNvZGVJbmRleCA9PT0gY29kZXdvcmRzWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgIGVuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjb2RlIDwgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLlRFWFRfQ09NUEFDVElPTl9NT0RFX0xBVENIKSB7XG4gICAgICAgICAgICAgICAgICAgIG51bWVyaWNDb2Rld29yZHNbY291bnRdID0gY29kZTtcbiAgICAgICAgICAgICAgICAgICAgY291bnQrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuVEVYVF9DT01QQUNUSU9OX01PREVfTEFUQ0g6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5CWVRFX0NPTVBBQ1RJT05fTU9ERV9MQVRDSDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLkJZVEVfQ09NUEFDVElPTl9NT0RFX0xBVENIXzY6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5CRUdJTl9NQUNST19QREY0MTdfQ09OVFJPTF9CTE9DSzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLkJFR0lOX01BQ1JPX1BERjQxN19PUFRJT05BTF9GSUVMRDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLk1BQ1JPX1BERjQxN19URVJNSU5BVE9SOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVJbmRleC0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKChjb3VudCAlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5NQVhfTlVNRVJJQ19DT0RFV09SRFMgPT09IDAgfHwgY29kZSA9PT0gRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLk5VTUVSSUNfQ09NUEFDVElPTl9NT0RFX0xBVENIIHx8IGVuZCkgJiYgY291bnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlLWludm9raW5nIE51bWVyaWMgQ29tcGFjdGlvbiBtb2RlIChieSB1c2luZyBjb2Rld29yZCA5MDJcbiAgICAgICAgICAgICAgICAgICAgLy8gd2hpbGUgaW4gTnVtZXJpYyBDb21wYWN0aW9uIG1vZGUpIHNlcnZlcyAgdG8gdGVybWluYXRlIHRoZVxuICAgICAgICAgICAgICAgICAgICAvLyBjdXJyZW50IE51bWVyaWMgQ29tcGFjdGlvbiBtb2RlIGdyb3VwaW5nIGFzIGRlc2NyaWJlZCBpbiA1LjQuNC4yLFxuICAgICAgICAgICAgICAgICAgICAvLyBhbmQgdGhlbiB0byBzdGFydCBhIG5ldyBvbmUgZ3JvdXBpbmcuXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLmRlY29kZUJhc2U5MDB0b0Jhc2UxMChudW1lcmljQ29kZXdvcmRzLCBjb3VudCkpO1xuICAgICAgICAgICAgICAgICAgICBjb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvZGVJbmRleDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ29udmVydCBhIGxpc3Qgb2YgTnVtZXJpYyBDb21wYWN0ZWQgY29kZXdvcmRzIGZyb20gQmFzZSA5MDAgdG8gQmFzZSAxMC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGNvZGV3b3JkcyBUaGUgYXJyYXkgb2YgY29kZXdvcmRzXG4gICAgICAgICAqIEBwYXJhbSBjb3VudCAgICAgVGhlIG51bWJlciBvZiBjb2Rld29yZHNcbiAgICAgICAgICogQHJldHVybiBUaGUgZGVjb2RlZCBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBOdW1lcmljIGRhdGEuXG4gICAgICAgICAqXG4gICAgICAgICAqIEVYQU1QTEVcbiAgICAgICAgICogRW5jb2RlIHRoZSBmaWZ0ZWVuIGRpZ2l0IG51bWVyaWMgc3RyaW5nIDAwMDIxMzI5ODE3NDAwMFxuICAgICAgICAgKiBQcmVmaXggdGhlIG51bWVyaWMgc3RyaW5nIHdpdGggYSAxIGFuZCBzZXQgdGhlIGluaXRpYWwgdmFsdWUgb2ZcbiAgICAgICAgICogdCA9IDEgMDAwIDIxMyAyOTggMTc0IDAwMFxuICAgICAgICAgKiBDYWxjdWxhdGUgY29kZXdvcmQgMFxuICAgICAgICAgKiBkMCA9IDEgMDAwIDIxMyAyOTggMTc0IDAwMCBtb2QgOTAwID0gMjAwXG4gICAgICAgICAqXG4gICAgICAgICAqIHQgPSAxIDAwMCAyMTMgMjk4IDE3NCAwMDAgZGl2IDkwMCA9IDEgMTExIDM0OCAxMDkgMDgyXG4gICAgICAgICAqIENhbGN1bGF0ZSBjb2Rld29yZCAxXG4gICAgICAgICAqIGQxID0gMSAxMTEgMzQ4IDEwOSAwODIgbW9kIDkwMCA9IDI4MlxuICAgICAgICAgKlxuICAgICAgICAgKiB0ID0gMSAxMTEgMzQ4IDEwOSAwODIgZGl2IDkwMCA9IDEgMjM0IDgzMSAyMzJcbiAgICAgICAgICogQ2FsY3VsYXRlIGNvZGV3b3JkIDJcbiAgICAgICAgICogZDIgPSAxIDIzNCA4MzEgMjMyIG1vZCA5MDAgPSA2MzJcbiAgICAgICAgICpcbiAgICAgICAgICogdCA9IDEgMjM0IDgzMSAyMzIgZGl2IDkwMCA9IDEgMzcyIDAzNFxuICAgICAgICAgKiBDYWxjdWxhdGUgY29kZXdvcmQgM1xuICAgICAgICAgKiBkMyA9IDEgMzcyIDAzNCBtb2QgOTAwID0gNDM0XG4gICAgICAgICAqXG4gICAgICAgICAqIHQgPSAxIDM3MiAwMzQgZGl2IDkwMCA9IDEgNTI0XG4gICAgICAgICAqIENhbGN1bGF0ZSBjb2Rld29yZCA0XG4gICAgICAgICAqIGQ0ID0gMSA1MjQgbW9kIDkwMCA9IDYyNFxuICAgICAgICAgKlxuICAgICAgICAgKiB0ID0gMSA1MjQgZGl2IDkwMCA9IDFcbiAgICAgICAgICogQ2FsY3VsYXRlIGNvZGV3b3JkIDVcbiAgICAgICAgICogZDUgPSAxIG1vZCA5MDAgPSAxXG4gICAgICAgICAqIHQgPSAxIGRpdiA5MDAgPSAwXG4gICAgICAgICAqIENvZGV3b3JkIHNlcXVlbmNlIGlzOiAxLCA2MjQsIDQzNCwgNjMyLCAyODIsIDIwMFxuICAgICAgICAgKlxuICAgICAgICAgKiBEZWNvZGUgdGhlIGFib3ZlIGNvZGV3b3JkcyBpbnZvbHZlc1xuICAgICAgICAgKiAgIDEgeCA5MDAgcG93ZXIgb2YgNSArIDYyNCB4IDkwMCBwb3dlciBvZiA0ICsgNDM0IHggOTAwIHBvd2VyIG9mIDMgK1xuICAgICAgICAgKiA2MzIgeCA5MDAgcG93ZXIgb2YgMiArIDI4MiB4IDkwMCBwb3dlciBvZiAxICsgMjAwIHggOTAwIHBvd2VyIG9mIDAgPSAxMDAwMjEzMjk4MTc0MDAwXG4gICAgICAgICAqXG4gICAgICAgICAqIFJlbW92ZSBsZWFkaW5nIDEgPT4gIFJlc3VsdCBpcyAwMDAyMTMyOTgxNzQwMDBcbiAgICAgICAgICpcbiAgICAgICAgICogQHRocm93cyBGb3JtYXRFeGNlcHRpb25cbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBkZWNvZGVCYXNlOTAwdG9CYXNlMTAoY29kZXdvcmRzLCBjb3VudCkge1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IGNyZWF0ZUJpZ0ludCgwKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgLyppbnQqLyA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5FWFA5MDBbY291bnQgLSBpIC0gMV0gKiBjcmVhdGVCaWdJbnQoY29kZXdvcmRzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCByZXN1bHRTdHJpbmcgPSByZXN1bHQudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHRTdHJpbmcuY2hhckF0KDApICE9PSAnMScpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0U3RyaW5nLnN1YnN0cmluZygxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuVEVYVF9DT01QQUNUSU9OX01PREVfTEFUQ0ggPSA5MDA7XG4gICAgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLkJZVEVfQ09NUEFDVElPTl9NT0RFX0xBVENIID0gOTAxO1xuICAgIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5OVU1FUklDX0NPTVBBQ1RJT05fTU9ERV9MQVRDSCA9IDkwMjtcbiAgICBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuQllURV9DT01QQUNUSU9OX01PREVfTEFUQ0hfNiA9IDkyNDtcbiAgICBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuRUNJX1VTRVJfREVGSU5FRCA9IDkyNTtcbiAgICBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuRUNJX0dFTkVSQUxfUFVSUE9TRSA9IDkyNjtcbiAgICBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuRUNJX0NIQVJTRVQgPSA5Mjc7XG4gICAgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLkJFR0lOX01BQ1JPX1BERjQxN19DT05UUk9MX0JMT0NLID0gOTI4O1xuICAgIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5CRUdJTl9NQUNST19QREY0MTdfT1BUSU9OQUxfRklFTEQgPSA5MjM7XG4gICAgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLk1BQ1JPX1BERjQxN19URVJNSU5BVE9SID0gOTIyO1xuICAgIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5NT0RFX1NISUZUX1RPX0JZVEVfQ09NUEFDVElPTl9NT0RFID0gOTEzO1xuICAgIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5NQVhfTlVNRVJJQ19DT0RFV09SRFMgPSAxNTtcbiAgICBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuTUFDUk9fUERGNDE3X09QVElPTkFMX0ZJRUxEX0ZJTEVfTkFNRSA9IDA7XG4gICAgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLk1BQ1JPX1BERjQxN19PUFRJT05BTF9GSUVMRF9TRUdNRU5UX0NPVU5UID0gMTtcbiAgICBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuTUFDUk9fUERGNDE3X09QVElPTkFMX0ZJRUxEX1RJTUVfU1RBTVAgPSAyO1xuICAgIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5NQUNST19QREY0MTdfT1BUSU9OQUxfRklFTERfU0VOREVSID0gMztcbiAgICBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuTUFDUk9fUERGNDE3X09QVElPTkFMX0ZJRUxEX0FERFJFU1NFRSA9IDQ7XG4gICAgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLk1BQ1JPX1BERjQxN19PUFRJT05BTF9GSUVMRF9GSUxFX1NJWkUgPSA1O1xuICAgIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5NQUNST19QREY0MTdfT1BUSU9OQUxfRklFTERfQ0hFQ0tTVU0gPSA2O1xuICAgIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5QTCA9IDI1O1xuICAgIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5MTCA9IDI3O1xuICAgIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5BUyA9IDI3O1xuICAgIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5NTCA9IDI4O1xuICAgIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5BTCA9IDI4O1xuICAgIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5QUyA9IDI5O1xuICAgIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5QQUwgPSAyOTtcbiAgICBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuUFVOQ1RfQ0hBUlMgPSAnOzw+QFtcXFxcXV9gfiFcXHJcXHQsOlxcbi0uJC9cInwqKCk/e31cXCcnO1xuICAgIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5NSVhFRF9DSEFSUyA9ICcwMTIzNDU2Nzg5JlxcclxcdCw6Iy0uJC8rJSo9Xic7XG4gICAgLyoqXG4gICAgICogVGFibGUgY29udGFpbmluZyB2YWx1ZXMgZm9yIHRoZSBleHBvbmVudCBvZiA5MDAuXG4gICAgICogVGhpcyBpcyB1c2VkIGluIHRoZSBudW1lcmljIGNvbXBhY3Rpb24gZGVjb2RlIGFsZ29yaXRobS5cbiAgICAgKi9cbiAgICBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuRVhQOTAwID0gZ2V0QmlnSW50Q29uc3RydWN0b3IoKSA/IGdldEVYUDkwMCgpIDogW107XG4gICAgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLk5VTUJFUl9PRl9TRVFVRU5DRV9DT0RFV09SRFMgPSAyO1xuXG4gICAgLypcbiAgICAqIENvcHlyaWdodCAyMDEzIFpYaW5nIGF1dGhvcnNcbiAgICAqXG4gICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICAgKlxuICAgICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAgICAqXG4gICAgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICAgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICAgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgICAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgICAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICAgICovXG4gICAgLy8gaW1wb3J0IGphdmEudXRpbC5BcnJheUxpc3Q7XG4gICAgLy8gaW1wb3J0IGphdmEudXRpbC5Db2xsZWN0aW9uO1xuICAgIC8vIGltcG9ydCBqYXZhLnV0aWwuRm9ybWF0dGVyO1xuICAgIC8vIGltcG9ydCBqYXZhLnV0aWwuTGlzdDtcbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIEd1ZW50aGVyIEdyYXVcbiAgICAgKi9cbiAgICAvKnB1YmxpYyBmaW5hbCovIGNsYXNzIFBERjQxN1NjYW5uaW5nRGVjb2RlciB7XG4gICAgICAgIGNvbnN0cnVjdG9yKCkgeyB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAVE9ETyBkb24ndCBwYXNzIGluIG1pbkNvZGV3b3JkV2lkdGggYW5kIG1heENvZGV3b3JkV2lkdGgsIHBhc3MgaW4gYmFyY29kZSBjb2x1bW5zIGZvciBzdGFydCBhbmQgc3RvcCBwYXR0ZXJuXG4gICAgICAgICAqXG4gICAgICAgICAqIGNvbHVtbnMuIFRoYXQgd2F5IHdpZHRoIGNhbiBiZSBkZWR1Y3RlZCBmcm9tIHRoZSBwYXR0ZXJuIGNvbHVtbi5cbiAgICAgICAgICogVGhpcyBhcHByb2FjaCBhbHNvIGFsbG93cyB0byBkZXRlY3QgbW9yZSBkZXRhaWxzIGFib3V0IHRoZSBiYXJjb2RlLCBlLmcuIGlmIGEgYmFyIHR5cGUgKHdoaXRlIG9yIGJsYWNrKSBpcyB3aWRlclxuICAgICAgICAgKiB0aGFuIGl0IHNob3VsZCBiZS4gVGhpcyBjYW4gaGFwcGVuIGlmIHRoZSBzY2FubmVyIHVzZWQgYSBiYWQgYmxhY2twb2ludC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIEJpdE1hdHJpeFxuICAgICAgICAgKiBAcGFyYW0gaW1hZ2VcbiAgICAgICAgICogQHBhcmFtIFJlc3VsdFBvaW50XG4gICAgICAgICAqIEBwYXJhbSBpbWFnZVRvcExlZnRcbiAgICAgICAgICogQHBhcmFtIFJlc3VsdFBvaW50XG4gICAgICAgICAqIEBwYXJhbSBpbWFnZUJvdHRvbUxlZnRcbiAgICAgICAgICogQHBhcmFtIFJlc3VsdFBvaW50XG4gICAgICAgICAqIEBwYXJhbSBpbWFnZVRvcFJpZ2h0XG4gICAgICAgICAqIEBwYXJhbSBSZXN1bHRQb2ludFxuICAgICAgICAgKiBAcGFyYW0gaW1hZ2VCb3R0b21SaWdodFxuICAgICAgICAgKiBAcGFyYW0gaW50XG4gICAgICAgICAqIEBwYXJhbSBtaW5Db2Rld29yZFdpZHRoXG4gICAgICAgICAqIEBwYXJhbSBpbnRcbiAgICAgICAgICogQHBhcmFtIG1heENvZGV3b3JkV2lkdGhcbiAgICAgICAgICpcbiAgICAgICAgICogQHRocm93cyBOb3RGb3VuZEV4Y2VwdGlvblxuICAgICAgICAgKiBAdGhyb3dzIEZvcm1hdEV4Y2VwdGlvblxuICAgICAgICAgKiBAdGhyb3dzIENoZWNrc3VtRXhjZXB0aW9uXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgZGVjb2RlKGltYWdlLCBpbWFnZVRvcExlZnQsIGltYWdlQm90dG9tTGVmdCwgaW1hZ2VUb3BSaWdodCwgaW1hZ2VCb3R0b21SaWdodCwgbWluQ29kZXdvcmRXaWR0aCwgbWF4Q29kZXdvcmRXaWR0aCkge1xuICAgICAgICAgICAgbGV0IGJvdW5kaW5nQm94ID0gbmV3IEJvdW5kaW5nQm94KGltYWdlLCBpbWFnZVRvcExlZnQsIGltYWdlQm90dG9tTGVmdCwgaW1hZ2VUb3BSaWdodCwgaW1hZ2VCb3R0b21SaWdodCk7XG4gICAgICAgICAgICBsZXQgbGVmdFJvd0luZGljYXRvckNvbHVtbiA9IG51bGw7XG4gICAgICAgICAgICBsZXQgcmlnaHRSb3dJbmRpY2F0b3JDb2x1bW4gPSBudWxsO1xuICAgICAgICAgICAgbGV0IGRldGVjdGlvblJlc3VsdDtcbiAgICAgICAgICAgIGZvciAobGV0IGZpcnN0UGFzcyAvKmJvb2xlYW4qLyA9IHRydWU7OyBmaXJzdFBhc3MgPSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGlmIChpbWFnZVRvcExlZnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0Um93SW5kaWNhdG9yQ29sdW1uID0gUERGNDE3U2Nhbm5pbmdEZWNvZGVyLmdldFJvd0luZGljYXRvckNvbHVtbihpbWFnZSwgYm91bmRpbmdCb3gsIGltYWdlVG9wTGVmdCwgdHJ1ZSwgbWluQ29kZXdvcmRXaWR0aCwgbWF4Q29kZXdvcmRXaWR0aCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpbWFnZVRvcFJpZ2h0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmlnaHRSb3dJbmRpY2F0b3JDb2x1bW4gPSBQREY0MTdTY2FubmluZ0RlY29kZXIuZ2V0Um93SW5kaWNhdG9yQ29sdW1uKGltYWdlLCBib3VuZGluZ0JveCwgaW1hZ2VUb3BSaWdodCwgZmFsc2UsIG1pbkNvZGV3b3JkV2lkdGgsIG1heENvZGV3b3JkV2lkdGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZXRlY3Rpb25SZXN1bHQgPSBQREY0MTdTY2FubmluZ0RlY29kZXIubWVyZ2UobGVmdFJvd0luZGljYXRvckNvbHVtbiwgcmlnaHRSb3dJbmRpY2F0b3JDb2x1bW4pO1xuICAgICAgICAgICAgICAgIGlmIChkZXRlY3Rpb25SZXN1bHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBOb3RGb3VuZEV4Y2VwdGlvbi5nZXROb3RGb3VuZEluc3RhbmNlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCByZXN1bHRCb3ggPSBkZXRlY3Rpb25SZXN1bHQuZ2V0Qm91bmRpbmdCb3goKTtcbiAgICAgICAgICAgICAgICBpZiAoZmlyc3RQYXNzICYmIHJlc3VsdEJveCAhPSBudWxsICYmXG4gICAgICAgICAgICAgICAgICAgIChyZXN1bHRCb3guZ2V0TWluWSgpIDwgYm91bmRpbmdCb3guZ2V0TWluWSgpIHx8IHJlc3VsdEJveC5nZXRNYXhZKCkgPiBib3VuZGluZ0JveC5nZXRNYXhZKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJvdW5kaW5nQm94ID0gcmVzdWx0Qm94O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGV0ZWN0aW9uUmVzdWx0LnNldEJvdW5kaW5nQm94KGJvdW5kaW5nQm94KTtcbiAgICAgICAgICAgIGxldCBtYXhCYXJjb2RlQ29sdW1uID0gZGV0ZWN0aW9uUmVzdWx0LmdldEJhcmNvZGVDb2x1bW5Db3VudCgpICsgMTtcbiAgICAgICAgICAgIGRldGVjdGlvblJlc3VsdC5zZXREZXRlY3Rpb25SZXN1bHRDb2x1bW4oMCwgbGVmdFJvd0luZGljYXRvckNvbHVtbik7XG4gICAgICAgICAgICBkZXRlY3Rpb25SZXN1bHQuc2V0RGV0ZWN0aW9uUmVzdWx0Q29sdW1uKG1heEJhcmNvZGVDb2x1bW4sIHJpZ2h0Um93SW5kaWNhdG9yQ29sdW1uKTtcbiAgICAgICAgICAgIGxldCBsZWZ0VG9SaWdodCA9IGxlZnRSb3dJbmRpY2F0b3JDb2x1bW4gIT0gbnVsbDtcbiAgICAgICAgICAgIGZvciAobGV0IGJhcmNvZGVDb2x1bW5Db3VudCAvKmludCovID0gMTsgYmFyY29kZUNvbHVtbkNvdW50IDw9IG1heEJhcmNvZGVDb2x1bW47IGJhcmNvZGVDb2x1bW5Db3VudCsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGJhcmNvZGVDb2x1bW4gPSBsZWZ0VG9SaWdodCA/IGJhcmNvZGVDb2x1bW5Db3VudCA6IG1heEJhcmNvZGVDb2x1bW4gLSBiYXJjb2RlQ29sdW1uQ291bnQ7XG4gICAgICAgICAgICAgICAgaWYgKGRldGVjdGlvblJlc3VsdC5nZXREZXRlY3Rpb25SZXN1bHRDb2x1bW4oYmFyY29kZUNvbHVtbikgIT09IC8qIG51bGwgKi8gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgd2lsbCBiZSB0aGUgY2FzZSBmb3IgdGhlIG9wcG9zaXRlIHJvdyBpbmRpY2F0b3IgY29sdW1uLCB3aGljaCBkb2Vzbid0IG5lZWQgdG8gYmUgZGVjb2RlZCBhZ2Fpbi5cbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBkZXRlY3Rpb25SZXN1bHRDb2x1bW47XG4gICAgICAgICAgICAgICAgaWYgKGJhcmNvZGVDb2x1bW4gPT09IDAgfHwgYmFyY29kZUNvbHVtbiA9PT0gbWF4QmFyY29kZUNvbHVtbikge1xuICAgICAgICAgICAgICAgICAgICBkZXRlY3Rpb25SZXN1bHRDb2x1bW4gPSBuZXcgRGV0ZWN0aW9uUmVzdWx0Um93SW5kaWNhdG9yQ29sdW1uKGJvdW5kaW5nQm94LCBiYXJjb2RlQ29sdW1uID09PSAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRldGVjdGlvblJlc3VsdENvbHVtbiA9IG5ldyBEZXRlY3Rpb25SZXN1bHRDb2x1bW4oYm91bmRpbmdCb3gpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZXRlY3Rpb25SZXN1bHQuc2V0RGV0ZWN0aW9uUmVzdWx0Q29sdW1uKGJhcmNvZGVDb2x1bW4sIGRldGVjdGlvblJlc3VsdENvbHVtbik7XG4gICAgICAgICAgICAgICAgbGV0IHN0YXJ0Q29sdW1uID0gLTE7XG4gICAgICAgICAgICAgICAgbGV0IHByZXZpb3VzU3RhcnRDb2x1bW4gPSBzdGFydENvbHVtbjtcbiAgICAgICAgICAgICAgICAvLyBUT0RPIHN0YXJ0IGF0IGEgcm93IGZvciB3aGljaCB3ZSBrbm93IHRoZSBzdGFydCBwb3NpdGlvbiwgdGhlbiBkZXRlY3QgdXB3YXJkcyBhbmQgZG93bndhcmRzIGZyb20gdGhlcmUuXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaW1hZ2VSb3cgLyppbnQqLyA9IGJvdW5kaW5nQm94LmdldE1pblkoKTsgaW1hZ2VSb3cgPD0gYm91bmRpbmdCb3guZ2V0TWF4WSgpOyBpbWFnZVJvdysrKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0Q29sdW1uID0gUERGNDE3U2Nhbm5pbmdEZWNvZGVyLmdldFN0YXJ0Q29sdW1uKGRldGVjdGlvblJlc3VsdCwgYmFyY29kZUNvbHVtbiwgaW1hZ2VSb3csIGxlZnRUb1JpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXJ0Q29sdW1uIDwgMCB8fCBzdGFydENvbHVtbiA+IGJvdW5kaW5nQm94LmdldE1heFgoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByZXZpb3VzU3RhcnRDb2x1bW4gPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydENvbHVtbiA9IHByZXZpb3VzU3RhcnRDb2x1bW47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGV0IGNvZGV3b3JkID0gUERGNDE3U2Nhbm5pbmdEZWNvZGVyLmRldGVjdENvZGV3b3JkKGltYWdlLCBib3VuZGluZ0JveC5nZXRNaW5YKCksIGJvdW5kaW5nQm94LmdldE1heFgoKSwgbGVmdFRvUmlnaHQsIHN0YXJ0Q29sdW1uLCBpbWFnZVJvdywgbWluQ29kZXdvcmRXaWR0aCwgbWF4Q29kZXdvcmRXaWR0aCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2Rld29yZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXRlY3Rpb25SZXN1bHRDb2x1bW4uc2V0Q29kZXdvcmQoaW1hZ2VSb3csIGNvZGV3b3JkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXZpb3VzU3RhcnRDb2x1bW4gPSBzdGFydENvbHVtbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbkNvZGV3b3JkV2lkdGggPSBNYXRoLm1pbihtaW5Db2Rld29yZFdpZHRoLCBjb2Rld29yZC5nZXRXaWR0aCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heENvZGV3b3JkV2lkdGggPSBNYXRoLm1heChtYXhDb2Rld29yZFdpZHRoLCBjb2Rld29yZC5nZXRXaWR0aCgpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBQREY0MTdTY2FubmluZ0RlY29kZXIuY3JlYXRlRGVjb2RlclJlc3VsdChkZXRlY3Rpb25SZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gbGVmdFJvd0luZGljYXRvckNvbHVtblxuICAgICAgICAgKiBAcGFyYW0gcmlnaHRSb3dJbmRpY2F0b3JDb2x1bW5cbiAgICAgICAgICpcbiAgICAgICAgICogQHRocm93cyBOb3RGb3VuZEV4Y2VwdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIG1lcmdlKGxlZnRSb3dJbmRpY2F0b3JDb2x1bW4sIHJpZ2h0Um93SW5kaWNhdG9yQ29sdW1uKSB7XG4gICAgICAgICAgICBpZiAobGVmdFJvd0luZGljYXRvckNvbHVtbiA9PSBudWxsICYmIHJpZ2h0Um93SW5kaWNhdG9yQ29sdW1uID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBiYXJjb2RlTWV0YWRhdGEgPSBQREY0MTdTY2FubmluZ0RlY29kZXIuZ2V0QmFyY29kZU1ldGFkYXRhKGxlZnRSb3dJbmRpY2F0b3JDb2x1bW4sIHJpZ2h0Um93SW5kaWNhdG9yQ29sdW1uKTtcbiAgICAgICAgICAgIGlmIChiYXJjb2RlTWV0YWRhdGEgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGJvdW5kaW5nQm94ID0gQm91bmRpbmdCb3gubWVyZ2UoUERGNDE3U2Nhbm5pbmdEZWNvZGVyLmFkanVzdEJvdW5kaW5nQm94KGxlZnRSb3dJbmRpY2F0b3JDb2x1bW4pLCBQREY0MTdTY2FubmluZ0RlY29kZXIuYWRqdXN0Qm91bmRpbmdCb3gocmlnaHRSb3dJbmRpY2F0b3JDb2x1bW4pKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGV0ZWN0aW9uUmVzdWx0KGJhcmNvZGVNZXRhZGF0YSwgYm91bmRpbmdCb3gpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gcm93SW5kaWNhdG9yQ29sdW1uXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0aHJvd3MgTm90Rm91bmRFeGNlcHRpb25cbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBhZGp1c3RCb3VuZGluZ0JveChyb3dJbmRpY2F0b3JDb2x1bW4pIHtcbiAgICAgICAgICAgIGlmIChyb3dJbmRpY2F0b3JDb2x1bW4gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHJvd0hlaWdodHMgPSByb3dJbmRpY2F0b3JDb2x1bW4uZ2V0Um93SGVpZ2h0cygpO1xuICAgICAgICAgICAgaWYgKHJvd0hlaWdodHMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IG1heFJvd0hlaWdodCA9IFBERjQxN1NjYW5uaW5nRGVjb2Rlci5nZXRNYXgocm93SGVpZ2h0cyk7XG4gICAgICAgICAgICBsZXQgbWlzc2luZ1N0YXJ0Um93cyA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCByb3dIZWlnaHQgLyppbnQqLyBvZiByb3dIZWlnaHRzKSB7XG4gICAgICAgICAgICAgICAgbWlzc2luZ1N0YXJ0Um93cyArPSBtYXhSb3dIZWlnaHQgLSByb3dIZWlnaHQ7XG4gICAgICAgICAgICAgICAgaWYgKHJvd0hlaWdodCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGNvZGV3b3JkcyA9IHJvd0luZGljYXRvckNvbHVtbi5nZXRDb2Rld29yZHMoKTtcbiAgICAgICAgICAgIGZvciAobGV0IHJvdyAvKmludCovID0gMDsgbWlzc2luZ1N0YXJ0Um93cyA+IDAgJiYgY29kZXdvcmRzW3Jvd10gPT0gbnVsbDsgcm93KyspIHtcbiAgICAgICAgICAgICAgICBtaXNzaW5nU3RhcnRSb3dzLS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgbWlzc2luZ0VuZFJvd3MgPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgcm93IC8qaW50Ki8gPSByb3dIZWlnaHRzLmxlbmd0aCAtIDE7IHJvdyA+PSAwOyByb3ctLSkge1xuICAgICAgICAgICAgICAgIG1pc3NpbmdFbmRSb3dzICs9IG1heFJvd0hlaWdodCAtIHJvd0hlaWdodHNbcm93XTtcbiAgICAgICAgICAgICAgICBpZiAocm93SGVpZ2h0c1tyb3ddID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCByb3cgLyppbnQqLyA9IGNvZGV3b3Jkcy5sZW5ndGggLSAxOyBtaXNzaW5nRW5kUm93cyA+IDAgJiYgY29kZXdvcmRzW3Jvd10gPT0gbnVsbDsgcm93LS0pIHtcbiAgICAgICAgICAgICAgICBtaXNzaW5nRW5kUm93cy0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJvd0luZGljYXRvckNvbHVtbi5nZXRCb3VuZGluZ0JveCgpLmFkZE1pc3NpbmdSb3dzKG1pc3NpbmdTdGFydFJvd3MsIG1pc3NpbmdFbmRSb3dzLCByb3dJbmRpY2F0b3JDb2x1bW4uaXNMZWZ0KCkpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBnZXRNYXgodmFsdWVzKSB7XG4gICAgICAgICAgICBsZXQgbWF4VmFsdWUgPSAtMTtcbiAgICAgICAgICAgIGZvciAobGV0IHZhbHVlIC8qaW50Ki8gb2YgdmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgbWF4VmFsdWUgPSBNYXRoLm1heChtYXhWYWx1ZSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1heFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBnZXRCYXJjb2RlTWV0YWRhdGEobGVmdFJvd0luZGljYXRvckNvbHVtbiwgcmlnaHRSb3dJbmRpY2F0b3JDb2x1bW4pIHtcbiAgICAgICAgICAgIGxldCBsZWZ0QmFyY29kZU1ldGFkYXRhO1xuICAgICAgICAgICAgaWYgKGxlZnRSb3dJbmRpY2F0b3JDb2x1bW4gPT0gbnVsbCB8fFxuICAgICAgICAgICAgICAgIChsZWZ0QmFyY29kZU1ldGFkYXRhID0gbGVmdFJvd0luZGljYXRvckNvbHVtbi5nZXRCYXJjb2RlTWV0YWRhdGEoKSkgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByaWdodFJvd0luZGljYXRvckNvbHVtbiA9PSBudWxsID8gbnVsbCA6IHJpZ2h0Um93SW5kaWNhdG9yQ29sdW1uLmdldEJhcmNvZGVNZXRhZGF0YSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHJpZ2h0QmFyY29kZU1ldGFkYXRhO1xuICAgICAgICAgICAgaWYgKHJpZ2h0Um93SW5kaWNhdG9yQ29sdW1uID09IG51bGwgfHxcbiAgICAgICAgICAgICAgICAocmlnaHRCYXJjb2RlTWV0YWRhdGEgPSByaWdodFJvd0luZGljYXRvckNvbHVtbi5nZXRCYXJjb2RlTWV0YWRhdGEoKSkgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsZWZ0QmFyY29kZU1ldGFkYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxlZnRCYXJjb2RlTWV0YWRhdGEuZ2V0Q29sdW1uQ291bnQoKSAhPT0gcmlnaHRCYXJjb2RlTWV0YWRhdGEuZ2V0Q29sdW1uQ291bnQoKSAmJlxuICAgICAgICAgICAgICAgIGxlZnRCYXJjb2RlTWV0YWRhdGEuZ2V0RXJyb3JDb3JyZWN0aW9uTGV2ZWwoKSAhPT0gcmlnaHRCYXJjb2RlTWV0YWRhdGEuZ2V0RXJyb3JDb3JyZWN0aW9uTGV2ZWwoKSAmJlxuICAgICAgICAgICAgICAgIGxlZnRCYXJjb2RlTWV0YWRhdGEuZ2V0Um93Q291bnQoKSAhPT0gcmlnaHRCYXJjb2RlTWV0YWRhdGEuZ2V0Um93Q291bnQoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGxlZnRCYXJjb2RlTWV0YWRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGdldFJvd0luZGljYXRvckNvbHVtbihpbWFnZSwgYm91bmRpbmdCb3gsIHN0YXJ0UG9pbnQsIGxlZnRUb1JpZ2h0LCBtaW5Db2Rld29yZFdpZHRoLCBtYXhDb2Rld29yZFdpZHRoKSB7XG4gICAgICAgICAgICBsZXQgcm93SW5kaWNhdG9yQ29sdW1uID0gbmV3IERldGVjdGlvblJlc3VsdFJvd0luZGljYXRvckNvbHVtbihib3VuZGluZ0JveCwgbGVmdFRvUmlnaHQpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSAvKmludCovID0gMDsgaSA8IDI7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBpbmNyZW1lbnQgPSBpID09PSAwID8gMSA6IC0xO1xuICAgICAgICAgICAgICAgIGxldCBzdGFydENvbHVtbiA9IE1hdGgudHJ1bmMoTWF0aC50cnVuYyhzdGFydFBvaW50LmdldFgoKSkpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGltYWdlUm93IC8qaW50Ki8gPSBNYXRoLnRydW5jKE1hdGgudHJ1bmMoc3RhcnRQb2ludC5nZXRZKCkpKTsgaW1hZ2VSb3cgPD0gYm91bmRpbmdCb3guZ2V0TWF4WSgpICYmXG4gICAgICAgICAgICAgICAgICAgIGltYWdlUm93ID49IGJvdW5kaW5nQm94LmdldE1pblkoKTsgaW1hZ2VSb3cgKz0gaW5jcmVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjb2Rld29yZCA9IFBERjQxN1NjYW5uaW5nRGVjb2Rlci5kZXRlY3RDb2Rld29yZChpbWFnZSwgMCwgaW1hZ2UuZ2V0V2lkdGgoKSwgbGVmdFRvUmlnaHQsIHN0YXJ0Q29sdW1uLCBpbWFnZVJvdywgbWluQ29kZXdvcmRXaWR0aCwgbWF4Q29kZXdvcmRXaWR0aCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2Rld29yZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByb3dJbmRpY2F0b3JDb2x1bW4uc2V0Q29kZXdvcmQoaW1hZ2VSb3csIGNvZGV3b3JkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsZWZ0VG9SaWdodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0Q29sdW1uID0gY29kZXdvcmQuZ2V0U3RhcnRYKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydENvbHVtbiA9IGNvZGV3b3JkLmdldEVuZFgoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByb3dJbmRpY2F0b3JDb2x1bW47XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBkZXRlY3Rpb25SZXN1bHRcbiAgICAgICAgICogQHBhcmFtIEJhcmNvZGVWYWx1ZVxuICAgICAgICAgKiBAcGFyYW0gcGFyYW0yXG4gICAgICAgICAqIEBwYXJhbSBwYXJhbTNcbiAgICAgICAgICogQHBhcmFtIGJhcmNvZGVNYXRyaXhcbiAgICAgICAgICpcbiAgICAgICAgICogQHRocm93cyBOb3RGb3VuZEV4Y2VwdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGFkanVzdENvZGV3b3JkQ291bnQoZGV0ZWN0aW9uUmVzdWx0LCBiYXJjb2RlTWF0cml4KSB7XG4gICAgICAgICAgICBsZXQgYmFyY29kZU1hdHJpeDAxID0gYmFyY29kZU1hdHJpeFswXVsxXTtcbiAgICAgICAgICAgIGxldCBudW1iZXJPZkNvZGV3b3JkcyA9IGJhcmNvZGVNYXRyaXgwMS5nZXRWYWx1ZSgpO1xuICAgICAgICAgICAgbGV0IGNhbGN1bGF0ZWROdW1iZXJPZkNvZGV3b3JkcyA9IGRldGVjdGlvblJlc3VsdC5nZXRCYXJjb2RlQ29sdW1uQ291bnQoKSAqXG4gICAgICAgICAgICAgICAgZGV0ZWN0aW9uUmVzdWx0LmdldEJhcmNvZGVSb3dDb3VudCgpIC1cbiAgICAgICAgICAgICAgICBQREY0MTdTY2FubmluZ0RlY29kZXIuZ2V0TnVtYmVyT2ZFQ0NvZGVXb3JkcyhkZXRlY3Rpb25SZXN1bHQuZ2V0QmFyY29kZUVDTGV2ZWwoKSk7XG4gICAgICAgICAgICBpZiAobnVtYmVyT2ZDb2Rld29yZHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNhbGN1bGF0ZWROdW1iZXJPZkNvZGV3b3JkcyA8IDEgfHwgY2FsY3VsYXRlZE51bWJlck9mQ29kZXdvcmRzID4gUERGNDE3Q29tbW9uLk1BWF9DT0RFV09SRFNfSU5fQkFSQ09ERSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBOb3RGb3VuZEV4Y2VwdGlvbi5nZXROb3RGb3VuZEluc3RhbmNlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJhcmNvZGVNYXRyaXgwMS5zZXRWYWx1ZShjYWxjdWxhdGVkTnVtYmVyT2ZDb2Rld29yZHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobnVtYmVyT2ZDb2Rld29yZHNbMF0gIT09IGNhbGN1bGF0ZWROdW1iZXJPZkNvZGV3b3Jkcykge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBjYWxjdWxhdGVkIG9uZSBpcyBtb3JlIHJlbGlhYmxlIGFzIGl0IGlzIGRlcml2ZWQgZnJvbSB0aGUgcm93IGluZGljYXRvciBjb2x1bW5zXG4gICAgICAgICAgICAgICAgYmFyY29kZU1hdHJpeDAxLnNldFZhbHVlKGNhbGN1bGF0ZWROdW1iZXJPZkNvZGV3b3Jkcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBkZXRlY3Rpb25SZXN1bHRcbiAgICAgICAgICpcbiAgICAgICAgICogQHRocm93cyBGb3JtYXRFeGNlcHRpb25cbiAgICAgICAgICogQHRocm93cyBDaGVja3N1bUV4Y2VwdGlvblxuICAgICAgICAgKiBAdGhyb3dzIE5vdEZvdW5kRXhjZXB0aW9uXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgY3JlYXRlRGVjb2RlclJlc3VsdChkZXRlY3Rpb25SZXN1bHQpIHtcbiAgICAgICAgICAgIGxldCBiYXJjb2RlTWF0cml4ID0gUERGNDE3U2Nhbm5pbmdEZWNvZGVyLmNyZWF0ZUJhcmNvZGVNYXRyaXgoZGV0ZWN0aW9uUmVzdWx0KTtcbiAgICAgICAgICAgIFBERjQxN1NjYW5uaW5nRGVjb2Rlci5hZGp1c3RDb2Rld29yZENvdW50KGRldGVjdGlvblJlc3VsdCwgYmFyY29kZU1hdHJpeCk7XG4gICAgICAgICAgICBsZXQgZXJhc3VyZXMgLypDb2xsZWN0aW9uPEludGVnZXI+Ki8gPSBuZXcgQXJyYXkoKTtcbiAgICAgICAgICAgIGxldCBjb2Rld29yZHMgPSBuZXcgSW50MzJBcnJheShkZXRlY3Rpb25SZXN1bHQuZ2V0QmFyY29kZVJvd0NvdW50KCkgKiBkZXRlY3Rpb25SZXN1bHQuZ2V0QmFyY29kZUNvbHVtbkNvdW50KCkpO1xuICAgICAgICAgICAgbGV0IGFtYmlndW91c0luZGV4VmFsdWVzTGlzdCA9IC8qTGlzdDxpbnRbXT4qLyBbXTtcbiAgICAgICAgICAgIGxldCBhbWJpZ3VvdXNJbmRleGVzTGlzdCA9IC8qQ29sbGVjdGlvbjxJbnRlZ2VyPiovIG5ldyBBcnJheSgpO1xuICAgICAgICAgICAgZm9yIChsZXQgcm93IC8qaW50Ki8gPSAwOyByb3cgPCBkZXRlY3Rpb25SZXN1bHQuZ2V0QmFyY29kZVJvd0NvdW50KCk7IHJvdysrKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgY29sdW1uIC8qaW50Ki8gPSAwOyBjb2x1bW4gPCBkZXRlY3Rpb25SZXN1bHQuZ2V0QmFyY29kZUNvbHVtbkNvdW50KCk7IGNvbHVtbisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB2YWx1ZXMgPSBiYXJjb2RlTWF0cml4W3Jvd11bY29sdW1uICsgMV0uZ2V0VmFsdWUoKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNvZGV3b3JkSW5kZXggPSByb3cgKiBkZXRlY3Rpb25SZXN1bHQuZ2V0QmFyY29kZUNvbHVtbkNvdW50KCkgKyBjb2x1bW47XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcmFzdXJlcy5wdXNoKGNvZGV3b3JkSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGV3b3Jkc1tjb2Rld29yZEluZGV4XSA9IHZhbHVlc1swXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFtYmlndW91c0luZGV4ZXNMaXN0LnB1c2goY29kZXdvcmRJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbWJpZ3VvdXNJbmRleFZhbHVlc0xpc3QucHVzaCh2YWx1ZXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGFtYmlndW91c0luZGV4VmFsdWVzID0gbmV3IEFycmF5KGFtYmlndW91c0luZGV4VmFsdWVzTGlzdC5sZW5ndGgpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSAvKmludCovID0gMDsgaSA8IGFtYmlndW91c0luZGV4VmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYW1iaWd1b3VzSW5kZXhWYWx1ZXNbaV0gPSBhbWJpZ3VvdXNJbmRleFZhbHVlc0xpc3RbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUERGNDE3U2Nhbm5pbmdEZWNvZGVyLmNyZWF0ZURlY29kZXJSZXN1bHRGcm9tQW1iaWd1b3VzVmFsdWVzKGRldGVjdGlvblJlc3VsdC5nZXRCYXJjb2RlRUNMZXZlbCgpLCBjb2Rld29yZHMsIFBERjQxN0NvbW1vbi50b0ludEFycmF5KGVyYXN1cmVzKSwgUERGNDE3Q29tbW9uLnRvSW50QXJyYXkoYW1iaWd1b3VzSW5kZXhlc0xpc3QpLCBhbWJpZ3VvdXNJbmRleFZhbHVlcyk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgbWV0aG9kIGRlYWxzIHdpdGggdGhlIGZhY3QsIHRoYXQgdGhlIGRlY29kaW5nIHByb2Nlc3MgZG9lc24ndCBhbHdheXMgeWllbGQgYSBzaW5nbGUgbW9zdCBsaWtlbHkgdmFsdWUuIFRoZVxuICAgICAgICAgKiBjdXJyZW50IGVycm9yIGNvcnJlY3Rpb24gaW1wbGVtZW50YXRpb24gZG9lc24ndCBkZWFsIHdpdGggZXJhc3VyZXMgdmVyeSB3ZWxsLCBzbyBpdCdzIGJldHRlciB0byBwcm92aWRlIGEgdmFsdWVcbiAgICAgICAgICogZm9yIHRoZXNlIGFtYmlndW91cyBjb2Rld29yZHMgaW5zdGVhZCBvZiB0cmVhdGluZyBpdCBhcyBhbiBlcmFzdXJlLiBUaGUgcHJvYmxlbSBpcyB0aGF0IHdlIGRvbid0IGtub3cgd2hpY2ggb2ZcbiAgICAgICAgICogdGhlIGFtYmlndW91cyB2YWx1ZXMgdG8gY2hvb3NlLiBXZSB0cnkgZGVjb2RlIHVzaW5nIHRoZSBmaXJzdCB2YWx1ZSwgYW5kIGlmIHRoYXQgZmFpbHMsIHdlIHVzZSBhbm90aGVyIG9mIHRoZVxuICAgICAgICAgKiBhbWJpZ3VvdXMgdmFsdWVzIGFuZCB0cnkgdG8gZGVjb2RlIGFnYWluLiBUaGlzIHVzdWFsbHkgb25seSBoYXBwZW5zIG9uIHZlcnkgaGFyZCB0byByZWFkIGFuZCBkZWNvZGUgYmFyY29kZXMsXG4gICAgICAgICAqIHNvIGRlY29kaW5nIHRoZSBub3JtYWwgYmFyY29kZXMgaXMgbm90IGFmZmVjdGVkIGJ5IHRoaXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBlcmFzdXJlQXJyYXkgY29udGFpbnMgdGhlIGluZGV4ZXMgb2YgZXJhc3VyZXNcbiAgICAgICAgICogQHBhcmFtIGFtYmlndW91c0luZGV4ZXMgYXJyYXkgd2l0aCB0aGUgaW5kZXhlcyB0aGF0IGhhdmUgbW9yZSB0aGFuIG9uZSBtb3N0IGxpa2VseSB2YWx1ZVxuICAgICAgICAgKiBAcGFyYW0gYW1iaWd1b3VzSW5kZXhWYWx1ZXMgdHdvIGRpbWVuc2lvbmFsIGFycmF5IHRoYXQgY29udGFpbnMgdGhlIGFtYmlndW91cyB2YWx1ZXMuIFRoZSBmaXJzdCBkaW1lbnNpb24gbXVzdFxuICAgICAgICAgKiBiZSB0aGUgc2FtZSBsZW5ndGggYXMgdGhlIGFtYmlndW91c0luZGV4ZXMgYXJyYXlcbiAgICAgICAgICpcbiAgICAgICAgICogQHRocm93cyBGb3JtYXRFeGNlcHRpb25cbiAgICAgICAgICogQHRocm93cyBDaGVja3N1bUV4Y2VwdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGNyZWF0ZURlY29kZXJSZXN1bHRGcm9tQW1iaWd1b3VzVmFsdWVzKGVjTGV2ZWwsIGNvZGV3b3JkcywgZXJhc3VyZUFycmF5LCBhbWJpZ3VvdXNJbmRleGVzLCBhbWJpZ3VvdXNJbmRleFZhbHVlcykge1xuICAgICAgICAgICAgbGV0IGFtYmlndW91c0luZGV4Q291bnQgPSBuZXcgSW50MzJBcnJheShhbWJpZ3VvdXNJbmRleGVzLmxlbmd0aCk7XG4gICAgICAgICAgICBsZXQgdHJpZXMgPSAxMDA7XG4gICAgICAgICAgICB3aGlsZSAodHJpZXMtLSA+IDApIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpIC8qaW50Ki8gPSAwOyBpIDwgYW1iaWd1b3VzSW5kZXhDb3VudC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjb2Rld29yZHNbYW1iaWd1b3VzSW5kZXhlc1tpXV0gPSBhbWJpZ3VvdXNJbmRleFZhbHVlc1tpXVthbWJpZ3VvdXNJbmRleENvdW50W2ldXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBERjQxN1NjYW5uaW5nRGVjb2Rlci5kZWNvZGVDb2Rld29yZHMoY29kZXdvcmRzLCBlY0xldmVsLCBlcmFzdXJlQXJyYXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpZ25vcmVkID0gZXJyIGluc3RhbmNlb2YgQ2hlY2tzdW1FeGNlcHRpb247XG4gICAgICAgICAgICAgICAgICAgIGlmICghaWdub3JlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChhbWJpZ3VvdXNJbmRleENvdW50Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBDaGVja3N1bUV4Y2VwdGlvbi5nZXRDaGVja3N1bUluc3RhbmNlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgLyppbnQqLyA9IDA7IGkgPCBhbWJpZ3VvdXNJbmRleENvdW50Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhbWJpZ3VvdXNJbmRleENvdW50W2ldIDwgYW1iaWd1b3VzSW5kZXhWYWx1ZXNbaV0ubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYW1iaWd1b3VzSW5kZXhDb3VudFtpXSsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbWJpZ3VvdXNJbmRleENvdW50W2ldID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpID09PSBhbWJpZ3VvdXNJbmRleENvdW50Lmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBDaGVja3N1bUV4Y2VwdGlvbi5nZXRDaGVja3N1bUluc3RhbmNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBDaGVja3N1bUV4Y2VwdGlvbi5nZXRDaGVja3N1bUluc3RhbmNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGNyZWF0ZUJhcmNvZGVNYXRyaXgoZGV0ZWN0aW9uUmVzdWx0KSB7XG4gICAgICAgICAgICAvLyBsZXQgYmFyY29kZU1hdHJpeDogQmFyY29kZVZhbHVlW11bXSA9XG4gICAgICAgICAgICAvLyBuZXcgQmFyY29kZVZhbHVlW2RldGVjdGlvblJlc3VsdC5nZXRCYXJjb2RlUm93Q291bnQoKV1bZGV0ZWN0aW9uUmVzdWx0LmdldEJhcmNvZGVDb2x1bW5Db3VudCgpICsgMl07XG4gICAgICAgICAgICBsZXQgYmFyY29kZU1hdHJpeCA9IEFycmF5LmZyb20oeyBsZW5ndGg6IGRldGVjdGlvblJlc3VsdC5nZXRCYXJjb2RlUm93Q291bnQoKSB9LCAoKSA9PiBuZXcgQXJyYXkoZGV0ZWN0aW9uUmVzdWx0LmdldEJhcmNvZGVDb2x1bW5Db3VudCgpICsgMikpO1xuICAgICAgICAgICAgZm9yIChsZXQgcm93IC8qaW50Ki8gPSAwOyByb3cgPCBiYXJjb2RlTWF0cml4Lmxlbmd0aDsgcm93KyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBjb2x1bW4gLyppbnQqLyA9IDA7IGNvbHVtbiA8IGJhcmNvZGVNYXRyaXhbcm93XS5sZW5ndGg7IGNvbHVtbisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGJhcmNvZGVNYXRyaXhbcm93XVtjb2x1bW5dID0gbmV3IEJhcmNvZGVWYWx1ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBjb2x1bW4gPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgZGV0ZWN0aW9uUmVzdWx0Q29sdW1uIC8qRGV0ZWN0aW9uUmVzdWx0Q29sdW1uKi8gb2YgZGV0ZWN0aW9uUmVzdWx0LmdldERldGVjdGlvblJlc3VsdENvbHVtbnMoKSkge1xuICAgICAgICAgICAgICAgIGlmIChkZXRlY3Rpb25SZXN1bHRDb2x1bW4gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBjb2Rld29yZCAvKkNvZGV3b3JkKi8gb2YgZGV0ZWN0aW9uUmVzdWx0Q29sdW1uLmdldENvZGV3b3JkcygpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29kZXdvcmQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCByb3dOdW1iZXIgPSBjb2Rld29yZC5nZXRSb3dOdW1iZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocm93TnVtYmVyID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJvd051bWJlciA+PSBiYXJjb2RlTWF0cml4Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgaGF2ZSBtb3JlIHJvd3MgdGhhbiB0aGUgYmFyY29kZSBtZXRhZGF0YSBhbGxvd3MgZm9yLCBpZ25vcmUgdGhlbS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhcmNvZGVNYXRyaXhbcm93TnVtYmVyXVtjb2x1bW5dLnNldFZhbHVlKGNvZGV3b3JkLmdldFZhbHVlKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb2x1bW4rKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBiYXJjb2RlTWF0cml4O1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBpc1ZhbGlkQmFyY29kZUNvbHVtbihkZXRlY3Rpb25SZXN1bHQsIGJhcmNvZGVDb2x1bW4pIHtcbiAgICAgICAgICAgIHJldHVybiBiYXJjb2RlQ29sdW1uID49IDAgJiYgYmFyY29kZUNvbHVtbiA8PSBkZXRlY3Rpb25SZXN1bHQuZ2V0QmFyY29kZUNvbHVtbkNvdW50KCkgKyAxO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBnZXRTdGFydENvbHVtbihkZXRlY3Rpb25SZXN1bHQsIGJhcmNvZGVDb2x1bW4sIGltYWdlUm93LCBsZWZ0VG9SaWdodCkge1xuICAgICAgICAgICAgbGV0IG9mZnNldCA9IGxlZnRUb1JpZ2h0ID8gMSA6IC0xO1xuICAgICAgICAgICAgbGV0IGNvZGV3b3JkID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChQREY0MTdTY2FubmluZ0RlY29kZXIuaXNWYWxpZEJhcmNvZGVDb2x1bW4oZGV0ZWN0aW9uUmVzdWx0LCBiYXJjb2RlQ29sdW1uIC0gb2Zmc2V0KSkge1xuICAgICAgICAgICAgICAgIGNvZGV3b3JkID0gZGV0ZWN0aW9uUmVzdWx0LmdldERldGVjdGlvblJlc3VsdENvbHVtbihiYXJjb2RlQ29sdW1uIC0gb2Zmc2V0KS5nZXRDb2Rld29yZChpbWFnZVJvdyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29kZXdvcmQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsZWZ0VG9SaWdodCA/IGNvZGV3b3JkLmdldEVuZFgoKSA6IGNvZGV3b3JkLmdldFN0YXJ0WCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29kZXdvcmQgPSBkZXRlY3Rpb25SZXN1bHQuZ2V0RGV0ZWN0aW9uUmVzdWx0Q29sdW1uKGJhcmNvZGVDb2x1bW4pLmdldENvZGV3b3JkTmVhcmJ5KGltYWdlUm93KTtcbiAgICAgICAgICAgIGlmIChjb2Rld29yZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxlZnRUb1JpZ2h0ID8gY29kZXdvcmQuZ2V0U3RhcnRYKCkgOiBjb2Rld29yZC5nZXRFbmRYKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoUERGNDE3U2Nhbm5pbmdEZWNvZGVyLmlzVmFsaWRCYXJjb2RlQ29sdW1uKGRldGVjdGlvblJlc3VsdCwgYmFyY29kZUNvbHVtbiAtIG9mZnNldCkpIHtcbiAgICAgICAgICAgICAgICBjb2Rld29yZCA9IGRldGVjdGlvblJlc3VsdC5nZXREZXRlY3Rpb25SZXN1bHRDb2x1bW4oYmFyY29kZUNvbHVtbiAtIG9mZnNldCkuZ2V0Q29kZXdvcmROZWFyYnkoaW1hZ2VSb3cpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvZGV3b3JkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGVmdFRvUmlnaHQgPyBjb2Rld29yZC5nZXRFbmRYKCkgOiBjb2Rld29yZC5nZXRTdGFydFgoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBza2lwcGVkQ29sdW1ucyA9IDA7XG4gICAgICAgICAgICB3aGlsZSAoUERGNDE3U2Nhbm5pbmdEZWNvZGVyLmlzVmFsaWRCYXJjb2RlQ29sdW1uKGRldGVjdGlvblJlc3VsdCwgYmFyY29kZUNvbHVtbiAtIG9mZnNldCkpIHtcbiAgICAgICAgICAgICAgICBiYXJjb2RlQ29sdW1uIC09IG9mZnNldDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBwcmV2aW91c1Jvd0NvZGV3b3JkIC8qQ29kZXdvcmQqLyBvZiBkZXRlY3Rpb25SZXN1bHQuZ2V0RGV0ZWN0aW9uUmVzdWx0Q29sdW1uKGJhcmNvZGVDb2x1bW4pLmdldENvZGV3b3JkcygpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcmV2aW91c1Jvd0NvZGV3b3JkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAobGVmdFRvUmlnaHQgPyBwcmV2aW91c1Jvd0NvZGV3b3JkLmdldEVuZFgoKSA6IHByZXZpb3VzUm93Q29kZXdvcmQuZ2V0U3RhcnRYKCkpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBza2lwcGVkQ29sdW1ucyAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChwcmV2aW91c1Jvd0NvZGV3b3JkLmdldEVuZFgoKSAtIHByZXZpb3VzUm93Q29kZXdvcmQuZ2V0U3RhcnRYKCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNraXBwZWRDb2x1bW5zKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbGVmdFRvUmlnaHQgPyBkZXRlY3Rpb25SZXN1bHQuZ2V0Qm91bmRpbmdCb3goKS5nZXRNaW5YKCkgOiBkZXRlY3Rpb25SZXN1bHQuZ2V0Qm91bmRpbmdCb3goKS5nZXRNYXhYKCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGRldGVjdENvZGV3b3JkKGltYWdlLCBtaW5Db2x1bW4sIG1heENvbHVtbiwgbGVmdFRvUmlnaHQsIHN0YXJ0Q29sdW1uLCBpbWFnZVJvdywgbWluQ29kZXdvcmRXaWR0aCwgbWF4Q29kZXdvcmRXaWR0aCkge1xuICAgICAgICAgICAgc3RhcnRDb2x1bW4gPSBQREY0MTdTY2FubmluZ0RlY29kZXIuYWRqdXN0Q29kZXdvcmRTdGFydENvbHVtbihpbWFnZSwgbWluQ29sdW1uLCBtYXhDb2x1bW4sIGxlZnRUb1JpZ2h0LCBzdGFydENvbHVtbiwgaW1hZ2VSb3cpO1xuICAgICAgICAgICAgLy8gd2UgdXN1YWxseSBrbm93IGZhaXJseSBleGFjdCBub3cgaG93IGxvbmcgYSBjb2Rld29yZCBpcy4gV2Ugc2hvdWxkIHByb3ZpZGUgbWluaW11bSBhbmQgbWF4aW11bSBleHBlY3RlZCBsZW5ndGhcbiAgICAgICAgICAgIC8vIGFuZCB0cnkgdG8gYWRqdXN0IHRoZSByZWFkIHBpeGVscywgZS5nLiByZW1vdmUgc2luZ2xlIHBpeGVsIGVycm9ycyBvciB0cnkgdG8gY3V0IG9mZiBleGNlZWRpbmcgcGl4ZWxzLlxuICAgICAgICAgICAgLy8gbWluIGFuZCBtYXhDb2Rld29yZFdpZHRoIHNob3VsZCBub3QgYmUgdXNlZCBhcyB0aGV5IGFyZSBjYWxjdWxhdGVkIGZvciB0aGUgd2hvbGUgYmFyY29kZSBhbiBjYW4gYmUgaW5hY2N1cmF0ZVxuICAgICAgICAgICAgLy8gZm9yIHRoZSBjdXJyZW50IHBvc2l0aW9uXG4gICAgICAgICAgICBsZXQgbW9kdWxlQml0Q291bnQgPSBQREY0MTdTY2FubmluZ0RlY29kZXIuZ2V0TW9kdWxlQml0Q291bnQoaW1hZ2UsIG1pbkNvbHVtbiwgbWF4Q29sdW1uLCBsZWZ0VG9SaWdodCwgc3RhcnRDb2x1bW4sIGltYWdlUm93KTtcbiAgICAgICAgICAgIGlmIChtb2R1bGVCaXRDb3VudCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZW5kQ29sdW1uO1xuICAgICAgICAgICAgbGV0IGNvZGV3b3JkQml0Q291bnQgPSBNYXRoVXRpbHMuc3VtKG1vZHVsZUJpdENvdW50KTtcbiAgICAgICAgICAgIGlmIChsZWZ0VG9SaWdodCkge1xuICAgICAgICAgICAgICAgIGVuZENvbHVtbiA9IHN0YXJ0Q29sdW1uICsgY29kZXdvcmRCaXRDb3VudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgLyppbnQqLyA9IDA7IGkgPCBtb2R1bGVCaXRDb3VudC5sZW5ndGggLyAyOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRtcENvdW50ID0gbW9kdWxlQml0Q291bnRbaV07XG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZUJpdENvdW50W2ldID0gbW9kdWxlQml0Q291bnRbbW9kdWxlQml0Q291bnQubGVuZ3RoIC0gMSAtIGldO1xuICAgICAgICAgICAgICAgICAgICBtb2R1bGVCaXRDb3VudFttb2R1bGVCaXRDb3VudC5sZW5ndGggLSAxIC0gaV0gPSB0bXBDb3VudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZW5kQ29sdW1uID0gc3RhcnRDb2x1bW47XG4gICAgICAgICAgICAgICAgc3RhcnRDb2x1bW4gPSBlbmRDb2x1bW4gLSBjb2Rld29yZEJpdENvdW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVE9ETyBpbXBsZW1lbnQgY2hlY2sgZm9yIHdpZHRoIGFuZCBjb3JyZWN0aW9uIG9mIGJsYWNrIGFuZCB3aGl0ZSBiYXJzXG4gICAgICAgICAgICAvLyB1c2Ugc3RhcnQgKGFuZCBtYXliZSBzdG9wIHBhdHRlcm4pIHRvIGRldGVybWluZSBpZiBibGFjayBiYXJzIGFyZSB3aWRlciB0aGFuIHdoaXRlIGJhcnMuIElmIHNvLCBhZGp1c3QuXG4gICAgICAgICAgICAvLyBzaG91bGQgcHJvYmFibHkgZG9uZSBvbmx5IGZvciBjb2Rld29yZHMgd2l0aCBhIGxvdCBtb3JlIHRoYW4gMTcgYml0cy5cbiAgICAgICAgICAgIC8vIFRoZSBmb2xsb3dpbmcgZml4ZXMgMTAtMS5wbmcsIHdoaWNoIGhhcyB3aWRlIGJsYWNrIGJhcnMgYW5kIHNtYWxsIHdoaXRlIGJhcnNcbiAgICAgICAgICAgIC8vICAgIGZvciAobGV0IGkgLyppbnQqLyA9IDA7IGkgPCBtb2R1bGVCaXRDb3VudC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgLy8gICAgICBpZiAoaSAlIDIgPT09IDApIHtcbiAgICAgICAgICAgIC8vICAgICAgICBtb2R1bGVCaXRDb3VudFtpXS0tO1xuICAgICAgICAgICAgLy8gICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gICAgICAgIG1vZHVsZUJpdENvdW50W2ldKys7XG4gICAgICAgICAgICAvLyAgICAgIH1cbiAgICAgICAgICAgIC8vICAgIH1cbiAgICAgICAgICAgIC8vIFdlIGNvdWxkIGFsc28gdXNlIHRoZSB3aWR0aCBvZiBzdXJyb3VuZGluZyBjb2Rld29yZHMgZm9yIG1vcmUgYWNjdXJhdGUgcmVzdWx0cywgYnV0IHRoaXMgc2VlbXNcbiAgICAgICAgICAgIC8vIHN1ZmZpY2llbnQgZm9yIG5vd1xuICAgICAgICAgICAgaWYgKCFQREY0MTdTY2FubmluZ0RlY29kZXIuY2hlY2tDb2Rld29yZFNrZXcoY29kZXdvcmRCaXRDb3VudCwgbWluQ29kZXdvcmRXaWR0aCwgbWF4Q29kZXdvcmRXaWR0aCkpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBjb3VsZCB0cnkgdG8gdXNlIHRoZSBzdGFydFggYW5kIGVuZFggcG9zaXRpb24gb2YgdGhlIGNvZGV3b3JkIGluIHRoZSBzYW1lIGNvbHVtbiBpbiB0aGUgcHJldmlvdXMgcm93LFxuICAgICAgICAgICAgICAgIC8vIGNyZWF0ZSB0aGUgYml0IGNvdW50IGZyb20gaXQgYW5kIG5vcm1hbGl6ZSBpdCB0byA4LiBUaGlzIHdvdWxkIGhlbHAgd2l0aCBzaW5nbGUgcGl4ZWwgZXJyb3JzLlxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGRlY29kZWRWYWx1ZSA9IFBERjQxN0NvZGV3b3JkRGVjb2Rlci5nZXREZWNvZGVkVmFsdWUobW9kdWxlQml0Q291bnQpO1xuICAgICAgICAgICAgbGV0IGNvZGV3b3JkID0gUERGNDE3Q29tbW9uLmdldENvZGV3b3JkKGRlY29kZWRWYWx1ZSk7XG4gICAgICAgICAgICBpZiAoY29kZXdvcmQgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IENvZGV3b3JkKHN0YXJ0Q29sdW1uLCBlbmRDb2x1bW4sIFBERjQxN1NjYW5uaW5nRGVjb2Rlci5nZXRDb2Rld29yZEJ1Y2tldE51bWJlcihkZWNvZGVkVmFsdWUpLCBjb2Rld29yZCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGdldE1vZHVsZUJpdENvdW50KGltYWdlLCBtaW5Db2x1bW4sIG1heENvbHVtbiwgbGVmdFRvUmlnaHQsIHN0YXJ0Q29sdW1uLCBpbWFnZVJvdykge1xuICAgICAgICAgICAgbGV0IGltYWdlQ29sdW1uID0gc3RhcnRDb2x1bW47XG4gICAgICAgICAgICBsZXQgbW9kdWxlQml0Q291bnQgPSBuZXcgSW50MzJBcnJheSg4KTtcbiAgICAgICAgICAgIGxldCBtb2R1bGVOdW1iZXIgPSAwO1xuICAgICAgICAgICAgbGV0IGluY3JlbWVudCA9IGxlZnRUb1JpZ2h0ID8gMSA6IC0xO1xuICAgICAgICAgICAgbGV0IHByZXZpb3VzUGl4ZWxWYWx1ZSA9IGxlZnRUb1JpZ2h0O1xuICAgICAgICAgICAgd2hpbGUgKChsZWZ0VG9SaWdodCA/IGltYWdlQ29sdW1uIDwgbWF4Q29sdW1uIDogaW1hZ2VDb2x1bW4gPj0gbWluQ29sdW1uKSAmJlxuICAgICAgICAgICAgICAgIG1vZHVsZU51bWJlciA8IG1vZHVsZUJpdENvdW50Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGlmIChpbWFnZS5nZXQoaW1hZ2VDb2x1bW4sIGltYWdlUm93KSA9PT0gcHJldmlvdXNQaXhlbFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZUJpdENvdW50W21vZHVsZU51bWJlcl0rKztcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2VDb2x1bW4gKz0gaW5jcmVtZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbW9kdWxlTnVtYmVyKys7XG4gICAgICAgICAgICAgICAgICAgIHByZXZpb3VzUGl4ZWxWYWx1ZSA9ICFwcmV2aW91c1BpeGVsVmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1vZHVsZU51bWJlciA9PT0gbW9kdWxlQml0Q291bnQubGVuZ3RoIHx8XG4gICAgICAgICAgICAgICAgKChpbWFnZUNvbHVtbiA9PT0gKGxlZnRUb1JpZ2h0ID8gbWF4Q29sdW1uIDogbWluQ29sdW1uKSkgJiZcbiAgICAgICAgICAgICAgICAgICAgbW9kdWxlTnVtYmVyID09PSBtb2R1bGVCaXRDb3VudC5sZW5ndGggLSAxKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtb2R1bGVCaXRDb3VudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBnZXROdW1iZXJPZkVDQ29kZVdvcmRzKGJhcmNvZGVFQ0xldmVsKSB7XG4gICAgICAgICAgICByZXR1cm4gMiA8PCBiYXJjb2RlRUNMZXZlbDtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgYWRqdXN0Q29kZXdvcmRTdGFydENvbHVtbihpbWFnZSwgbWluQ29sdW1uLCBtYXhDb2x1bW4sIGxlZnRUb1JpZ2h0LCBjb2Rld29yZFN0YXJ0Q29sdW1uLCBpbWFnZVJvdykge1xuICAgICAgICAgICAgbGV0IGNvcnJlY3RlZFN0YXJ0Q29sdW1uID0gY29kZXdvcmRTdGFydENvbHVtbjtcbiAgICAgICAgICAgIGxldCBpbmNyZW1lbnQgPSBsZWZ0VG9SaWdodCA/IC0xIDogMTtcbiAgICAgICAgICAgIC8vIHRoZXJlIHNob3VsZCBiZSBubyBibGFjayBwaXhlbHMgYmVmb3JlIHRoZSBzdGFydCBjb2x1bW4uIElmIHRoZXJlIGFyZSwgdGhlbiB3ZSBuZWVkIHRvIHN0YXJ0IGVhcmxpZXIuXG4gICAgICAgICAgICBmb3IgKGxldCBpIC8qaW50Ki8gPSAwOyBpIDwgMjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKChsZWZ0VG9SaWdodCA/IGNvcnJlY3RlZFN0YXJ0Q29sdW1uID49IG1pbkNvbHVtbiA6IGNvcnJlY3RlZFN0YXJ0Q29sdW1uIDwgbWF4Q29sdW1uKSAmJlxuICAgICAgICAgICAgICAgICAgICBsZWZ0VG9SaWdodCA9PT0gaW1hZ2UuZ2V0KGNvcnJlY3RlZFN0YXJ0Q29sdW1uLCBpbWFnZVJvdykpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKGNvZGV3b3JkU3RhcnRDb2x1bW4gLSBjb3JyZWN0ZWRTdGFydENvbHVtbikgPiBQREY0MTdTY2FubmluZ0RlY29kZXIuQ09ERVdPUkRfU0tFV19TSVpFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29kZXdvcmRTdGFydENvbHVtbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb3JyZWN0ZWRTdGFydENvbHVtbiArPSBpbmNyZW1lbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGluY3JlbWVudCA9IC1pbmNyZW1lbnQ7XG4gICAgICAgICAgICAgICAgbGVmdFRvUmlnaHQgPSAhbGVmdFRvUmlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY29ycmVjdGVkU3RhcnRDb2x1bW47XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGNoZWNrQ29kZXdvcmRTa2V3KGNvZGV3b3JkU2l6ZSwgbWluQ29kZXdvcmRXaWR0aCwgbWF4Q29kZXdvcmRXaWR0aCkge1xuICAgICAgICAgICAgcmV0dXJuIG1pbkNvZGV3b3JkV2lkdGggLSBQREY0MTdTY2FubmluZ0RlY29kZXIuQ09ERVdPUkRfU0tFV19TSVpFIDw9IGNvZGV3b3JkU2l6ZSAmJlxuICAgICAgICAgICAgICAgIGNvZGV3b3JkU2l6ZSA8PSBtYXhDb2Rld29yZFdpZHRoICsgUERGNDE3U2Nhbm5pbmdEZWNvZGVyLkNPREVXT1JEX1NLRVdfU0laRTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHRocm93cyBGb3JtYXRFeGNlcHRpb24sXG4gICAgICAgICAqIEB0aHJvd3MgQ2hlY2tzdW1FeGNlcHRpb25cbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBkZWNvZGVDb2Rld29yZHMoY29kZXdvcmRzLCBlY0xldmVsLCBlcmFzdXJlcykge1xuICAgICAgICAgICAgaWYgKGNvZGV3b3Jkcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBGb3JtYXRFeGNlcHRpb24uZ2V0Rm9ybWF0SW5zdGFuY2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBudW1FQ0NvZGV3b3JkcyA9IDEgPDwgKGVjTGV2ZWwgKyAxKTtcbiAgICAgICAgICAgIGxldCBjb3JyZWN0ZWRFcnJvcnNDb3VudCA9IFBERjQxN1NjYW5uaW5nRGVjb2Rlci5jb3JyZWN0RXJyb3JzKGNvZGV3b3JkcywgZXJhc3VyZXMsIG51bUVDQ29kZXdvcmRzKTtcbiAgICAgICAgICAgIFBERjQxN1NjYW5uaW5nRGVjb2Rlci52ZXJpZnlDb2Rld29yZENvdW50KGNvZGV3b3JkcywgbnVtRUNDb2Rld29yZHMpO1xuICAgICAgICAgICAgLy8gRGVjb2RlIHRoZSBjb2Rld29yZHNcbiAgICAgICAgICAgIGxldCBkZWNvZGVyUmVzdWx0ID0gRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLmRlY29kZShjb2Rld29yZHMsICcnICsgZWNMZXZlbCk7XG4gICAgICAgICAgICBkZWNvZGVyUmVzdWx0LnNldEVycm9yc0NvcnJlY3RlZChjb3JyZWN0ZWRFcnJvcnNDb3VudCk7XG4gICAgICAgICAgICBkZWNvZGVyUmVzdWx0LnNldEVyYXN1cmVzKGVyYXN1cmVzLmxlbmd0aCk7XG4gICAgICAgICAgICByZXR1cm4gZGVjb2RlclJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogPHA+R2l2ZW4gZGF0YSBhbmQgZXJyb3ItY29ycmVjdGlvbiBjb2Rld29yZHMgcmVjZWl2ZWQsIHBvc3NpYmx5IGNvcnJ1cHRlZCBieSBlcnJvcnMsIGF0dGVtcHRzIHRvXG4gICAgICAgICAqIGNvcnJlY3QgdGhlIGVycm9ycyBpbi1wbGFjZS48L3A+XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBjb2Rld29yZHMgICBkYXRhIGFuZCBlcnJvciBjb3JyZWN0aW9uIGNvZGV3b3Jkc1xuICAgICAgICAgKiBAcGFyYW0gZXJhc3VyZXMgcG9zaXRpb25zIG9mIGFueSBrbm93biBlcmFzdXJlc1xuICAgICAgICAgKiBAcGFyYW0gbnVtRUNDb2Rld29yZHMgbnVtYmVyIG9mIGVycm9yIGNvcnJlY3Rpb24gY29kZXdvcmRzIHRoYXQgYXJlIGF2YWlsYWJsZSBpbiBjb2Rld29yZHNcbiAgICAgICAgICogQHRocm93cyBDaGVja3N1bUV4Y2VwdGlvbiBpZiBlcnJvciBjb3JyZWN0aW9uIGZhaWxzXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgY29ycmVjdEVycm9ycyhjb2Rld29yZHMsIGVyYXN1cmVzLCBudW1FQ0NvZGV3b3Jkcykge1xuICAgICAgICAgICAgaWYgKGVyYXN1cmVzICE9IG51bGwgJiZcbiAgICAgICAgICAgICAgICBlcmFzdXJlcy5sZW5ndGggPiBudW1FQ0NvZGV3b3JkcyAvIDIgKyBQREY0MTdTY2FubmluZ0RlY29kZXIuTUFYX0VSUk9SUyB8fFxuICAgICAgICAgICAgICAgIG51bUVDQ29kZXdvcmRzIDwgMCB8fFxuICAgICAgICAgICAgICAgIG51bUVDQ29kZXdvcmRzID4gUERGNDE3U2Nhbm5pbmdEZWNvZGVyLk1BWF9FQ19DT0RFV09SRFMpIHtcbiAgICAgICAgICAgICAgICAvLyBUb28gbWFueSBlcnJvcnMgb3IgRUMgQ29kZXdvcmRzIGlzIGNvcnJ1cHRlZFxuICAgICAgICAgICAgICAgIHRocm93IENoZWNrc3VtRXhjZXB0aW9uLmdldENoZWNrc3VtSW5zdGFuY2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBQREY0MTdTY2FubmluZ0RlY29kZXIuZXJyb3JDb3JyZWN0aW9uLmRlY29kZShjb2Rld29yZHMsIG51bUVDQ29kZXdvcmRzLCBlcmFzdXJlcyk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFZlcmlmeSB0aGF0IGFsbCBpcyBPSyB3aXRoIHRoZSBjb2Rld29yZCBhcnJheS5cbiAgICAgICAgICogQHRocm93cyBGb3JtYXRFeGNlcHRpb25cbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyB2ZXJpZnlDb2Rld29yZENvdW50KGNvZGV3b3JkcywgbnVtRUNDb2Rld29yZHMpIHtcbiAgICAgICAgICAgIGlmIChjb2Rld29yZHMubGVuZ3RoIDwgNCkge1xuICAgICAgICAgICAgICAgIC8vIENvZGV3b3JkIGFycmF5IHNpemUgc2hvdWxkIGJlIGF0IGxlYXN0IDQgYWxsb3dpbmcgZm9yXG4gICAgICAgICAgICAgICAgLy8gQ291bnQgQ1csIEF0IGxlYXN0IG9uZSBEYXRhIENXLCBFcnJvciBDb3JyZWN0aW9uIENXLCBFcnJvciBDb3JyZWN0aW9uIENXXG4gICAgICAgICAgICAgICAgdGhyb3cgRm9ybWF0RXhjZXB0aW9uLmdldEZvcm1hdEluc3RhbmNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUaGUgZmlyc3QgY29kZXdvcmQsIHRoZSBTeW1ib2wgTGVuZ3RoIERlc2NyaXB0b3IsIHNoYWxsIGFsd2F5cyBlbmNvZGUgdGhlIHRvdGFsIG51bWJlciBvZiBkYXRhXG4gICAgICAgICAgICAvLyBjb2Rld29yZHMgaW4gdGhlIHN5bWJvbCwgaW5jbHVkaW5nIHRoZSBTeW1ib2wgTGVuZ3RoIERlc2NyaXB0b3IgaXRzZWxmLCBkYXRhIGNvZGV3b3JkcyBhbmQgcGFkXG4gICAgICAgICAgICAvLyBjb2Rld29yZHMsIGJ1dCBleGNsdWRpbmcgdGhlIG51bWJlciBvZiBlcnJvciBjb3JyZWN0aW9uIGNvZGV3b3Jkcy5cbiAgICAgICAgICAgIGxldCBudW1iZXJPZkNvZGV3b3JkcyA9IGNvZGV3b3Jkc1swXTtcbiAgICAgICAgICAgIGlmIChudW1iZXJPZkNvZGV3b3JkcyA+IGNvZGV3b3Jkcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBGb3JtYXRFeGNlcHRpb24uZ2V0Rm9ybWF0SW5zdGFuY2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChudW1iZXJPZkNvZGV3b3JkcyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIFJlc2V0IHRvIHRoZSBsZW5ndGggb2YgdGhlIGFycmF5IC0gOCAoQWxsb3cgZm9yIGF0IGxlYXN0IGxldmVsIDMgRXJyb3IgQ29ycmVjdGlvbiAoOCBFcnJvciBDb2Rld29yZHMpXG4gICAgICAgICAgICAgICAgaWYgKG51bUVDQ29kZXdvcmRzIDwgY29kZXdvcmRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBjb2Rld29yZHNbMF0gPSBjb2Rld29yZHMubGVuZ3RoIC0gbnVtRUNDb2Rld29yZHM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBGb3JtYXRFeGNlcHRpb24uZ2V0Rm9ybWF0SW5zdGFuY2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGdldEJpdENvdW50Rm9yQ29kZXdvcmQoY29kZXdvcmQpIHtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBuZXcgSW50MzJBcnJheSg4KTtcbiAgICAgICAgICAgIGxldCBwcmV2aW91c1ZhbHVlID0gMDtcbiAgICAgICAgICAgIGxldCBpID0gcmVzdWx0Lmxlbmd0aCAtIDE7XG4gICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICAgIGlmICgoY29kZXdvcmQgJiAweDEpICE9PSBwcmV2aW91c1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXZpb3VzVmFsdWUgPSBjb2Rld29yZCAmIDB4MTtcbiAgICAgICAgICAgICAgICAgICAgaS0tO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdFtpXSsrO1xuICAgICAgICAgICAgICAgIGNvZGV3b3JkID4+PSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgZ2V0Q29kZXdvcmRCdWNrZXROdW1iZXIoY29kZXdvcmQpIHtcbiAgICAgICAgICAgIGlmIChjb2Rld29yZCBpbnN0YW5jZW9mIEludDMyQXJyYXkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRDb2Rld29yZEJ1Y2tldE51bWJlcl9JbnQzMkFycmF5KGNvZGV3b3JkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldENvZGV3b3JkQnVja2V0TnVtYmVyX251bWJlcihjb2Rld29yZCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGdldENvZGV3b3JkQnVja2V0TnVtYmVyX251bWJlcihjb2Rld29yZCkge1xuICAgICAgICAgICAgcmV0dXJuIFBERjQxN1NjYW5uaW5nRGVjb2Rlci5nZXRDb2Rld29yZEJ1Y2tldE51bWJlcihQREY0MTdTY2FubmluZ0RlY29kZXIuZ2V0Qml0Q291bnRGb3JDb2Rld29yZChjb2Rld29yZCkpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBnZXRDb2Rld29yZEJ1Y2tldE51bWJlcl9JbnQzMkFycmF5KG1vZHVsZUJpdENvdW50KSB7XG4gICAgICAgICAgICByZXR1cm4gKG1vZHVsZUJpdENvdW50WzBdIC0gbW9kdWxlQml0Q291bnRbMl0gKyBtb2R1bGVCaXRDb3VudFs0XSAtIG1vZHVsZUJpdENvdW50WzZdICsgOSkgJSA5O1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyB0b1N0cmluZyhiYXJjb2RlTWF0cml4KSB7XG4gICAgICAgICAgICBsZXQgZm9ybWF0dGVyID0gbmV3IEZvcm1hdHRlcigpO1xuICAgICAgICAgICAgLy8gdHJ5IChsZXQgZm9ybWF0dGVyID0gbmV3IEZvcm1hdHRlcigpKSB7XG4gICAgICAgICAgICBmb3IgKGxldCByb3cgLyppbnQqLyA9IDA7IHJvdyA8IGJhcmNvZGVNYXRyaXgubGVuZ3RoOyByb3crKykge1xuICAgICAgICAgICAgICAgIGZvcm1hdHRlci5mb3JtYXQoJ1JvdyAlMmQ6ICcsIHJvdyk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgY29sdW1uIC8qaW50Ki8gPSAwOyBjb2x1bW4gPCBiYXJjb2RlTWF0cml4W3Jvd10ubGVuZ3RoOyBjb2x1bW4rKykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgYmFyY29kZVZhbHVlID0gYmFyY29kZU1hdHJpeFtyb3ddW2NvbHVtbl07XG4gICAgICAgICAgICAgICAgICAgIGlmIChiYXJjb2RlVmFsdWUuZ2V0VmFsdWUoKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1hdHRlci5mb3JtYXQoJyAgICAgICAgJywgbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3JtYXR0ZXIuZm9ybWF0KCclNGQoJTJkKScsIGJhcmNvZGVWYWx1ZS5nZXRWYWx1ZSgpWzBdLCBiYXJjb2RlVmFsdWUuZ2V0Q29uZmlkZW5jZShiYXJjb2RlVmFsdWUuZ2V0VmFsdWUoKVswXSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvcm1hdHRlci5mb3JtYXQoJyVuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0dGVyLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAvLyB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLypmaW5hbCovIFBERjQxN1NjYW5uaW5nRGVjb2Rlci5DT0RFV09SRF9TS0VXX1NJWkUgPSAyO1xuICAgIC8qZmluYWwqLyBQREY0MTdTY2FubmluZ0RlY29kZXIuTUFYX0VSUk9SUyA9IDM7XG4gICAgLypmaW5hbCovIFBERjQxN1NjYW5uaW5nRGVjb2Rlci5NQVhfRUNfQ09ERVdPUkRTID0gNTEyO1xuICAgIC8qZmluYWwqLyBQREY0MTdTY2FubmluZ0RlY29kZXIuZXJyb3JDb3JyZWN0aW9uID0gbmV3IEVycm9yQ29ycmVjdGlvbigpO1xuXG4gICAgLypcbiAgICAgKiBDb3B5cmlnaHQgMjAwOSBaWGluZyBhdXRob3JzXG4gICAgICpcbiAgICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgICAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgICAgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgICAgKlxuICAgICAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gICAgICpcbiAgICAgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICAgICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgICAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICAgICAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgICAgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAgICAgKi9cbiAgICAvLyBpbXBvcnQgamF2YS51dGlsLkFycmF5TGlzdDtcbiAgICAvLyBpbXBvcnQgamF2YS51dGlsLkxpc3Q7XG4gICAgLy8gaW1wb3J0IGphdmEudXRpbC5NYXA7XG4gICAgLyoqXG4gICAgICogVGhpcyBpbXBsZW1lbnRhdGlvbiBjYW4gZGV0ZWN0IGFuZCBkZWNvZGUgUERGNDE3IGNvZGVzIGluIGFuIGltYWdlLlxuICAgICAqXG4gICAgICogQGF1dGhvciBHdWVudGhlciBHcmF1XG4gICAgICovXG4gICAgLypwdWJsaWMgZmluYWwqLyBjbGFzcyBQREY0MTdSZWFkZXIge1xuICAgICAgICAvLyBwcml2YXRlIHN0YXRpYyAvKmZpbmFsIFJlc3VsdFtdKi8gRU1QVFlfUkVTVUxUX0FSUkFZOiBSZXN1bHRbXSA9IG5ldyBSZXN1bHQoWzBdKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExvY2F0ZXMgYW5kIGRlY29kZXMgYSBQREY0MTcgY29kZSBpbiBhbiBpbWFnZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiBhIFN0cmluZyByZXByZXNlbnRpbmcgdGhlIGNvbnRlbnQgZW5jb2RlZCBieSB0aGUgUERGNDE3IGNvZGVcbiAgICAgICAgICogQHRocm93cyBOb3RGb3VuZEV4Y2VwdGlvbiBpZiBhIFBERjQxNyBjb2RlIGNhbm5vdCBiZSBmb3VuZCxcbiAgICAgICAgICogQHRocm93cyBGb3JtYXRFeGNlcHRpb24gaWYgYSBQREY0MTcgY2Fubm90IGJlIGRlY29kZWRcbiAgICAgICAgICogQHRocm93cyBDaGVja3N1bUV4Y2VwdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgLy8gQE92ZXJyaWRlXG4gICAgICAgIGRlY29kZShpbWFnZSwgaGludHMgPSBudWxsKSB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gUERGNDE3UmVhZGVyLmRlY29kZShpbWFnZSwgaGludHMsIGZhbHNlKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT0gbnVsbCB8fCByZXN1bHQubGVuZ3RoID09PSAwIHx8IHJlc3VsdFswXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgTm90Rm91bmRFeGNlcHRpb24uZ2V0Tm90Rm91bmRJbnN0YW5jZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdFswXTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIEJpbmFyeUJpdG1hcFxuICAgICAgICAgKiBAcGFyYW0gaW1hZ2VcbiAgICAgICAgICogQHRocm93cyBOb3RGb3VuZEV4Y2VwdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgLy8gICBAT3ZlcnJpZGVcbiAgICAgICAgZGVjb2RlTXVsdGlwbGUoaW1hZ2UsIGhpbnRzID0gbnVsbCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUERGNDE3UmVhZGVyLmRlY29kZShpbWFnZSwgaGludHMsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGlnbm9yZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoaWdub3JlZCBpbnN0YW5jZW9mIEZvcm1hdEV4Y2VwdGlvbiB8fCBpZ25vcmVkIGluc3RhbmNlb2YgQ2hlY2tzdW1FeGNlcHRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgTm90Rm91bmRFeGNlcHRpb24uZ2V0Tm90Rm91bmRJbnN0YW5jZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBpZ25vcmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gaW1hZ2VcbiAgICAgICAgICogQHBhcmFtIGhpbnRzXG4gICAgICAgICAqIEBwYXJhbSBtdWx0aXBsZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAdGhyb3dzIE5vdEZvdW5kRXhjZXB0aW9uXG4gICAgICAgICAqIEB0aHJvd3MgRm9ybWF0RXhjZXB0aW9uXHUwMERGXG4gICAgICAgICAqIEB0aHJvd3MgQ2hlY2tzdW1FeGNlcHRpb25cbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBkZWNvZGUoaW1hZ2UsIGhpbnRzLCBtdWx0aXBsZSkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0cyA9IG5ldyBBcnJheSgpO1xuICAgICAgICAgICAgY29uc3QgZGV0ZWN0b3JSZXN1bHQgPSBEZXRlY3RvciQzLmRldGVjdE11bHRpcGxlKGltYWdlLCBoaW50cywgbXVsdGlwbGUpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBwb2ludHMgb2YgZGV0ZWN0b3JSZXN1bHQuZ2V0UG9pbnRzKCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkZWNvZGVyUmVzdWx0ID0gUERGNDE3U2Nhbm5pbmdEZWNvZGVyLmRlY29kZShkZXRlY3RvclJlc3VsdC5nZXRCaXRzKCksIHBvaW50c1s0XSwgcG9pbnRzWzVdLCBwb2ludHNbNl0sIHBvaW50c1s3XSwgUERGNDE3UmVhZGVyLmdldE1pbkNvZGV3b3JkV2lkdGgocG9pbnRzKSwgUERGNDE3UmVhZGVyLmdldE1heENvZGV3b3JkV2lkdGgocG9pbnRzKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IFJlc3VsdChkZWNvZGVyUmVzdWx0LmdldFRleHQoKSwgZGVjb2RlclJlc3VsdC5nZXRSYXdCeXRlcygpLCB1bmRlZmluZWQsIHBvaW50cywgQmFyY29kZUZvcm1hdCQxLlBERl80MTcpO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXRNZXRhZGF0YShSZXN1bHRNZXRhZGF0YVR5cGUkMS5FUlJPUl9DT1JSRUNUSU9OX0xFVkVMLCBkZWNvZGVyUmVzdWx0LmdldEVDTGV2ZWwoKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcGRmNDE3UmVzdWx0TWV0YWRhdGEgPSBkZWNvZGVyUmVzdWx0LmdldE90aGVyKCk7XG4gICAgICAgICAgICAgICAgaWYgKHBkZjQxN1Jlc3VsdE1ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1dE1ldGFkYXRhKFJlc3VsdE1ldGFkYXRhVHlwZSQxLlBERjQxN19FWFRSQV9NRVRBREFUQSwgcGRmNDE3UmVzdWx0TWV0YWRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2gocmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzLm1hcCh4ID0+IHgpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBnZXRNYXhXaWR0aChwMSwgcDIpIHtcbiAgICAgICAgICAgIGlmIChwMSA9PSBudWxsIHx8IHAyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBNYXRoLnRydW5jKE1hdGguYWJzKHAxLmdldFgoKSAtIHAyLmdldFgoKSkpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBnZXRNaW5XaWR0aChwMSwgcDIpIHtcbiAgICAgICAgICAgIGlmIChwMSA9PSBudWxsIHx8IHAyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gSW50ZWdlci5NQVhfVkFMVUU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gTWF0aC50cnVuYyhNYXRoLmFicyhwMS5nZXRYKCkgLSBwMi5nZXRYKCkpKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgZ2V0TWF4Q29kZXdvcmRXaWR0aChwKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLm1heChNYXRoLm1heChQREY0MTdSZWFkZXIuZ2V0TWF4V2lkdGgocFswXSwgcFs0XSksIFBERjQxN1JlYWRlci5nZXRNYXhXaWR0aChwWzZdLCBwWzJdKSAqIFBERjQxN0NvbW1vbi5NT0RVTEVTX0lOX0NPREVXT1JEIC9cbiAgICAgICAgICAgICAgICBQREY0MTdDb21tb24uTU9EVUxFU19JTl9TVE9QX1BBVFRFUk4pLCBNYXRoLm1heChQREY0MTdSZWFkZXIuZ2V0TWF4V2lkdGgocFsxXSwgcFs1XSksIFBERjQxN1JlYWRlci5nZXRNYXhXaWR0aChwWzddLCBwWzNdKSAqIFBERjQxN0NvbW1vbi5NT0RVTEVTX0lOX0NPREVXT1JEIC9cbiAgICAgICAgICAgICAgICBQREY0MTdDb21tb24uTU9EVUxFU19JTl9TVE9QX1BBVFRFUk4pKSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGdldE1pbkNvZGV3b3JkV2lkdGgocCkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5taW4oTWF0aC5taW4oUERGNDE3UmVhZGVyLmdldE1pbldpZHRoKHBbMF0sIHBbNF0pLCBQREY0MTdSZWFkZXIuZ2V0TWluV2lkdGgocFs2XSwgcFsyXSkgKiBQREY0MTdDb21tb24uTU9EVUxFU19JTl9DT0RFV09SRCAvXG4gICAgICAgICAgICAgICAgUERGNDE3Q29tbW9uLk1PRFVMRVNfSU5fU1RPUF9QQVRURVJOKSwgTWF0aC5taW4oUERGNDE3UmVhZGVyLmdldE1pbldpZHRoKHBbMV0sIHBbNV0pLCBQREY0MTdSZWFkZXIuZ2V0TWluV2lkdGgocFs3XSwgcFszXSkgKiBQREY0MTdDb21tb24uTU9EVUxFU19JTl9DT0RFV09SRCAvXG4gICAgICAgICAgICAgICAgUERGNDE3Q29tbW9uLk1PRFVMRVNfSU5fU1RPUF9QQVRURVJOKSkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEBPdmVycmlkZVxuICAgICAgICByZXNldCgpIHtcbiAgICAgICAgICAgIC8vIG5vdGhpbmcgbmVlZHMgdG8gYmUgcmVzZXRcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEN1c3RvbSBFcnJvciBjbGFzcyBvZiB0eXBlIEV4Y2VwdGlvbi5cbiAgICAgKi9cbiAgICBjbGFzcyBSZWFkZXJFeGNlcHRpb24gZXh0ZW5kcyBFeGNlcHRpb24ge1xuICAgIH1cbiAgICBSZWFkZXJFeGNlcHRpb24ua2luZCA9ICdSZWFkZXJFeGNlcHRpb24nO1xuXG4gICAgLypcbiAgICAgKiBDb3B5cmlnaHQgMjAwOSBaWGluZyBhdXRob3JzXG4gICAgICpcbiAgICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgICAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgICAgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgICAgKlxuICAgICAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gICAgICpcbiAgICAgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICAgICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgICAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICAgICAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgICAgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAgICAgKi9cbiAgICAvKm5hbWVzcGFjZSBjb20uZ29vZ2xlLnp4aW5nIHsqL1xuICAgIC8qKlxuICAgICAqIE11bHRpRm9ybWF0UmVhZGVyIGlzIGEgY29udmVuaWVuY2UgY2xhc3MgYW5kIHRoZSBtYWluIGVudHJ5IHBvaW50IGludG8gdGhlIGxpYnJhcnkgZm9yIG1vc3QgdXNlcy5cbiAgICAgKiBCeSBkZWZhdWx0IGl0IGF0dGVtcHRzIHRvIGRlY29kZSBhbGwgYmFyY29kZSBmb3JtYXRzIHRoYXQgdGhlIGxpYnJhcnkgc3VwcG9ydHMuIE9wdGlvbmFsbHksIHlvdVxuICAgICAqIGNhbiBwcm92aWRlIGEgaGludHMgb2JqZWN0IHRvIHJlcXVlc3QgZGlmZmVyZW50IGJlaGF2aW9yLCBmb3IgZXhhbXBsZSBvbmx5IGRlY29kaW5nIFFSIGNvZGVzLlxuICAgICAqXG4gICAgICogQGF1dGhvciBTZWFuIE93ZW5cbiAgICAgKiBAYXV0aG9yIGRzd2l0a2luQGdvb2dsZS5jb20gKERhbmllbCBTd2l0a2luKVxuICAgICAqL1xuICAgIGNsYXNzIE11bHRpRm9ybWF0UmVhZGVyIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzc1xuICAgICAgICAgKiBcbiAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSB2ZXJib3NlIGlmICd0cnVlJyBsb2dzIHdpbGwgYmUgZHVtcGVkIHRvIGNvbnNvbGUsIG90aGVyd2lzZSBoaWRkZW4uXG4gICAgICAgICAqIEBwYXJhbSBoaW50cyBUaGUgaGludHMgdG8gdXNlLCBjbGVhcmluZyB0aGUgcHJldmlvdXMgc3RhdGUuXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdHJ1Y3Rvcih2ZXJib3NlLCBoaW50cykge1xuICAgICAgICAgICAgdGhpcy52ZXJib3NlID0gKHZlcmJvc2UgPT09IHRydWUpO1xuICAgICAgICAgICAgaWYgKGhpbnRzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRIaW50cyhoaW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgdmVyc2lvbiBvZiBkZWNvZGUgaG9ub3JzIHRoZSBpbnRlbnQgb2YgUmVhZGVyLmRlY29kZShCaW5hcnlCaXRtYXApIGluIHRoYXQgaXRcbiAgICAgICAgICogcGFzc2VzIG51bGwgYXMgYSBoaW50IHRvIHRoZSBkZWNvZGVycy4gSG93ZXZlciwgdGhhdCBtYWtlcyBpdCBpbmVmZmljaWVudCB0byBjYWxsIHJlcGVhdGVkbHkuXG4gICAgICAgICAqIFVzZSBzZXRIaW50cygpIGZvbGxvd2VkIGJ5IGRlY29kZVdpdGhTdGF0ZSgpIGZvciBjb250aW51b3VzIHNjYW4gYXBwbGljYXRpb25zLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gaW1hZ2UgVGhlIHBpeGVsIGRhdGEgdG8gZGVjb2RlXG4gICAgICAgICAqIEByZXR1cm4gVGhlIGNvbnRlbnRzIG9mIHRoZSBpbWFnZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAdGhyb3dzIE5vdEZvdW5kRXhjZXB0aW9uIEFueSBlcnJvcnMgd2hpY2ggb2NjdXJyZWRcbiAgICAgICAgICovXG4gICAgICAgIC8qQE92ZXJyaWRlKi9cbiAgICAgICAgLy8gcHVibGljIGRlY29kZShpbWFnZTogQmluYXJ5Qml0bWFwKTogUmVzdWx0IHtcbiAgICAgICAgLy8gICBzZXRIaW50cyhudWxsKVxuICAgICAgICAvLyAgIHJldHVybiBkZWNvZGVJbnRlcm5hbChpbWFnZSlcbiAgICAgICAgLy8gfVxuICAgICAgICAvKipcbiAgICAgICAgICogRGVjb2RlIGFuIGltYWdlIHVzaW5nIHRoZSBoaW50cyBwcm92aWRlZC4gRG9lcyBub3QgaG9ub3IgZXhpc3Rpbmcgc3RhdGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBpbWFnZSBUaGUgcGl4ZWwgZGF0YSB0byBkZWNvZGVcbiAgICAgICAgICogQHBhcmFtIGhpbnRzIFRoZSBoaW50cyB0byB1c2UsIGNsZWFyaW5nIHRoZSBwcmV2aW91cyBzdGF0ZS5cbiAgICAgICAgICogQHJldHVybiBUaGUgY29udGVudHMgb2YgdGhlIGltYWdlXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0aHJvd3MgTm90Rm91bmRFeGNlcHRpb24gQW55IGVycm9ycyB3aGljaCBvY2N1cnJlZFxuICAgICAgICAgKi9cbiAgICAgICAgLypAT3ZlcnJpZGUqL1xuICAgICAgICBkZWNvZGUoaW1hZ2UsIGhpbnRzKSB7XG4gICAgICAgICAgICBpZiAoaGludHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldEhpbnRzKGhpbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlY29kZUludGVybmFsKGltYWdlKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogRGVjb2RlIGFuIGltYWdlIHVzaW5nIHRoZSBzdGF0ZSBzZXQgdXAgYnkgY2FsbGluZyBzZXRIaW50cygpIHByZXZpb3VzbHkuIENvbnRpbnVvdXMgc2NhblxuICAgICAgICAgKiBjbGllbnRzIHdpbGwgZ2V0IGEgPGI+bGFyZ2U8L2I+IHNwZWVkIGluY3JlYXNlIGJ5IHVzaW5nIHRoaXMgaW5zdGVhZCBvZiBkZWNvZGUoKS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGltYWdlIFRoZSBwaXhlbCBkYXRhIHRvIGRlY29kZVxuICAgICAgICAgKiBAcmV0dXJuIFRoZSBjb250ZW50cyBvZiB0aGUgaW1hZ2VcbiAgICAgICAgICpcbiAgICAgICAgICogQHRocm93cyBOb3RGb3VuZEV4Y2VwdGlvbiBBbnkgZXJyb3JzIHdoaWNoIG9jY3VycmVkXG4gICAgICAgICAqL1xuICAgICAgICBkZWNvZGVXaXRoU3RhdGUoaW1hZ2UpIHtcbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0byBzZXQgdXAgdGhlIGRlZmF1bHQgc3RhdGUgc28gd2UgZG9uJ3QgY3Jhc2hcbiAgICAgICAgICAgIGlmICh0aGlzLnJlYWRlcnMgPT09IG51bGwgfHwgdGhpcy5yZWFkZXJzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldEhpbnRzKG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlSW50ZXJuYWwoaW1hZ2UpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIG1ldGhvZCBhZGRzIHN0YXRlIHRvIHRoZSBNdWx0aUZvcm1hdFJlYWRlci4gQnkgc2V0dGluZyB0aGUgaGludHMgb25jZSwgc3Vic2VxdWVudCBjYWxsc1xuICAgICAgICAgKiB0byBkZWNvZGVXaXRoU3RhdGUoaW1hZ2UpIGNhbiByZXVzZSB0aGUgc2FtZSBzZXQgb2YgcmVhZGVycyB3aXRob3V0IHJlYWxsb2NhdGluZyBtZW1vcnkuIFRoaXNcbiAgICAgICAgICogaXMgaW1wb3J0YW50IGZvciBwZXJmb3JtYW5jZSBpbiBjb250aW51b3VzIHNjYW4gY2xpZW50cy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGhpbnRzIFRoZSBzZXQgb2YgaGludHMgdG8gdXNlIGZvciBzdWJzZXF1ZW50IGNhbGxzIHRvIGRlY29kZShpbWFnZSlcbiAgICAgICAgICovXG4gICAgICAgIHNldEhpbnRzKGhpbnRzKSB7XG4gICAgICAgICAgICB0aGlzLmhpbnRzID0gaGludHM7XG4gICAgICAgICAgICBjb25zdCB0cnlIYXJkZXIgPSAhaXNOdWxsT3JVbmRlZmluZWQoaGludHMpXG4gICAgICAgICAgICAgICAgJiYgaGludHMuZ2V0KERlY29kZUhpbnRUeXBlJDEuVFJZX0hBUkRFUikgPT09IHRydWU7XG4gICAgICAgICAgICBjb25zdCBmb3JtYXRzID0gaXNOdWxsT3JVbmRlZmluZWQoaGludHMpID8gbnVsbCA6IGhpbnRzLmdldChEZWNvZGVIaW50VHlwZSQxLlBPU1NJQkxFX0ZPUk1BVFMpO1xuICAgICAgICAgICAgY29uc3QgcmVhZGVycyA9IG5ldyBBcnJheSgpO1xuICAgICAgICAgICAgaWYgKCFpc051bGxPclVuZGVmaW5lZChmb3JtYXRzKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFkZE9uZURSZWFkZXIgPSBmb3JtYXRzLnNvbWUoZiA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgICAgICAgICBmID09PSBCYXJjb2RlRm9ybWF0JDEuVVBDX0EgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGYgPT09IEJhcmNvZGVGb3JtYXQkMS5VUENfRSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgZiA9PT0gQmFyY29kZUZvcm1hdCQxLkVBTl8xMyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgZiA9PT0gQmFyY29kZUZvcm1hdCQxLkVBTl84IHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBmID09PSBCYXJjb2RlRm9ybWF0JDEuQ09EQUJBUiB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgZiA9PT0gQmFyY29kZUZvcm1hdCQxLkNPREVfMzkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGYgPT09IEJhcmNvZGVGb3JtYXQkMS5DT0RFXzkzIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBmID09PSBCYXJjb2RlRm9ybWF0JDEuQ09ERV8xMjggfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGYgPT09IEJhcmNvZGVGb3JtYXQkMS5JVEYgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGYgPT09IEJhcmNvZGVGb3JtYXQkMS5SU1NfMTQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGYgPT09IEJhcmNvZGVGb3JtYXQkMS5SU1NfRVhQQU5ERUQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIC8vIFB1dCAxRCByZWFkZXJzIHVwZnJvbnQgaW4gXCJub3JtYWxcIiBtb2RlXG4gICAgICAgICAgICAgICAgaWYgKGFkZE9uZURSZWFkZXIgJiYgIXRyeUhhcmRlcikge1xuICAgICAgICAgICAgICAgICAgICByZWFkZXJzLnB1c2gobmV3IE11bHRpRm9ybWF0T25lRFJlYWRlcihoaW50cywgdGhpcy52ZXJib3NlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChmb3JtYXRzLmluY2x1ZGVzKEJhcmNvZGVGb3JtYXQkMS5RUl9DT0RFKSkge1xuICAgICAgICAgICAgICAgICAgICByZWFkZXJzLnB1c2gobmV3IFFSQ29kZVJlYWRlcigpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGZvcm1hdHMuaW5jbHVkZXMoQmFyY29kZUZvcm1hdCQxLkRBVEFfTUFUUklYKSkge1xuICAgICAgICAgICAgICAgICAgICByZWFkZXJzLnB1c2gobmV3IERhdGFNYXRyaXhSZWFkZXIoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChmb3JtYXRzLmluY2x1ZGVzKEJhcmNvZGVGb3JtYXQkMS5BWlRFQykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVycy5wdXNoKG5ldyBBenRlY1JlYWRlcigpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGZvcm1hdHMuaW5jbHVkZXMoQmFyY29kZUZvcm1hdCQxLlBERl80MTcpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlcnMucHVzaChuZXcgUERGNDE3UmVhZGVyKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBpZiAoZm9ybWF0cy5pbmNsdWRlcyhCYXJjb2RlRm9ybWF0Lk1BWElDT0RFKSkge1xuICAgICAgICAgICAgICAgIC8vICAgIHJlYWRlcnMucHVzaChuZXcgTWF4aUNvZGVSZWFkZXIoKSlcbiAgICAgICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICAgICAgLy8gQXQgZW5kIGluIFwidHJ5IGhhcmRlclwiIG1vZGVcbiAgICAgICAgICAgICAgICBpZiAoYWRkT25lRFJlYWRlciAmJiB0cnlIYXJkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVycy5wdXNoKG5ldyBNdWx0aUZvcm1hdE9uZURSZWFkZXIoaGludHMsIHRoaXMudmVyYm9zZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZWFkZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGlmICghdHJ5SGFyZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlcnMucHVzaChuZXcgTXVsdGlGb3JtYXRPbmVEUmVhZGVyKGhpbnRzLCB0aGlzLnZlcmJvc2UpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVhZGVycy5wdXNoKG5ldyBRUkNvZGVSZWFkZXIoKSk7XG4gICAgICAgICAgICAgICAgcmVhZGVycy5wdXNoKG5ldyBEYXRhTWF0cml4UmVhZGVyKCkpO1xuICAgICAgICAgICAgICAgIHJlYWRlcnMucHVzaChuZXcgQXp0ZWNSZWFkZXIoKSk7XG4gICAgICAgICAgICAgICAgcmVhZGVycy5wdXNoKG5ldyBQREY0MTdSZWFkZXIoKSk7XG4gICAgICAgICAgICAgICAgLy8gcmVhZGVycy5wdXNoKG5ldyBNYXhpQ29kZVJlYWRlcigpKVxuICAgICAgICAgICAgICAgIGlmICh0cnlIYXJkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVycy5wdXNoKG5ldyBNdWx0aUZvcm1hdE9uZURSZWFkZXIoaGludHMsIHRoaXMudmVyYm9zZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmVhZGVycyA9IHJlYWRlcnM7IC8vIC50b0FycmF5KG5ldyBSZWFkZXJbcmVhZGVycy5zaXplKCldKVxuICAgICAgICB9XG4gICAgICAgIC8qQE92ZXJyaWRlKi9cbiAgICAgICAgcmVzZXQoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5yZWFkZXJzICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCByZWFkZXIgb2YgdGhpcy5yZWFkZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5yZXNldCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHRocm93cyBOb3RGb3VuZEV4Y2VwdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgZGVjb2RlSW50ZXJuYWwoaW1hZ2UpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlYWRlcnMgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVhZGVyRXhjZXB0aW9uKCdObyByZWFkZXJzIHdoZXJlIHNlbGVjdGVkLCBub3RoaW5nIGNhbiBiZSByZWFkLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCByZWFkZXIgb2YgdGhpcy5yZWFkZXJzKSB7XG4gICAgICAgICAgICAgICAgLy8gVHJ5aW5nIHRvIGRlY29kZSB3aXRoICR7cmVhZGVyfSByZWFkZXIuXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlYWRlci5kZWNvZGUoaW1hZ2UsIHRoaXMuaGludHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4IGluc3RhbmNlb2YgUmVhZGVyRXhjZXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBCYWQgRXhjZXB0aW9uLlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbignTm8gTXVsdGlGb3JtYXQgUmVhZGVycyB3ZXJlIGFibGUgdG8gZGV0ZWN0IHRoZSBjb2RlLicpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY2xhc3MgQnJvd3Nlck11bHRpRm9ybWF0UmVhZGVyIGV4dGVuZHMgQnJvd3NlckNvZGVSZWFkZXIge1xuICAgICAgICBjb25zdHJ1Y3RvcihoaW50cyA9IG51bGwsIHRpbWVCZXR3ZWVuU2NhbnNNaWxsaXMgPSA1MDApIHtcbiAgICAgICAgICAgIGNvbnN0IHJlYWRlciA9IG5ldyBNdWx0aUZvcm1hdFJlYWRlcigpO1xuICAgICAgICAgICAgcmVhZGVyLnNldEhpbnRzKGhpbnRzKTtcbiAgICAgICAgICAgIHN1cGVyKHJlYWRlciwgdGltZUJldHdlZW5TY2Fuc01pbGxpcyk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE92ZXJ3cml0ZSBkZWNvZGVCaXRtYXAgdG8gY2FsbCBkZWNvZGVXaXRoU3RhdGUsIHdoaWNoIHdpbGwgcGF5XG4gICAgICAgICAqIGF0dGVudGlvbiB0byB0aGUgaGludHMgc2V0IGluIHRoZSBjb25zdHJ1Y3RvciBmdW5jdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgZGVjb2RlQml0bWFwKGJpbmFyeUJpdG1hcCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVhZGVyLmRlY29kZVdpdGhTdGF0ZShiaW5hcnlCaXRtYXApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgTW92aW5nIHRvIEB6eGluZy9icm93c2VyXG4gICAgICpcbiAgICAgKiBRUiBDb2RlIHJlYWRlciB0byB1c2UgZnJvbSBicm93c2VyLlxuICAgICAqL1xuICAgIGNsYXNzIEJyb3dzZXJQREY0MTdSZWFkZXIgZXh0ZW5kcyBCcm93c2VyQ29kZVJlYWRlciB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIEJyb3dzZXJQREY0MTdSZWFkZXIuXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbdGltZUJldHdlZW5TY2Fuc01pbGxpcz01MDBdIHRoZSB0aW1lIGRlbGF5IGJldHdlZW4gc3Vic2VxdWVudCBkZWNvZGUgdHJpZXNcbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0cnVjdG9yKHRpbWVCZXR3ZWVuU2NhbnNNaWxsaXMgPSA1MDApIHtcbiAgICAgICAgICAgIHN1cGVyKG5ldyBQREY0MTdSZWFkZXIoKSwgdGltZUJldHdlZW5TY2Fuc01pbGxpcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCBNb3ZpbmcgdG8gQHp4aW5nL2Jyb3dzZXJcbiAgICAgKlxuICAgICAqIFFSIENvZGUgcmVhZGVyIHRvIHVzZSBmcm9tIGJyb3dzZXIuXG4gICAgICovXG4gICAgY2xhc3MgQnJvd3NlclFSQ29kZVJlYWRlciBleHRlbmRzIEJyb3dzZXJDb2RlUmVhZGVyIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgQnJvd3NlclFSQ29kZVJlYWRlci5cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFt0aW1lQmV0d2VlblNjYW5zTWlsbGlzPTUwMF0gdGhlIHRpbWUgZGVsYXkgYmV0d2VlbiBzdWJzZXF1ZW50IGRlY29kZSB0cmllc1xuICAgICAgICAgKi9cbiAgICAgICAgY29uc3RydWN0b3IodGltZUJldHdlZW5TY2Fuc01pbGxpcyA9IDUwMCkge1xuICAgICAgICAgICAgc3VwZXIobmV3IFFSQ29kZVJlYWRlcigpLCB0aW1lQmV0d2VlblNjYW5zTWlsbGlzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qXG4gICAgICogQ29weXJpZ2h0IDIwMDkgWlhpbmcgYXV0aG9yc1xuICAgICAqXG4gICAgICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgICAgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICAgICpcbiAgICAgKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICAgICAqXG4gICAgICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICAgICAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgICAgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgICAgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gICAgICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gICAgICovXG4gICAgLypuYW1lc3BhY2UgY29tLmdvb2dsZS56eGluZyB7Ki9cbiAgICAvKipcbiAgICAgKiBUaGVzZSBhcmUgYSBzZXQgb2YgaGludHMgdGhhdCB5b3UgbWF5IHBhc3MgdG8gV3JpdGVycyB0byBzcGVjaWZ5IHRoZWlyIGJlaGF2aW9yLlxuICAgICAqXG4gICAgICogQGF1dGhvciBkc3dpdGtpbkBnb29nbGUuY29tIChEYW5pZWwgU3dpdGtpbilcbiAgICAgKi9cbiAgICB2YXIgRW5jb2RlSGludFR5cGU7XG4gICAgKGZ1bmN0aW9uIChFbmNvZGVIaW50VHlwZSkge1xuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmaWVzIHdoYXQgZGVncmVlIG9mIGVycm9yIGNvcnJlY3Rpb24gdG8gdXNlLCBmb3IgZXhhbXBsZSBpbiBRUiBDb2Rlcy5cbiAgICAgICAgICogVHlwZSBkZXBlbmRzIG9uIHRoZSBlbmNvZGVyLiBGb3IgZXhhbXBsZSBmb3IgUVIgY29kZXMgaXQncyB0eXBlXG4gICAgICAgICAqIHtAbGluayBjb20uZ29vZ2xlLnp4aW5nLnFyY29kZS5kZWNvZGVyLkVycm9yQ29ycmVjdGlvbkxldmVsIEVycm9yQ29ycmVjdGlvbkxldmVsfS5cbiAgICAgICAgICogRm9yIEF6dGVjIGl0IGlzIG9mIHR5cGUge0BsaW5rIEludGVnZXJ9LCByZXByZXNlbnRpbmcgdGhlIG1pbmltYWwgcGVyY2VudGFnZSBvZiBlcnJvciBjb3JyZWN0aW9uIHdvcmRzLlxuICAgICAgICAgKiBGb3IgUERGNDE3IGl0IGlzIG9mIHR5cGUge0BsaW5rIEludGVnZXJ9LCB2YWxpZCB2YWx1ZXMgYmVpbmcgMCB0byA4LlxuICAgICAgICAgKiBJbiBhbGwgY2FzZXMsIGl0IGNhbiBhbHNvIGJlIGEge0BsaW5rIFN0cmluZ30gcmVwcmVzZW50YXRpb24gb2YgdGhlIGRlc2lyZWQgdmFsdWUgYXMgd2VsbC5cbiAgICAgICAgICogTm90ZTogYW4gQXp0ZWMgc3ltYm9sIHNob3VsZCBoYXZlIGEgbWluaW11bSBvZiAyNSUgRUMgd29yZHMuXG4gICAgICAgICAqL1xuICAgICAgICBFbmNvZGVIaW50VHlwZVtFbmNvZGVIaW50VHlwZVtcIkVSUk9SX0NPUlJFQ1RJT05cIl0gPSAwXSA9IFwiRVJST1JfQ09SUkVDVElPTlwiO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmaWVzIHdoYXQgY2hhcmFjdGVyIGVuY29kaW5nIHRvIHVzZSB3aGVyZSBhcHBsaWNhYmxlICh0eXBlIHtAbGluayBTdHJpbmd9KVxuICAgICAgICAgKi9cbiAgICAgICAgRW5jb2RlSGludFR5cGVbRW5jb2RlSGludFR5cGVbXCJDSEFSQUNURVJfU0VUXCJdID0gMV0gPSBcIkNIQVJBQ1RFUl9TRVRcIjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyB0aGUgbWF0cml4IHNoYXBlIGZvciBEYXRhIE1hdHJpeCAodHlwZSB7QGxpbmsgY29tLmdvb2dsZS56eGluZy5kYXRhbWF0cml4LmVuY29kZXIuU3ltYm9sU2hhcGVIaW50fSlcbiAgICAgICAgICovXG4gICAgICAgIEVuY29kZUhpbnRUeXBlW0VuY29kZUhpbnRUeXBlW1wiREFUQV9NQVRSSVhfU0hBUEVcIl0gPSAyXSA9IFwiREFUQV9NQVRSSVhfU0hBUEVcIjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyBhIG1pbmltdW0gYmFyY29kZSBzaXplICh0eXBlIHtAbGluayBEaW1lbnNpb259KS4gT25seSBhcHBsaWNhYmxlIHRvIERhdGEgTWF0cml4IG5vdy5cbiAgICAgICAgICpcbiAgICAgICAgICogQGRlcHJlY2F0ZWQgdXNlIHdpZHRoL2hlaWdodCBwYXJhbXMgaW5cbiAgICAgICAgICoge0BsaW5rIGNvbS5nb29nbGUuenhpbmcuZGF0YW1hdHJpeC5EYXRhTWF0cml4V3JpdGVyI2VuY29kZShTdHJpbmcsIEJhcmNvZGVGb3JtYXQsIGludCwgaW50KX1cbiAgICAgICAgICovXG4gICAgICAgIC8qQERlcHJlY2F0ZWQqL1xuICAgICAgICBFbmNvZGVIaW50VHlwZVtFbmNvZGVIaW50VHlwZVtcIk1JTl9TSVpFXCJdID0gM10gPSBcIk1JTl9TSVpFXCI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZpZXMgYSBtYXhpbXVtIGJhcmNvZGUgc2l6ZSAodHlwZSB7QGxpbmsgRGltZW5zaW9ufSkuIE9ubHkgYXBwbGljYWJsZSB0byBEYXRhIE1hdHJpeCBub3cuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBkZXByZWNhdGVkIHdpdGhvdXQgcmVwbGFjZW1lbnRcbiAgICAgICAgICovXG4gICAgICAgIC8qQERlcHJlY2F0ZWQqL1xuICAgICAgICBFbmNvZGVIaW50VHlwZVtFbmNvZGVIaW50VHlwZVtcIk1BWF9TSVpFXCJdID0gNF0gPSBcIk1BWF9TSVpFXCI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZpZXMgbWFyZ2luLCBpbiBwaXhlbHMsIHRvIHVzZSB3aGVuIGdlbmVyYXRpbmcgdGhlIGJhcmNvZGUuIFRoZSBtZWFuaW5nIGNhbiB2YXJ5XG4gICAgICAgICAqIGJ5IGZvcm1hdDsgZm9yIGV4YW1wbGUgaXQgY29udHJvbHMgbWFyZ2luIGJlZm9yZSBhbmQgYWZ0ZXIgdGhlIGJhcmNvZGUgaG9yaXpvbnRhbGx5IGZvclxuICAgICAgICAgKiBtb3N0IDFEIGZvcm1hdHMuIChUeXBlIHtAbGluayBJbnRlZ2VyfSwgb3Ige0BsaW5rIFN0cmluZ30gcmVwcmVzZW50YXRpb24gb2YgdGhlIGludGVnZXIgdmFsdWUpLlxuICAgICAgICAgKi9cbiAgICAgICAgRW5jb2RlSGludFR5cGVbRW5jb2RlSGludFR5cGVbXCJNQVJHSU5cIl0gPSA1XSA9IFwiTUFSR0lOXCI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZpZXMgd2hldGhlciB0byB1c2UgY29tcGFjdCBtb2RlIGZvciBQREY0MTcgKHR5cGUge0BsaW5rIEJvb2xlYW59LCBvciBcInRydWVcIiBvciBcImZhbHNlXCJcbiAgICAgICAgICoge0BsaW5rIFN0cmluZ30gdmFsdWUpLlxuICAgICAgICAgKi9cbiAgICAgICAgRW5jb2RlSGludFR5cGVbRW5jb2RlSGludFR5cGVbXCJQREY0MTdfQ09NUEFDVFwiXSA9IDZdID0gXCJQREY0MTdfQ09NUEFDVFwiO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmaWVzIHdoYXQgY29tcGFjdGlvbiBtb2RlIHRvIHVzZSBmb3IgUERGNDE3ICh0eXBlXG4gICAgICAgICAqIHtAbGluayBjb20uZ29vZ2xlLnp4aW5nLnBkZjQxNy5lbmNvZGVyLkNvbXBhY3Rpb24gQ29tcGFjdGlvbn0gb3Ige0BsaW5rIFN0cmluZ30gdmFsdWUgb2Ygb25lIG9mIGl0c1xuICAgICAgICAgKiBlbnVtIHZhbHVlcykuXG4gICAgICAgICAqL1xuICAgICAgICBFbmNvZGVIaW50VHlwZVtFbmNvZGVIaW50VHlwZVtcIlBERjQxN19DT01QQUNUSU9OXCJdID0gN10gPSBcIlBERjQxN19DT01QQUNUSU9OXCI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZpZXMgdGhlIG1pbmltdW0gYW5kIG1heGltdW0gbnVtYmVyIG9mIHJvd3MgYW5kIGNvbHVtbnMgZm9yIFBERjQxNyAodHlwZVxuICAgICAgICAgKiB7QGxpbmsgY29tLmdvb2dsZS56eGluZy5wZGY0MTcuZW5jb2Rlci5EaW1lbnNpb25zIERpbWVuc2lvbnN9KS5cbiAgICAgICAgICovXG4gICAgICAgIEVuY29kZUhpbnRUeXBlW0VuY29kZUhpbnRUeXBlW1wiUERGNDE3X0RJTUVOU0lPTlNcIl0gPSA4XSA9IFwiUERGNDE3X0RJTUVOU0lPTlNcIjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyB0aGUgcmVxdWlyZWQgbnVtYmVyIG9mIGxheWVycyBmb3IgYW4gQXp0ZWMgY29kZS5cbiAgICAgICAgICogQSBuZWdhdGl2ZSBudW1iZXIgKC0xLCAtMiwgLTMsIC00KSBzcGVjaWZpZXMgYSBjb21wYWN0IEF6dGVjIGNvZGUuXG4gICAgICAgICAqIDAgaW5kaWNhdGVzIHRvIHVzZSB0aGUgbWluaW11bSBudW1iZXIgb2YgbGF5ZXJzICh0aGUgZGVmYXVsdCkuXG4gICAgICAgICAqIEEgcG9zaXRpdmUgbnVtYmVyICgxLCAyLCAuLiAzMikgc3BlY2lmaWVzIGEgbm9ybWFsIChub24tY29tcGFjdCkgQXp0ZWMgY29kZS5cbiAgICAgICAgICogKFR5cGUge0BsaW5rIEludGVnZXJ9LCBvciB7QGxpbmsgU3RyaW5nfSByZXByZXNlbnRhdGlvbiBvZiB0aGUgaW50ZWdlciB2YWx1ZSkuXG4gICAgICAgICAqL1xuICAgICAgICBFbmNvZGVIaW50VHlwZVtFbmNvZGVIaW50VHlwZVtcIkFaVEVDX0xBWUVSU1wiXSA9IDldID0gXCJBWlRFQ19MQVlFUlNcIjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyB0aGUgZXhhY3QgdmVyc2lvbiBvZiBRUiBjb2RlIHRvIGJlIGVuY29kZWQuXG4gICAgICAgICAqIChUeXBlIHtAbGluayBJbnRlZ2VyfSwgb3Ige0BsaW5rIFN0cmluZ30gcmVwcmVzZW50YXRpb24gb2YgdGhlIGludGVnZXIgdmFsdWUpLlxuICAgICAgICAgKi9cbiAgICAgICAgRW5jb2RlSGludFR5cGVbRW5jb2RlSGludFR5cGVbXCJRUl9WRVJTSU9OXCJdID0gMTBdID0gXCJRUl9WRVJTSU9OXCI7XG4gICAgfSkoRW5jb2RlSGludFR5cGUgfHwgKEVuY29kZUhpbnRUeXBlID0ge30pKTtcbiAgICB2YXIgRW5jb2RlSGludFR5cGUkMSA9IEVuY29kZUhpbnRUeXBlO1xuXG4gICAgLyoqXG4gICAgICogPHA+SW1wbGVtZW50cyBSZWVkLVNvbG9tb24gZW5jb2RpbmcsIGFzIHRoZSBuYW1lIGltcGxpZXMuPC9wPlxuICAgICAqXG4gICAgICogQGF1dGhvciBTZWFuIE93ZW5cbiAgICAgKiBAYXV0aG9yIFdpbGxpYW0gUnVja2xpZGdlXG4gICAgICovXG4gICAgY2xhc3MgUmVlZFNvbG9tb25FbmNvZGVyIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgcmVlZCBzb2xvbW9uIGVycm9yLWNvcnJlY3RpbmcgZW5jb2RpbmcgY29uc3RydWN0b3IgaXMgY3JlYXRlZCBieVxuICAgICAgICAgKiBwYXNzaW5nIGFzIEdhbG9pcyBGaWVsZCB3aXRoIG9mIHNpemUgZXF1YWwgdG8gdGhlIG51bWJlciBvZiBjb2RlXG4gICAgICAgICAqIHdvcmRzIChzeW1ib2xzKSBpbiB0aGUgYWxwaGFiZXQgKHRoZSBudW1iZXIgb2YgdmFsdWVzIGluIGVhY2hcbiAgICAgICAgICogZWxlbWVudCBvZiBhcnJheXMgdGhhdCBhcmUgZW5jb2RlZC9kZWNvZGVkKS5cbiAgICAgICAgICogQHBhcmFtIGZpZWxkIEEgZ2Fsb2lzIGZpZWxkIHdpdGggYSBudW1iZXIgb2YgZWxlbWVudHMgZXF1YWwgdG8gdGhlIHNpemVcbiAgICAgICAgICogb2YgdGhlIGFscGhhYmV0IG9mIHN5bWJvbHMgdG8gZW5jb2RlLlxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3RydWN0b3IoZmllbGQpIHtcbiAgICAgICAgICAgIHRoaXMuZmllbGQgPSBmaWVsZDtcbiAgICAgICAgICAgIHRoaXMuY2FjaGVkR2VuZXJhdG9ycyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5jYWNoZWRHZW5lcmF0b3JzLnB1c2gobmV3IEdlbmVyaWNHRlBvbHkoZmllbGQsIEludDMyQXJyYXkuZnJvbShbMV0pKSk7XG4gICAgICAgIH1cbiAgICAgICAgYnVpbGRHZW5lcmF0b3IoZGVncmVlIC8qaW50Ki8pIHtcbiAgICAgICAgICAgIGNvbnN0IGNhY2hlZEdlbmVyYXRvcnMgPSB0aGlzLmNhY2hlZEdlbmVyYXRvcnM7XG4gICAgICAgICAgICBpZiAoZGVncmVlID49IGNhY2hlZEdlbmVyYXRvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbGV0IGxhc3RHZW5lcmF0b3IgPSBjYWNoZWRHZW5lcmF0b3JzW2NhY2hlZEdlbmVyYXRvcnMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgY29uc3QgZmllbGQgPSB0aGlzLmZpZWxkO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGQgPSBjYWNoZWRHZW5lcmF0b3JzLmxlbmd0aDsgZCA8PSBkZWdyZWU7IGQrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0R2VuZXJhdG9yID0gbGFzdEdlbmVyYXRvci5tdWx0aXBseShuZXcgR2VuZXJpY0dGUG9seShmaWVsZCwgSW50MzJBcnJheS5mcm9tKFsxLCBmaWVsZC5leHAoZCAtIDEgKyBmaWVsZC5nZXRHZW5lcmF0b3JCYXNlKCkpXSkpKTtcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVkR2VuZXJhdG9ycy5wdXNoKG5leHRHZW5lcmF0b3IpO1xuICAgICAgICAgICAgICAgICAgICBsYXN0R2VuZXJhdG9yID0gbmV4dEdlbmVyYXRvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkR2VuZXJhdG9yc1tkZWdyZWVdO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiA8cD5FbmNvZGUgYSBzZXF1ZW5jZSBvZiBjb2RlIHdvcmRzIChzeW1ib2xzKSB1c2luZyBSZWVkLVNvbG9tb24gdG8gYWxsb3cgZGVjb2RlcnNcbiAgICAgICAgICogdG8gZGV0ZWN0IGFuZCBjb3JyZWN0IGVycm9ycyB0aGF0IG1heSBoYXZlIGJlZW4gaW50cm9kdWNlZCB3aGVuIHRoZSByZXN1bHRpbmdcbiAgICAgICAgICogZGF0YSBpcyBzdG9yZWQgb3IgdHJhbnNtaXR0ZWQuPC9wPlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gdG9FbmNvZGUgYXJyYXkgdXNlZCBmb3IgYm90aCBhbmQgb3V0cHV0LiBDYWxsZXIgaW5pdGlhbGl6ZXMgdGhlIGFycmF5IHdpdGhcbiAgICAgICAgICogdGhlIGNvZGUgd29yZHMgKHN5bWJvbHMpIHRvIGJlIGVuY29kZWQgZm9sbG93ZWQgYnkgZW1wdHkgZWxlbWVudHMgYWxsb2NhdGVkIHRvIG1ha2VcbiAgICAgICAgICogc3BhY2UgZm9yIGVycm9yLWNvcnJlY3Rpb24gY29kZSB3b3JkcyBpbiB0aGUgZW5jb2RlZCBvdXRwdXQuIFRoZSBhcnJheSBjb250YWluc1xuICAgICAgICAgKiB0aGUgZW5jZG9kZWQgb3V0cHV0IHdoZW4gZW5jb2RlIHJldHVybnMuIENvZGUgd29yZHMgYXJlIGVuY29kZWQgYXMgbnVtYmVycyBmcm9tXG4gICAgICAgICAqIDAgdG8gbi0xLCB3aGVyZSBuIGlzIHRoZSBudW1iZXIgb2YgcG9zc2libGUgY29kZSB3b3JkcyAoc3ltYm9scyksIGFzIGRldGVybWluZWRcbiAgICAgICAgICogYnkgdGhlIHNpemUgb2YgdGhlIEdhbG9pcyBGaWVsZCBwYXNzZWQgaW4gdGhlIGNvbnN0cnVjdG9yIG9mIHRoaXMgb2JqZWN0LlxuICAgICAgICAgKiBAcGFyYW0gZWNCeXRlcyB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIHJlc2VydmVkIGluIHRoZSBhcnJheSAoZmlyc3QgcGFyYW1ldGVyKVxuICAgICAgICAgKiB0byBzdG9yZSBlcnJvci1jb3JyZWN0aW9uIGNvZGUgd29yZHMuIFRodXMsIHRoZSBudW1iZXIgb2YgY29kZSB3b3JkcyAoc3ltYm9scylcbiAgICAgICAgICogdG8gZW5jb2RlIGluIHRoZSBmaXJzdCBwYXJhbWV0ZXIgaXMgdGh1cyB0b0VuY29kZS5sZW5ndGggLSBlY0J5dGVzLlxuICAgICAgICAgKiBOb3RlLCB0aGUgdXNlIG9mIFwiYnl0ZXNcIiBpbiB0aGUgbmFtZSBvZiB0aGlzIHBhcmFtZXRlciBpcyBtaXNsZWFkaW5nLCBhcyB0aGVyZSBtYXlcbiAgICAgICAgICogYmUgbW9yZSBvciBmZXdlciB0aGFuIDI1NiBzeW1ib2xzIGJlaW5nIGVuY29kZWQsIGFzIGRldGVybWluZWQgYnkgdGhlIG51bWJlciBvZlxuICAgICAgICAgKiBlbGVtZW50cyBpbiB0aGUgR2Fsb2lzIEZpZWxkIHBhc3NlZCBhcyBhIGNvbnN0cnVjdG9yIHRvIHRoaXMgb2JqZWN0LlxuICAgICAgICAgKiBAdGhyb3dzIElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbiB0aHJvd24gaW4gcmVzcG9uc2UgdG8gdmFsaWRhdGlvbiBlcnJyb3MuXG4gICAgICAgICAqL1xuICAgICAgICBlbmNvZGUodG9FbmNvZGUsIGVjQnl0ZXMgLyppbnQqLykge1xuICAgICAgICAgICAgaWYgKGVjQnl0ZXMgPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCdObyBlcnJvciBjb3JyZWN0aW9uIGJ5dGVzJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBkYXRhQnl0ZXMgPSB0b0VuY29kZS5sZW5ndGggLSBlY0J5dGVzO1xuICAgICAgICAgICAgaWYgKGRhdGFCeXRlcyA8PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignTm8gZGF0YSBieXRlcyBwcm92aWRlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZ2VuZXJhdG9yID0gdGhpcy5idWlsZEdlbmVyYXRvcihlY0J5dGVzKTtcbiAgICAgICAgICAgIGNvbnN0IGluZm9Db2VmZmljaWVudHMgPSBuZXcgSW50MzJBcnJheShkYXRhQnl0ZXMpO1xuICAgICAgICAgICAgU3lzdGVtLmFycmF5Y29weSh0b0VuY29kZSwgMCwgaW5mb0NvZWZmaWNpZW50cywgMCwgZGF0YUJ5dGVzKTtcbiAgICAgICAgICAgIGxldCBpbmZvID0gbmV3IEdlbmVyaWNHRlBvbHkodGhpcy5maWVsZCwgaW5mb0NvZWZmaWNpZW50cyk7XG4gICAgICAgICAgICBpbmZvID0gaW5mby5tdWx0aXBseUJ5TW9ub21pYWwoZWNCeXRlcywgMSk7XG4gICAgICAgICAgICBjb25zdCByZW1haW5kZXIgPSBpbmZvLmRpdmlkZShnZW5lcmF0b3IpWzFdO1xuICAgICAgICAgICAgY29uc3QgY29lZmZpY2llbnRzID0gcmVtYWluZGVyLmdldENvZWZmaWNpZW50cygpO1xuICAgICAgICAgICAgY29uc3QgbnVtWmVyb0NvZWZmaWNpZW50cyA9IGVjQnl0ZXMgLSBjb2VmZmljaWVudHMubGVuZ3RoO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1aZXJvQ29lZmZpY2llbnRzOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0b0VuY29kZVtkYXRhQnl0ZXMgKyBpXSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBTeXN0ZW0uYXJyYXljb3B5KGNvZWZmaWNpZW50cywgMCwgdG9FbmNvZGUsIGRhdGFCeXRlcyArIG51bVplcm9Db2VmZmljaWVudHMsIGNvZWZmaWNpZW50cy5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGF1dGhvciBTYXRvcnUgVGFrYWJheWFzaGlcbiAgICAgKiBAYXV0aG9yIERhbmllbCBTd2l0a2luXG4gICAgICogQGF1dGhvciBTZWFuIE93ZW5cbiAgICAgKi9cbiAgICBjbGFzcyBNYXNrVXRpbCB7XG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgICAgLy8gZG8gbm90aGluZ1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBcHBseSBtYXNrIHBlbmFsdHkgcnVsZSAxIGFuZCByZXR1cm4gdGhlIHBlbmFsdHkuIEZpbmQgcmVwZXRpdGl2ZSBjZWxscyB3aXRoIHRoZSBzYW1lIGNvbG9yIGFuZFxuICAgICAgICAgKiBnaXZlIHBlbmFsdHkgdG8gdGhlbS4gRXhhbXBsZTogMDAwMDAgb3IgMTExMTEuXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgYXBwbHlNYXNrUGVuYWx0eVJ1bGUxKG1hdHJpeCkge1xuICAgICAgICAgICAgcmV0dXJuIE1hc2tVdGlsLmFwcGx5TWFza1BlbmFsdHlSdWxlMUludGVybmFsKG1hdHJpeCwgdHJ1ZSkgKyBNYXNrVXRpbC5hcHBseU1hc2tQZW5hbHR5UnVsZTFJbnRlcm5hbChtYXRyaXgsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQXBwbHkgbWFzayBwZW5hbHR5IHJ1bGUgMiBhbmQgcmV0dXJuIHRoZSBwZW5hbHR5LiBGaW5kIDJ4MiBibG9ja3Mgd2l0aCB0aGUgc2FtZSBjb2xvciBhbmQgZ2l2ZVxuICAgICAgICAgKiBwZW5hbHR5IHRvIHRoZW0uIFRoaXMgaXMgYWN0dWFsbHkgZXF1aXZhbGVudCB0byB0aGUgc3BlYydzIHJ1bGUsIHdoaWNoIGlzIHRvIGZpbmQgTXhOIGJsb2NrcyBhbmQgZ2l2ZSBhXG4gICAgICAgICAqIHBlbmFsdHkgcHJvcG9ydGlvbmFsIHRvIChNLTEpeChOLTEpLCBiZWNhdXNlIHRoaXMgaXMgdGhlIG51bWJlciBvZiAyeDIgYmxvY2tzIGluc2lkZSBzdWNoIGEgYmxvY2suXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgYXBwbHlNYXNrUGVuYWx0eVJ1bGUyKG1hdHJpeCkge1xuICAgICAgICAgICAgbGV0IHBlbmFsdHkgPSAwO1xuICAgICAgICAgICAgY29uc3QgYXJyYXkgPSBtYXRyaXguZ2V0QXJyYXkoKTtcbiAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gbWF0cml4LmdldFdpZHRoKCk7XG4gICAgICAgICAgICBjb25zdCBoZWlnaHQgPSBtYXRyaXguZ2V0SGVpZ2h0KCk7XG4gICAgICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IGhlaWdodCAtIDE7IHkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFycmF5WSA9IGFycmF5W3ldO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgd2lkdGggLSAxOyB4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBhcnJheVlbeF07XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gYXJyYXlZW3ggKyAxXSAmJiB2YWx1ZSA9PT0gYXJyYXlbeSArIDFdW3hdICYmIHZhbHVlID09PSBhcnJheVt5ICsgMV1beCArIDFdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwZW5hbHR5Kys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gTWFza1V0aWwuTjIgKiBwZW5hbHR5O1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBcHBseSBtYXNrIHBlbmFsdHkgcnVsZSAzIGFuZCByZXR1cm4gdGhlIHBlbmFsdHkuIEZpbmQgY29uc2VjdXRpdmUgcnVucyBvZiAxOjE6MzoxOjE6NFxuICAgICAgICAgKiBzdGFydGluZyB3aXRoIGJsYWNrLCBvciA0OjE6MTozOjE6MSBzdGFydGluZyB3aXRoIHdoaXRlLCBhbmQgZ2l2ZSBwZW5hbHR5IHRvIHRoZW0uICBJZiB3ZVxuICAgICAgICAgKiBmaW5kIHBhdHRlcm5zIGxpa2UgMDAwMDEwMTExMDEwMDAwLCB3ZSBnaXZlIHBlbmFsdHkgb25jZS5cbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBhcHBseU1hc2tQZW5hbHR5UnVsZTMobWF0cml4KSB7XG4gICAgICAgICAgICBsZXQgbnVtUGVuYWx0aWVzID0gMDtcbiAgICAgICAgICAgIGNvbnN0IGFycmF5ID0gbWF0cml4LmdldEFycmF5KCk7XG4gICAgICAgICAgICBjb25zdCB3aWR0aCA9IG1hdHJpeC5nZXRXaWR0aCgpO1xuICAgICAgICAgICAgY29uc3QgaGVpZ2h0ID0gbWF0cml4LmdldEhlaWdodCgpO1xuICAgICAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCBoZWlnaHQ7IHkrKykge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgd2lkdGg7IHgrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhcnJheVkgPSBhcnJheVt5XTsgLy8gV2UgY2FuIGF0IGxlYXN0IG9wdGltaXplIHRoaXMgYWNjZXNzXG4gICAgICAgICAgICAgICAgICAgIGlmICh4ICsgNiA8IHdpZHRoICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBhcnJheVlbeF0gPT09IDEgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5WVt4ICsgMV0gPT09IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5WVt4ICsgMl0gPT09IDEgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5WVt4ICsgM10gPT09IDEgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5WVt4ICsgNF0gPT09IDEgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5WVt4ICsgNV0gPT09IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5WVt4ICsgNl0gPT09IDEgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIChNYXNrVXRpbC5pc1doaXRlSG9yaXpvbnRhbChhcnJheVksIHggLSA0LCB4KSB8fCBNYXNrVXRpbC5pc1doaXRlSG9yaXpvbnRhbChhcnJheVksIHggKyA3LCB4ICsgMTEpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbnVtUGVuYWx0aWVzKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHkgKyA2IDwgaGVpZ2h0ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBhcnJheVt5XVt4XSA9PT0gMSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgYXJyYXlbeSArIDFdW3hdID09PSAwICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBhcnJheVt5ICsgMl1beF0gPT09IDEgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5W3kgKyAzXVt4XSA9PT0gMSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgYXJyYXlbeSArIDRdW3hdID09PSAxICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBhcnJheVt5ICsgNV1beF0gPT09IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5W3kgKyA2XVt4XSA9PT0gMSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKE1hc2tVdGlsLmlzV2hpdGVWZXJ0aWNhbChhcnJheSwgeCwgeSAtIDQsIHkpIHx8IE1hc2tVdGlsLmlzV2hpdGVWZXJ0aWNhbChhcnJheSwgeCwgeSArIDcsIHkgKyAxMSkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBudW1QZW5hbHRpZXMrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudW1QZW5hbHRpZXMgKiBNYXNrVXRpbC5OMztcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgaXNXaGl0ZUhvcml6b250YWwocm93QXJyYXksIGZyb20gLyppbnQqLywgdG8gLyppbnQqLykge1xuICAgICAgICAgICAgZnJvbSA9IE1hdGgubWF4KGZyb20sIDApO1xuICAgICAgICAgICAgdG8gPSBNYXRoLm1pbih0bywgcm93QXJyYXkubGVuZ3RoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBmcm9tOyBpIDwgdG87IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChyb3dBcnJheVtpXSA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGlzV2hpdGVWZXJ0aWNhbChhcnJheSwgY29sIC8qaW50Ki8sIGZyb20gLyppbnQqLywgdG8gLyppbnQqLykge1xuICAgICAgICAgICAgZnJvbSA9IE1hdGgubWF4KGZyb20sIDApO1xuICAgICAgICAgICAgdG8gPSBNYXRoLm1pbih0bywgYXJyYXkubGVuZ3RoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBmcm9tOyBpIDwgdG87IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChhcnJheVtpXVtjb2xdID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQXBwbHkgbWFzayBwZW5hbHR5IHJ1bGUgNCBhbmQgcmV0dXJuIHRoZSBwZW5hbHR5LiBDYWxjdWxhdGUgdGhlIHJhdGlvIG9mIGRhcmsgY2VsbHMgYW5kIGdpdmVcbiAgICAgICAgICogcGVuYWx0eSBpZiB0aGUgcmF0aW8gaXMgZmFyIGZyb20gNTAlLiBJdCBnaXZlcyAxMCBwZW5hbHR5IGZvciA1JSBkaXN0YW5jZS5cbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBhcHBseU1hc2tQZW5hbHR5UnVsZTQobWF0cml4KSB7XG4gICAgICAgICAgICBsZXQgbnVtRGFya0NlbGxzID0gMDtcbiAgICAgICAgICAgIGNvbnN0IGFycmF5ID0gbWF0cml4LmdldEFycmF5KCk7XG4gICAgICAgICAgICBjb25zdCB3aWR0aCA9IG1hdHJpeC5nZXRXaWR0aCgpO1xuICAgICAgICAgICAgY29uc3QgaGVpZ2h0ID0gbWF0cml4LmdldEhlaWdodCgpO1xuICAgICAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCBoZWlnaHQ7IHkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFycmF5WSA9IGFycmF5W3ldO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgd2lkdGg7IHgrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXJyYXlZW3hdID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBudW1EYXJrQ2VsbHMrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG51bVRvdGFsQ2VsbHMgPSBtYXRyaXguZ2V0SGVpZ2h0KCkgKiBtYXRyaXguZ2V0V2lkdGgoKTtcbiAgICAgICAgICAgIGNvbnN0IGZpdmVQZXJjZW50VmFyaWFuY2VzID0gTWF0aC5mbG9vcihNYXRoLmFicyhudW1EYXJrQ2VsbHMgKiAyIC0gbnVtVG90YWxDZWxscykgKiAxMCAvIG51bVRvdGFsQ2VsbHMpO1xuICAgICAgICAgICAgcmV0dXJuIGZpdmVQZXJjZW50VmFyaWFuY2VzICogTWFza1V0aWwuTjQ7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybiB0aGUgbWFzayBiaXQgZm9yIFwiZ2V0TWFza1BhdHRlcm5cIiBhdCBcInhcIiBhbmQgXCJ5XCIuIFNlZSA4Ljggb2YgSklTWDA1MTA6MjAwNCBmb3IgbWFza1xuICAgICAgICAgKiBwYXR0ZXJuIGNvbmRpdGlvbnMuXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgZ2V0RGF0YU1hc2tCaXQobWFza1BhdHRlcm4gLyppbnQqLywgeCAvKmludCovLCB5IC8qaW50Ki8pIHtcbiAgICAgICAgICAgIGxldCBpbnRlcm1lZGlhdGU7IC8qaW50Ki9cbiAgICAgICAgICAgIGxldCB0ZW1wOyAvKmludCovXG4gICAgICAgICAgICBzd2l0Y2ggKG1hc2tQYXR0ZXJuKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICBpbnRlcm1lZGlhdGUgPSAoeSArIHgpICYgMHgxO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIGludGVybWVkaWF0ZSA9IHkgJiAweDE7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJtZWRpYXRlID0geCAlIDM7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJtZWRpYXRlID0gKHkgKyB4KSAlIDM7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJtZWRpYXRlID0gKE1hdGguZmxvb3IoeSAvIDIpICsgTWF0aC5mbG9vcih4IC8gMykpICYgMHgxO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgIHRlbXAgPSB5ICogeDtcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJtZWRpYXRlID0gKHRlbXAgJiAweDEpICsgKHRlbXAgJSAzKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICB0ZW1wID0geSAqIHg7XG4gICAgICAgICAgICAgICAgICAgIGludGVybWVkaWF0ZSA9ICgodGVtcCAmIDB4MSkgKyAodGVtcCAlIDMpKSAmIDB4MTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgICAgICB0ZW1wID0geSAqIHg7XG4gICAgICAgICAgICAgICAgICAgIGludGVybWVkaWF0ZSA9ICgodGVtcCAlIDMpICsgKCh5ICsgeCkgJiAweDEpKSAmIDB4MTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignSW52YWxpZCBtYXNrIHBhdHRlcm46ICcgKyBtYXNrUGF0dGVybik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaW50ZXJtZWRpYXRlID09PSAwO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBIZWxwZXIgZnVuY3Rpb24gZm9yIGFwcGx5TWFza1BlbmFsdHlSdWxlMS4gV2UgbmVlZCB0aGlzIGZvciBkb2luZyB0aGlzIGNhbGN1bGF0aW9uIGluIGJvdGhcbiAgICAgICAgICogdmVydGljYWwgYW5kIGhvcml6b250YWwgb3JkZXJzIHJlc3BlY3RpdmVseS5cbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBhcHBseU1hc2tQZW5hbHR5UnVsZTFJbnRlcm5hbChtYXRyaXgsIGlzSG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgbGV0IHBlbmFsdHkgPSAwO1xuICAgICAgICAgICAgY29uc3QgaUxpbWl0ID0gaXNIb3Jpem9udGFsID8gbWF0cml4LmdldEhlaWdodCgpIDogbWF0cml4LmdldFdpZHRoKCk7XG4gICAgICAgICAgICBjb25zdCBqTGltaXQgPSBpc0hvcml6b250YWwgPyBtYXRyaXguZ2V0V2lkdGgoKSA6IG1hdHJpeC5nZXRIZWlnaHQoKTtcbiAgICAgICAgICAgIGNvbnN0IGFycmF5ID0gbWF0cml4LmdldEFycmF5KCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlMaW1pdDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IG51bVNhbWVCaXRDZWxscyA9IDA7XG4gICAgICAgICAgICAgICAgbGV0IHByZXZCaXQgPSAtMTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGpMaW1pdDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJpdCA9IGlzSG9yaXpvbnRhbCA/IGFycmF5W2ldW2pdIDogYXJyYXlbal1baV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChiaXQgPT09IHByZXZCaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bVNhbWVCaXRDZWxscysrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG51bVNhbWVCaXRDZWxscyA+PSA1KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVuYWx0eSArPSBNYXNrVXRpbC5OMSArIChudW1TYW1lQml0Q2VsbHMgLSA1KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG51bVNhbWVCaXRDZWxscyA9IDE7IC8vIEluY2x1ZGUgdGhlIGNlbGwgaXRzZWxmLlxuICAgICAgICAgICAgICAgICAgICAgICAgcHJldkJpdCA9IGJpdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobnVtU2FtZUJpdENlbGxzID49IDUpIHtcbiAgICAgICAgICAgICAgICAgICAgcGVuYWx0eSArPSBNYXNrVXRpbC5OMSArIChudW1TYW1lQml0Q2VsbHMgLSA1KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcGVuYWx0eTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBQZW5hbHR5IHdlaWdodHMgZnJvbSBzZWN0aW9uIDYuOC4yLjFcbiAgICBNYXNrVXRpbC5OMSA9IDM7XG4gICAgTWFza1V0aWwuTjIgPSAzO1xuICAgIE1hc2tVdGlsLk4zID0gNDA7XG4gICAgTWFza1V0aWwuTjQgPSAxMDtcblxuICAgIC8qKlxuICAgICAqIEpBVkFQT1JUOiBUaGUgb3JpZ2luYWwgY29kZSB3YXMgYSAyRCBhcnJheSBvZiBpbnRzLCBidXQgc2luY2UgaXQgb25seSBldmVyIGdldHMgYXNzaWduZWRcbiAgICAgKiAtMSwgMCwgYW5kIDEsIEknbSBnb2luZyB0byB1c2UgbGVzcyBtZW1vcnkgYW5kIGdvIHdpdGggYnl0ZXMuXG4gICAgICpcbiAgICAgKiBAYXV0aG9yIGRzd2l0a2luQGdvb2dsZS5jb20gKERhbmllbCBTd2l0a2luKVxuICAgICAqL1xuICAgIGNsYXNzIEJ5dGVNYXRyaXgge1xuICAgICAgICBjb25zdHJ1Y3Rvcih3aWR0aCAvKmludCovLCBoZWlnaHQgLyppbnQqLykge1xuICAgICAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgICAgICBjb25zdCBieXRlcyA9IG5ldyBBcnJheShoZWlnaHQpOyAvLyBbaGVpZ2h0XVt3aWR0aF1cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpICE9PSBoZWlnaHQ7IGkrKykge1xuICAgICAgICAgICAgICAgIGJ5dGVzW2ldID0gbmV3IFVpbnQ4QXJyYXkod2lkdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5ieXRlcyA9IGJ5dGVzO1xuICAgICAgICB9XG4gICAgICAgIGdldEhlaWdodCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICBnZXRXaWR0aCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndpZHRoO1xuICAgICAgICB9XG4gICAgICAgIGdldCh4IC8qaW50Ki8sIHkgLyppbnQqLykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYnl0ZXNbeV1beF07XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gYW4gaW50ZXJuYWwgcmVwcmVzZW50YXRpb24gYXMgYnl0ZXMsIGluIHJvdy1tYWpvciBvcmRlci4gYXJyYXlbeV1beF0gcmVwcmVzZW50cyBwb2ludCAoeCx5KVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0QXJyYXkoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ieXRlcztcbiAgICAgICAgfVxuICAgICAgICAvLyBUWVBFU0NSSVBUUE9SVDogcHJlZmZlciB0byBsZXQgdHdvIG1ldGhvZHMgaW5zdGVhZCBvZiBvdmVycmlkZSB0byBhdm9pZCB0eXBlIGNvbXBhcmlzb24gaW5zaWRlXG4gICAgICAgIHNldE51bWJlcih4IC8qaW50Ki8sIHkgLyppbnQqLywgdmFsdWUgLypieXRlfGludCovKSB7XG4gICAgICAgICAgICB0aGlzLmJ5dGVzW3ldW3hdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcHVibGljIHNldCh4OiBudW1iZXIgLyppbnQqLywgeTogbnVtYmVyIC8qaW50Ki8sIHZhbHVlOiBudW1iZXIgLyppbnQqLyk6IHZvaWQge1xuICAgICAgICAvLyAgIGJ5dGVzW3ldW3hdID0gKGJ5dGUpIHZhbHVlXG4gICAgICAgIC8vIH1cbiAgICAgICAgc2V0Qm9vbGVhbih4IC8qaW50Ki8sIHkgLyppbnQqLywgdmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuYnl0ZXNbeV1beF0gPSAvKihieXRlKSAqLyAodmFsdWUgPyAxIDogMCk7XG4gICAgICAgIH1cbiAgICAgICAgY2xlYXIodmFsdWUgLypieXRlKi8pIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgYUJ5dGUgb2YgdGhpcy5ieXRlcykge1xuICAgICAgICAgICAgICAgIEFycmF5cy5maWxsKGFCeXRlLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZXF1YWxzKG8pIHtcbiAgICAgICAgICAgIGlmICghKG8gaW5zdGFuY2VvZiBCeXRlTWF0cml4KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG90aGVyID0gbztcbiAgICAgICAgICAgIGlmICh0aGlzLndpZHRoICE9PSBvdGhlci53aWR0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmhlaWdodCAhPT0gb3RoZXIuaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgeSA9IDAsIGhlaWdodCA9IHRoaXMuaGVpZ2h0OyB5IDwgaGVpZ2h0OyArK3kpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBieXRlc1kgPSB0aGlzLmJ5dGVzW3ldO1xuICAgICAgICAgICAgICAgIGNvbnN0IG90aGVyQnl0ZXNZID0gb3RoZXIuYnl0ZXNbeV07XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgeCA9IDAsIHdpZHRoID0gdGhpcy53aWR0aDsgeCA8IHdpZHRoOyArK3gpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJ5dGVzWVt4XSAhPT0gb3RoZXJCeXRlc1lbeF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8qQE92ZXJyaWRlKi9cbiAgICAgICAgdG9TdHJpbmcoKSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgU3RyaW5nQnVpbGRlcigpOyAvLyAoMiAqIHdpZHRoICogaGVpZ2h0ICsgMilcbiAgICAgICAgICAgIGZvciAobGV0IHkgPSAwLCBoZWlnaHQgPSB0aGlzLmhlaWdodDsgeSA8IGhlaWdodDsgKyt5KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYnl0ZXNZID0gdGhpcy5ieXRlc1t5XTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCB4ID0gMCwgd2lkdGggPSB0aGlzLndpZHRoOyB4IDwgd2lkdGg7ICsreCkge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGJ5dGVzWVt4XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoJyAwJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZCgnIDEnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZCgnICAnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKCdcXG4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBhdXRob3Igc2F0b3J1eEBnb29nbGUuY29tIChTYXRvcnUgVGFrYWJheWFzaGkpIC0gY3JlYXRvclxuICAgICAqIEBhdXRob3IgZHN3aXRraW5AZ29vZ2xlLmNvbSAoRGFuaWVsIFN3aXRraW4pIC0gcG9ydGVkIGZyb20gQysrXG4gICAgICovXG4gICAgY2xhc3MgUVJDb2RlIHtcbiAgICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgICAgICB0aGlzLm1hc2tQYXR0ZXJuID0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0TW9kZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1vZGU7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0RUNMZXZlbCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVjTGV2ZWw7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0VmVyc2lvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZlcnNpb247XG4gICAgICAgIH1cbiAgICAgICAgZ2V0TWFza1BhdHRlcm4oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYXNrUGF0dGVybjtcbiAgICAgICAgfVxuICAgICAgICBnZXRNYXRyaXgoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYXRyaXg7XG4gICAgICAgIH1cbiAgICAgICAgLypAT3ZlcnJpZGUqL1xuICAgICAgICB0b1N0cmluZygpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBTdHJpbmdCdWlsZGVyKCk7IC8vICgyMDApXG4gICAgICAgICAgICByZXN1bHQuYXBwZW5kKCc8PFxcbicpO1xuICAgICAgICAgICAgcmVzdWx0LmFwcGVuZCgnIG1vZGU6ICcpO1xuICAgICAgICAgICAgcmVzdWx0LmFwcGVuZCh0aGlzLm1vZGUgPyB0aGlzLm1vZGUudG9TdHJpbmcoKSA6ICdudWxsJyk7XG4gICAgICAgICAgICByZXN1bHQuYXBwZW5kKCdcXG4gZWNMZXZlbDogJyk7XG4gICAgICAgICAgICByZXN1bHQuYXBwZW5kKHRoaXMuZWNMZXZlbCA/IHRoaXMuZWNMZXZlbC50b1N0cmluZygpIDogJ251bGwnKTtcbiAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoJ1xcbiB2ZXJzaW9uOiAnKTtcbiAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQodGhpcy52ZXJzaW9uID8gdGhpcy52ZXJzaW9uLnRvU3RyaW5nKCkgOiAnbnVsbCcpO1xuICAgICAgICAgICAgcmVzdWx0LmFwcGVuZCgnXFxuIG1hc2tQYXR0ZXJuOiAnKTtcbiAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQodGhpcy5tYXNrUGF0dGVybi50b1N0cmluZygpKTtcbiAgICAgICAgICAgIGlmICh0aGlzLm1hdHJpeCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoJ1xcbiBtYXRyaXg6XFxuJyk7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZCh0aGlzLm1hdHJpeC50b1N0cmluZygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoJ1xcbiBtYXRyaXg6IG51bGxcXG4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoJz4+XFxuJyk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0TW9kZSh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5tb2RlID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgc2V0RUNMZXZlbCh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5lY0xldmVsID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmVyc2lvbih2ZXJzaW9uKSB7XG4gICAgICAgICAgICB0aGlzLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgICAgICB9XG4gICAgICAgIHNldE1hc2tQYXR0ZXJuKHZhbHVlIC8qaW50Ki8pIHtcbiAgICAgICAgICAgIHRoaXMubWFza1BhdHRlcm4gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBzZXRNYXRyaXgodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMubWF0cml4ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hlY2sgaWYgXCJtYXNrX3BhdHRlcm5cIiBpcyB2YWxpZC5cbiAgICAgICAgc3RhdGljIGlzVmFsaWRNYXNrUGF0dGVybihtYXNrUGF0dGVybiAvKmludCovKSB7XG4gICAgICAgICAgICByZXR1cm4gbWFza1BhdHRlcm4gPj0gMCAmJiBtYXNrUGF0dGVybiA8IFFSQ29kZS5OVU1fTUFTS19QQVRURVJOUztcbiAgICAgICAgfVxuICAgIH1cbiAgICBRUkNvZGUuTlVNX01BU0tfUEFUVEVSTlMgPSA4O1xuXG4gICAgLyoqXG4gICAgICogQ3VzdG9tIEVycm9yIGNsYXNzIG9mIHR5cGUgRXhjZXB0aW9uLlxuICAgICAqL1xuICAgIGNsYXNzIFdyaXRlckV4Y2VwdGlvbiBleHRlbmRzIEV4Y2VwdGlvbiB7XG4gICAgfVxuICAgIFdyaXRlckV4Y2VwdGlvbi5raW5kID0gJ1dyaXRlckV4Y2VwdGlvbic7XG5cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIHNhdG9ydXhAZ29vZ2xlLmNvbSAoU2F0b3J1IFRha2FiYXlhc2hpKSAtIGNyZWF0b3JcbiAgICAgKiBAYXV0aG9yIGRzd2l0a2luQGdvb2dsZS5jb20gKERhbmllbCBTd2l0a2luKSAtIHBvcnRlZCBmcm9tIEMrK1xuICAgICAqL1xuICAgIGNsYXNzIE1hdHJpeFV0aWwge1xuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgICAgIC8vIGRvIG5vdGhpbmdcbiAgICAgICAgfVxuICAgICAgICAvLyBTZXQgYWxsIGNlbGxzIHRvIC0xIChUWVBFU0NSSVBUUE9SVDogMjU1KS4gIC0xIChUWVBFU0NSSVBUUE9SVDogMjU1KSBtZWFucyB0aGF0IHRoZSBjZWxsIGlzIGVtcHR5IChub3Qgc2V0IHlldCkuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEpBVkFQT1JUOiBXZSBzaG91bGRuJ3QgbmVlZCB0byBkbyB0aGlzIGF0IGFsbC4gVGhlIGNvZGUgc2hvdWxkIGJlIHJld3JpdHRlbiB0byBiZWdpbiBlbmNvZGluZ1xuICAgICAgICAvLyB3aXRoIHRoZSBCeXRlTWF0cml4IGluaXRpYWxpemVkIGFsbCB0byB6ZXJvLlxuICAgICAgICBzdGF0aWMgY2xlYXJNYXRyaXgobWF0cml4KSB7XG4gICAgICAgICAgICAvLyBUWVBFU0NSSVBUUE9SVDogd2UgdXNlIFVpbnRBcnJheSBzZSBjaGFuZ2VkIGhlcmUgZnJvbSAtMSB0byAyNTVcbiAgICAgICAgICAgIG1hdHJpeC5jbGVhcigvKihieXRlKSAqLyAvKi0xKi8gMjU1KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBCdWlsZCAyRCBtYXRyaXggb2YgUVIgQ29kZSBmcm9tIFwiZGF0YUJpdHNcIiB3aXRoIFwiZWNMZXZlbFwiLCBcInZlcnNpb25cIiBhbmQgXCJnZXRNYXNrUGF0dGVyblwiLiBPblxuICAgICAgICAvLyBzdWNjZXNzLCBzdG9yZSB0aGUgcmVzdWx0IGluIFwibWF0cml4XCIgYW5kIHJldHVybiB0cnVlLlxuICAgICAgICBzdGF0aWMgYnVpbGRNYXRyaXgoZGF0YUJpdHMsIGVjTGV2ZWwsIHZlcnNpb24sIG1hc2tQYXR0ZXJuIC8qaW50Ki8sIG1hdHJpeCkge1xuICAgICAgICAgICAgTWF0cml4VXRpbC5jbGVhck1hdHJpeChtYXRyaXgpO1xuICAgICAgICAgICAgTWF0cml4VXRpbC5lbWJlZEJhc2ljUGF0dGVybnModmVyc2lvbiwgbWF0cml4KTtcbiAgICAgICAgICAgIC8vIFR5cGUgaW5mb3JtYXRpb24gYXBwZWFyIHdpdGggYW55IHZlcnNpb24uXG4gICAgICAgICAgICBNYXRyaXhVdGlsLmVtYmVkVHlwZUluZm8oZWNMZXZlbCwgbWFza1BhdHRlcm4sIG1hdHJpeCk7XG4gICAgICAgICAgICAvLyBWZXJzaW9uIGluZm8gYXBwZWFyIGlmIHZlcnNpb24gPj0gNy5cbiAgICAgICAgICAgIE1hdHJpeFV0aWwubWF5YmVFbWJlZFZlcnNpb25JbmZvKHZlcnNpb24sIG1hdHJpeCk7XG4gICAgICAgICAgICAvLyBEYXRhIHNob3VsZCBiZSBlbWJlZGRlZCBhdCBlbmQuXG4gICAgICAgICAgICBNYXRyaXhVdGlsLmVtYmVkRGF0YUJpdHMoZGF0YUJpdHMsIG1hc2tQYXR0ZXJuLCBtYXRyaXgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEVtYmVkIGJhc2ljIHBhdHRlcm5zLiBPbiBzdWNjZXNzLCBtb2RpZnkgdGhlIG1hdHJpeCBhbmQgcmV0dXJuIHRydWUuXG4gICAgICAgIC8vIFRoZSBiYXNpYyBwYXR0ZXJucyBhcmU6XG4gICAgICAgIC8vIC0gUG9zaXRpb24gZGV0ZWN0aW9uIHBhdHRlcm5zXG4gICAgICAgIC8vIC0gVGltaW5nIHBhdHRlcm5zXG4gICAgICAgIC8vIC0gRGFyayBkb3QgYXQgdGhlIGxlZnQgYm90dG9tIGNvcm5lclxuICAgICAgICAvLyAtIFBvc2l0aW9uIGFkanVzdG1lbnQgcGF0dGVybnMsIGlmIG5lZWQgYmVcbiAgICAgICAgc3RhdGljIGVtYmVkQmFzaWNQYXR0ZXJucyh2ZXJzaW9uLCBtYXRyaXgpIHtcbiAgICAgICAgICAgIC8vIExldCdzIGdldCBzdGFydGVkIHdpdGggZW1iZWRkaW5nIGJpZyBzcXVhcmVzIGF0IGNvcm5lcnMuXG4gICAgICAgICAgICBNYXRyaXhVdGlsLmVtYmVkUG9zaXRpb25EZXRlY3Rpb25QYXR0ZXJuc0FuZFNlcGFyYXRvcnMobWF0cml4KTtcbiAgICAgICAgICAgIC8vIFRoZW4sIGVtYmVkIHRoZSBkYXJrIGRvdCBhdCB0aGUgbGVmdCBib3R0b20gY29ybmVyLlxuICAgICAgICAgICAgTWF0cml4VXRpbC5lbWJlZERhcmtEb3RBdExlZnRCb3R0b21Db3JuZXIobWF0cml4KTtcbiAgICAgICAgICAgIC8vIFBvc2l0aW9uIGFkanVzdG1lbnQgcGF0dGVybnMgYXBwZWFyIGlmIHZlcnNpb24gPj0gMi5cbiAgICAgICAgICAgIE1hdHJpeFV0aWwubWF5YmVFbWJlZFBvc2l0aW9uQWRqdXN0bWVudFBhdHRlcm5zKHZlcnNpb24sIG1hdHJpeCk7XG4gICAgICAgICAgICAvLyBUaW1pbmcgcGF0dGVybnMgc2hvdWxkIGJlIGVtYmVkZGVkIGFmdGVyIHBvc2l0aW9uIGFkai4gcGF0dGVybnMuXG4gICAgICAgICAgICBNYXRyaXhVdGlsLmVtYmVkVGltaW5nUGF0dGVybnMobWF0cml4KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBFbWJlZCB0eXBlIGluZm9ybWF0aW9uLiBPbiBzdWNjZXNzLCBtb2RpZnkgdGhlIG1hdHJpeC5cbiAgICAgICAgc3RhdGljIGVtYmVkVHlwZUluZm8oZWNMZXZlbCwgbWFza1BhdHRlcm4gLyppbnQqLywgbWF0cml4KSB7XG4gICAgICAgICAgICBjb25zdCB0eXBlSW5mb0JpdHMgPSBuZXcgQml0QXJyYXkoKTtcbiAgICAgICAgICAgIE1hdHJpeFV0aWwubWFrZVR5cGVJbmZvQml0cyhlY0xldmVsLCBtYXNrUGF0dGVybiwgdHlwZUluZm9CaXRzKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBzaXplID0gdHlwZUluZm9CaXRzLmdldFNpemUoKTsgaSA8IHNpemU7ICsraSkge1xuICAgICAgICAgICAgICAgIC8vIFBsYWNlIGJpdHMgaW4gTFNCIHRvIE1TQiBvcmRlci4gIExTQiAobGVhc3Qgc2lnbmlmaWNhbnQgYml0KSBpcyB0aGUgbGFzdCB2YWx1ZSBpblxuICAgICAgICAgICAgICAgIC8vIFwidHlwZUluZm9CaXRzXCIuXG4gICAgICAgICAgICAgICAgY29uc3QgYml0ID0gdHlwZUluZm9CaXRzLmdldCh0eXBlSW5mb0JpdHMuZ2V0U2l6ZSgpIC0gMSAtIGkpO1xuICAgICAgICAgICAgICAgIC8vIFR5cGUgaW5mbyBiaXRzIGF0IHRoZSBsZWZ0IHRvcCBjb3JuZXIuIFNlZSA4Ljkgb2YgSklTWDA1MTA6MjAwNCAocC40NikuXG4gICAgICAgICAgICAgICAgY29uc3QgY29vcmRpbmF0ZXMgPSBNYXRyaXhVdGlsLlRZUEVfSU5GT19DT09SRElOQVRFU1tpXTtcbiAgICAgICAgICAgICAgICBjb25zdCB4MSA9IGNvb3JkaW5hdGVzWzBdO1xuICAgICAgICAgICAgICAgIGNvbnN0IHkxID0gY29vcmRpbmF0ZXNbMV07XG4gICAgICAgICAgICAgICAgbWF0cml4LnNldEJvb2xlYW4oeDEsIHkxLCBiaXQpO1xuICAgICAgICAgICAgICAgIGlmIChpIDwgOCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBSaWdodCB0b3AgY29ybmVyLlxuICAgICAgICAgICAgICAgICAgICBjb25zdCB4MiA9IG1hdHJpeC5nZXRXaWR0aCgpIC0gaSAtIDE7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHkyID0gODtcbiAgICAgICAgICAgICAgICAgICAgbWF0cml4LnNldEJvb2xlYW4oeDIsIHkyLCBiaXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTGVmdCBib3R0b20gY29ybmVyLlxuICAgICAgICAgICAgICAgICAgICBjb25zdCB4MiA9IDg7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHkyID0gbWF0cml4LmdldEhlaWdodCgpIC0gNyArIChpIC0gOCk7XG4gICAgICAgICAgICAgICAgICAgIG1hdHJpeC5zZXRCb29sZWFuKHgyLCB5MiwgYml0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gRW1iZWQgdmVyc2lvbiBpbmZvcm1hdGlvbiBpZiBuZWVkIGJlLiBPbiBzdWNjZXNzLCBtb2RpZnkgdGhlIG1hdHJpeCBhbmQgcmV0dXJuIHRydWUuXG4gICAgICAgIC8vIFNlZSA4LjEwIG9mIEpJU1gwNTEwOjIwMDQgKHAuNDcpIGZvciBob3cgdG8gZW1iZWQgdmVyc2lvbiBpbmZvcm1hdGlvbi5cbiAgICAgICAgc3RhdGljIG1heWJlRW1iZWRWZXJzaW9uSW5mbyh2ZXJzaW9uLCBtYXRyaXgpIHtcbiAgICAgICAgICAgIGlmICh2ZXJzaW9uLmdldFZlcnNpb25OdW1iZXIoKSA8IDcpIHsgLy8gVmVyc2lvbiBpbmZvIGlzIG5lY2Vzc2FyeSBpZiB2ZXJzaW9uID49IDcuXG4gICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBEb24ndCBuZWVkIHZlcnNpb24gaW5mby5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHZlcnNpb25JbmZvQml0cyA9IG5ldyBCaXRBcnJheSgpO1xuICAgICAgICAgICAgTWF0cml4VXRpbC5tYWtlVmVyc2lvbkluZm9CaXRzKHZlcnNpb24sIHZlcnNpb25JbmZvQml0cyk7XG4gICAgICAgICAgICBsZXQgYml0SW5kZXggPSA2ICogMyAtIDE7IC8vIEl0IHdpbGwgZGVjcmVhc2UgZnJvbSAxNyB0byAwLlxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA2OyArK2kpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IDM7ICsraikge1xuICAgICAgICAgICAgICAgICAgICAvLyBQbGFjZSBiaXRzIGluIExTQiAobGVhc3Qgc2lnbmlmaWNhbnQgYml0KSB0byBNU0Igb3JkZXIuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJpdCA9IHZlcnNpb25JbmZvQml0cy5nZXQoYml0SW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBiaXRJbmRleC0tO1xuICAgICAgICAgICAgICAgICAgICAvLyBMZWZ0IGJvdHRvbSBjb3JuZXIuXG4gICAgICAgICAgICAgICAgICAgIG1hdHJpeC5zZXRCb29sZWFuKGksIG1hdHJpeC5nZXRIZWlnaHQoKSAtIDExICsgaiwgYml0KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmlnaHQgYm90dG9tIGNvcm5lci5cbiAgICAgICAgICAgICAgICAgICAgbWF0cml4LnNldEJvb2xlYW4obWF0cml4LmdldEhlaWdodCgpIC0gMTEgKyBqLCBpLCBiaXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBFbWJlZCBcImRhdGFCaXRzXCIgdXNpbmcgXCJnZXRNYXNrUGF0dGVyblwiLiBPbiBzdWNjZXNzLCBtb2RpZnkgdGhlIG1hdHJpeCBhbmQgcmV0dXJuIHRydWUuXG4gICAgICAgIC8vIEZvciBkZWJ1Z2dpbmcgcHVycG9zZXMsIGl0IHNraXBzIG1hc2tpbmcgcHJvY2VzcyBpZiBcImdldE1hc2tQYXR0ZXJuXCIgaXMgLTEoVFlQRVNDUklQVFBPUlQ6IDI1NSkuXG4gICAgICAgIC8vIFNlZSA4Ljcgb2YgSklTWDA1MTA6MjAwNCAocC4zOCkgZm9yIGhvdyB0byBlbWJlZCBkYXRhIGJpdHMuXG4gICAgICAgIHN0YXRpYyBlbWJlZERhdGFCaXRzKGRhdGFCaXRzLCBtYXNrUGF0dGVybiAvKmludCovLCBtYXRyaXgpIHtcbiAgICAgICAgICAgIGxldCBiaXRJbmRleCA9IDA7XG4gICAgICAgICAgICBsZXQgZGlyZWN0aW9uID0gLTE7XG4gICAgICAgICAgICAvLyBTdGFydCBmcm9tIHRoZSByaWdodCBib3R0b20gY2VsbC5cbiAgICAgICAgICAgIGxldCB4ID0gbWF0cml4LmdldFdpZHRoKCkgLSAxO1xuICAgICAgICAgICAgbGV0IHkgPSBtYXRyaXguZ2V0SGVpZ2h0KCkgLSAxO1xuICAgICAgICAgICAgd2hpbGUgKHggPiAwKSB7XG4gICAgICAgICAgICAgICAgLy8gU2tpcCB0aGUgdmVydGljYWwgdGltaW5nIHBhdHRlcm4uXG4gICAgICAgICAgICAgICAgaWYgKHggPT09IDYpIHtcbiAgICAgICAgICAgICAgICAgICAgeCAtPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3aGlsZSAoeSA+PSAwICYmIHkgPCBtYXRyaXguZ2V0SGVpZ2h0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAyOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHh4ID0geCAtIGk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTa2lwIHRoZSBjZWxsIGlmIGl0J3Mgbm90IGVtcHR5LlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFNYXRyaXhVdGlsLmlzRW1wdHkobWF0cml4LmdldCh4eCwgeSkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgYml0O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJpdEluZGV4IDwgZGF0YUJpdHMuZ2V0U2l6ZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYml0ID0gZGF0YUJpdHMuZ2V0KGJpdEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICArK2JpdEluZGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUGFkZGluZyBiaXQuIElmIHRoZXJlIGlzIG5vIGJpdCBsZWZ0LCB3ZSdsbCBmaWxsIHRoZSBsZWZ0IGNlbGxzIHdpdGggMCwgYXMgZGVzY3JpYmVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW4gOC40Ljkgb2YgSklTWDA1MTA6MjAwNCAocC4gMjQpLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJpdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2tpcCBtYXNraW5nIGlmIG1hc2tfcGF0dGVybiBpcyAtMSAoVFlQRVNDUklQVFBPUlQ6IDI1NSkuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWFza1BhdHRlcm4gIT09IDI1NSAmJiBNYXNrVXRpbC5nZXREYXRhTWFza0JpdChtYXNrUGF0dGVybiwgeHgsIHkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYml0ID0gIWJpdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdHJpeC5zZXRCb29sZWFuKHh4LCB5LCBiaXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHkgKz0gZGlyZWN0aW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkaXJlY3Rpb24gPSAtZGlyZWN0aW9uOyAvLyBSZXZlcnNlIHRoZSBkaXJlY3Rpb24uXG4gICAgICAgICAgICAgICAgeSArPSBkaXJlY3Rpb247XG4gICAgICAgICAgICAgICAgeCAtPSAyOyAvLyBNb3ZlIHRvIHRoZSBsZWZ0LlxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQWxsIGJpdHMgc2hvdWxkIGJlIGNvbnN1bWVkLlxuICAgICAgICAgICAgaWYgKGJpdEluZGV4ICE9PSBkYXRhQml0cy5nZXRTaXplKCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgV3JpdGVyRXhjZXB0aW9uKCdOb3QgYWxsIGJpdHMgY29uc3VtZWQ6ICcgKyBiaXRJbmRleCArICcvJyArIGRhdGFCaXRzLmdldFNpemUoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmV0dXJuIHRoZSBwb3NpdGlvbiBvZiB0aGUgbW9zdCBzaWduaWZpY2FudCBiaXQgc2V0IChvbmU6IHRvKSBpbiB0aGUgXCJ2YWx1ZVwiLiBUaGUgbW9zdFxuICAgICAgICAvLyBzaWduaWZpY2FudCBiaXQgaXMgcG9zaXRpb24gMzIuIElmIHRoZXJlIGlzIG5vIGJpdCBzZXQsIHJldHVybiAwLiBFeGFtcGxlczpcbiAgICAgICAgLy8gLSBmaW5kTVNCU2V0KDApID0+IDBcbiAgICAgICAgLy8gLSBmaW5kTVNCU2V0KDEpID0+IDFcbiAgICAgICAgLy8gLSBmaW5kTVNCU2V0KDI1NSkgPT4gOFxuICAgICAgICBzdGF0aWMgZmluZE1TQlNldCh2YWx1ZSAvKmludCovKSB7XG4gICAgICAgICAgICByZXR1cm4gMzIgLSBJbnRlZ2VyLm51bWJlck9mTGVhZGluZ1plcm9zKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDYWxjdWxhdGUgQkNIIChCb3NlLUNoYXVkaHVyaS1Ib2NxdWVuZ2hlbSkgY29kZSBmb3IgXCJ2YWx1ZVwiIHVzaW5nIHBvbHlub21pYWwgXCJwb2x5XCIuIFRoZSBCQ0hcbiAgICAgICAgLy8gY29kZSBpcyB1c2VkIGZvciBlbmNvZGluZyB0eXBlIGluZm9ybWF0aW9uIGFuZCB2ZXJzaW9uIGluZm9ybWF0aW9uLlxuICAgICAgICAvLyBFeGFtcGxlOiBDYWxjdWxhdGlvbiBvZiB2ZXJzaW9uIGluZm9ybWF0aW9uIG9mIDcuXG4gICAgICAgIC8vIGYoeCkgaXMgY3JlYXRlZCBmcm9tIDcuXG4gICAgICAgIC8vICAgLSA3ID0gMDAwMTExIGluIDYgYml0c1xuICAgICAgICAvLyAgIC0gZih4KSA9IHheMiArIHheMSArIHheMFxuICAgICAgICAvLyBnKHgpIGlzIGdpdmVuIGJ5IHRoZSBzdGFuZGFyZCAocC4gNjcpXG4gICAgICAgIC8vICAgLSBnKHgpID0geF4xMiArIHheMTEgKyB4XjEwICsgeF45ICsgeF44ICsgeF41ICsgeF4yICsgMVxuICAgICAgICAvLyBNdWx0aXBseSBmKHgpIGJ5IHheKDE4IC0gNilcbiAgICAgICAgLy8gICAtIGYnKHgpID0gZih4KSAqIHheKDE4IC0gNilcbiAgICAgICAgLy8gICAtIGYnKHgpID0geF4xNCArIHheMTMgKyB4XjEyXG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgcmVtYWluZGVyIG9mIGYnKHgpIC8gZyh4KVxuICAgICAgICAvLyAgICAgICAgIHheMlxuICAgICAgICAvLyAgICAgICAgIF9fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fXG4gICAgICAgIC8vICAgZyh4KSApeF4xNCArIHheMTMgKyB4XjEyXG4gICAgICAgIC8vICAgICAgICAgeF4xNCArIHheMTMgKyB4XjEyICsgeF4xMSArIHheMTAgKyB4XjcgKyB4XjQgKyB4XjJcbiAgICAgICAgLy8gICAgICAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHheMTEgKyB4XjEwICsgeF43ICsgeF40ICsgeF4yXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFRoZSByZW1haW5kZXIgaXMgeF4xMSArIHheMTAgKyB4XjcgKyB4XjQgKyB4XjJcbiAgICAgICAgLy8gRW5jb2RlIGl0IGluIGJpbmFyeTogMTEwMDEwMDEwMTAwXG4gICAgICAgIC8vIFRoZSByZXR1cm4gdmFsdWUgaXMgMHhjOTQgKDExMDAgMTAwMSAwMTAwKVxuICAgICAgICAvL1xuICAgICAgICAvLyBTaW5jZSBhbGwgY29lZmZpY2llbnRzIGluIHRoZSBwb2x5bm9taWFscyBhcmUgMSBvciAwLCB3ZSBjYW4gZG8gdGhlIGNhbGN1bGF0aW9uIGJ5IGJpdFxuICAgICAgICAvLyBvcGVyYXRpb25zLiBXZSBkb24ndCBjYXJlIGlmIGNvZWZmaWNpZW50cyBhcmUgcG9zaXRpdmUgb3IgbmVnYXRpdmUuXG4gICAgICAgIHN0YXRpYyBjYWxjdWxhdGVCQ0hDb2RlKHZhbHVlIC8qaW50Ki8sIHBvbHkgLyppbnQqLykge1xuICAgICAgICAgICAgaWYgKHBvbHkgPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCcwIHBvbHlub21pYWwnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHBvbHkgaXMgXCIxIDExMTEgMDAxMCAwMTAxXCIgKHZlcnNpb24gaW5mbyBwb2x5KSwgbXNiU2V0SW5Qb2x5IGlzIDEzLiBXZSdsbCBzdWJ0cmFjdCAxXG4gICAgICAgICAgICAvLyBmcm9tIDEzIHRvIG1ha2UgaXQgMTIuXG4gICAgICAgICAgICBjb25zdCBtc2JTZXRJblBvbHkgPSBNYXRyaXhVdGlsLmZpbmRNU0JTZXQocG9seSk7XG4gICAgICAgICAgICB2YWx1ZSA8PD0gbXNiU2V0SW5Qb2x5IC0gMTtcbiAgICAgICAgICAgIC8vIERvIHRoZSBkaXZpc2lvbiBidXNpbmVzcyB1c2luZyBleGNsdXNpdmUtb3Igb3BlcmF0aW9ucy5cbiAgICAgICAgICAgIHdoaWxlIChNYXRyaXhVdGlsLmZpbmRNU0JTZXQodmFsdWUpID49IG1zYlNldEluUG9seSkge1xuICAgICAgICAgICAgICAgIHZhbHVlIF49IHBvbHkgPDwgKE1hdHJpeFV0aWwuZmluZE1TQlNldCh2YWx1ZSkgLSBtc2JTZXRJblBvbHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTm93IHRoZSBcInZhbHVlXCIgaXMgdGhlIHJlbWFpbmRlciAoaS5lLiB0aGUgQkNIIGNvZGUpXG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTWFrZSBiaXQgdmVjdG9yIG9mIHR5cGUgaW5mb3JtYXRpb24uIE9uIHN1Y2Nlc3MsIHN0b3JlIHRoZSByZXN1bHQgaW4gXCJiaXRzXCIgYW5kIHJldHVybiB0cnVlLlxuICAgICAgICAvLyBFbmNvZGUgZXJyb3IgY29ycmVjdGlvbiBsZXZlbCBhbmQgbWFzayBwYXR0ZXJuLiBTZWUgOC45IG9mXG4gICAgICAgIC8vIEpJU1gwNTEwOjIwMDQgKHAuNDUpIGZvciBkZXRhaWxzLlxuICAgICAgICBzdGF0aWMgbWFrZVR5cGVJbmZvQml0cyhlY0xldmVsLCBtYXNrUGF0dGVybiAvKmludCovLCBiaXRzKSB7XG4gICAgICAgICAgICBpZiAoIVFSQ29kZS5pc1ZhbGlkTWFza1BhdHRlcm4obWFza1BhdHRlcm4pKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFdyaXRlckV4Y2VwdGlvbignSW52YWxpZCBtYXNrIHBhdHRlcm4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHR5cGVJbmZvID0gKGVjTGV2ZWwuZ2V0Qml0cygpIDw8IDMpIHwgbWFza1BhdHRlcm47XG4gICAgICAgICAgICBiaXRzLmFwcGVuZEJpdHModHlwZUluZm8sIDUpO1xuICAgICAgICAgICAgY29uc3QgYmNoQ29kZSA9IE1hdHJpeFV0aWwuY2FsY3VsYXRlQkNIQ29kZSh0eXBlSW5mbywgTWF0cml4VXRpbC5UWVBFX0lORk9fUE9MWSk7XG4gICAgICAgICAgICBiaXRzLmFwcGVuZEJpdHMoYmNoQ29kZSwgMTApO1xuICAgICAgICAgICAgY29uc3QgbWFza0JpdHMgPSBuZXcgQml0QXJyYXkoKTtcbiAgICAgICAgICAgIG1hc2tCaXRzLmFwcGVuZEJpdHMoTWF0cml4VXRpbC5UWVBFX0lORk9fTUFTS19QQVRURVJOLCAxNSk7XG4gICAgICAgICAgICBiaXRzLnhvcihtYXNrQml0cyk7XG4gICAgICAgICAgICBpZiAoYml0cy5nZXRTaXplKCkgIT09IDE1KSB7IC8vIEp1c3QgaW4gY2FzZS5cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgV3JpdGVyRXhjZXB0aW9uKCdzaG91bGQgbm90IGhhcHBlbiBidXQgd2UgZ290OiAnICsgYml0cy5nZXRTaXplKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIE1ha2UgYml0IHZlY3RvciBvZiB2ZXJzaW9uIGluZm9ybWF0aW9uLiBPbiBzdWNjZXNzLCBzdG9yZSB0aGUgcmVzdWx0IGluIFwiYml0c1wiIGFuZCByZXR1cm4gdHJ1ZS5cbiAgICAgICAgLy8gU2VlIDguMTAgb2YgSklTWDA1MTA6MjAwNCAocC40NSkgZm9yIGRldGFpbHMuXG4gICAgICAgIHN0YXRpYyBtYWtlVmVyc2lvbkluZm9CaXRzKHZlcnNpb24sIGJpdHMpIHtcbiAgICAgICAgICAgIGJpdHMuYXBwZW5kQml0cyh2ZXJzaW9uLmdldFZlcnNpb25OdW1iZXIoKSwgNik7XG4gICAgICAgICAgICBjb25zdCBiY2hDb2RlID0gTWF0cml4VXRpbC5jYWxjdWxhdGVCQ0hDb2RlKHZlcnNpb24uZ2V0VmVyc2lvbk51bWJlcigpLCBNYXRyaXhVdGlsLlZFUlNJT05fSU5GT19QT0xZKTtcbiAgICAgICAgICAgIGJpdHMuYXBwZW5kQml0cyhiY2hDb2RlLCAxMik7XG4gICAgICAgICAgICBpZiAoYml0cy5nZXRTaXplKCkgIT09IDE4KSB7IC8vIEp1c3QgaW4gY2FzZS5cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgV3JpdGVyRXhjZXB0aW9uKCdzaG91bGQgbm90IGhhcHBlbiBidXQgd2UgZ290OiAnICsgYml0cy5nZXRTaXplKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIENoZWNrIGlmIFwidmFsdWVcIiBpcyBlbXB0eS5cbiAgICAgICAgc3RhdGljIGlzRW1wdHkodmFsdWUgLyppbnQqLykge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlID09PSAyNTU7IC8vIC0xXG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGVtYmVkVGltaW5nUGF0dGVybnMobWF0cml4KSB7XG4gICAgICAgICAgICAvLyAtOCBpcyBmb3Igc2tpcHBpbmcgcG9zaXRpb24gZGV0ZWN0aW9uIHBhdHRlcm5zICg3OiBzaXplKSwgYW5kIHR3byBob3Jpem9udGFsL3ZlcnRpY2FsXG4gICAgICAgICAgICAvLyBzZXBhcmF0aW9uIHBhdHRlcm5zICgxOiBzaXplKS4gVGh1cywgOCA9IDcgKyAxLlxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDg7IGkgPCBtYXRyaXguZ2V0V2lkdGgoKSAtIDg7ICsraSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJpdCA9IChpICsgMSkgJSAyO1xuICAgICAgICAgICAgICAgIC8vIEhvcml6b250YWwgbGluZS5cbiAgICAgICAgICAgICAgICBpZiAoTWF0cml4VXRpbC5pc0VtcHR5KG1hdHJpeC5nZXQoaSwgNikpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdHJpeC5zZXROdW1iZXIoaSwgNiwgYml0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVmVydGljYWwgbGluZS5cbiAgICAgICAgICAgICAgICBpZiAoTWF0cml4VXRpbC5pc0VtcHR5KG1hdHJpeC5nZXQoNiwgaSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdHJpeC5zZXROdW1iZXIoNiwgaSwgYml0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gRW1iZWQgdGhlIGxvbmVseSBkYXJrIGRvdCBhdCBsZWZ0IGJvdHRvbSBjb3JuZXIuIEpJU1gwNTEwOjIwMDQgKHAuNDYpXG4gICAgICAgIHN0YXRpYyBlbWJlZERhcmtEb3RBdExlZnRCb3R0b21Db3JuZXIobWF0cml4KSB7XG4gICAgICAgICAgICBpZiAobWF0cml4LmdldCg4LCBtYXRyaXguZ2V0SGVpZ2h0KCkgLSA4KSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBXcml0ZXJFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1hdHJpeC5zZXROdW1iZXIoOCwgbWF0cml4LmdldEhlaWdodCgpIC0gOCwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGVtYmVkSG9yaXpvbnRhbFNlcGFyYXRpb25QYXR0ZXJuKHhTdGFydCAvKmludCovLCB5U3RhcnQgLyppbnQqLywgbWF0cml4KSB7XG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IDg7ICsreCkge1xuICAgICAgICAgICAgICAgIGlmICghTWF0cml4VXRpbC5pc0VtcHR5KG1hdHJpeC5nZXQoeFN0YXJ0ICsgeCwgeVN0YXJ0KSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFdyaXRlckV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtYXRyaXguc2V0TnVtYmVyKHhTdGFydCArIHgsIHlTdGFydCwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGVtYmVkVmVydGljYWxTZXBhcmF0aW9uUGF0dGVybih4U3RhcnQgLyppbnQqLywgeVN0YXJ0IC8qaW50Ki8sIG1hdHJpeCkge1xuICAgICAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCA3OyArK3kpIHtcbiAgICAgICAgICAgICAgICBpZiAoIU1hdHJpeFV0aWwuaXNFbXB0eShtYXRyaXguZ2V0KHhTdGFydCwgeVN0YXJ0ICsgeSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBXcml0ZXJFeGNlcHRpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbWF0cml4LnNldE51bWJlcih4U3RhcnQsIHlTdGFydCArIHksIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBlbWJlZFBvc2l0aW9uQWRqdXN0bWVudFBhdHRlcm4oeFN0YXJ0IC8qaW50Ki8sIHlTdGFydCAvKmludCovLCBtYXRyaXgpIHtcbiAgICAgICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgNTsgKyt5KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGF0dGVyblkgPSBNYXRyaXhVdGlsLlBPU0lUSU9OX0FESlVTVE1FTlRfUEFUVEVSTlt5XTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IDU7ICsreCkge1xuICAgICAgICAgICAgICAgICAgICBtYXRyaXguc2V0TnVtYmVyKHhTdGFydCArIHgsIHlTdGFydCArIHksIHBhdHRlcm5ZW3hdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGVtYmVkUG9zaXRpb25EZXRlY3Rpb25QYXR0ZXJuKHhTdGFydCAvKmludCovLCB5U3RhcnQgLyppbnQqLywgbWF0cml4KSB7XG4gICAgICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IDc7ICsreSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhdHRlcm5ZID0gTWF0cml4VXRpbC5QT1NJVElPTl9ERVRFQ1RJT05fUEFUVEVSTlt5XTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IDc7ICsreCkge1xuICAgICAgICAgICAgICAgICAgICBtYXRyaXguc2V0TnVtYmVyKHhTdGFydCArIHgsIHlTdGFydCArIHksIHBhdHRlcm5ZW3hdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gRW1iZWQgcG9zaXRpb24gZGV0ZWN0aW9uIHBhdHRlcm5zIGFuZCBzdXJyb3VuZGluZyB2ZXJ0aWNhbC9ob3Jpem9udGFsIHNlcGFyYXRvcnMuXG4gICAgICAgIHN0YXRpYyBlbWJlZFBvc2l0aW9uRGV0ZWN0aW9uUGF0dGVybnNBbmRTZXBhcmF0b3JzKG1hdHJpeCkge1xuICAgICAgICAgICAgLy8gRW1iZWQgdGhyZWUgYmlnIHNxdWFyZXMgYXQgY29ybmVycy5cbiAgICAgICAgICAgIGNvbnN0IHBkcFdpZHRoID0gTWF0cml4VXRpbC5QT1NJVElPTl9ERVRFQ1RJT05fUEFUVEVSTlswXS5sZW5ndGg7XG4gICAgICAgICAgICAvLyBMZWZ0IHRvcCBjb3JuZXIuXG4gICAgICAgICAgICBNYXRyaXhVdGlsLmVtYmVkUG9zaXRpb25EZXRlY3Rpb25QYXR0ZXJuKDAsIDAsIG1hdHJpeCk7XG4gICAgICAgICAgICAvLyBSaWdodCB0b3AgY29ybmVyLlxuICAgICAgICAgICAgTWF0cml4VXRpbC5lbWJlZFBvc2l0aW9uRGV0ZWN0aW9uUGF0dGVybihtYXRyaXguZ2V0V2lkdGgoKSAtIHBkcFdpZHRoLCAwLCBtYXRyaXgpO1xuICAgICAgICAgICAgLy8gTGVmdCBib3R0b20gY29ybmVyLlxuICAgICAgICAgICAgTWF0cml4VXRpbC5lbWJlZFBvc2l0aW9uRGV0ZWN0aW9uUGF0dGVybigwLCBtYXRyaXguZ2V0V2lkdGgoKSAtIHBkcFdpZHRoLCBtYXRyaXgpO1xuICAgICAgICAgICAgLy8gRW1iZWQgaG9yaXpvbnRhbCBzZXBhcmF0aW9uIHBhdHRlcm5zIGFyb3VuZCB0aGUgc3F1YXJlcy5cbiAgICAgICAgICAgIGNvbnN0IGhzcFdpZHRoID0gODtcbiAgICAgICAgICAgIC8vIExlZnQgdG9wIGNvcm5lci5cbiAgICAgICAgICAgIE1hdHJpeFV0aWwuZW1iZWRIb3Jpem9udGFsU2VwYXJhdGlvblBhdHRlcm4oMCwgaHNwV2lkdGggLSAxLCBtYXRyaXgpO1xuICAgICAgICAgICAgLy8gUmlnaHQgdG9wIGNvcm5lci5cbiAgICAgICAgICAgIE1hdHJpeFV0aWwuZW1iZWRIb3Jpem9udGFsU2VwYXJhdGlvblBhdHRlcm4obWF0cml4LmdldFdpZHRoKCkgLSBoc3BXaWR0aCwgaHNwV2lkdGggLSAxLCBtYXRyaXgpO1xuICAgICAgICAgICAgLy8gTGVmdCBib3R0b20gY29ybmVyLlxuICAgICAgICAgICAgTWF0cml4VXRpbC5lbWJlZEhvcml6b250YWxTZXBhcmF0aW9uUGF0dGVybigwLCBtYXRyaXguZ2V0V2lkdGgoKSAtIGhzcFdpZHRoLCBtYXRyaXgpO1xuICAgICAgICAgICAgLy8gRW1iZWQgdmVydGljYWwgc2VwYXJhdGlvbiBwYXR0ZXJucyBhcm91bmQgdGhlIHNxdWFyZXMuXG4gICAgICAgICAgICBjb25zdCB2c3BTaXplID0gNztcbiAgICAgICAgICAgIC8vIExlZnQgdG9wIGNvcm5lci5cbiAgICAgICAgICAgIE1hdHJpeFV0aWwuZW1iZWRWZXJ0aWNhbFNlcGFyYXRpb25QYXR0ZXJuKHZzcFNpemUsIDAsIG1hdHJpeCk7XG4gICAgICAgICAgICAvLyBSaWdodCB0b3AgY29ybmVyLlxuICAgICAgICAgICAgTWF0cml4VXRpbC5lbWJlZFZlcnRpY2FsU2VwYXJhdGlvblBhdHRlcm4obWF0cml4LmdldEhlaWdodCgpIC0gdnNwU2l6ZSAtIDEsIDAsIG1hdHJpeCk7XG4gICAgICAgICAgICAvLyBMZWZ0IGJvdHRvbSBjb3JuZXIuXG4gICAgICAgICAgICBNYXRyaXhVdGlsLmVtYmVkVmVydGljYWxTZXBhcmF0aW9uUGF0dGVybih2c3BTaXplLCBtYXRyaXguZ2V0SGVpZ2h0KCkgLSB2c3BTaXplLCBtYXRyaXgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEVtYmVkIHBvc2l0aW9uIGFkanVzdG1lbnQgcGF0dGVybnMgaWYgbmVlZCBiZS5cbiAgICAgICAgc3RhdGljIG1heWJlRW1iZWRQb3NpdGlvbkFkanVzdG1lbnRQYXR0ZXJucyh2ZXJzaW9uLCBtYXRyaXgpIHtcbiAgICAgICAgICAgIGlmICh2ZXJzaW9uLmdldFZlcnNpb25OdW1iZXIoKSA8IDIpIHsgLy8gVGhlIHBhdHRlcm5zIGFwcGVhciBpZiB2ZXJzaW9uID49IDJcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHZlcnNpb24uZ2V0VmVyc2lvbk51bWJlcigpIC0gMTtcbiAgICAgICAgICAgIGNvbnN0IGNvb3JkaW5hdGVzID0gTWF0cml4VXRpbC5QT1NJVElPTl9BREpVU1RNRU5UX1BBVFRFUk5fQ09PUkRJTkFURV9UQUJMRVtpbmRleF07XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuZ3RoID0gY29vcmRpbmF0ZXMubGVuZ3RoOyBpICE9PSBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHkgPSBjb29yZGluYXRlc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoeSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqICE9PSBsZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeCA9IGNvb3JkaW5hdGVzW2pdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHggPj0gMCAmJiBNYXRyaXhVdGlsLmlzRW1wdHkobWF0cml4LmdldCh4LCB5KSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgY2VsbCBpcyB1bnNldCwgd2UgZW1iZWQgdGhlIHBvc2l0aW9uIGFkanVzdG1lbnQgcGF0dGVybiBoZXJlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIC0yIGlzIG5lY2Vzc2FyeSBzaW5jZSB0aGUgeC95IGNvb3JkaW5hdGVzIHBvaW50IHRvIHRoZSBjZW50ZXIgb2YgdGhlIHBhdHRlcm4sIG5vdCB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBsZWZ0IHRvcCBjb3JuZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0cml4VXRpbC5lbWJlZFBvc2l0aW9uQWRqdXN0bWVudFBhdHRlcm4oeCAtIDIsIHkgLSAyLCBtYXRyaXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIE1hdHJpeFV0aWwuUE9TSVRJT05fREVURUNUSU9OX1BBVFRFUk4gPSBBcnJheS5mcm9tKFtcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAxLCAxLCAxLCAxLCAxLCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMCwgMCwgMCwgMCwgMCwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDAsIDEsIDEsIDEsIDAsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAwLCAxLCAxLCAxLCAwLCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMCwgMSwgMSwgMSwgMCwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDAsIDAsIDAsIDAsIDAsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAxLCAxLCAxLCAxLCAxLCAxXSksXG4gICAgXSk7XG4gICAgTWF0cml4VXRpbC5QT1NJVElPTl9BREpVU1RNRU5UX1BBVFRFUk4gPSBBcnJheS5mcm9tKFtcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAxLCAxLCAxLCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMCwgMCwgMCwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDAsIDEsIDAsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAwLCAwLCAwLCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMSwgMSwgMSwgMV0pLFxuICAgIF0pO1xuICAgIC8vIEZyb20gQXBwZW5kaXggRS4gVGFibGUgMSwgSklTMDUxMFg6MjAwNCAoNzE6IHApLiBUaGUgdGFibGUgd2FzIGRvdWJsZS1jaGVja2VkIGJ5IGtvbWF0c3UuXG4gICAgTWF0cml4VXRpbC5QT1NJVElPTl9BREpVU1RNRU5UX1BBVFRFUk5fQ09PUkRJTkFURV9UQUJMRSA9IEFycmF5LmZyb20oW1xuICAgICAgICBJbnQzMkFycmF5LmZyb20oWy0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNiwgMTgsIC0xLCAtMSwgLTEsIC0xLCAtMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzYsIDIyLCAtMSwgLTEsIC0xLCAtMSwgLTFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFs2LCAyNiwgLTEsIC0xLCAtMSwgLTEsIC0xXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNiwgMzAsIC0xLCAtMSwgLTEsIC0xLCAtMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzYsIDM0LCAtMSwgLTEsIC0xLCAtMSwgLTFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFs2LCAyMiwgMzgsIC0xLCAtMSwgLTEsIC0xXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNiwgMjQsIDQyLCAtMSwgLTEsIC0xLCAtMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzYsIDI2LCA0NiwgLTEsIC0xLCAtMSwgLTFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFs2LCAyOCwgNTAsIC0xLCAtMSwgLTEsIC0xXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNiwgMzAsIDU0LCAtMSwgLTEsIC0xLCAtMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzYsIDMyLCA1OCwgLTEsIC0xLCAtMSwgLTFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFs2LCAzNCwgNjIsIC0xLCAtMSwgLTEsIC0xXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNiwgMjYsIDQ2LCA2NiwgLTEsIC0xLCAtMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzYsIDI2LCA0OCwgNzAsIC0xLCAtMSwgLTFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFs2LCAyNiwgNTAsIDc0LCAtMSwgLTEsIC0xXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNiwgMzAsIDU0LCA3OCwgLTEsIC0xLCAtMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzYsIDMwLCA1NiwgODIsIC0xLCAtMSwgLTFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFs2LCAzMCwgNTgsIDg2LCAtMSwgLTEsIC0xXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNiwgMzQsIDYyLCA5MCwgLTEsIC0xLCAtMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzYsIDI4LCA1MCwgNzIsIDk0LCAtMSwgLTFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFs2LCAyNiwgNTAsIDc0LCA5OCwgLTEsIC0xXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNiwgMzAsIDU0LCA3OCwgMTAyLCAtMSwgLTFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFs2LCAyOCwgNTQsIDgwLCAxMDYsIC0xLCAtMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzYsIDMyLCA1OCwgODQsIDExMCwgLTEsIC0xXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNiwgMzAsIDU4LCA4NiwgMTE0LCAtMSwgLTFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFs2LCAzNCwgNjIsIDkwLCAxMTgsIC0xLCAtMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzYsIDI2LCA1MCwgNzQsIDk4LCAxMjIsIC0xXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNiwgMzAsIDU0LCA3OCwgMTAyLCAxMjYsIC0xXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNiwgMjYsIDUyLCA3OCwgMTA0LCAxMzAsIC0xXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNiwgMzAsIDU2LCA4MiwgMTA4LCAxMzQsIC0xXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNiwgMzQsIDYwLCA4NiwgMTEyLCAxMzgsIC0xXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNiwgMzAsIDU4LCA4NiwgMTE0LCAxNDIsIC0xXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNiwgMzQsIDYyLCA5MCwgMTE4LCAxNDYsIC0xXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNiwgMzAsIDU0LCA3OCwgMTAyLCAxMjYsIDE1MF0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzYsIDI0LCA1MCwgNzYsIDEwMiwgMTI4LCAxNTRdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFs2LCAyOCwgNTQsIDgwLCAxMDYsIDEzMiwgMTU4XSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNiwgMzIsIDU4LCA4NCwgMTEwLCAxMzYsIDE2Ml0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzYsIDI2LCA1NCwgODIsIDExMCwgMTM4LCAxNjZdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFs2LCAzMCwgNTgsIDg2LCAxMTQsIDE0MiwgMTcwXSksXG4gICAgXSk7XG4gICAgLy8gVHlwZSBpbmZvIGNlbGxzIGF0IHRoZSBsZWZ0IHRvcCBjb3JuZXIuXG4gICAgTWF0cml4VXRpbC5UWVBFX0lORk9fQ09PUkRJTkFURVMgPSBBcnJheS5mcm9tKFtcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFs4LCAwXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbOCwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzgsIDJdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFs4LCAzXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbOCwgNF0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzgsIDVdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFs4LCA3XSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbOCwgOF0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzcsIDhdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFs1LCA4XSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNCwgOF0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzMsIDhdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsyLCA4XSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgOF0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzAsIDhdKSxcbiAgICBdKTtcbiAgICAvLyBGcm9tIEFwcGVuZGl4IEQgaW4gSklTWDA1MTA6MjAwNCAocC4gNjcpXG4gICAgTWF0cml4VXRpbC5WRVJTSU9OX0lORk9fUE9MWSA9IDB4MWYyNTsgLy8gMSAxMTExIDAwMTAgMDEwMVxuICAgIC8vIEZyb20gQXBwZW5kaXggQyBpbiBKSVNYMDUxMDoyMDA0IChwLjY1KS5cbiAgICBNYXRyaXhVdGlsLlRZUEVfSU5GT19QT0xZID0gMHg1Mzc7XG4gICAgTWF0cml4VXRpbC5UWVBFX0lORk9fTUFTS19QQVRURVJOID0gMHg1NDEyO1xuXG4gICAgLypuYW1lc3BhY2UgY29tLmdvb2dsZS56eGluZy5xcmNvZGUuZW5jb2RlciB7Ki9cbiAgICBjbGFzcyBCbG9ja1BhaXIge1xuICAgICAgICBjb25zdHJ1Y3RvcihkYXRhQnl0ZXMsIGVycm9yQ29ycmVjdGlvbkJ5dGVzKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGFCeXRlcyA9IGRhdGFCeXRlcztcbiAgICAgICAgICAgIHRoaXMuZXJyb3JDb3JyZWN0aW9uQnl0ZXMgPSBlcnJvckNvcnJlY3Rpb25CeXRlcztcbiAgICAgICAgfVxuICAgICAgICBnZXREYXRhQnl0ZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhQnl0ZXM7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0RXJyb3JDb3JyZWN0aW9uQnl0ZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lcnJvckNvcnJlY3Rpb25CeXRlcztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qaW1wb3J0IGphdmEuaW8uVW5zdXBwb3J0ZWRFbmNvZGluZ0V4Y2VwdGlvbjsqL1xuICAgIC8qaW1wb3J0IGphdmEudXRpbC5BcnJheUxpc3Q7Ki9cbiAgICAvKmltcG9ydCBqYXZhLnV0aWwuQ29sbGVjdGlvbjsqL1xuICAgIC8qaW1wb3J0IGphdmEudXRpbC5NYXA7Ki9cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIHNhdG9ydXhAZ29vZ2xlLmNvbSAoU2F0b3J1IFRha2FiYXlhc2hpKSAtIGNyZWF0b3JcbiAgICAgKiBAYXV0aG9yIGRzd2l0a2luQGdvb2dsZS5jb20gKERhbmllbCBTd2l0a2luKSAtIHBvcnRlZCBmcm9tIEMrK1xuICAgICAqL1xuICAgIGNsYXNzIEVuY29kZXIge1xuICAgICAgICAvLyBUWVBFU0NSSVBUUE9SVDogY2hhbmdlZCB0byBVVEY4LCB0aGUgZGVmYXVsdCBmb3IganNcbiAgICAgICAgY29uc3RydWN0b3IoKSB7IH1cbiAgICAgICAgLy8gVGhlIG1hc2sgcGVuYWx0eSBjYWxjdWxhdGlvbiBpcyBjb21wbGljYXRlZC4gIFNlZSBUYWJsZSAyMSBvZiBKSVNYMDUxMDoyMDA0IChwLjQ1KSBmb3IgZGV0YWlscy5cbiAgICAgICAgLy8gQmFzaWNhbGx5IGl0IGFwcGxpZXMgZm91ciBydWxlcyBhbmQgc3VtbWF0ZSBhbGwgcGVuYWx0aWVzLlxuICAgICAgICBzdGF0aWMgY2FsY3VsYXRlTWFza1BlbmFsdHkobWF0cml4KSB7XG4gICAgICAgICAgICByZXR1cm4gTWFza1V0aWwuYXBwbHlNYXNrUGVuYWx0eVJ1bGUxKG1hdHJpeClcbiAgICAgICAgICAgICAgICArIE1hc2tVdGlsLmFwcGx5TWFza1BlbmFsdHlSdWxlMihtYXRyaXgpXG4gICAgICAgICAgICAgICAgKyBNYXNrVXRpbC5hcHBseU1hc2tQZW5hbHR5UnVsZTMobWF0cml4KVxuICAgICAgICAgICAgICAgICsgTWFza1V0aWwuYXBwbHlNYXNrUGVuYWx0eVJ1bGU0KG1hdHJpeCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSBjb250ZW50IHRleHQgdG8gZW5jb2RlXG4gICAgICAgICAqIEBwYXJhbSBlY0xldmVsIGVycm9yIGNvcnJlY3Rpb24gbGV2ZWwgdG8gdXNlXG4gICAgICAgICAqIEByZXR1cm4ge0BsaW5rIFFSQ29kZX0gcmVwcmVzZW50aW5nIHRoZSBlbmNvZGVkIFFSIGNvZGVcbiAgICAgICAgICogQHRocm93cyBXcml0ZXJFeGNlcHRpb24gaWYgZW5jb2RpbmcgY2FuJ3Qgc3VjY2VlZCwgYmVjYXVzZSBvZiBmb3IgZXhhbXBsZSBpbnZhbGlkIGNvbnRlbnRcbiAgICAgICAgICogICBvciBjb25maWd1cmF0aW9uXG4gICAgICAgICAqL1xuICAgICAgICAvLyBwdWJsaWMgc3RhdGljIGVuY29kZShjb250ZW50OiBzdHJpbmcsIGVjTGV2ZWw6IEVycm9yQ29ycmVjdGlvbkxldmVsKTogUVJDb2RlIC8qdGhyb3dzIFdyaXRlckV4Y2VwdGlvbiovIHtcbiAgICAgICAgLy8gICByZXR1cm4gZW5jb2RlKGNvbnRlbnQsIGVjTGV2ZWwsIG51bGwpXG4gICAgICAgIC8vIH1cbiAgICAgICAgc3RhdGljIGVuY29kZShjb250ZW50LCBlY0xldmVsLCBoaW50cyA9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIERldGVybWluZSB3aGF0IGNoYXJhY3RlciBlbmNvZGluZyBoYXMgYmVlbiBzcGVjaWZpZWQgYnkgdGhlIGNhbGxlciwgaWYgYW55XG4gICAgICAgICAgICBsZXQgZW5jb2RpbmcgPSBFbmNvZGVyLkRFRkFVTFRfQllURV9NT0RFX0VOQ09ESU5HO1xuICAgICAgICAgICAgY29uc3QgaGFzRW5jb2RpbmdIaW50ID0gaGludHMgIT09IG51bGwgJiYgdW5kZWZpbmVkICE9PSBoaW50cy5nZXQoRW5jb2RlSGludFR5cGUkMS5DSEFSQUNURVJfU0VUKTtcbiAgICAgICAgICAgIGlmIChoYXNFbmNvZGluZ0hpbnQpIHtcbiAgICAgICAgICAgICAgICBlbmNvZGluZyA9IGhpbnRzLmdldChFbmNvZGVIaW50VHlwZSQxLkNIQVJBQ1RFUl9TRVQpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBQaWNrIGFuIGVuY29kaW5nIG1vZGUgYXBwcm9wcmlhdGUgZm9yIHRoZSBjb250ZW50LiBOb3RlIHRoYXQgdGhpcyB3aWxsIG5vdCBhdHRlbXB0IHRvIHVzZVxuICAgICAgICAgICAgLy8gbXVsdGlwbGUgbW9kZXMgLyBzZWdtZW50cyBldmVuIGlmIHRoYXQgd2VyZSBtb3JlIGVmZmljaWVudC4gVHdvdWxkIGJlIG5pY2UuXG4gICAgICAgICAgICBjb25zdCBtb2RlID0gdGhpcy5jaG9vc2VNb2RlKGNvbnRlbnQsIGVuY29kaW5nKTtcbiAgICAgICAgICAgIC8vIFRoaXMgd2lsbCBzdG9yZSB0aGUgaGVhZGVyIGluZm9ybWF0aW9uLCBsaWtlIG1vZGUgYW5kXG4gICAgICAgICAgICAvLyBsZW5ndGgsIGFzIHdlbGwgYXMgXCJoZWFkZXJcIiBzZWdtZW50cyBsaWtlIGFuIEVDSSBzZWdtZW50LlxuICAgICAgICAgICAgY29uc3QgaGVhZGVyQml0cyA9IG5ldyBCaXRBcnJheSgpO1xuICAgICAgICAgICAgLy8gQXBwZW5kIEVDSSBzZWdtZW50IGlmIGFwcGxpY2FibGVcbiAgICAgICAgICAgIGlmIChtb2RlID09PSBNb2RlJDEuQllURSAmJiAoaGFzRW5jb2RpbmdIaW50IHx8IEVuY29kZXIuREVGQVVMVF9CWVRFX01PREVfRU5DT0RJTkcgIT09IGVuY29kaW5nKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVjaSA9IENoYXJhY3RlclNldEVDSS5nZXRDaGFyYWN0ZXJTZXRFQ0lCeU5hbWUoZW5jb2RpbmcpO1xuICAgICAgICAgICAgICAgIGlmIChlY2kgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcGVuZEVDSShlY2ksIGhlYWRlckJpdHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIChXaXRoIEVDSSBpbiBwbGFjZSwpIFdyaXRlIHRoZSBtb2RlIG1hcmtlclxuICAgICAgICAgICAgdGhpcy5hcHBlbmRNb2RlSW5mbyhtb2RlLCBoZWFkZXJCaXRzKTtcbiAgICAgICAgICAgIC8vIENvbGxlY3QgZGF0YSB3aXRoaW4gdGhlIG1haW4gc2VnbWVudCwgc2VwYXJhdGVseSwgdG8gY291bnQgaXRzIHNpemUgaWYgbmVlZGVkLiBEb24ndCBhZGQgaXQgdG9cbiAgICAgICAgICAgIC8vIG1haW4gcGF5bG9hZCB5ZXQuXG4gICAgICAgICAgICBjb25zdCBkYXRhQml0cyA9IG5ldyBCaXRBcnJheSgpO1xuICAgICAgICAgICAgdGhpcy5hcHBlbmRCeXRlcyhjb250ZW50LCBtb2RlLCBkYXRhQml0cywgZW5jb2RpbmcpO1xuICAgICAgICAgICAgbGV0IHZlcnNpb247XG4gICAgICAgICAgICBpZiAoaGludHMgIT09IG51bGwgJiYgdW5kZWZpbmVkICE9PSBoaW50cy5nZXQoRW5jb2RlSGludFR5cGUkMS5RUl9WRVJTSU9OKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZlcnNpb25OdW1iZXIgPSBOdW1iZXIucGFyc2VJbnQoaGludHMuZ2V0KEVuY29kZUhpbnRUeXBlJDEuUVJfVkVSU0lPTikudG9TdHJpbmcoKSwgMTApO1xuICAgICAgICAgICAgICAgIHZlcnNpb24gPSBWZXJzaW9uJDEuZ2V0VmVyc2lvbkZvck51bWJlcih2ZXJzaW9uTnVtYmVyKTtcbiAgICAgICAgICAgICAgICBjb25zdCBiaXRzTmVlZGVkID0gdGhpcy5jYWxjdWxhdGVCaXRzTmVlZGVkKG1vZGUsIGhlYWRlckJpdHMsIGRhdGFCaXRzLCB2ZXJzaW9uKTtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMud2lsbEZpdChiaXRzTmVlZGVkLCB2ZXJzaW9uLCBlY0xldmVsKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgV3JpdGVyRXhjZXB0aW9uKCdEYXRhIHRvbyBiaWcgZm9yIHJlcXVlc3RlZCB2ZXJzaW9uJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmVyc2lvbiA9IHRoaXMucmVjb21tZW5kVmVyc2lvbihlY0xldmVsLCBtb2RlLCBoZWFkZXJCaXRzLCBkYXRhQml0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJBbmREYXRhQml0cyA9IG5ldyBCaXRBcnJheSgpO1xuICAgICAgICAgICAgaGVhZGVyQW5kRGF0YUJpdHMuYXBwZW5kQml0QXJyYXkoaGVhZGVyQml0cyk7XG4gICAgICAgICAgICAvLyBGaW5kIFwibGVuZ3RoXCIgb2YgbWFpbiBzZWdtZW50IGFuZCB3cml0ZSBpdFxuICAgICAgICAgICAgY29uc3QgbnVtTGV0dGVycyA9IG1vZGUgPT09IE1vZGUkMS5CWVRFID8gZGF0YUJpdHMuZ2V0U2l6ZUluQnl0ZXMoKSA6IGNvbnRlbnQubGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy5hcHBlbmRMZW5ndGhJbmZvKG51bUxldHRlcnMsIHZlcnNpb24sIG1vZGUsIGhlYWRlckFuZERhdGFCaXRzKTtcbiAgICAgICAgICAgIC8vIFB1dCBkYXRhIHRvZ2V0aGVyIGludG8gdGhlIG92ZXJhbGwgcGF5bG9hZFxuICAgICAgICAgICAgaGVhZGVyQW5kRGF0YUJpdHMuYXBwZW5kQml0QXJyYXkoZGF0YUJpdHMpO1xuICAgICAgICAgICAgY29uc3QgZWNCbG9ja3MgPSB2ZXJzaW9uLmdldEVDQmxvY2tzRm9yTGV2ZWwoZWNMZXZlbCk7XG4gICAgICAgICAgICBjb25zdCBudW1EYXRhQnl0ZXMgPSB2ZXJzaW9uLmdldFRvdGFsQ29kZXdvcmRzKCkgLSBlY0Jsb2Nrcy5nZXRUb3RhbEVDQ29kZXdvcmRzKCk7XG4gICAgICAgICAgICAvLyBUZXJtaW5hdGUgdGhlIGJpdHMgcHJvcGVybHkuXG4gICAgICAgICAgICB0aGlzLnRlcm1pbmF0ZUJpdHMobnVtRGF0YUJ5dGVzLCBoZWFkZXJBbmREYXRhQml0cyk7XG4gICAgICAgICAgICAvLyBJbnRlcmxlYXZlIGRhdGEgYml0cyB3aXRoIGVycm9yIGNvcnJlY3Rpb24gY29kZS5cbiAgICAgICAgICAgIGNvbnN0IGZpbmFsQml0cyA9IHRoaXMuaW50ZXJsZWF2ZVdpdGhFQ0J5dGVzKGhlYWRlckFuZERhdGFCaXRzLCB2ZXJzaW9uLmdldFRvdGFsQ29kZXdvcmRzKCksIG51bURhdGFCeXRlcywgZWNCbG9ja3MuZ2V0TnVtQmxvY2tzKCkpO1xuICAgICAgICAgICAgY29uc3QgcXJDb2RlID0gbmV3IFFSQ29kZSgpO1xuICAgICAgICAgICAgcXJDb2RlLnNldEVDTGV2ZWwoZWNMZXZlbCk7XG4gICAgICAgICAgICBxckNvZGUuc2V0TW9kZShtb2RlKTtcbiAgICAgICAgICAgIHFyQ29kZS5zZXRWZXJzaW9uKHZlcnNpb24pO1xuICAgICAgICAgICAgLy8gIENob29zZSB0aGUgbWFzayBwYXR0ZXJuIGFuZCBzZXQgdG8gXCJxckNvZGVcIi5cbiAgICAgICAgICAgIGNvbnN0IGRpbWVuc2lvbiA9IHZlcnNpb24uZ2V0RGltZW5zaW9uRm9yVmVyc2lvbigpO1xuICAgICAgICAgICAgY29uc3QgbWF0cml4ID0gbmV3IEJ5dGVNYXRyaXgoZGltZW5zaW9uLCBkaW1lbnNpb24pO1xuICAgICAgICAgICAgY29uc3QgbWFza1BhdHRlcm4gPSB0aGlzLmNob29zZU1hc2tQYXR0ZXJuKGZpbmFsQml0cywgZWNMZXZlbCwgdmVyc2lvbiwgbWF0cml4KTtcbiAgICAgICAgICAgIHFyQ29kZS5zZXRNYXNrUGF0dGVybihtYXNrUGF0dGVybik7XG4gICAgICAgICAgICAvLyBCdWlsZCB0aGUgbWF0cml4IGFuZCBzZXQgaXQgdG8gXCJxckNvZGVcIi5cbiAgICAgICAgICAgIE1hdHJpeFV0aWwuYnVpbGRNYXRyaXgoZmluYWxCaXRzLCBlY0xldmVsLCB2ZXJzaW9uLCBtYXNrUGF0dGVybiwgbWF0cml4KTtcbiAgICAgICAgICAgIHFyQ29kZS5zZXRNYXRyaXgobWF0cml4KTtcbiAgICAgICAgICAgIHJldHVybiBxckNvZGU7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlY2lkZXMgdGhlIHNtYWxsZXN0IHZlcnNpb24gb2YgUVIgY29kZSB0aGF0IHdpbGwgY29udGFpbiBhbGwgb2YgdGhlIHByb3ZpZGVkIGRhdGEuXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0aHJvd3MgV3JpdGVyRXhjZXB0aW9uIGlmIHRoZSBkYXRhIGNhbm5vdCBmaXQgaW4gYW55IHZlcnNpb25cbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyByZWNvbW1lbmRWZXJzaW9uKGVjTGV2ZWwsIG1vZGUsIGhlYWRlckJpdHMsIGRhdGFCaXRzKSB7XG4gICAgICAgICAgICAvLyBIYXJkIHBhcnQ6IG5lZWQgdG8ga25vdyB2ZXJzaW9uIHRvIGtub3cgaG93IG1hbnkgYml0cyBsZW5ndGggdGFrZXMuIEJ1dCBuZWVkIHRvIGtub3cgaG93IG1hbnlcbiAgICAgICAgICAgIC8vIGJpdHMgaXQgdGFrZXMgdG8ga25vdyB2ZXJzaW9uLiBGaXJzdCB3ZSB0YWtlIGEgZ3Vlc3MgYXQgdmVyc2lvbiBieSBhc3N1bWluZyB2ZXJzaW9uIHdpbGwgYmVcbiAgICAgICAgICAgIC8vIHRoZSBtaW5pbXVtLCAxOlxuICAgICAgICAgICAgY29uc3QgcHJvdmlzaW9uYWxCaXRzTmVlZGVkID0gdGhpcy5jYWxjdWxhdGVCaXRzTmVlZGVkKG1vZGUsIGhlYWRlckJpdHMsIGRhdGFCaXRzLCBWZXJzaW9uJDEuZ2V0VmVyc2lvbkZvck51bWJlcigxKSk7XG4gICAgICAgICAgICBjb25zdCBwcm92aXNpb25hbFZlcnNpb24gPSB0aGlzLmNob29zZVZlcnNpb24ocHJvdmlzaW9uYWxCaXRzTmVlZGVkLCBlY0xldmVsKTtcbiAgICAgICAgICAgIC8vIFVzZSB0aGF0IGd1ZXNzIHRvIGNhbGN1bGF0ZSB0aGUgcmlnaHQgdmVyc2lvbi4gSSBhbSBzdGlsbCBub3Qgc3VyZSB0aGlzIHdvcmtzIGluIDEwMCUgb2YgY2FzZXMuXG4gICAgICAgICAgICBjb25zdCBiaXRzTmVlZGVkID0gdGhpcy5jYWxjdWxhdGVCaXRzTmVlZGVkKG1vZGUsIGhlYWRlckJpdHMsIGRhdGFCaXRzLCBwcm92aXNpb25hbFZlcnNpb24pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hvb3NlVmVyc2lvbihiaXRzTmVlZGVkLCBlY0xldmVsKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgY2FsY3VsYXRlQml0c05lZWRlZChtb2RlLCBoZWFkZXJCaXRzLCBkYXRhQml0cywgdmVyc2lvbikge1xuICAgICAgICAgICAgcmV0dXJuIGhlYWRlckJpdHMuZ2V0U2l6ZSgpICsgbW9kZS5nZXRDaGFyYWN0ZXJDb3VudEJpdHModmVyc2lvbikgKyBkYXRhQml0cy5nZXRTaXplKCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gdGhlIGNvZGUgcG9pbnQgb2YgdGhlIHRhYmxlIHVzZWQgaW4gYWxwaGFudW1lcmljIG1vZGUgb3JcbiAgICAgICAgICogIC0xIGlmIHRoZXJlIGlzIG5vIGNvcnJlc3BvbmRpbmcgY29kZSBpbiB0aGUgdGFibGUuXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgZ2V0QWxwaGFudW1lcmljQ29kZShjb2RlIC8qaW50Ki8pIHtcbiAgICAgICAgICAgIGlmIChjb2RlIDwgRW5jb2Rlci5BTFBIQU5VTUVSSUNfVEFCTEUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEVuY29kZXIuQUxQSEFOVU1FUklDX1RBQkxFW2NvZGVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIC8vIHB1YmxpYyBzdGF0aWMgY2hvb3NlTW9kZShjb250ZW50OiBzdHJpbmcpOiBNb2RlIHtcbiAgICAgICAgLy8gICByZXR1cm4gY2hvb3NlTW9kZShjb250ZW50LCBudWxsKTtcbiAgICAgICAgLy8gfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ2hvb3NlIHRoZSBiZXN0IG1vZGUgYnkgZXhhbWluaW5nIHRoZSBjb250ZW50LiBOb3RlIHRoYXQgJ2VuY29kaW5nJyBpcyB1c2VkIGFzIGEgaGludDtcbiAgICAgICAgICogaWYgaXQgaXMgU2hpZnRfSklTLCBhbmQgdGhlIGlucHV0IGlzIG9ubHkgZG91YmxlLWJ5dGUgS2FuamksIHRoZW4gd2UgcmV0dXJuIHtAbGluayBNb2RlI0tBTkpJfS5cbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBjaG9vc2VNb2RlKGNvbnRlbnQsIGVuY29kaW5nID0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKENoYXJhY3RlclNldEVDSS5TSklTLmdldE5hbWUoKSA9PT0gZW5jb2RpbmcgJiYgdGhpcy5pc09ubHlEb3VibGVCeXRlS2FuamkoY29udGVudCkpIHtcbiAgICAgICAgICAgICAgICAvLyBDaG9vc2UgS2FuamkgbW9kZSBpZiBhbGwgaW5wdXQgYXJlIGRvdWJsZS1ieXRlIGNoYXJhY3RlcnNcbiAgICAgICAgICAgICAgICByZXR1cm4gTW9kZSQxLktBTkpJO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGhhc051bWVyaWMgPSBmYWxzZTtcbiAgICAgICAgICAgIGxldCBoYXNBbHBoYW51bWVyaWMgPSBmYWxzZTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW5ndGggPSBjb250ZW50Lmxlbmd0aDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYyA9IGNvbnRlbnQuY2hhckF0KGkpO1xuICAgICAgICAgICAgICAgIGlmIChFbmNvZGVyLmlzRGlnaXQoYykpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFzTnVtZXJpYyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuZ2V0QWxwaGFudW1lcmljQ29kZShjLmNoYXJDb2RlQXQoMCkpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBoYXNBbHBoYW51bWVyaWMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE1vZGUkMS5CWVRFO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoYXNBbHBoYW51bWVyaWMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTW9kZSQxLkFMUEhBTlVNRVJJQztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoYXNOdW1lcmljKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE1vZGUkMS5OVU1FUklDO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIE1vZGUkMS5CWVRFO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBpc09ubHlEb3VibGVCeXRlS2FuamkoY29udGVudCkge1xuICAgICAgICAgICAgbGV0IGJ5dGVzO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBieXRlcyA9IFN0cmluZ0VuY29kaW5nLmVuY29kZShjb250ZW50LCBDaGFyYWN0ZXJTZXRFQ0kuU0pJUyk7IC8vIGNvbnRlbnQuZ2V0Qnl0ZXMoXCJTaGlmdF9KSVNcIikpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoaWdub3JlZCAvKjogVW5zdXBwb3J0ZWRFbmNvZGluZ0V4Y2VwdGlvbiovKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gYnl0ZXMubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGxlbmd0aCAlIDIgIT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYnl0ZTEgPSBieXRlc1tpXSAmIDB4RkY7XG4gICAgICAgICAgICAgICAgaWYgKChieXRlMSA8IDB4ODEgfHwgYnl0ZTEgPiAweDlGKSAmJiAoYnl0ZTEgPCAweEUwIHx8IGJ5dGUxID4gMHhFQikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBjaG9vc2VNYXNrUGF0dGVybihiaXRzLCBlY0xldmVsLCB2ZXJzaW9uLCBtYXRyaXgpIHtcbiAgICAgICAgICAgIGxldCBtaW5QZW5hbHR5ID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7IC8vIExvd2VyIHBlbmFsdHkgaXMgYmV0dGVyLlxuICAgICAgICAgICAgbGV0IGJlc3RNYXNrUGF0dGVybiA9IC0xO1xuICAgICAgICAgICAgLy8gV2UgdHJ5IGFsbCBtYXNrIHBhdHRlcm5zIHRvIGNob29zZSB0aGUgYmVzdCBvbmUuXG4gICAgICAgICAgICBmb3IgKGxldCBtYXNrUGF0dGVybiA9IDA7IG1hc2tQYXR0ZXJuIDwgUVJDb2RlLk5VTV9NQVNLX1BBVFRFUk5TOyBtYXNrUGF0dGVybisrKSB7XG4gICAgICAgICAgICAgICAgTWF0cml4VXRpbC5idWlsZE1hdHJpeChiaXRzLCBlY0xldmVsLCB2ZXJzaW9uLCBtYXNrUGF0dGVybiwgbWF0cml4KTtcbiAgICAgICAgICAgICAgICBsZXQgcGVuYWx0eSA9IHRoaXMuY2FsY3VsYXRlTWFza1BlbmFsdHkobWF0cml4KTtcbiAgICAgICAgICAgICAgICBpZiAocGVuYWx0eSA8IG1pblBlbmFsdHkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWluUGVuYWx0eSA9IHBlbmFsdHk7XG4gICAgICAgICAgICAgICAgICAgIGJlc3RNYXNrUGF0dGVybiA9IG1hc2tQYXR0ZXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBiZXN0TWFza1BhdHRlcm47XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGNob29zZVZlcnNpb24obnVtSW5wdXRCaXRzIC8qaW50Ki8sIGVjTGV2ZWwpIHtcbiAgICAgICAgICAgIGZvciAobGV0IHZlcnNpb25OdW0gPSAxOyB2ZXJzaW9uTnVtIDw9IDQwOyB2ZXJzaW9uTnVtKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2ZXJzaW9uID0gVmVyc2lvbiQxLmdldFZlcnNpb25Gb3JOdW1iZXIodmVyc2lvbk51bSk7XG4gICAgICAgICAgICAgICAgaWYgKEVuY29kZXIud2lsbEZpdChudW1JbnB1dEJpdHMsIHZlcnNpb24sIGVjTGV2ZWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2ZXJzaW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBXcml0ZXJFeGNlcHRpb24oJ0RhdGEgdG9vIGJpZycpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHRydWUgaWYgdGhlIG51bWJlciBvZiBpbnB1dCBiaXRzIHdpbGwgZml0IGluIGEgY29kZSB3aXRoIHRoZSBzcGVjaWZpZWQgdmVyc2lvbiBhbmRcbiAgICAgICAgICogZXJyb3IgY29ycmVjdGlvbiBsZXZlbC5cbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyB3aWxsRml0KG51bUlucHV0Qml0cyAvKmludCovLCB2ZXJzaW9uLCBlY0xldmVsKSB7XG4gICAgICAgICAgICAvLyBJbiB0aGUgZm9sbG93aW5nIGNvbW1lbnRzLCB3ZSB1c2UgbnVtYmVycyBvZiBWZXJzaW9uIDctSC5cbiAgICAgICAgICAgIC8vIG51bUJ5dGVzID0gMTk2XG4gICAgICAgICAgICBjb25zdCBudW1CeXRlcyA9IHZlcnNpb24uZ2V0VG90YWxDb2Rld29yZHMoKTtcbiAgICAgICAgICAgIC8vIGdldE51bUVDQnl0ZXMgPSAxMzBcbiAgICAgICAgICAgIGNvbnN0IGVjQmxvY2tzID0gdmVyc2lvbi5nZXRFQ0Jsb2Nrc0ZvckxldmVsKGVjTGV2ZWwpO1xuICAgICAgICAgICAgY29uc3QgbnVtRWNCeXRlcyA9IGVjQmxvY2tzLmdldFRvdGFsRUNDb2Rld29yZHMoKTtcbiAgICAgICAgICAgIC8vIGdldE51bURhdGFCeXRlcyA9IDE5NiAtIDEzMCA9IDY2XG4gICAgICAgICAgICBjb25zdCBudW1EYXRhQnl0ZXMgPSBudW1CeXRlcyAtIG51bUVjQnl0ZXM7XG4gICAgICAgICAgICBjb25zdCB0b3RhbElucHV0Qnl0ZXMgPSAobnVtSW5wdXRCaXRzICsgNykgLyA4O1xuICAgICAgICAgICAgcmV0dXJuIG51bURhdGFCeXRlcyA+PSB0b3RhbElucHV0Qnl0ZXM7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRlcm1pbmF0ZSBiaXRzIGFzIGRlc2NyaWJlZCBpbiA4LjQuOCBhbmQgOC40Ljkgb2YgSklTWDA1MTA6MjAwNCAocC4yNCkuXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgdGVybWluYXRlQml0cyhudW1EYXRhQnl0ZXMgLyppbnQqLywgYml0cykge1xuICAgICAgICAgICAgY29uc3QgY2FwYWNpdHkgPSBudW1EYXRhQnl0ZXMgKiA4O1xuICAgICAgICAgICAgaWYgKGJpdHMuZ2V0U2l6ZSgpID4gY2FwYWNpdHkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgV3JpdGVyRXhjZXB0aW9uKCdkYXRhIGJpdHMgY2Fubm90IGZpdCBpbiB0aGUgUVIgQ29kZScgKyBiaXRzLmdldFNpemUoKSArICcgPiAnICtcbiAgICAgICAgICAgICAgICAgICAgY2FwYWNpdHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA0ICYmIGJpdHMuZ2V0U2l6ZSgpIDwgY2FwYWNpdHk7ICsraSkge1xuICAgICAgICAgICAgICAgIGJpdHMuYXBwZW5kQml0KGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEFwcGVuZCB0ZXJtaW5hdGlvbiBiaXRzLiBTZWUgOC40Ljggb2YgSklTWDA1MTA6MjAwNCAocC4yNCkgZm9yIGRldGFpbHMuXG4gICAgICAgICAgICAvLyBJZiB0aGUgbGFzdCBieXRlIGlzbid0IDgtYml0IGFsaWduZWQsIHdlJ2xsIGFkZCBwYWRkaW5nIGJpdHMuXG4gICAgICAgICAgICBjb25zdCBudW1CaXRzSW5MYXN0Qnl0ZSA9IGJpdHMuZ2V0U2l6ZSgpICYgMHgwNztcbiAgICAgICAgICAgIGlmIChudW1CaXRzSW5MYXN0Qnl0ZSA+IDApIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gbnVtQml0c0luTGFzdEJ5dGU7IGkgPCA4OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYml0cy5hcHBlbmRCaXQoZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgbW9yZSBzcGFjZSwgd2UnbGwgZmlsbCB0aGUgc3BhY2Ugd2l0aCBwYWRkaW5nIHBhdHRlcm5zIGRlZmluZWQgaW4gOC40LjkgKHAuMjQpLlxuICAgICAgICAgICAgY29uc3QgbnVtUGFkZGluZ0J5dGVzID0gbnVtRGF0YUJ5dGVzIC0gYml0cy5nZXRTaXplSW5CeXRlcygpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1QYWRkaW5nQnl0ZXM7ICsraSkge1xuICAgICAgICAgICAgICAgIGJpdHMuYXBwZW5kQml0cygoaSAmIDB4MDEpID09PSAwID8gMHhFQyA6IDB4MTEsIDgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGJpdHMuZ2V0U2l6ZSgpICE9PSBjYXBhY2l0eSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBXcml0ZXJFeGNlcHRpb24oJ0JpdHMgc2l6ZSBkb2VzIG5vdCBlcXVhbCBjYXBhY2l0eScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgbnVtYmVyIG9mIGRhdGEgYnl0ZXMgYW5kIG51bWJlciBvZiBlcnJvciBjb3JyZWN0aW9uIGJ5dGVzIGZvciBibG9jayBpZCBcImJsb2NrSURcIi4gU3RvcmVcbiAgICAgICAgICogdGhlIHJlc3VsdCBpbiBcIm51bURhdGFCeXRlc0luQmxvY2tcIiwgYW5kIFwibnVtRUNCeXRlc0luQmxvY2tcIi4gU2VlIHRhYmxlIDEyIGluIDguNS4xIG9mXG4gICAgICAgICAqIEpJU1gwNTEwOjIwMDQgKHAuMzApXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgZ2V0TnVtRGF0YUJ5dGVzQW5kTnVtRUNCeXRlc0ZvckJsb2NrSUQobnVtVG90YWxCeXRlcyAvKmludCovLCBudW1EYXRhQnl0ZXMgLyppbnQqLywgbnVtUlNCbG9ja3MgLyppbnQqLywgYmxvY2tJRCAvKmludCovLCBudW1EYXRhQnl0ZXNJbkJsb2NrLCBudW1FQ0J5dGVzSW5CbG9jaykge1xuICAgICAgICAgICAgaWYgKGJsb2NrSUQgPj0gbnVtUlNCbG9ja3MpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgV3JpdGVyRXhjZXB0aW9uKCdCbG9jayBJRCB0b28gbGFyZ2UnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIG51bVJzQmxvY2tzSW5Hcm91cDIgPSAxOTYgJSA1ID0gMVxuICAgICAgICAgICAgY29uc3QgbnVtUnNCbG9ja3NJbkdyb3VwMiA9IG51bVRvdGFsQnl0ZXMgJSBudW1SU0Jsb2NrcztcbiAgICAgICAgICAgIC8vIG51bVJzQmxvY2tzSW5Hcm91cDEgPSA1IC0gMSA9IDRcbiAgICAgICAgICAgIGNvbnN0IG51bVJzQmxvY2tzSW5Hcm91cDEgPSBudW1SU0Jsb2NrcyAtIG51bVJzQmxvY2tzSW5Hcm91cDI7XG4gICAgICAgICAgICAvLyBudW1Ub3RhbEJ5dGVzSW5Hcm91cDEgPSAxOTYgLyA1ID0gMzlcbiAgICAgICAgICAgIGNvbnN0IG51bVRvdGFsQnl0ZXNJbkdyb3VwMSA9IE1hdGguZmxvb3IobnVtVG90YWxCeXRlcyAvIG51bVJTQmxvY2tzKTtcbiAgICAgICAgICAgIC8vIG51bVRvdGFsQnl0ZXNJbkdyb3VwMiA9IDM5ICsgMSA9IDQwXG4gICAgICAgICAgICBjb25zdCBudW1Ub3RhbEJ5dGVzSW5Hcm91cDIgPSBudW1Ub3RhbEJ5dGVzSW5Hcm91cDEgKyAxO1xuICAgICAgICAgICAgLy8gbnVtRGF0YUJ5dGVzSW5Hcm91cDEgPSA2NiAvIDUgPSAxM1xuICAgICAgICAgICAgY29uc3QgbnVtRGF0YUJ5dGVzSW5Hcm91cDEgPSBNYXRoLmZsb29yKG51bURhdGFCeXRlcyAvIG51bVJTQmxvY2tzKTtcbiAgICAgICAgICAgIC8vIG51bURhdGFCeXRlc0luR3JvdXAyID0gMTMgKyAxID0gMTRcbiAgICAgICAgICAgIGNvbnN0IG51bURhdGFCeXRlc0luR3JvdXAyID0gbnVtRGF0YUJ5dGVzSW5Hcm91cDEgKyAxO1xuICAgICAgICAgICAgLy8gbnVtRWNCeXRlc0luR3JvdXAxID0gMzkgLSAxMyA9IDI2XG4gICAgICAgICAgICBjb25zdCBudW1FY0J5dGVzSW5Hcm91cDEgPSBudW1Ub3RhbEJ5dGVzSW5Hcm91cDEgLSBudW1EYXRhQnl0ZXNJbkdyb3VwMTtcbiAgICAgICAgICAgIC8vIG51bUVjQnl0ZXNJbkdyb3VwMiA9IDQwIC0gMTQgPSAyNlxuICAgICAgICAgICAgY29uc3QgbnVtRWNCeXRlc0luR3JvdXAyID0gbnVtVG90YWxCeXRlc0luR3JvdXAyIC0gbnVtRGF0YUJ5dGVzSW5Hcm91cDI7XG4gICAgICAgICAgICAvLyBTYW5pdHkgY2hlY2tzLlxuICAgICAgICAgICAgLy8gMjYgPSAyNlxuICAgICAgICAgICAgaWYgKG51bUVjQnl0ZXNJbkdyb3VwMSAhPT0gbnVtRWNCeXRlc0luR3JvdXAyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFdyaXRlckV4Y2VwdGlvbignRUMgYnl0ZXMgbWlzbWF0Y2gnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIDUgPSA0ICsgMS5cbiAgICAgICAgICAgIGlmIChudW1SU0Jsb2NrcyAhPT0gbnVtUnNCbG9ja3NJbkdyb3VwMSArIG51bVJzQmxvY2tzSW5Hcm91cDIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgV3JpdGVyRXhjZXB0aW9uKCdSUyBibG9ja3MgbWlzbWF0Y2gnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIDE5NiA9ICgxMyArIDI2KSAqIDQgKyAoMTQgKyAyNikgKiAxXG4gICAgICAgICAgICBpZiAobnVtVG90YWxCeXRlcyAhPT1cbiAgICAgICAgICAgICAgICAoKG51bURhdGFCeXRlc0luR3JvdXAxICsgbnVtRWNCeXRlc0luR3JvdXAxKSAqXG4gICAgICAgICAgICAgICAgICAgIG51bVJzQmxvY2tzSW5Hcm91cDEpICtcbiAgICAgICAgICAgICAgICAgICAgKChudW1EYXRhQnl0ZXNJbkdyb3VwMiArIG51bUVjQnl0ZXNJbkdyb3VwMikgKlxuICAgICAgICAgICAgICAgICAgICAgICAgbnVtUnNCbG9ja3NJbkdyb3VwMikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgV3JpdGVyRXhjZXB0aW9uKCdUb3RhbCBieXRlcyBtaXNtYXRjaCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGJsb2NrSUQgPCBudW1Sc0Jsb2Nrc0luR3JvdXAxKSB7XG4gICAgICAgICAgICAgICAgbnVtRGF0YUJ5dGVzSW5CbG9ja1swXSA9IG51bURhdGFCeXRlc0luR3JvdXAxO1xuICAgICAgICAgICAgICAgIG51bUVDQnl0ZXNJbkJsb2NrWzBdID0gbnVtRWNCeXRlc0luR3JvdXAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbnVtRGF0YUJ5dGVzSW5CbG9ja1swXSA9IG51bURhdGFCeXRlc0luR3JvdXAyO1xuICAgICAgICAgICAgICAgIG51bUVDQnl0ZXNJbkJsb2NrWzBdID0gbnVtRWNCeXRlc0luR3JvdXAyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnRlcmxlYXZlIFwiYml0c1wiIHdpdGggY29ycmVzcG9uZGluZyBlcnJvciBjb3JyZWN0aW9uIGJ5dGVzLiBPbiBzdWNjZXNzLCBzdG9yZSB0aGUgcmVzdWx0IGluXG4gICAgICAgICAqIFwicmVzdWx0XCIuIFRoZSBpbnRlcmxlYXZlIHJ1bGUgaXMgY29tcGxpY2F0ZWQuIFNlZSA4LjYgb2YgSklTWDA1MTA6MjAwNCAocC4zNykgZm9yIGRldGFpbHMuXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgaW50ZXJsZWF2ZVdpdGhFQ0J5dGVzKGJpdHMsIG51bVRvdGFsQnl0ZXMgLyppbnQqLywgbnVtRGF0YUJ5dGVzIC8qaW50Ki8sIG51bVJTQmxvY2tzIC8qaW50Ki8pIHtcbiAgICAgICAgICAgIC8vIFwiYml0c1wiIG11c3QgaGF2ZSBcImdldE51bURhdGFCeXRlc1wiIGJ5dGVzIG9mIGRhdGEuXG4gICAgICAgICAgICBpZiAoYml0cy5nZXRTaXplSW5CeXRlcygpICE9PSBudW1EYXRhQnl0ZXMpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgV3JpdGVyRXhjZXB0aW9uKCdOdW1iZXIgb2YgYml0cyBhbmQgZGF0YSBieXRlcyBkb2VzIG5vdCBtYXRjaCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU3RlcCAxLiAgRGl2aWRlIGRhdGEgYnl0ZXMgaW50byBibG9ja3MgYW5kIGdlbmVyYXRlIGVycm9yIGNvcnJlY3Rpb24gYnl0ZXMgZm9yIHRoZW0uIFdlJ2xsXG4gICAgICAgICAgICAvLyBzdG9yZSB0aGUgZGl2aWRlZCBkYXRhIGJ5dGVzIGJsb2NrcyBhbmQgZXJyb3IgY29ycmVjdGlvbiBieXRlcyBibG9ja3MgaW50byBcImJsb2Nrc1wiLlxuICAgICAgICAgICAgbGV0IGRhdGFCeXRlc09mZnNldCA9IDA7XG4gICAgICAgICAgICBsZXQgbWF4TnVtRGF0YUJ5dGVzID0gMDtcbiAgICAgICAgICAgIGxldCBtYXhOdW1FY0J5dGVzID0gMDtcbiAgICAgICAgICAgIC8vIFNpbmNlLCB3ZSBrbm93IHRoZSBudW1iZXIgb2YgcmVlZHNvbG1vbiBibG9ja3MsIHdlIGNhbiBpbml0aWFsaXplIHRoZSB2ZWN0b3Igd2l0aCB0aGUgbnVtYmVyLlxuICAgICAgICAgICAgY29uc3QgYmxvY2tzID0gbmV3IEFycmF5KCk7IC8vIG5ldyBBcnJheTxCbG9ja1BhaXI+KG51bVJTQmxvY2tzKVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1SU0Jsb2NrczsgKytpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbnVtRGF0YUJ5dGVzSW5CbG9jayA9IG5ldyBJbnQzMkFycmF5KDEpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG51bUVjQnl0ZXNJbkJsb2NrID0gbmV3IEludDMyQXJyYXkoMSk7XG4gICAgICAgICAgICAgICAgRW5jb2Rlci5nZXROdW1EYXRhQnl0ZXNBbmROdW1FQ0J5dGVzRm9yQmxvY2tJRChudW1Ub3RhbEJ5dGVzLCBudW1EYXRhQnl0ZXMsIG51bVJTQmxvY2tzLCBpLCBudW1EYXRhQnl0ZXNJbkJsb2NrLCBudW1FY0J5dGVzSW5CbG9jayk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2l6ZSA9IG51bURhdGFCeXRlc0luQmxvY2tbMF07XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YUJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoc2l6ZSk7XG4gICAgICAgICAgICAgICAgYml0cy50b0J5dGVzKDggKiBkYXRhQnl0ZXNPZmZzZXQsIGRhdGFCeXRlcywgMCwgc2l6ZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgZWNCeXRlcyA9IEVuY29kZXIuZ2VuZXJhdGVFQ0J5dGVzKGRhdGFCeXRlcywgbnVtRWNCeXRlc0luQmxvY2tbMF0pO1xuICAgICAgICAgICAgICAgIGJsb2Nrcy5wdXNoKG5ldyBCbG9ja1BhaXIoZGF0YUJ5dGVzLCBlY0J5dGVzKSk7XG4gICAgICAgICAgICAgICAgbWF4TnVtRGF0YUJ5dGVzID0gTWF0aC5tYXgobWF4TnVtRGF0YUJ5dGVzLCBzaXplKTtcbiAgICAgICAgICAgICAgICBtYXhOdW1FY0J5dGVzID0gTWF0aC5tYXgobWF4TnVtRWNCeXRlcywgZWNCeXRlcy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGRhdGFCeXRlc09mZnNldCArPSBudW1EYXRhQnl0ZXNJbkJsb2NrWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG51bURhdGFCeXRlcyAhPT0gZGF0YUJ5dGVzT2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFdyaXRlckV4Y2VwdGlvbignRGF0YSBieXRlcyBkb2VzIG5vdCBtYXRjaCBvZmZzZXQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBCaXRBcnJheSgpO1xuICAgICAgICAgICAgLy8gRmlyc3QsIHBsYWNlIGRhdGEgYmxvY2tzLlxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXhOdW1EYXRhQnl0ZXM7ICsraSkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgYmxvY2sgb2YgYmxvY2tzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGFCeXRlcyA9IGJsb2NrLmdldERhdGFCeXRlcygpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSA8IGRhdGFCeXRlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmRCaXRzKGRhdGFCeXRlc1tpXSwgOCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUaGVuLCBwbGFjZSBlcnJvciBjb3JyZWN0aW9uIGJsb2Nrcy5cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF4TnVtRWNCeXRlczsgKytpKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBibG9jayBvZiBibG9ja3MpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZWNCeXRlcyA9IGJsb2NrLmdldEVycm9yQ29ycmVjdGlvbkJ5dGVzKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpIDwgZWNCeXRlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmRCaXRzKGVjQnl0ZXNbaV0sIDgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG51bVRvdGFsQnl0ZXMgIT09IHJlc3VsdC5nZXRTaXplSW5CeXRlcygpKSB7IC8vIFNob3VsZCBiZSBzYW1lLlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBXcml0ZXJFeGNlcHRpb24oJ0ludGVybGVhdmluZyBlcnJvcjogJyArIG51bVRvdGFsQnl0ZXMgKyAnIGFuZCAnICtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmdldFNpemVJbkJ5dGVzKCkgKyAnIGRpZmZlci4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGdlbmVyYXRlRUNCeXRlcyhkYXRhQnl0ZXMsIG51bUVjQnl0ZXNJbkJsb2NrIC8qaW50Ki8pIHtcbiAgICAgICAgICAgIGNvbnN0IG51bURhdGFCeXRlcyA9IGRhdGFCeXRlcy5sZW5ndGg7XG4gICAgICAgICAgICBjb25zdCB0b0VuY29kZSA9IG5ldyBJbnQzMkFycmF5KG51bURhdGFCeXRlcyArIG51bUVjQnl0ZXNJbkJsb2NrKTsgLy8gaW50W251bURhdGFCeXRlcyArIG51bUVjQnl0ZXNJbkJsb2NrXVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1EYXRhQnl0ZXM7IGkrKykge1xuICAgICAgICAgICAgICAgIHRvRW5jb2RlW2ldID0gZGF0YUJ5dGVzW2ldICYgMHhGRjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5ldyBSZWVkU29sb21vbkVuY29kZXIoR2VuZXJpY0dGLlFSX0NPREVfRklFTERfMjU2KS5lbmNvZGUodG9FbmNvZGUsIG51bUVjQnl0ZXNJbkJsb2NrKTtcbiAgICAgICAgICAgIGNvbnN0IGVjQnl0ZXMgPSBuZXcgVWludDhBcnJheShudW1FY0J5dGVzSW5CbG9jayk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUVjQnl0ZXNJbkJsb2NrOyBpKyspIHtcbiAgICAgICAgICAgICAgICBlY0J5dGVzW2ldID0gLyooYnl0ZSkgKi8gdG9FbmNvZGVbbnVtRGF0YUJ5dGVzICsgaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZWNCeXRlcztcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQXBwZW5kIG1vZGUgaW5mby4gT24gc3VjY2Vzcywgc3RvcmUgdGhlIHJlc3VsdCBpbiBcImJpdHNcIi5cbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBhcHBlbmRNb2RlSW5mbyhtb2RlLCBiaXRzKSB7XG4gICAgICAgICAgICBiaXRzLmFwcGVuZEJpdHMobW9kZS5nZXRCaXRzKCksIDQpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBcHBlbmQgbGVuZ3RoIGluZm8uIE9uIHN1Y2Nlc3MsIHN0b3JlIHRoZSByZXN1bHQgaW4gXCJiaXRzXCIuXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgYXBwZW5kTGVuZ3RoSW5mbyhudW1MZXR0ZXJzIC8qaW50Ki8sIHZlcnNpb24sIG1vZGUsIGJpdHMpIHtcbiAgICAgICAgICAgIGNvbnN0IG51bUJpdHMgPSBtb2RlLmdldENoYXJhY3RlckNvdW50Qml0cyh2ZXJzaW9uKTtcbiAgICAgICAgICAgIGlmIChudW1MZXR0ZXJzID49ICgxIDw8IG51bUJpdHMpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFdyaXRlckV4Y2VwdGlvbihudW1MZXR0ZXJzICsgJyBpcyBiaWdnZXIgdGhhbiAnICsgKCgxIDw8IG51bUJpdHMpIC0gMSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYml0cy5hcHBlbmRCaXRzKG51bUxldHRlcnMsIG51bUJpdHMpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBcHBlbmQgXCJieXRlc1wiIGluIFwibW9kZVwiIG1vZGUgKGVuY29kaW5nKSBpbnRvIFwiYml0c1wiLiBPbiBzdWNjZXNzLCBzdG9yZSB0aGUgcmVzdWx0IGluIFwiYml0c1wiLlxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGFwcGVuZEJ5dGVzKGNvbnRlbnQsIG1vZGUsIGJpdHMsIGVuY29kaW5nKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKG1vZGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIE1vZGUkMS5OVU1FUklDOlxuICAgICAgICAgICAgICAgICAgICBFbmNvZGVyLmFwcGVuZE51bWVyaWNCeXRlcyhjb250ZW50LCBiaXRzKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBNb2RlJDEuQUxQSEFOVU1FUklDOlxuICAgICAgICAgICAgICAgICAgICBFbmNvZGVyLmFwcGVuZEFscGhhbnVtZXJpY0J5dGVzKGNvbnRlbnQsIGJpdHMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIE1vZGUkMS5CWVRFOlxuICAgICAgICAgICAgICAgICAgICBFbmNvZGVyLmFwcGVuZDhCaXRCeXRlcyhjb250ZW50LCBiaXRzLCBlbmNvZGluZyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgTW9kZSQxLktBTkpJOlxuICAgICAgICAgICAgICAgICAgICBFbmNvZGVyLmFwcGVuZEthbmppQnl0ZXMoY29udGVudCwgYml0cyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBXcml0ZXJFeGNlcHRpb24oJ0ludmFsaWQgbW9kZTogJyArIG1vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBnZXREaWdpdChzaW5nbGVDaGFyYWN0ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBzaW5nbGVDaGFyYWN0ZXIuY2hhckNvZGVBdCgwKSAtIDQ4O1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBpc0RpZ2l0KHNpbmdsZUNoYXJhY3Rlcikge1xuICAgICAgICAgICAgY29uc3QgY24gPSBFbmNvZGVyLmdldERpZ2l0KHNpbmdsZUNoYXJhY3Rlcik7XG4gICAgICAgICAgICByZXR1cm4gY24gPj0gMCAmJiBjbiA8PSA5O1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBhcHBlbmROdW1lcmljQnl0ZXMoY29udGVudCwgYml0cykge1xuICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gY29udGVudC5sZW5ndGg7XG4gICAgICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgICAgICB3aGlsZSAoaSA8IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG51bTEgPSBFbmNvZGVyLmdldERpZ2l0KGNvbnRlbnQuY2hhckF0KGkpKTtcbiAgICAgICAgICAgICAgICBpZiAoaSArIDIgPCBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRW5jb2RlIHRocmVlIG51bWVyaWMgbGV0dGVycyBpbiB0ZW4gYml0cy5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbnVtMiA9IEVuY29kZXIuZ2V0RGlnaXQoY29udGVudC5jaGFyQXQoaSArIDEpKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbnVtMyA9IEVuY29kZXIuZ2V0RGlnaXQoY29udGVudC5jaGFyQXQoaSArIDIpKTtcbiAgICAgICAgICAgICAgICAgICAgYml0cy5hcHBlbmRCaXRzKG51bTEgKiAxMDAgKyBudW0yICogMTAgKyBudW0zLCAxMCk7XG4gICAgICAgICAgICAgICAgICAgIGkgKz0gMztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaSArIDEgPCBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRW5jb2RlIHR3byBudW1lcmljIGxldHRlcnMgaW4gc2V2ZW4gYml0cy5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbnVtMiA9IEVuY29kZXIuZ2V0RGlnaXQoY29udGVudC5jaGFyQXQoaSArIDEpKTtcbiAgICAgICAgICAgICAgICAgICAgYml0cy5hcHBlbmRCaXRzKG51bTEgKiAxMCArIG51bTIsIDcpO1xuICAgICAgICAgICAgICAgICAgICBpICs9IDI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBFbmNvZGUgb25lIG51bWVyaWMgbGV0dGVyIGluIGZvdXIgYml0cy5cbiAgICAgICAgICAgICAgICAgICAgYml0cy5hcHBlbmRCaXRzKG51bTEsIDQpO1xuICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBhcHBlbmRBbHBoYW51bWVyaWNCeXRlcyhjb250ZW50LCBiaXRzKSB7XG4gICAgICAgICAgICBjb25zdCBsZW5ndGggPSBjb250ZW50Lmxlbmd0aDtcbiAgICAgICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgICAgIHdoaWxlIChpIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29kZTEgPSBFbmNvZGVyLmdldEFscGhhbnVtZXJpY0NvZGUoY29udGVudC5jaGFyQ29kZUF0KGkpKTtcbiAgICAgICAgICAgICAgICBpZiAoY29kZTEgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBXcml0ZXJFeGNlcHRpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGkgKyAxIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvZGUyID0gRW5jb2Rlci5nZXRBbHBoYW51bWVyaWNDb2RlKGNvbnRlbnQuY2hhckNvZGVBdChpICsgMSkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29kZTIgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgV3JpdGVyRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gRW5jb2RlIHR3byBhbHBoYW51bWVyaWMgbGV0dGVycyBpbiAxMSBiaXRzLlxuICAgICAgICAgICAgICAgICAgICBiaXRzLmFwcGVuZEJpdHMoY29kZTEgKiA0NSArIGNvZGUyLCAxMSk7XG4gICAgICAgICAgICAgICAgICAgIGkgKz0gMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEVuY29kZSBvbmUgYWxwaGFudW1lcmljIGxldHRlciBpbiBzaXggYml0cy5cbiAgICAgICAgICAgICAgICAgICAgYml0cy5hcHBlbmRCaXRzKGNvZGUxLCA2KTtcbiAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgYXBwZW5kOEJpdEJ5dGVzKGNvbnRlbnQsIGJpdHMsIGVuY29kaW5nKSB7XG4gICAgICAgICAgICBsZXQgYnl0ZXM7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGJ5dGVzID0gU3RyaW5nRW5jb2RpbmcuZW5jb2RlKGNvbnRlbnQsIGVuY29kaW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoICh1ZWUgLyo6IFVuc3VwcG9ydGVkRW5jb2RpbmdFeGNlcHRpb24qLykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBXcml0ZXJFeGNlcHRpb24odWVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW5ndGggPSBieXRlcy5sZW5ndGg7IGkgIT09IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYiA9IGJ5dGVzW2ldO1xuICAgICAgICAgICAgICAgIGJpdHMuYXBwZW5kQml0cyhiLCA4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHRocm93cyBXcml0ZXJFeGNlcHRpb25cbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBhcHBlbmRLYW5qaUJ5dGVzKGNvbnRlbnQsIGJpdHMpIHtcbiAgICAgICAgICAgIGxldCBieXRlcztcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYnl0ZXMgPSBTdHJpbmdFbmNvZGluZy5lbmNvZGUoY29udGVudCwgQ2hhcmFjdGVyU2V0RUNJLlNKSVMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKHVlZSAvKjogVW5zdXBwb3J0ZWRFbmNvZGluZ0V4Y2VwdGlvbiovKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFdyaXRlckV4Y2VwdGlvbih1ZWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gYnl0ZXMubGVuZ3RoO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJ5dGUxID0gYnl0ZXNbaV0gJiAweEZGO1xuICAgICAgICAgICAgICAgIGNvbnN0IGJ5dGUyID0gYnl0ZXNbaSArIDFdICYgMHhGRjtcbiAgICAgICAgICAgICAgICBjb25zdCBjb2RlID0gKChieXRlMSA8PCA4KSAmIDB4RkZGRkZGRkYpIHwgYnl0ZTI7XG4gICAgICAgICAgICAgICAgbGV0IHN1YnRyYWN0ZWQgPSAtMTtcbiAgICAgICAgICAgICAgICBpZiAoY29kZSA+PSAweDgxNDAgJiYgY29kZSA8PSAweDlmZmMpIHtcbiAgICAgICAgICAgICAgICAgICAgc3VidHJhY3RlZCA9IGNvZGUgLSAweDgxNDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNvZGUgPj0gMHhlMDQwICYmIGNvZGUgPD0gMHhlYmJmKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1YnRyYWN0ZWQgPSBjb2RlIC0gMHhjMTQwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc3VidHJhY3RlZCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFdyaXRlckV4Y2VwdGlvbignSW52YWxpZCBieXRlIHNlcXVlbmNlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGVuY29kZWQgPSAoKHN1YnRyYWN0ZWQgPj4gOCkgKiAweGMwKSArIChzdWJ0cmFjdGVkICYgMHhmZik7XG4gICAgICAgICAgICAgICAgYml0cy5hcHBlbmRCaXRzKGVuY29kZWQsIDEzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgYXBwZW5kRUNJKGVjaSwgYml0cykge1xuICAgICAgICAgICAgYml0cy5hcHBlbmRCaXRzKE1vZGUkMS5FQ0kuZ2V0Qml0cygpLCA0KTtcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgY29ycmVjdCBmb3IgdmFsdWVzIHVwIHRvIDEyNywgd2hpY2ggaXMgYWxsIHdlIG5lZWQgbm93LlxuICAgICAgICAgICAgYml0cy5hcHBlbmRCaXRzKGVjaS5nZXRWYWx1ZSgpLCA4KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBUaGUgb3JpZ2luYWwgdGFibGUgaXMgZGVmaW5lZCBpbiB0aGUgdGFibGUgNSBvZiBKSVNYMDUxMDoyMDA0IChwLjE5KS5cbiAgICBFbmNvZGVyLkFMUEhBTlVNRVJJQ19UQUJMRSA9IEludDMyQXJyYXkuZnJvbShbXG4gICAgICAgIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLFxuICAgICAgICAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSxcbiAgICAgICAgMzYsIC0xLCAtMSwgLTEsIDM3LCAzOCwgLTEsIC0xLCAtMSwgLTEsIDM5LCA0MCwgLTEsIDQxLCA0MiwgNDMsXG4gICAgICAgIDAsIDEsIDIsIDMsIDQsIDUsIDYsIDcsIDgsIDksIDQ0LCAtMSwgLTEsIC0xLCAtMSwgLTEsXG4gICAgICAgIC0xLCAxMCwgMTEsIDEyLCAxMywgMTQsIDE1LCAxNiwgMTcsIDE4LCAxOSwgMjAsIDIxLCAyMiwgMjMsIDI0LFxuICAgICAgICAyNSwgMjYsIDI3LCAyOCwgMjksIDMwLCAzMSwgMzIsIDMzLCAzNCwgMzUsIC0xLCAtMSwgLTEsIC0xLCAtMSxcbiAgICBdKTtcbiAgICBFbmNvZGVyLkRFRkFVTFRfQllURV9NT0RFX0VOQ09ESU5HID0gQ2hhcmFjdGVyU2V0RUNJLlVURjguZ2V0TmFtZSgpOyAvLyBcIklTTy04ODU5LTFcIlxuXG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgTW92aW5nIHRvIEB6eGluZy9icm93c2VyXG4gICAgICovXG4gICAgY2xhc3MgQnJvd3NlclFSQ29kZVN2Z1dyaXRlciB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXcml0ZXMgYW5kIHJlbmRlcnMgYSBRUkNvZGUgU1ZHIGVsZW1lbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBjb250ZW50c1xuICAgICAgICAgKiBAcGFyYW0gd2lkdGhcbiAgICAgICAgICogQHBhcmFtIGhlaWdodFxuICAgICAgICAgKiBAcGFyYW0gaGludHNcbiAgICAgICAgICovXG4gICAgICAgIHdyaXRlKGNvbnRlbnRzLCB3aWR0aCwgaGVpZ2h0LCBoaW50cyA9IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChjb250ZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCdGb3VuZCBlbXB0eSBjb250ZW50cycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaWYgKGZvcm1hdCAhPSBCYXJjb2RlRm9ybWF0LlFSX0NPREUpIHtcbiAgICAgICAgICAgIC8vICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbihcIkNhbiBvbmx5IGVuY29kZSBRUl9DT0RFLCBidXQgZ290IFwiICsgZm9ybWF0KVxuICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgaWYgKHdpZHRoIDwgMCB8fCBoZWlnaHQgPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignUmVxdWVzdGVkIGRpbWVuc2lvbnMgYXJlIHRvbyBzbWFsbDogJyArIHdpZHRoICsgJ3gnICsgaGVpZ2h0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBlcnJvckNvcnJlY3Rpb25MZXZlbCA9IEVycm9yQ29ycmVjdGlvbkxldmVsLkw7XG4gICAgICAgICAgICBsZXQgcXVpZXRab25lID0gQnJvd3NlclFSQ29kZVN2Z1dyaXRlci5RVUlFVF9aT05FX1NJWkU7XG4gICAgICAgICAgICBpZiAoaGludHMgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodW5kZWZpbmVkICE9PSBoaW50cy5nZXQoRW5jb2RlSGludFR5cGUkMS5FUlJPUl9DT1JSRUNUSU9OKSkge1xuICAgICAgICAgICAgICAgICAgICBlcnJvckNvcnJlY3Rpb25MZXZlbCA9IEVycm9yQ29ycmVjdGlvbkxldmVsLmZyb21TdHJpbmcoaGludHMuZ2V0KEVuY29kZUhpbnRUeXBlJDEuRVJST1JfQ09SUkVDVElPTikudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh1bmRlZmluZWQgIT09IGhpbnRzLmdldChFbmNvZGVIaW50VHlwZSQxLk1BUkdJTikpIHtcbiAgICAgICAgICAgICAgICAgICAgcXVpZXRab25lID0gTnVtYmVyLnBhcnNlSW50KGhpbnRzLmdldChFbmNvZGVIaW50VHlwZSQxLk1BUkdJTikudG9TdHJpbmcoKSwgMTApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNvZGUgPSBFbmNvZGVyLmVuY29kZShjb250ZW50cywgZXJyb3JDb3JyZWN0aW9uTGV2ZWwsIGhpbnRzKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbmRlclJlc3VsdChjb2RlLCB3aWR0aCwgaGVpZ2h0LCBxdWlldFpvbmUpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW5kZXJzIHRoZSByZXN1bHQgYW5kIHRoZW4gYXBwZW5kcyBpdCB0byB0aGUgRE9NLlxuICAgICAgICAgKi9cbiAgICAgICAgd3JpdGVUb0RvbShjb250YWluZXJFbGVtZW50LCBjb250ZW50cywgd2lkdGgsIGhlaWdodCwgaGludHMgPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRhaW5lckVsZW1lbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyRWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoY29udGFpbmVyRWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzdmdFbGVtZW50ID0gdGhpcy53cml0ZShjb250ZW50cywgd2lkdGgsIGhlaWdodCwgaGludHMpO1xuICAgICAgICAgICAgaWYgKGNvbnRhaW5lckVsZW1lbnQpXG4gICAgICAgICAgICAgICAgY29udGFpbmVyRWxlbWVudC5hcHBlbmRDaGlsZChzdmdFbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogTm90ZSB0aGF0IHRoZSBpbnB1dCBtYXRyaXggdXNlcyAwID09IHdoaXRlLCAxID09IGJsYWNrLlxuICAgICAgICAgKiBUaGUgb3V0cHV0IG1hdHJpeCB1c2VzIDAgPT0gYmxhY2ssIDI1NSA9PSB3aGl0ZSAoaS5lLiBhbiA4IGJpdCBncmV5c2NhbGUgYml0bWFwKS5cbiAgICAgICAgICovXG4gICAgICAgIHJlbmRlclJlc3VsdChjb2RlLCB3aWR0aCAvKmludCovLCBoZWlnaHQgLyppbnQqLywgcXVpZXRab25lIC8qaW50Ki8pIHtcbiAgICAgICAgICAgIGNvbnN0IGlucHV0ID0gY29kZS5nZXRNYXRyaXgoKTtcbiAgICAgICAgICAgIGlmIChpbnB1dCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsU3RhdGVFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGlucHV0V2lkdGggPSBpbnB1dC5nZXRXaWR0aCgpO1xuICAgICAgICAgICAgY29uc3QgaW5wdXRIZWlnaHQgPSBpbnB1dC5nZXRIZWlnaHQoKTtcbiAgICAgICAgICAgIGNvbnN0IHFyV2lkdGggPSBpbnB1dFdpZHRoICsgKHF1aWV0Wm9uZSAqIDIpO1xuICAgICAgICAgICAgY29uc3QgcXJIZWlnaHQgPSBpbnB1dEhlaWdodCArIChxdWlldFpvbmUgKiAyKTtcbiAgICAgICAgICAgIGNvbnN0IG91dHB1dFdpZHRoID0gTWF0aC5tYXgod2lkdGgsIHFyV2lkdGgpO1xuICAgICAgICAgICAgY29uc3Qgb3V0cHV0SGVpZ2h0ID0gTWF0aC5tYXgoaGVpZ2h0LCBxckhlaWdodCk7XG4gICAgICAgICAgICBjb25zdCBtdWx0aXBsZSA9IE1hdGgubWluKE1hdGguZmxvb3Iob3V0cHV0V2lkdGggLyBxcldpZHRoKSwgTWF0aC5mbG9vcihvdXRwdXRIZWlnaHQgLyBxckhlaWdodCkpO1xuICAgICAgICAgICAgLy8gUGFkZGluZyBpbmNsdWRlcyBib3RoIHRoZSBxdWlldCB6b25lIGFuZCB0aGUgZXh0cmEgd2hpdGUgcGl4ZWxzIHRvIGFjY29tbW9kYXRlIHRoZSByZXF1ZXN0ZWRcbiAgICAgICAgICAgIC8vIGRpbWVuc2lvbnMuIEZvciBleGFtcGxlLCBpZiBpbnB1dCBpcyAyNXgyNSB0aGUgUVIgd2lsbCBiZSAzM3gzMyBpbmNsdWRpbmcgdGhlIHF1aWV0IHpvbmUuXG4gICAgICAgICAgICAvLyBJZiB0aGUgcmVxdWVzdGVkIHNpemUgaXMgMjAweDE2MCwgdGhlIG11bHRpcGxlIHdpbGwgYmUgNCwgZm9yIGEgUVIgb2YgMTMyeDEzMi4gVGhlc2Ugd2lsbFxuICAgICAgICAgICAgLy8gaGFuZGxlIGFsbCB0aGUgcGFkZGluZyBmcm9tIDEwMHgxMDAgKHRoZSBhY3R1YWwgUVIpIHVwIHRvIDIwMHgxNjAuXG4gICAgICAgICAgICBjb25zdCBsZWZ0UGFkZGluZyA9IE1hdGguZmxvb3IoKG91dHB1dFdpZHRoIC0gKGlucHV0V2lkdGggKiBtdWx0aXBsZSkpIC8gMik7XG4gICAgICAgICAgICBjb25zdCB0b3BQYWRkaW5nID0gTWF0aC5mbG9vcigob3V0cHV0SGVpZ2h0IC0gKGlucHV0SGVpZ2h0ICogbXVsdGlwbGUpKSAvIDIpO1xuICAgICAgICAgICAgY29uc3Qgc3ZnRWxlbWVudCA9IHRoaXMuY3JlYXRlU1ZHRWxlbWVudChvdXRwdXRXaWR0aCwgb3V0cHV0SGVpZ2h0KTtcbiAgICAgICAgICAgIGZvciAobGV0IGlucHV0WSA9IDAsIG91dHB1dFkgPSB0b3BQYWRkaW5nOyBpbnB1dFkgPCBpbnB1dEhlaWdodDsgaW5wdXRZKyssIG91dHB1dFkgKz0gbXVsdGlwbGUpIHtcbiAgICAgICAgICAgICAgICAvLyBXcml0ZSB0aGUgY29udGVudHMgb2YgdGhpcyByb3cgb2YgdGhlIGJhcmNvZGVcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpbnB1dFggPSAwLCBvdXRwdXRYID0gbGVmdFBhZGRpbmc7IGlucHV0WCA8IGlucHV0V2lkdGg7IGlucHV0WCsrLCBvdXRwdXRYICs9IG11bHRpcGxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dC5nZXQoaW5wdXRYLCBpbnB1dFkpID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzdmdSZWN0RWxlbWVudCA9IHRoaXMuY3JlYXRlU3ZnUmVjdEVsZW1lbnQob3V0cHV0WCwgb3V0cHV0WSwgbXVsdGlwbGUsIG11bHRpcGxlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN2Z0VsZW1lbnQuYXBwZW5kQ2hpbGQoc3ZnUmVjdEVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN2Z0VsZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBTVkcgZWxlbWVudC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHcgU1ZHJ3Mgd2lkdGggYXR0cmlidXRlXG4gICAgICAgICAqIEBwYXJhbSBoIFNWRydzIGhlaWdodCBhdHRyaWJ1dGVcbiAgICAgICAgICovXG4gICAgICAgIGNyZWF0ZVNWR0VsZW1lbnQodywgaCkge1xuICAgICAgICAgICAgY29uc3Qgc3ZnRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhCcm93c2VyUVJDb2RlU3ZnV3JpdGVyLlNWR19OUywgJ3N2ZycpO1xuICAgICAgICAgICAgc3ZnRWxlbWVudC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnaGVpZ2h0Jywgdy50b1N0cmluZygpKTtcbiAgICAgICAgICAgIHN2Z0VsZW1lbnQuc2V0QXR0cmlidXRlTlMobnVsbCwgJ3dpZHRoJywgaC50b1N0cmluZygpKTtcbiAgICAgICAgICAgIHJldHVybiBzdmdFbGVtZW50O1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgU1ZHIHJlY3QgZWxlbWVudC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHggRWxlbWVudCdzIHggY29vcmRpbmF0ZVxuICAgICAgICAgKiBAcGFyYW0geSBFbGVtZW50J3MgeSBjb29yZGluYXRlXG4gICAgICAgICAqIEBwYXJhbSB3IEVsZW1lbnQncyB3aWR0aCBhdHRyaWJ1dGVcbiAgICAgICAgICogQHBhcmFtIGggRWxlbWVudCdzIGhlaWdodCBhdHRyaWJ1dGVcbiAgICAgICAgICovXG4gICAgICAgIGNyZWF0ZVN2Z1JlY3RFbGVtZW50KHgsIHksIHcsIGgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlY3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoQnJvd3NlclFSQ29kZVN2Z1dyaXRlci5TVkdfTlMsICdyZWN0Jyk7XG4gICAgICAgICAgICByZWN0LnNldEF0dHJpYnV0ZU5TKG51bGwsICd4JywgeC50b1N0cmluZygpKTtcbiAgICAgICAgICAgIHJlY3Quc2V0QXR0cmlidXRlTlMobnVsbCwgJ3knLCB5LnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgcmVjdC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnaGVpZ2h0Jywgdy50b1N0cmluZygpKTtcbiAgICAgICAgICAgIHJlY3Quc2V0QXR0cmlidXRlTlMobnVsbCwgJ3dpZHRoJywgaC50b1N0cmluZygpKTtcbiAgICAgICAgICAgIHJlY3Quc2V0QXR0cmlidXRlTlMobnVsbCwgJ2ZpbGwnLCAnIzAwMDAwMCcpO1xuICAgICAgICAgICAgcmV0dXJuIHJlY3Q7XG4gICAgICAgIH1cbiAgICB9XG4gICAgQnJvd3NlclFSQ29kZVN2Z1dyaXRlci5RVUlFVF9aT05FX1NJWkUgPSA0O1xuICAgIC8qKlxuICAgICAqIFNWRyBtYXJrdXAgTmFtZVNwYWNlXG4gICAgICovXG4gICAgQnJvd3NlclFSQ29kZVN2Z1dyaXRlci5TVkdfTlMgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnO1xuXG4gICAgLyppbXBvcnQgamF2YS51dGlsLk1hcDsqL1xuICAgIC8qKlxuICAgICAqIFRoaXMgb2JqZWN0IHJlbmRlcnMgYSBRUiBDb2RlIGFzIGEgQml0TWF0cml4IDJEIGFycmF5IG9mIGdyZXlzY2FsZSB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAYXV0aG9yIGRzd2l0a2luQGdvb2dsZS5jb20gKERhbmllbCBTd2l0a2luKVxuICAgICAqL1xuICAgIGNsYXNzIFFSQ29kZVdyaXRlciB7XG4gICAgICAgIC8qQE92ZXJyaWRlKi9cbiAgICAgICAgLy8gcHVibGljIGVuY29kZShjb250ZW50czogc3RyaW5nLCBmb3JtYXQ6IEJhcmNvZGVGb3JtYXQsIHdpZHRoOiBudW1iZXIgLyppbnQqLywgaGVpZ2h0OiBudW1iZXIgLyppbnQqLyk6IEJpdE1hdHJpeFxuICAgICAgICAvLyAgICAgLyp0aHJvd3MgV3JpdGVyRXhjZXB0aW9uICovIHtcbiAgICAgICAgLy8gICByZXR1cm4gZW5jb2RlKGNvbnRlbnRzLCBmb3JtYXQsIHdpZHRoLCBoZWlnaHQsIG51bGwpXG4gICAgICAgIC8vIH1cbiAgICAgICAgLypAT3ZlcnJpZGUqL1xuICAgICAgICBlbmNvZGUoY29udGVudHMsIGZvcm1hdCwgd2lkdGggLyppbnQqLywgaGVpZ2h0IC8qaW50Ki8sIGhpbnRzKSB7XG4gICAgICAgICAgICBpZiAoY29udGVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignRm91bmQgZW1wdHkgY29udGVudHMnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmb3JtYXQgIT09IEJhcmNvZGVGb3JtYXQkMS5RUl9DT0RFKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignQ2FuIG9ubHkgZW5jb2RlIFFSX0NPREUsIGJ1dCBnb3QgJyArIGZvcm1hdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAod2lkdGggPCAwIHx8IGhlaWdodCA8IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKGBSZXF1ZXN0ZWQgZGltZW5zaW9ucyBhcmUgdG9vIHNtYWxsOiAke3dpZHRofXgke2hlaWdodH1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBlcnJvckNvcnJlY3Rpb25MZXZlbCA9IEVycm9yQ29ycmVjdGlvbkxldmVsLkw7XG4gICAgICAgICAgICBsZXQgcXVpZXRab25lID0gUVJDb2RlV3JpdGVyLlFVSUVUX1pPTkVfU0laRTtcbiAgICAgICAgICAgIGlmIChoaW50cyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh1bmRlZmluZWQgIT09IGhpbnRzLmdldChFbmNvZGVIaW50VHlwZSQxLkVSUk9SX0NPUlJFQ1RJT04pKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yQ29ycmVjdGlvbkxldmVsID0gRXJyb3JDb3JyZWN0aW9uTGV2ZWwuZnJvbVN0cmluZyhoaW50cy5nZXQoRW5jb2RlSGludFR5cGUkMS5FUlJPUl9DT1JSRUNUSU9OKS50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHVuZGVmaW5lZCAhPT0gaGludHMuZ2V0KEVuY29kZUhpbnRUeXBlJDEuTUFSR0lOKSkge1xuICAgICAgICAgICAgICAgICAgICBxdWlldFpvbmUgPSBOdW1iZXIucGFyc2VJbnQoaGludHMuZ2V0KEVuY29kZUhpbnRUeXBlJDEuTUFSR0lOKS50b1N0cmluZygpLCAxMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY29kZSA9IEVuY29kZXIuZW5jb2RlKGNvbnRlbnRzLCBlcnJvckNvcnJlY3Rpb25MZXZlbCwgaGludHMpO1xuICAgICAgICAgICAgcmV0dXJuIFFSQ29kZVdyaXRlci5yZW5kZXJSZXN1bHQoY29kZSwgd2lkdGgsIGhlaWdodCwgcXVpZXRab25lKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBOb3RlIHRoYXQgdGhlIGlucHV0IG1hdHJpeCB1c2VzIDAgPT0gd2hpdGUsIDEgPT0gYmxhY2ssIHdoaWxlIHRoZSBvdXRwdXQgbWF0cml4IHVzZXNcbiAgICAgICAgLy8gMCA9PSBibGFjaywgMjU1ID09IHdoaXRlIChpLmUuIGFuIDggYml0IGdyZXlzY2FsZSBiaXRtYXApLlxuICAgICAgICBzdGF0aWMgcmVuZGVyUmVzdWx0KGNvZGUsIHdpZHRoIC8qaW50Ki8sIGhlaWdodCAvKmludCovLCBxdWlldFpvbmUgLyppbnQqLykge1xuICAgICAgICAgICAgY29uc3QgaW5wdXQgPSBjb2RlLmdldE1hdHJpeCgpO1xuICAgICAgICAgICAgaWYgKGlucHV0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxTdGF0ZUV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaW5wdXRXaWR0aCA9IGlucHV0LmdldFdpZHRoKCk7XG4gICAgICAgICAgICBjb25zdCBpbnB1dEhlaWdodCA9IGlucHV0LmdldEhlaWdodCgpO1xuICAgICAgICAgICAgY29uc3QgcXJXaWR0aCA9IGlucHV0V2lkdGggKyAocXVpZXRab25lICogMik7XG4gICAgICAgICAgICBjb25zdCBxckhlaWdodCA9IGlucHV0SGVpZ2h0ICsgKHF1aWV0Wm9uZSAqIDIpO1xuICAgICAgICAgICAgY29uc3Qgb3V0cHV0V2lkdGggPSBNYXRoLm1heCh3aWR0aCwgcXJXaWR0aCk7XG4gICAgICAgICAgICBjb25zdCBvdXRwdXRIZWlnaHQgPSBNYXRoLm1heChoZWlnaHQsIHFySGVpZ2h0KTtcbiAgICAgICAgICAgIGNvbnN0IG11bHRpcGxlID0gTWF0aC5taW4oTWF0aC5mbG9vcihvdXRwdXRXaWR0aCAvIHFyV2lkdGgpLCBNYXRoLmZsb29yKG91dHB1dEhlaWdodCAvIHFySGVpZ2h0KSk7XG4gICAgICAgICAgICAvLyBQYWRkaW5nIGluY2x1ZGVzIGJvdGggdGhlIHF1aWV0IHpvbmUgYW5kIHRoZSBleHRyYSB3aGl0ZSBwaXhlbHMgdG8gYWNjb21tb2RhdGUgdGhlIHJlcXVlc3RlZFxuICAgICAgICAgICAgLy8gZGltZW5zaW9ucy4gRm9yIGV4YW1wbGUsIGlmIGlucHV0IGlzIDI1eDI1IHRoZSBRUiB3aWxsIGJlIDMzeDMzIGluY2x1ZGluZyB0aGUgcXVpZXQgem9uZS5cbiAgICAgICAgICAgIC8vIElmIHRoZSByZXF1ZXN0ZWQgc2l6ZSBpcyAyMDB4MTYwLCB0aGUgbXVsdGlwbGUgd2lsbCBiZSA0LCBmb3IgYSBRUiBvZiAxMzJ4MTMyLiBUaGVzZSB3aWxsXG4gICAgICAgICAgICAvLyBoYW5kbGUgYWxsIHRoZSBwYWRkaW5nIGZyb20gMTAweDEwMCAodGhlIGFjdHVhbCBRUikgdXAgdG8gMjAweDE2MC5cbiAgICAgICAgICAgIGNvbnN0IGxlZnRQYWRkaW5nID0gTWF0aC5mbG9vcigob3V0cHV0V2lkdGggLSAoaW5wdXRXaWR0aCAqIG11bHRpcGxlKSkgLyAyKTtcbiAgICAgICAgICAgIGNvbnN0IHRvcFBhZGRpbmcgPSBNYXRoLmZsb29yKChvdXRwdXRIZWlnaHQgLSAoaW5wdXRIZWlnaHQgKiBtdWx0aXBsZSkpIC8gMik7XG4gICAgICAgICAgICBjb25zdCBvdXRwdXQgPSBuZXcgQml0TWF0cml4KG91dHB1dFdpZHRoLCBvdXRwdXRIZWlnaHQpO1xuICAgICAgICAgICAgZm9yIChsZXQgaW5wdXRZID0gMCwgb3V0cHV0WSA9IHRvcFBhZGRpbmc7IGlucHV0WSA8IGlucHV0SGVpZ2h0OyBpbnB1dFkrKywgb3V0cHV0WSArPSBtdWx0aXBsZSkge1xuICAgICAgICAgICAgICAgIC8vIFdyaXRlIHRoZSBjb250ZW50cyBvZiB0aGlzIHJvdyBvZiB0aGUgYmFyY29kZVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGlucHV0WCA9IDAsIG91dHB1dFggPSBsZWZ0UGFkZGluZzsgaW5wdXRYIDwgaW5wdXRXaWR0aDsgaW5wdXRYKyssIG91dHB1dFggKz0gbXVsdGlwbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0LmdldChpbnB1dFgsIGlucHV0WSkgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5zZXRSZWdpb24ob3V0cHV0WCwgb3V0cHV0WSwgbXVsdGlwbGUsIG11bHRpcGxlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgUVJDb2RlV3JpdGVyLlFVSUVUX1pPTkVfU0laRSA9IDQ7XG5cbiAgICAvKmltcG9ydCBqYXZhLnV0aWwuTWFwOyovXG4gICAgLyoqXG4gICAgICogVGhpcyBpcyBhIGZhY3RvcnkgY2xhc3Mgd2hpY2ggZmluZHMgdGhlIGFwcHJvcHJpYXRlIFdyaXRlciBzdWJjbGFzcyBmb3IgdGhlIEJhcmNvZGVGb3JtYXRcbiAgICAgKiByZXF1ZXN0ZWQgYW5kIGVuY29kZXMgdGhlIGJhcmNvZGUgd2l0aCB0aGUgc3VwcGxpZWQgY29udGVudHMuXG4gICAgICpcbiAgICAgKiBAYXV0aG9yIGRzd2l0a2luQGdvb2dsZS5jb20gKERhbmllbCBTd2l0a2luKVxuICAgICAqL1xuICAgIGNsYXNzIE11bHRpRm9ybWF0V3JpdGVyIHtcbiAgICAgICAgLypAT3ZlcnJpZGUqL1xuICAgICAgICAvLyBwdWJsaWMgZW5jb2RlKGNvbnRlbnRzOiBzdHJpbmcsXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1hdDogQmFyY29kZUZvcm1hdCxcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IG51bWJlciAvKmludCovLFxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IG51bWJlciAvKmludCovKTogQml0TWF0cml4IC8qdGhyb3dzIFdyaXRlckV4Y2VwdGlvbiAqLyB7XG4gICAgICAgIC8vICAgcmV0dXJuIGVuY29kZShjb250ZW50cywgZm9ybWF0LCB3aWR0aCwgaGVpZ2h0LCBudWxsKVxuICAgICAgICAvLyB9XG4gICAgICAgIC8qQE92ZXJyaWRlKi9cbiAgICAgICAgZW5jb2RlKGNvbnRlbnRzLCBmb3JtYXQsIHdpZHRoIC8qaW50Ki8sIGhlaWdodCAvKmludCovLCBoaW50cykge1xuICAgICAgICAgICAgbGV0IHdyaXRlcjtcbiAgICAgICAgICAgIHN3aXRjaCAoZm9ybWF0KSB7XG4gICAgICAgICAgICAgICAgLy8gY2FzZSBCYXJjb2RlRm9ybWF0LkVBTl84OlxuICAgICAgICAgICAgICAgIC8vICAgd3JpdGVyID0gbmV3IEVBTjhXcml0ZXIoKVxuICAgICAgICAgICAgICAgIC8vICAgYnJlYWtcbiAgICAgICAgICAgICAgICAvLyBjYXNlIEJhcmNvZGVGb3JtYXQuVVBDX0U6XG4gICAgICAgICAgICAgICAgLy8gICB3cml0ZXIgPSBuZXcgVVBDRVdyaXRlcigpXG4gICAgICAgICAgICAgICAgLy8gICBicmVha1xuICAgICAgICAgICAgICAgIC8vIGNhc2UgQmFyY29kZUZvcm1hdC5FQU5fMTM6XG4gICAgICAgICAgICAgICAgLy8gICB3cml0ZXIgPSBuZXcgRUFOMTNXcml0ZXIoKVxuICAgICAgICAgICAgICAgIC8vICAgYnJlYWtcbiAgICAgICAgICAgICAgICAvLyBjYXNlIEJhcmNvZGVGb3JtYXQuVVBDX0E6XG4gICAgICAgICAgICAgICAgLy8gICB3cml0ZXIgPSBuZXcgVVBDQVdyaXRlcigpXG4gICAgICAgICAgICAgICAgLy8gICBicmVha1xuICAgICAgICAgICAgICAgIGNhc2UgQmFyY29kZUZvcm1hdCQxLlFSX0NPREU6XG4gICAgICAgICAgICAgICAgICAgIHdyaXRlciA9IG5ldyBRUkNvZGVXcml0ZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgLy8gY2FzZSBCYXJjb2RlRm9ybWF0LkNPREVfMzk6XG4gICAgICAgICAgICAgICAgLy8gICB3cml0ZXIgPSBuZXcgQ29kZTM5V3JpdGVyKClcbiAgICAgICAgICAgICAgICAvLyAgIGJyZWFrXG4gICAgICAgICAgICAgICAgLy8gY2FzZSBCYXJjb2RlRm9ybWF0LkNPREVfOTM6XG4gICAgICAgICAgICAgICAgLy8gICB3cml0ZXIgPSBuZXcgQ29kZTkzV3JpdGVyKClcbiAgICAgICAgICAgICAgICAvLyAgIGJyZWFrXG4gICAgICAgICAgICAgICAgLy8gY2FzZSBCYXJjb2RlRm9ybWF0LkNPREVfMTI4OlxuICAgICAgICAgICAgICAgIC8vICAgd3JpdGVyID0gbmV3IENvZGUxMjhXcml0ZXIoKVxuICAgICAgICAgICAgICAgIC8vICAgYnJlYWtcbiAgICAgICAgICAgICAgICAvLyBjYXNlIEJhcmNvZGVGb3JtYXQuSVRGOlxuICAgICAgICAgICAgICAgIC8vICAgd3JpdGVyID0gbmV3IElURldyaXRlcigpXG4gICAgICAgICAgICAgICAgLy8gICBicmVha1xuICAgICAgICAgICAgICAgIC8vIGNhc2UgQmFyY29kZUZvcm1hdC5QREZfNDE3OlxuICAgICAgICAgICAgICAgIC8vICAgd3JpdGVyID0gbmV3IFBERjQxN1dyaXRlcigpXG4gICAgICAgICAgICAgICAgLy8gICBicmVha1xuICAgICAgICAgICAgICAgIC8vIGNhc2UgQmFyY29kZUZvcm1hdC5DT0RBQkFSOlxuICAgICAgICAgICAgICAgIC8vICAgd3JpdGVyID0gbmV3IENvZGFCYXJXcml0ZXIoKVxuICAgICAgICAgICAgICAgIC8vICAgYnJlYWtcbiAgICAgICAgICAgICAgICAvLyBjYXNlIEJhcmNvZGVGb3JtYXQuREFUQV9NQVRSSVg6XG4gICAgICAgICAgICAgICAgLy8gICB3cml0ZXIgPSBuZXcgRGF0YU1hdHJpeFdyaXRlcigpXG4gICAgICAgICAgICAgICAgLy8gICBicmVha1xuICAgICAgICAgICAgICAgIC8vIGNhc2UgQmFyY29kZUZvcm1hdC5BWlRFQzpcbiAgICAgICAgICAgICAgICAvLyAgIHdyaXRlciA9IG5ldyBBenRlY1dyaXRlcigpXG4gICAgICAgICAgICAgICAgLy8gICBicmVha1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oJ05vIGVuY29kZXIgYXZhaWxhYmxlIGZvciBmb3JtYXQgJyArIGZvcm1hdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gd3JpdGVyLmVuY29kZShjb250ZW50cywgZm9ybWF0LCB3aWR0aCwgaGVpZ2h0LCBoaW50cyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKlxuICAgICAqIENvcHlyaWdodCAyMDA5IFpYaW5nIGF1dGhvcnNcbiAgICAgKlxuICAgICAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gICAgICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgICAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgICAqXG4gICAgICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAgICAgKlxuICAgICAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgICAgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICAgICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gICAgICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICAgICAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIFRoaXMgb2JqZWN0IGV4dGVuZHMgTHVtaW5hbmNlU291cmNlIGFyb3VuZCBhbiBhcnJheSBvZiBZVVYgZGF0YSByZXR1cm5lZCBmcm9tIHRoZSBjYW1lcmEgZHJpdmVyLFxuICAgICAqIHdpdGggdGhlIG9wdGlvbiB0byBjcm9wIHRvIGEgcmVjdGFuZ2xlIHdpdGhpbiB0aGUgZnVsbCBkYXRhLiBUaGlzIGNhbiBiZSB1c2VkIHRvIGV4Y2x1ZGVcbiAgICAgKiBzdXBlcmZsdW91cyBwaXhlbHMgYXJvdW5kIHRoZSBwZXJpbWV0ZXIgYW5kIHNwZWVkIHVwIGRlY29kaW5nLlxuICAgICAqXG4gICAgICogSXQgd29ya3MgZm9yIGFueSBwaXhlbCBmb3JtYXQgd2hlcmUgdGhlIFkgY2hhbm5lbCBpcyBwbGFuYXIgYW5kIGFwcGVhcnMgZmlyc3QsIGluY2x1ZGluZ1xuICAgICAqIFlDYkNyXzQyMF9TUCBhbmQgWUNiQ3JfNDIyX1NQLlxuICAgICAqXG4gICAgICogQGF1dGhvciBkc3dpdGtpbkBnb29nbGUuY29tIChEYW5pZWwgU3dpdGtpbilcbiAgICAgKi9cbiAgICBjbGFzcyBQbGFuYXJZVVZMdW1pbmFuY2VTb3VyY2UgZXh0ZW5kcyBMdW1pbmFuY2VTb3VyY2Uge1xuICAgICAgICBjb25zdHJ1Y3Rvcih5dXZEYXRhLCBkYXRhV2lkdGggLyppbnQqLywgZGF0YUhlaWdodCAvKmludCovLCBsZWZ0IC8qaW50Ki8sIHRvcCAvKmludCovLCB3aWR0aCAvKmludCovLCBoZWlnaHQgLyppbnQqLywgcmV2ZXJzZUhvcml6b250YWwpIHtcbiAgICAgICAgICAgIHN1cGVyKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgdGhpcy55dXZEYXRhID0geXV2RGF0YTtcbiAgICAgICAgICAgIHRoaXMuZGF0YVdpZHRoID0gZGF0YVdpZHRoO1xuICAgICAgICAgICAgdGhpcy5kYXRhSGVpZ2h0ID0gZGF0YUhlaWdodDtcbiAgICAgICAgICAgIHRoaXMubGVmdCA9IGxlZnQ7XG4gICAgICAgICAgICB0aGlzLnRvcCA9IHRvcDtcbiAgICAgICAgICAgIGlmIChsZWZ0ICsgd2lkdGggPiBkYXRhV2lkdGggfHwgdG9wICsgaGVpZ2h0ID4gZGF0YUhlaWdodCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oJ0Nyb3AgcmVjdGFuZ2xlIGRvZXMgbm90IGZpdCB3aXRoaW4gaW1hZ2UgZGF0YS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXZlcnNlSG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmV2ZXJzZUhvcml6b250YWwod2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLypAT3ZlcnJpZGUqL1xuICAgICAgICBnZXRSb3coeSAvKmludCovLCByb3cpIHtcbiAgICAgICAgICAgIGlmICh5IDwgMCB8fCB5ID49IHRoaXMuZ2V0SGVpZ2h0KCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCdSZXF1ZXN0ZWQgcm93IGlzIG91dHNpZGUgdGhlIGltYWdlOiAnICsgeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB3aWR0aCA9IHRoaXMuZ2V0V2lkdGgoKTtcbiAgICAgICAgICAgIGlmIChyb3cgPT09IG51bGwgfHwgcm93ID09PSB1bmRlZmluZWQgfHwgcm93Lmxlbmd0aCA8IHdpZHRoKSB7XG4gICAgICAgICAgICAgICAgcm93ID0gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KHdpZHRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9ICh5ICsgdGhpcy50b3ApICogdGhpcy5kYXRhV2lkdGggKyB0aGlzLmxlZnQ7XG4gICAgICAgICAgICBTeXN0ZW0uYXJyYXljb3B5KHRoaXMueXV2RGF0YSwgb2Zmc2V0LCByb3csIDAsIHdpZHRoKTtcbiAgICAgICAgICAgIHJldHVybiByb3c7XG4gICAgICAgIH1cbiAgICAgICAgLypAT3ZlcnJpZGUqL1xuICAgICAgICBnZXRNYXRyaXgoKSB7XG4gICAgICAgICAgICBjb25zdCB3aWR0aCA9IHRoaXMuZ2V0V2lkdGgoKTtcbiAgICAgICAgICAgIGNvbnN0IGhlaWdodCA9IHRoaXMuZ2V0SGVpZ2h0KCk7XG4gICAgICAgICAgICAvLyBJZiB0aGUgY2FsbGVyIGFza3MgZm9yIHRoZSBlbnRpcmUgdW5kZXJseWluZyBpbWFnZSwgc2F2ZSB0aGUgY29weSBhbmQgZ2l2ZSB0aGVtIHRoZVxuICAgICAgICAgICAgLy8gb3JpZ2luYWwgZGF0YS4gVGhlIGRvY3Mgc3BlY2lmaWNhbGx5IHdhcm4gdGhhdCByZXN1bHQubGVuZ3RoIG11c3QgYmUgaWdub3JlZC5cbiAgICAgICAgICAgIGlmICh3aWR0aCA9PT0gdGhpcy5kYXRhV2lkdGggJiYgaGVpZ2h0ID09PSB0aGlzLmRhdGFIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy55dXZEYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYXJlYSA9IHdpZHRoICogaGVpZ2h0O1xuICAgICAgICAgICAgY29uc3QgbWF0cml4ID0gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KGFyZWEpO1xuICAgICAgICAgICAgbGV0IGlucHV0T2Zmc2V0ID0gdGhpcy50b3AgKiB0aGlzLmRhdGFXaWR0aCArIHRoaXMubGVmdDtcbiAgICAgICAgICAgIC8vIElmIHRoZSB3aWR0aCBtYXRjaGVzIHRoZSBmdWxsIHdpZHRoIG9mIHRoZSB1bmRlcmx5aW5nIGRhdGEsIHBlcmZvcm0gYSBzaW5nbGUgY29weS5cbiAgICAgICAgICAgIGlmICh3aWR0aCA9PT0gdGhpcy5kYXRhV2lkdGgpIHtcbiAgICAgICAgICAgICAgICBTeXN0ZW0uYXJyYXljb3B5KHRoaXMueXV2RGF0YSwgaW5wdXRPZmZzZXQsIG1hdHJpeCwgMCwgYXJlYSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hdHJpeDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSBjb3B5IG9uZSBjcm9wcGVkIHJvdyBhdCBhIHRpbWUuXG4gICAgICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IGhlaWdodDsgeSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3V0cHV0T2Zmc2V0ID0geSAqIHdpZHRoO1xuICAgICAgICAgICAgICAgIFN5c3RlbS5hcnJheWNvcHkodGhpcy55dXZEYXRhLCBpbnB1dE9mZnNldCwgbWF0cml4LCBvdXRwdXRPZmZzZXQsIHdpZHRoKTtcbiAgICAgICAgICAgICAgICBpbnB1dE9mZnNldCArPSB0aGlzLmRhdGFXaWR0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtYXRyaXg7XG4gICAgICAgIH1cbiAgICAgICAgLypAT3ZlcnJpZGUqL1xuICAgICAgICBpc0Nyb3BTdXBwb3J0ZWQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvKkBPdmVycmlkZSovXG4gICAgICAgIGNyb3AobGVmdCAvKmludCovLCB0b3AgLyppbnQqLywgd2lkdGggLyppbnQqLywgaGVpZ2h0IC8qaW50Ki8pIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUGxhbmFyWVVWTHVtaW5hbmNlU291cmNlKHRoaXMueXV2RGF0YSwgdGhpcy5kYXRhV2lkdGgsIHRoaXMuZGF0YUhlaWdodCwgdGhpcy5sZWZ0ICsgbGVmdCwgdGhpcy50b3AgKyB0b3AsIHdpZHRoLCBoZWlnaHQsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICByZW5kZXJUaHVtYm5haWwoKSB7XG4gICAgICAgICAgICBjb25zdCB3aWR0aCA9IHRoaXMuZ2V0V2lkdGgoKSAvIFBsYW5hcllVVkx1bWluYW5jZVNvdXJjZS5USFVNQk5BSUxfU0NBTEVfRkFDVE9SO1xuICAgICAgICAgICAgY29uc3QgaGVpZ2h0ID0gdGhpcy5nZXRIZWlnaHQoKSAvIFBsYW5hcllVVkx1bWluYW5jZVNvdXJjZS5USFVNQk5BSUxfU0NBTEVfRkFDVE9SO1xuICAgICAgICAgICAgY29uc3QgcGl4ZWxzID0gbmV3IEludDMyQXJyYXkod2lkdGggKiBoZWlnaHQpO1xuICAgICAgICAgICAgY29uc3QgeXV2ID0gdGhpcy55dXZEYXRhO1xuICAgICAgICAgICAgbGV0IGlucHV0T2Zmc2V0ID0gdGhpcy50b3AgKiB0aGlzLmRhdGFXaWR0aCArIHRoaXMubGVmdDtcbiAgICAgICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgaGVpZ2h0OyB5KyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvdXRwdXRPZmZzZXQgPSB5ICogd2lkdGg7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCB3aWR0aDsgeCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGdyZXkgPSB5dXZbaW5wdXRPZmZzZXQgKyB4ICogUGxhbmFyWVVWTHVtaW5hbmNlU291cmNlLlRIVU1CTkFJTF9TQ0FMRV9GQUNUT1JdICYgMHhmZjtcbiAgICAgICAgICAgICAgICAgICAgcGl4ZWxzW291dHB1dE9mZnNldCArIHhdID0gMHhGRjAwMDAwMCB8IChncmV5ICogMHgwMDAxMDEwMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlucHV0T2Zmc2V0ICs9IHRoaXMuZGF0YVdpZHRoICogUGxhbmFyWVVWTHVtaW5hbmNlU291cmNlLlRIVU1CTkFJTF9TQ0FMRV9GQUNUT1I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcGl4ZWxzO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHdpZHRoIG9mIGltYWdlIGZyb20ge0BsaW5rICNyZW5kZXJUaHVtYm5haWwoKX1cbiAgICAgICAgICovXG4gICAgICAgIGdldFRodW1ibmFpbFdpZHRoKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0V2lkdGgoKSAvIFBsYW5hcllVVkx1bWluYW5jZVNvdXJjZS5USFVNQk5BSUxfU0NBTEVfRkFDVE9SO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIGhlaWdodCBvZiBpbWFnZSBmcm9tIHtAbGluayAjcmVuZGVyVGh1bWJuYWlsKCl9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRUaHVtYm5haWxIZWlnaHQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRIZWlnaHQoKSAvIFBsYW5hcllVVkx1bWluYW5jZVNvdXJjZS5USFVNQk5BSUxfU0NBTEVfRkFDVE9SO1xuICAgICAgICB9XG4gICAgICAgIHJldmVyc2VIb3Jpem9udGFsKHdpZHRoIC8qaW50Ki8sIGhlaWdodCAvKmludCovKSB7XG4gICAgICAgICAgICBjb25zdCB5dXZEYXRhID0gdGhpcy55dXZEYXRhO1xuICAgICAgICAgICAgZm9yIChsZXQgeSA9IDAsIHJvd1N0YXJ0ID0gdGhpcy50b3AgKiB0aGlzLmRhdGFXaWR0aCArIHRoaXMubGVmdDsgeSA8IGhlaWdodDsgeSsrLCByb3dTdGFydCArPSB0aGlzLmRhdGFXaWR0aCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1pZGRsZSA9IHJvd1N0YXJ0ICsgd2lkdGggLyAyO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHgxID0gcm93U3RhcnQsIHgyID0gcm93U3RhcnQgKyB3aWR0aCAtIDE7IHgxIDwgbWlkZGxlOyB4MSsrLCB4Mi0tKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRlbXAgPSB5dXZEYXRhW3gxXTtcbiAgICAgICAgICAgICAgICAgICAgeXV2RGF0YVt4MV0gPSB5dXZEYXRhW3gyXTtcbiAgICAgICAgICAgICAgICAgICAgeXV2RGF0YVt4Ml0gPSB0ZW1wO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpbnZlcnQoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEludmVydGVkTHVtaW5hbmNlU291cmNlKHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIFBsYW5hcllVVkx1bWluYW5jZVNvdXJjZS5USFVNQk5BSUxfU0NBTEVfRkFDVE9SID0gMjtcblxuICAgIC8qXG4gICAgICogQ29weXJpZ2h0IDIwMDkgWlhpbmcgYXV0aG9yc1xuICAgICAqXG4gICAgICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgICAgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICAgICpcbiAgICAgKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICAgICAqXG4gICAgICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICAgICAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgICAgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgICAgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gICAgICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gICAgICovXG4gICAgLyoqXG4gICAgICogVGhpcyBjbGFzcyBpcyB1c2VkIHRvIGhlbHAgZGVjb2RlIGltYWdlcyBmcm9tIGZpbGVzIHdoaWNoIGFycml2ZSBhcyBSR0IgZGF0YSBmcm9tXG4gICAgICogYW4gQVJHQiBwaXhlbCBhcnJheS4gSXQgZG9lcyBub3Qgc3VwcG9ydCByb3RhdGlvbi5cbiAgICAgKlxuICAgICAqIEBhdXRob3IgZHN3aXRraW5AZ29vZ2xlLmNvbSAoRGFuaWVsIFN3aXRraW4pXG4gICAgICogQGF1dGhvciBCZXRhbWlub3NcbiAgICAgKi9cbiAgICBjbGFzcyBSR0JMdW1pbmFuY2VTb3VyY2UgZXh0ZW5kcyBMdW1pbmFuY2VTb3VyY2Uge1xuICAgICAgICBjb25zdHJ1Y3RvcihsdW1pbmFuY2VzLCB3aWR0aCAvKmludCovLCBoZWlnaHQgLyppbnQqLywgZGF0YVdpZHRoIC8qaW50Ki8sIGRhdGFIZWlnaHQgLyppbnQqLywgbGVmdCAvKmludCovLCB0b3AgLyppbnQqLykge1xuICAgICAgICAgICAgc3VwZXIod2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICB0aGlzLmRhdGFXaWR0aCA9IGRhdGFXaWR0aDtcbiAgICAgICAgICAgIHRoaXMuZGF0YUhlaWdodCA9IGRhdGFIZWlnaHQ7XG4gICAgICAgICAgICB0aGlzLmxlZnQgPSBsZWZ0O1xuICAgICAgICAgICAgdGhpcy50b3AgPSB0b3A7XG4gICAgICAgICAgICBpZiAobHVtaW5hbmNlcy5CWVRFU19QRVJfRUxFTUVOVCA9PT0gNCkgeyAvLyBJbnQzMkFycmF5XG4gICAgICAgICAgICAgICAgY29uc3Qgc2l6ZSA9IHdpZHRoICogaGVpZ2h0O1xuICAgICAgICAgICAgICAgIGNvbnN0IGx1bWluYW5jZXNVaW50OEFycmF5ID0gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KHNpemUpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IG9mZnNldCA9IDA7IG9mZnNldCA8IHNpemU7IG9mZnNldCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBpeGVsID0gbHVtaW5hbmNlc1tvZmZzZXRdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByID0gKHBpeGVsID4+IDE2KSAmIDB4ZmY7IC8vIHJlZFxuICAgICAgICAgICAgICAgICAgICBjb25zdCBnMiA9IChwaXhlbCA+PiA3KSAmIDB4MWZlOyAvLyAyICogZ3JlZW5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYiA9IHBpeGVsICYgMHhmZjsgLy8gYmx1ZVxuICAgICAgICAgICAgICAgICAgICAvLyBDYWxjdWxhdGUgZ3JlZW4tZmF2b3VyaW5nIGF2ZXJhZ2UgY2hlYXBseVxuICAgICAgICAgICAgICAgICAgICBsdW1pbmFuY2VzVWludDhBcnJheVtvZmZzZXRdID0gLyooYnl0ZSkgKi8gKChyICsgZzIgKyBiKSAvIDQpICYgMHhGRjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5sdW1pbmFuY2VzID0gbHVtaW5hbmNlc1VpbnQ4QXJyYXk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmx1bWluYW5jZXMgPSBsdW1pbmFuY2VzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHVuZGVmaW5lZCA9PT0gZGF0YVdpZHRoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhV2lkdGggPSB3aWR0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh1bmRlZmluZWQgPT09IGRhdGFIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGFIZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodW5kZWZpbmVkID09PSBsZWZ0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sZWZ0ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh1bmRlZmluZWQgPT09IHRvcCkge1xuICAgICAgICAgICAgICAgIHRoaXMudG9wID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmxlZnQgKyB3aWR0aCA+IHRoaXMuZGF0YVdpZHRoIHx8IHRoaXMudG9wICsgaGVpZ2h0ID4gdGhpcy5kYXRhSGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignQ3JvcCByZWN0YW5nbGUgZG9lcyBub3QgZml0IHdpdGhpbiBpbWFnZSBkYXRhLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qQE92ZXJyaWRlKi9cbiAgICAgICAgZ2V0Um93KHkgLyppbnQqLywgcm93KSB7XG4gICAgICAgICAgICBpZiAoeSA8IDAgfHwgeSA+PSB0aGlzLmdldEhlaWdodCgpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignUmVxdWVzdGVkIHJvdyBpcyBvdXRzaWRlIHRoZSBpbWFnZTogJyArIHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgd2lkdGggPSB0aGlzLmdldFdpZHRoKCk7XG4gICAgICAgICAgICBpZiAocm93ID09PSBudWxsIHx8IHJvdyA9PT0gdW5kZWZpbmVkIHx8IHJvdy5sZW5ndGggPCB3aWR0aCkge1xuICAgICAgICAgICAgICAgIHJvdyA9IG5ldyBVaW50OENsYW1wZWRBcnJheSh3aWR0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBvZmZzZXQgPSAoeSArIHRoaXMudG9wKSAqIHRoaXMuZGF0YVdpZHRoICsgdGhpcy5sZWZ0O1xuICAgICAgICAgICAgU3lzdGVtLmFycmF5Y29weSh0aGlzLmx1bWluYW5jZXMsIG9mZnNldCwgcm93LCAwLCB3aWR0aCk7XG4gICAgICAgICAgICByZXR1cm4gcm93O1xuICAgICAgICB9XG4gICAgICAgIC8qQE92ZXJyaWRlKi9cbiAgICAgICAgZ2V0TWF0cml4KCkge1xuICAgICAgICAgICAgY29uc3Qgd2lkdGggPSB0aGlzLmdldFdpZHRoKCk7XG4gICAgICAgICAgICBjb25zdCBoZWlnaHQgPSB0aGlzLmdldEhlaWdodCgpO1xuICAgICAgICAgICAgLy8gSWYgdGhlIGNhbGxlciBhc2tzIGZvciB0aGUgZW50aXJlIHVuZGVybHlpbmcgaW1hZ2UsIHNhdmUgdGhlIGNvcHkgYW5kIGdpdmUgdGhlbSB0aGVcbiAgICAgICAgICAgIC8vIG9yaWdpbmFsIGRhdGEuIFRoZSBkb2NzIHNwZWNpZmljYWxseSB3YXJuIHRoYXQgcmVzdWx0Lmxlbmd0aCBtdXN0IGJlIGlnbm9yZWQuXG4gICAgICAgICAgICBpZiAod2lkdGggPT09IHRoaXMuZGF0YVdpZHRoICYmIGhlaWdodCA9PT0gdGhpcy5kYXRhSGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubHVtaW5hbmNlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGFyZWEgPSB3aWR0aCAqIGhlaWdodDtcbiAgICAgICAgICAgIGNvbnN0IG1hdHJpeCA9IG5ldyBVaW50OENsYW1wZWRBcnJheShhcmVhKTtcbiAgICAgICAgICAgIGxldCBpbnB1dE9mZnNldCA9IHRoaXMudG9wICogdGhpcy5kYXRhV2lkdGggKyB0aGlzLmxlZnQ7XG4gICAgICAgICAgICAvLyBJZiB0aGUgd2lkdGggbWF0Y2hlcyB0aGUgZnVsbCB3aWR0aCBvZiB0aGUgdW5kZXJseWluZyBkYXRhLCBwZXJmb3JtIGEgc2luZ2xlIGNvcHkuXG4gICAgICAgICAgICBpZiAod2lkdGggPT09IHRoaXMuZGF0YVdpZHRoKSB7XG4gICAgICAgICAgICAgICAgU3lzdGVtLmFycmF5Y29weSh0aGlzLmx1bWluYW5jZXMsIGlucHV0T2Zmc2V0LCBtYXRyaXgsIDAsIGFyZWEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBtYXRyaXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBPdGhlcndpc2UgY29weSBvbmUgY3JvcHBlZCByb3cgYXQgYSB0aW1lLlxuICAgICAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCBoZWlnaHQ7IHkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG91dHB1dE9mZnNldCA9IHkgKiB3aWR0aDtcbiAgICAgICAgICAgICAgICBTeXN0ZW0uYXJyYXljb3B5KHRoaXMubHVtaW5hbmNlcywgaW5wdXRPZmZzZXQsIG1hdHJpeCwgb3V0cHV0T2Zmc2V0LCB3aWR0aCk7XG4gICAgICAgICAgICAgICAgaW5wdXRPZmZzZXQgKz0gdGhpcy5kYXRhV2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWF0cml4O1xuICAgICAgICB9XG4gICAgICAgIC8qQE92ZXJyaWRlKi9cbiAgICAgICAgaXNDcm9wU3VwcG9ydGVkKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLypAT3ZlcnJpZGUqL1xuICAgICAgICBjcm9wKGxlZnQgLyppbnQqLywgdG9wIC8qaW50Ki8sIHdpZHRoIC8qaW50Ki8sIGhlaWdodCAvKmludCovKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJHQkx1bWluYW5jZVNvdXJjZSh0aGlzLmx1bWluYW5jZXMsIHdpZHRoLCBoZWlnaHQsIHRoaXMuZGF0YVdpZHRoLCB0aGlzLmRhdGFIZWlnaHQsIHRoaXMubGVmdCArIGxlZnQsIHRoaXMudG9wICsgdG9wKTtcbiAgICAgICAgfVxuICAgICAgICBpbnZlcnQoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEludmVydGVkTHVtaW5hbmNlU291cmNlKHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSnVzdCB0byBtYWtlIGEgc2hvcnRjdXQgYmV0d2VlbiBKYXZhIGNvZGUgYW5kIFRTIGNvZGUuXG4gICAgICovXG4gICAgY2xhc3MgQ2hhcnNldCBleHRlbmRzIENoYXJhY3RlclNldEVDSSB7XG4gICAgICAgIHN0YXRpYyBmb3JOYW1lKG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldENoYXJhY3RlclNldEVDSUJ5TmFtZShuYW1lKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEp1c3QgdG8gbWFrZSBhIHNob3J0Y3V0IGJldHdlZW4gSmF2YSBjb2RlIGFuZCBUUyBjb2RlLlxuICAgICAqL1xuICAgIGNsYXNzIFN0YW5kYXJkQ2hhcnNldHMge1xuICAgIH1cbiAgICBTdGFuZGFyZENoYXJzZXRzLklTT184ODU5XzEgPSBDaGFyYWN0ZXJTZXRFQ0kuSVNPODg1OV8xO1xuXG4gICAgLypcbiAgICAqIENvcHlyaWdodCAyMDEzIFpYaW5nIGF1dGhvcnNcbiAgICAqXG4gICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICAgKlxuICAgICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAgICAqXG4gICAgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICAgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICAgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgICAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgICAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICAgICovXG4gICAgLyoqXG4gICAgICogQXp0ZWMgMkQgY29kZSByZXByZXNlbnRhdGlvblxuICAgICAqXG4gICAgICogQGF1dGhvciBSdXN0YW0gQWJkdWxsYWV2XG4gICAgICovXG4gICAgLypwdWJsaWMgZmluYWwqLyBjbGFzcyBBenRlY0NvZGUge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7QGNvZGUgdHJ1ZX0gaWYgY29tcGFjdCBpbnN0ZWFkIG9mIGZ1bGwgbW9kZVxuICAgICAgICAgKi9cbiAgICAgICAgaXNDb21wYWN0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29tcGFjdDtcbiAgICAgICAgfVxuICAgICAgICBzZXRDb21wYWN0KGNvbXBhY3QpIHtcbiAgICAgICAgICAgIHRoaXMuY29tcGFjdCA9IGNvbXBhY3Q7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gc2l6ZSBpbiBwaXhlbHMgKHdpZHRoIGFuZCBoZWlnaHQpXG4gICAgICAgICAqL1xuICAgICAgICBnZXRTaXplKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2l6ZTtcbiAgICAgICAgfVxuICAgICAgICBzZXRTaXplKHNpemUpIHtcbiAgICAgICAgICAgIHRoaXMuc2l6ZSA9IHNpemU7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gbnVtYmVyIG9mIGxldmVsc1xuICAgICAgICAgKi9cbiAgICAgICAgZ2V0TGF5ZXJzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGF5ZXJzO1xuICAgICAgICB9XG4gICAgICAgIHNldExheWVycyhsYXllcnMpIHtcbiAgICAgICAgICAgIHRoaXMubGF5ZXJzID0gbGF5ZXJzO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIG51bWJlciBvZiBkYXRhIGNvZGV3b3Jkc1xuICAgICAgICAgKi9cbiAgICAgICAgZ2V0Q29kZVdvcmRzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29kZVdvcmRzO1xuICAgICAgICB9XG4gICAgICAgIHNldENvZGVXb3Jkcyhjb2RlV29yZHMpIHtcbiAgICAgICAgICAgIHRoaXMuY29kZVdvcmRzID0gY29kZVdvcmRzO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHRoZSBzeW1ib2wgaW1hZ2VcbiAgICAgICAgICovXG4gICAgICAgIGdldE1hdHJpeCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1hdHJpeDtcbiAgICAgICAgfVxuICAgICAgICBzZXRNYXRyaXgobWF0cml4KSB7XG4gICAgICAgICAgICB0aGlzLm1hdHJpeCA9IG1hdHJpeDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNsYXNzIENvbGxlY3Rpb25zIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBzaW5nbGV0b25MaXN0KFQpIG1ldGhvZCBpcyB1c2VkIHRvIHJldHVybiBhbiBpbW11dGFibGUgbGlzdCBjb250YWluaW5nIG9ubHkgdGhlIHNwZWNpZmllZCBvYmplY3QuXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgc2luZ2xldG9uTGlzdChpdGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gW2l0ZW1dO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbWluKENvbGxlY3Rpb248PyBleHRlbmRzIFQ+LCBDb21wYXJhdG9yPD8gc3VwZXIgVD4pIG1ldGhvZCBpcyB1c2VkIHRvIHJldHVybiB0aGUgbWluaW11bSBlbGVtZW50IG9mIHRoZSBnaXZlbiBjb2xsZWN0aW9uLCBhY2NvcmRpbmcgdG8gdGhlIG9yZGVyIGluZHVjZWQgYnkgdGhlIHNwZWNpZmllZCBjb21wYXJhdG9yLlxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIG1pbihjb2xsZWN0aW9uLCBjb21wYXJhdG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gY29sbGVjdGlvbi5zb3J0KGNvbXBhcmF0b3IpWzBdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLypcbiAgICAqIENvcHlyaWdodCAyMDEzIFpYaW5nIGF1dGhvcnNcbiAgICAqXG4gICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICAgKlxuICAgICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAgICAqXG4gICAgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICAgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICAgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgICAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgICAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICAgICovXG4gICAgY2xhc3MgVG9rZW4ge1xuICAgICAgICBjb25zdHJ1Y3RvcihwcmV2aW91cykge1xuICAgICAgICAgICAgdGhpcy5wcmV2aW91cyA9IHByZXZpb3VzO1xuICAgICAgICB9XG4gICAgICAgIGdldFByZXZpb3VzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJldmlvdXM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKlxuICAgICogQ29weXJpZ2h0IDIwMTMgWlhpbmcgYXV0aG9yc1xuICAgICpcbiAgICAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gICAgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICAgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgICAqXG4gICAgKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICAgICpcbiAgICAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgICAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgICAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICAgICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICAgICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gICAgKi9cbiAgICAvKmZpbmFsKi8gY2xhc3MgU2ltcGxlVG9rZW4gZXh0ZW5kcyBUb2tlbiB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHByZXZpb3VzLCB2YWx1ZSwgYml0Q291bnQpIHtcbiAgICAgICAgICAgIHN1cGVyKHByZXZpb3VzKTtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuYml0Q291bnQgPSBiaXRDb3VudDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQE92ZXJyaWRlXG4gICAgICAgICAqL1xuICAgICAgICBhcHBlbmRUbyhiaXRBcnJheSwgdGV4dCkge1xuICAgICAgICAgICAgYml0QXJyYXkuYXBwZW5kQml0cyh0aGlzLnZhbHVlLCB0aGlzLmJpdENvdW50KTtcbiAgICAgICAgfVxuICAgICAgICBhZGQodmFsdWUsIGJpdENvdW50KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNpbXBsZVRva2VuKHRoaXMsIHZhbHVlLCBiaXRDb3VudCk7XG4gICAgICAgIH1cbiAgICAgICAgYWRkQmluYXJ5U2hpZnQoc3RhcnQsIGJ5dGVDb3VudCkge1xuICAgICAgICAgICAgLy8gbm8tb3AgY2FuJ3QgYmluYXJ5IHNoaWZ0IGEgc2ltcGxlIHRva2VuXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ2FkZEJpbmFyeVNoaWZ0IG9uIFNpbXBsZVRva2VuLCB0aGlzIHNpbXBseSByZXR1cm5zIGEgY29weSBvZiB0aGlzIHRva2VuJyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNpbXBsZVRva2VuKHRoaXMsIHN0YXJ0LCBieXRlQ291bnQpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAT3ZlcnJpZGVcbiAgICAgICAgICovXG4gICAgICAgIHRvU3RyaW5nKCkge1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gdGhpcy52YWx1ZSAmICgoMSA8PCB0aGlzLmJpdENvdW50KSAtIDEpO1xuICAgICAgICAgICAgdmFsdWUgfD0gMSA8PCB0aGlzLmJpdENvdW50O1xuICAgICAgICAgICAgcmV0dXJuICc8JyArIEludGVnZXIudG9CaW5hcnlTdHJpbmcodmFsdWUgfCAoMSA8PCB0aGlzLmJpdENvdW50KSkuc3Vic3RyaW5nKDEpICsgJz4nO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLypcbiAgICAqIENvcHlyaWdodCAyMDEzIFpYaW5nIGF1dGhvcnNcbiAgICAqXG4gICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICAgKlxuICAgICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAgICAqXG4gICAgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICAgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICAgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgICAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgICAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICAgICovXG4gICAgLypmaW5hbCovIGNsYXNzIEJpbmFyeVNoaWZ0VG9rZW4gZXh0ZW5kcyBTaW1wbGVUb2tlbiB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHByZXZpb3VzLCBiaW5hcnlTaGlmdFN0YXJ0LCBiaW5hcnlTaGlmdEJ5dGVDb3VudCkge1xuICAgICAgICAgICAgc3VwZXIocHJldmlvdXMsIDAsIDApO1xuICAgICAgICAgICAgdGhpcy5iaW5hcnlTaGlmdFN0YXJ0ID0gYmluYXJ5U2hpZnRTdGFydDtcbiAgICAgICAgICAgIHRoaXMuYmluYXJ5U2hpZnRCeXRlQ291bnQgPSBiaW5hcnlTaGlmdEJ5dGVDb3VudDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQE92ZXJyaWRlXG4gICAgICAgICAqL1xuICAgICAgICBhcHBlbmRUbyhiaXRBcnJheSwgdGV4dCkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmJpbmFyeVNoaWZ0Qnl0ZUNvdW50OyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gMCB8fCAoaSA9PT0gMzEgJiYgdGhpcy5iaW5hcnlTaGlmdEJ5dGVDb3VudCA8PSA2MikpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgbmVlZCBhIGhlYWRlciBiZWZvcmUgdGhlIGZpcnN0IGNoYXJhY3RlciwgYW5kIGJlZm9yZVxuICAgICAgICAgICAgICAgICAgICAvLyBjaGFyYWN0ZXIgMzEgd2hlbiB0aGUgdG90YWwgYnl0ZSBjb2RlIGlzIDw9IDYyXG4gICAgICAgICAgICAgICAgICAgIGJpdEFycmF5LmFwcGVuZEJpdHMoMzEsIDUpOyAvLyBCSU5BUllfU0hJRlRcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYmluYXJ5U2hpZnRCeXRlQ291bnQgPiA2Mikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYml0QXJyYXkuYXBwZW5kQml0cyh0aGlzLmJpbmFyeVNoaWZ0Qnl0ZUNvdW50IC0gMzEsIDE2KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAxIDw9IGJpbmFyeVNoaWZ0Qnl0ZUNvZGUgPD0gNjJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJpdEFycmF5LmFwcGVuZEJpdHMoTWF0aC5taW4odGhpcy5iaW5hcnlTaGlmdEJ5dGVDb3VudCwgMzEpLCA1KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIDMyIDw9IGJpbmFyeVNoaWZ0Q291bnQgPD0gNjIgYW5kIGkgPT0gMzFcbiAgICAgICAgICAgICAgICAgICAgICAgIGJpdEFycmF5LmFwcGVuZEJpdHModGhpcy5iaW5hcnlTaGlmdEJ5dGVDb3VudCAtIDMxLCA1KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBiaXRBcnJheS5hcHBlbmRCaXRzKHRleHRbdGhpcy5iaW5hcnlTaGlmdFN0YXJ0ICsgaV0sIDgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFkZEJpbmFyeVNoaWZ0KHN0YXJ0LCBieXRlQ291bnQpIHtcbiAgICAgICAgICAgIC8vIGludCBiaXRDb3VudCA9IChieXRlQ291bnQgKiA4KSArIChieXRlQ291bnQgPD0gMzEgPyAxMCA6IGJ5dGVDb3VudCA8PSA2MiA/IDIwIDogMjEpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBCaW5hcnlTaGlmdFRva2VuKHRoaXMsIHN0YXJ0LCBieXRlQ291bnQpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAT3ZlcnJpZGVcbiAgICAgICAgICovXG4gICAgICAgIHRvU3RyaW5nKCkge1xuICAgICAgICAgICAgcmV0dXJuICc8JyArIHRoaXMuYmluYXJ5U2hpZnRTdGFydCArICc6OicgKyAodGhpcy5iaW5hcnlTaGlmdFN0YXJ0ICsgdGhpcy5iaW5hcnlTaGlmdEJ5dGVDb3VudCAtIDEpICsgJz4nO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkQmluYXJ5U2hpZnQodG9rZW4sIHN0YXJ0LCBieXRlQ291bnQpIHtcbiAgICAgICAgLy8gaW50IGJpdENvdW50ID0gKGJ5dGVDb3VudCAqIDgpICsgKGJ5dGVDb3VudCA8PSAzMSA/IDEwIDogYnl0ZUNvdW50IDw9IDYyID8gMjAgOiAyMSk7XG4gICAgICAgIHJldHVybiBuZXcgQmluYXJ5U2hpZnRUb2tlbih0b2tlbiwgc3RhcnQsIGJ5dGVDb3VudCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFkZCh0b2tlbiwgdmFsdWUsIGJpdENvdW50KSB7XG4gICAgICAgIHJldHVybiBuZXcgU2ltcGxlVG9rZW4odG9rZW4sIHZhbHVlLCBiaXRDb3VudCk7XG4gICAgfVxuXG4gICAgY29uc3QgLypmaW5hbCovIE1PREVfTkFNRVMgPSBbXG4gICAgICAgICdVUFBFUicsXG4gICAgICAgICdMT1dFUicsXG4gICAgICAgICdESUdJVCcsXG4gICAgICAgICdNSVhFRCcsXG4gICAgICAgICdQVU5DVCdcbiAgICBdO1xuICAgIGNvbnN0IC8qZmluYWwqLyBNT0RFX1VQUEVSID0gMDsgLy8gNSBiaXRzXG4gICAgY29uc3QgLypmaW5hbCovIE1PREVfTE9XRVIgPSAxOyAvLyA1IGJpdHNcbiAgICBjb25zdCAvKmZpbmFsKi8gTU9ERV9ESUdJVCA9IDI7IC8vIDQgYml0c1xuICAgIGNvbnN0IC8qZmluYWwqLyBNT0RFX01JWEVEID0gMzsgLy8gNSBiaXRzXG4gICAgY29uc3QgLypmaW5hbCovIE1PREVfUFVOQ1QgPSA0OyAvLyA1IGJpdHNcbiAgICBjb25zdCBFTVBUWV9UT0tFTiA9IG5ldyBTaW1wbGVUb2tlbihudWxsLCAwLCAwKTtcblxuICAgIC8vIFRoZSBMYXRjaCBUYWJsZSBzaG93cywgZm9yIGVhY2ggcGFpciBvZiBNb2RlcywgdGhlIG9wdGltYWwgbWV0aG9kIGZvclxuICAgIC8vIGdldHRpbmcgZnJvbSBvbmUgbW9kZSB0byBhbm90aGVyLiAgSW4gdGhlIHdvcnN0IHBvc3NpYmxlIGNhc2UsIHRoaXMgY2FuXG4gICAgLy8gYmUgdXAgdG8gMTQgYml0cy4gIEluIHRoZSBiZXN0IHBvc3NpYmxlIGNhc2UsIHdlIGFyZSBhbHJlYWR5IHRoZXJlIVxuICAgIC8vIFRoZSBoaWdoIGhhbGYtd29yZCBvZiBlYWNoIGVudHJ5IGdpdmVzIHRoZSBudW1iZXIgb2YgYml0cy5cbiAgICAvLyBUaGUgbG93IGhhbGYtd29yZCBvZiBlYWNoIGVudHJ5IGFyZSB0aGUgYWN0dWFsIGJpdHMgbmVjZXNzYXJ5IHRvIGNoYW5nZVxuICAgIGNvbnN0IExBVENIX1RBQkxFID0gW1xuICAgICAgICBJbnQzMkFycmF5LmZyb20oW1xuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICg1IDw8IDE2KSArIDI4LFxuICAgICAgICAgICAgKDUgPDwgMTYpICsgMzAsXG4gICAgICAgICAgICAoNSA8PCAxNikgKyAyOSxcbiAgICAgICAgICAgICgxMCA8PCAxNikgKyAoMjkgPDwgNSkgKyAzMCAvLyBVUFBFUiAtPiBNSVhFRCAtPiBQVU5DVFxuICAgICAgICBdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFtcbiAgICAgICAgICAgICg5IDw8IDE2KSArICgzMCA8PCA0KSArIDE0LFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICg1IDw8IDE2KSArIDMwLFxuICAgICAgICAgICAgKDUgPDwgMTYpICsgMjksXG4gICAgICAgICAgICAoMTAgPDwgMTYpICsgKDI5IDw8IDUpICsgMzAgLy8gTE9XRVIgLT4gTUlYRUQgLT4gUFVOQ1RcbiAgICAgICAgXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbXG4gICAgICAgICAgICAoNCA8PCAxNikgKyAxNCxcbiAgICAgICAgICAgICg5IDw8IDE2KSArICgxNCA8PCA1KSArIDI4LFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICg5IDw8IDE2KSArICgxNCA8PCA1KSArIDI5LFxuICAgICAgICAgICAgKDE0IDw8IDE2KSArICgxNCA8PCAxMCkgKyAoMjkgPDwgNSkgKyAzMFxuICAgICAgICAgICAgLy8gRElHSVQgLT4gVVBQRVIgLT4gTUlYRUQgLT4gUFVOQ1RcbiAgICAgICAgXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbXG4gICAgICAgICAgICAoNSA8PCAxNikgKyAyOSxcbiAgICAgICAgICAgICg1IDw8IDE2KSArIDI4LFxuICAgICAgICAgICAgKDEwIDw8IDE2KSArICgyOSA8PCA1KSArIDMwLFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICg1IDw8IDE2KSArIDMwIC8vIE1JWEVEIC0+IFBVTkNUXG4gICAgICAgIF0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oW1xuICAgICAgICAgICAgKDUgPDwgMTYpICsgMzEsXG4gICAgICAgICAgICAoMTAgPDwgMTYpICsgKDMxIDw8IDUpICsgMjgsXG4gICAgICAgICAgICAoMTAgPDwgMTYpICsgKDMxIDw8IDUpICsgMzAsXG4gICAgICAgICAgICAoMTAgPDwgMTYpICsgKDMxIDw8IDUpICsgMjksXG4gICAgICAgICAgICAwXG4gICAgICAgIF0pXG4gICAgXTtcblxuICAgIGZ1bmN0aW9uIHN0YXRpY19TSElGVF9UQUJMRShTSElGVF9UQUJMRSkge1xuICAgICAgICBmb3IgKGxldCB0YWJsZSAvKkludDMyQXJyYXkqLyBvZiBTSElGVF9UQUJMRSkge1xuICAgICAgICAgICAgQXJyYXlzLmZpbGwodGFibGUsIC0xKTtcbiAgICAgICAgfVxuICAgICAgICBTSElGVF9UQUJMRVtNT0RFX1VQUEVSXVtNT0RFX1BVTkNUXSA9IDA7XG4gICAgICAgIFNISUZUX1RBQkxFW01PREVfTE9XRVJdW01PREVfUFVOQ1RdID0gMDtcbiAgICAgICAgU0hJRlRfVEFCTEVbTU9ERV9MT1dFUl1bTU9ERV9VUFBFUl0gPSAyODtcbiAgICAgICAgU0hJRlRfVEFCTEVbTU9ERV9NSVhFRF1bTU9ERV9QVU5DVF0gPSAwO1xuICAgICAgICBTSElGVF9UQUJMRVtNT0RFX0RJR0lUXVtNT0RFX1BVTkNUXSA9IDA7XG4gICAgICAgIFNISUZUX1RBQkxFW01PREVfRElHSVRdW01PREVfVVBQRVJdID0gMTU7XG4gICAgICAgIHJldHVybiBTSElGVF9UQUJMRTtcbiAgICB9XG4gICAgY29uc3QgLypmaW5hbCovIFNISUZUX1RBQkxFID0gc3RhdGljX1NISUZUX1RBQkxFKEFycmF5cy5jcmVhdGVJbnQzMkFycmF5KDYsIDYpKTsgLy8gbW9kZSBzaGlmdCBjb2RlcywgcGVyIHRhYmxlXG5cbiAgICAvKlxuICAgICAqIENvcHlyaWdodCAyMDEzIFpYaW5nIGF1dGhvcnNcbiAgICAgKlxuICAgICAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gICAgICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgICAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgICAqXG4gICAgICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAgICAgKlxuICAgICAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgICAgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICAgICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gICAgICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICAgICAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIFN0YXRlIHJlcHJlc2VudHMgYWxsIGluZm9ybWF0aW9uIGFib3V0IGEgc2VxdWVuY2UgbmVjZXNzYXJ5IHRvIGdlbmVyYXRlIHRoZSBjdXJyZW50IG91dHB1dC5cbiAgICAgKiBOb3RlIHRoYXQgYSBzdGF0ZSBpcyBpbW11dGFibGUuXG4gICAgICovXG4gICAgLypmaW5hbCovIGNsYXNzIFN0YXRlIHtcbiAgICAgICAgY29uc3RydWN0b3IodG9rZW4sIG1vZGUsIGJpbmFyeUJ5dGVzLCBiaXRDb3VudCkge1xuICAgICAgICAgICAgdGhpcy50b2tlbiA9IHRva2VuO1xuICAgICAgICAgICAgdGhpcy5tb2RlID0gbW9kZTtcbiAgICAgICAgICAgIHRoaXMuYmluYXJ5U2hpZnRCeXRlQ291bnQgPSBiaW5hcnlCeXRlcztcbiAgICAgICAgICAgIHRoaXMuYml0Q291bnQgPSBiaXRDb3VudDtcbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBtYXRjaCB0aGUgdG9rZW5cbiAgICAgICAgICAgIC8vIGludCBiaW5hcnlTaGlmdEJpdENvdW50ID0gKGJpbmFyeVNoaWZ0Qnl0ZUNvdW50ICogOCkgK1xuICAgICAgICAgICAgLy8gICAgKGJpbmFyeVNoaWZ0Qnl0ZUNvdW50ID09PSAwID8gMCA6XG4gICAgICAgICAgICAvLyAgICAgYmluYXJ5U2hpZnRCeXRlQ291bnQgPD0gMzEgPyAxMCA6XG4gICAgICAgICAgICAvLyAgICAgYmluYXJ5U2hpZnRCeXRlQ291bnQgPD0gNjIgPyAyMCA6IDIxKTtcbiAgICAgICAgICAgIC8vIGFzc2VydCB0aGlzLmJpdENvdW50ID09PSB0b2tlbi5nZXRUb3RhbEJpdENvdW50KCkgKyBiaW5hcnlTaGlmdEJpdENvdW50O1xuICAgICAgICB9XG4gICAgICAgIGdldE1vZGUoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tb2RlO1xuICAgICAgICB9XG4gICAgICAgIGdldFRva2VuKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9rZW47XG4gICAgICAgIH1cbiAgICAgICAgZ2V0QmluYXJ5U2hpZnRCeXRlQ291bnQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5iaW5hcnlTaGlmdEJ5dGVDb3VudDtcbiAgICAgICAgfVxuICAgICAgICBnZXRCaXRDb3VudCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJpdENvdW50O1xuICAgICAgICB9XG4gICAgICAgIC8vIENyZWF0ZSBhIG5ldyBzdGF0ZSByZXByZXNlbnRpbmcgdGhpcyBzdGF0ZSB3aXRoIGEgbGF0Y2ggdG8gYSAobm90XG4gICAgICAgIC8vIG5lY2Vzc2FyeSBkaWZmZXJlbnQpIG1vZGUsIGFuZCB0aGVuIGEgY29kZS5cbiAgICAgICAgbGF0Y2hBbmRBcHBlbmQobW9kZSwgdmFsdWUpIHtcbiAgICAgICAgICAgIC8vIGFzc2VydCBiaW5hcnlTaGlmdEJ5dGVDb3VudCA9PT0gMDtcbiAgICAgICAgICAgIGxldCBiaXRDb3VudCA9IHRoaXMuYml0Q291bnQ7XG4gICAgICAgICAgICBsZXQgdG9rZW4gPSB0aGlzLnRva2VuO1xuICAgICAgICAgICAgaWYgKG1vZGUgIT09IHRoaXMubW9kZSkge1xuICAgICAgICAgICAgICAgIGxldCBsYXRjaCA9IExBVENIX1RBQkxFW3RoaXMubW9kZV1bbW9kZV07XG4gICAgICAgICAgICAgICAgdG9rZW4gPSBhZGQodG9rZW4sIGxhdGNoICYgMHhmZmZmLCBsYXRjaCA+PiAxNik7XG4gICAgICAgICAgICAgICAgYml0Q291bnQgKz0gbGF0Y2ggPj4gMTY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgbGF0Y2hNb2RlQml0Q291bnQgPSBtb2RlID09PSBNT0RFX0RJR0lUID8gNCA6IDU7XG4gICAgICAgICAgICB0b2tlbiA9IGFkZCh0b2tlbiwgdmFsdWUsIGxhdGNoTW9kZUJpdENvdW50KTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU3RhdGUodG9rZW4sIG1vZGUsIDAsIGJpdENvdW50ICsgbGF0Y2hNb2RlQml0Q291bnQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENyZWF0ZSBhIG5ldyBzdGF0ZSByZXByZXNlbnRpbmcgdGhpcyBzdGF0ZSwgd2l0aCBhIHRlbXBvcmFyeSBzaGlmdFxuICAgICAgICAvLyB0byBhIGRpZmZlcmVudCBtb2RlIHRvIG91dHB1dCBhIHNpbmdsZSB2YWx1ZS5cbiAgICAgICAgc2hpZnRBbmRBcHBlbmQobW9kZSwgdmFsdWUpIHtcbiAgICAgICAgICAgIC8vIGFzc2VydCBiaW5hcnlTaGlmdEJ5dGVDb3VudCA9PT0gMCAmJiB0aGlzLm1vZGUgIT09IG1vZGU7XG4gICAgICAgICAgICBsZXQgdG9rZW4gPSB0aGlzLnRva2VuO1xuICAgICAgICAgICAgbGV0IHRoaXNNb2RlQml0Q291bnQgPSB0aGlzLm1vZGUgPT09IE1PREVfRElHSVQgPyA0IDogNTtcbiAgICAgICAgICAgIC8vIFNoaWZ0cyBleGlzdCBvbmx5IHRvIFVQUEVSIGFuZCBQVU5DVCwgYm90aCB3aXRoIHRva2VucyBzaXplIDUuXG4gICAgICAgICAgICB0b2tlbiA9IGFkZCh0b2tlbiwgU0hJRlRfVEFCTEVbdGhpcy5tb2RlXVttb2RlXSwgdGhpc01vZGVCaXRDb3VudCk7XG4gICAgICAgICAgICB0b2tlbiA9IGFkZCh0b2tlbiwgdmFsdWUsIDUpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTdGF0ZSh0b2tlbiwgdGhpcy5tb2RlLCAwLCB0aGlzLmJpdENvdW50ICsgdGhpc01vZGVCaXRDb3VudCArIDUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENyZWF0ZSBhIG5ldyBzdGF0ZSByZXByZXNlbnRpbmcgdGhpcyBzdGF0ZSwgYnV0IGFuIGFkZGl0aW9uYWwgY2hhcmFjdGVyXG4gICAgICAgIC8vIG91dHB1dCBpbiBCaW5hcnkgU2hpZnQgbW9kZS5cbiAgICAgICAgYWRkQmluYXJ5U2hpZnRDaGFyKGluZGV4KSB7XG4gICAgICAgICAgICBsZXQgdG9rZW4gPSB0aGlzLnRva2VuO1xuICAgICAgICAgICAgbGV0IG1vZGUgPSB0aGlzLm1vZGU7XG4gICAgICAgICAgICBsZXQgYml0Q291bnQgPSB0aGlzLmJpdENvdW50O1xuICAgICAgICAgICAgaWYgKHRoaXMubW9kZSA9PT0gTU9ERV9QVU5DVCB8fCB0aGlzLm1vZGUgPT09IE1PREVfRElHSVQpIHtcbiAgICAgICAgICAgICAgICAvLyBhc3NlcnQgYmluYXJ5U2hpZnRCeXRlQ291bnQgPT09IDA7XG4gICAgICAgICAgICAgICAgbGV0IGxhdGNoID0gTEFUQ0hfVEFCTEVbbW9kZV1bTU9ERV9VUFBFUl07XG4gICAgICAgICAgICAgICAgdG9rZW4gPSBhZGQodG9rZW4sIGxhdGNoICYgMHhmZmZmLCBsYXRjaCA+PiAxNik7XG4gICAgICAgICAgICAgICAgYml0Q291bnQgKz0gbGF0Y2ggPj4gMTY7XG4gICAgICAgICAgICAgICAgbW9kZSA9IE1PREVfVVBQRVI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZGVsdGFCaXRDb3VudCA9IHRoaXMuYmluYXJ5U2hpZnRCeXRlQ291bnQgPT09IDAgfHwgdGhpcy5iaW5hcnlTaGlmdEJ5dGVDb3VudCA9PT0gMzFcbiAgICAgICAgICAgICAgICA/IDE4XG4gICAgICAgICAgICAgICAgOiB0aGlzLmJpbmFyeVNoaWZ0Qnl0ZUNvdW50ID09PSA2MlxuICAgICAgICAgICAgICAgICAgICA/IDlcbiAgICAgICAgICAgICAgICAgICAgOiA4O1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IG5ldyBTdGF0ZSh0b2tlbiwgbW9kZSwgdGhpcy5iaW5hcnlTaGlmdEJ5dGVDb3VudCArIDEsIGJpdENvdW50ICsgZGVsdGFCaXRDb3VudCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0LmJpbmFyeVNoaWZ0Qnl0ZUNvdW50ID09PSAyMDQ3ICsgMzEpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgc3RyaW5nIGlzIGFzIGxvbmcgYXMgaXQncyBhbGxvd2VkIHRvIGJlLiAgV2Ugc2hvdWxkIGVuZCBpdC5cbiAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuZW5kQmluYXJ5U2hpZnQoaW5kZXggKyAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ3JlYXRlIHRoZSBzdGF0ZSBpZGVudGljYWwgdG8gdGhpcyBvbmUsIGJ1dCB3ZSBhcmUgbm8gbG9uZ2VyIGluXG4gICAgICAgIC8vIEJpbmFyeSBTaGlmdCBtb2RlLlxuICAgICAgICBlbmRCaW5hcnlTaGlmdChpbmRleCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuYmluYXJ5U2hpZnRCeXRlQ291bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCB0b2tlbiA9IHRoaXMudG9rZW47XG4gICAgICAgICAgICB0b2tlbiA9IGFkZEJpbmFyeVNoaWZ0KHRva2VuLCBpbmRleCAtIHRoaXMuYmluYXJ5U2hpZnRCeXRlQ291bnQsIHRoaXMuYmluYXJ5U2hpZnRCeXRlQ291bnQpO1xuICAgICAgICAgICAgLy8gYXNzZXJ0IHRva2VuLmdldFRvdGFsQml0Q291bnQoKSA9PT0gdGhpcy5iaXRDb3VudDtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU3RhdGUodG9rZW4sIHRoaXMubW9kZSwgMCwgdGhpcy5iaXRDb3VudCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmV0dXJucyB0cnVlIGlmIFwidGhpc1wiIHN0YXRlIGlzIGJldHRlciAoZXF1YWw6IG9yKSB0byBiZSBpbiB0aGFuIFwidGhhdFwiXG4gICAgICAgIC8vIHN0YXRlIHVuZGVyIGFsbCBwb3NzaWJsZSBjaXJjdW1zdGFuY2VzLlxuICAgICAgICBpc0JldHRlclRoYW5PckVxdWFsVG8ob3RoZXIpIHtcbiAgICAgICAgICAgIGxldCBuZXdNb2RlQml0Q291bnQgPSB0aGlzLmJpdENvdW50ICsgKExBVENIX1RBQkxFW3RoaXMubW9kZV1bb3RoZXIubW9kZV0gPj4gMTYpO1xuICAgICAgICAgICAgaWYgKHRoaXMuYmluYXJ5U2hpZnRCeXRlQ291bnQgPCBvdGhlci5iaW5hcnlTaGlmdEJ5dGVDb3VudCkge1xuICAgICAgICAgICAgICAgIC8vIGFkZCBhZGRpdGlvbmFsIEIvUyBlbmNvZGluZyBjb3N0IG9mIG90aGVyLCBpZiBhbnlcbiAgICAgICAgICAgICAgICBuZXdNb2RlQml0Q291bnQgKz1cbiAgICAgICAgICAgICAgICAgICAgU3RhdGUuY2FsY3VsYXRlQmluYXJ5U2hpZnRDb3N0KG90aGVyKSAtXG4gICAgICAgICAgICAgICAgICAgICAgICBTdGF0ZS5jYWxjdWxhdGVCaW5hcnlTaGlmdENvc3QodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLmJpbmFyeVNoaWZ0Qnl0ZUNvdW50ID4gb3RoZXIuYmluYXJ5U2hpZnRCeXRlQ291bnQgJiZcbiAgICAgICAgICAgICAgICBvdGhlci5iaW5hcnlTaGlmdEJ5dGVDb3VudCA+IDApIHtcbiAgICAgICAgICAgICAgICAvLyBtYXhpbXVtIHBvc3NpYmxlIGFkZGl0aW9uYWwgY29zdCAoaXQ6IGgpXG4gICAgICAgICAgICAgICAgbmV3TW9kZUJpdENvdW50ICs9IDEwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ld01vZGVCaXRDb3VudCA8PSBvdGhlci5iaXRDb3VudDtcbiAgICAgICAgfVxuICAgICAgICB0b0JpdEFycmF5KHRleHQpIHtcbiAgICAgICAgICAgIC8vIFJldmVyc2UgdGhlIHRva2Vucywgc28gdGhhdCB0aGV5IGFyZSBpbiB0aGUgb3JkZXIgdGhhdCB0aGV5IHNob3VsZFxuICAgICAgICAgICAgLy8gYmUgb3V0cHV0XG4gICAgICAgICAgICBsZXQgc3ltYm9scyA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgdG9rZW4gPSB0aGlzLmVuZEJpbmFyeVNoaWZ0KHRleHQubGVuZ3RoKS50b2tlbjsgdG9rZW4gIT09IG51bGw7IHRva2VuID0gdG9rZW4uZ2V0UHJldmlvdXMoKSkge1xuICAgICAgICAgICAgICAgIHN5bWJvbHMudW5zaGlmdCh0b2tlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgYml0QXJyYXkgPSBuZXcgQml0QXJyYXkoKTtcbiAgICAgICAgICAgIC8vIEFkZCBlYWNoIHRva2VuIHRvIHRoZSByZXN1bHQuXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHN5bWJvbCBvZiBzeW1ib2xzKSB7XG4gICAgICAgICAgICAgICAgc3ltYm9sLmFwcGVuZFRvKGJpdEFycmF5LCB0ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGFzc2VydCBiaXRBcnJheS5nZXRTaXplKCkgPT09IHRoaXMuYml0Q291bnQ7XG4gICAgICAgICAgICByZXR1cm4gYml0QXJyYXk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBPdmVycmlkZVxuICAgICAgICAgKi9cbiAgICAgICAgdG9TdHJpbmcoKSB7XG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nVXRpbHMuZm9ybWF0KCclcyBiaXRzPSVkIGJ5dGVzPSVkJywgTU9ERV9OQU1FU1t0aGlzLm1vZGVdLCB0aGlzLmJpdENvdW50LCB0aGlzLmJpbmFyeVNoaWZ0Qnl0ZUNvdW50KTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgY2FsY3VsYXRlQmluYXJ5U2hpZnRDb3N0KHN0YXRlKSB7XG4gICAgICAgICAgICBpZiAoc3RhdGUuYmluYXJ5U2hpZnRCeXRlQ291bnQgPiA2Mikge1xuICAgICAgICAgICAgICAgIHJldHVybiAyMTsgLy8gQi9TIHdpdGggZXh0ZW5kZWQgbGVuZ3RoXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RhdGUuYmluYXJ5U2hpZnRCeXRlQ291bnQgPiAzMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAyMDsgLy8gdHdvIEIvU1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0YXRlLmJpbmFyeVNoaWZ0Qnl0ZUNvdW50ID4gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAxMDsgLy8gb25lIEIvU1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgU3RhdGUuSU5JVElBTF9TVEFURSA9IG5ldyBTdGF0ZShFTVBUWV9UT0tFTiwgTU9ERV9VUFBFUiwgMCwgMCk7XG5cbiAgICBmdW5jdGlvbiBzdGF0aWNfQ0hBUl9NQVAoQ0hBUl9NQVApIHtcbiAgICAgICAgY29uc3Qgc3BhY2VDaGFyQ29kZSA9IFN0cmluZ1V0aWxzLmdldENoYXJDb2RlKCcgJyk7XG4gICAgICAgIGNvbnN0IHBvaW50Q2hhckNvZGUgPSBTdHJpbmdVdGlscy5nZXRDaGFyQ29kZSgnLicpO1xuICAgICAgICBjb25zdCBjb21tYUNoYXJDb2RlID0gU3RyaW5nVXRpbHMuZ2V0Q2hhckNvZGUoJywnKTtcbiAgICAgICAgQ0hBUl9NQVBbTU9ERV9VUFBFUl1bc3BhY2VDaGFyQ29kZV0gPSAxO1xuICAgICAgICBjb25zdCB6VXBwZXJDaGFyQ29kZSA9IFN0cmluZ1V0aWxzLmdldENoYXJDb2RlKCdaJyk7XG4gICAgICAgIGNvbnN0IGFVcHBlckNoYXJDb2RlID0gU3RyaW5nVXRpbHMuZ2V0Q2hhckNvZGUoJ0EnKTtcbiAgICAgICAgZm9yIChsZXQgYyA9IGFVcHBlckNoYXJDb2RlOyBjIDw9IHpVcHBlckNoYXJDb2RlOyBjKyspIHtcbiAgICAgICAgICAgIENIQVJfTUFQW01PREVfVVBQRVJdW2NdID0gYyAtIGFVcHBlckNoYXJDb2RlICsgMjtcbiAgICAgICAgfVxuICAgICAgICBDSEFSX01BUFtNT0RFX0xPV0VSXVtzcGFjZUNoYXJDb2RlXSA9IDE7XG4gICAgICAgIGNvbnN0IHpMb3dlckNoYXJDb2RlID0gU3RyaW5nVXRpbHMuZ2V0Q2hhckNvZGUoJ3onKTtcbiAgICAgICAgY29uc3QgYUxvd2VyQ2hhckNvZGUgPSBTdHJpbmdVdGlscy5nZXRDaGFyQ29kZSgnYScpO1xuICAgICAgICBmb3IgKGxldCBjID0gYUxvd2VyQ2hhckNvZGU7IGMgPD0gekxvd2VyQ2hhckNvZGU7IGMrKykge1xuICAgICAgICAgICAgQ0hBUl9NQVBbTU9ERV9MT1dFUl1bY10gPSBjIC0gYUxvd2VyQ2hhckNvZGUgKyAyO1xuICAgICAgICB9XG4gICAgICAgIENIQVJfTUFQW01PREVfRElHSVRdW3NwYWNlQ2hhckNvZGVdID0gMTtcbiAgICAgICAgY29uc3QgbmluZUNoYXJDb2RlID0gU3RyaW5nVXRpbHMuZ2V0Q2hhckNvZGUoJzknKTtcbiAgICAgICAgY29uc3QgemVyb0NoYXJDb2RlID0gU3RyaW5nVXRpbHMuZ2V0Q2hhckNvZGUoJzAnKTtcbiAgICAgICAgZm9yIChsZXQgYyA9IHplcm9DaGFyQ29kZTsgYyA8PSBuaW5lQ2hhckNvZGU7IGMrKykge1xuICAgICAgICAgICAgQ0hBUl9NQVBbTU9ERV9ESUdJVF1bY10gPSBjIC0gemVyb0NoYXJDb2RlICsgMjtcbiAgICAgICAgfVxuICAgICAgICBDSEFSX01BUFtNT0RFX0RJR0lUXVtjb21tYUNoYXJDb2RlXSA9IDEyO1xuICAgICAgICBDSEFSX01BUFtNT0RFX0RJR0lUXVtwb2ludENoYXJDb2RlXSA9IDEzO1xuICAgICAgICBjb25zdCBtaXhlZFRhYmxlID0gW1xuICAgICAgICAgICAgJ1xceDAwJyxcbiAgICAgICAgICAgICcgJyxcbiAgICAgICAgICAgICdcXHgwMScsXG4gICAgICAgICAgICAnXFx4MDInLFxuICAgICAgICAgICAgJ1xceDAzJyxcbiAgICAgICAgICAgICdcXHgwNCcsXG4gICAgICAgICAgICAnXFx4MDUnLFxuICAgICAgICAgICAgJ1xceDA2JyxcbiAgICAgICAgICAgICdcXHgwNycsXG4gICAgICAgICAgICAnXFxiJyxcbiAgICAgICAgICAgICdcXHQnLFxuICAgICAgICAgICAgJ1xcbicsXG4gICAgICAgICAgICAnXFx4MGInLFxuICAgICAgICAgICAgJ1xcZicsXG4gICAgICAgICAgICAnXFxyJyxcbiAgICAgICAgICAgICdcXHgxYicsXG4gICAgICAgICAgICAnXFx4MWMnLFxuICAgICAgICAgICAgJ1xceDFkJyxcbiAgICAgICAgICAgICdcXHgxZScsXG4gICAgICAgICAgICAnXFx4MWYnLFxuICAgICAgICAgICAgJ0AnLFxuICAgICAgICAgICAgJ1xcXFwnLFxuICAgICAgICAgICAgJ14nLFxuICAgICAgICAgICAgJ18nLFxuICAgICAgICAgICAgJ2AnLFxuICAgICAgICAgICAgJ3wnLFxuICAgICAgICAgICAgJ34nLFxuICAgICAgICAgICAgJ1xceDdmJ1xuICAgICAgICBdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1peGVkVGFibGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIENIQVJfTUFQW01PREVfTUlYRURdW1N0cmluZ1V0aWxzLmdldENoYXJDb2RlKG1peGVkVGFibGVbaV0pXSA9IGk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHVuY3RUYWJsZSA9IFtcbiAgICAgICAgICAgICdcXHgwMCcsXG4gICAgICAgICAgICAnXFxyJyxcbiAgICAgICAgICAgICdcXHgwMCcsXG4gICAgICAgICAgICAnXFx4MDAnLFxuICAgICAgICAgICAgJ1xceDAwJyxcbiAgICAgICAgICAgICdcXHgwMCcsXG4gICAgICAgICAgICAnIScsXG4gICAgICAgICAgICAnXFwnJyxcbiAgICAgICAgICAgICcjJyxcbiAgICAgICAgICAgICckJyxcbiAgICAgICAgICAgICclJyxcbiAgICAgICAgICAgICcmJyxcbiAgICAgICAgICAgICdcXCcnLFxuICAgICAgICAgICAgJygnLFxuICAgICAgICAgICAgJyknLFxuICAgICAgICAgICAgJyonLFxuICAgICAgICAgICAgJysnLFxuICAgICAgICAgICAgJywnLFxuICAgICAgICAgICAgJy0nLFxuICAgICAgICAgICAgJy4nLFxuICAgICAgICAgICAgJy8nLFxuICAgICAgICAgICAgJzonLFxuICAgICAgICAgICAgJzsnLFxuICAgICAgICAgICAgJzwnLFxuICAgICAgICAgICAgJz0nLFxuICAgICAgICAgICAgJz4nLFxuICAgICAgICAgICAgJz8nLFxuICAgICAgICAgICAgJ1snLFxuICAgICAgICAgICAgJ10nLFxuICAgICAgICAgICAgJ3snLFxuICAgICAgICAgICAgJ30nXG4gICAgICAgIF07XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHVuY3RUYWJsZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKFN0cmluZ1V0aWxzLmdldENoYXJDb2RlKHB1bmN0VGFibGVbaV0pID4gMCkge1xuICAgICAgICAgICAgICAgIENIQVJfTUFQW01PREVfUFVOQ1RdW1N0cmluZ1V0aWxzLmdldENoYXJDb2RlKHB1bmN0VGFibGVbaV0pXSA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIENIQVJfTUFQO1xuICAgIH1cbiAgICBjb25zdCBDSEFSX01BUCA9IHN0YXRpY19DSEFSX01BUChBcnJheXMuY3JlYXRlSW50MzJBcnJheSg1LCAyNTYpKTtcblxuICAgIC8qXG4gICAgICogQ29weXJpZ2h0IDIwMTMgWlhpbmcgYXV0aG9yc1xuICAgICAqXG4gICAgICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgICAgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICAgICpcbiAgICAgKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICAgICAqXG4gICAgICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICAgICAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgICAgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgICAgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gICAgICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gICAgICovXG4gICAgLyoqXG4gICAgICogVGhpcyBwcm9kdWNlcyBuZWFybHkgb3B0aW1hbCBlbmNvZGluZ3Mgb2YgdGV4dCBpbnRvIHRoZSBmaXJzdC1sZXZlbCBvZlxuICAgICAqIGVuY29kaW5nIHVzZWQgYnkgQXp0ZWMgY29kZS5cbiAgICAgKlxuICAgICAqIEl0IHVzZXMgYSBkeW5hbWljIGFsZ29yaXRobS4gIEZvciBlYWNoIHByZWZpeCBvZiB0aGUgc3RyaW5nLCBpdCBkZXRlcm1pbmVzXG4gICAgICogYSBzZXQgb2YgZW5jb2RpbmdzIHRoYXQgY291bGQgbGVhZCB0byB0aGlzIHByZWZpeC4gIFdlIHJlcGVhdGVkbHkgYWRkIGFcbiAgICAgKiBjaGFyYWN0ZXIgYW5kIGdlbmVyYXRlIGEgbmV3IHNldCBvZiBvcHRpbWFsIGVuY29kaW5ncyB1bnRpbCB3ZSBoYXZlIHJlYWRcbiAgICAgKiB0aHJvdWdoIHRoZSBlbnRpcmUgaW5wdXQuXG4gICAgICpcbiAgICAgKiBAYXV0aG9yIEZyYW5rIFllbGxpblxuICAgICAqIEBhdXRob3IgUnVzdGFtIEFiZHVsbGFldlxuICAgICAqL1xuICAgIC8qcHVibGljIGZpbmFsKi8gY2xhc3MgSGlnaExldmVsRW5jb2RlciB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHRleHQpIHtcbiAgICAgICAgICAgIHRoaXMudGV4dCA9IHRleHQ7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gdGV4dCByZXByZXNlbnRlZCBieSB0aGlzIGVuY29kZXIgZW5jb2RlZCBhcyBhIHtAbGluayBCaXRBcnJheX1cbiAgICAgICAgICovXG4gICAgICAgIGVuY29kZSgpIHtcbiAgICAgICAgICAgIGNvbnN0IHNwYWNlQ2hhckNvZGUgPSBTdHJpbmdVdGlscy5nZXRDaGFyQ29kZSgnICcpO1xuICAgICAgICAgICAgY29uc3QgbGluZUJyZWFrQ2hhckNvZGUgPSBTdHJpbmdVdGlscy5nZXRDaGFyQ29kZSgnXFxuJyk7XG4gICAgICAgICAgICBsZXQgc3RhdGVzID0gQ29sbGVjdGlvbnMuc2luZ2xldG9uTGlzdChTdGF0ZS5JTklUSUFMX1NUQVRFKTtcbiAgICAgICAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCB0aGlzLnRleHQubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHBhaXJDb2RlO1xuICAgICAgICAgICAgICAgIGxldCBuZXh0Q2hhciA9IGluZGV4ICsgMSA8IHRoaXMudGV4dC5sZW5ndGggPyB0aGlzLnRleHRbaW5kZXggKyAxXSA6IDA7XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0aGlzLnRleHRbaW5kZXhdKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgU3RyaW5nVXRpbHMuZ2V0Q2hhckNvZGUoJ1xccicpOlxuICAgICAgICAgICAgICAgICAgICAgICAgcGFpckNvZGUgPSBuZXh0Q2hhciA9PT0gbGluZUJyZWFrQ2hhckNvZGUgPyAyIDogMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFN0cmluZ1V0aWxzLmdldENoYXJDb2RlKCcuJyk6XG4gICAgICAgICAgICAgICAgICAgICAgICBwYWlyQ29kZSA9IG5leHRDaGFyID09PSBzcGFjZUNoYXJDb2RlID8gMyA6IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBTdHJpbmdVdGlscy5nZXRDaGFyQ29kZSgnLCcpOlxuICAgICAgICAgICAgICAgICAgICAgICAgcGFpckNvZGUgPSBuZXh0Q2hhciA9PT0gc3BhY2VDaGFyQ29kZSA/IDQgOiAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgU3RyaW5nVXRpbHMuZ2V0Q2hhckNvZGUoJzonKTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhaXJDb2RlID0gbmV4dENoYXIgPT09IHNwYWNlQ2hhckNvZGUgPyA1IDogMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgcGFpckNvZGUgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocGFpckNvZGUgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgb25lIG9mIHRoZSBmb3VyIHNwZWNpYWwgUFVOQ1QgcGFpcnMuICBUcmVhdCB0aGVtIHNwZWNpYWxseS5cbiAgICAgICAgICAgICAgICAgICAgLy8gR2V0IGEgbmV3IHNldCBvZiBzdGF0ZXMgZm9yIHRoZSB0d28gbmV3IGNoYXJhY3RlcnMuXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlcyA9IEhpZ2hMZXZlbEVuY29kZXIudXBkYXRlU3RhdGVMaXN0Rm9yUGFpcihzdGF0ZXMsIGluZGV4LCBwYWlyQ29kZSk7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBHZXQgYSBuZXcgc2V0IG9mIHN0YXRlcyBmb3IgdGhlIG5ldyBjaGFyYWN0ZXIuXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlcyA9IHRoaXMudXBkYXRlU3RhdGVMaXN0Rm9yQ2hhcihzdGF0ZXMsIGluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBXZSBhcmUgbGVmdCB3aXRoIGEgc2V0IG9mIHN0YXRlcy4gIEZpbmQgdGhlIHNob3J0ZXN0IG9uZS5cbiAgICAgICAgICAgIGNvbnN0IG1pblN0YXRlID0gQ29sbGVjdGlvbnMubWluKHN0YXRlcywgKGEsIGIpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYS5nZXRCaXRDb3VudCgpIC0gYi5nZXRCaXRDb3VudCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBDb252ZXJ0IGl0IHRvIGEgYml0IGFycmF5LCBhbmQgcmV0dXJuLlxuICAgICAgICAgICAgcmV0dXJuIG1pblN0YXRlLnRvQml0QXJyYXkodGhpcy50ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXZSB1cGRhdGUgYSBzZXQgb2Ygc3RhdGVzIGZvciBhIG5ldyBjaGFyYWN0ZXIgYnkgdXBkYXRpbmcgZWFjaCBzdGF0ZVxuICAgICAgICAvLyBmb3IgdGhlIG5ldyBjaGFyYWN0ZXIsIG1lcmdpbmcgdGhlIHJlc3VsdHMsIGFuZCB0aGVuIHJlbW92aW5nIHRoZVxuICAgICAgICAvLyBub24tb3B0aW1hbCBzdGF0ZXMuXG4gICAgICAgIHVwZGF0ZVN0YXRlTGlzdEZvckNoYXIoc3RhdGVzLCBpbmRleCkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBzdGF0ZSAvKlN0YXRlKi8gb2Ygc3RhdGVzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZUZvckNoYXIoc3RhdGUsIGluZGV4LCByZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEhpZ2hMZXZlbEVuY29kZXIuc2ltcGxpZnlTdGF0ZXMocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZXR1cm4gYSBzZXQgb2Ygc3RhdGVzIHRoYXQgcmVwcmVzZW50IHRoZSBwb3NzaWJsZSB3YXlzIG9mIHVwZGF0aW5nIHRoaXNcbiAgICAgICAgLy8gc3RhdGUgZm9yIHRoZSBuZXh0IGNoYXJhY3Rlci4gIFRoZSByZXN1bHRpbmcgc2V0IG9mIHN0YXRlcyBhcmUgYWRkZWQgdG9cbiAgICAgICAgLy8gdGhlIFwicmVzdWx0XCIgbGlzdC5cbiAgICAgICAgdXBkYXRlU3RhdGVGb3JDaGFyKHN0YXRlLCBpbmRleCwgcmVzdWx0KSB7XG4gICAgICAgICAgICBsZXQgY2ggPSAodGhpcy50ZXh0W2luZGV4XSAmIDB4ZmYpO1xuICAgICAgICAgICAgbGV0IGNoYXJJbkN1cnJlbnRUYWJsZSA9IENIQVJfTUFQW3N0YXRlLmdldE1vZGUoKV1bY2hdID4gMDtcbiAgICAgICAgICAgIGxldCBzdGF0ZU5vQmluYXJ5ID0gbnVsbDtcbiAgICAgICAgICAgIGZvciAobGV0IG1vZGUgLyppbnQqLyA9IDA7IG1vZGUgPD0gTU9ERV9QVU5DVDsgbW9kZSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNoYXJJbk1vZGUgPSBDSEFSX01BUFttb2RlXVtjaF07XG4gICAgICAgICAgICAgICAgaWYgKGNoYXJJbk1vZGUgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZU5vQmluYXJ5ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9ubHkgY3JlYXRlIHN0YXRlTm9CaW5hcnkgdGhlIGZpcnN0IHRpbWUgaXQncyByZXF1aXJlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlTm9CaW5hcnkgPSBzdGF0ZS5lbmRCaW5hcnlTaGlmdChpbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gVHJ5IGdlbmVyYXRpbmcgdGhlIGNoYXJhY3RlciBieSBsYXRjaGluZyB0byBpdHMgbW9kZVxuICAgICAgICAgICAgICAgICAgICBpZiAoIWNoYXJJbkN1cnJlbnRUYWJsZSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZSA9PT0gc3RhdGUuZ2V0TW9kZSgpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlID09PSBNT0RFX0RJR0lUKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgY2hhcmFjdGVyIGlzIGluIHRoZSBjdXJyZW50IHRhYmxlLCB3ZSBkb24ndCB3YW50IHRvIGxhdGNoIHRvXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhbnkgb3RoZXIgbW9kZSBleGNlcHQgcG9zc2libHkgZGlnaXQgKHdoaWNoIHVzZXMgb25seSA0IGJpdHMpLiAgQW55XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvdGhlciBsYXRjaCB3b3VsZCBiZSBlcXVhbGx5IHN1Y2Nlc3NmdWwgKmFmdGVyKiB0aGlzIGNoYXJhY3RlciwgYW5kXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzbyB3b3VsZG4ndCBzYXZlIGFueSBiaXRzLlxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbGF0Y2hTdGF0ZSA9IHN0YXRlTm9CaW5hcnkubGF0Y2hBbmRBcHBlbmQobW9kZSwgY2hhckluTW9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChsYXRjaFN0YXRlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBUcnkgZ2VuZXJhdGluZyB0aGUgY2hhcmFjdGVyIGJ5IHN3aXRjaGluZyB0byBpdHMgbW9kZS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjaGFySW5DdXJyZW50VGFibGUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIFNISUZUX1RBQkxFW3N0YXRlLmdldE1vZGUoKV1bbW9kZV0gPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSXQgbmV2ZXIgbWFrZXMgc2Vuc2UgdG8gdGVtcG9yYXJpbHkgc2hpZnQgdG8gYW5vdGhlciBtb2RlIGlmIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2hhcmFjdGVyIGV4aXN0cyBpbiB0aGUgY3VycmVudCBtb2RlLiAgVGhhdCBjYW4gbmV2ZXIgc2F2ZSBiaXRzLlxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2hpZnRTdGF0ZSA9IHN0YXRlTm9CaW5hcnkuc2hpZnRBbmRBcHBlbmQobW9kZSwgY2hhckluTW9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChzaGlmdFN0YXRlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdGF0ZS5nZXRCaW5hcnlTaGlmdEJ5dGVDb3VudCgpID4gMCB8fFxuICAgICAgICAgICAgICAgIENIQVJfTUFQW3N0YXRlLmdldE1vZGUoKV1bY2hdID09PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gSXQncyBuZXZlciB3b3J0aHdoaWxlIHRvIGdvIGludG8gYmluYXJ5IHNoaWZ0IG1vZGUgaWYgeW91J3JlIG5vdCBhbHJlYWR5XG4gICAgICAgICAgICAgICAgLy8gaW4gYmluYXJ5IHNoaWZ0IG1vZGUsIGFuZCB0aGUgY2hhcmFjdGVyIGV4aXN0cyBpbiB5b3VyIGN1cnJlbnQgbW9kZS5cbiAgICAgICAgICAgICAgICAvLyBUaGF0IGNhbiBuZXZlciBzYXZlIGJpdHMgb3ZlciBqdXN0IG91dHB1dHRpbmcgdGhlIGNoYXIgaW4gdGhlIGN1cnJlbnQgbW9kZS5cbiAgICAgICAgICAgICAgICBsZXQgYmluYXJ5U3RhdGUgPSBzdGF0ZS5hZGRCaW5hcnlTaGlmdENoYXIoaW5kZXgpO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGJpbmFyeVN0YXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgdXBkYXRlU3RhdGVMaXN0Rm9yUGFpcihzdGF0ZXMsIGluZGV4LCBwYWlyQ29kZSkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBzdGF0ZSAvKlN0YXRlKi8gb2Ygc3RhdGVzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZUZvclBhaXIoc3RhdGUsIGluZGV4LCBwYWlyQ29kZSwgcmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNpbXBsaWZ5U3RhdGVzKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIHVwZGF0ZVN0YXRlRm9yUGFpcihzdGF0ZSwgaW5kZXgsIHBhaXJDb2RlLCByZXN1bHQpIHtcbiAgICAgICAgICAgIGxldCBzdGF0ZU5vQmluYXJ5ID0gc3RhdGUuZW5kQmluYXJ5U2hpZnQoaW5kZXgpO1xuICAgICAgICAgICAgLy8gUG9zc2liaWxpdHkgMS4gIExhdGNoIHRvIEMuTU9ERV9QVU5DVCwgYW5kIHRoZW4gYXBwZW5kIHRoaXMgY29kZVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goc3RhdGVOb0JpbmFyeS5sYXRjaEFuZEFwcGVuZChNT0RFX1BVTkNULCBwYWlyQ29kZSkpO1xuICAgICAgICAgICAgaWYgKHN0YXRlLmdldE1vZGUoKSAhPT0gTU9ERV9QVU5DVCkge1xuICAgICAgICAgICAgICAgIC8vIFBvc3NpYmlsaXR5IDIuICBTaGlmdCB0byBDLk1PREVfUFVOQ1QsIGFuZCB0aGVuIGFwcGVuZCB0aGlzIGNvZGUuXG4gICAgICAgICAgICAgICAgLy8gRXZlcnkgc3RhdGUgZXhjZXB0IEMuTU9ERV9QVU5DVCAoaGFuZGxlZCBhYm92ZSkgY2FuIHNoaWZ0XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goc3RhdGVOb0JpbmFyeS5zaGlmdEFuZEFwcGVuZChNT0RFX1BVTkNULCBwYWlyQ29kZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhaXJDb2RlID09PSAzIHx8IHBhaXJDb2RlID09PSA0KSB7XG4gICAgICAgICAgICAgICAgLy8gYm90aCBjaGFyYWN0ZXJzIGFyZSBpbiBESUdJVFMuICBTb21ldGltZXMgYmV0dGVyIHRvIGp1c3QgYWRkIHR3byBkaWdpdHNcbiAgICAgICAgICAgICAgICBsZXQgZGlnaXRTdGF0ZSA9IHN0YXRlTm9CaW5hcnlcbiAgICAgICAgICAgICAgICAgICAgLmxhdGNoQW5kQXBwZW5kKE1PREVfRElHSVQsIDE2IC0gcGFpckNvZGUpIC8vIHBlcmlvZCBvciBjb21tYSBpbiBESUdJVFxuICAgICAgICAgICAgICAgICAgICAubGF0Y2hBbmRBcHBlbmQoTU9ERV9ESUdJVCwgMSk7IC8vIHNwYWNlIGluIERJR0lUXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZGlnaXRTdGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RhdGUuZ2V0QmluYXJ5U2hpZnRCeXRlQ291bnQoKSA+IDApIHtcbiAgICAgICAgICAgICAgICAvLyBJdCBvbmx5IG1ha2VzIHNlbnNlIHRvIGRvIHRoZSBjaGFyYWN0ZXJzIGFzIGJpbmFyeSBpZiB3ZSdyZSBhbHJlYWR5XG4gICAgICAgICAgICAgICAgLy8gaW4gYmluYXJ5IG1vZGUuXG4gICAgICAgICAgICAgICAgbGV0IGJpbmFyeVN0YXRlID0gc3RhdGVcbiAgICAgICAgICAgICAgICAgICAgLmFkZEJpbmFyeVNoaWZ0Q2hhcihpbmRleClcbiAgICAgICAgICAgICAgICAgICAgLmFkZEJpbmFyeVNoaWZ0Q2hhcihpbmRleCArIDEpO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGJpbmFyeVN0YXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgc2ltcGxpZnlTdGF0ZXMoc3RhdGVzKSB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG5ld1N0YXRlIG9mIHN0YXRlcykge1xuICAgICAgICAgICAgICAgIGxldCBhZGQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgb2xkU3RhdGUgb2YgcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvbGRTdGF0ZS5pc0JldHRlclRoYW5PckVxdWFsVG8obmV3U3RhdGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXdTdGF0ZS5pc0JldHRlclRoYW5PckVxdWFsVG8ob2xkU3RhdGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpdGVyYXRvci5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5maWx0ZXIoeCA9PiB4ICE9PSBvbGRTdGF0ZSk7IC8vIHJlbW92ZSBvbGQgc3RhdGVcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYWRkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ld1N0YXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBDb3B5cmlnaHQgMjAxMyBaWGluZyBhdXRob3JzXG4gICAgICpcbiAgICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgICAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgICAgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgICAgKlxuICAgICAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gICAgICpcbiAgICAgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICAgICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgICAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICAgICAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgICAgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAgICAgKi9cbiAgICAvLyBwYWNrYWdlIGNvbS5nb29nbGUuenhpbmcuYXp0ZWMuZW5jb2RlcjtcbiAgICAvLyBpbXBvcnQgY29tLmdvb2dsZS56eGluZy5jb21tb24uQml0QXJyYXk7XG4gICAgLy8gaW1wb3J0IGNvbS5nb29nbGUuenhpbmcuY29tbW9uLkJpdE1hdHJpeDtcbiAgICAvLyBpbXBvcnQgY29tLmdvb2dsZS56eGluZy5jb21tb24ucmVlZHNvbG9tb24uR2VuZXJpY0dGO1xuICAgIC8vIGltcG9ydCBjb20uZ29vZ2xlLnp4aW5nLmNvbW1vbi5yZWVkc29sb21vbi5SZWVkU29sb21vbkVuY29kZXI7XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIEF6dGVjIDJEIGJhcmNvZGVzLlxuICAgICAqXG4gICAgICogQGF1dGhvciBSdXN0YW0gQWJkdWxsYWV2XG4gICAgICovXG4gICAgLypwdWJsaWMgZmluYWwqLyBjbGFzcyBFbmNvZGVyJDEge1xuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogRW5jb2RlcyB0aGUgZ2l2ZW4gYmluYXJ5IGNvbnRlbnQgYXMgYW4gQXp0ZWMgc3ltYm9sXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBkYXRhIGlucHV0IGRhdGEgc3RyaW5nXG4gICAgICAgICAqIEByZXR1cm4gQXp0ZWMgc3ltYm9sIG1hdHJpeCB3aXRoIG1ldGFkYXRhXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgZW5jb2RlQnl0ZXMoZGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuIEVuY29kZXIkMS5lbmNvZGUoZGF0YSwgRW5jb2RlciQxLkRFRkFVTFRfRUNfUEVSQ0VOVCwgRW5jb2RlciQxLkRFRkFVTFRfQVpURUNfTEFZRVJTKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogRW5jb2RlcyB0aGUgZ2l2ZW4gYmluYXJ5IGNvbnRlbnQgYXMgYW4gQXp0ZWMgc3ltYm9sXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBkYXRhIGlucHV0IGRhdGEgc3RyaW5nXG4gICAgICAgICAqIEBwYXJhbSBtaW5FQ0NQZXJjZW50IG1pbmltYWwgcGVyY2VudGFnZSBvZiBlcnJvciBjaGVjayB3b3JkcyAoQWNjb3JkaW5nIHRvIElTTy9JRUMgMjQ3Nzg6MjAwOCxcbiAgICAgICAgICogICAgICAgICAgICAgICAgICAgICAgYSBtaW5pbXVtIG9mIDIzJSArIDMgd29yZHMgaXMgcmVjb21tZW5kZWQpXG4gICAgICAgICAqIEBwYXJhbSB1c2VyU3BlY2lmaWVkTGF5ZXJzIGlmIG5vbi16ZXJvLCBhIHVzZXItc3BlY2lmaWVkIHZhbHVlIGZvciB0aGUgbnVtYmVyIG9mIGxheWVyc1xuICAgICAgICAgKiBAcmV0dXJuIEF6dGVjIHN5bWJvbCBtYXRyaXggd2l0aCBtZXRhZGF0YVxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGVuY29kZShkYXRhLCBtaW5FQ0NQZXJjZW50LCB1c2VyU3BlY2lmaWVkTGF5ZXJzKSB7XG4gICAgICAgICAgICAvLyBIaWdoLWxldmVsIGVuY29kZVxuICAgICAgICAgICAgbGV0IGJpdHMgPSBuZXcgSGlnaExldmVsRW5jb2RlcihkYXRhKS5lbmNvZGUoKTtcbiAgICAgICAgICAgIC8vIHN0dWZmIGJpdHMgYW5kIGNob29zZSBzeW1ib2wgc2l6ZVxuICAgICAgICAgICAgbGV0IGVjY0JpdHMgPSBJbnRlZ2VyLnRydW5jRGl2aXNpb24oKGJpdHMuZ2V0U2l6ZSgpICogbWluRUNDUGVyY2VudCksIDEwMCkgKyAxMTtcbiAgICAgICAgICAgIGxldCB0b3RhbFNpemVCaXRzID0gYml0cy5nZXRTaXplKCkgKyBlY2NCaXRzO1xuICAgICAgICAgICAgbGV0IGNvbXBhY3Q7XG4gICAgICAgICAgICBsZXQgbGF5ZXJzO1xuICAgICAgICAgICAgbGV0IHRvdGFsQml0c0luTGF5ZXI7XG4gICAgICAgICAgICBsZXQgd29yZFNpemU7XG4gICAgICAgICAgICBsZXQgc3R1ZmZlZEJpdHM7XG4gICAgICAgICAgICBpZiAodXNlclNwZWNpZmllZExheWVycyAhPT0gRW5jb2RlciQxLkRFRkFVTFRfQVpURUNfTEFZRVJTKSB7XG4gICAgICAgICAgICAgICAgY29tcGFjdCA9IHVzZXJTcGVjaWZpZWRMYXllcnMgPCAwO1xuICAgICAgICAgICAgICAgIGxheWVycyA9IE1hdGguYWJzKHVzZXJTcGVjaWZpZWRMYXllcnMpO1xuICAgICAgICAgICAgICAgIGlmIChsYXllcnMgPiAoY29tcGFjdCA/IEVuY29kZXIkMS5NQVhfTkJfQklUU19DT01QQUNUIDogRW5jb2RlciQxLk1BWF9OQl9CSVRTKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKFN0cmluZ1V0aWxzLmZvcm1hdCgnSWxsZWdhbCB2YWx1ZSAlcyBmb3IgbGF5ZXJzJywgdXNlclNwZWNpZmllZExheWVycykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0b3RhbEJpdHNJbkxheWVyID0gRW5jb2RlciQxLnRvdGFsQml0c0luTGF5ZXIobGF5ZXJzLCBjb21wYWN0KTtcbiAgICAgICAgICAgICAgICB3b3JkU2l6ZSA9IEVuY29kZXIkMS5XT1JEX1NJWkVbbGF5ZXJzXTtcbiAgICAgICAgICAgICAgICBsZXQgdXNhYmxlQml0c0luTGF5ZXJzID0gdG90YWxCaXRzSW5MYXllciAtICh0b3RhbEJpdHNJbkxheWVyICUgd29yZFNpemUpO1xuICAgICAgICAgICAgICAgIHN0dWZmZWRCaXRzID0gRW5jb2RlciQxLnN0dWZmQml0cyhiaXRzLCB3b3JkU2l6ZSk7XG4gICAgICAgICAgICAgICAgaWYgKHN0dWZmZWRCaXRzLmdldFNpemUoKSArIGVjY0JpdHMgPiB1c2FibGVCaXRzSW5MYXllcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignRGF0YSB0byBsYXJnZSBmb3IgdXNlciBzcGVjaWZpZWQgbGF5ZXInKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNvbXBhY3QgJiYgc3R1ZmZlZEJpdHMuZ2V0U2l6ZSgpID4gd29yZFNpemUgKiA2NCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBDb21wYWN0IGZvcm1hdCBvbmx5IGFsbG93cyA2NCBkYXRhIHdvcmRzLCB0aG91Z2ggQzQgY2FuIGhvbGQgbW9yZSB3b3JkcyB0aGFuIHRoYXRcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignRGF0YSB0byBsYXJnZSBmb3IgdXNlciBzcGVjaWZpZWQgbGF5ZXInKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB3b3JkU2l6ZSA9IDA7XG4gICAgICAgICAgICAgICAgc3R1ZmZlZEJpdHMgPSBudWxsO1xuICAgICAgICAgICAgICAgIC8vIFdlIGxvb2sgYXQgdGhlIHBvc3NpYmxlIHRhYmxlIHNpemVzIGluIHRoZSBvcmRlciBDb21wYWN0MSwgQ29tcGFjdDIsIENvbXBhY3QzLFxuICAgICAgICAgICAgICAgIC8vIENvbXBhY3Q0LCBOb3JtYWw0LC4uLiAgTm9ybWFsKGkpIGZvciBpIDwgNCBpc24ndCB0eXBpY2FsbHkgdXNlZCBzaW5jZSBDb21wYWN0KGkrMSlcbiAgICAgICAgICAgICAgICAvLyBpcyB0aGUgc2FtZSBzaXplLCBidXQgaGFzIG1vcmUgZGF0YS5cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpIC8qaW50Ki8gPSAwOzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpID4gRW5jb2RlciQxLk1BWF9OQl9CSVRTKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCdEYXRhIHRvbyBsYXJnZSBmb3IgYW4gQXp0ZWMgY29kZScpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbXBhY3QgPSBpIDw9IDM7XG4gICAgICAgICAgICAgICAgICAgIGxheWVycyA9IGNvbXBhY3QgPyBpICsgMSA6IGk7XG4gICAgICAgICAgICAgICAgICAgIHRvdGFsQml0c0luTGF5ZXIgPSBFbmNvZGVyJDEudG90YWxCaXRzSW5MYXllcihsYXllcnMsIGNvbXBhY3QpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodG90YWxTaXplQml0cyA+IHRvdGFsQml0c0luTGF5ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFtSZV1zdHVmZiB0aGUgYml0cyBpZiB0aGlzIGlzIHRoZSBmaXJzdCBvcHBvcnR1bml0eSwgb3IgaWYgdGhlXG4gICAgICAgICAgICAgICAgICAgIC8vIHdvcmRTaXplIGhhcyBjaGFuZ2VkXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdHVmZmVkQml0cyA9PSBudWxsIHx8IHdvcmRTaXplICE9PSBFbmNvZGVyJDEuV09SRF9TSVpFW2xheWVyc10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdvcmRTaXplID0gRW5jb2RlciQxLldPUkRfU0laRVtsYXllcnNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3R1ZmZlZEJpdHMgPSBFbmNvZGVyJDEuc3R1ZmZCaXRzKGJpdHMsIHdvcmRTaXplKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsZXQgdXNhYmxlQml0c0luTGF5ZXJzID0gdG90YWxCaXRzSW5MYXllciAtICh0b3RhbEJpdHNJbkxheWVyICUgd29yZFNpemUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29tcGFjdCAmJiBzdHVmZmVkQml0cy5nZXRTaXplKCkgPiB3b3JkU2l6ZSAqIDY0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDb21wYWN0IGZvcm1hdCBvbmx5IGFsbG93cyA2NCBkYXRhIHdvcmRzLCB0aG91Z2ggQzQgY2FuIGhvbGQgbW9yZSB3b3JkcyB0aGFuIHRoYXRcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdHVmZmVkQml0cy5nZXRTaXplKCkgKyBlY2NCaXRzIDw9IHVzYWJsZUJpdHNJbkxheWVycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgbWVzc2FnZUJpdHMgPSBFbmNvZGVyJDEuZ2VuZXJhdGVDaGVja1dvcmRzKHN0dWZmZWRCaXRzLCB0b3RhbEJpdHNJbkxheWVyLCB3b3JkU2l6ZSk7XG4gICAgICAgICAgICAvLyBnZW5lcmF0ZSBtb2RlIG1lc3NhZ2VcbiAgICAgICAgICAgIGxldCBtZXNzYWdlU2l6ZUluV29yZHMgPSBzdHVmZmVkQml0cy5nZXRTaXplKCkgLyB3b3JkU2l6ZTtcbiAgICAgICAgICAgIGxldCBtb2RlTWVzc2FnZSA9IEVuY29kZXIkMS5nZW5lcmF0ZU1vZGVNZXNzYWdlKGNvbXBhY3QsIGxheWVycywgbWVzc2FnZVNpemVJbldvcmRzKTtcbiAgICAgICAgICAgIC8vIGFsbG9jYXRlIHN5bWJvbFxuICAgICAgICAgICAgbGV0IGJhc2VNYXRyaXhTaXplID0gKGNvbXBhY3QgPyAxMSA6IDE0KSArIGxheWVycyAqIDQ7IC8vIG5vdCBpbmNsdWRpbmcgYWxpZ25tZW50IGxpbmVzXG4gICAgICAgICAgICBsZXQgYWxpZ25tZW50TWFwID0gbmV3IEludDMyQXJyYXkoYmFzZU1hdHJpeFNpemUpO1xuICAgICAgICAgICAgbGV0IG1hdHJpeFNpemU7XG4gICAgICAgICAgICBpZiAoY29tcGFjdCkge1xuICAgICAgICAgICAgICAgIC8vIG5vIGFsaWdubWVudCBtYXJrcyBpbiBjb21wYWN0IG1vZGUsIGFsaWdubWVudE1hcCBpcyBhIG5vLW9wXG4gICAgICAgICAgICAgICAgbWF0cml4U2l6ZSA9IGJhc2VNYXRyaXhTaXplO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgLyppbnQqLyA9IDA7IGkgPCBhbGlnbm1lbnRNYXAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYWxpZ25tZW50TWFwW2ldID0gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtYXRyaXhTaXplID0gYmFzZU1hdHJpeFNpemUgKyAxICsgMiAqIEludGVnZXIudHJ1bmNEaXZpc2lvbigoSW50ZWdlci50cnVuY0RpdmlzaW9uKGJhc2VNYXRyaXhTaXplLCAyKSAtIDEpLCAxNSk7XG4gICAgICAgICAgICAgICAgbGV0IG9yaWdDZW50ZXIgPSBJbnRlZ2VyLnRydW5jRGl2aXNpb24oYmFzZU1hdHJpeFNpemUsIDIpO1xuICAgICAgICAgICAgICAgIGxldCBjZW50ZXIgPSBJbnRlZ2VyLnRydW5jRGl2aXNpb24obWF0cml4U2l6ZSwgMik7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSAvKmludCovID0gMDsgaSA8IG9yaWdDZW50ZXI7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbmV3T2Zmc2V0ID0gaSArIEludGVnZXIudHJ1bmNEaXZpc2lvbihpLCAxNSk7XG4gICAgICAgICAgICAgICAgICAgIGFsaWdubWVudE1hcFtvcmlnQ2VudGVyIC0gaSAtIDFdID0gY2VudGVyIC0gbmV3T2Zmc2V0IC0gMTtcbiAgICAgICAgICAgICAgICAgICAgYWxpZ25tZW50TWFwW29yaWdDZW50ZXIgKyBpXSA9IGNlbnRlciArIG5ld09mZnNldCArIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IG1hdHJpeCA9IG5ldyBCaXRNYXRyaXgobWF0cml4U2l6ZSk7XG4gICAgICAgICAgICAvLyBkcmF3IGRhdGEgYml0c1xuICAgICAgICAgICAgZm9yIChsZXQgaSAvKmludCovID0gMCwgcm93T2Zmc2V0ID0gMDsgaSA8IGxheWVyczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHJvd1NpemUgPSAobGF5ZXJzIC0gaSkgKiA0ICsgKGNvbXBhY3QgPyA5IDogMTIpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogLyppbnQqLyA9IDA7IGogPCByb3dTaXplOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNvbHVtbk9mZnNldCA9IGogKiAyO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBrIC8qaW50Ki8gPSAwOyBrIDwgMjsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWVzc2FnZUJpdHMuZ2V0KHJvd09mZnNldCArIGNvbHVtbk9mZnNldCArIGspKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0cml4LnNldChhbGlnbm1lbnRNYXBbaSAqIDIgKyBrXSwgYWxpZ25tZW50TWFwW2kgKiAyICsgal0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2VCaXRzLmdldChyb3dPZmZzZXQgKyByb3dTaXplICogMiArIGNvbHVtbk9mZnNldCArIGspKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0cml4LnNldChhbGlnbm1lbnRNYXBbaSAqIDIgKyBqXSwgYWxpZ25tZW50TWFwW2Jhc2VNYXRyaXhTaXplIC0gMSAtIGkgKiAyIC0ga10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2VCaXRzLmdldChyb3dPZmZzZXQgKyByb3dTaXplICogNCArIGNvbHVtbk9mZnNldCArIGspKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0cml4LnNldChhbGlnbm1lbnRNYXBbYmFzZU1hdHJpeFNpemUgLSAxIC0gaSAqIDIgLSBrXSwgYWxpZ25tZW50TWFwW2Jhc2VNYXRyaXhTaXplIC0gMSAtIGkgKiAyIC0gal0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2VCaXRzLmdldChyb3dPZmZzZXQgKyByb3dTaXplICogNiArIGNvbHVtbk9mZnNldCArIGspKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0cml4LnNldChhbGlnbm1lbnRNYXBbYmFzZU1hdHJpeFNpemUgLSAxIC0gaSAqIDIgLSBqXSwgYWxpZ25tZW50TWFwW2kgKiAyICsga10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJvd09mZnNldCArPSByb3dTaXplICogODtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGRyYXcgbW9kZSBtZXNzYWdlXG4gICAgICAgICAgICBFbmNvZGVyJDEuZHJhd01vZGVNZXNzYWdlKG1hdHJpeCwgY29tcGFjdCwgbWF0cml4U2l6ZSwgbW9kZU1lc3NhZ2UpO1xuICAgICAgICAgICAgLy8gZHJhdyBhbGlnbm1lbnQgbWFya3NcbiAgICAgICAgICAgIGlmIChjb21wYWN0KSB7XG4gICAgICAgICAgICAgICAgRW5jb2RlciQxLmRyYXdCdWxsc0V5ZShtYXRyaXgsIEludGVnZXIudHJ1bmNEaXZpc2lvbihtYXRyaXhTaXplLCAyKSwgNSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBFbmNvZGVyJDEuZHJhd0J1bGxzRXllKG1hdHJpeCwgSW50ZWdlci50cnVuY0RpdmlzaW9uKG1hdHJpeFNpemUsIDIpLCA3KTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpIC8qaW50Ki8gPSAwLCBqID0gMDsgaSA8IEludGVnZXIudHJ1bmNEaXZpc2lvbihiYXNlTWF0cml4U2l6ZSwgMikgLSAxOyBpICs9IDE1LCBqICs9IDE2KSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGsgLyppbnQqLyA9IEludGVnZXIudHJ1bmNEaXZpc2lvbihtYXRyaXhTaXplLCAyKSAmIDE7IGsgPCBtYXRyaXhTaXplOyBrICs9IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdHJpeC5zZXQoSW50ZWdlci50cnVuY0RpdmlzaW9uKG1hdHJpeFNpemUsIDIpIC0gaiwgayk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRyaXguc2V0KEludGVnZXIudHJ1bmNEaXZpc2lvbihtYXRyaXhTaXplLCAyKSArIGosIGspO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0cml4LnNldChrLCBJbnRlZ2VyLnRydW5jRGl2aXNpb24obWF0cml4U2l6ZSwgMikgLSBqKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdHJpeC5zZXQoaywgSW50ZWdlci50cnVuY0RpdmlzaW9uKG1hdHJpeFNpemUsIDIpICsgaik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgYXp0ZWMgPSBuZXcgQXp0ZWNDb2RlKCk7XG4gICAgICAgICAgICBhenRlYy5zZXRDb21wYWN0KGNvbXBhY3QpO1xuICAgICAgICAgICAgYXp0ZWMuc2V0U2l6ZShtYXRyaXhTaXplKTtcbiAgICAgICAgICAgIGF6dGVjLnNldExheWVycyhsYXllcnMpO1xuICAgICAgICAgICAgYXp0ZWMuc2V0Q29kZVdvcmRzKG1lc3NhZ2VTaXplSW5Xb3Jkcyk7XG4gICAgICAgICAgICBhenRlYy5zZXRNYXRyaXgobWF0cml4KTtcbiAgICAgICAgICAgIHJldHVybiBhenRlYztcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgZHJhd0J1bGxzRXllKG1hdHJpeCwgY2VudGVyLCBzaXplKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpIC8qaW50Ki8gPSAwOyBpIDwgc2l6ZTsgaSArPSAyKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiAvKmludCovID0gY2VudGVyIC0gaTsgaiA8PSBjZW50ZXIgKyBpOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0cml4LnNldChqLCBjZW50ZXIgLSBpKTtcbiAgICAgICAgICAgICAgICAgICAgbWF0cml4LnNldChqLCBjZW50ZXIgKyBpKTtcbiAgICAgICAgICAgICAgICAgICAgbWF0cml4LnNldChjZW50ZXIgLSBpLCBqKTtcbiAgICAgICAgICAgICAgICAgICAgbWF0cml4LnNldChjZW50ZXIgKyBpLCBqKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtYXRyaXguc2V0KGNlbnRlciAtIHNpemUsIGNlbnRlciAtIHNpemUpO1xuICAgICAgICAgICAgbWF0cml4LnNldChjZW50ZXIgLSBzaXplICsgMSwgY2VudGVyIC0gc2l6ZSk7XG4gICAgICAgICAgICBtYXRyaXguc2V0KGNlbnRlciAtIHNpemUsIGNlbnRlciAtIHNpemUgKyAxKTtcbiAgICAgICAgICAgIG1hdHJpeC5zZXQoY2VudGVyICsgc2l6ZSwgY2VudGVyIC0gc2l6ZSk7XG4gICAgICAgICAgICBtYXRyaXguc2V0KGNlbnRlciArIHNpemUsIGNlbnRlciAtIHNpemUgKyAxKTtcbiAgICAgICAgICAgIG1hdHJpeC5zZXQoY2VudGVyICsgc2l6ZSwgY2VudGVyICsgc2l6ZSAtIDEpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBnZW5lcmF0ZU1vZGVNZXNzYWdlKGNvbXBhY3QsIGxheWVycywgbWVzc2FnZVNpemVJbldvcmRzKSB7XG4gICAgICAgICAgICBsZXQgbW9kZU1lc3NhZ2UgPSBuZXcgQml0QXJyYXkoKTtcbiAgICAgICAgICAgIGlmIChjb21wYWN0KSB7XG4gICAgICAgICAgICAgICAgbW9kZU1lc3NhZ2UuYXBwZW5kQml0cyhsYXllcnMgLSAxLCAyKTtcbiAgICAgICAgICAgICAgICBtb2RlTWVzc2FnZS5hcHBlbmRCaXRzKG1lc3NhZ2VTaXplSW5Xb3JkcyAtIDEsIDYpO1xuICAgICAgICAgICAgICAgIG1vZGVNZXNzYWdlID0gRW5jb2RlciQxLmdlbmVyYXRlQ2hlY2tXb3Jkcyhtb2RlTWVzc2FnZSwgMjgsIDQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbW9kZU1lc3NhZ2UuYXBwZW5kQml0cyhsYXllcnMgLSAxLCA1KTtcbiAgICAgICAgICAgICAgICBtb2RlTWVzc2FnZS5hcHBlbmRCaXRzKG1lc3NhZ2VTaXplSW5Xb3JkcyAtIDEsIDExKTtcbiAgICAgICAgICAgICAgICBtb2RlTWVzc2FnZSA9IEVuY29kZXIkMS5nZW5lcmF0ZUNoZWNrV29yZHMobW9kZU1lc3NhZ2UsIDQwLCA0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtb2RlTWVzc2FnZTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgZHJhd01vZGVNZXNzYWdlKG1hdHJpeCwgY29tcGFjdCwgbWF0cml4U2l6ZSwgbW9kZU1lc3NhZ2UpIHtcbiAgICAgICAgICAgIGxldCBjZW50ZXIgPSBJbnRlZ2VyLnRydW5jRGl2aXNpb24obWF0cml4U2l6ZSwgMik7XG4gICAgICAgICAgICBpZiAoY29tcGFjdCkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgLyppbnQqLyA9IDA7IGkgPCA3OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG9mZnNldCA9IGNlbnRlciAtIDMgKyBpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobW9kZU1lc3NhZ2UuZ2V0KGkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRyaXguc2V0KG9mZnNldCwgY2VudGVyIC0gNSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG1vZGVNZXNzYWdlLmdldChpICsgNykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdHJpeC5zZXQoY2VudGVyICsgNSwgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobW9kZU1lc3NhZ2UuZ2V0KDIwIC0gaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdHJpeC5zZXQob2Zmc2V0LCBjZW50ZXIgKyA1KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobW9kZU1lc3NhZ2UuZ2V0KDI3IC0gaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdHJpeC5zZXQoY2VudGVyIC0gNSwgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgLyppbnQqLyA9IDA7IGkgPCAxMDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBvZmZzZXQgPSBjZW50ZXIgLSA1ICsgaSArIEludGVnZXIudHJ1bmNEaXZpc2lvbihpLCA1KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1vZGVNZXNzYWdlLmdldChpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0cml4LnNldChvZmZzZXQsIGNlbnRlciAtIDcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb2RlTWVzc2FnZS5nZXQoaSArIDEwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0cml4LnNldChjZW50ZXIgKyA3LCBvZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb2RlTWVzc2FnZS5nZXQoMjkgLSBpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0cml4LnNldChvZmZzZXQsIGNlbnRlciArIDcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb2RlTWVzc2FnZS5nZXQoMzkgLSBpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0cml4LnNldChjZW50ZXIgLSA3LCBvZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBnZW5lcmF0ZUNoZWNrV29yZHMoYml0QXJyYXksIHRvdGFsQml0cywgd29yZFNpemUpIHtcbiAgICAgICAgICAgIC8vIGJpdEFycmF5IGlzIGd1YXJhbnRlZWQgdG8gYmUgYSBtdWx0aXBsZSBvZiB0aGUgd29yZFNpemUsIHNvIG5vIHBhZGRpbmcgbmVlZGVkXG4gICAgICAgICAgICBsZXQgbWVzc2FnZVNpemVJbldvcmRzID0gYml0QXJyYXkuZ2V0U2l6ZSgpIC8gd29yZFNpemU7XG4gICAgICAgICAgICBsZXQgcnMgPSBuZXcgUmVlZFNvbG9tb25FbmNvZGVyKEVuY29kZXIkMS5nZXRHRih3b3JkU2l6ZSkpO1xuICAgICAgICAgICAgbGV0IHRvdGFsV29yZHMgPSBJbnRlZ2VyLnRydW5jRGl2aXNpb24odG90YWxCaXRzLCB3b3JkU2l6ZSk7XG4gICAgICAgICAgICBsZXQgbWVzc2FnZVdvcmRzID0gRW5jb2RlciQxLmJpdHNUb1dvcmRzKGJpdEFycmF5LCB3b3JkU2l6ZSwgdG90YWxXb3Jkcyk7XG4gICAgICAgICAgICBycy5lbmNvZGUobWVzc2FnZVdvcmRzLCB0b3RhbFdvcmRzIC0gbWVzc2FnZVNpemVJbldvcmRzKTtcbiAgICAgICAgICAgIGxldCBzdGFydFBhZCA9IHRvdGFsQml0cyAlIHdvcmRTaXplO1xuICAgICAgICAgICAgbGV0IG1lc3NhZ2VCaXRzID0gbmV3IEJpdEFycmF5KCk7XG4gICAgICAgICAgICBtZXNzYWdlQml0cy5hcHBlbmRCaXRzKDAsIHN0YXJ0UGFkKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbWVzc2FnZVdvcmQgLyo6IGludCovIG9mIEFycmF5LmZyb20obWVzc2FnZVdvcmRzKSkge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2VCaXRzLmFwcGVuZEJpdHMobWVzc2FnZVdvcmQsIHdvcmRTaXplKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlQml0cztcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgYml0c1RvV29yZHMoc3R1ZmZlZEJpdHMsIHdvcmRTaXplLCB0b3RhbFdvcmRzKSB7XG4gICAgICAgICAgICBsZXQgbWVzc2FnZSA9IG5ldyBJbnQzMkFycmF5KHRvdGFsV29yZHMpO1xuICAgICAgICAgICAgbGV0IGk7XG4gICAgICAgICAgICBsZXQgbjtcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIG4gPSBzdHVmZmVkQml0cy5nZXRTaXplKCkgLyB3b3JkU2l6ZTsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiAvKmludCovID0gMDsgaiA8IHdvcmRTaXplOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgfD0gc3R1ZmZlZEJpdHMuZ2V0KGkgKiB3b3JkU2l6ZSArIGopID8gKDEgPDwgd29yZFNpemUgLSBqIC0gMSkgOiAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtZXNzYWdlW2ldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgZ2V0R0Yod29yZFNpemUpIHtcbiAgICAgICAgICAgIHN3aXRjaCAod29yZFNpemUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBHZW5lcmljR0YuQVpURUNfUEFSQU07XG4gICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gR2VuZXJpY0dGLkFaVEVDX0RBVEFfNjtcbiAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBHZW5lcmljR0YuQVpURUNfREFUQV84O1xuICAgICAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBHZW5lcmljR0YuQVpURUNfREFUQV8xMDtcbiAgICAgICAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gR2VuZXJpY0dGLkFaVEVDX0RBVEFfMTI7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignVW5zdXBwb3J0ZWQgd29yZCBzaXplICcgKyB3b3JkU2l6ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIHN0dWZmQml0cyhiaXRzLCB3b3JkU2l6ZSkge1xuICAgICAgICAgICAgbGV0IG91dCA9IG5ldyBCaXRBcnJheSgpO1xuICAgICAgICAgICAgbGV0IG4gPSBiaXRzLmdldFNpemUoKTtcbiAgICAgICAgICAgIGxldCBtYXNrID0gKDEgPDwgd29yZFNpemUpIC0gMjtcbiAgICAgICAgICAgIGZvciAobGV0IGkgLyppbnQqLyA9IDA7IGkgPCBuOyBpICs9IHdvcmRTaXplKSB7XG4gICAgICAgICAgICAgICAgbGV0IHdvcmQgPSAwO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogLyppbnQqLyA9IDA7IGogPCB3b3JkU2l6ZTsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpICsgaiA+PSBuIHx8IGJpdHMuZ2V0KGkgKyBqKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd29yZCB8PSAxIDw8ICh3b3JkU2l6ZSAtIDEgLSBqKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoKHdvcmQgJiBtYXNrKSA9PT0gbWFzaykge1xuICAgICAgICAgICAgICAgICAgICBvdXQuYXBwZW5kQml0cyh3b3JkICYgbWFzaywgd29yZFNpemUpO1xuICAgICAgICAgICAgICAgICAgICBpLS07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCh3b3JkICYgbWFzaykgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0LmFwcGVuZEJpdHMod29yZCB8IDEsIHdvcmRTaXplKTtcbiAgICAgICAgICAgICAgICAgICAgaS0tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0LmFwcGVuZEJpdHMod29yZCwgd29yZFNpemUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIHRvdGFsQml0c0luTGF5ZXIobGF5ZXJzLCBjb21wYWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gKChjb21wYWN0ID8gODggOiAxMTIpICsgMTYgKiBsYXllcnMpICogbGF5ZXJzO1xuICAgICAgICB9XG4gICAgfVxuICAgIEVuY29kZXIkMS5ERUZBVUxUX0VDX1BFUkNFTlQgPSAzMzsgLy8gZGVmYXVsdCBtaW5pbWFsIHBlcmNlbnRhZ2Ugb2YgZXJyb3IgY2hlY2sgd29yZHNcbiAgICBFbmNvZGVyJDEuREVGQVVMVF9BWlRFQ19MQVlFUlMgPSAwO1xuICAgIEVuY29kZXIkMS5NQVhfTkJfQklUUyA9IDMyO1xuICAgIEVuY29kZXIkMS5NQVhfTkJfQklUU19DT01QQUNUID0gNDtcbiAgICBFbmNvZGVyJDEuV09SRF9TSVpFID0gSW50MzJBcnJheS5mcm9tKFtcbiAgICAgICAgNCwgNiwgNiwgOCwgOCwgOCwgOCwgOCwgOCwgMTAsIDEwLCAxMCwgMTAsIDEwLCAxMCwgMTAsIDEwLCAxMCwgMTAsIDEwLCAxMCwgMTAsIDEwLFxuICAgICAgICAxMiwgMTIsIDEyLCAxMiwgMTIsIDEyLCAxMiwgMTIsIDEyLCAxMlxuICAgIF0pO1xuXG4gICAgLypcbiAgICAqIENvcHlyaWdodCAyMDEzIFpYaW5nIGF1dGhvcnNcbiAgICAqXG4gICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICAgKlxuICAgICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAgICAqXG4gICAgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICAgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICAgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgICAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgICAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICAgICovXG4gICAgLyoqXG4gICAgICogUmVuZGVycyBhbiBBenRlYyBjb2RlIGFzIGEge0BsaW5rIEJpdE1hdHJpeH0uXG4gICAgICovXG4gICAgLypwdWJsaWMgZmluYWwqLyBjbGFzcyBBenRlY1dyaXRlciB7XG4gICAgICAgIC8vIEBPdmVycmlkZVxuICAgICAgICBlbmNvZGUoY29udGVudHMsIGZvcm1hdCwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlV2l0aEhpbnRzKGNvbnRlbnRzLCBmb3JtYXQsIHdpZHRoLCBoZWlnaHQsIG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEBPdmVycmlkZVxuICAgICAgICBlbmNvZGVXaXRoSGludHMoY29udGVudHMsIGZvcm1hdCwgd2lkdGgsIGhlaWdodCwgaGludHMpIHtcbiAgICAgICAgICAgIGxldCBjaGFyc2V0ID0gU3RhbmRhcmRDaGFyc2V0cy5JU09fODg1OV8xO1xuICAgICAgICAgICAgbGV0IGVjY1BlcmNlbnQgPSBFbmNvZGVyJDEuREVGQVVMVF9FQ19QRVJDRU5UO1xuICAgICAgICAgICAgbGV0IGxheWVycyA9IEVuY29kZXIkMS5ERUZBVUxUX0FaVEVDX0xBWUVSUztcbiAgICAgICAgICAgIGlmIChoaW50cyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhpbnRzLmhhcyhFbmNvZGVIaW50VHlwZSQxLkNIQVJBQ1RFUl9TRVQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYXJzZXQgPSBDaGFyc2V0LmZvck5hbWUoaGludHMuZ2V0KEVuY29kZUhpbnRUeXBlJDEuQ0hBUkFDVEVSX1NFVCkudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChoaW50cy5oYXMoRW5jb2RlSGludFR5cGUkMS5FUlJPUl9DT1JSRUNUSU9OKSkge1xuICAgICAgICAgICAgICAgICAgICBlY2NQZXJjZW50ID0gSW50ZWdlci5wYXJzZUludChoaW50cy5nZXQoRW5jb2RlSGludFR5cGUkMS5FUlJPUl9DT1JSRUNUSU9OKS50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGhpbnRzLmhhcyhFbmNvZGVIaW50VHlwZSQxLkFaVEVDX0xBWUVSUykpIHtcbiAgICAgICAgICAgICAgICAgICAgbGF5ZXJzID0gSW50ZWdlci5wYXJzZUludChoaW50cy5nZXQoRW5jb2RlSGludFR5cGUkMS5BWlRFQ19MQVlFUlMpLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBBenRlY1dyaXRlci5lbmNvZGVMYXllcnMoY29udGVudHMsIGZvcm1hdCwgd2lkdGgsIGhlaWdodCwgY2hhcnNldCwgZWNjUGVyY2VudCwgbGF5ZXJzKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgZW5jb2RlTGF5ZXJzKGNvbnRlbnRzLCBmb3JtYXQsIHdpZHRoLCBoZWlnaHQsIGNoYXJzZXQsIGVjY1BlcmNlbnQsIGxheWVycykge1xuICAgICAgICAgICAgaWYgKGZvcm1hdCAhPT0gQmFyY29kZUZvcm1hdCQxLkFaVEVDKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignQ2FuIG9ubHkgZW5jb2RlIEFaVEVDLCBidXQgZ290ICcgKyBmb3JtYXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGF6dGVjID0gRW5jb2RlciQxLmVuY29kZShTdHJpbmdVdGlscy5nZXRCeXRlcyhjb250ZW50cywgY2hhcnNldCksIGVjY1BlcmNlbnQsIGxheWVycyk7XG4gICAgICAgICAgICByZXR1cm4gQXp0ZWNXcml0ZXIucmVuZGVyUmVzdWx0KGF6dGVjLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgcmVuZGVyUmVzdWx0KGNvZGUsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgICAgIGxldCBpbnB1dCA9IGNvZGUuZ2V0TWF0cml4KCk7XG4gICAgICAgICAgICBpZiAoaW5wdXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsU3RhdGVFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBpbnB1dFdpZHRoID0gaW5wdXQuZ2V0V2lkdGgoKTtcbiAgICAgICAgICAgIGxldCBpbnB1dEhlaWdodCA9IGlucHV0LmdldEhlaWdodCgpO1xuICAgICAgICAgICAgbGV0IG91dHB1dFdpZHRoID0gTWF0aC5tYXgod2lkdGgsIGlucHV0V2lkdGgpO1xuICAgICAgICAgICAgbGV0IG91dHB1dEhlaWdodCA9IE1hdGgubWF4KGhlaWdodCwgaW5wdXRIZWlnaHQpO1xuICAgICAgICAgICAgbGV0IG11bHRpcGxlID0gTWF0aC5taW4ob3V0cHV0V2lkdGggLyBpbnB1dFdpZHRoLCBvdXRwdXRIZWlnaHQgLyBpbnB1dEhlaWdodCk7XG4gICAgICAgICAgICBsZXQgbGVmdFBhZGRpbmcgPSAob3V0cHV0V2lkdGggLSAoaW5wdXRXaWR0aCAqIG11bHRpcGxlKSkgLyAyO1xuICAgICAgICAgICAgbGV0IHRvcFBhZGRpbmcgPSAob3V0cHV0SGVpZ2h0IC0gKGlucHV0SGVpZ2h0ICogbXVsdGlwbGUpKSAvIDI7XG4gICAgICAgICAgICBsZXQgb3V0cHV0ID0gbmV3IEJpdE1hdHJpeChvdXRwdXRXaWR0aCwgb3V0cHV0SGVpZ2h0KTtcbiAgICAgICAgICAgIGZvciAobGV0IGlucHV0WSAvKmludCovID0gMCwgb3V0cHV0WSA9IHRvcFBhZGRpbmc7IGlucHV0WSA8IGlucHV0SGVpZ2h0OyBpbnB1dFkrKywgb3V0cHV0WSArPSBtdWx0aXBsZSkge1xuICAgICAgICAgICAgICAgIC8vIFdyaXRlIHRoZSBjb250ZW50cyBvZiB0aGlzIHJvdyBvZiB0aGUgYmFyY29kZVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGlucHV0WCAvKmludCovID0gMCwgb3V0cHV0WCA9IGxlZnRQYWRkaW5nOyBpbnB1dFggPCBpbnB1dFdpZHRoOyBpbnB1dFgrKywgb3V0cHV0WCArPSBtdWx0aXBsZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXQuZ2V0KGlucHV0WCwgaW5wdXRZKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnNldFJlZ2lvbihvdXRwdXRYLCBvdXRwdXRZLCBtdWx0aXBsZSwgbXVsdGlwbGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGV4cG9ydHMuQWJzdHJhY3RFeHBhbmRlZERlY29kZXIgPSBBYnN0cmFjdEV4cGFuZGVkRGVjb2RlcjtcbiAgICBleHBvcnRzLkFyZ3VtZW50RXhjZXB0aW9uID0gQXJndW1lbnRFeGNlcHRpb247XG4gICAgZXhwb3J0cy5Bcml0aG1ldGljRXhjZXB0aW9uID0gQXJpdGhtZXRpY0V4Y2VwdGlvbjtcbiAgICBleHBvcnRzLkF6dGVjQ29kZSA9IEF6dGVjQ29kZTtcbiAgICBleHBvcnRzLkF6dGVjQ29kZVJlYWRlciA9IEF6dGVjUmVhZGVyO1xuICAgIGV4cG9ydHMuQXp0ZWNDb2RlV3JpdGVyID0gQXp0ZWNXcml0ZXI7XG4gICAgZXhwb3J0cy5BenRlY0RlY29kZXIgPSBEZWNvZGVyO1xuICAgIGV4cG9ydHMuQXp0ZWNEZXRlY3RvciA9IERldGVjdG9yO1xuICAgIGV4cG9ydHMuQXp0ZWNEZXRlY3RvclJlc3VsdCA9IEF6dGVjRGV0ZWN0b3JSZXN1bHQ7XG4gICAgZXhwb3J0cy5BenRlY0VuY29kZXIgPSBFbmNvZGVyJDE7XG4gICAgZXhwb3J0cy5BenRlY0hpZ2hMZXZlbEVuY29kZXIgPSBIaWdoTGV2ZWxFbmNvZGVyO1xuICAgIGV4cG9ydHMuQXp0ZWNQb2ludCA9IFBvaW50O1xuICAgIGV4cG9ydHMuQmFyY29kZUZvcm1hdCA9IEJhcmNvZGVGb3JtYXQkMTtcbiAgICBleHBvcnRzLkJpbmFyaXplciA9IEJpbmFyaXplcjtcbiAgICBleHBvcnRzLkJpbmFyeUJpdG1hcCA9IEJpbmFyeUJpdG1hcDtcbiAgICBleHBvcnRzLkJpdEFycmF5ID0gQml0QXJyYXk7XG4gICAgZXhwb3J0cy5CaXRNYXRyaXggPSBCaXRNYXRyaXg7XG4gICAgZXhwb3J0cy5CaXRTb3VyY2UgPSBCaXRTb3VyY2U7XG4gICAgZXhwb3J0cy5Ccm93c2VyQXp0ZWNDb2RlUmVhZGVyID0gQnJvd3NlckF6dGVjQ29kZVJlYWRlcjtcbiAgICBleHBvcnRzLkJyb3dzZXJCYXJjb2RlUmVhZGVyID0gQnJvd3NlckJhcmNvZGVSZWFkZXI7XG4gICAgZXhwb3J0cy5Ccm93c2VyQ29kZVJlYWRlciA9IEJyb3dzZXJDb2RlUmVhZGVyO1xuICAgIGV4cG9ydHMuQnJvd3NlckRhdGFtYXRyaXhDb2RlUmVhZGVyID0gQnJvd3NlckRhdGFtYXRyaXhDb2RlUmVhZGVyO1xuICAgIGV4cG9ydHMuQnJvd3Nlck11bHRpRm9ybWF0UmVhZGVyID0gQnJvd3Nlck11bHRpRm9ybWF0UmVhZGVyO1xuICAgIGV4cG9ydHMuQnJvd3NlclBERjQxN1JlYWRlciA9IEJyb3dzZXJQREY0MTdSZWFkZXI7XG4gICAgZXhwb3J0cy5Ccm93c2VyUVJDb2RlUmVhZGVyID0gQnJvd3NlclFSQ29kZVJlYWRlcjtcbiAgICBleHBvcnRzLkJyb3dzZXJRUkNvZGVTdmdXcml0ZXIgPSBCcm93c2VyUVJDb2RlU3ZnV3JpdGVyO1xuICAgIGV4cG9ydHMuQ2hhcmFjdGVyU2V0RUNJID0gQ2hhcmFjdGVyU2V0RUNJO1xuICAgIGV4cG9ydHMuQ2hlY2tzdW1FeGNlcHRpb24gPSBDaGVja3N1bUV4Y2VwdGlvbjtcbiAgICBleHBvcnRzLkNvZGUxMjhSZWFkZXIgPSBDb2RlMTI4UmVhZGVyO1xuICAgIGV4cG9ydHMuQ29kZTM5UmVhZGVyID0gQ29kZTM5UmVhZGVyO1xuICAgIGV4cG9ydHMuRGF0YU1hdHJpeERlY29kZWRCaXRTdHJlYW1QYXJzZXIgPSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyO1xuICAgIGV4cG9ydHMuRGF0YU1hdHJpeFJlYWRlciA9IERhdGFNYXRyaXhSZWFkZXI7XG4gICAgZXhwb3J0cy5EZWNvZGVIaW50VHlwZSA9IERlY29kZUhpbnRUeXBlJDE7XG4gICAgZXhwb3J0cy5EZWNvZGVyUmVzdWx0ID0gRGVjb2RlclJlc3VsdDtcbiAgICBleHBvcnRzLkRlZmF1bHRHcmlkU2FtcGxlciA9IERlZmF1bHRHcmlkU2FtcGxlcjtcbiAgICBleHBvcnRzLkRldGVjdG9yUmVzdWx0ID0gRGV0ZWN0b3JSZXN1bHQ7XG4gICAgZXhwb3J0cy5FQU4xM1JlYWRlciA9IEVBTjEzUmVhZGVyO1xuICAgIGV4cG9ydHMuRW5jb2RlSGludFR5cGUgPSBFbmNvZGVIaW50VHlwZSQxO1xuICAgIGV4cG9ydHMuRXhjZXB0aW9uID0gRXhjZXB0aW9uO1xuICAgIGV4cG9ydHMuRm9ybWF0RXhjZXB0aW9uID0gRm9ybWF0RXhjZXB0aW9uO1xuICAgIGV4cG9ydHMuR2VuZXJpY0dGID0gR2VuZXJpY0dGO1xuICAgIGV4cG9ydHMuR2VuZXJpY0dGUG9seSA9IEdlbmVyaWNHRlBvbHk7XG4gICAgZXhwb3J0cy5HbG9iYWxIaXN0b2dyYW1CaW5hcml6ZXIgPSBHbG9iYWxIaXN0b2dyYW1CaW5hcml6ZXI7XG4gICAgZXhwb3J0cy5HcmlkU2FtcGxlciA9IEdyaWRTYW1wbGVyO1xuICAgIGV4cG9ydHMuR3JpZFNhbXBsZXJJbnN0YW5jZSA9IEdyaWRTYW1wbGVySW5zdGFuY2U7XG4gICAgZXhwb3J0cy5IVE1MQ2FudmFzRWxlbWVudEx1bWluYW5jZVNvdXJjZSA9IEhUTUxDYW52YXNFbGVtZW50THVtaW5hbmNlU291cmNlO1xuICAgIGV4cG9ydHMuSHlicmlkQmluYXJpemVyID0gSHlicmlkQmluYXJpemVyO1xuICAgIGV4cG9ydHMuSVRGUmVhZGVyID0gSVRGUmVhZGVyO1xuICAgIGV4cG9ydHMuSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uID0gSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uO1xuICAgIGV4cG9ydHMuSWxsZWdhbFN0YXRlRXhjZXB0aW9uID0gSWxsZWdhbFN0YXRlRXhjZXB0aW9uO1xuICAgIGV4cG9ydHMuSW52ZXJ0ZWRMdW1pbmFuY2VTb3VyY2UgPSBJbnZlcnRlZEx1bWluYW5jZVNvdXJjZTtcbiAgICBleHBvcnRzLkx1bWluYW5jZVNvdXJjZSA9IEx1bWluYW5jZVNvdXJjZTtcbiAgICBleHBvcnRzLk1hdGhVdGlscyA9IE1hdGhVdGlscztcbiAgICBleHBvcnRzLk11bHRpRm9ybWF0T25lRFJlYWRlciA9IE11bHRpRm9ybWF0T25lRFJlYWRlcjtcbiAgICBleHBvcnRzLk11bHRpRm9ybWF0UmVhZGVyID0gTXVsdGlGb3JtYXRSZWFkZXI7XG4gICAgZXhwb3J0cy5NdWx0aUZvcm1hdFdyaXRlciA9IE11bHRpRm9ybWF0V3JpdGVyO1xuICAgIGV4cG9ydHMuTm90Rm91bmRFeGNlcHRpb24gPSBOb3RGb3VuZEV4Y2VwdGlvbjtcbiAgICBleHBvcnRzLk9uZURSZWFkZXIgPSBPbmVEUmVhZGVyO1xuICAgIGV4cG9ydHMuUERGNDE3RGVjb2RlZEJpdFN0cmVhbVBhcnNlciA9IERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMjtcbiAgICBleHBvcnRzLlBERjQxN0RlY29kZXJFcnJvckNvcnJlY3Rpb24gPSBFcnJvckNvcnJlY3Rpb247XG4gICAgZXhwb3J0cy5QREY0MTdSZWFkZXIgPSBQREY0MTdSZWFkZXI7XG4gICAgZXhwb3J0cy5QREY0MTdSZXN1bHRNZXRhZGF0YSA9IFBERjQxN1Jlc3VsdE1ldGFkYXRhO1xuICAgIGV4cG9ydHMuUGVyc3BlY3RpdmVUcmFuc2Zvcm0gPSBQZXJzcGVjdGl2ZVRyYW5zZm9ybTtcbiAgICBleHBvcnRzLlBsYW5hcllVVkx1bWluYW5jZVNvdXJjZSA9IFBsYW5hcllVVkx1bWluYW5jZVNvdXJjZTtcbiAgICBleHBvcnRzLlFSQ29kZUJ5dGVNYXRyaXggPSBCeXRlTWF0cml4O1xuICAgIGV4cG9ydHMuUVJDb2RlRGF0YU1hc2sgPSBEYXRhTWFzaztcbiAgICBleHBvcnRzLlFSQ29kZURlY29kZWRCaXRTdHJlYW1QYXJzZXIgPSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDE7XG4gICAgZXhwb3J0cy5RUkNvZGVEZWNvZGVyRXJyb3JDb3JyZWN0aW9uTGV2ZWwgPSBFcnJvckNvcnJlY3Rpb25MZXZlbDtcbiAgICBleHBvcnRzLlFSQ29kZURlY29kZXJGb3JtYXRJbmZvcm1hdGlvbiA9IEZvcm1hdEluZm9ybWF0aW9uO1xuICAgIGV4cG9ydHMuUVJDb2RlRW5jb2RlciA9IEVuY29kZXI7XG4gICAgZXhwb3J0cy5RUkNvZGVFbmNvZGVyUVJDb2RlID0gUVJDb2RlO1xuICAgIGV4cG9ydHMuUVJDb2RlTWFza1V0aWwgPSBNYXNrVXRpbDtcbiAgICBleHBvcnRzLlFSQ29kZU1hdHJpeFV0aWwgPSBNYXRyaXhVdGlsO1xuICAgIGV4cG9ydHMuUVJDb2RlTW9kZSA9IE1vZGUkMTtcbiAgICBleHBvcnRzLlFSQ29kZVJlYWRlciA9IFFSQ29kZVJlYWRlcjtcbiAgICBleHBvcnRzLlFSQ29kZVZlcnNpb24gPSBWZXJzaW9uJDE7XG4gICAgZXhwb3J0cy5RUkNvZGVXcml0ZXIgPSBRUkNvZGVXcml0ZXI7XG4gICAgZXhwb3J0cy5SR0JMdW1pbmFuY2VTb3VyY2UgPSBSR0JMdW1pbmFuY2VTb3VyY2U7XG4gICAgZXhwb3J0cy5SU1MxNFJlYWRlciA9IFJTUzE0UmVhZGVyO1xuICAgIGV4cG9ydHMuUlNTRXhwYW5kZWRSZWFkZXIgPSBSU1NFeHBhbmRlZFJlYWRlcjtcbiAgICBleHBvcnRzLlJlYWRlckV4Y2VwdGlvbiA9IFJlYWRlckV4Y2VwdGlvbjtcbiAgICBleHBvcnRzLlJlZWRTb2xvbW9uRGVjb2RlciA9IFJlZWRTb2xvbW9uRGVjb2RlcjtcbiAgICBleHBvcnRzLlJlZWRTb2xvbW9uRW5jb2RlciA9IFJlZWRTb2xvbW9uRW5jb2RlcjtcbiAgICBleHBvcnRzLlJlZWRTb2xvbW9uRXhjZXB0aW9uID0gUmVlZFNvbG9tb25FeGNlcHRpb247XG4gICAgZXhwb3J0cy5SZXN1bHQgPSBSZXN1bHQ7XG4gICAgZXhwb3J0cy5SZXN1bHRNZXRhZGF0YVR5cGUgPSBSZXN1bHRNZXRhZGF0YVR5cGUkMTtcbiAgICBleHBvcnRzLlJlc3VsdFBvaW50ID0gUmVzdWx0UG9pbnQ7XG4gICAgZXhwb3J0cy5TdHJpbmdVdGlscyA9IFN0cmluZ1V0aWxzO1xuICAgIGV4cG9ydHMuVW5zdXBwb3J0ZWRPcGVyYXRpb25FeGNlcHRpb24gPSBVbnN1cHBvcnRlZE9wZXJhdGlvbkV4Y2VwdGlvbjtcbiAgICBleHBvcnRzLlZpZGVvSW5wdXREZXZpY2UgPSBWaWRlb0lucHV0RGV2aWNlO1xuICAgIGV4cG9ydHMuV2hpdGVSZWN0YW5nbGVEZXRlY3RvciA9IFdoaXRlUmVjdGFuZ2xlRGV0ZWN0b3I7XG4gICAgZXhwb3J0cy5Xcml0ZXJFeGNlcHRpb24gPSBXcml0ZXJFeGNlcHRpb247XG4gICAgZXhwb3J0cy5aWGluZ0FycmF5cyA9IEFycmF5cztcbiAgICBleHBvcnRzLlpYaW5nQ2hhcnNldCA9IENoYXJzZXQ7XG4gICAgZXhwb3J0cy5aWGluZ0ludGVnZXIgPSBJbnRlZ2VyO1xuICAgIGV4cG9ydHMuWlhpbmdTdGFuZGFyZENoYXJzZXRzID0gU3RhbmRhcmRDaGFyc2V0cztcbiAgICBleHBvcnRzLlpYaW5nU3RyaW5nQnVpbGRlciA9IFN0cmluZ0J1aWxkZXI7XG4gICAgZXhwb3J0cy5aWGluZ1N0cmluZ0VuY29kaW5nID0gU3RyaW5nRW5jb2Rpbmc7XG4gICAgZXhwb3J0cy5aWGluZ1N5c3RlbSA9IFN5c3RlbTtcbiAgICBleHBvcnRzLmNyZWF0ZUFic3RyYWN0RXhwYW5kZWREZWNvZGVyID0gY3JlYXRlRGVjb2RlcjtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKSk7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbihmdW5jdGlvbigpIHtcbiAgdmFyIFBvbHlmaWxsRXZlbnQgPSBldmVudENvbnN0cnVjdG9yKCk7XG5cbiAgZnVuY3Rpb24gZXZlbnRDb25zdHJ1Y3RvcigpIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdy5DdXN0b21FdmVudCA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gd2luZG93LkN1c3RvbUV2ZW50O1xuICAgIC8vIElFPD05IFN1cHBvcnRcbiAgICBmdW5jdGlvbiBDdXN0b21FdmVudChldmVudCwgcGFyYW1zKSB7XG4gICAgICBwYXJhbXMgPSBwYXJhbXMgfHwge2J1YmJsZXM6IGZhbHNlLCBjYW5jZWxhYmxlOiBmYWxzZSwgZGV0YWlsOiB1bmRlZmluZWR9O1xuICAgICAgdmFyIGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdDdXN0b21FdmVudCcpO1xuICAgICAgZXZ0LmluaXRDdXN0b21FdmVudChldmVudCwgcGFyYW1zLmJ1YmJsZXMsIHBhcmFtcy5jYW5jZWxhYmxlLCBwYXJhbXMuZGV0YWlsKTtcbiAgICAgIHJldHVybiBldnQ7XG4gICAgfVxuICAgIEN1c3RvbUV2ZW50LnByb3RvdHlwZSA9IHdpbmRvdy5FdmVudC5wcm90b3R5cGU7XG4gICAgcmV0dXJuIEN1c3RvbUV2ZW50O1xuICB9XG5cbiAgZnVuY3Rpb24gYnVpbGRIaWRkZW5JbnB1dChuYW1lLCB2YWx1ZSkge1xuICAgIHZhciBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcbiAgICBpbnB1dC50eXBlID0gXCJoaWRkZW5cIjtcbiAgICBpbnB1dC5uYW1lID0gbmFtZTtcbiAgICBpbnB1dC52YWx1ZSA9IHZhbHVlO1xuICAgIHJldHVybiBpbnB1dDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZUNsaWNrKGVsZW1lbnQsIHRhcmdldE1vZGlmaWVyS2V5KSB7XG4gICAgdmFyIHRvID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXRvXCIpLFxuICAgICAgICBtZXRob2QgPSBidWlsZEhpZGRlbklucHV0KFwiX21ldGhvZFwiLCBlbGVtZW50LmdldEF0dHJpYnV0ZShcImRhdGEtbWV0aG9kXCIpKSxcbiAgICAgICAgY3NyZiA9IGJ1aWxkSGlkZGVuSW5wdXQoXCJfY3NyZl90b2tlblwiLCBlbGVtZW50LmdldEF0dHJpYnV0ZShcImRhdGEtY3NyZlwiKSksXG4gICAgICAgIGZvcm0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZm9ybVwiKSxcbiAgICAgICAgdGFyZ2V0ID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJ0YXJnZXRcIik7XG5cbiAgICBmb3JtLm1ldGhvZCA9IChlbGVtZW50LmdldEF0dHJpYnV0ZShcImRhdGEtbWV0aG9kXCIpID09PSBcImdldFwiKSA/IFwiZ2V0XCIgOiBcInBvc3RcIjtcbiAgICBmb3JtLmFjdGlvbiA9IHRvO1xuICAgIGZvcm0uc3R5bGUuZGlzcGxheSA9IFwiaGlkZGVuXCI7XG5cbiAgICBpZiAodGFyZ2V0KSBmb3JtLnRhcmdldCA9IHRhcmdldDtcbiAgICBlbHNlIGlmICh0YXJnZXRNb2RpZmllcktleSkgZm9ybS50YXJnZXQgPSBcIl9ibGFua1wiO1xuXG4gICAgZm9ybS5hcHBlbmRDaGlsZChjc3JmKTtcbiAgICBmb3JtLmFwcGVuZENoaWxkKG1ldGhvZCk7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChmb3JtKTtcbiAgICBmb3JtLnN1Ym1pdCgpO1xuICB9XG5cbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBmdW5jdGlvbihlKSB7XG4gICAgdmFyIGVsZW1lbnQgPSBlLnRhcmdldDtcbiAgICBpZiAoZS5kZWZhdWx0UHJldmVudGVkKSByZXR1cm47XG5cbiAgICB3aGlsZSAoZWxlbWVudCAmJiBlbGVtZW50LmdldEF0dHJpYnV0ZSkge1xuICAgICAgdmFyIHBob2VuaXhMaW5rRXZlbnQgPSBuZXcgUG9seWZpbGxFdmVudCgncGhvZW5peC5saW5rLmNsaWNrJywge1xuICAgICAgICBcImJ1YmJsZXNcIjogdHJ1ZSwgXCJjYW5jZWxhYmxlXCI6IHRydWVcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIWVsZW1lbnQuZGlzcGF0Y2hFdmVudChwaG9lbml4TGlua0V2ZW50KSkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiZGF0YS1tZXRob2RcIikpIHtcbiAgICAgICAgaGFuZGxlQ2xpY2soZWxlbWVudCwgZS5tZXRhS2V5IHx8IGUuc2hpZnRLZXkpO1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7XG4gICAgICB9XG4gICAgfVxuICB9LCBmYWxzZSk7XG5cbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Bob2VuaXgubGluay5jbGljaycsIGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIG1lc3NhZ2UgPSBlLnRhcmdldC5nZXRBdHRyaWJ1dGUoXCJkYXRhLWNvbmZpcm1cIik7XG4gICAgaWYobWVzc2FnZSAmJiAhd2luZG93LmNvbmZpcm0obWVzc2FnZSkpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH0sIGZhbHNlKTtcbn0pKCk7XG4iLCAiLy8gd3JhcHMgdmFsdWUgaW4gY2xvc3VyZSBvciByZXR1cm5zIGNsb3N1cmVcbmV4cG9ydCBsZXQgY2xvc3VyZSA9ICh2YWx1ZSkgPT4ge1xuICBpZih0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIil7XG4gICAgcmV0dXJuIHZhbHVlXG4gIH0gZWxzZSB7XG4gICAgbGV0IGNsb3N1cmUgPSBmdW5jdGlvbiAoKXsgcmV0dXJuIHZhbHVlIH1cbiAgICByZXR1cm4gY2xvc3VyZVxuICB9XG59XG4iLCAiZXhwb3J0IGNvbnN0IGdsb2JhbFNlbGYgPSB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiBudWxsXG5leHBvcnQgY29uc3QgcGh4V2luZG93ID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IG51bGxcbmV4cG9ydCBjb25zdCBnbG9iYWwgPSBnbG9iYWxTZWxmIHx8IHBoeFdpbmRvdyB8fCBnbG9iYWxcbmV4cG9ydCBjb25zdCBERUZBVUxUX1ZTTiA9IFwiMi4wLjBcIlxuZXhwb3J0IGNvbnN0IFNPQ0tFVF9TVEFURVMgPSB7Y29ubmVjdGluZzogMCwgb3BlbjogMSwgY2xvc2luZzogMiwgY2xvc2VkOiAzfVxuZXhwb3J0IGNvbnN0IERFRkFVTFRfVElNRU9VVCA9IDEwMDAwXG5leHBvcnQgY29uc3QgV1NfQ0xPU0VfTk9STUFMID0gMTAwMFxuZXhwb3J0IGNvbnN0IENIQU5ORUxfU1RBVEVTID0ge1xuICBjbG9zZWQ6IFwiY2xvc2VkXCIsXG4gIGVycm9yZWQ6IFwiZXJyb3JlZFwiLFxuICBqb2luZWQ6IFwiam9pbmVkXCIsXG4gIGpvaW5pbmc6IFwiam9pbmluZ1wiLFxuICBsZWF2aW5nOiBcImxlYXZpbmdcIixcbn1cbmV4cG9ydCBjb25zdCBDSEFOTkVMX0VWRU5UUyA9IHtcbiAgY2xvc2U6IFwicGh4X2Nsb3NlXCIsXG4gIGVycm9yOiBcInBoeF9lcnJvclwiLFxuICBqb2luOiBcInBoeF9qb2luXCIsXG4gIHJlcGx5OiBcInBoeF9yZXBseVwiLFxuICBsZWF2ZTogXCJwaHhfbGVhdmVcIlxufVxuXG5leHBvcnQgY29uc3QgVFJBTlNQT1JUUyA9IHtcbiAgbG9uZ3BvbGw6IFwibG9uZ3BvbGxcIixcbiAgd2Vic29ja2V0OiBcIndlYnNvY2tldFwiXG59XG5leHBvcnQgY29uc3QgWEhSX1NUQVRFUyA9IHtcbiAgY29tcGxldGU6IDRcbn1cbiIsICIvKipcbiAqIEluaXRpYWxpemVzIHRoZSBQdXNoXG4gKiBAcGFyYW0ge0NoYW5uZWx9IGNoYW5uZWwgLSBUaGUgQ2hhbm5lbFxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50IC0gVGhlIGV2ZW50LCBmb3IgZXhhbXBsZSBgXCJwaHhfam9pblwiYFxuICogQHBhcmFtIHtPYmplY3R9IHBheWxvYWQgLSBUaGUgcGF5bG9hZCwgZm9yIGV4YW1wbGUgYHt1c2VyX2lkOiAxMjN9YFxuICogQHBhcmFtIHtudW1iZXJ9IHRpbWVvdXQgLSBUaGUgcHVzaCB0aW1lb3V0IGluIG1pbGxpc2Vjb25kc1xuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQdXNoIHtcbiAgY29uc3RydWN0b3IoY2hhbm5lbCwgZXZlbnQsIHBheWxvYWQsIHRpbWVvdXQpe1xuICAgIHRoaXMuY2hhbm5lbCA9IGNoYW5uZWxcbiAgICB0aGlzLmV2ZW50ID0gZXZlbnRcbiAgICB0aGlzLnBheWxvYWQgPSBwYXlsb2FkIHx8IGZ1bmN0aW9uICgpeyByZXR1cm4ge30gfVxuICAgIHRoaXMucmVjZWl2ZWRSZXNwID0gbnVsbFxuICAgIHRoaXMudGltZW91dCA9IHRpbWVvdXRcbiAgICB0aGlzLnRpbWVvdXRUaW1lciA9IG51bGxcbiAgICB0aGlzLnJlY0hvb2tzID0gW11cbiAgICB0aGlzLnNlbnQgPSBmYWxzZVxuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lb3V0XG4gICAqL1xuICByZXNlbmQodGltZW91dCl7XG4gICAgdGhpcy50aW1lb3V0ID0gdGltZW91dFxuICAgIHRoaXMucmVzZXQoKVxuICAgIHRoaXMuc2VuZCgpXG4gIH1cblxuICAvKipcbiAgICpcbiAgICovXG4gIHNlbmQoKXtcbiAgICBpZih0aGlzLmhhc1JlY2VpdmVkKFwidGltZW91dFwiKSl7IHJldHVybiB9XG4gICAgdGhpcy5zdGFydFRpbWVvdXQoKVxuICAgIHRoaXMuc2VudCA9IHRydWVcbiAgICB0aGlzLmNoYW5uZWwuc29ja2V0LnB1c2goe1xuICAgICAgdG9waWM6IHRoaXMuY2hhbm5lbC50b3BpYyxcbiAgICAgIGV2ZW50OiB0aGlzLmV2ZW50LFxuICAgICAgcGF5bG9hZDogdGhpcy5wYXlsb2FkKCksXG4gICAgICByZWY6IHRoaXMucmVmLFxuICAgICAgam9pbl9yZWY6IHRoaXMuY2hhbm5lbC5qb2luUmVmKClcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gc3RhdHVzXG4gICAqIEBwYXJhbSB7Kn0gY2FsbGJhY2tcbiAgICovXG4gIHJlY2VpdmUoc3RhdHVzLCBjYWxsYmFjayl7XG4gICAgaWYodGhpcy5oYXNSZWNlaXZlZChzdGF0dXMpKXtcbiAgICAgIGNhbGxiYWNrKHRoaXMucmVjZWl2ZWRSZXNwLnJlc3BvbnNlKVxuICAgIH1cblxuICAgIHRoaXMucmVjSG9va3MucHVzaCh7c3RhdHVzLCBjYWxsYmFja30pXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcmVzZXQoKXtcbiAgICB0aGlzLmNhbmNlbFJlZkV2ZW50KClcbiAgICB0aGlzLnJlZiA9IG51bGxcbiAgICB0aGlzLnJlZkV2ZW50ID0gbnVsbFxuICAgIHRoaXMucmVjZWl2ZWRSZXNwID0gbnVsbFxuICAgIHRoaXMuc2VudCA9IGZhbHNlXG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIG1hdGNoUmVjZWl2ZSh7c3RhdHVzLCByZXNwb25zZSwgX3JlZn0pe1xuICAgIHRoaXMucmVjSG9va3MuZmlsdGVyKGggPT4gaC5zdGF0dXMgPT09IHN0YXR1cylcbiAgICAgIC5mb3JFYWNoKGggPT4gaC5jYWxsYmFjayhyZXNwb25zZSkpXG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNhbmNlbFJlZkV2ZW50KCl7XG4gICAgaWYoIXRoaXMucmVmRXZlbnQpeyByZXR1cm4gfVxuICAgIHRoaXMuY2hhbm5lbC5vZmYodGhpcy5yZWZFdmVudClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY2FuY2VsVGltZW91dCgpe1xuICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXRUaW1lcilcbiAgICB0aGlzLnRpbWVvdXRUaW1lciA9IG51bGxcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc3RhcnRUaW1lb3V0KCl7XG4gICAgaWYodGhpcy50aW1lb3V0VGltZXIpeyB0aGlzLmNhbmNlbFRpbWVvdXQoKSB9XG4gICAgdGhpcy5yZWYgPSB0aGlzLmNoYW5uZWwuc29ja2V0Lm1ha2VSZWYoKVxuICAgIHRoaXMucmVmRXZlbnQgPSB0aGlzLmNoYW5uZWwucmVwbHlFdmVudE5hbWUodGhpcy5yZWYpXG5cbiAgICB0aGlzLmNoYW5uZWwub24odGhpcy5yZWZFdmVudCwgcGF5bG9hZCA9PiB7XG4gICAgICB0aGlzLmNhbmNlbFJlZkV2ZW50KClcbiAgICAgIHRoaXMuY2FuY2VsVGltZW91dCgpXG4gICAgICB0aGlzLnJlY2VpdmVkUmVzcCA9IHBheWxvYWRcbiAgICAgIHRoaXMubWF0Y2hSZWNlaXZlKHBheWxvYWQpXG4gICAgfSlcblxuICAgIHRoaXMudGltZW91dFRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLnRyaWdnZXIoXCJ0aW1lb3V0XCIsIHt9KVxuICAgIH0sIHRoaXMudGltZW91dClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaGFzUmVjZWl2ZWQoc3RhdHVzKXtcbiAgICByZXR1cm4gdGhpcy5yZWNlaXZlZFJlc3AgJiYgdGhpcy5yZWNlaXZlZFJlc3Auc3RhdHVzID09PSBzdGF0dXNcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdHJpZ2dlcihzdGF0dXMsIHJlc3BvbnNlKXtcbiAgICB0aGlzLmNoYW5uZWwudHJpZ2dlcih0aGlzLnJlZkV2ZW50LCB7c3RhdHVzLCByZXNwb25zZX0pXG4gIH1cbn1cbiIsICIvKipcbiAqXG4gKiBDcmVhdGVzIGEgdGltZXIgdGhhdCBhY2NlcHRzIGEgYHRpbWVyQ2FsY2AgZnVuY3Rpb24gdG8gcGVyZm9ybVxuICogY2FsY3VsYXRlZCB0aW1lb3V0IHJldHJpZXMsIHN1Y2ggYXMgZXhwb25lbnRpYWwgYmFja29mZi5cbiAqXG4gKiBAZXhhbXBsZVxuICogbGV0IHJlY29ubmVjdFRpbWVyID0gbmV3IFRpbWVyKCgpID0+IHRoaXMuY29ubmVjdCgpLCBmdW5jdGlvbih0cmllcyl7XG4gKiAgIHJldHVybiBbMTAwMCwgNTAwMCwgMTAwMDBdW3RyaWVzIC0gMV0gfHwgMTAwMDBcbiAqIH0pXG4gKiByZWNvbm5lY3RUaW1lci5zY2hlZHVsZVRpbWVvdXQoKSAvLyBmaXJlcyBhZnRlciAxMDAwXG4gKiByZWNvbm5lY3RUaW1lci5zY2hlZHVsZVRpbWVvdXQoKSAvLyBmaXJlcyBhZnRlciA1MDAwXG4gKiByZWNvbm5lY3RUaW1lci5yZXNldCgpXG4gKiByZWNvbm5lY3RUaW1lci5zY2hlZHVsZVRpbWVvdXQoKSAvLyBmaXJlcyBhZnRlciAxMDAwXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRpbWVyQ2FsY1xuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUaW1lciB7XG4gIGNvbnN0cnVjdG9yKGNhbGxiYWNrLCB0aW1lckNhbGMpe1xuICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFja1xuICAgIHRoaXMudGltZXJDYWxjID0gdGltZXJDYWxjXG4gICAgdGhpcy50aW1lciA9IG51bGxcbiAgICB0aGlzLnRyaWVzID0gMFxuICB9XG5cbiAgcmVzZXQoKXtcbiAgICB0aGlzLnRyaWVzID0gMFxuICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVyKVxuICB9XG5cbiAgLyoqXG4gICAqIENhbmNlbHMgYW55IHByZXZpb3VzIHNjaGVkdWxlVGltZW91dCBhbmQgc2NoZWR1bGVzIGNhbGxiYWNrXG4gICAqL1xuICBzY2hlZHVsZVRpbWVvdXQoKXtcbiAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lcilcblxuICAgIHRoaXMudGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMudHJpZXMgPSB0aGlzLnRyaWVzICsgMVxuICAgICAgdGhpcy5jYWxsYmFjaygpXG4gICAgfSwgdGhpcy50aW1lckNhbGModGhpcy50cmllcyArIDEpKVxuICB9XG59XG4iLCAiaW1wb3J0IHtjbG9zdXJlfSBmcm9tIFwiLi91dGlsc1wiXG5pbXBvcnQge1xuICBDSEFOTkVMX0VWRU5UUyxcbiAgQ0hBTk5FTF9TVEFURVMsXG59IGZyb20gXCIuL2NvbnN0YW50c1wiXG5cbmltcG9ydCBQdXNoIGZyb20gXCIuL3B1c2hcIlxuaW1wb3J0IFRpbWVyIGZyb20gXCIuL3RpbWVyXCJcblxuLyoqXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRvcGljXG4gKiBAcGFyYW0geyhPYmplY3R8ZnVuY3Rpb24pfSBwYXJhbXNcbiAqIEBwYXJhbSB7U29ja2V0fSBzb2NrZXRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ2hhbm5lbCB7XG4gIGNvbnN0cnVjdG9yKHRvcGljLCBwYXJhbXMsIHNvY2tldCl7XG4gICAgdGhpcy5zdGF0ZSA9IENIQU5ORUxfU1RBVEVTLmNsb3NlZFxuICAgIHRoaXMudG9waWMgPSB0b3BpY1xuICAgIHRoaXMucGFyYW1zID0gY2xvc3VyZShwYXJhbXMgfHwge30pXG4gICAgdGhpcy5zb2NrZXQgPSBzb2NrZXRcbiAgICB0aGlzLmJpbmRpbmdzID0gW11cbiAgICB0aGlzLmJpbmRpbmdSZWYgPSAwXG4gICAgdGhpcy50aW1lb3V0ID0gdGhpcy5zb2NrZXQudGltZW91dFxuICAgIHRoaXMuam9pbmVkT25jZSA9IGZhbHNlXG4gICAgdGhpcy5qb2luUHVzaCA9IG5ldyBQdXNoKHRoaXMsIENIQU5ORUxfRVZFTlRTLmpvaW4sIHRoaXMucGFyYW1zLCB0aGlzLnRpbWVvdXQpXG4gICAgdGhpcy5wdXNoQnVmZmVyID0gW11cbiAgICB0aGlzLnN0YXRlQ2hhbmdlUmVmcyA9IFtdXG5cbiAgICB0aGlzLnJlam9pblRpbWVyID0gbmV3IFRpbWVyKCgpID0+IHtcbiAgICAgIGlmKHRoaXMuc29ja2V0LmlzQ29ubmVjdGVkKCkpeyB0aGlzLnJlam9pbigpIH1cbiAgICB9LCB0aGlzLnNvY2tldC5yZWpvaW5BZnRlck1zKVxuICAgIHRoaXMuc3RhdGVDaGFuZ2VSZWZzLnB1c2godGhpcy5zb2NrZXQub25FcnJvcigoKSA9PiB0aGlzLnJlam9pblRpbWVyLnJlc2V0KCkpKVxuICAgIHRoaXMuc3RhdGVDaGFuZ2VSZWZzLnB1c2godGhpcy5zb2NrZXQub25PcGVuKCgpID0+IHtcbiAgICAgIHRoaXMucmVqb2luVGltZXIucmVzZXQoKVxuICAgICAgaWYodGhpcy5pc0Vycm9yZWQoKSl7IHRoaXMucmVqb2luKCkgfVxuICAgIH0pXG4gICAgKVxuICAgIHRoaXMuam9pblB1c2gucmVjZWl2ZShcIm9rXCIsICgpID0+IHtcbiAgICAgIHRoaXMuc3RhdGUgPSBDSEFOTkVMX1NUQVRFUy5qb2luZWRcbiAgICAgIHRoaXMucmVqb2luVGltZXIucmVzZXQoKVxuICAgICAgdGhpcy5wdXNoQnVmZmVyLmZvckVhY2gocHVzaEV2ZW50ID0+IHB1c2hFdmVudC5zZW5kKCkpXG4gICAgICB0aGlzLnB1c2hCdWZmZXIgPSBbXVxuICAgIH0pXG4gICAgdGhpcy5qb2luUHVzaC5yZWNlaXZlKFwiZXJyb3JcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5zdGF0ZSA9IENIQU5ORUxfU1RBVEVTLmVycm9yZWRcbiAgICAgIGlmKHRoaXMuc29ja2V0LmlzQ29ubmVjdGVkKCkpeyB0aGlzLnJlam9pblRpbWVyLnNjaGVkdWxlVGltZW91dCgpIH1cbiAgICB9KVxuICAgIHRoaXMub25DbG9zZSgoKSA9PiB7XG4gICAgICB0aGlzLnJlam9pblRpbWVyLnJlc2V0KClcbiAgICAgIGlmKHRoaXMuc29ja2V0Lmhhc0xvZ2dlcigpKSB0aGlzLnNvY2tldC5sb2coXCJjaGFubmVsXCIsIGBjbG9zZSAke3RoaXMudG9waWN9ICR7dGhpcy5qb2luUmVmKCl9YClcbiAgICAgIHRoaXMuc3RhdGUgPSBDSEFOTkVMX1NUQVRFUy5jbG9zZWRcbiAgICAgIHRoaXMuc29ja2V0LnJlbW92ZSh0aGlzKVxuICAgIH0pXG4gICAgdGhpcy5vbkVycm9yKHJlYXNvbiA9PiB7XG4gICAgICBpZih0aGlzLnNvY2tldC5oYXNMb2dnZXIoKSkgdGhpcy5zb2NrZXQubG9nKFwiY2hhbm5lbFwiLCBgZXJyb3IgJHt0aGlzLnRvcGljfWAsIHJlYXNvbilcbiAgICAgIGlmKHRoaXMuaXNKb2luaW5nKCkpeyB0aGlzLmpvaW5QdXNoLnJlc2V0KCkgfVxuICAgICAgdGhpcy5zdGF0ZSA9IENIQU5ORUxfU1RBVEVTLmVycm9yZWRcbiAgICAgIGlmKHRoaXMuc29ja2V0LmlzQ29ubmVjdGVkKCkpeyB0aGlzLnJlam9pblRpbWVyLnNjaGVkdWxlVGltZW91dCgpIH1cbiAgICB9KVxuICAgIHRoaXMuam9pblB1c2gucmVjZWl2ZShcInRpbWVvdXRcIiwgKCkgPT4ge1xuICAgICAgaWYodGhpcy5zb2NrZXQuaGFzTG9nZ2VyKCkpIHRoaXMuc29ja2V0LmxvZyhcImNoYW5uZWxcIiwgYHRpbWVvdXQgJHt0aGlzLnRvcGljfSAoJHt0aGlzLmpvaW5SZWYoKX0pYCwgdGhpcy5qb2luUHVzaC50aW1lb3V0KVxuICAgICAgbGV0IGxlYXZlUHVzaCA9IG5ldyBQdXNoKHRoaXMsIENIQU5ORUxfRVZFTlRTLmxlYXZlLCBjbG9zdXJlKHt9KSwgdGhpcy50aW1lb3V0KVxuICAgICAgbGVhdmVQdXNoLnNlbmQoKVxuICAgICAgdGhpcy5zdGF0ZSA9IENIQU5ORUxfU1RBVEVTLmVycm9yZWRcbiAgICAgIHRoaXMuam9pblB1c2gucmVzZXQoKVxuICAgICAgaWYodGhpcy5zb2NrZXQuaXNDb25uZWN0ZWQoKSl7IHRoaXMucmVqb2luVGltZXIuc2NoZWR1bGVUaW1lb3V0KCkgfVxuICAgIH0pXG4gICAgdGhpcy5vbihDSEFOTkVMX0VWRU5UUy5yZXBseSwgKHBheWxvYWQsIHJlZikgPT4ge1xuICAgICAgdGhpcy50cmlnZ2VyKHRoaXMucmVwbHlFdmVudE5hbWUocmVmKSwgcGF5bG9hZClcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEpvaW4gdGhlIGNoYW5uZWxcbiAgICogQHBhcmFtIHtpbnRlZ2VyfSB0aW1lb3V0XG4gICAqIEByZXR1cm5zIHtQdXNofVxuICAgKi9cbiAgam9pbih0aW1lb3V0ID0gdGhpcy50aW1lb3V0KXtcbiAgICBpZih0aGlzLmpvaW5lZE9uY2Upe1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHJpZWQgdG8gam9pbiBtdWx0aXBsZSB0aW1lcy4gJ2pvaW4nIGNhbiBvbmx5IGJlIGNhbGxlZCBhIHNpbmdsZSB0aW1lIHBlciBjaGFubmVsIGluc3RhbmNlXCIpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudGltZW91dCA9IHRpbWVvdXRcbiAgICAgIHRoaXMuam9pbmVkT25jZSA9IHRydWVcbiAgICAgIHRoaXMucmVqb2luKClcbiAgICAgIHJldHVybiB0aGlzLmpvaW5QdXNoXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEhvb2sgaW50byBjaGFubmVsIGNsb3NlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBvbkNsb3NlKGNhbGxiYWNrKXtcbiAgICB0aGlzLm9uKENIQU5ORUxfRVZFTlRTLmNsb3NlLCBjYWxsYmFjaylcbiAgfVxuXG4gIC8qKlxuICAgKiBIb29rIGludG8gY2hhbm5lbCBlcnJvcnNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIG9uRXJyb3IoY2FsbGJhY2spe1xuICAgIHJldHVybiB0aGlzLm9uKENIQU5ORUxfRVZFTlRTLmVycm9yLCByZWFzb24gPT4gY2FsbGJhY2socmVhc29uKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBTdWJzY3JpYmVzIG9uIGNoYW5uZWwgZXZlbnRzXG4gICAqXG4gICAqIFN1YnNjcmlwdGlvbiByZXR1cm5zIGEgcmVmIGNvdW50ZXIsIHdoaWNoIGNhbiBiZSB1c2VkIGxhdGVyIHRvXG4gICAqIHVuc3Vic2NyaWJlIHRoZSBleGFjdCBldmVudCBsaXN0ZW5lclxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBjb25zdCByZWYxID0gY2hhbm5lbC5vbihcImV2ZW50XCIsIGRvX3N0dWZmKVxuICAgKiBjb25zdCByZWYyID0gY2hhbm5lbC5vbihcImV2ZW50XCIsIGRvX290aGVyX3N0dWZmKVxuICAgKiBjaGFubmVsLm9mZihcImV2ZW50XCIsIHJlZjEpXG4gICAqIC8vIFNpbmNlIHVuc3Vic2NyaXB0aW9uLCBkb19zdHVmZiB3b24ndCBmaXJlLFxuICAgKiAvLyB3aGlsZSBkb19vdGhlcl9zdHVmZiB3aWxsIGtlZXAgZmlyaW5nIG9uIHRoZSBcImV2ZW50XCJcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHtpbnRlZ2VyfSByZWZcbiAgICovXG4gIG9uKGV2ZW50LCBjYWxsYmFjayl7XG4gICAgbGV0IHJlZiA9IHRoaXMuYmluZGluZ1JlZisrXG4gICAgdGhpcy5iaW5kaW5ncy5wdXNoKHtldmVudCwgcmVmLCBjYWxsYmFja30pXG4gICAgcmV0dXJuIHJlZlxuICB9XG5cbiAgLyoqXG4gICAqIFVuc3Vic2NyaWJlcyBvZmYgb2YgY2hhbm5lbCBldmVudHNcbiAgICpcbiAgICogVXNlIHRoZSByZWYgcmV0dXJuZWQgZnJvbSBhIGNoYW5uZWwub24oKSB0byB1bnN1YnNjcmliZSBvbmVcbiAgICogaGFuZGxlciwgb3IgcGFzcyBub3RoaW5nIGZvciB0aGUgcmVmIHRvIHVuc3Vic2NyaWJlIGFsbFxuICAgKiBoYW5kbGVycyBmb3IgdGhlIGdpdmVuIGV2ZW50LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBVbnN1YnNjcmliZSB0aGUgZG9fc3R1ZmYgaGFuZGxlclxuICAgKiBjb25zdCByZWYxID0gY2hhbm5lbC5vbihcImV2ZW50XCIsIGRvX3N0dWZmKVxuICAgKiBjaGFubmVsLm9mZihcImV2ZW50XCIsIHJlZjEpXG4gICAqXG4gICAqIC8vIFVuc3Vic2NyaWJlIGFsbCBoYW5kbGVycyBmcm9tIGV2ZW50XG4gICAqIGNoYW5uZWwub2ZmKFwiZXZlbnRcIilcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50XG4gICAqIEBwYXJhbSB7aW50ZWdlcn0gcmVmXG4gICAqL1xuICBvZmYoZXZlbnQsIHJlZil7XG4gICAgdGhpcy5iaW5kaW5ncyA9IHRoaXMuYmluZGluZ3MuZmlsdGVyKChiaW5kKSA9PiB7XG4gICAgICByZXR1cm4gIShiaW5kLmV2ZW50ID09PSBldmVudCAmJiAodHlwZW9mIHJlZiA9PT0gXCJ1bmRlZmluZWRcIiB8fCByZWYgPT09IGJpbmQucmVmKSlcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjYW5QdXNoKCl7IHJldHVybiB0aGlzLnNvY2tldC5pc0Nvbm5lY3RlZCgpICYmIHRoaXMuaXNKb2luZWQoKSB9XG5cbiAgLyoqXG4gICAqIFNlbmRzIGEgbWVzc2FnZSBgZXZlbnRgIHRvIHBob2VuaXggd2l0aCB0aGUgcGF5bG9hZCBgcGF5bG9hZGAuXG4gICAqIFBob2VuaXggcmVjZWl2ZXMgdGhpcyBpbiB0aGUgYGhhbmRsZV9pbihldmVudCwgcGF5bG9hZCwgc29ja2V0KWBcbiAgICogZnVuY3Rpb24uIGlmIHBob2VuaXggcmVwbGllcyBvciBpdCB0aW1lcyBvdXQgKGRlZmF1bHQgMTAwMDBtcyksXG4gICAqIHRoZW4gb3B0aW9uYWxseSB0aGUgcmVwbHkgY2FuIGJlIHJlY2VpdmVkLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBjaGFubmVsLnB1c2goXCJldmVudFwiKVxuICAgKiAgIC5yZWNlaXZlKFwib2tcIiwgcGF5bG9hZCA9PiBjb25zb2xlLmxvZyhcInBob2VuaXggcmVwbGllZDpcIiwgcGF5bG9hZCkpXG4gICAqICAgLnJlY2VpdmUoXCJlcnJvclwiLCBlcnIgPT4gY29uc29sZS5sb2coXCJwaG9lbml4IGVycm9yZWRcIiwgZXJyKSlcbiAgICogICAucmVjZWl2ZShcInRpbWVvdXRcIiwgKCkgPT4gY29uc29sZS5sb2coXCJ0aW1lZCBvdXQgcHVzaGluZ1wiKSlcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXlsb2FkXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbdGltZW91dF1cbiAgICogQHJldHVybnMge1B1c2h9XG4gICAqL1xuICBwdXNoKGV2ZW50LCBwYXlsb2FkLCB0aW1lb3V0ID0gdGhpcy50aW1lb3V0KXtcbiAgICBwYXlsb2FkID0gcGF5bG9hZCB8fCB7fVxuICAgIGlmKCF0aGlzLmpvaW5lZE9uY2Upe1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGB0cmllZCB0byBwdXNoICcke2V2ZW50fScgdG8gJyR7dGhpcy50b3BpY30nIGJlZm9yZSBqb2luaW5nLiBVc2UgY2hhbm5lbC5qb2luKCkgYmVmb3JlIHB1c2hpbmcgZXZlbnRzYClcbiAgICB9XG4gICAgbGV0IHB1c2hFdmVudCA9IG5ldyBQdXNoKHRoaXMsIGV2ZW50LCBmdW5jdGlvbiAoKXsgcmV0dXJuIHBheWxvYWQgfSwgdGltZW91dClcbiAgICBpZih0aGlzLmNhblB1c2goKSl7XG4gICAgICBwdXNoRXZlbnQuc2VuZCgpXG4gICAgfSBlbHNlIHtcbiAgICAgIHB1c2hFdmVudC5zdGFydFRpbWVvdXQoKVxuICAgICAgdGhpcy5wdXNoQnVmZmVyLnB1c2gocHVzaEV2ZW50KVxuICAgIH1cblxuICAgIHJldHVybiBwdXNoRXZlbnRcbiAgfVxuXG4gIC8qKiBMZWF2ZXMgdGhlIGNoYW5uZWxcbiAgICpcbiAgICogVW5zdWJzY3JpYmVzIGZyb20gc2VydmVyIGV2ZW50cywgYW5kXG4gICAqIGluc3RydWN0cyBjaGFubmVsIHRvIHRlcm1pbmF0ZSBvbiBzZXJ2ZXJcbiAgICpcbiAgICogVHJpZ2dlcnMgb25DbG9zZSgpIGhvb2tzXG4gICAqXG4gICAqIFRvIHJlY2VpdmUgbGVhdmUgYWNrbm93bGVkZ2VtZW50cywgdXNlIHRoZSBgcmVjZWl2ZWBcbiAgICogaG9vayB0byBiaW5kIHRvIHRoZSBzZXJ2ZXIgYWNrLCBpZTpcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogY2hhbm5lbC5sZWF2ZSgpLnJlY2VpdmUoXCJva1wiLCAoKSA9PiBhbGVydChcImxlZnQhXCIpIClcbiAgICpcbiAgICogQHBhcmFtIHtpbnRlZ2VyfSB0aW1lb3V0XG4gICAqIEByZXR1cm5zIHtQdXNofVxuICAgKi9cbiAgbGVhdmUodGltZW91dCA9IHRoaXMudGltZW91dCl7XG4gICAgdGhpcy5yZWpvaW5UaW1lci5yZXNldCgpXG4gICAgdGhpcy5qb2luUHVzaC5jYW5jZWxUaW1lb3V0KClcblxuICAgIHRoaXMuc3RhdGUgPSBDSEFOTkVMX1NUQVRFUy5sZWF2aW5nXG4gICAgbGV0IG9uQ2xvc2UgPSAoKSA9PiB7XG4gICAgICBpZih0aGlzLnNvY2tldC5oYXNMb2dnZXIoKSkgdGhpcy5zb2NrZXQubG9nKFwiY2hhbm5lbFwiLCBgbGVhdmUgJHt0aGlzLnRvcGljfWApXG4gICAgICB0aGlzLnRyaWdnZXIoQ0hBTk5FTF9FVkVOVFMuY2xvc2UsIFwibGVhdmVcIilcbiAgICB9XG4gICAgbGV0IGxlYXZlUHVzaCA9IG5ldyBQdXNoKHRoaXMsIENIQU5ORUxfRVZFTlRTLmxlYXZlLCBjbG9zdXJlKHt9KSwgdGltZW91dClcbiAgICBsZWF2ZVB1c2gucmVjZWl2ZShcIm9rXCIsICgpID0+IG9uQ2xvc2UoKSlcbiAgICAgIC5yZWNlaXZlKFwidGltZW91dFwiLCAoKSA9PiBvbkNsb3NlKCkpXG4gICAgbGVhdmVQdXNoLnNlbmQoKVxuICAgIGlmKCF0aGlzLmNhblB1c2goKSl7IGxlYXZlUHVzaC50cmlnZ2VyKFwib2tcIiwge30pIH1cblxuICAgIHJldHVybiBsZWF2ZVB1c2hcbiAgfVxuXG4gIC8qKlxuICAgKiBPdmVycmlkYWJsZSBtZXNzYWdlIGhvb2tcbiAgICpcbiAgICogUmVjZWl2ZXMgYWxsIGV2ZW50cyBmb3Igc3BlY2lhbGl6ZWQgbWVzc2FnZSBoYW5kbGluZ1xuICAgKiBiZWZvcmUgZGlzcGF0Y2hpbmcgdG8gdGhlIGNoYW5uZWwgY2FsbGJhY2tzLlxuICAgKlxuICAgKiBNdXN0IHJldHVybiB0aGUgcGF5bG9hZCwgbW9kaWZpZWQgb3IgdW5tb2RpZmllZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IHBheWxvYWRcbiAgICogQHBhcmFtIHtpbnRlZ2VyfSByZWZcbiAgICogQHJldHVybnMge09iamVjdH1cbiAgICovXG4gIG9uTWVzc2FnZShfZXZlbnQsIHBheWxvYWQsIF9yZWYpeyByZXR1cm4gcGF5bG9hZCB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBpc01lbWJlcih0b3BpYywgZXZlbnQsIHBheWxvYWQsIGpvaW5SZWYpe1xuICAgIGlmKHRoaXMudG9waWMgIT09IHRvcGljKXsgcmV0dXJuIGZhbHNlIH1cblxuICAgIGlmKGpvaW5SZWYgJiYgam9pblJlZiAhPT0gdGhpcy5qb2luUmVmKCkpe1xuICAgICAgaWYodGhpcy5zb2NrZXQuaGFzTG9nZ2VyKCkpIHRoaXMuc29ja2V0LmxvZyhcImNoYW5uZWxcIiwgXCJkcm9wcGluZyBvdXRkYXRlZCBtZXNzYWdlXCIsIHt0b3BpYywgZXZlbnQsIHBheWxvYWQsIGpvaW5SZWZ9KVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBqb2luUmVmKCl7IHJldHVybiB0aGlzLmpvaW5QdXNoLnJlZiB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICByZWpvaW4odGltZW91dCA9IHRoaXMudGltZW91dCl7XG4gICAgaWYodGhpcy5pc0xlYXZpbmcoKSl7IHJldHVybiB9XG4gICAgdGhpcy5zb2NrZXQubGVhdmVPcGVuVG9waWModGhpcy50b3BpYylcbiAgICB0aGlzLnN0YXRlID0gQ0hBTk5FTF9TVEFURVMuam9pbmluZ1xuICAgIHRoaXMuam9pblB1c2gucmVzZW5kKHRpbWVvdXQpXG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRyaWdnZXIoZXZlbnQsIHBheWxvYWQsIHJlZiwgam9pblJlZil7XG4gICAgbGV0IGhhbmRsZWRQYXlsb2FkID0gdGhpcy5vbk1lc3NhZ2UoZXZlbnQsIHBheWxvYWQsIHJlZiwgam9pblJlZilcbiAgICBpZihwYXlsb2FkICYmICFoYW5kbGVkUGF5bG9hZCl7IHRocm93IG5ldyBFcnJvcihcImNoYW5uZWwgb25NZXNzYWdlIGNhbGxiYWNrcyBtdXN0IHJldHVybiB0aGUgcGF5bG9hZCwgbW9kaWZpZWQgb3IgdW5tb2RpZmllZFwiKSB9XG5cbiAgICBsZXQgZXZlbnRCaW5kaW5ncyA9IHRoaXMuYmluZGluZ3MuZmlsdGVyKGJpbmQgPT4gYmluZC5ldmVudCA9PT0gZXZlbnQpXG5cbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgZXZlbnRCaW5kaW5ncy5sZW5ndGg7IGkrKyl7XG4gICAgICBsZXQgYmluZCA9IGV2ZW50QmluZGluZ3NbaV1cbiAgICAgIGJpbmQuY2FsbGJhY2soaGFuZGxlZFBheWxvYWQsIHJlZiwgam9pblJlZiB8fCB0aGlzLmpvaW5SZWYoKSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHJlcGx5RXZlbnROYW1lKHJlZil7IHJldHVybiBgY2hhbl9yZXBseV8ke3JlZn1gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGlzQ2xvc2VkKCl7IHJldHVybiB0aGlzLnN0YXRlID09PSBDSEFOTkVMX1NUQVRFUy5jbG9zZWQgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaXNFcnJvcmVkKCl7IHJldHVybiB0aGlzLnN0YXRlID09PSBDSEFOTkVMX1NUQVRFUy5lcnJvcmVkIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGlzSm9pbmVkKCl7IHJldHVybiB0aGlzLnN0YXRlID09PSBDSEFOTkVMX1NUQVRFUy5qb2luZWQgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaXNKb2luaW5nKCl7IHJldHVybiB0aGlzLnN0YXRlID09PSBDSEFOTkVMX1NUQVRFUy5qb2luaW5nIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGlzTGVhdmluZygpeyByZXR1cm4gdGhpcy5zdGF0ZSA9PT0gQ0hBTk5FTF9TVEFURVMubGVhdmluZyB9XG59XG4iLCAiaW1wb3J0IHtcbiAgZ2xvYmFsLFxuICBYSFJfU1RBVEVTXG59IGZyb20gXCIuL2NvbnN0YW50c1wiXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFqYXgge1xuXG4gIHN0YXRpYyByZXF1ZXN0KG1ldGhvZCwgZW5kUG9pbnQsIGFjY2VwdCwgYm9keSwgdGltZW91dCwgb250aW1lb3V0LCBjYWxsYmFjayl7XG4gICAgaWYoZ2xvYmFsLlhEb21haW5SZXF1ZXN0KXtcbiAgICAgIGxldCByZXEgPSBuZXcgZ2xvYmFsLlhEb21haW5SZXF1ZXN0KCkgLy8gSUU4LCBJRTlcbiAgICAgIHRoaXMueGRvbWFpblJlcXVlc3QocmVxLCBtZXRob2QsIGVuZFBvaW50LCBib2R5LCB0aW1lb3V0LCBvbnRpbWVvdXQsIGNhbGxiYWNrKVxuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgcmVxID0gbmV3IGdsb2JhbC5YTUxIdHRwUmVxdWVzdCgpIC8vIElFNyssIEZpcmVmb3gsIENocm9tZSwgT3BlcmEsIFNhZmFyaVxuICAgICAgdGhpcy54aHJSZXF1ZXN0KHJlcSwgbWV0aG9kLCBlbmRQb2ludCwgYWNjZXB0LCBib2R5LCB0aW1lb3V0LCBvbnRpbWVvdXQsIGNhbGxiYWNrKVxuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyB4ZG9tYWluUmVxdWVzdChyZXEsIG1ldGhvZCwgZW5kUG9pbnQsIGJvZHksIHRpbWVvdXQsIG9udGltZW91dCwgY2FsbGJhY2spe1xuICAgIHJlcS50aW1lb3V0ID0gdGltZW91dFxuICAgIHJlcS5vcGVuKG1ldGhvZCwgZW5kUG9pbnQpXG4gICAgcmVxLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgIGxldCByZXNwb25zZSA9IHRoaXMucGFyc2VKU09OKHJlcS5yZXNwb25zZVRleHQpXG4gICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhyZXNwb25zZSlcbiAgICB9XG4gICAgaWYob250aW1lb3V0KXsgcmVxLm9udGltZW91dCA9IG9udGltZW91dCB9XG5cbiAgICAvLyBXb3JrIGFyb3VuZCBidWcgaW4gSUU5IHRoYXQgcmVxdWlyZXMgYW4gYXR0YWNoZWQgb25wcm9ncmVzcyBoYW5kbGVyXG4gICAgcmVxLm9ucHJvZ3Jlc3MgPSAoKSA9PiB7IH1cblxuICAgIHJlcS5zZW5kKGJvZHkpXG4gIH1cblxuICBzdGF0aWMgeGhyUmVxdWVzdChyZXEsIG1ldGhvZCwgZW5kUG9pbnQsIGFjY2VwdCwgYm9keSwgdGltZW91dCwgb250aW1lb3V0LCBjYWxsYmFjayl7XG4gICAgcmVxLm9wZW4obWV0aG9kLCBlbmRQb2ludCwgdHJ1ZSlcbiAgICByZXEudGltZW91dCA9IHRpbWVvdXRcbiAgICByZXEuc2V0UmVxdWVzdEhlYWRlcihcIkNvbnRlbnQtVHlwZVwiLCBhY2NlcHQpXG4gICAgcmVxLm9uZXJyb3IgPSAoKSA9PiB7IGNhbGxiYWNrICYmIGNhbGxiYWNrKG51bGwpIH1cbiAgICByZXEub25yZWFkeXN0YXRlY2hhbmdlID0gKCkgPT4ge1xuICAgICAgaWYocmVxLnJlYWR5U3RhdGUgPT09IFhIUl9TVEFURVMuY29tcGxldGUgJiYgY2FsbGJhY2spe1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSB0aGlzLnBhcnNlSlNPTihyZXEucmVzcG9uc2VUZXh0KVxuICAgICAgICBjYWxsYmFjayhyZXNwb25zZSlcbiAgICAgIH1cbiAgICB9XG4gICAgaWYob250aW1lb3V0KXsgcmVxLm9udGltZW91dCA9IG9udGltZW91dCB9XG5cbiAgICByZXEuc2VuZChib2R5KVxuICB9XG5cbiAgc3RhdGljIHBhcnNlSlNPTihyZXNwKXtcbiAgICBpZighcmVzcCB8fCByZXNwID09PSBcIlwiKXsgcmV0dXJuIG51bGwgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBKU09OLnBhcnNlKHJlc3ApXG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICBjb25zb2xlICYmIGNvbnNvbGUubG9nKFwiZmFpbGVkIHRvIHBhcnNlIEpTT04gcmVzcG9uc2VcIiwgcmVzcClcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICB9XG5cbiAgc3RhdGljIHNlcmlhbGl6ZShvYmosIHBhcmVudEtleSl7XG4gICAgbGV0IHF1ZXJ5U3RyID0gW11cbiAgICBmb3IodmFyIGtleSBpbiBvYmope1xuICAgICAgaWYoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpeyBjb250aW51ZSB9XG4gICAgICBsZXQgcGFyYW1LZXkgPSBwYXJlbnRLZXkgPyBgJHtwYXJlbnRLZXl9WyR7a2V5fV1gIDoga2V5XG4gICAgICBsZXQgcGFyYW1WYWwgPSBvYmpba2V5XVxuICAgICAgaWYodHlwZW9mIHBhcmFtVmFsID09PSBcIm9iamVjdFwiKXtcbiAgICAgICAgcXVlcnlTdHIucHVzaCh0aGlzLnNlcmlhbGl6ZShwYXJhbVZhbCwgcGFyYW1LZXkpKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcXVlcnlTdHIucHVzaChlbmNvZGVVUklDb21wb25lbnQocGFyYW1LZXkpICsgXCI9XCIgKyBlbmNvZGVVUklDb21wb25lbnQocGFyYW1WYWwpKVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcXVlcnlTdHIuam9pbihcIiZcIilcbiAgfVxuXG4gIHN0YXRpYyBhcHBlbmRQYXJhbXModXJsLCBwYXJhbXMpe1xuICAgIGlmKE9iamVjdC5rZXlzKHBhcmFtcykubGVuZ3RoID09PSAwKXsgcmV0dXJuIHVybCB9XG5cbiAgICBsZXQgcHJlZml4ID0gdXJsLm1hdGNoKC9cXD8vKSA/IFwiJlwiIDogXCI/XCJcbiAgICByZXR1cm4gYCR7dXJsfSR7cHJlZml4fSR7dGhpcy5zZXJpYWxpemUocGFyYW1zKX1gXG4gIH1cbn1cbiIsICJpbXBvcnQge1xuICBTT0NLRVRfU1RBVEVTLFxuICBUUkFOU1BPUlRTXG59IGZyb20gXCIuL2NvbnN0YW50c1wiXG5cbmltcG9ydCBBamF4IGZyb20gXCIuL2FqYXhcIlxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMb25nUG9sbCB7XG5cbiAgY29uc3RydWN0b3IoZW5kUG9pbnQpe1xuICAgIHRoaXMuZW5kUG9pbnQgPSBudWxsXG4gICAgdGhpcy50b2tlbiA9IG51bGxcbiAgICB0aGlzLnNraXBIZWFydGJlYXQgPSB0cnVlXG4gICAgdGhpcy5vbm9wZW4gPSBmdW5jdGlvbiAoKXsgfSAvLyBub29wXG4gICAgdGhpcy5vbmVycm9yID0gZnVuY3Rpb24gKCl7IH0gLy8gbm9vcFxuICAgIHRoaXMub25tZXNzYWdlID0gZnVuY3Rpb24gKCl7IH0gLy8gbm9vcFxuICAgIHRoaXMub25jbG9zZSA9IGZ1bmN0aW9uICgpeyB9IC8vIG5vb3BcbiAgICB0aGlzLnBvbGxFbmRwb2ludCA9IHRoaXMubm9ybWFsaXplRW5kcG9pbnQoZW5kUG9pbnQpXG4gICAgdGhpcy5yZWFkeVN0YXRlID0gU09DS0VUX1NUQVRFUy5jb25uZWN0aW5nXG4gICAgdGhpcy5wb2xsKClcbiAgfVxuXG4gIG5vcm1hbGl6ZUVuZHBvaW50KGVuZFBvaW50KXtcbiAgICByZXR1cm4gKGVuZFBvaW50XG4gICAgICAucmVwbGFjZShcIndzOi8vXCIsIFwiaHR0cDovL1wiKVxuICAgICAgLnJlcGxhY2UoXCJ3c3M6Ly9cIiwgXCJodHRwczovL1wiKVxuICAgICAgLnJlcGxhY2UobmV3IFJlZ0V4cChcIiguKilcXC9cIiArIFRSQU5TUE9SVFMud2Vic29ja2V0KSwgXCIkMS9cIiArIFRSQU5TUE9SVFMubG9uZ3BvbGwpKVxuICB9XG5cbiAgZW5kcG9pbnRVUkwoKXtcbiAgICByZXR1cm4gQWpheC5hcHBlbmRQYXJhbXModGhpcy5wb2xsRW5kcG9pbnQsIHt0b2tlbjogdGhpcy50b2tlbn0pXG4gIH1cblxuICBjbG9zZUFuZFJldHJ5KGNvZGUsIHJlYXNvbiwgd2FzQ2xlYW4pe1xuICAgIHRoaXMuY2xvc2UoY29kZSwgcmVhc29uLCB3YXNDbGVhbilcbiAgICB0aGlzLnJlYWR5U3RhdGUgPSBTT0NLRVRfU1RBVEVTLmNvbm5lY3RpbmdcbiAgfVxuXG4gIG9udGltZW91dCgpe1xuICAgIHRoaXMub25lcnJvcihcInRpbWVvdXRcIilcbiAgICB0aGlzLmNsb3NlQW5kUmV0cnkoMTAwNSwgXCJ0aW1lb3V0XCIsIGZhbHNlKVxuICB9XG5cbiAgcG9sbCgpe1xuICAgIGlmKCEodGhpcy5yZWFkeVN0YXRlID09PSBTT0NLRVRfU1RBVEVTLm9wZW4gfHwgdGhpcy5yZWFkeVN0YXRlID09PSBTT0NLRVRfU1RBVEVTLmNvbm5lY3RpbmcpKXsgcmV0dXJuIH1cblxuICAgIEFqYXgucmVxdWVzdChcIkdFVFwiLCB0aGlzLmVuZHBvaW50VVJMKCksIFwiYXBwbGljYXRpb24vanNvblwiLCBudWxsLCB0aGlzLnRpbWVvdXQsIHRoaXMub250aW1lb3V0LmJpbmQodGhpcyksIChyZXNwKSA9PiB7XG4gICAgICBpZihyZXNwKXtcbiAgICAgICAgdmFyIHtzdGF0dXMsIHRva2VuLCBtZXNzYWdlc30gPSByZXNwXG4gICAgICAgIHRoaXMudG9rZW4gPSB0b2tlblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdHVzID0gMFxuICAgICAgfVxuXG4gICAgICBzd2l0Y2goc3RhdHVzKXtcbiAgICAgICAgY2FzZSAyMDA6XG4gICAgICAgICAgbWVzc2FnZXMuZm9yRWFjaChtc2cgPT4ge1xuICAgICAgICAgICAgLy8gVGFza3MgYXJlIHdoYXQgdGhpbmdzIGxpa2UgZXZlbnQgaGFuZGxlcnMsIHNldFRpbWVvdXQgY2FsbGJhY2tzLFxuICAgICAgICAgICAgLy8gcHJvbWlzZSByZXNvbHZlcyBhbmQgbW9yZSBhcmUgcnVuIHdpdGhpbi5cbiAgICAgICAgICAgIC8vIEluIG1vZGVybiBicm93c2VycywgdGhlcmUgYXJlIHR3byBkaWZmZXJlbnQga2luZHMgb2YgdGFza3MsXG4gICAgICAgICAgICAvLyBtaWNyb3Rhc2tzIGFuZCBtYWNyb3Rhc2tzLlxuICAgICAgICAgICAgLy8gTWljcm90YXNrcyBhcmUgbWFpbmx5IHVzZWQgZm9yIFByb21pc2VzLCB3aGlsZSBtYWNyb3Rhc2tzIGFyZVxuICAgICAgICAgICAgLy8gdXNlZCBmb3IgZXZlcnl0aGluZyBlbHNlLlxuICAgICAgICAgICAgLy8gTWljcm90YXNrcyBhbHdheXMgaGF2ZSBwcmlvcml0eSBvdmVyIG1hY3JvdGFza3MuIElmIHRoZSBKUyBlbmdpbmVcbiAgICAgICAgICAgIC8vIGlzIGxvb2tpbmcgZm9yIGEgdGFzayB0byBydW4sIGl0IHdpbGwgYWx3YXlzIHRyeSB0byBlbXB0eSB0aGVcbiAgICAgICAgICAgIC8vIG1pY3JvdGFzayBxdWV1ZSBiZWZvcmUgYXR0ZW1wdGluZyB0byBydW4gYW55dGhpbmcgZnJvbSB0aGVcbiAgICAgICAgICAgIC8vIG1hY3JvdGFzayBxdWV1ZS5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBGb3IgdGhlIFdlYlNvY2tldCB0cmFuc3BvcnQsIG1lc3NhZ2VzIGFsd2F5cyBhcnJpdmUgaW4gdGhlaXIgb3duXG4gICAgICAgICAgICAvLyBldmVudC4gVGhpcyBtZWFucyB0aGF0IGlmIGFueSBwcm9taXNlcyBhcmUgcmVzb2x2ZWQgZnJvbSB3aXRoaW4sXG4gICAgICAgICAgICAvLyB0aGVpciBjYWxsYmFja3Mgd2lsbCBhbHdheXMgZmluaXNoIGV4ZWN1dGlvbiBieSB0aGUgdGltZSB0aGVcbiAgICAgICAgICAgIC8vIG5leHQgbWVzc2FnZSBldmVudCBoYW5kbGVyIGlzIHJ1bi5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBJbiBvcmRlciB0byBlbXVsYXRlIHRoaXMgYmVoYXZpb3VyLCB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSBlYWNoXG4gICAgICAgICAgICAvLyBvbm1lc3NhZ2UgaGFuZGxlciBpcyBydW4gd2l0aGluIGl0J3Mgb3duIG1hY3JvdGFzay5cbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICB0aGlzLm9ubWVzc2FnZSh7ZGF0YTogbXNnfSlcbiAgICAgICAgICAgIH0sIDApXG4gICAgICAgICAgfSlcbiAgICAgICAgICB0aGlzLnBvbGwoKVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMjA0OlxuICAgICAgICAgIHRoaXMucG9sbCgpXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA0MTA6XG4gICAgICAgICAgdGhpcy5yZWFkeVN0YXRlID0gU09DS0VUX1NUQVRFUy5vcGVuXG4gICAgICAgICAgdGhpcy5vbm9wZW4oe30pXG4gICAgICAgICAgdGhpcy5wb2xsKClcbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDQwMzpcbiAgICAgICAgICB0aGlzLm9uZXJyb3IoNDAzKVxuICAgICAgICAgIHRoaXMuY2xvc2UoMTAwOCwgXCJmb3JiaWRkZW5cIiwgZmFsc2UpXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICBjYXNlIDUwMDpcbiAgICAgICAgICB0aGlzLm9uZXJyb3IoNTAwKVxuICAgICAgICAgIHRoaXMuY2xvc2VBbmRSZXRyeSgxMDExLCBcImludGVybmFsIHNlcnZlciBlcnJvclwiLCA1MDApXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKGB1bmhhbmRsZWQgcG9sbCBzdGF0dXMgJHtzdGF0dXN9YClcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgc2VuZChib2R5KXtcbiAgICBBamF4LnJlcXVlc3QoXCJQT1NUXCIsIHRoaXMuZW5kcG9pbnRVUkwoKSwgXCJhcHBsaWNhdGlvbi9qc29uXCIsIGJvZHksIHRoaXMudGltZW91dCwgdGhpcy5vbmVycm9yLmJpbmQodGhpcywgXCJ0aW1lb3V0XCIpLCAocmVzcCkgPT4ge1xuICAgICAgaWYoIXJlc3AgfHwgcmVzcC5zdGF0dXMgIT09IDIwMCl7XG4gICAgICAgIHRoaXMub25lcnJvcihyZXNwICYmIHJlc3Auc3RhdHVzKVxuICAgICAgICB0aGlzLmNsb3NlQW5kUmV0cnkoMTAxMSwgXCJpbnRlcm5hbCBzZXJ2ZXIgZXJyb3JcIiwgZmFsc2UpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIGNsb3NlKGNvZGUsIHJlYXNvbiwgd2FzQ2xlYW4pe1xuICAgIHRoaXMucmVhZHlTdGF0ZSA9IFNPQ0tFVF9TVEFURVMuY2xvc2VkXG4gICAgbGV0IG9wdHMgPSBPYmplY3QuYXNzaWduKHtjb2RlOiAxMDAwLCByZWFzb246IHVuZGVmaW5lZCwgd2FzQ2xlYW46IHRydWV9LCB7Y29kZSwgcmVhc29uLCB3YXNDbGVhbn0pXG4gICAgaWYodHlwZW9mKENsb3NlRXZlbnQpICE9PSBcInVuZGVmaW5lZFwiKXtcbiAgICAgIHRoaXMub25jbG9zZShuZXcgQ2xvc2VFdmVudChcImNsb3NlXCIsIG9wdHMpKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm9uY2xvc2Uob3B0cylcbiAgICB9XG4gIH1cbn1cbiIsICIvKipcbiAqIEluaXRpYWxpemVzIHRoZSBQcmVzZW5jZVxuICogQHBhcmFtIHtDaGFubmVsfSBjaGFubmVsIC0gVGhlIENoYW5uZWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gVGhlIG9wdGlvbnMsXG4gKiAgICAgICAgZm9yIGV4YW1wbGUgYHtldmVudHM6IHtzdGF0ZTogXCJzdGF0ZVwiLCBkaWZmOiBcImRpZmZcIn19YFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQcmVzZW5jZSB7XG5cbiAgY29uc3RydWN0b3IoY2hhbm5lbCwgb3B0cyA9IHt9KXtcbiAgICBsZXQgZXZlbnRzID0gb3B0cy5ldmVudHMgfHwge3N0YXRlOiBcInByZXNlbmNlX3N0YXRlXCIsIGRpZmY6IFwicHJlc2VuY2VfZGlmZlwifVxuICAgIHRoaXMuc3RhdGUgPSB7fVxuICAgIHRoaXMucGVuZGluZ0RpZmZzID0gW11cbiAgICB0aGlzLmNoYW5uZWwgPSBjaGFubmVsXG4gICAgdGhpcy5qb2luUmVmID0gbnVsbFxuICAgIHRoaXMuY2FsbGVyID0ge1xuICAgICAgb25Kb2luOiBmdW5jdGlvbiAoKXsgfSxcbiAgICAgIG9uTGVhdmU6IGZ1bmN0aW9uICgpeyB9LFxuICAgICAgb25TeW5jOiBmdW5jdGlvbiAoKXsgfVxuICAgIH1cblxuICAgIHRoaXMuY2hhbm5lbC5vbihldmVudHMuc3RhdGUsIG5ld1N0YXRlID0+IHtcbiAgICAgIGxldCB7b25Kb2luLCBvbkxlYXZlLCBvblN5bmN9ID0gdGhpcy5jYWxsZXJcblxuICAgICAgdGhpcy5qb2luUmVmID0gdGhpcy5jaGFubmVsLmpvaW5SZWYoKVxuICAgICAgdGhpcy5zdGF0ZSA9IFByZXNlbmNlLnN5bmNTdGF0ZSh0aGlzLnN0YXRlLCBuZXdTdGF0ZSwgb25Kb2luLCBvbkxlYXZlKVxuXG4gICAgICB0aGlzLnBlbmRpbmdEaWZmcy5mb3JFYWNoKGRpZmYgPT4ge1xuICAgICAgICB0aGlzLnN0YXRlID0gUHJlc2VuY2Uuc3luY0RpZmYodGhpcy5zdGF0ZSwgZGlmZiwgb25Kb2luLCBvbkxlYXZlKVxuICAgICAgfSlcbiAgICAgIHRoaXMucGVuZGluZ0RpZmZzID0gW11cbiAgICAgIG9uU3luYygpXG4gICAgfSlcblxuICAgIHRoaXMuY2hhbm5lbC5vbihldmVudHMuZGlmZiwgZGlmZiA9PiB7XG4gICAgICBsZXQge29uSm9pbiwgb25MZWF2ZSwgb25TeW5jfSA9IHRoaXMuY2FsbGVyXG5cbiAgICAgIGlmKHRoaXMuaW5QZW5kaW5nU3luY1N0YXRlKCkpe1xuICAgICAgICB0aGlzLnBlbmRpbmdEaWZmcy5wdXNoKGRpZmYpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnN0YXRlID0gUHJlc2VuY2Uuc3luY0RpZmYodGhpcy5zdGF0ZSwgZGlmZiwgb25Kb2luLCBvbkxlYXZlKVxuICAgICAgICBvblN5bmMoKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBvbkpvaW4oY2FsbGJhY2speyB0aGlzLmNhbGxlci5vbkpvaW4gPSBjYWxsYmFjayB9XG5cbiAgb25MZWF2ZShjYWxsYmFjayl7IHRoaXMuY2FsbGVyLm9uTGVhdmUgPSBjYWxsYmFjayB9XG5cbiAgb25TeW5jKGNhbGxiYWNrKXsgdGhpcy5jYWxsZXIub25TeW5jID0gY2FsbGJhY2sgfVxuXG4gIGxpc3QoYnkpeyByZXR1cm4gUHJlc2VuY2UubGlzdCh0aGlzLnN0YXRlLCBieSkgfVxuXG4gIGluUGVuZGluZ1N5bmNTdGF0ZSgpe1xuICAgIHJldHVybiAhdGhpcy5qb2luUmVmIHx8ICh0aGlzLmpvaW5SZWYgIT09IHRoaXMuY2hhbm5lbC5qb2luUmVmKCkpXG4gIH1cblxuICAvLyBsb3dlci1sZXZlbCBwdWJsaWMgc3RhdGljIEFQSVxuXG4gIC8qKlxuICAgKiBVc2VkIHRvIHN5bmMgdGhlIGxpc3Qgb2YgcHJlc2VuY2VzIG9uIHRoZSBzZXJ2ZXJcbiAgICogd2l0aCB0aGUgY2xpZW50J3Mgc3RhdGUuIEFuIG9wdGlvbmFsIGBvbkpvaW5gIGFuZCBgb25MZWF2ZWAgY2FsbGJhY2sgY2FuXG4gICAqIGJlIHByb3ZpZGVkIHRvIHJlYWN0IHRvIGNoYW5nZXMgaW4gdGhlIGNsaWVudCdzIGxvY2FsIHByZXNlbmNlcyBhY3Jvc3NcbiAgICogZGlzY29ubmVjdHMgYW5kIHJlY29ubmVjdHMgd2l0aCB0aGUgc2VydmVyLlxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJlc2VuY2V9XG4gICAqL1xuICBzdGF0aWMgc3luY1N0YXRlKGN1cnJlbnRTdGF0ZSwgbmV3U3RhdGUsIG9uSm9pbiwgb25MZWF2ZSl7XG4gICAgbGV0IHN0YXRlID0gdGhpcy5jbG9uZShjdXJyZW50U3RhdGUpXG4gICAgbGV0IGpvaW5zID0ge31cbiAgICBsZXQgbGVhdmVzID0ge31cblxuICAgIHRoaXMubWFwKHN0YXRlLCAoa2V5LCBwcmVzZW5jZSkgPT4ge1xuICAgICAgaWYoIW5ld1N0YXRlW2tleV0pe1xuICAgICAgICBsZWF2ZXNba2V5XSA9IHByZXNlbmNlXG4gICAgICB9XG4gICAgfSlcbiAgICB0aGlzLm1hcChuZXdTdGF0ZSwgKGtleSwgbmV3UHJlc2VuY2UpID0+IHtcbiAgICAgIGxldCBjdXJyZW50UHJlc2VuY2UgPSBzdGF0ZVtrZXldXG4gICAgICBpZihjdXJyZW50UHJlc2VuY2Upe1xuICAgICAgICBsZXQgbmV3UmVmcyA9IG5ld1ByZXNlbmNlLm1ldGFzLm1hcChtID0+IG0ucGh4X3JlZilcbiAgICAgICAgbGV0IGN1clJlZnMgPSBjdXJyZW50UHJlc2VuY2UubWV0YXMubWFwKG0gPT4gbS5waHhfcmVmKVxuICAgICAgICBsZXQgam9pbmVkTWV0YXMgPSBuZXdQcmVzZW5jZS5tZXRhcy5maWx0ZXIobSA9PiBjdXJSZWZzLmluZGV4T2YobS5waHhfcmVmKSA8IDApXG4gICAgICAgIGxldCBsZWZ0TWV0YXMgPSBjdXJyZW50UHJlc2VuY2UubWV0YXMuZmlsdGVyKG0gPT4gbmV3UmVmcy5pbmRleE9mKG0ucGh4X3JlZikgPCAwKVxuICAgICAgICBpZihqb2luZWRNZXRhcy5sZW5ndGggPiAwKXtcbiAgICAgICAgICBqb2luc1trZXldID0gbmV3UHJlc2VuY2VcbiAgICAgICAgICBqb2luc1trZXldLm1ldGFzID0gam9pbmVkTWV0YXNcbiAgICAgICAgfVxuICAgICAgICBpZihsZWZ0TWV0YXMubGVuZ3RoID4gMCl7XG4gICAgICAgICAgbGVhdmVzW2tleV0gPSB0aGlzLmNsb25lKGN1cnJlbnRQcmVzZW5jZSlcbiAgICAgICAgICBsZWF2ZXNba2V5XS5tZXRhcyA9IGxlZnRNZXRhc1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBqb2luc1trZXldID0gbmV3UHJlc2VuY2VcbiAgICAgIH1cbiAgICB9KVxuICAgIHJldHVybiB0aGlzLnN5bmNEaWZmKHN0YXRlLCB7am9pbnM6IGpvaW5zLCBsZWF2ZXM6IGxlYXZlc30sIG9uSm9pbiwgb25MZWF2ZSlcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBVc2VkIHRvIHN5bmMgYSBkaWZmIG9mIHByZXNlbmNlIGpvaW4gYW5kIGxlYXZlXG4gICAqIGV2ZW50cyBmcm9tIHRoZSBzZXJ2ZXIsIGFzIHRoZXkgaGFwcGVuLiBMaWtlIGBzeW5jU3RhdGVgLCBgc3luY0RpZmZgXG4gICAqIGFjY2VwdHMgb3B0aW9uYWwgYG9uSm9pbmAgYW5kIGBvbkxlYXZlYCBjYWxsYmFja3MgdG8gcmVhY3QgdG8gYSB1c2VyXG4gICAqIGpvaW5pbmcgb3IgbGVhdmluZyBmcm9tIGEgZGV2aWNlLlxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJlc2VuY2V9XG4gICAqL1xuICBzdGF0aWMgc3luY0RpZmYoc3RhdGUsIGRpZmYsIG9uSm9pbiwgb25MZWF2ZSl7XG4gICAgbGV0IHtqb2lucywgbGVhdmVzfSA9IHRoaXMuY2xvbmUoZGlmZilcbiAgICBpZighb25Kb2luKXsgb25Kb2luID0gZnVuY3Rpb24gKCl7IH0gfVxuICAgIGlmKCFvbkxlYXZlKXsgb25MZWF2ZSA9IGZ1bmN0aW9uICgpeyB9IH1cblxuICAgIHRoaXMubWFwKGpvaW5zLCAoa2V5LCBuZXdQcmVzZW5jZSkgPT4ge1xuICAgICAgbGV0IGN1cnJlbnRQcmVzZW5jZSA9IHN0YXRlW2tleV1cbiAgICAgIHN0YXRlW2tleV0gPSB0aGlzLmNsb25lKG5ld1ByZXNlbmNlKVxuICAgICAgaWYoY3VycmVudFByZXNlbmNlKXtcbiAgICAgICAgbGV0IGpvaW5lZFJlZnMgPSBzdGF0ZVtrZXldLm1ldGFzLm1hcChtID0+IG0ucGh4X3JlZilcbiAgICAgICAgbGV0IGN1ck1ldGFzID0gY3VycmVudFByZXNlbmNlLm1ldGFzLmZpbHRlcihtID0+IGpvaW5lZFJlZnMuaW5kZXhPZihtLnBoeF9yZWYpIDwgMClcbiAgICAgICAgc3RhdGVba2V5XS5tZXRhcy51bnNoaWZ0KC4uLmN1ck1ldGFzKVxuICAgICAgfVxuICAgICAgb25Kb2luKGtleSwgY3VycmVudFByZXNlbmNlLCBuZXdQcmVzZW5jZSlcbiAgICB9KVxuICAgIHRoaXMubWFwKGxlYXZlcywgKGtleSwgbGVmdFByZXNlbmNlKSA9PiB7XG4gICAgICBsZXQgY3VycmVudFByZXNlbmNlID0gc3RhdGVba2V5XVxuICAgICAgaWYoIWN1cnJlbnRQcmVzZW5jZSl7IHJldHVybiB9XG4gICAgICBsZXQgcmVmc1RvUmVtb3ZlID0gbGVmdFByZXNlbmNlLm1ldGFzLm1hcChtID0+IG0ucGh4X3JlZilcbiAgICAgIGN1cnJlbnRQcmVzZW5jZS5tZXRhcyA9IGN1cnJlbnRQcmVzZW5jZS5tZXRhcy5maWx0ZXIocCA9PiB7XG4gICAgICAgIHJldHVybiByZWZzVG9SZW1vdmUuaW5kZXhPZihwLnBoeF9yZWYpIDwgMFxuICAgICAgfSlcbiAgICAgIG9uTGVhdmUoa2V5LCBjdXJyZW50UHJlc2VuY2UsIGxlZnRQcmVzZW5jZSlcbiAgICAgIGlmKGN1cnJlbnRQcmVzZW5jZS5tZXRhcy5sZW5ndGggPT09IDApe1xuICAgICAgICBkZWxldGUgc3RhdGVba2V5XVxuICAgICAgfVxuICAgIH0pXG4gICAgcmV0dXJuIHN0YXRlXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJlc2VuY2VzLCB3aXRoIHNlbGVjdGVkIG1ldGFkYXRhLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gcHJlc2VuY2VzXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNob29zZXJcbiAgICpcbiAgICogQHJldHVybnMge1ByZXNlbmNlfVxuICAgKi9cbiAgc3RhdGljIGxpc3QocHJlc2VuY2VzLCBjaG9vc2VyKXtcbiAgICBpZighY2hvb3Nlcil7IGNob29zZXIgPSBmdW5jdGlvbiAoa2V5LCBwcmVzKXsgcmV0dXJuIHByZXMgfSB9XG5cbiAgICByZXR1cm4gdGhpcy5tYXAocHJlc2VuY2VzLCAoa2V5LCBwcmVzZW5jZSkgPT4ge1xuICAgICAgcmV0dXJuIGNob29zZXIoa2V5LCBwcmVzZW5jZSlcbiAgICB9KVxuICB9XG5cbiAgLy8gcHJpdmF0ZVxuXG4gIHN0YXRpYyBtYXAob2JqLCBmdW5jKXtcbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob2JqKS5tYXAoa2V5ID0+IGZ1bmMoa2V5LCBvYmpba2V5XSkpXG4gIH1cblxuICBzdGF0aWMgY2xvbmUob2JqKXsgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkob2JqKSkgfVxufVxuIiwgIi8qIFRoZSBkZWZhdWx0IHNlcmlhbGl6ZXIgZm9yIGVuY29kaW5nIGFuZCBkZWNvZGluZyBtZXNzYWdlcyAqL1xuaW1wb3J0IHtcbiAgQ0hBTk5FTF9FVkVOVFNcbn0gZnJvbSBcIi4vY29uc3RhbnRzXCJcblxuZXhwb3J0IGRlZmF1bHQge1xuICBIRUFERVJfTEVOR1RIOiAxLFxuICBNRVRBX0xFTkdUSDogNCxcbiAgS0lORFM6IHtwdXNoOiAwLCByZXBseTogMSwgYnJvYWRjYXN0OiAyfSxcblxuICBlbmNvZGUobXNnLCBjYWxsYmFjayl7XG4gICAgaWYobXNnLnBheWxvYWQuY29uc3RydWN0b3IgPT09IEFycmF5QnVmZmVyKXtcbiAgICAgIHJldHVybiBjYWxsYmFjayh0aGlzLmJpbmFyeUVuY29kZShtc2cpKVxuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgcGF5bG9hZCA9IFttc2cuam9pbl9yZWYsIG1zZy5yZWYsIG1zZy50b3BpYywgbXNnLmV2ZW50LCBtc2cucGF5bG9hZF1cbiAgICAgIHJldHVybiBjYWxsYmFjayhKU09OLnN0cmluZ2lmeShwYXlsb2FkKSlcbiAgICB9XG4gIH0sXG5cbiAgZGVjb2RlKHJhd1BheWxvYWQsIGNhbGxiYWNrKXtcbiAgICBpZihyYXdQYXlsb2FkLmNvbnN0cnVjdG9yID09PSBBcnJheUJ1ZmZlcil7XG4gICAgICByZXR1cm4gY2FsbGJhY2sodGhpcy5iaW5hcnlEZWNvZGUocmF3UGF5bG9hZCkpXG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBbam9pbl9yZWYsIHJlZiwgdG9waWMsIGV2ZW50LCBwYXlsb2FkXSA9IEpTT04ucGFyc2UocmF3UGF5bG9hZClcbiAgICAgIHJldHVybiBjYWxsYmFjayh7am9pbl9yZWYsIHJlZiwgdG9waWMsIGV2ZW50LCBwYXlsb2FkfSlcbiAgICB9XG4gIH0sXG5cbiAgLy8gcHJpdmF0ZVxuXG4gIGJpbmFyeUVuY29kZShtZXNzYWdlKXtcbiAgICBsZXQge2pvaW5fcmVmLCByZWYsIGV2ZW50LCB0b3BpYywgcGF5bG9hZH0gPSBtZXNzYWdlXG4gICAgbGV0IG1ldGFMZW5ndGggPSB0aGlzLk1FVEFfTEVOR1RIICsgam9pbl9yZWYubGVuZ3RoICsgcmVmLmxlbmd0aCArIHRvcGljLmxlbmd0aCArIGV2ZW50Lmxlbmd0aFxuICAgIGxldCBoZWFkZXIgPSBuZXcgQXJyYXlCdWZmZXIodGhpcy5IRUFERVJfTEVOR1RIICsgbWV0YUxlbmd0aClcbiAgICBsZXQgdmlldyA9IG5ldyBEYXRhVmlldyhoZWFkZXIpXG4gICAgbGV0IG9mZnNldCA9IDBcblxuICAgIHZpZXcuc2V0VWludDgob2Zmc2V0KyssIHRoaXMuS0lORFMucHVzaCkgLy8ga2luZFxuICAgIHZpZXcuc2V0VWludDgob2Zmc2V0KyssIGpvaW5fcmVmLmxlbmd0aClcbiAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCByZWYubGVuZ3RoKVxuICAgIHZpZXcuc2V0VWludDgob2Zmc2V0KyssIHRvcGljLmxlbmd0aClcbiAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCBldmVudC5sZW5ndGgpXG4gICAgQXJyYXkuZnJvbShqb2luX3JlZiwgY2hhciA9PiB2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCBjaGFyLmNoYXJDb2RlQXQoMCkpKVxuICAgIEFycmF5LmZyb20ocmVmLCBjaGFyID0+IHZpZXcuc2V0VWludDgob2Zmc2V0KyssIGNoYXIuY2hhckNvZGVBdCgwKSkpXG4gICAgQXJyYXkuZnJvbSh0b3BpYywgY2hhciA9PiB2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCBjaGFyLmNoYXJDb2RlQXQoMCkpKVxuICAgIEFycmF5LmZyb20oZXZlbnQsIGNoYXIgPT4gdmlldy5zZXRVaW50OChvZmZzZXQrKywgY2hhci5jaGFyQ29kZUF0KDApKSlcblxuICAgIHZhciBjb21iaW5lZCA9IG5ldyBVaW50OEFycmF5KGhlYWRlci5ieXRlTGVuZ3RoICsgcGF5bG9hZC5ieXRlTGVuZ3RoKVxuICAgIGNvbWJpbmVkLnNldChuZXcgVWludDhBcnJheShoZWFkZXIpLCAwKVxuICAgIGNvbWJpbmVkLnNldChuZXcgVWludDhBcnJheShwYXlsb2FkKSwgaGVhZGVyLmJ5dGVMZW5ndGgpXG5cbiAgICByZXR1cm4gY29tYmluZWQuYnVmZmVyXG4gIH0sXG5cbiAgYmluYXJ5RGVjb2RlKGJ1ZmZlcil7XG4gICAgbGV0IHZpZXcgPSBuZXcgRGF0YVZpZXcoYnVmZmVyKVxuICAgIGxldCBraW5kID0gdmlldy5nZXRVaW50OCgwKVxuICAgIGxldCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKClcbiAgICBzd2l0Y2goa2luZCl7XG4gICAgICBjYXNlIHRoaXMuS0lORFMucHVzaDogcmV0dXJuIHRoaXMuZGVjb2RlUHVzaChidWZmZXIsIHZpZXcsIGRlY29kZXIpXG4gICAgICBjYXNlIHRoaXMuS0lORFMucmVwbHk6IHJldHVybiB0aGlzLmRlY29kZVJlcGx5KGJ1ZmZlciwgdmlldywgZGVjb2RlcilcbiAgICAgIGNhc2UgdGhpcy5LSU5EUy5icm9hZGNhc3Q6IHJldHVybiB0aGlzLmRlY29kZUJyb2FkY2FzdChidWZmZXIsIHZpZXcsIGRlY29kZXIpXG4gICAgfVxuICB9LFxuXG4gIGRlY29kZVB1c2goYnVmZmVyLCB2aWV3LCBkZWNvZGVyKXtcbiAgICBsZXQgam9pblJlZlNpemUgPSB2aWV3LmdldFVpbnQ4KDEpXG4gICAgbGV0IHRvcGljU2l6ZSA9IHZpZXcuZ2V0VWludDgoMilcbiAgICBsZXQgZXZlbnRTaXplID0gdmlldy5nZXRVaW50OCgzKVxuICAgIGxldCBvZmZzZXQgPSB0aGlzLkhFQURFUl9MRU5HVEggKyB0aGlzLk1FVEFfTEVOR1RIIC0gMSAvLyBwdXNoZXMgaGF2ZSBubyByZWZcbiAgICBsZXQgam9pblJlZiA9IGRlY29kZXIuZGVjb2RlKGJ1ZmZlci5zbGljZShvZmZzZXQsIG9mZnNldCArIGpvaW5SZWZTaXplKSlcbiAgICBvZmZzZXQgPSBvZmZzZXQgKyBqb2luUmVmU2l6ZVxuICAgIGxldCB0b3BpYyA9IGRlY29kZXIuZGVjb2RlKGJ1ZmZlci5zbGljZShvZmZzZXQsIG9mZnNldCArIHRvcGljU2l6ZSkpXG4gICAgb2Zmc2V0ID0gb2Zmc2V0ICsgdG9waWNTaXplXG4gICAgbGV0IGV2ZW50ID0gZGVjb2Rlci5kZWNvZGUoYnVmZmVyLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgZXZlbnRTaXplKSlcbiAgICBvZmZzZXQgPSBvZmZzZXQgKyBldmVudFNpemVcbiAgICBsZXQgZGF0YSA9IGJ1ZmZlci5zbGljZShvZmZzZXQsIGJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgIHJldHVybiB7am9pbl9yZWY6IGpvaW5SZWYsIHJlZjogbnVsbCwgdG9waWM6IHRvcGljLCBldmVudDogZXZlbnQsIHBheWxvYWQ6IGRhdGF9XG4gIH0sXG5cbiAgZGVjb2RlUmVwbHkoYnVmZmVyLCB2aWV3LCBkZWNvZGVyKXtcbiAgICBsZXQgam9pblJlZlNpemUgPSB2aWV3LmdldFVpbnQ4KDEpXG4gICAgbGV0IHJlZlNpemUgPSB2aWV3LmdldFVpbnQ4KDIpXG4gICAgbGV0IHRvcGljU2l6ZSA9IHZpZXcuZ2V0VWludDgoMylcbiAgICBsZXQgZXZlbnRTaXplID0gdmlldy5nZXRVaW50OCg0KVxuICAgIGxldCBvZmZzZXQgPSB0aGlzLkhFQURFUl9MRU5HVEggKyB0aGlzLk1FVEFfTEVOR1RIXG4gICAgbGV0IGpvaW5SZWYgPSBkZWNvZGVyLmRlY29kZShidWZmZXIuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBqb2luUmVmU2l6ZSkpXG4gICAgb2Zmc2V0ID0gb2Zmc2V0ICsgam9pblJlZlNpemVcbiAgICBsZXQgcmVmID0gZGVjb2Rlci5kZWNvZGUoYnVmZmVyLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgcmVmU2l6ZSkpXG4gICAgb2Zmc2V0ID0gb2Zmc2V0ICsgcmVmU2l6ZVxuICAgIGxldCB0b3BpYyA9IGRlY29kZXIuZGVjb2RlKGJ1ZmZlci5zbGljZShvZmZzZXQsIG9mZnNldCArIHRvcGljU2l6ZSkpXG4gICAgb2Zmc2V0ID0gb2Zmc2V0ICsgdG9waWNTaXplXG4gICAgbGV0IGV2ZW50ID0gZGVjb2Rlci5kZWNvZGUoYnVmZmVyLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgZXZlbnRTaXplKSlcbiAgICBvZmZzZXQgPSBvZmZzZXQgKyBldmVudFNpemVcbiAgICBsZXQgZGF0YSA9IGJ1ZmZlci5zbGljZShvZmZzZXQsIGJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgIGxldCBwYXlsb2FkID0ge3N0YXR1czogZXZlbnQsIHJlc3BvbnNlOiBkYXRhfVxuICAgIHJldHVybiB7am9pbl9yZWY6IGpvaW5SZWYsIHJlZjogcmVmLCB0b3BpYzogdG9waWMsIGV2ZW50OiBDSEFOTkVMX0VWRU5UUy5yZXBseSwgcGF5bG9hZDogcGF5bG9hZH1cbiAgfSxcblxuICBkZWNvZGVCcm9hZGNhc3QoYnVmZmVyLCB2aWV3LCBkZWNvZGVyKXtcbiAgICBsZXQgdG9waWNTaXplID0gdmlldy5nZXRVaW50OCgxKVxuICAgIGxldCBldmVudFNpemUgPSB2aWV3LmdldFVpbnQ4KDIpXG4gICAgbGV0IG9mZnNldCA9IHRoaXMuSEVBREVSX0xFTkdUSCArIDJcbiAgICBsZXQgdG9waWMgPSBkZWNvZGVyLmRlY29kZShidWZmZXIuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyB0b3BpY1NpemUpKVxuICAgIG9mZnNldCA9IG9mZnNldCArIHRvcGljU2l6ZVxuICAgIGxldCBldmVudCA9IGRlY29kZXIuZGVjb2RlKGJ1ZmZlci5zbGljZShvZmZzZXQsIG9mZnNldCArIGV2ZW50U2l6ZSkpXG4gICAgb2Zmc2V0ID0gb2Zmc2V0ICsgZXZlbnRTaXplXG4gICAgbGV0IGRhdGEgPSBidWZmZXIuc2xpY2Uob2Zmc2V0LCBidWZmZXIuYnl0ZUxlbmd0aClcblxuICAgIHJldHVybiB7am9pbl9yZWY6IG51bGwsIHJlZjogbnVsbCwgdG9waWM6IHRvcGljLCBldmVudDogZXZlbnQsIHBheWxvYWQ6IGRhdGF9XG4gIH1cbn1cbiIsICJpbXBvcnQge1xuICBnbG9iYWwsXG4gIHBoeFdpbmRvdyxcbiAgQ0hBTk5FTF9FVkVOVFMsXG4gIERFRkFVTFRfVElNRU9VVCxcbiAgREVGQVVMVF9WU04sXG4gIFNPQ0tFVF9TVEFURVMsXG4gIFRSQU5TUE9SVFMsXG4gIFdTX0NMT1NFX05PUk1BTFxufSBmcm9tIFwiLi9jb25zdGFudHNcIlxuXG5pbXBvcnQge1xuICBjbG9zdXJlXG59IGZyb20gXCIuL3V0aWxzXCJcblxuaW1wb3J0IEFqYXggZnJvbSBcIi4vYWpheFwiXG5pbXBvcnQgQ2hhbm5lbCBmcm9tIFwiLi9jaGFubmVsXCJcbmltcG9ydCBMb25nUG9sbCBmcm9tIFwiLi9sb25ncG9sbFwiXG5pbXBvcnQgU2VyaWFsaXplciBmcm9tIFwiLi9zZXJpYWxpemVyXCJcbmltcG9ydCBUaW1lciBmcm9tIFwiLi90aW1lclwiXG5cbi8qKiBJbml0aWFsaXplcyB0aGUgU29ja2V0ICpcbiAqXG4gKiBGb3IgSUU4IHN1cHBvcnQgdXNlIGFuIEVTNS1zaGltIChodHRwczovL2dpdGh1Yi5jb20vZXMtc2hpbXMvZXM1LXNoaW0pXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGVuZFBvaW50IC0gVGhlIHN0cmluZyBXZWJTb2NrZXQgZW5kcG9pbnQsIGllLCBgXCJ3czovL2V4YW1wbGUuY29tL3NvY2tldFwiYCxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgXCJ3c3M6Ly9leGFtcGxlLmNvbVwiYFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBcIi9zb2NrZXRcImAgKGluaGVyaXRlZCBob3N0ICYgcHJvdG9jb2wpXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdHNdIC0gT3B0aW9uYWwgY29uZmlndXJhdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdHMudHJhbnNwb3J0XSAtIFRoZSBXZWJzb2NrZXQgVHJhbnNwb3J0LCBmb3IgZXhhbXBsZSBXZWJTb2NrZXQgb3IgUGhvZW5peC5Mb25nUG9sbC5cbiAqXG4gKiBEZWZhdWx0cyB0byBXZWJTb2NrZXQgd2l0aCBhdXRvbWF0aWMgTG9uZ1BvbGwgZmFsbGJhY2suXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0cy5lbmNvZGVdIC0gVGhlIGZ1bmN0aW9uIHRvIGVuY29kZSBvdXRnb2luZyBtZXNzYWdlcy5cbiAqXG4gKiBEZWZhdWx0cyB0byBKU09OIGVuY29kZXIuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdHMuZGVjb2RlXSAtIFRoZSBmdW5jdGlvbiB0byBkZWNvZGUgaW5jb21pbmcgbWVzc2FnZXMuXG4gKlxuICogRGVmYXVsdHMgdG8gSlNPTjpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiAocGF5bG9hZCwgY2FsbGJhY2spID0+IGNhbGxiYWNrKEpTT04ucGFyc2UocGF5bG9hZCkpXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdHMudGltZW91dF0gLSBUaGUgZGVmYXVsdCB0aW1lb3V0IGluIG1pbGxpc2Vjb25kcyB0byB0cmlnZ2VyIHB1c2ggdGltZW91dHMuXG4gKlxuICogRGVmYXVsdHMgYERFRkFVTFRfVElNRU9VVGBcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy5oZWFydGJlYXRJbnRlcnZhbE1zXSAtIFRoZSBtaWxsaXNlYyBpbnRlcnZhbCB0byBzZW5kIGEgaGVhcnRiZWF0IG1lc3NhZ2VcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy5yZWNvbm5lY3RBZnRlck1zXSAtIFRoZSBvcHRpb25hbCBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIG1pbGxzZWNcbiAqIHNvY2tldCByZWNvbm5lY3QgaW50ZXJ2YWwuXG4gKlxuICogRGVmYXVsdHMgdG8gc3RlcHBlZCBiYWNrb2ZmIG9mOlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIGZ1bmN0aW9uKHRyaWVzKXtcbiAqICAgcmV0dXJuIFsxMCwgNTAsIDEwMCwgMTUwLCAyMDAsIDI1MCwgNTAwLCAxMDAwLCAyMDAwXVt0cmllcyAtIDFdIHx8IDUwMDBcbiAqIH1cbiAqIGBgYGBcbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdHMucmVqb2luQWZ0ZXJNc10gLSBUaGUgb3B0aW9uYWwgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBtaWxsc2VjXG4gKiByZWpvaW4gaW50ZXJ2YWwgZm9yIGluZGl2aWR1YWwgY2hhbm5lbHMuXG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogZnVuY3Rpb24odHJpZXMpe1xuICogICByZXR1cm4gWzEwMDAsIDIwMDAsIDUwMDBdW3RyaWVzIC0gMV0gfHwgMTAwMDBcbiAqIH1cbiAqIGBgYGBcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0cy5sb2dnZXJdIC0gVGhlIG9wdGlvbmFsIGZ1bmN0aW9uIGZvciBzcGVjaWFsaXplZCBsb2dnaW5nLCBpZTpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBmdW5jdGlvbihraW5kLCBtc2csIGRhdGEpIHtcbiAqICAgY29uc29sZS5sb2coYCR7a2luZH06ICR7bXNnfWAsIGRhdGEpXG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdHMubG9uZ3BvbGxlclRpbWVvdXRdIC0gVGhlIG1heGltdW0gdGltZW91dCBvZiBhIGxvbmcgcG9sbCBBSkFYIHJlcXVlc3QuXG4gKlxuICogRGVmYXVsdHMgdG8gMjBzIChkb3VibGUgdGhlIHNlcnZlciBsb25nIHBvbGwgdGltZXIpLlxuICpcbiAqIEBwYXJhbSB7KE9iamVjdHxmdW5jdGlvbil9IFtvcHRzLnBhcmFtc10gLSBUaGUgb3B0aW9uYWwgcGFyYW1zIHRvIHBhc3Mgd2hlbiBjb25uZWN0aW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuYmluYXJ5VHlwZV0gLSBUaGUgYmluYXJ5IHR5cGUgdG8gdXNlIGZvciBiaW5hcnkgV2ViU29ja2V0IGZyYW1lcy5cbiAqXG4gKiBEZWZhdWx0cyB0byBcImFycmF5YnVmZmVyXCJcbiAqXG4gKiBAcGFyYW0ge3Zzbn0gW29wdHMudnNuXSAtIFRoZSBzZXJpYWxpemVyJ3MgcHJvdG9jb2wgdmVyc2lvbiB0byBzZW5kIG9uIGNvbm5lY3QuXG4gKlxuICogRGVmYXVsdHMgdG8gREVGQVVMVF9WU04uXG4qL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU29ja2V0IHtcbiAgY29uc3RydWN0b3IoZW5kUG9pbnQsIG9wdHMgPSB7fSl7XG4gICAgdGhpcy5zdGF0ZUNoYW5nZUNhbGxiYWNrcyA9IHtvcGVuOiBbXSwgY2xvc2U6IFtdLCBlcnJvcjogW10sIG1lc3NhZ2U6IFtdfVxuICAgIHRoaXMuY2hhbm5lbHMgPSBbXVxuICAgIHRoaXMuc2VuZEJ1ZmZlciA9IFtdXG4gICAgdGhpcy5yZWYgPSAwXG4gICAgdGhpcy50aW1lb3V0ID0gb3B0cy50aW1lb3V0IHx8IERFRkFVTFRfVElNRU9VVFxuICAgIHRoaXMudHJhbnNwb3J0ID0gb3B0cy50cmFuc3BvcnQgfHwgZ2xvYmFsLldlYlNvY2tldCB8fCBMb25nUG9sbFxuICAgIHRoaXMuZXN0YWJsaXNoZWRDb25uZWN0aW9ucyA9IDBcbiAgICB0aGlzLmRlZmF1bHRFbmNvZGVyID0gU2VyaWFsaXplci5lbmNvZGUuYmluZChTZXJpYWxpemVyKVxuICAgIHRoaXMuZGVmYXVsdERlY29kZXIgPSBTZXJpYWxpemVyLmRlY29kZS5iaW5kKFNlcmlhbGl6ZXIpXG4gICAgdGhpcy5jbG9zZVdhc0NsZWFuID0gZmFsc2VcbiAgICB0aGlzLmJpbmFyeVR5cGUgPSBvcHRzLmJpbmFyeVR5cGUgfHwgXCJhcnJheWJ1ZmZlclwiXG4gICAgdGhpcy5jb25uZWN0Q2xvY2sgPSAxXG4gICAgaWYodGhpcy50cmFuc3BvcnQgIT09IExvbmdQb2xsKXtcbiAgICAgIHRoaXMuZW5jb2RlID0gb3B0cy5lbmNvZGUgfHwgdGhpcy5kZWZhdWx0RW5jb2RlclxuICAgICAgdGhpcy5kZWNvZGUgPSBvcHRzLmRlY29kZSB8fCB0aGlzLmRlZmF1bHREZWNvZGVyXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZW5jb2RlID0gdGhpcy5kZWZhdWx0RW5jb2RlclxuICAgICAgdGhpcy5kZWNvZGUgPSB0aGlzLmRlZmF1bHREZWNvZGVyXG4gICAgfVxuICAgIGxldCBhd2FpdGluZ0Nvbm5lY3Rpb25PblBhZ2VTaG93ID0gbnVsbFxuICAgIGlmKHBoeFdpbmRvdyAmJiBwaHhXaW5kb3cuYWRkRXZlbnRMaXN0ZW5lcil7XG4gICAgICBwaHhXaW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBhZ2VoaWRlXCIsIF9lID0+IHtcbiAgICAgICAgaWYodGhpcy5jb25uKXtcbiAgICAgICAgICB0aGlzLmRpc2Nvbm5lY3QoKVxuICAgICAgICAgIGF3YWl0aW5nQ29ubmVjdGlvbk9uUGFnZVNob3cgPSB0aGlzLmNvbm5lY3RDbG9ja1xuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgcGh4V2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwYWdlc2hvd1wiLCBfZSA9PiB7XG4gICAgICAgIGlmKGF3YWl0aW5nQ29ubmVjdGlvbk9uUGFnZVNob3cgPT09IHRoaXMuY29ubmVjdENsb2NrKXtcbiAgICAgICAgICBhd2FpdGluZ0Nvbm5lY3Rpb25PblBhZ2VTaG93ID0gbnVsbFxuICAgICAgICAgIHRoaXMuY29ubmVjdCgpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICAgIHRoaXMuaGVhcnRiZWF0SW50ZXJ2YWxNcyA9IG9wdHMuaGVhcnRiZWF0SW50ZXJ2YWxNcyB8fCAzMDAwMFxuICAgIHRoaXMucmVqb2luQWZ0ZXJNcyA9ICh0cmllcykgPT4ge1xuICAgICAgaWYob3B0cy5yZWpvaW5BZnRlck1zKXtcbiAgICAgICAgcmV0dXJuIG9wdHMucmVqb2luQWZ0ZXJNcyh0cmllcylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBbMTAwMCwgMjAwMCwgNTAwMF1bdHJpZXMgLSAxXSB8fCAxMDAwMFxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnJlY29ubmVjdEFmdGVyTXMgPSAodHJpZXMpID0+IHtcbiAgICAgIGlmKG9wdHMucmVjb25uZWN0QWZ0ZXJNcyl7XG4gICAgICAgIHJldHVybiBvcHRzLnJlY29ubmVjdEFmdGVyTXModHJpZXMpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gWzEwLCA1MCwgMTAwLCAxNTAsIDIwMCwgMjUwLCA1MDAsIDEwMDAsIDIwMDBdW3RyaWVzIC0gMV0gfHwgNTAwMFxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmxvZ2dlciA9IG9wdHMubG9nZ2VyIHx8IG51bGxcbiAgICB0aGlzLmxvbmdwb2xsZXJUaW1lb3V0ID0gb3B0cy5sb25ncG9sbGVyVGltZW91dCB8fCAyMDAwMFxuICAgIHRoaXMucGFyYW1zID0gY2xvc3VyZShvcHRzLnBhcmFtcyB8fCB7fSlcbiAgICB0aGlzLmVuZFBvaW50ID0gYCR7ZW5kUG9pbnR9LyR7VFJBTlNQT1JUUy53ZWJzb2NrZXR9YFxuICAgIHRoaXMudnNuID0gb3B0cy52c24gfHwgREVGQVVMVF9WU05cbiAgICB0aGlzLmhlYXJ0YmVhdFRpbWVyID0gbnVsbFxuICAgIHRoaXMucGVuZGluZ0hlYXJ0YmVhdFJlZiA9IG51bGxcbiAgICB0aGlzLnJlY29ubmVjdFRpbWVyID0gbmV3IFRpbWVyKCgpID0+IHtcbiAgICAgIHRoaXMudGVhcmRvd24oKCkgPT4gdGhpcy5jb25uZWN0KCkpXG4gICAgfSwgdGhpcy5yZWNvbm5lY3RBZnRlck1zKVxuICB9XG5cbiAgLyoqXG4gICAqIERpc2Nvbm5lY3RzIGFuZCByZXBsYWNlcyB0aGUgYWN0aXZlIHRyYW5zcG9ydFxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBuZXdUcmFuc3BvcnQgLSBUaGUgbmV3IHRyYW5zcG9ydCBjbGFzcyB0byBpbnN0YW50aWF0ZVxuICAgKlxuICAgKi9cbiAgcmVwbGFjZVRyYW5zcG9ydChuZXdUcmFuc3BvcnQpe1xuICAgIHRoaXMuZGlzY29ubmVjdCgpXG4gICAgdGhpcy50cmFuc3BvcnQgPSBuZXdUcmFuc3BvcnRcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBzb2NrZXQgcHJvdG9jb2xcbiAgICpcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIHByb3RvY29sKCl7IHJldHVybiBsb2NhdGlvbi5wcm90b2NvbC5tYXRjaCgvXmh0dHBzLykgPyBcIndzc1wiIDogXCJ3c1wiIH1cblxuICAvKipcbiAgICogVGhlIGZ1bGx5IHF1YWxpZmVkIHNvY2tldCB1cmxcbiAgICpcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIGVuZFBvaW50VVJMKCl7XG4gICAgbGV0IHVyaSA9IEFqYXguYXBwZW5kUGFyYW1zKFxuICAgICAgQWpheC5hcHBlbmRQYXJhbXModGhpcy5lbmRQb2ludCwgdGhpcy5wYXJhbXMoKSksIHt2c246IHRoaXMudnNufSlcbiAgICBpZih1cmkuY2hhckF0KDApICE9PSBcIi9cIil7IHJldHVybiB1cmkgfVxuICAgIGlmKHVyaS5jaGFyQXQoMSkgPT09IFwiL1wiKXsgcmV0dXJuIGAke3RoaXMucHJvdG9jb2woKX06JHt1cml9YCB9XG5cbiAgICByZXR1cm4gYCR7dGhpcy5wcm90b2NvbCgpfTovLyR7bG9jYXRpb24uaG9zdH0ke3VyaX1gXG4gIH1cblxuICAvKipcbiAgICogRGlzY29ubmVjdHMgdGhlIHNvY2tldFxuICAgKlxuICAgKiBTZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0Nsb3NlRXZlbnQjU3RhdHVzX2NvZGVzIGZvciB2YWxpZCBzdGF0dXMgY29kZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gT3B0aW9uYWwgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGFmdGVyIHNvY2tldCBpcyBkaXNjb25uZWN0ZWQuXG4gICAqIEBwYXJhbSB7aW50ZWdlcn0gY29kZSAtIEEgc3RhdHVzIGNvZGUgZm9yIGRpc2Nvbm5lY3Rpb24gKE9wdGlvbmFsKS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlYXNvbiAtIEEgdGV4dHVhbCBkZXNjcmlwdGlvbiBvZiB0aGUgcmVhc29uIHRvIGRpc2Nvbm5lY3QuIChPcHRpb25hbClcbiAgICovXG4gIGRpc2Nvbm5lY3QoY2FsbGJhY2ssIGNvZGUsIHJlYXNvbil7XG4gICAgdGhpcy5jb25uZWN0Q2xvY2srK1xuICAgIHRoaXMuY2xvc2VXYXNDbGVhbiA9IHRydWVcbiAgICB0aGlzLnJlY29ubmVjdFRpbWVyLnJlc2V0KClcbiAgICB0aGlzLnRlYXJkb3duKGNhbGxiYWNrLCBjb2RlLCByZWFzb24pXG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyAtIFRoZSBwYXJhbXMgdG8gc2VuZCB3aGVuIGNvbm5lY3RpbmcsIGZvciBleGFtcGxlIGB7dXNlcl9pZDogdXNlclRva2VufWBcbiAgICpcbiAgICogUGFzc2luZyBwYXJhbXMgdG8gY29ubmVjdCBpcyBkZXByZWNhdGVkOyBwYXNzIHRoZW0gaW4gdGhlIFNvY2tldCBjb25zdHJ1Y3RvciBpbnN0ZWFkOlxuICAgKiBgbmV3IFNvY2tldChcIi9zb2NrZXRcIiwge3BhcmFtczoge3VzZXJfaWQ6IHVzZXJUb2tlbn19KWAuXG4gICAqL1xuICBjb25uZWN0KHBhcmFtcyl7XG4gICAgdGhpcy5jb25uZWN0Q2xvY2srK1xuICAgIGlmKHBhcmFtcyl7XG4gICAgICBjb25zb2xlICYmIGNvbnNvbGUubG9nKFwicGFzc2luZyBwYXJhbXMgdG8gY29ubmVjdCBpcyBkZXByZWNhdGVkLiBJbnN0ZWFkIHBhc3MgOnBhcmFtcyB0byB0aGUgU29ja2V0IGNvbnN0cnVjdG9yXCIpXG4gICAgICB0aGlzLnBhcmFtcyA9IGNsb3N1cmUocGFyYW1zKVxuICAgIH1cbiAgICBpZih0aGlzLmNvbm4peyByZXR1cm4gfVxuICAgIHRoaXMuY2xvc2VXYXNDbGVhbiA9IGZhbHNlXG4gICAgdGhpcy5jb25uID0gbmV3IHRoaXMudHJhbnNwb3J0KHRoaXMuZW5kUG9pbnRVUkwoKSlcbiAgICB0aGlzLmNvbm4uYmluYXJ5VHlwZSA9IHRoaXMuYmluYXJ5VHlwZVxuICAgIHRoaXMuY29ubi50aW1lb3V0ID0gdGhpcy5sb25ncG9sbGVyVGltZW91dFxuICAgIHRoaXMuY29ubi5vbm9wZW4gPSAoKSA9PiB0aGlzLm9uQ29ubk9wZW4oKVxuICAgIHRoaXMuY29ubi5vbmVycm9yID0gZXJyb3IgPT4gdGhpcy5vbkNvbm5FcnJvcihlcnJvcilcbiAgICB0aGlzLmNvbm4ub25tZXNzYWdlID0gZXZlbnQgPT4gdGhpcy5vbkNvbm5NZXNzYWdlKGV2ZW50KVxuICAgIHRoaXMuY29ubi5vbmNsb3NlID0gZXZlbnQgPT4gdGhpcy5vbkNvbm5DbG9zZShldmVudClcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2dzIHRoZSBtZXNzYWdlLiBPdmVycmlkZSBgdGhpcy5sb2dnZXJgIGZvciBzcGVjaWFsaXplZCBsb2dnaW5nLiBub29wcyBieSBkZWZhdWx0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBraW5kXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtc2dcbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICovXG4gIGxvZyhraW5kLCBtc2csIGRhdGEpeyB0aGlzLmxvZ2dlcihraW5kLCBtc2csIGRhdGEpIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIGEgbG9nZ2VyIGhhcyBiZWVuIHNldCBvbiB0aGlzIHNvY2tldC5cbiAgICovXG4gIGhhc0xvZ2dlcigpeyByZXR1cm4gdGhpcy5sb2dnZXIgIT09IG51bGwgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgY2FsbGJhY2tzIGZvciBjb25uZWN0aW9uIG9wZW4gZXZlbnRzXG4gICAqXG4gICAqIEBleGFtcGxlIHNvY2tldC5vbk9wZW4oZnVuY3Rpb24oKXsgY29uc29sZS5pbmZvKFwidGhlIHNvY2tldCB3YXMgb3BlbmVkXCIpIH0pXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBvbk9wZW4oY2FsbGJhY2spe1xuICAgIGxldCByZWYgPSB0aGlzLm1ha2VSZWYoKVxuICAgIHRoaXMuc3RhdGVDaGFuZ2VDYWxsYmFja3Mub3Blbi5wdXNoKFtyZWYsIGNhbGxiYWNrXSlcbiAgICByZXR1cm4gcmVmXG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXJzIGNhbGxiYWNrcyBmb3IgY29ubmVjdGlvbiBjbG9zZSBldmVudHNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIG9uQ2xvc2UoY2FsbGJhY2spe1xuICAgIGxldCByZWYgPSB0aGlzLm1ha2VSZWYoKVxuICAgIHRoaXMuc3RhdGVDaGFuZ2VDYWxsYmFja3MuY2xvc2UucHVzaChbcmVmLCBjYWxsYmFja10pXG4gICAgcmV0dXJuIHJlZlxuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBjYWxsYmFja3MgZm9yIGNvbm5lY3Rpb24gZXJyb3IgZXZlbnRzXG4gICAqXG4gICAqIEBleGFtcGxlIHNvY2tldC5vbkVycm9yKGZ1bmN0aW9uKGVycm9yKXsgYWxlcnQoXCJBbiBlcnJvciBvY2N1cnJlZFwiKSB9KVxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgb25FcnJvcihjYWxsYmFjayl7XG4gICAgbGV0IHJlZiA9IHRoaXMubWFrZVJlZigpXG4gICAgdGhpcy5zdGF0ZUNoYW5nZUNhbGxiYWNrcy5lcnJvci5wdXNoKFtyZWYsIGNhbGxiYWNrXSlcbiAgICByZXR1cm4gcmVmXG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXJzIGNhbGxiYWNrcyBmb3IgY29ubmVjdGlvbiBtZXNzYWdlIGV2ZW50c1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgb25NZXNzYWdlKGNhbGxiYWNrKXtcbiAgICBsZXQgcmVmID0gdGhpcy5tYWtlUmVmKClcbiAgICB0aGlzLnN0YXRlQ2hhbmdlQ2FsbGJhY2tzLm1lc3NhZ2UucHVzaChbcmVmLCBjYWxsYmFja10pXG4gICAgcmV0dXJuIHJlZlxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBvbkNvbm5PcGVuKCl7XG4gICAgaWYodGhpcy5oYXNMb2dnZXIoKSkgdGhpcy5sb2coXCJ0cmFuc3BvcnRcIiwgYGNvbm5lY3RlZCB0byAke3RoaXMuZW5kUG9pbnRVUkwoKX1gKVxuICAgIHRoaXMuY2xvc2VXYXNDbGVhbiA9IGZhbHNlXG4gICAgdGhpcy5lc3RhYmxpc2hlZENvbm5lY3Rpb25zKytcbiAgICB0aGlzLmZsdXNoU2VuZEJ1ZmZlcigpXG4gICAgdGhpcy5yZWNvbm5lY3RUaW1lci5yZXNldCgpXG4gICAgdGhpcy5yZXNldEhlYXJ0YmVhdCgpXG4gICAgdGhpcy5zdGF0ZUNoYW5nZUNhbGxiYWNrcy5vcGVuLmZvckVhY2goKFssIGNhbGxiYWNrXSkgPT4gY2FsbGJhY2soKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuICBoZWFydGJlYXRUaW1lb3V0KCl7XG4gICAgaWYodGhpcy5wZW5kaW5nSGVhcnRiZWF0UmVmKXtcbiAgICAgIHRoaXMucGVuZGluZ0hlYXJ0YmVhdFJlZiA9IG51bGxcbiAgICAgIGlmKHRoaXMuaGFzTG9nZ2VyKCkpeyB0aGlzLmxvZyhcInRyYW5zcG9ydFwiLCBcImhlYXJ0YmVhdCB0aW1lb3V0LiBBdHRlbXB0aW5nIHRvIHJlLWVzdGFibGlzaCBjb25uZWN0aW9uXCIpIH1cbiAgICAgIHRoaXMuYWJub3JtYWxDbG9zZShcImhlYXJ0YmVhdCB0aW1lb3V0XCIpXG4gICAgfVxuICB9XG5cbiAgcmVzZXRIZWFydGJlYXQoKXtcbiAgICBpZih0aGlzLmNvbm4gJiYgdGhpcy5jb25uLnNraXBIZWFydGJlYXQpeyByZXR1cm4gfVxuICAgIHRoaXMucGVuZGluZ0hlYXJ0YmVhdFJlZiA9IG51bGxcbiAgICBjbGVhclRpbWVvdXQodGhpcy5oZWFydGJlYXRUaW1lcilcbiAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMuc2VuZEhlYXJ0YmVhdCgpLCB0aGlzLmhlYXJ0YmVhdEludGVydmFsTXMpXG4gIH1cblxuICB0ZWFyZG93bihjYWxsYmFjaywgY29kZSwgcmVhc29uKXtcbiAgICBpZighdGhpcy5jb25uKXtcbiAgICAgIHJldHVybiBjYWxsYmFjayAmJiBjYWxsYmFjaygpXG4gICAgfVxuXG4gICAgdGhpcy53YWl0Rm9yQnVmZmVyRG9uZSgoKSA9PiB7XG4gICAgICBpZih0aGlzLmNvbm4pe1xuICAgICAgICBpZihjb2RlKXsgdGhpcy5jb25uLmNsb3NlKGNvZGUsIHJlYXNvbiB8fCBcIlwiKSB9IGVsc2UgeyB0aGlzLmNvbm4uY2xvc2UoKSB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMud2FpdEZvclNvY2tldENsb3NlZCgoKSA9PiB7XG4gICAgICAgIGlmKHRoaXMuY29ubil7XG4gICAgICAgICAgdGhpcy5jb25uLm9uY2xvc2UgPSBmdW5jdGlvbiAoKXsgfSAvLyBub29wXG4gICAgICAgICAgdGhpcy5jb25uID0gbnVsbFxuICAgICAgICB9XG5cbiAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soKVxuICAgICAgfSlcbiAgICB9KVxuICB9XG5cbiAgd2FpdEZvckJ1ZmZlckRvbmUoY2FsbGJhY2ssIHRyaWVzID0gMSl7XG4gICAgaWYodHJpZXMgPT09IDUgfHwgIXRoaXMuY29ubiB8fCAhdGhpcy5jb25uLmJ1ZmZlcmVkQW1vdW50KXtcbiAgICAgIGNhbGxiYWNrKClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy53YWl0Rm9yQnVmZmVyRG9uZShjYWxsYmFjaywgdHJpZXMgKyAxKVxuICAgIH0sIDE1MCAqIHRyaWVzKVxuICB9XG5cbiAgd2FpdEZvclNvY2tldENsb3NlZChjYWxsYmFjaywgdHJpZXMgPSAxKXtcbiAgICBpZih0cmllcyA9PT0gNSB8fCAhdGhpcy5jb25uIHx8IHRoaXMuY29ubi5yZWFkeVN0YXRlID09PSBTT0NLRVRfU1RBVEVTLmNsb3NlZCl7XG4gICAgICBjYWxsYmFjaygpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMud2FpdEZvclNvY2tldENsb3NlZChjYWxsYmFjaywgdHJpZXMgKyAxKVxuICAgIH0sIDE1MCAqIHRyaWVzKVxuICB9XG5cbiAgb25Db25uQ2xvc2UoZXZlbnQpe1xuICAgIGxldCBjbG9zZUNvZGUgPSBldmVudCAmJiBldmVudC5jb2RlXG4gICAgaWYodGhpcy5oYXNMb2dnZXIoKSkgdGhpcy5sb2coXCJ0cmFuc3BvcnRcIiwgXCJjbG9zZVwiLCBldmVudClcbiAgICB0aGlzLnRyaWdnZXJDaGFuRXJyb3IoKVxuICAgIGNsZWFyVGltZW91dCh0aGlzLmhlYXJ0YmVhdFRpbWVyKVxuICAgIGlmKCF0aGlzLmNsb3NlV2FzQ2xlYW4gJiYgY2xvc2VDb2RlICE9PSAxMDAwKXtcbiAgICAgIHRoaXMucmVjb25uZWN0VGltZXIuc2NoZWR1bGVUaW1lb3V0KClcbiAgICB9XG4gICAgdGhpcy5zdGF0ZUNoYW5nZUNhbGxiYWNrcy5jbG9zZS5mb3JFYWNoKChbLCBjYWxsYmFja10pID0+IGNhbGxiYWNrKGV2ZW50KSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgb25Db25uRXJyb3IoZXJyb3Ipe1xuICAgIGlmKHRoaXMuaGFzTG9nZ2VyKCkpIHRoaXMubG9nKFwidHJhbnNwb3J0XCIsIGVycm9yKVxuICAgIGxldCB0cmFuc3BvcnRCZWZvcmUgPSB0aGlzLnRyYW5zcG9ydFxuICAgIGxldCBlc3RhYmxpc2hlZEJlZm9yZSA9IHRoaXMuZXN0YWJsaXNoZWRDb25uZWN0aW9uc1xuICAgIHRoaXMuc3RhdGVDaGFuZ2VDYWxsYmFja3MuZXJyb3IuZm9yRWFjaCgoWywgY2FsbGJhY2tdKSA9PiB7XG4gICAgICBjYWxsYmFjayhlcnJvciwgdHJhbnNwb3J0QmVmb3JlLCBlc3RhYmxpc2hlZEJlZm9yZSlcbiAgICB9KVxuICAgIGlmKHRyYW5zcG9ydEJlZm9yZSA9PT0gdGhpcy50cmFuc3BvcnQgfHwgZXN0YWJsaXNoZWRCZWZvcmUgPiAwKXtcbiAgICAgIHRoaXMudHJpZ2dlckNoYW5FcnJvcigpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0cmlnZ2VyQ2hhbkVycm9yKCl7XG4gICAgdGhpcy5jaGFubmVscy5mb3JFYWNoKGNoYW5uZWwgPT4ge1xuICAgICAgaWYoIShjaGFubmVsLmlzRXJyb3JlZCgpIHx8IGNoYW5uZWwuaXNMZWF2aW5nKCkgfHwgY2hhbm5lbC5pc0Nsb3NlZCgpKSl7XG4gICAgICAgIGNoYW5uZWwudHJpZ2dlcihDSEFOTkVMX0VWRU5UUy5lcnJvcilcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBjb25uZWN0aW9uU3RhdGUoKXtcbiAgICBzd2l0Y2godGhpcy5jb25uICYmIHRoaXMuY29ubi5yZWFkeVN0YXRlKXtcbiAgICAgIGNhc2UgU09DS0VUX1NUQVRFUy5jb25uZWN0aW5nOiByZXR1cm4gXCJjb25uZWN0aW5nXCJcbiAgICAgIGNhc2UgU09DS0VUX1NUQVRFUy5vcGVuOiByZXR1cm4gXCJvcGVuXCJcbiAgICAgIGNhc2UgU09DS0VUX1NUQVRFUy5jbG9zaW5nOiByZXR1cm4gXCJjbG9zaW5nXCJcbiAgICAgIGRlZmF1bHQ6IHJldHVybiBcImNsb3NlZFwiXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgaXNDb25uZWN0ZWQoKXsgcmV0dXJuIHRoaXMuY29ubmVjdGlvblN0YXRlKCkgPT09IFwib3BlblwiIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICpcbiAgICogQHBhcmFtIHtDaGFubmVsfVxuICAgKi9cbiAgcmVtb3ZlKGNoYW5uZWwpe1xuICAgIHRoaXMub2ZmKGNoYW5uZWwuc3RhdGVDaGFuZ2VSZWZzKVxuICAgIHRoaXMuY2hhbm5lbHMgPSB0aGlzLmNoYW5uZWxzLmZpbHRlcihjID0+IGMuam9pblJlZigpICE9PSBjaGFubmVsLmpvaW5SZWYoKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGBvbk9wZW5gLCBgb25DbG9zZWAsIGBvbkVycm9yLGAgYW5kIGBvbk1lc3NhZ2VgIHJlZ2lzdHJhdGlvbnMuXG4gICAqXG4gICAqIEBwYXJhbSB7cmVmc30gLSBsaXN0IG9mIHJlZnMgcmV0dXJuZWQgYnkgY2FsbHMgdG9cbiAgICogICAgICAgICAgICAgICAgIGBvbk9wZW5gLCBgb25DbG9zZWAsIGBvbkVycm9yLGAgYW5kIGBvbk1lc3NhZ2VgXG4gICAqL1xuICBvZmYocmVmcyl7XG4gICAgZm9yKGxldCBrZXkgaW4gdGhpcy5zdGF0ZUNoYW5nZUNhbGxiYWNrcyl7XG4gICAgICB0aGlzLnN0YXRlQ2hhbmdlQ2FsbGJhY2tzW2tleV0gPSB0aGlzLnN0YXRlQ2hhbmdlQ2FsbGJhY2tzW2tleV0uZmlsdGVyKChbcmVmXSkgPT4ge1xuICAgICAgICByZXR1cm4gcmVmcy5pbmRleE9mKHJlZikgPT09IC0xXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWF0ZXMgYSBuZXcgY2hhbm5lbCBmb3IgdGhlIGdpdmVuIHRvcGljXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0b3BpY1xuICAgKiBAcGFyYW0ge09iamVjdH0gY2hhblBhcmFtcyAtIFBhcmFtZXRlcnMgZm9yIHRoZSBjaGFubmVsXG4gICAqIEByZXR1cm5zIHtDaGFubmVsfVxuICAgKi9cbiAgY2hhbm5lbCh0b3BpYywgY2hhblBhcmFtcyA9IHt9KXtcbiAgICBsZXQgY2hhbiA9IG5ldyBDaGFubmVsKHRvcGljLCBjaGFuUGFyYW1zLCB0aGlzKVxuICAgIHRoaXMuY2hhbm5lbHMucHVzaChjaGFuKVxuICAgIHJldHVybiBjaGFuXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICovXG4gIHB1c2goZGF0YSl7XG4gICAgaWYodGhpcy5oYXNMb2dnZXIoKSl7XG4gICAgICBsZXQge3RvcGljLCBldmVudCwgcGF5bG9hZCwgcmVmLCBqb2luX3JlZn0gPSBkYXRhXG4gICAgICB0aGlzLmxvZyhcInB1c2hcIiwgYCR7dG9waWN9ICR7ZXZlbnR9ICgke2pvaW5fcmVmfSwgJHtyZWZ9KWAsIHBheWxvYWQpXG4gICAgfVxuXG4gICAgaWYodGhpcy5pc0Nvbm5lY3RlZCgpKXtcbiAgICAgIHRoaXMuZW5jb2RlKGRhdGEsIHJlc3VsdCA9PiB0aGlzLmNvbm4uc2VuZChyZXN1bHQpKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNlbmRCdWZmZXIucHVzaCgoKSA9PiB0aGlzLmVuY29kZShkYXRhLCByZXN1bHQgPT4gdGhpcy5jb25uLnNlbmQocmVzdWx0KSkpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgbmV4dCBtZXNzYWdlIHJlZiwgYWNjb3VudGluZyBmb3Igb3ZlcmZsb3dzXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBtYWtlUmVmKCl7XG4gICAgbGV0IG5ld1JlZiA9IHRoaXMucmVmICsgMVxuICAgIGlmKG5ld1JlZiA9PT0gdGhpcy5yZWYpeyB0aGlzLnJlZiA9IDAgfSBlbHNlIHsgdGhpcy5yZWYgPSBuZXdSZWYgfVxuXG4gICAgcmV0dXJuIHRoaXMucmVmLnRvU3RyaW5nKClcbiAgfVxuXG4gIHNlbmRIZWFydGJlYXQoKXtcbiAgICBpZih0aGlzLnBlbmRpbmdIZWFydGJlYXRSZWYgJiYgIXRoaXMuaXNDb25uZWN0ZWQoKSl7IHJldHVybiB9XG4gICAgdGhpcy5wZW5kaW5nSGVhcnRiZWF0UmVmID0gdGhpcy5tYWtlUmVmKClcbiAgICB0aGlzLnB1c2goe3RvcGljOiBcInBob2VuaXhcIiwgZXZlbnQ6IFwiaGVhcnRiZWF0XCIsIHBheWxvYWQ6IHt9LCByZWY6IHRoaXMucGVuZGluZ0hlYXJ0YmVhdFJlZn0pXG4gICAgdGhpcy5oZWFydGJlYXRUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4gdGhpcy5oZWFydGJlYXRUaW1lb3V0KCksIHRoaXMuaGVhcnRiZWF0SW50ZXJ2YWxNcylcbiAgfVxuXG4gIGFibm9ybWFsQ2xvc2UocmVhc29uKXtcbiAgICB0aGlzLmNsb3NlV2FzQ2xlYW4gPSBmYWxzZVxuICAgIGlmKHRoaXMuaXNDb25uZWN0ZWQoKSl7IHRoaXMuY29ubi5jbG9zZShXU19DTE9TRV9OT1JNQUwsIHJlYXNvbikgfVxuICB9XG5cbiAgZmx1c2hTZW5kQnVmZmVyKCl7XG4gICAgaWYodGhpcy5pc0Nvbm5lY3RlZCgpICYmIHRoaXMuc2VuZEJ1ZmZlci5sZW5ndGggPiAwKXtcbiAgICAgIHRoaXMuc2VuZEJ1ZmZlci5mb3JFYWNoKGNhbGxiYWNrID0+IGNhbGxiYWNrKCkpXG4gICAgICB0aGlzLnNlbmRCdWZmZXIgPSBbXVxuICAgIH1cbiAgfVxuXG4gIG9uQ29ubk1lc3NhZ2UocmF3TWVzc2FnZSl7XG4gICAgdGhpcy5kZWNvZGUocmF3TWVzc2FnZS5kYXRhLCBtc2cgPT4ge1xuICAgICAgbGV0IHt0b3BpYywgZXZlbnQsIHBheWxvYWQsIHJlZiwgam9pbl9yZWZ9ID0gbXNnXG4gICAgICBpZihyZWYgJiYgcmVmID09PSB0aGlzLnBlbmRpbmdIZWFydGJlYXRSZWYpe1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5oZWFydGJlYXRUaW1lcilcbiAgICAgICAgdGhpcy5wZW5kaW5nSGVhcnRiZWF0UmVmID0gbnVsbFxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMuc2VuZEhlYXJ0YmVhdCgpLCB0aGlzLmhlYXJ0YmVhdEludGVydmFsTXMpXG4gICAgICB9XG5cbiAgICAgIGlmKHRoaXMuaGFzTG9nZ2VyKCkpIHRoaXMubG9nKFwicmVjZWl2ZVwiLCBgJHtwYXlsb2FkLnN0YXR1cyB8fCBcIlwifSAke3RvcGljfSAke2V2ZW50fSAke3JlZiAmJiBcIihcIiArIHJlZiArIFwiKVwiIHx8IFwiXCJ9YCwgcGF5bG9hZClcblxuICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHRoaXMuY2hhbm5lbHMubGVuZ3RoOyBpKyspe1xuICAgICAgICBjb25zdCBjaGFubmVsID0gdGhpcy5jaGFubmVsc1tpXVxuICAgICAgICBpZighY2hhbm5lbC5pc01lbWJlcih0b3BpYywgZXZlbnQsIHBheWxvYWQsIGpvaW5fcmVmKSl7IGNvbnRpbnVlIH1cbiAgICAgICAgY2hhbm5lbC50cmlnZ2VyKGV2ZW50LCBwYXlsb2FkLCByZWYsIGpvaW5fcmVmKVxuICAgICAgfVxuXG4gICAgICBmb3IobGV0IGkgPSAwOyBpIDwgdGhpcy5zdGF0ZUNoYW5nZUNhbGxiYWNrcy5tZXNzYWdlLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgbGV0IFssIGNhbGxiYWNrXSA9IHRoaXMuc3RhdGVDaGFuZ2VDYWxsYmFja3MubWVzc2FnZVtpXVxuICAgICAgICBjYWxsYmFjayhtc2cpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIGxlYXZlT3BlblRvcGljKHRvcGljKXtcbiAgICBsZXQgZHVwQ2hhbm5lbCA9IHRoaXMuY2hhbm5lbHMuZmluZChjID0+IGMudG9waWMgPT09IHRvcGljICYmIChjLmlzSm9pbmVkKCkgfHwgYy5pc0pvaW5pbmcoKSkpXG4gICAgaWYoZHVwQ2hhbm5lbCl7XG4gICAgICBpZih0aGlzLmhhc0xvZ2dlcigpKSB0aGlzLmxvZyhcInRyYW5zcG9ydFwiLCBgbGVhdmluZyBkdXBsaWNhdGUgdG9waWMgXCIke3RvcGljfVwiYClcbiAgICAgIGR1cENoYW5uZWwubGVhdmUoKVxuICAgIH1cbiAgfVxufVxuIiwgIlxuZXhwb3J0IGNvbnN0IENPTlNFQ1VUSVZFX1JFTE9BRFMgPSBcImNvbnNlY3V0aXZlLXJlbG9hZHNcIlxuZXhwb3J0IGNvbnN0IE1BWF9SRUxPQURTID0gMTBcbmV4cG9ydCBjb25zdCBSRUxPQURfSklUVEVSX01JTiA9IDEwMDBcbmV4cG9ydCBjb25zdCBSRUxPQURfSklUVEVSX01BWCA9IDMwMDBcbmV4cG9ydCBjb25zdCBGQUlMU0FGRV9KSVRURVIgPSAzMDAwMFxuZXhwb3J0IGNvbnN0IFBIWF9FVkVOVF9DTEFTU0VTID0gW1xuICBcInBoeC1jbGljay1sb2FkaW5nXCIsIFwicGh4LWNoYW5nZS1sb2FkaW5nXCIsIFwicGh4LXN1Ym1pdC1sb2FkaW5nXCIsXG4gIFwicGh4LWtleWRvd24tbG9hZGluZ1wiLCBcInBoeC1rZXl1cC1sb2FkaW5nXCIsIFwicGh4LWJsdXItbG9hZGluZ1wiLCBcInBoeC1mb2N1cy1sb2FkaW5nXCJcbl1cbmV4cG9ydCBjb25zdCBQSFhfQ09NUE9ORU5UID0gXCJkYXRhLXBoeC1jb21wb25lbnRcIlxuZXhwb3J0IGNvbnN0IFBIWF9MSVZFX0xJTksgPSBcImRhdGEtcGh4LWxpbmtcIlxuZXhwb3J0IGNvbnN0IFBIWF9UUkFDS19TVEFUSUMgPSBcInRyYWNrLXN0YXRpY1wiXG5leHBvcnQgY29uc3QgUEhYX0xJTktfU1RBVEUgPSBcImRhdGEtcGh4LWxpbmstc3RhdGVcIlxuZXhwb3J0IGNvbnN0IFBIWF9SRUYgPSBcImRhdGEtcGh4LXJlZlwiXG5leHBvcnQgY29uc3QgUEhYX1JFRl9TUkMgPSBcImRhdGEtcGh4LXJlZi1zcmNcIlxuZXhwb3J0IGNvbnN0IFBIWF9UUkFDS19VUExPQURTID0gXCJ0cmFjay11cGxvYWRzXCJcbmV4cG9ydCBjb25zdCBQSFhfVVBMT0FEX1JFRiA9IFwiZGF0YS1waHgtdXBsb2FkLXJlZlwiXG5leHBvcnQgY29uc3QgUEhYX1BSRUZMSUdIVEVEX1JFRlMgPSBcImRhdGEtcGh4LXByZWZsaWdodGVkLXJlZnNcIlxuZXhwb3J0IGNvbnN0IFBIWF9ET05FX1JFRlMgPSBcImRhdGEtcGh4LWRvbmUtcmVmc1wiXG5leHBvcnQgY29uc3QgUEhYX0RST1BfVEFSR0VUID0gXCJkcm9wLXRhcmdldFwiXG5leHBvcnQgY29uc3QgUEhYX0FDVElWRV9FTlRSWV9SRUZTID0gXCJkYXRhLXBoeC1hY3RpdmUtcmVmc1wiXG5leHBvcnQgY29uc3QgUEhYX0xJVkVfRklMRV9VUERBVEVEID0gXCJwaHg6bGl2ZS1maWxlOnVwZGF0ZWRcIlxuZXhwb3J0IGNvbnN0IFBIWF9TS0lQID0gXCJkYXRhLXBoeC1za2lwXCJcbmV4cG9ydCBjb25zdCBQSFhfUFJVTkUgPSBcImRhdGEtcGh4LXBydW5lXCJcbmV4cG9ydCBjb25zdCBQSFhfUEFHRV9MT0FESU5HID0gXCJwYWdlLWxvYWRpbmdcIlxuZXhwb3J0IGNvbnN0IFBIWF9DT05ORUNURURfQ0xBU1MgPSBcInBoeC1jb25uZWN0ZWRcIlxuZXhwb3J0IGNvbnN0IFBIWF9ESVNDT05ORUNURURfQ0xBU1MgPSBcInBoeC1sb2FkaW5nXCJcbmV4cG9ydCBjb25zdCBQSFhfTk9fRkVFREJBQ0tfQ0xBU1MgPSBcInBoeC1uby1mZWVkYmFja1wiXG5leHBvcnQgY29uc3QgUEhYX0VSUk9SX0NMQVNTID0gXCJwaHgtZXJyb3JcIlxuZXhwb3J0IGNvbnN0IFBIWF9QQVJFTlRfSUQgPSBcImRhdGEtcGh4LXBhcmVudC1pZFwiXG5leHBvcnQgY29uc3QgUEhYX01BSU4gPSBcImRhdGEtcGh4LW1haW5cIlxuZXhwb3J0IGNvbnN0IFBIWF9ST09UX0lEID0gXCJkYXRhLXBoeC1yb290LWlkXCJcbmV4cG9ydCBjb25zdCBQSFhfVFJJR0dFUl9BQ1RJT04gPSBcInRyaWdnZXItYWN0aW9uXCJcbmV4cG9ydCBjb25zdCBQSFhfRkVFREJBQ0tfRk9SID0gXCJmZWVkYmFjay1mb3JcIlxuZXhwb3J0IGNvbnN0IFBIWF9IQVNfRk9DVVNFRCA9IFwicGh4LWhhcy1mb2N1c2VkXCJcbmV4cG9ydCBjb25zdCBGT0NVU0FCTEVfSU5QVVRTID0gW1widGV4dFwiLCBcInRleHRhcmVhXCIsIFwibnVtYmVyXCIsIFwiZW1haWxcIiwgXCJwYXNzd29yZFwiLCBcInNlYXJjaFwiLCBcInRlbFwiLCBcInVybFwiLCBcImRhdGVcIiwgXCJ0aW1lXCIsIFwiZGF0ZXRpbWUtbG9jYWxcIiwgXCJjb2xvclwiLCBcInJhbmdlXCJdXG5leHBvcnQgY29uc3QgQ0hFQ0tBQkxFX0lOUFVUUyA9IFtcImNoZWNrYm94XCIsIFwicmFkaW9cIl1cbmV4cG9ydCBjb25zdCBQSFhfSEFTX1NVQk1JVFRFRCA9IFwicGh4LWhhcy1zdWJtaXR0ZWRcIlxuZXhwb3J0IGNvbnN0IFBIWF9TRVNTSU9OID0gXCJkYXRhLXBoeC1zZXNzaW9uXCJcbmV4cG9ydCBjb25zdCBQSFhfVklFV19TRUxFQ1RPUiA9IGBbJHtQSFhfU0VTU0lPTn1dYFxuZXhwb3J0IGNvbnN0IFBIWF9TVElDS1kgPSBcImRhdGEtcGh4LXN0aWNreVwiXG5leHBvcnQgY29uc3QgUEhYX1NUQVRJQyA9IFwiZGF0YS1waHgtc3RhdGljXCJcbmV4cG9ydCBjb25zdCBQSFhfUkVBRE9OTFkgPSBcImRhdGEtcGh4LXJlYWRvbmx5XCJcbmV4cG9ydCBjb25zdCBQSFhfRElTQUJMRUQgPSBcImRhdGEtcGh4LWRpc2FibGVkXCJcbmV4cG9ydCBjb25zdCBQSFhfRElTQUJMRV9XSVRIID0gXCJkaXNhYmxlLXdpdGhcIlxuZXhwb3J0IGNvbnN0IFBIWF9ESVNBQkxFX1dJVEhfUkVTVE9SRSA9IFwiZGF0YS1waHgtZGlzYWJsZS13aXRoLXJlc3RvcmVcIlxuZXhwb3J0IGNvbnN0IFBIWF9IT09LID0gXCJob29rXCJcbmV4cG9ydCBjb25zdCBQSFhfREVCT1VOQ0UgPSBcImRlYm91bmNlXCJcbmV4cG9ydCBjb25zdCBQSFhfVEhST1RUTEUgPSBcInRocm90dGxlXCJcbmV4cG9ydCBjb25zdCBQSFhfVVBEQVRFID0gXCJ1cGRhdGVcIlxuZXhwb3J0IGNvbnN0IFBIWF9LRVkgPSBcImtleVwiXG5leHBvcnQgY29uc3QgUEhYX1BSSVZBVEUgPSBcInBoeFByaXZhdGVcIlxuZXhwb3J0IGNvbnN0IFBIWF9BVVRPX1JFQ09WRVIgPSBcImF1dG8tcmVjb3ZlclwiXG5leHBvcnQgY29uc3QgUEhYX0xWX0RFQlVHID0gXCJwaHg6bGl2ZS1zb2NrZXQ6ZGVidWdcIlxuZXhwb3J0IGNvbnN0IFBIWF9MVl9QUk9GSUxFID0gXCJwaHg6bGl2ZS1zb2NrZXQ6cHJvZmlsaW5nXCJcbmV4cG9ydCBjb25zdCBQSFhfTFZfTEFURU5DWV9TSU0gPSBcInBoeDpsaXZlLXNvY2tldDpsYXRlbmN5LXNpbVwiXG5leHBvcnQgY29uc3QgUEhYX1BST0dSRVNTID0gXCJwcm9ncmVzc1wiXG5leHBvcnQgY29uc3QgTE9BREVSX1RJTUVPVVQgPSAxXG5leHBvcnQgY29uc3QgQkVGT1JFX1VOTE9BRF9MT0FERVJfVElNRU9VVCA9IDIwMFxuZXhwb3J0IGNvbnN0IEJJTkRJTkdfUFJFRklYID0gXCJwaHgtXCJcbmV4cG9ydCBjb25zdCBQVVNIX1RJTUVPVVQgPSAzMDAwMFxuZXhwb3J0IGNvbnN0IExJTktfSEVBREVSID0gXCJ4LXJlcXVlc3RlZC13aXRoXCJcbmV4cG9ydCBjb25zdCBSRVNQT05TRV9VUkxfSEVBREVSID0gXCJ4LXJlc3BvbnNlLXVybFwiXG5leHBvcnQgY29uc3QgREVCT1VOQ0VfVFJJR0dFUiA9IFwiZGVib3VuY2UtdHJpZ2dlclwiXG5leHBvcnQgY29uc3QgVEhST1RUTEVEID0gXCJ0aHJvdHRsZWRcIlxuZXhwb3J0IGNvbnN0IERFQk9VTkNFX1BSRVZfS0VZID0gXCJkZWJvdW5jZS1wcmV2LWtleVwiXG5leHBvcnQgY29uc3QgREVGQVVMVFMgPSB7XG4gIGRlYm91bmNlOiAzMDAsXG4gIHRocm90dGxlOiAzMDBcbn1cblxuLy8gUmVuZGVyZWRcbmV4cG9ydCBjb25zdCBEWU5BTUlDUyA9IFwiZFwiXG5leHBvcnQgY29uc3QgU1RBVElDID0gXCJzXCJcbmV4cG9ydCBjb25zdCBDT01QT05FTlRTID0gXCJjXCJcbmV4cG9ydCBjb25zdCBFVkVOVFMgPSBcImVcIlxuZXhwb3J0IGNvbnN0IFJFUExZID0gXCJyXCJcbmV4cG9ydCBjb25zdCBUSVRMRSA9IFwidFwiXG5leHBvcnQgY29uc3QgVEVNUExBVEVTID0gXCJwXCJcbiIsICJpbXBvcnQge1xuICBsb2dFcnJvclxufSBmcm9tIFwiLi91dGlsc1wiXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEVudHJ5VXBsb2FkZXIge1xuICBjb25zdHJ1Y3RvcihlbnRyeSwgY2h1bmtTaXplLCBsaXZlU29ja2V0KXtcbiAgICB0aGlzLmxpdmVTb2NrZXQgPSBsaXZlU29ja2V0XG4gICAgdGhpcy5lbnRyeSA9IGVudHJ5XG4gICAgdGhpcy5vZmZzZXQgPSAwXG4gICAgdGhpcy5jaHVua1NpemUgPSBjaHVua1NpemVcbiAgICB0aGlzLmNodW5rVGltZXIgPSBudWxsXG4gICAgdGhpcy51cGxvYWRDaGFubmVsID0gbGl2ZVNvY2tldC5jaGFubmVsKGBsdnU6JHtlbnRyeS5yZWZ9YCwge3Rva2VuOiBlbnRyeS5tZXRhZGF0YSgpfSlcbiAgfVxuXG4gIGVycm9yKHJlYXNvbil7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuY2h1bmtUaW1lcilcbiAgICB0aGlzLnVwbG9hZENoYW5uZWwubGVhdmUoKVxuICAgIHRoaXMuZW50cnkuZXJyb3IocmVhc29uKVxuICB9XG5cbiAgdXBsb2FkKCl7XG4gICAgdGhpcy51cGxvYWRDaGFubmVsLm9uRXJyb3IocmVhc29uID0+IHRoaXMuZXJyb3IocmVhc29uKSlcbiAgICB0aGlzLnVwbG9hZENoYW5uZWwuam9pbigpXG4gICAgICAucmVjZWl2ZShcIm9rXCIsIF9kYXRhID0+IHRoaXMucmVhZE5leHRDaHVuaygpKVxuICAgICAgLnJlY2VpdmUoXCJlcnJvclwiLCByZWFzb24gPT4gdGhpcy5lcnJvcihyZWFzb24pKVxuICB9XG5cbiAgaXNEb25lKCl7IHJldHVybiB0aGlzLm9mZnNldCA+PSB0aGlzLmVudHJ5LmZpbGUuc2l6ZSB9XG5cbiAgcmVhZE5leHRDaHVuaygpe1xuICAgIGxldCByZWFkZXIgPSBuZXcgd2luZG93LkZpbGVSZWFkZXIoKVxuICAgIGxldCBibG9iID0gdGhpcy5lbnRyeS5maWxlLnNsaWNlKHRoaXMub2Zmc2V0LCB0aGlzLmNodW5rU2l6ZSArIHRoaXMub2Zmc2V0KVxuICAgIHJlYWRlci5vbmxvYWQgPSAoZSkgPT4ge1xuICAgICAgaWYoZS50YXJnZXQuZXJyb3IgPT09IG51bGwpe1xuICAgICAgICB0aGlzLm9mZnNldCArPSBlLnRhcmdldC5yZXN1bHQuYnl0ZUxlbmd0aFxuICAgICAgICB0aGlzLnB1c2hDaHVuayhlLnRhcmdldC5yZXN1bHQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbG9nRXJyb3IoXCJSZWFkIGVycm9yOiBcIiArIGUudGFyZ2V0LmVycm9yKVxuICAgICAgfVxuICAgIH1cbiAgICByZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIoYmxvYilcbiAgfVxuXG4gIHB1c2hDaHVuayhjaHVuayl7XG4gICAgaWYoIXRoaXMudXBsb2FkQ2hhbm5lbC5pc0pvaW5lZCgpKXsgcmV0dXJuIH1cbiAgICB0aGlzLnVwbG9hZENoYW5uZWwucHVzaChcImNodW5rXCIsIGNodW5rKVxuICAgICAgLnJlY2VpdmUoXCJva1wiLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuZW50cnkucHJvZ3Jlc3MoKHRoaXMub2Zmc2V0IC8gdGhpcy5lbnRyeS5maWxlLnNpemUpICogMTAwKVxuICAgICAgICBpZighdGhpcy5pc0RvbmUoKSl7XG4gICAgICAgICAgdGhpcy5jaHVua1RpbWVyID0gc2V0VGltZW91dCgoKSA9PiB0aGlzLnJlYWROZXh0Q2h1bmsoKSwgdGhpcy5saXZlU29ja2V0LmdldExhdGVuY3lTaW0oKSB8fCAwKVxuICAgICAgICB9XG4gICAgICB9KVxuICB9XG59XG4iLCAiaW1wb3J0IHtcbiAgUEhYX1ZJRVdfU0VMRUNUT1Jcbn0gZnJvbSBcIi4vY29uc3RhbnRzXCJcblxuaW1wb3J0IEVudHJ5VXBsb2FkZXIgZnJvbSBcIi4vZW50cnlfdXBsb2FkZXJcIlxuXG5leHBvcnQgbGV0IGxvZ0Vycm9yID0gKG1zZywgb2JqKSA9PiBjb25zb2xlLmVycm9yICYmIGNvbnNvbGUuZXJyb3IobXNnLCBvYmopXG5cbmV4cG9ydCBsZXQgaXNDaWQgPSAoY2lkKSA9PiB7XG4gIGxldCB0eXBlID0gdHlwZW9mKGNpZClcbiAgcmV0dXJuIHR5cGUgPT09IFwibnVtYmVyXCIgfHwgKHR5cGUgPT09IFwic3RyaW5nXCIgJiYgL14oMHxbMS05XVxcZCopJC8udGVzdChjaWQpKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZGV0ZWN0RHVwbGljYXRlSWRzKCl7XG4gIGxldCBpZHMgPSBuZXcgU2V0KClcbiAgbGV0IGVsZW1zID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIipbaWRdXCIpXG4gIGZvcihsZXQgaSA9IDAsIGxlbiA9IGVsZW1zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKXtcbiAgICBpZihpZHMuaGFzKGVsZW1zW2ldLmlkKSl7XG4gICAgICBjb25zb2xlLmVycm9yKGBNdWx0aXBsZSBJRHMgZGV0ZWN0ZWQ6ICR7ZWxlbXNbaV0uaWR9LiBFbnN1cmUgdW5pcXVlIGVsZW1lbnQgaWRzLmApXG4gICAgfSBlbHNlIHtcbiAgICAgIGlkcy5hZGQoZWxlbXNbaV0uaWQpXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBsZXQgZGVidWcgPSAodmlldywga2luZCwgbXNnLCBvYmopID0+IHtcbiAgaWYodmlldy5saXZlU29ja2V0LmlzRGVidWdFbmFibGVkKCkpe1xuICAgIGNvbnNvbGUubG9nKGAke3ZpZXcuaWR9ICR7a2luZH06ICR7bXNnfSAtIGAsIG9iailcbiAgfVxufVxuXG4vLyB3cmFwcyB2YWx1ZSBpbiBjbG9zdXJlIG9yIHJldHVybnMgY2xvc3VyZVxuZXhwb3J0IGxldCBjbG9zdXJlID0gKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gXCJmdW5jdGlvblwiID8gdmFsIDogZnVuY3Rpb24gKCl7IHJldHVybiB2YWwgfVxuXG5leHBvcnQgbGV0IGNsb25lID0gKG9iaikgPT4geyByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShvYmopKSB9XG5cbmV4cG9ydCBsZXQgY2xvc2VzdFBoeEJpbmRpbmcgPSAoZWwsIGJpbmRpbmcsIGJvcmRlckVsKSA9PiB7XG4gIGRvIHtcbiAgICBpZihlbC5tYXRjaGVzKGBbJHtiaW5kaW5nfV1gKSl7IHJldHVybiBlbCB9XG4gICAgZWwgPSBlbC5wYXJlbnRFbGVtZW50IHx8IGVsLnBhcmVudE5vZGVcbiAgfSB3aGlsZShlbCAhPT0gbnVsbCAmJiBlbC5ub2RlVHlwZSA9PT0gMSAmJiAhKChib3JkZXJFbCAmJiBib3JkZXJFbC5pc1NhbWVOb2RlKGVsKSkgfHwgZWwubWF0Y2hlcyhQSFhfVklFV19TRUxFQ1RPUikpKVxuICByZXR1cm4gbnVsbFxufVxuXG5leHBvcnQgbGV0IGlzT2JqZWN0ID0gKG9iaikgPT4ge1xuICByZXR1cm4gb2JqICE9PSBudWxsICYmIHR5cGVvZiBvYmogPT09IFwib2JqZWN0XCIgJiYgIShvYmogaW5zdGFuY2VvZiBBcnJheSlcbn1cblxuZXhwb3J0IGxldCBpc0VxdWFsT2JqID0gKG9iajEsIG9iajIpID0+IEpTT04uc3RyaW5naWZ5KG9iajEpID09PSBKU09OLnN0cmluZ2lmeShvYmoyKVxuXG5leHBvcnQgbGV0IGlzRW1wdHkgPSAob2JqKSA9PiB7XG4gIGZvcihsZXQgeCBpbiBvYmopeyByZXR1cm4gZmFsc2UgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG5leHBvcnQgbGV0IG1heWJlID0gKGVsLCBjYWxsYmFjaykgPT4gZWwgJiYgY2FsbGJhY2soZWwpXG5cbmV4cG9ydCBsZXQgY2hhbm5lbFVwbG9hZGVyID0gZnVuY3Rpb24gKGVudHJpZXMsIG9uRXJyb3IsIHJlc3AsIGxpdmVTb2NrZXQpe1xuICBlbnRyaWVzLmZvckVhY2goZW50cnkgPT4ge1xuICAgIGxldCBlbnRyeVVwbG9hZGVyID0gbmV3IEVudHJ5VXBsb2FkZXIoZW50cnksIHJlc3AuY29uZmlnLmNodW5rX3NpemUsIGxpdmVTb2NrZXQpXG4gICAgZW50cnlVcGxvYWRlci51cGxvYWQoKVxuICB9KVxufVxuIiwgImxldCBCcm93c2VyID0ge1xuICBjYW5QdXNoU3RhdGUoKXsgcmV0dXJuICh0eXBlb2YgKGhpc3RvcnkucHVzaFN0YXRlKSAhPT0gXCJ1bmRlZmluZWRcIikgfSxcblxuICBkcm9wTG9jYWwobG9jYWxTdG9yYWdlLCBuYW1lc3BhY2UsIHN1YmtleSl7XG4gICAgcmV0dXJuIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKHRoaXMubG9jYWxLZXkobmFtZXNwYWNlLCBzdWJrZXkpKVxuICB9LFxuXG4gIHVwZGF0ZUxvY2FsKGxvY2FsU3RvcmFnZSwgbmFtZXNwYWNlLCBzdWJrZXksIGluaXRpYWwsIGZ1bmMpe1xuICAgIGxldCBjdXJyZW50ID0gdGhpcy5nZXRMb2NhbChsb2NhbFN0b3JhZ2UsIG5hbWVzcGFjZSwgc3Via2V5KVxuICAgIGxldCBrZXkgPSB0aGlzLmxvY2FsS2V5KG5hbWVzcGFjZSwgc3Via2V5KVxuICAgIGxldCBuZXdWYWwgPSBjdXJyZW50ID09PSBudWxsID8gaW5pdGlhbCA6IGZ1bmMoY3VycmVudClcbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShrZXksIEpTT04uc3RyaW5naWZ5KG5ld1ZhbCkpXG4gICAgcmV0dXJuIG5ld1ZhbFxuICB9LFxuXG4gIGdldExvY2FsKGxvY2FsU3RvcmFnZSwgbmFtZXNwYWNlLCBzdWJrZXkpe1xuICAgIHJldHVybiBKU09OLnBhcnNlKGxvY2FsU3RvcmFnZS5nZXRJdGVtKHRoaXMubG9jYWxLZXkobmFtZXNwYWNlLCBzdWJrZXkpKSlcbiAgfSxcblxuICB1cGRhdGVDdXJyZW50U3RhdGUoY2FsbGJhY2spe1xuICAgIGlmKCF0aGlzLmNhblB1c2hTdGF0ZSgpKXsgcmV0dXJuIH1cbiAgICBoaXN0b3J5LnJlcGxhY2VTdGF0ZShjYWxsYmFjayhoaXN0b3J5LnN0YXRlIHx8IHt9KSwgXCJcIiwgd2luZG93LmxvY2F0aW9uLmhyZWYpXG4gIH0sXG5cbiAgcHVzaFN0YXRlKGtpbmQsIG1ldGEsIHRvKXtcbiAgICBpZih0aGlzLmNhblB1c2hTdGF0ZSgpKXtcbiAgICAgIGlmKHRvICE9PSB3aW5kb3cubG9jYXRpb24uaHJlZil7XG4gICAgICAgIGlmKG1ldGEudHlwZSA9PSBcInJlZGlyZWN0XCIgJiYgbWV0YS5zY3JvbGwpe1xuICAgICAgICAgIC8vIElmIHdlJ3JlIHJlZGlyZWN0aW5nIHN0b3JlIHRoZSBjdXJyZW50IHNjcm9sbFkgZm9yIHRoZSBjdXJyZW50IGhpc3Rvcnkgc3RhdGUuXG4gICAgICAgICAgbGV0IGN1cnJlbnRTdGF0ZSA9IGhpc3Rvcnkuc3RhdGUgfHwge31cbiAgICAgICAgICBjdXJyZW50U3RhdGUuc2Nyb2xsID0gbWV0YS5zY3JvbGxcbiAgICAgICAgICBoaXN0b3J5LnJlcGxhY2VTdGF0ZShjdXJyZW50U3RhdGUsIFwiXCIsIHdpbmRvdy5sb2NhdGlvbi5ocmVmKVxuICAgICAgICB9XG5cbiAgICAgICAgZGVsZXRlIG1ldGEuc2Nyb2xsIC8vIE9ubHkgc3RvcmUgdGhlIHNjcm9sbCBpbiB0aGUgcmVkaXJlY3QgY2FzZS5cbiAgICAgICAgaGlzdG9yeVtraW5kICsgXCJTdGF0ZVwiXShtZXRhLCBcIlwiLCB0byB8fCBudWxsKSAvLyBJRSB3aWxsIGNvZXJjZSB1bmRlZmluZWQgdG8gc3RyaW5nXG4gICAgICAgIGxldCBoYXNoRWwgPSB0aGlzLmdldEhhc2hUYXJnZXRFbCh3aW5kb3cubG9jYXRpb24uaGFzaClcblxuICAgICAgICBpZihoYXNoRWwpe1xuICAgICAgICAgIGhhc2hFbC5zY3JvbGxJbnRvVmlldygpXG4gICAgICAgIH0gZWxzZSBpZihtZXRhLnR5cGUgPT09IFwicmVkaXJlY3RcIil7XG4gICAgICAgICAgd2luZG93LnNjcm9sbCgwLCAwKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVkaXJlY3QodG8pXG4gICAgfVxuICB9LFxuXG4gIHNldENvb2tpZShuYW1lLCB2YWx1ZSl7XG4gICAgZG9jdW1lbnQuY29va2llID0gYCR7bmFtZX09JHt2YWx1ZX1gXG4gIH0sXG5cbiAgZ2V0Q29va2llKG5hbWUpe1xuICAgIHJldHVybiBkb2N1bWVudC5jb29raWUucmVwbGFjZShuZXcgUmVnRXhwKGAoPzooPzpefC4qO1xccyopJHtuYW1lfVxccypcXD1cXHMqKFteO10qKS4qJCl8Xi4qJGApLCBcIiQxXCIpXG4gIH0sXG5cbiAgcmVkaXJlY3QodG9VUkwsIGZsYXNoKXtcbiAgICBpZihmbGFzaCl7IEJyb3dzZXIuc2V0Q29va2llKFwiX19waG9lbml4X2ZsYXNoX19cIiwgZmxhc2ggKyBcIjsgbWF4LWFnZT02MDAwMDsgcGF0aD0vXCIpIH1cbiAgICB3aW5kb3cubG9jYXRpb24gPSB0b1VSTFxuICB9LFxuXG4gIGxvY2FsS2V5KG5hbWVzcGFjZSwgc3Via2V5KXsgcmV0dXJuIGAke25hbWVzcGFjZX0tJHtzdWJrZXl9YCB9LFxuXG4gIGdldEhhc2hUYXJnZXRFbChtYXliZUhhc2gpe1xuICAgIGxldCBoYXNoID0gbWF5YmVIYXNoLnRvU3RyaW5nKCkuc3Vic3RyaW5nKDEpXG4gICAgaWYoaGFzaCA9PT0gXCJcIil7IHJldHVybiB9XG4gICAgcmV0dXJuIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGhhc2gpIHx8IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYGFbbmFtZT1cIiR7aGFzaH1cIl1gKVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEJyb3dzZXJcbiIsICJpbXBvcnQge1xuICBDSEVDS0FCTEVfSU5QVVRTLFxuICBERUJPVU5DRV9QUkVWX0tFWSxcbiAgREVCT1VOQ0VfVFJJR0dFUixcbiAgRk9DVVNBQkxFX0lOUFVUUyxcbiAgUEhYX0NPTVBPTkVOVCxcbiAgUEhYX0VWRU5UX0NMQVNTRVMsXG4gIFBIWF9IQVNfRk9DVVNFRCxcbiAgUEhYX0hBU19TVUJNSVRURUQsXG4gIFBIWF9NQUlOLFxuICBQSFhfTk9fRkVFREJBQ0tfQ0xBU1MsXG4gIFBIWF9QQVJFTlRfSUQsXG4gIFBIWF9QUklWQVRFLFxuICBQSFhfUkVGLFxuICBQSFhfUkVGX1NSQyxcbiAgUEhYX1JPT1RfSUQsXG4gIFBIWF9TRVNTSU9OLFxuICBQSFhfU1RBVElDLFxuICBQSFhfVVBMT0FEX1JFRixcbiAgUEhYX1ZJRVdfU0VMRUNUT1IsXG4gIFBIWF9TVElDS1ksXG4gIFRIUk9UVExFRFxufSBmcm9tIFwiLi9jb25zdGFudHNcIlxuXG5pbXBvcnQge1xuICBsb2dFcnJvclxufSBmcm9tIFwiLi91dGlsc1wiXG5cbmxldCBET00gPSB7XG4gIGJ5SWQoaWQpeyByZXR1cm4gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpIHx8IGxvZ0Vycm9yKGBubyBpZCBmb3VuZCBmb3IgJHtpZH1gKSB9LFxuXG4gIHJlbW92ZUNsYXNzKGVsLCBjbGFzc05hbWUpe1xuICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOYW1lKVxuICAgIGlmKGVsLmNsYXNzTGlzdC5sZW5ndGggPT09IDApeyBlbC5yZW1vdmVBdHRyaWJ1dGUoXCJjbGFzc1wiKSB9XG4gIH0sXG5cbiAgYWxsKG5vZGUsIHF1ZXJ5LCBjYWxsYmFjayl7XG4gICAgaWYoIW5vZGUpeyByZXR1cm4gW10gfVxuICAgIGxldCBhcnJheSA9IEFycmF5LmZyb20obm9kZS5xdWVyeVNlbGVjdG9yQWxsKHF1ZXJ5KSlcbiAgICByZXR1cm4gY2FsbGJhY2sgPyBhcnJheS5mb3JFYWNoKGNhbGxiYWNrKSA6IGFycmF5XG4gIH0sXG5cbiAgY2hpbGROb2RlTGVuZ3RoKGh0bWwpe1xuICAgIGxldCB0ZW1wbGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0ZW1wbGF0ZVwiKVxuICAgIHRlbXBsYXRlLmlubmVySFRNTCA9IGh0bWxcbiAgICByZXR1cm4gdGVtcGxhdGUuY29udGVudC5jaGlsZEVsZW1lbnRDb3VudFxuICB9LFxuXG4gIGlzVXBsb2FkSW5wdXQoZWwpeyByZXR1cm4gZWwudHlwZSA9PT0gXCJmaWxlXCIgJiYgZWwuZ2V0QXR0cmlidXRlKFBIWF9VUExPQURfUkVGKSAhPT0gbnVsbCB9LFxuXG4gIGZpbmRVcGxvYWRJbnB1dHMobm9kZSl7IHJldHVybiB0aGlzLmFsbChub2RlLCBgaW5wdXRbdHlwZT1cImZpbGVcIl1bJHtQSFhfVVBMT0FEX1JFRn1dYCkgfSxcblxuICBmaW5kQ29tcG9uZW50Tm9kZUxpc3Qobm9kZSwgY2lkKXtcbiAgICByZXR1cm4gdGhpcy5maWx0ZXJXaXRoaW5TYW1lTGl2ZVZpZXcodGhpcy5hbGwobm9kZSwgYFske1BIWF9DT01QT05FTlR9PVwiJHtjaWR9XCJdYCksIG5vZGUpXG4gIH0sXG5cbiAgaXNQaHhEZXN0cm95ZWQobm9kZSl7XG4gICAgcmV0dXJuIG5vZGUuaWQgJiYgRE9NLnByaXZhdGUobm9kZSwgXCJkZXN0cm95ZWRcIikgPyB0cnVlIDogZmFsc2VcbiAgfSxcblxuICBtYXJrUGh4Q2hpbGREZXN0cm95ZWQoZWwpe1xuICAgIGlmKHRoaXMuaXNQaHhDaGlsZChlbCkpeyBlbC5zZXRBdHRyaWJ1dGUoUEhYX1NFU1NJT04sIFwiXCIpIH1cbiAgICB0aGlzLnB1dFByaXZhdGUoZWwsIFwiZGVzdHJveWVkXCIsIHRydWUpXG4gIH0sXG5cbiAgZmluZFBoeENoaWxkcmVuSW5GcmFnbWVudChodG1sLCBwYXJlbnRJZCl7XG4gICAgbGV0IHRlbXBsYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRlbXBsYXRlXCIpXG4gICAgdGVtcGxhdGUuaW5uZXJIVE1MID0gaHRtbFxuICAgIHJldHVybiB0aGlzLmZpbmRQaHhDaGlsZHJlbih0ZW1wbGF0ZS5jb250ZW50LCBwYXJlbnRJZClcbiAgfSxcblxuICBpc0lnbm9yZWQoZWwsIHBoeFVwZGF0ZSl7XG4gICAgcmV0dXJuIChlbC5nZXRBdHRyaWJ1dGUocGh4VXBkYXRlKSB8fCBlbC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXBoeC11cGRhdGVcIikpID09PSBcImlnbm9yZVwiXG4gIH0sXG5cbiAgaXNQaHhVcGRhdGUoZWwsIHBoeFVwZGF0ZSwgdXBkYXRlVHlwZXMpe1xuICAgIHJldHVybiBlbC5nZXRBdHRyaWJ1dGUgJiYgdXBkYXRlVHlwZXMuaW5kZXhPZihlbC5nZXRBdHRyaWJ1dGUocGh4VXBkYXRlKSkgPj0gMFxuICB9LFxuXG4gIGZpbmRQaHhTdGlja3koZWwpeyByZXR1cm4gdGhpcy5hbGwoZWwsIGBbJHtQSFhfU1RJQ0tZfV1gKSB9LFxuXG4gIGZpbmRQaHhDaGlsZHJlbihlbCwgcGFyZW50SWQpe1xuICAgIHJldHVybiB0aGlzLmFsbChlbCwgYCR7UEhYX1ZJRVdfU0VMRUNUT1J9WyR7UEhYX1BBUkVOVF9JRH09XCIke3BhcmVudElkfVwiXWApXG4gIH0sXG5cbiAgZmluZFBhcmVudENJRHMobm9kZSwgY2lkcyl7XG4gICAgbGV0IGluaXRpYWwgPSBuZXcgU2V0KGNpZHMpXG4gICAgcmV0dXJuIGNpZHMucmVkdWNlKChhY2MsIGNpZCkgPT4ge1xuICAgICAgbGV0IHNlbGVjdG9yID0gYFske1BIWF9DT01QT05FTlR9PVwiJHtjaWR9XCJdIFske1BIWF9DT01QT05FTlR9XWBcblxuICAgICAgdGhpcy5maWx0ZXJXaXRoaW5TYW1lTGl2ZVZpZXcodGhpcy5hbGwobm9kZSwgc2VsZWN0b3IpLCBub2RlKVxuICAgICAgICAubWFwKGVsID0+IHBhcnNlSW50KGVsLmdldEF0dHJpYnV0ZShQSFhfQ09NUE9ORU5UKSkpXG4gICAgICAgIC5mb3JFYWNoKGNoaWxkQ0lEID0+IGFjYy5kZWxldGUoY2hpbGRDSUQpKVxuXG4gICAgICByZXR1cm4gYWNjXG4gICAgfSwgaW5pdGlhbClcbiAgfSxcblxuICBmaWx0ZXJXaXRoaW5TYW1lTGl2ZVZpZXcobm9kZXMsIHBhcmVudCl7XG4gICAgaWYocGFyZW50LnF1ZXJ5U2VsZWN0b3IoUEhYX1ZJRVdfU0VMRUNUT1IpKXtcbiAgICAgIHJldHVybiBub2Rlcy5maWx0ZXIoZWwgPT4gdGhpcy53aXRoaW5TYW1lTGl2ZVZpZXcoZWwsIHBhcmVudCkpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBub2Rlc1xuICAgIH1cbiAgfSxcblxuICB3aXRoaW5TYW1lTGl2ZVZpZXcobm9kZSwgcGFyZW50KXtcbiAgICB3aGlsZShub2RlID0gbm9kZS5wYXJlbnROb2RlKXtcbiAgICAgIGlmKG5vZGUuaXNTYW1lTm9kZShwYXJlbnQpKXsgcmV0dXJuIHRydWUgfVxuICAgICAgaWYobm9kZS5nZXRBdHRyaWJ1dGUoUEhYX1NFU1NJT04pICE9PSBudWxsKXsgcmV0dXJuIGZhbHNlIH1cbiAgICB9XG4gIH0sXG5cbiAgcHJpdmF0ZShlbCwga2V5KXsgcmV0dXJuIGVsW1BIWF9QUklWQVRFXSAmJiBlbFtQSFhfUFJJVkFURV1ba2V5XSB9LFxuXG4gIGRlbGV0ZVByaXZhdGUoZWwsIGtleSl7IGVsW1BIWF9QUklWQVRFXSAmJiBkZWxldGUgKGVsW1BIWF9QUklWQVRFXVtrZXldKSB9LFxuXG4gIHB1dFByaXZhdGUoZWwsIGtleSwgdmFsdWUpe1xuICAgIGlmKCFlbFtQSFhfUFJJVkFURV0peyBlbFtQSFhfUFJJVkFURV0gPSB7fSB9XG4gICAgZWxbUEhYX1BSSVZBVEVdW2tleV0gPSB2YWx1ZVxuICB9LFxuXG4gIHVwZGF0ZVByaXZhdGUoZWwsIGtleSwgZGVmYXVsdFZhbCwgdXBkYXRlRnVuYyl7XG4gICAgbGV0IGV4aXN0aW5nID0gdGhpcy5wcml2YXRlKGVsLCBrZXkpXG4gICAgaWYoZXhpc3RpbmcgPT09IHVuZGVmaW5lZCl7XG4gICAgICB0aGlzLnB1dFByaXZhdGUoZWwsIGtleSwgdXBkYXRlRnVuYyhkZWZhdWx0VmFsKSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wdXRQcml2YXRlKGVsLCBrZXksIHVwZGF0ZUZ1bmMoZXhpc3RpbmcpKVxuICAgIH1cbiAgfSxcblxuICBjb3B5UHJpdmF0ZXModGFyZ2V0LCBzb3VyY2Upe1xuICAgIGlmKHNvdXJjZVtQSFhfUFJJVkFURV0pe1xuICAgICAgdGFyZ2V0W1BIWF9QUklWQVRFXSA9IHNvdXJjZVtQSFhfUFJJVkFURV1cbiAgICB9XG4gIH0sXG5cbiAgcHV0VGl0bGUoc3RyKXtcbiAgICBsZXQgdGl0bGVFbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCJ0aXRsZVwiKVxuICAgIGxldCB7cHJlZml4LCBzdWZmaXh9ID0gdGl0bGVFbC5kYXRhc2V0XG4gICAgZG9jdW1lbnQudGl0bGUgPSBgJHtwcmVmaXggfHwgXCJcIn0ke3N0cn0ke3N1ZmZpeCB8fCBcIlwifWBcbiAgfSxcblxuICBkZWJvdW5jZShlbCwgZXZlbnQsIHBoeERlYm91bmNlLCBkZWZhdWx0RGVib3VuY2UsIHBoeFRocm90dGxlLCBkZWZhdWx0VGhyb3R0bGUsIGNhbGxiYWNrKXtcbiAgICBsZXQgZGVib3VuY2UgPSBlbC5nZXRBdHRyaWJ1dGUocGh4RGVib3VuY2UpXG4gICAgbGV0IHRocm90dGxlID0gZWwuZ2V0QXR0cmlidXRlKHBoeFRocm90dGxlKVxuICAgIGlmKGRlYm91bmNlID09PSBcIlwiKXsgZGVib3VuY2UgPSBkZWZhdWx0RGVib3VuY2UgfVxuICAgIGlmKHRocm90dGxlID09PSBcIlwiKXsgdGhyb3R0bGUgPSBkZWZhdWx0VGhyb3R0bGUgfVxuICAgIGxldCB2YWx1ZSA9IGRlYm91bmNlIHx8IHRocm90dGxlXG4gICAgc3dpdGNoKHZhbHVlKXtcbiAgICAgIGNhc2UgbnVsbDogcmV0dXJuIGNhbGxiYWNrKClcblxuICAgICAgY2FzZSBcImJsdXJcIjpcbiAgICAgICAgaWYodGhpcy5vbmNlKGVsLCBcImRlYm91bmNlLWJsdXJcIikpe1xuICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsICgpID0+IGNhbGxiYWNrKCkpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGxldCB0aW1lb3V0ID0gcGFyc2VJbnQodmFsdWUpXG4gICAgICAgIGxldCB0cmlnZ2VyID0gKCkgPT4gdGhyb3R0bGUgPyB0aGlzLmRlbGV0ZVByaXZhdGUoZWwsIFRIUk9UVExFRCkgOiBjYWxsYmFjaygpXG4gICAgICAgIGxldCBjdXJyZW50Q3ljbGUgPSB0aGlzLmluY0N5Y2xlKGVsLCBERUJPVU5DRV9UUklHR0VSLCB0cmlnZ2VyKVxuICAgICAgICBpZihpc05hTih0aW1lb3V0KSl7IHJldHVybiBsb2dFcnJvcihgaW52YWxpZCB0aHJvdHRsZS9kZWJvdW5jZSB2YWx1ZTogJHt2YWx1ZX1gKSB9XG4gICAgICAgIGlmKHRocm90dGxlKXtcbiAgICAgICAgICBsZXQgbmV3S2V5RG93biA9IGZhbHNlXG4gICAgICAgICAgaWYoZXZlbnQudHlwZSA9PT0gXCJrZXlkb3duXCIpe1xuICAgICAgICAgICAgbGV0IHByZXZLZXkgPSB0aGlzLnByaXZhdGUoZWwsIERFQk9VTkNFX1BSRVZfS0VZKVxuICAgICAgICAgICAgdGhpcy5wdXRQcml2YXRlKGVsLCBERUJPVU5DRV9QUkVWX0tFWSwgZXZlbnQua2V5KVxuICAgICAgICAgICAgbmV3S2V5RG93biA9IHByZXZLZXkgIT09IGV2ZW50LmtleVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmKCFuZXdLZXlEb3duICYmIHRoaXMucHJpdmF0ZShlbCwgVEhST1RUTEVEKSl7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FsbGJhY2soKVxuICAgICAgICAgICAgdGhpcy5wdXRQcml2YXRlKGVsLCBUSFJPVFRMRUQsIHRydWUpXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMudHJpZ2dlckN5Y2xlKGVsLCBERUJPVU5DRV9UUklHR0VSKSwgdGltZW91dClcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLnRyaWdnZXJDeWNsZShlbCwgREVCT1VOQ0VfVFJJR0dFUiwgY3VycmVudEN5Y2xlKSwgdGltZW91dClcbiAgICAgICAgfVxuXG5cbiAgICAgICAgbGV0IGZvcm0gPSBlbC5mb3JtXG4gICAgICAgIGlmKGZvcm0gJiYgdGhpcy5vbmNlKGZvcm0sIFwiYmluZC1kZWJvdW5jZVwiKSl7XG4gICAgICAgICAgZm9ybS5hZGRFdmVudExpc3RlbmVyKFwic3VibWl0XCIsICgpID0+IHtcbiAgICAgICAgICAgIEFycmF5LmZyb20oKG5ldyBGb3JtRGF0YShmb3JtKSkuZW50cmllcygpLCAoW25hbWVdKSA9PiB7XG4gICAgICAgICAgICAgIGxldCBpbnB1dCA9IGZvcm0ucXVlcnlTZWxlY3RvcihgW25hbWU9XCIke25hbWV9XCJdYClcbiAgICAgICAgICAgICAgdGhpcy5pbmNDeWNsZShpbnB1dCwgREVCT1VOQ0VfVFJJR0dFUilcbiAgICAgICAgICAgICAgdGhpcy5kZWxldGVQcml2YXRlKGlucHV0LCBUSFJPVFRMRUQpXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgICAgaWYodGhpcy5vbmNlKGVsLCBcImJpbmQtZGVib3VuY2VcIikpe1xuICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsICgpID0+IHRoaXMudHJpZ2dlckN5Y2xlKGVsLCBERUJPVU5DRV9UUklHR0VSKSlcbiAgICAgICAgfVxuICAgIH1cbiAgfSxcblxuICB0cmlnZ2VyQ3ljbGUoZWwsIGtleSwgY3VycmVudEN5Y2xlKXtcbiAgICBsZXQgW2N5Y2xlLCB0cmlnZ2VyXSA9IHRoaXMucHJpdmF0ZShlbCwga2V5KVxuICAgIGlmKCFjdXJyZW50Q3ljbGUpeyBjdXJyZW50Q3ljbGUgPSBjeWNsZSB9XG4gICAgaWYoY3VycmVudEN5Y2xlID09PSBjeWNsZSl7XG4gICAgICB0aGlzLmluY0N5Y2xlKGVsLCBrZXkpXG4gICAgICB0cmlnZ2VyKClcbiAgICB9XG4gIH0sXG5cbiAgb25jZShlbCwga2V5KXtcbiAgICBpZih0aGlzLnByaXZhdGUoZWwsIGtleSkgPT09IHRydWUpeyByZXR1cm4gZmFsc2UgfVxuICAgIHRoaXMucHV0UHJpdmF0ZShlbCwga2V5LCB0cnVlKVxuICAgIHJldHVybiB0cnVlXG4gIH0sXG5cbiAgaW5jQ3ljbGUoZWwsIGtleSwgdHJpZ2dlciA9IGZ1bmN0aW9uICgpeyB9KXtcbiAgICBsZXQgW2N1cnJlbnRDeWNsZV0gPSB0aGlzLnByaXZhdGUoZWwsIGtleSkgfHwgWzAsIHRyaWdnZXJdXG4gICAgY3VycmVudEN5Y2xlKytcbiAgICB0aGlzLnB1dFByaXZhdGUoZWwsIGtleSwgW2N1cnJlbnRDeWNsZSwgdHJpZ2dlcl0pXG4gICAgcmV0dXJuIGN1cnJlbnRDeWNsZVxuICB9LFxuXG4gIGRpc2NhcmRFcnJvcihjb250YWluZXIsIGVsLCBwaHhGZWVkYmFja0Zvcil7XG4gICAgbGV0IGZpZWxkID0gZWwuZ2V0QXR0cmlidXRlICYmIGVsLmdldEF0dHJpYnV0ZShwaHhGZWVkYmFja0ZvcilcbiAgICAvLyBUT0RPOiBSZW1vdmUgaWQgbG9va3VwIGFmdGVyIHdlIHVwZGF0ZSBQaG9lbml4IHRvIHVzZSBpbnB1dF9uYW1lIGluc3RlYWQgb2YgaW5wdXRfaWRcbiAgICBsZXQgaW5wdXQgPSBmaWVsZCAmJiBjb250YWluZXIucXVlcnlTZWxlY3RvcihgW2lkPVwiJHtmaWVsZH1cIl0sIFtuYW1lPVwiJHtmaWVsZH1cIl1gKVxuICAgIGlmKCFpbnB1dCl7IHJldHVybiB9XG5cbiAgICBpZighKHRoaXMucHJpdmF0ZShpbnB1dCwgUEhYX0hBU19GT0NVU0VEKSB8fCB0aGlzLnByaXZhdGUoaW5wdXQuZm9ybSwgUEhYX0hBU19TVUJNSVRURUQpKSl7XG4gICAgICBlbC5jbGFzc0xpc3QuYWRkKFBIWF9OT19GRUVEQkFDS19DTEFTUylcbiAgICB9XG4gIH0sXG5cbiAgc2hvd0Vycm9yKGlucHV0RWwsIHBoeEZlZWRiYWNrRm9yKXtcbiAgICBpZihpbnB1dEVsLmlkIHx8IGlucHV0RWwubmFtZSl7XG4gICAgICB0aGlzLmFsbChpbnB1dEVsLmZvcm0sIGBbJHtwaHhGZWVkYmFja0Zvcn09XCIke2lucHV0RWwuaWR9XCJdLCBbJHtwaHhGZWVkYmFja0Zvcn09XCIke2lucHV0RWwubmFtZX1cIl1gLCAoZWwpID0+IHtcbiAgICAgICAgdGhpcy5yZW1vdmVDbGFzcyhlbCwgUEhYX05PX0ZFRURCQUNLX0NMQVNTKVxuICAgICAgfSlcbiAgICB9XG4gIH0sXG5cbiAgaXNQaHhDaGlsZChub2RlKXtcbiAgICByZXR1cm4gbm9kZS5nZXRBdHRyaWJ1dGUgJiYgbm9kZS5nZXRBdHRyaWJ1dGUoUEhYX1BBUkVOVF9JRClcbiAgfSxcblxuICBpc1BoeFN0aWNreShub2RlKXtcbiAgICByZXR1cm4gbm9kZS5nZXRBdHRyaWJ1dGUgJiYgbm9kZS5nZXRBdHRyaWJ1dGUoUEhYX1NUSUNLWSkgIT09IG51bGxcbiAgfSxcblxuICBmaXJzdFBoeENoaWxkKGVsKXtcbiAgICByZXR1cm4gdGhpcy5pc1BoeENoaWxkKGVsKSA/IGVsIDogdGhpcy5hbGwoZWwsIGBbJHtQSFhfUEFSRU5UX0lEfV1gKVswXVxuICB9LFxuXG4gIGRpc3BhdGNoRXZlbnQodGFyZ2V0LCBuYW1lLCBvcHRzID0ge30pe1xuICAgIGxldCBidWJibGVzID0gb3B0cy5idWJibGVzID09PSB1bmRlZmluZWQgPyB0cnVlIDogISFvcHRzLmJ1YmJsZXNcbiAgICBsZXQgZXZlbnRPcHRzID0ge2J1YmJsZXM6IGJ1YmJsZXMsIGNhbmNlbGFibGU6IHRydWUsIGRldGFpbDogb3B0cy5kZXRhaWwgfHwge319XG4gICAgbGV0IGV2ZW50ID0gbmFtZSA9PT0gXCJjbGlja1wiID8gbmV3IE1vdXNlRXZlbnQoXCJjbGlja1wiLCBldmVudE9wdHMpIDogbmV3IEN1c3RvbUV2ZW50KG5hbWUsIGV2ZW50T3B0cylcbiAgICB0YXJnZXQuZGlzcGF0Y2hFdmVudChldmVudClcbiAgfSxcblxuICBjbG9uZU5vZGUobm9kZSwgaHRtbCl7XG4gICAgaWYodHlwZW9mIChodG1sKSA9PT0gXCJ1bmRlZmluZWRcIil7XG4gICAgICByZXR1cm4gbm9kZS5jbG9uZU5vZGUodHJ1ZSlcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGNsb25lZCA9IG5vZGUuY2xvbmVOb2RlKGZhbHNlKVxuICAgICAgY2xvbmVkLmlubmVySFRNTCA9IGh0bWxcbiAgICAgIHJldHVybiBjbG9uZWRcbiAgICB9XG4gIH0sXG5cbiAgbWVyZ2VBdHRycyh0YXJnZXQsIHNvdXJjZSwgb3B0cyA9IHt9KXtcbiAgICBsZXQgZXhjbHVkZSA9IG9wdHMuZXhjbHVkZSB8fCBbXVxuICAgIGxldCBpc0lnbm9yZWQgPSBvcHRzLmlzSWdub3JlZFxuICAgIGxldCBzb3VyY2VBdHRycyA9IHNvdXJjZS5hdHRyaWJ1dGVzXG4gICAgZm9yKGxldCBpID0gc291cmNlQXR0cnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pe1xuICAgICAgbGV0IG5hbWUgPSBzb3VyY2VBdHRyc1tpXS5uYW1lXG4gICAgICBpZihleGNsdWRlLmluZGV4T2YobmFtZSkgPCAwKXsgdGFyZ2V0LnNldEF0dHJpYnV0ZShuYW1lLCBzb3VyY2UuZ2V0QXR0cmlidXRlKG5hbWUpKSB9XG4gICAgfVxuXG4gICAgbGV0IHRhcmdldEF0dHJzID0gdGFyZ2V0LmF0dHJpYnV0ZXNcbiAgICBmb3IobGV0IGkgPSB0YXJnZXRBdHRycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSl7XG4gICAgICBsZXQgbmFtZSA9IHRhcmdldEF0dHJzW2ldLm5hbWVcbiAgICAgIGlmKGlzSWdub3JlZCl7XG4gICAgICAgIGlmKG5hbWUuc3RhcnRzV2l0aChcImRhdGEtXCIpICYmICFzb3VyY2UuaGFzQXR0cmlidXRlKG5hbWUpKXsgdGFyZ2V0LnJlbW92ZUF0dHJpYnV0ZShuYW1lKSB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZighc291cmNlLmhhc0F0dHJpYnV0ZShuYW1lKSl7IHRhcmdldC5yZW1vdmVBdHRyaWJ1dGUobmFtZSkgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBtZXJnZUZvY3VzZWRJbnB1dCh0YXJnZXQsIHNvdXJjZSl7XG4gICAgLy8gc2tpcCBzZWxlY3RzIGJlY2F1c2UgRkYgd2lsbCByZXNldCBoaWdobGlnaHRlZCBpbmRleCBmb3IgYW55IHNldEF0dHJpYnV0ZVxuICAgIGlmKCEodGFyZ2V0IGluc3RhbmNlb2YgSFRNTFNlbGVjdEVsZW1lbnQpKXsgRE9NLm1lcmdlQXR0cnModGFyZ2V0LCBzb3VyY2UsIHtleGNsdWRlOiBbXCJ2YWx1ZVwiXX0pIH1cbiAgICBpZihzb3VyY2UucmVhZE9ubHkpe1xuICAgICAgdGFyZ2V0LnNldEF0dHJpYnV0ZShcInJlYWRvbmx5XCIsIHRydWUpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRhcmdldC5yZW1vdmVBdHRyaWJ1dGUoXCJyZWFkb25seVwiKVxuICAgIH1cbiAgfSxcblxuICBoYXNTZWxlY3Rpb25SYW5nZShlbCl7XG4gICAgcmV0dXJuIGVsLnNldFNlbGVjdGlvblJhbmdlICYmIChlbC50eXBlID09PSBcInRleHRcIiB8fCBlbC50eXBlID09PSBcInRleHRhcmVhXCIpXG4gIH0sXG5cbiAgcmVzdG9yZUZvY3VzKGZvY3VzZWQsIHNlbGVjdGlvblN0YXJ0LCBzZWxlY3Rpb25FbmQpe1xuICAgIGlmKCFET00uaXNUZXh0dWFsSW5wdXQoZm9jdXNlZCkpeyByZXR1cm4gfVxuICAgIGxldCB3YXNGb2N1c2VkID0gZm9jdXNlZC5tYXRjaGVzKFwiOmZvY3VzXCIpXG4gICAgaWYoZm9jdXNlZC5yZWFkT25seSl7IGZvY3VzZWQuYmx1cigpIH1cbiAgICBpZighd2FzRm9jdXNlZCl7IGZvY3VzZWQuZm9jdXMoKSB9XG4gICAgaWYodGhpcy5oYXNTZWxlY3Rpb25SYW5nZShmb2N1c2VkKSl7XG4gICAgICBmb2N1c2VkLnNldFNlbGVjdGlvblJhbmdlKHNlbGVjdGlvblN0YXJ0LCBzZWxlY3Rpb25FbmQpXG4gICAgfVxuICB9LFxuXG4gIGlzRm9ybUlucHV0KGVsKXsgcmV0dXJuIC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhKSQvaS50ZXN0KGVsLnRhZ05hbWUpICYmIGVsLnR5cGUgIT09IFwiYnV0dG9uXCIgfSxcblxuICBzeW5jQXR0cnNUb1Byb3BzKGVsKXtcbiAgICBpZihlbCBpbnN0YW5jZW9mIEhUTUxJbnB1dEVsZW1lbnQgJiYgQ0hFQ0tBQkxFX0lOUFVUUy5pbmRleE9mKGVsLnR5cGUudG9Mb2NhbGVMb3dlckNhc2UoKSkgPj0gMCl7XG4gICAgICBlbC5jaGVja2VkID0gZWwuZ2V0QXR0cmlidXRlKFwiY2hlY2tlZFwiKSAhPT0gbnVsbFxuICAgIH1cbiAgfSxcblxuICBpc1RleHR1YWxJbnB1dChlbCl7IHJldHVybiBGT0NVU0FCTEVfSU5QVVRTLmluZGV4T2YoZWwudHlwZSkgPj0gMCB9LFxuXG4gIGlzTm93VHJpZ2dlckZvcm1FeHRlcm5hbChlbCwgcGh4VHJpZ2dlckV4dGVybmFsKXtcbiAgICByZXR1cm4gZWwuZ2V0QXR0cmlidXRlICYmIGVsLmdldEF0dHJpYnV0ZShwaHhUcmlnZ2VyRXh0ZXJuYWwpICE9PSBudWxsXG4gIH0sXG5cbiAgc3luY1BlbmRpbmdSZWYoZnJvbUVsLCB0b0VsLCBkaXNhYmxlV2l0aCl7XG4gICAgbGV0IHJlZiA9IGZyb21FbC5nZXRBdHRyaWJ1dGUoUEhYX1JFRilcbiAgICBpZihyZWYgPT09IG51bGwpeyByZXR1cm4gdHJ1ZSB9XG4gICAgbGV0IHJlZlNyYyA9IGZyb21FbC5nZXRBdHRyaWJ1dGUoUEhYX1JFRl9TUkMpXG5cbiAgICBpZihET00uaXNGb3JtSW5wdXQoZnJvbUVsKSB8fCBmcm9tRWwuZ2V0QXR0cmlidXRlKGRpc2FibGVXaXRoKSAhPT0gbnVsbCl7XG4gICAgICBpZihET00uaXNVcGxvYWRJbnB1dChmcm9tRWwpKXsgRE9NLm1lcmdlQXR0cnMoZnJvbUVsLCB0b0VsLCB7aXNJZ25vcmVkOiB0cnVlfSkgfVxuICAgICAgRE9NLnB1dFByaXZhdGUoZnJvbUVsLCBQSFhfUkVGLCB0b0VsKVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfSBlbHNlIHtcbiAgICAgIFBIWF9FVkVOVF9DTEFTU0VTLmZvckVhY2goY2xhc3NOYW1lID0+IHtcbiAgICAgICAgZnJvbUVsLmNsYXNzTGlzdC5jb250YWlucyhjbGFzc05hbWUpICYmIHRvRWwuY2xhc3NMaXN0LmFkZChjbGFzc05hbWUpXG4gICAgICB9KVxuICAgICAgdG9FbC5zZXRBdHRyaWJ1dGUoUEhYX1JFRiwgcmVmKVxuICAgICAgdG9FbC5zZXRBdHRyaWJ1dGUoUEhYX1JFRl9TUkMsIHJlZlNyYylcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9LFxuXG4gIGNsZWFuQ2hpbGROb2Rlcyhjb250YWluZXIsIHBoeFVwZGF0ZSl7XG4gICAgaWYoRE9NLmlzUGh4VXBkYXRlKGNvbnRhaW5lciwgcGh4VXBkYXRlLCBbXCJhcHBlbmRcIiwgXCJwcmVwZW5kXCJdKSl7XG4gICAgICBsZXQgdG9SZW1vdmUgPSBbXVxuICAgICAgY29udGFpbmVyLmNoaWxkTm9kZXMuZm9yRWFjaChjaGlsZE5vZGUgPT4ge1xuICAgICAgICBpZighY2hpbGROb2RlLmlkKXtcbiAgICAgICAgICAvLyBTa2lwIHdhcm5pbmcgaWYgaXQncyBhbiBlbXB0eSB0ZXh0IG5vZGUgKGUuZy4gYSBuZXctbGluZSlcbiAgICAgICAgICBsZXQgaXNFbXB0eVRleHROb2RlID0gY2hpbGROb2RlLm5vZGVUeXBlID09PSBOb2RlLlRFWFRfTk9ERSAmJiBjaGlsZE5vZGUubm9kZVZhbHVlLnRyaW0oKSA9PT0gXCJcIlxuICAgICAgICAgIGlmKCFpc0VtcHR5VGV4dE5vZGUpe1xuICAgICAgICAgICAgbG9nRXJyb3IoXCJvbmx5IEhUTUwgZWxlbWVudCB0YWdzIHdpdGggYW4gaWQgYXJlIGFsbG93ZWQgaW5zaWRlIGNvbnRhaW5lcnMgd2l0aCBwaHgtdXBkYXRlLlxcblxcblwiICtcbiAgICAgICAgICAgICAgYHJlbW92aW5nIGlsbGVnYWwgbm9kZTogXCIkeyhjaGlsZE5vZGUub3V0ZXJIVE1MIHx8IGNoaWxkTm9kZS5ub2RlVmFsdWUpLnRyaW0oKX1cIlxcblxcbmApXG4gICAgICAgICAgfVxuICAgICAgICAgIHRvUmVtb3ZlLnB1c2goY2hpbGROb2RlKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgdG9SZW1vdmUuZm9yRWFjaChjaGlsZE5vZGUgPT4gY2hpbGROb2RlLnJlbW92ZSgpKVxuICAgIH1cbiAgfSxcblxuICByZXBsYWNlUm9vdENvbnRhaW5lcihjb250YWluZXIsIHRhZ05hbWUsIGF0dHJzKXtcbiAgICBsZXQgcmV0YWluZWRBdHRycyA9IG5ldyBTZXQoW1wiaWRcIiwgUEhYX1NFU1NJT04sIFBIWF9TVEFUSUMsIFBIWF9NQUlOLCBQSFhfUk9PVF9JRF0pXG4gICAgaWYoY29udGFpbmVyLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gdGFnTmFtZS50b0xvd2VyQ2FzZSgpKXtcbiAgICAgIEFycmF5LmZyb20oY29udGFpbmVyLmF0dHJpYnV0ZXMpXG4gICAgICAgIC5maWx0ZXIoYXR0ciA9PiAhcmV0YWluZWRBdHRycy5oYXMoYXR0ci5uYW1lLnRvTG93ZXJDYXNlKCkpKVxuICAgICAgICAuZm9yRWFjaChhdHRyID0+IGNvbnRhaW5lci5yZW1vdmVBdHRyaWJ1dGUoYXR0ci5uYW1lKSlcblxuICAgICAgT2JqZWN0LmtleXMoYXR0cnMpXG4gICAgICAgIC5maWx0ZXIobmFtZSA9PiAhcmV0YWluZWRBdHRycy5oYXMobmFtZS50b0xvd2VyQ2FzZSgpKSlcbiAgICAgICAgLmZvckVhY2goYXR0ciA9PiBjb250YWluZXIuc2V0QXR0cmlidXRlKGF0dHIsIGF0dHJzW2F0dHJdKSlcblxuICAgICAgcmV0dXJuIGNvbnRhaW5lclxuXG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBuZXdDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZ05hbWUpXG4gICAgICBPYmplY3Qua2V5cyhhdHRycykuZm9yRWFjaChhdHRyID0+IG5ld0NvbnRhaW5lci5zZXRBdHRyaWJ1dGUoYXR0ciwgYXR0cnNbYXR0cl0pKVxuICAgICAgcmV0YWluZWRBdHRycy5mb3JFYWNoKGF0dHIgPT4gbmV3Q29udGFpbmVyLnNldEF0dHJpYnV0ZShhdHRyLCBjb250YWluZXIuZ2V0QXR0cmlidXRlKGF0dHIpKSlcbiAgICAgIG5ld0NvbnRhaW5lci5pbm5lckhUTUwgPSBjb250YWluZXIuaW5uZXJIVE1MXG4gICAgICBjb250YWluZXIucmVwbGFjZVdpdGgobmV3Q29udGFpbmVyKVxuICAgICAgcmV0dXJuIG5ld0NvbnRhaW5lclxuICAgIH1cbiAgfSxcblxuICBnZXRTdGlja3koZWwsIG5hbWUsIGRlZmF1bHRWYWwpe1xuICAgIGxldCBvcCA9IChET00ucHJpdmF0ZShlbCwgXCJzdGlja3lcIikgfHwgW10pLmZpbmQoKFtleGlzdGluZ05hbWUsIF0pID0+IG5hbWUgPT09IGV4aXN0aW5nTmFtZSlcbiAgICBpZihvcCl7XG4gICAgICBsZXQgW19uYW1lLCBfb3AsIHN0YXNoZWRSZXN1bHRdID0gb3BcbiAgICAgIHJldHVybiBzdGFzaGVkUmVzdWx0XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0eXBlb2YoZGVmYXVsdFZhbCkgPT09IFwiZnVuY3Rpb25cIiA/IGRlZmF1bHRWYWwoKSA6IGRlZmF1bHRWYWxcbiAgICB9XG4gIH0sXG5cbiAgZGVsZXRlU3RpY2t5KGVsLCBuYW1lKXtcbiAgICB0aGlzLnVwZGF0ZVByaXZhdGUoZWwsIFwic3RpY2t5XCIsIFtdLCBvcHMgPT4ge1xuICAgICAgcmV0dXJuIG9wcy5maWx0ZXIoKFtleGlzdGluZ05hbWUsIF9dKSA9PiBleGlzdGluZ05hbWUgIT09IG5hbWUpXG4gICAgfSlcbiAgfSxcblxuICBwdXRTdGlja3koZWwsIG5hbWUsIG9wKXtcbiAgICBsZXQgc3Rhc2hlZFJlc3VsdCA9IG9wKGVsKVxuICAgIHRoaXMudXBkYXRlUHJpdmF0ZShlbCwgXCJzdGlja3lcIiwgW10sIG9wcyA9PiB7XG4gICAgICBsZXQgZXhpc3RpbmdJbmRleCA9IG9wcy5maW5kSW5kZXgoKFtleGlzdGluZ05hbWUsIF0pID0+IG5hbWUgPT09IGV4aXN0aW5nTmFtZSlcbiAgICAgIGlmKGV4aXN0aW5nSW5kZXggPj0gMCl7XG4gICAgICAgIG9wc1tleGlzdGluZ0luZGV4XSA9IFtuYW1lLCBvcCwgc3Rhc2hlZFJlc3VsdF1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9wcy5wdXNoKFtuYW1lLCBvcCwgc3Rhc2hlZFJlc3VsdF0pXG4gICAgICB9XG4gICAgICByZXR1cm4gb3BzXG4gICAgfSlcbiAgfSxcblxuICBhcHBseVN0aWNreU9wZXJhdGlvbnMoZWwpe1xuICAgIGxldCBvcHMgPSBET00ucHJpdmF0ZShlbCwgXCJzdGlja3lcIilcbiAgICBpZighb3BzKXsgcmV0dXJuIH1cblxuICAgIG9wcy5mb3JFYWNoKChbbmFtZSwgb3AsIF9zdGFzaGVkXSkgPT4gdGhpcy5wdXRTdGlja3koZWwsIG5hbWUsIG9wKSlcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBET01cbiIsICJpbXBvcnQge1xuICBQSFhfQUNUSVZFX0VOVFJZX1JFRlMsXG4gIFBIWF9MSVZFX0ZJTEVfVVBEQVRFRCxcbiAgUEhYX1BSRUZMSUdIVEVEX1JFRlNcbn0gZnJvbSBcIi4vY29uc3RhbnRzXCJcblxuaW1wb3J0IHtcbiAgY2hhbm5lbFVwbG9hZGVyLFxuICBsb2dFcnJvclxufSBmcm9tIFwiLi91dGlsc1wiXG5cbmltcG9ydCBMaXZlVXBsb2FkZXIgZnJvbSBcIi4vbGl2ZV91cGxvYWRlclwiXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFVwbG9hZEVudHJ5IHtcbiAgc3RhdGljIGlzQWN0aXZlKGZpbGVFbCwgZmlsZSl7XG4gICAgbGV0IGlzTmV3ID0gZmlsZS5fcGh4UmVmID09PSB1bmRlZmluZWRcbiAgICBsZXQgYWN0aXZlUmVmcyA9IGZpbGVFbC5nZXRBdHRyaWJ1dGUoUEhYX0FDVElWRV9FTlRSWV9SRUZTKS5zcGxpdChcIixcIilcbiAgICBsZXQgaXNBY3RpdmUgPSBhY3RpdmVSZWZzLmluZGV4T2YoTGl2ZVVwbG9hZGVyLmdlbkZpbGVSZWYoZmlsZSkpID49IDBcbiAgICByZXR1cm4gZmlsZS5zaXplID4gMCAmJiAoaXNOZXcgfHwgaXNBY3RpdmUpXG4gIH1cblxuICBzdGF0aWMgaXNQcmVmbGlnaHRlZChmaWxlRWwsIGZpbGUpe1xuICAgIGxldCBwcmVmbGlnaHRlZFJlZnMgPSBmaWxlRWwuZ2V0QXR0cmlidXRlKFBIWF9QUkVGTElHSFRFRF9SRUZTKS5zcGxpdChcIixcIilcbiAgICBsZXQgaXNQcmVmbGlnaHRlZCA9IHByZWZsaWdodGVkUmVmcy5pbmRleE9mKExpdmVVcGxvYWRlci5nZW5GaWxlUmVmKGZpbGUpKSA+PSAwXG4gICAgcmV0dXJuIGlzUHJlZmxpZ2h0ZWQgJiYgdGhpcy5pc0FjdGl2ZShmaWxlRWwsIGZpbGUpXG4gIH1cblxuICBjb25zdHJ1Y3RvcihmaWxlRWwsIGZpbGUsIHZpZXcpe1xuICAgIHRoaXMucmVmID0gTGl2ZVVwbG9hZGVyLmdlbkZpbGVSZWYoZmlsZSlcbiAgICB0aGlzLmZpbGVFbCA9IGZpbGVFbFxuICAgIHRoaXMuZmlsZSA9IGZpbGVcbiAgICB0aGlzLnZpZXcgPSB2aWV3XG4gICAgdGhpcy5tZXRhID0gbnVsbFxuICAgIHRoaXMuX2lzQ2FuY2VsbGVkID0gZmFsc2VcbiAgICB0aGlzLl9pc0RvbmUgPSBmYWxzZVxuICAgIHRoaXMuX3Byb2dyZXNzID0gMFxuICAgIHRoaXMuX2xhc3RQcm9ncmVzc1NlbnQgPSAtMVxuICAgIHRoaXMuX29uRG9uZSA9IGZ1bmN0aW9uICgpeyB9XG4gICAgdGhpcy5fb25FbFVwZGF0ZWQgPSB0aGlzLm9uRWxVcGRhdGVkLmJpbmQodGhpcylcbiAgICB0aGlzLmZpbGVFbC5hZGRFdmVudExpc3RlbmVyKFBIWF9MSVZFX0ZJTEVfVVBEQVRFRCwgdGhpcy5fb25FbFVwZGF0ZWQpXG4gIH1cblxuICBtZXRhZGF0YSgpeyByZXR1cm4gdGhpcy5tZXRhIH1cblxuICBwcm9ncmVzcyhwcm9ncmVzcyl7XG4gICAgdGhpcy5fcHJvZ3Jlc3MgPSBNYXRoLmZsb29yKHByb2dyZXNzKVxuICAgIGlmKHRoaXMuX3Byb2dyZXNzID4gdGhpcy5fbGFzdFByb2dyZXNzU2VudCl7XG4gICAgICBpZih0aGlzLl9wcm9ncmVzcyA+PSAxMDApe1xuICAgICAgICB0aGlzLl9wcm9ncmVzcyA9IDEwMFxuICAgICAgICB0aGlzLl9sYXN0UHJvZ3Jlc3NTZW50ID0gMTAwXG4gICAgICAgIHRoaXMuX2lzRG9uZSA9IHRydWVcbiAgICAgICAgdGhpcy52aWV3LnB1c2hGaWxlUHJvZ3Jlc3ModGhpcy5maWxlRWwsIHRoaXMucmVmLCAxMDAsICgpID0+IHtcbiAgICAgICAgICBMaXZlVXBsb2FkZXIudW50cmFja0ZpbGUodGhpcy5maWxlRWwsIHRoaXMuZmlsZSlcbiAgICAgICAgICB0aGlzLl9vbkRvbmUoKVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fbGFzdFByb2dyZXNzU2VudCA9IHRoaXMuX3Byb2dyZXNzXG4gICAgICAgIHRoaXMudmlldy5wdXNoRmlsZVByb2dyZXNzKHRoaXMuZmlsZUVsLCB0aGlzLnJlZiwgdGhpcy5fcHJvZ3Jlc3MpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY2FuY2VsKCl7XG4gICAgdGhpcy5faXNDYW5jZWxsZWQgPSB0cnVlXG4gICAgdGhpcy5faXNEb25lID0gdHJ1ZVxuICAgIHRoaXMuX29uRG9uZSgpXG4gIH1cblxuICBpc0RvbmUoKXsgcmV0dXJuIHRoaXMuX2lzRG9uZSB9XG5cbiAgZXJyb3IocmVhc29uID0gXCJmYWlsZWRcIil7XG4gICAgdGhpcy52aWV3LnB1c2hGaWxlUHJvZ3Jlc3ModGhpcy5maWxlRWwsIHRoaXMucmVmLCB7ZXJyb3I6IHJlYXNvbn0pXG4gICAgTGl2ZVVwbG9hZGVyLmNsZWFyRmlsZXModGhpcy5maWxlRWwpXG4gIH1cblxuICAvL3ByaXZhdGVcblxuICBvbkRvbmUoY2FsbGJhY2spe1xuICAgIHRoaXMuX29uRG9uZSA9ICgpID0+IHtcbiAgICAgIHRoaXMuZmlsZUVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoUEhYX0xJVkVfRklMRV9VUERBVEVELCB0aGlzLl9vbkVsVXBkYXRlZClcbiAgICAgIGNhbGxiYWNrKClcbiAgICB9XG4gIH1cblxuICBvbkVsVXBkYXRlZCgpe1xuICAgIGxldCBhY3RpdmVSZWZzID0gdGhpcy5maWxlRWwuZ2V0QXR0cmlidXRlKFBIWF9BQ1RJVkVfRU5UUllfUkVGUykuc3BsaXQoXCIsXCIpXG4gICAgaWYoYWN0aXZlUmVmcy5pbmRleE9mKHRoaXMucmVmKSA9PT0gLTEpeyB0aGlzLmNhbmNlbCgpIH1cbiAgfVxuXG4gIHRvUHJlZmxpZ2h0UGF5bG9hZCgpe1xuICAgIHJldHVybiB7XG4gICAgICBsYXN0X21vZGlmaWVkOiB0aGlzLmZpbGUubGFzdE1vZGlmaWVkLFxuICAgICAgbmFtZTogdGhpcy5maWxlLm5hbWUsXG4gICAgICBzaXplOiB0aGlzLmZpbGUuc2l6ZSxcbiAgICAgIHR5cGU6IHRoaXMuZmlsZS50eXBlLFxuICAgICAgcmVmOiB0aGlzLnJlZlxuICAgIH1cbiAgfVxuXG4gIHVwbG9hZGVyKHVwbG9hZGVycyl7XG4gICAgaWYodGhpcy5tZXRhLnVwbG9hZGVyKXtcbiAgICAgIGxldCBjYWxsYmFjayA9IHVwbG9hZGVyc1t0aGlzLm1ldGEudXBsb2FkZXJdIHx8IGxvZ0Vycm9yKGBubyB1cGxvYWRlciBjb25maWd1cmVkIGZvciAke3RoaXMubWV0YS51cGxvYWRlcn1gKVxuICAgICAgcmV0dXJuIHtuYW1lOiB0aGlzLm1ldGEudXBsb2FkZXIsIGNhbGxiYWNrOiBjYWxsYmFja31cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHtuYW1lOiBcImNoYW5uZWxcIiwgY2FsbGJhY2s6IGNoYW5uZWxVcGxvYWRlcn1cbiAgICB9XG4gIH1cblxuICB6aXBQb3N0RmxpZ2h0KHJlc3Ape1xuICAgIHRoaXMubWV0YSA9IHJlc3AuZW50cmllc1t0aGlzLnJlZl1cbiAgICBpZighdGhpcy5tZXRhKXsgbG9nRXJyb3IoYG5vIHByZWZsaWdodCB1cGxvYWQgcmVzcG9uc2UgcmV0dXJuZWQgd2l0aCByZWYgJHt0aGlzLnJlZn1gLCB7aW5wdXQ6IHRoaXMuZmlsZUVsLCByZXNwb25zZTogcmVzcH0pIH1cbiAgfVxufVxuIiwgImltcG9ydCB7XG4gIFBIWF9ET05FX1JFRlMsXG4gIFBIWF9QUkVGTElHSFRFRF9SRUZTLFxuICBQSFhfVVBMT0FEX1JFRlxufSBmcm9tIFwiLi9jb25zdGFudHNcIlxuXG5pbXBvcnQge1xufSBmcm9tIFwiLi91dGlsc1wiXG5cbmltcG9ydCBET00gZnJvbSBcIi4vZG9tXCJcbmltcG9ydCBVcGxvYWRFbnRyeSBmcm9tIFwiLi91cGxvYWRfZW50cnlcIlxuXG5sZXQgbGl2ZVVwbG9hZGVyRmlsZVJlZiA9IDBcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGl2ZVVwbG9hZGVyIHtcbiAgc3RhdGljIGdlbkZpbGVSZWYoZmlsZSl7XG4gICAgbGV0IHJlZiA9IGZpbGUuX3BoeFJlZlxuICAgIGlmKHJlZiAhPT0gdW5kZWZpbmVkKXtcbiAgICAgIHJldHVybiByZWZcbiAgICB9IGVsc2Uge1xuICAgICAgZmlsZS5fcGh4UmVmID0gKGxpdmVVcGxvYWRlckZpbGVSZWYrKykudG9TdHJpbmcoKVxuICAgICAgcmV0dXJuIGZpbGUuX3BoeFJlZlxuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBnZXRFbnRyeURhdGFVUkwoaW5wdXRFbCwgcmVmLCBjYWxsYmFjayl7XG4gICAgbGV0IGZpbGUgPSB0aGlzLmFjdGl2ZUZpbGVzKGlucHV0RWwpLmZpbmQoZmlsZSA9PiB0aGlzLmdlbkZpbGVSZWYoZmlsZSkgPT09IHJlZilcbiAgICBjYWxsYmFjayhVUkwuY3JlYXRlT2JqZWN0VVJMKGZpbGUpKVxuICB9XG5cbiAgc3RhdGljIGhhc1VwbG9hZHNJblByb2dyZXNzKGZvcm1FbCl7XG4gICAgbGV0IGFjdGl2ZSA9IDBcbiAgICBET00uZmluZFVwbG9hZElucHV0cyhmb3JtRWwpLmZvckVhY2goaW5wdXQgPT4ge1xuICAgICAgaWYoaW5wdXQuZ2V0QXR0cmlidXRlKFBIWF9QUkVGTElHSFRFRF9SRUZTKSAhPT0gaW5wdXQuZ2V0QXR0cmlidXRlKFBIWF9ET05FX1JFRlMpKXtcbiAgICAgICAgYWN0aXZlKytcbiAgICAgIH1cbiAgICB9KVxuICAgIHJldHVybiBhY3RpdmUgPiAwXG4gIH1cblxuICBzdGF0aWMgc2VyaWFsaXplVXBsb2FkcyhpbnB1dEVsKXtcbiAgICBsZXQgZmlsZXMgPSB0aGlzLmFjdGl2ZUZpbGVzKGlucHV0RWwpXG4gICAgbGV0IGZpbGVEYXRhID0ge31cbiAgICBmaWxlcy5mb3JFYWNoKGZpbGUgPT4ge1xuICAgICAgbGV0IGVudHJ5ID0ge3BhdGg6IGlucHV0RWwubmFtZX1cbiAgICAgIGxldCB1cGxvYWRSZWYgPSBpbnB1dEVsLmdldEF0dHJpYnV0ZShQSFhfVVBMT0FEX1JFRilcbiAgICAgIGZpbGVEYXRhW3VwbG9hZFJlZl0gPSBmaWxlRGF0YVt1cGxvYWRSZWZdIHx8IFtdXG4gICAgICBlbnRyeS5yZWYgPSB0aGlzLmdlbkZpbGVSZWYoZmlsZSlcbiAgICAgIGVudHJ5Lm5hbWUgPSBmaWxlLm5hbWUgfHwgZW50cnkucmVmXG4gICAgICBlbnRyeS50eXBlID0gZmlsZS50eXBlXG4gICAgICBlbnRyeS5zaXplID0gZmlsZS5zaXplXG4gICAgICBmaWxlRGF0YVt1cGxvYWRSZWZdLnB1c2goZW50cnkpXG4gICAgfSlcbiAgICByZXR1cm4gZmlsZURhdGFcbiAgfVxuXG4gIHN0YXRpYyBjbGVhckZpbGVzKGlucHV0RWwpe1xuICAgIGlucHV0RWwudmFsdWUgPSBudWxsXG4gICAgaW5wdXRFbC5yZW1vdmVBdHRyaWJ1dGUoUEhYX1VQTE9BRF9SRUYpXG4gICAgRE9NLnB1dFByaXZhdGUoaW5wdXRFbCwgXCJmaWxlc1wiLCBbXSlcbiAgfVxuXG4gIHN0YXRpYyB1bnRyYWNrRmlsZShpbnB1dEVsLCBmaWxlKXtcbiAgICBET00ucHV0UHJpdmF0ZShpbnB1dEVsLCBcImZpbGVzXCIsIERPTS5wcml2YXRlKGlucHV0RWwsIFwiZmlsZXNcIikuZmlsdGVyKGYgPT4gIU9iamVjdC5pcyhmLCBmaWxlKSkpXG4gIH1cblxuICBzdGF0aWMgdHJhY2tGaWxlcyhpbnB1dEVsLCBmaWxlcyl7XG4gICAgaWYoaW5wdXRFbC5nZXRBdHRyaWJ1dGUoXCJtdWx0aXBsZVwiKSAhPT0gbnVsbCl7XG4gICAgICBsZXQgbmV3RmlsZXMgPSBmaWxlcy5maWx0ZXIoZmlsZSA9PiAhdGhpcy5hY3RpdmVGaWxlcyhpbnB1dEVsKS5maW5kKGYgPT4gT2JqZWN0LmlzKGYsIGZpbGUpKSlcbiAgICAgIERPTS5wdXRQcml2YXRlKGlucHV0RWwsIFwiZmlsZXNcIiwgdGhpcy5hY3RpdmVGaWxlcyhpbnB1dEVsKS5jb25jYXQobmV3RmlsZXMpKVxuICAgICAgaW5wdXRFbC52YWx1ZSA9IG51bGxcbiAgICB9IGVsc2Uge1xuICAgICAgRE9NLnB1dFByaXZhdGUoaW5wdXRFbCwgXCJmaWxlc1wiLCBmaWxlcylcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgYWN0aXZlRmlsZUlucHV0cyhmb3JtRWwpe1xuICAgIGxldCBmaWxlSW5wdXRzID0gRE9NLmZpbmRVcGxvYWRJbnB1dHMoZm9ybUVsKVxuICAgIHJldHVybiBBcnJheS5mcm9tKGZpbGVJbnB1dHMpLmZpbHRlcihlbCA9PiBlbC5maWxlcyAmJiB0aGlzLmFjdGl2ZUZpbGVzKGVsKS5sZW5ndGggPiAwKVxuICB9XG5cbiAgc3RhdGljIGFjdGl2ZUZpbGVzKGlucHV0KXtcbiAgICByZXR1cm4gKERPTS5wcml2YXRlKGlucHV0LCBcImZpbGVzXCIpIHx8IFtdKS5maWx0ZXIoZiA9PiBVcGxvYWRFbnRyeS5pc0FjdGl2ZShpbnB1dCwgZikpXG4gIH1cblxuICBzdGF0aWMgaW5wdXRzQXdhaXRpbmdQcmVmbGlnaHQoZm9ybUVsKXtcbiAgICBsZXQgZmlsZUlucHV0cyA9IERPTS5maW5kVXBsb2FkSW5wdXRzKGZvcm1FbClcbiAgICByZXR1cm4gQXJyYXkuZnJvbShmaWxlSW5wdXRzKS5maWx0ZXIoaW5wdXQgPT4gdGhpcy5maWxlc0F3YWl0aW5nUHJlZmxpZ2h0KGlucHV0KS5sZW5ndGggPiAwKVxuICB9XG5cbiAgc3RhdGljIGZpbGVzQXdhaXRpbmdQcmVmbGlnaHQoaW5wdXQpe1xuICAgIHJldHVybiB0aGlzLmFjdGl2ZUZpbGVzKGlucHV0KS5maWx0ZXIoZiA9PiAhVXBsb2FkRW50cnkuaXNQcmVmbGlnaHRlZChpbnB1dCwgZikpXG4gIH1cblxuICBjb25zdHJ1Y3RvcihpbnB1dEVsLCB2aWV3LCBvbkNvbXBsZXRlKXtcbiAgICB0aGlzLnZpZXcgPSB2aWV3XG4gICAgdGhpcy5vbkNvbXBsZXRlID0gb25Db21wbGV0ZVxuICAgIHRoaXMuX2VudHJpZXMgPVxuICAgICAgQXJyYXkuZnJvbShMaXZlVXBsb2FkZXIuZmlsZXNBd2FpdGluZ1ByZWZsaWdodChpbnB1dEVsKSB8fCBbXSlcbiAgICAgICAgLm1hcChmaWxlID0+IG5ldyBVcGxvYWRFbnRyeShpbnB1dEVsLCBmaWxlLCB2aWV3KSlcblxuICAgIHRoaXMubnVtRW50cmllc0luUHJvZ3Jlc3MgPSB0aGlzLl9lbnRyaWVzLmxlbmd0aFxuICB9XG5cbiAgZW50cmllcygpeyByZXR1cm4gdGhpcy5fZW50cmllcyB9XG5cbiAgaW5pdEFkYXB0ZXJVcGxvYWQocmVzcCwgb25FcnJvciwgbGl2ZVNvY2tldCl7XG4gICAgdGhpcy5fZW50cmllcyA9XG4gICAgICB0aGlzLl9lbnRyaWVzLm1hcChlbnRyeSA9PiB7XG4gICAgICAgIGVudHJ5LnppcFBvc3RGbGlnaHQocmVzcClcbiAgICAgICAgZW50cnkub25Eb25lKCgpID0+IHtcbiAgICAgICAgICB0aGlzLm51bUVudHJpZXNJblByb2dyZXNzLS1cbiAgICAgICAgICBpZih0aGlzLm51bUVudHJpZXNJblByb2dyZXNzID09PSAwKXsgdGhpcy5vbkNvbXBsZXRlKCkgfVxuICAgICAgICB9KVxuICAgICAgICByZXR1cm4gZW50cnlcbiAgICAgIH0pXG5cbiAgICBsZXQgZ3JvdXBlZEVudHJpZXMgPSB0aGlzLl9lbnRyaWVzLnJlZHVjZSgoYWNjLCBlbnRyeSkgPT4ge1xuICAgICAgbGV0IHtuYW1lLCBjYWxsYmFja30gPSBlbnRyeS51cGxvYWRlcihsaXZlU29ja2V0LnVwbG9hZGVycylcbiAgICAgIGFjY1tuYW1lXSA9IGFjY1tuYW1lXSB8fCB7Y2FsbGJhY2s6IGNhbGxiYWNrLCBlbnRyaWVzOiBbXX1cbiAgICAgIGFjY1tuYW1lXS5lbnRyaWVzLnB1c2goZW50cnkpXG4gICAgICByZXR1cm4gYWNjXG4gICAgfSwge30pXG5cbiAgICBmb3IobGV0IG5hbWUgaW4gZ3JvdXBlZEVudHJpZXMpe1xuICAgICAgbGV0IHtjYWxsYmFjaywgZW50cmllc30gPSBncm91cGVkRW50cmllc1tuYW1lXVxuICAgICAgY2FsbGJhY2soZW50cmllcywgb25FcnJvciwgcmVzcCwgbGl2ZVNvY2tldClcbiAgICB9XG4gIH1cbn1cbiIsICJpbXBvcnQge1xuICBQSFhfQUNUSVZFX0VOVFJZX1JFRlMsXG4gIFBIWF9MSVZFX0ZJTEVfVVBEQVRFRCxcbiAgUEhYX1BSRUZMSUdIVEVEX1JFRlMsXG4gIFBIWF9VUExPQURfUkVGXG59IGZyb20gXCIuL2NvbnN0YW50c1wiXG5cbmltcG9ydCBMaXZlVXBsb2FkZXIgZnJvbSBcIi4vbGl2ZV91cGxvYWRlclwiXG5cbmxldCBIb29rcyA9IHtcbiAgTGl2ZUZpbGVVcGxvYWQ6IHtcbiAgICBhY3RpdmVSZWZzKCl7IHJldHVybiB0aGlzLmVsLmdldEF0dHJpYnV0ZShQSFhfQUNUSVZFX0VOVFJZX1JFRlMpIH0sXG5cbiAgICBwcmVmbGlnaHRlZFJlZnMoKXsgcmV0dXJuIHRoaXMuZWwuZ2V0QXR0cmlidXRlKFBIWF9QUkVGTElHSFRFRF9SRUZTKSB9LFxuXG4gICAgbW91bnRlZCgpeyB0aGlzLnByZWZsaWdodGVkV2FzID0gdGhpcy5wcmVmbGlnaHRlZFJlZnMoKSB9LFxuXG4gICAgdXBkYXRlZCgpe1xuICAgICAgbGV0IG5ld1ByZWZsaWdodHMgPSB0aGlzLnByZWZsaWdodGVkUmVmcygpXG4gICAgICBpZih0aGlzLnByZWZsaWdodGVkV2FzICE9PSBuZXdQcmVmbGlnaHRzKXtcbiAgICAgICAgdGhpcy5wcmVmbGlnaHRlZFdhcyA9IG5ld1ByZWZsaWdodHNcbiAgICAgICAgaWYobmV3UHJlZmxpZ2h0cyA9PT0gXCJcIil7XG4gICAgICAgICAgdGhpcy5fX3ZpZXcuY2FuY2VsU3VibWl0KHRoaXMuZWwuZm9ybSlcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZih0aGlzLmFjdGl2ZVJlZnMoKSA9PT0gXCJcIil7IHRoaXMuZWwudmFsdWUgPSBudWxsIH1cbiAgICAgIHRoaXMuZWwuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoUEhYX0xJVkVfRklMRV9VUERBVEVEKSlcbiAgICB9XG4gIH0sXG5cbiAgTGl2ZUltZ1ByZXZpZXc6IHtcbiAgICBtb3VudGVkKCl7XG4gICAgICB0aGlzLnJlZiA9IHRoaXMuZWwuZ2V0QXR0cmlidXRlKFwiZGF0YS1waHgtZW50cnktcmVmXCIpXG4gICAgICB0aGlzLmlucHV0RWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLmVsLmdldEF0dHJpYnV0ZShQSFhfVVBMT0FEX1JFRikpXG4gICAgICBMaXZlVXBsb2FkZXIuZ2V0RW50cnlEYXRhVVJMKHRoaXMuaW5wdXRFbCwgdGhpcy5yZWYsIHVybCA9PiB7XG4gICAgICAgIHRoaXMudXJsID0gdXJsXG4gICAgICAgIHRoaXMuZWwuc3JjID0gdXJsXG4gICAgICB9KVxuICAgIH0sXG4gICAgZGVzdHJveWVkKCl7XG4gICAgICBVUkwucmV2b2tlT2JqZWN0VVJMKHRoaXMudXJsKVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBIb29rc1xuIiwgImltcG9ydCB7XG4gIG1heWJlXG59IGZyb20gXCIuL3V0aWxzXCJcblxuaW1wb3J0IERPTSBmcm9tIFwiLi9kb21cIlxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBET01Qb3N0TW9ycGhSZXN0b3JlciB7XG4gIGNvbnN0cnVjdG9yKGNvbnRhaW5lckJlZm9yZSwgY29udGFpbmVyQWZ0ZXIsIHVwZGF0ZVR5cGUpe1xuICAgIGxldCBpZHNCZWZvcmUgPSBuZXcgU2V0KClcbiAgICBsZXQgaWRzQWZ0ZXIgPSBuZXcgU2V0KFsuLi5jb250YWluZXJBZnRlci5jaGlsZHJlbl0ubWFwKGNoaWxkID0+IGNoaWxkLmlkKSlcblxuICAgIGxldCBlbGVtZW50c1RvTW9kaWZ5ID0gW11cblxuICAgIEFycmF5LmZyb20oY29udGFpbmVyQmVmb3JlLmNoaWxkcmVuKS5mb3JFYWNoKGNoaWxkID0+IHtcbiAgICAgIGlmKGNoaWxkLmlkKXsgLy8gYWxsIG9mIG91ciBjaGlsZHJlbiBzaG91bGQgYmUgZWxlbWVudHMgd2l0aCBpZHNcbiAgICAgICAgaWRzQmVmb3JlLmFkZChjaGlsZC5pZClcbiAgICAgICAgaWYoaWRzQWZ0ZXIuaGFzKGNoaWxkLmlkKSl7XG4gICAgICAgICAgbGV0IHByZXZpb3VzRWxlbWVudElkID0gY2hpbGQucHJldmlvdXNFbGVtZW50U2libGluZyAmJiBjaGlsZC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nLmlkXG4gICAgICAgICAgZWxlbWVudHNUb01vZGlmeS5wdXNoKHtlbGVtZW50SWQ6IGNoaWxkLmlkLCBwcmV2aW91c0VsZW1lbnRJZDogcHJldmlvdXNFbGVtZW50SWR9KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcblxuICAgIHRoaXMuY29udGFpbmVySWQgPSBjb250YWluZXJBZnRlci5pZFxuICAgIHRoaXMudXBkYXRlVHlwZSA9IHVwZGF0ZVR5cGVcbiAgICB0aGlzLmVsZW1lbnRzVG9Nb2RpZnkgPSBlbGVtZW50c1RvTW9kaWZ5XG4gICAgdGhpcy5lbGVtZW50SWRzVG9BZGQgPSBbLi4uaWRzQWZ0ZXJdLmZpbHRlcihpZCA9PiAhaWRzQmVmb3JlLmhhcyhpZCkpXG4gIH1cblxuICAvLyBXZSBkbyB0aGUgZm9sbG93aW5nIHRvIG9wdGltaXplIGFwcGVuZC9wcmVwZW5kIG9wZXJhdGlvbnM6XG4gIC8vICAgMSkgVHJhY2sgaWRzIG9mIG1vZGlmaWVkIGVsZW1lbnRzICYgb2YgbmV3IGVsZW1lbnRzXG4gIC8vICAgMikgQWxsIHRoZSBtb2RpZmllZCBlbGVtZW50cyBhcmUgcHV0IGJhY2sgaW4gdGhlIGNvcnJlY3QgcG9zaXRpb24gaW4gdGhlIERPTSB0cmVlXG4gIC8vICAgICAgYnkgc3RvcmluZyB0aGUgaWQgb2YgdGhlaXIgcHJldmlvdXMgc2libGluZ1xuICAvLyAgIDMpIE5ldyBlbGVtZW50cyBhcmUgZ29pbmcgdG8gYmUgcHV0IGluIHRoZSByaWdodCBwbGFjZSBieSBtb3JwaGRvbSBkdXJpbmcgYXBwZW5kLlxuICAvLyAgICAgIEZvciBwcmVwZW5kLCB3ZSBtb3ZlIHRoZW0gdG8gdGhlIGZpcnN0IHBvc2l0aW9uIGluIHRoZSBjb250YWluZXJcbiAgcGVyZm9ybSgpe1xuICAgIGxldCBjb250YWluZXIgPSBET00uYnlJZCh0aGlzLmNvbnRhaW5lcklkKVxuICAgIHRoaXMuZWxlbWVudHNUb01vZGlmeS5mb3JFYWNoKGVsZW1lbnRUb01vZGlmeSA9PiB7XG4gICAgICBpZihlbGVtZW50VG9Nb2RpZnkucHJldmlvdXNFbGVtZW50SWQpe1xuICAgICAgICBtYXliZShkb2N1bWVudC5nZXRFbGVtZW50QnlJZChlbGVtZW50VG9Nb2RpZnkucHJldmlvdXNFbGVtZW50SWQpLCBwcmV2aW91c0VsZW0gPT4ge1xuICAgICAgICAgIG1heWJlKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGVsZW1lbnRUb01vZGlmeS5lbGVtZW50SWQpLCBlbGVtID0+IHtcbiAgICAgICAgICAgIGxldCBpc0luUmlnaHRQbGFjZSA9IGVsZW0ucHJldmlvdXNFbGVtZW50U2libGluZyAmJiBlbGVtLnByZXZpb3VzRWxlbWVudFNpYmxpbmcuaWQgPT0gcHJldmlvdXNFbGVtLmlkXG4gICAgICAgICAgICBpZighaXNJblJpZ2h0UGxhY2Upe1xuICAgICAgICAgICAgICBwcmV2aW91c0VsZW0uaW5zZXJ0QWRqYWNlbnRFbGVtZW50KFwiYWZ0ZXJlbmRcIiwgZWxlbSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVGhpcyBpcyB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgY29udGFpbmVyXG4gICAgICAgIG1heWJlKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGVsZW1lbnRUb01vZGlmeS5lbGVtZW50SWQpLCBlbGVtID0+IHtcbiAgICAgICAgICBsZXQgaXNJblJpZ2h0UGxhY2UgPSBlbGVtLnByZXZpb3VzRWxlbWVudFNpYmxpbmcgPT0gbnVsbFxuICAgICAgICAgIGlmKCFpc0luUmlnaHRQbGFjZSl7XG4gICAgICAgICAgICBjb250YWluZXIuaW5zZXJ0QWRqYWNlbnRFbGVtZW50KFwiYWZ0ZXJiZWdpblwiLCBlbGVtKVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgaWYodGhpcy51cGRhdGVUeXBlID09IFwicHJlcGVuZFwiKXtcbiAgICAgIHRoaXMuZWxlbWVudElkc1RvQWRkLnJldmVyc2UoKS5mb3JFYWNoKGVsZW1JZCA9PiB7XG4gICAgICAgIG1heWJlKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGVsZW1JZCksIGVsZW0gPT4gY29udGFpbmVyLmluc2VydEFkamFjZW50RWxlbWVudChcImFmdGVyYmVnaW5cIiwgZWxlbSkpXG4gICAgICB9KVxuICAgIH1cbiAgfVxufVxuIiwgInZhciBET0NVTUVOVF9GUkFHTUVOVF9OT0RFID0gMTE7XG5cbmZ1bmN0aW9uIG1vcnBoQXR0cnMoZnJvbU5vZGUsIHRvTm9kZSkge1xuICAgIHZhciB0b05vZGVBdHRycyA9IHRvTm9kZS5hdHRyaWJ1dGVzO1xuICAgIHZhciBhdHRyO1xuICAgIHZhciBhdHRyTmFtZTtcbiAgICB2YXIgYXR0ck5hbWVzcGFjZVVSSTtcbiAgICB2YXIgYXR0clZhbHVlO1xuICAgIHZhciBmcm9tVmFsdWU7XG5cbiAgICAvLyBkb2N1bWVudC1mcmFnbWVudHMgZG9udCBoYXZlIGF0dHJpYnV0ZXMgc28gbGV0cyBub3QgZG8gYW55dGhpbmdcbiAgICBpZiAodG9Ob2RlLm5vZGVUeXBlID09PSBET0NVTUVOVF9GUkFHTUVOVF9OT0RFIHx8IGZyb21Ob2RlLm5vZGVUeXBlID09PSBET0NVTUVOVF9GUkFHTUVOVF9OT0RFKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gdXBkYXRlIGF0dHJpYnV0ZXMgb24gb3JpZ2luYWwgRE9NIGVsZW1lbnRcbiAgICBmb3IgKHZhciBpID0gdG9Ob2RlQXR0cnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgYXR0ciA9IHRvTm9kZUF0dHJzW2ldO1xuICAgICAgICBhdHRyTmFtZSA9IGF0dHIubmFtZTtcbiAgICAgICAgYXR0ck5hbWVzcGFjZVVSSSA9IGF0dHIubmFtZXNwYWNlVVJJO1xuICAgICAgICBhdHRyVmFsdWUgPSBhdHRyLnZhbHVlO1xuXG4gICAgICAgIGlmIChhdHRyTmFtZXNwYWNlVVJJKSB7XG4gICAgICAgICAgICBhdHRyTmFtZSA9IGF0dHIubG9jYWxOYW1lIHx8IGF0dHJOYW1lO1xuICAgICAgICAgICAgZnJvbVZhbHVlID0gZnJvbU5vZGUuZ2V0QXR0cmlidXRlTlMoYXR0ck5hbWVzcGFjZVVSSSwgYXR0ck5hbWUpO1xuXG4gICAgICAgICAgICBpZiAoZnJvbVZhbHVlICE9PSBhdHRyVmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoYXR0ci5wcmVmaXggPT09ICd4bWxucycpe1xuICAgICAgICAgICAgICAgICAgICBhdHRyTmFtZSA9IGF0dHIubmFtZTsgLy8gSXQncyBub3QgYWxsb3dlZCB0byBzZXQgYW4gYXR0cmlidXRlIHdpdGggdGhlIFhNTE5TIG5hbWVzcGFjZSB3aXRob3V0IHNwZWNpZnlpbmcgdGhlIGB4bWxuc2AgcHJlZml4XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZyb21Ob2RlLnNldEF0dHJpYnV0ZU5TKGF0dHJOYW1lc3BhY2VVUkksIGF0dHJOYW1lLCBhdHRyVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZnJvbVZhbHVlID0gZnJvbU5vZGUuZ2V0QXR0cmlidXRlKGF0dHJOYW1lKTtcblxuICAgICAgICAgICAgaWYgKGZyb21WYWx1ZSAhPT0gYXR0clZhbHVlKSB7XG4gICAgICAgICAgICAgICAgZnJvbU5vZGUuc2V0QXR0cmlidXRlKGF0dHJOYW1lLCBhdHRyVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmVtb3ZlIGFueSBleHRyYSBhdHRyaWJ1dGVzIGZvdW5kIG9uIHRoZSBvcmlnaW5hbCBET00gZWxlbWVudCB0aGF0XG4gICAgLy8gd2VyZW4ndCBmb3VuZCBvbiB0aGUgdGFyZ2V0IGVsZW1lbnQuXG4gICAgdmFyIGZyb21Ob2RlQXR0cnMgPSBmcm9tTm9kZS5hdHRyaWJ1dGVzO1xuXG4gICAgZm9yICh2YXIgZCA9IGZyb21Ob2RlQXR0cnMubGVuZ3RoIC0gMTsgZCA+PSAwOyBkLS0pIHtcbiAgICAgICAgYXR0ciA9IGZyb21Ob2RlQXR0cnNbZF07XG4gICAgICAgIGF0dHJOYW1lID0gYXR0ci5uYW1lO1xuICAgICAgICBhdHRyTmFtZXNwYWNlVVJJID0gYXR0ci5uYW1lc3BhY2VVUkk7XG5cbiAgICAgICAgaWYgKGF0dHJOYW1lc3BhY2VVUkkpIHtcbiAgICAgICAgICAgIGF0dHJOYW1lID0gYXR0ci5sb2NhbE5hbWUgfHwgYXR0ck5hbWU7XG5cbiAgICAgICAgICAgIGlmICghdG9Ob2RlLmhhc0F0dHJpYnV0ZU5TKGF0dHJOYW1lc3BhY2VVUkksIGF0dHJOYW1lKSkge1xuICAgICAgICAgICAgICAgIGZyb21Ob2RlLnJlbW92ZUF0dHJpYnV0ZU5TKGF0dHJOYW1lc3BhY2VVUkksIGF0dHJOYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghdG9Ob2RlLmhhc0F0dHJpYnV0ZShhdHRyTmFtZSkpIHtcbiAgICAgICAgICAgICAgICBmcm9tTm9kZS5yZW1vdmVBdHRyaWJ1dGUoYXR0ck5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG52YXIgcmFuZ2U7IC8vIENyZWF0ZSBhIHJhbmdlIG9iamVjdCBmb3IgZWZmaWNlbnRseSByZW5kZXJpbmcgc3RyaW5ncyB0byBlbGVtZW50cy5cbnZhciBOU19YSFRNTCA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sJztcblxudmFyIGRvYyA9IHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBkb2N1bWVudDtcbnZhciBIQVNfVEVNUExBVEVfU1VQUE9SVCA9ICEhZG9jICYmICdjb250ZW50JyBpbiBkb2MuY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKTtcbnZhciBIQVNfUkFOR0VfU1VQUE9SVCA9ICEhZG9jICYmIGRvYy5jcmVhdGVSYW5nZSAmJiAnY3JlYXRlQ29udGV4dHVhbEZyYWdtZW50JyBpbiBkb2MuY3JlYXRlUmFuZ2UoKTtcblxuZnVuY3Rpb24gY3JlYXRlRnJhZ21lbnRGcm9tVGVtcGxhdGUoc3RyKSB7XG4gICAgdmFyIHRlbXBsYXRlID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJyk7XG4gICAgdGVtcGxhdGUuaW5uZXJIVE1MID0gc3RyO1xuICAgIHJldHVybiB0ZW1wbGF0ZS5jb250ZW50LmNoaWxkTm9kZXNbMF07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZyYWdtZW50RnJvbVJhbmdlKHN0cikge1xuICAgIGlmICghcmFuZ2UpIHtcbiAgICAgICAgcmFuZ2UgPSBkb2MuY3JlYXRlUmFuZ2UoKTtcbiAgICAgICAgcmFuZ2Uuc2VsZWN0Tm9kZShkb2MuYm9keSk7XG4gICAgfVxuXG4gICAgdmFyIGZyYWdtZW50ID0gcmFuZ2UuY3JlYXRlQ29udGV4dHVhbEZyYWdtZW50KHN0cik7XG4gICAgcmV0dXJuIGZyYWdtZW50LmNoaWxkTm9kZXNbMF07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZyYWdtZW50RnJvbVdyYXAoc3RyKSB7XG4gICAgdmFyIGZyYWdtZW50ID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ2JvZHknKTtcbiAgICBmcmFnbWVudC5pbm5lckhUTUwgPSBzdHI7XG4gICAgcmV0dXJuIGZyYWdtZW50LmNoaWxkTm9kZXNbMF07XG59XG5cbi8qKlxuICogVGhpcyBpcyBhYm91dCB0aGUgc2FtZVxuICogdmFyIGh0bWwgPSBuZXcgRE9NUGFyc2VyKCkucGFyc2VGcm9tU3RyaW5nKHN0ciwgJ3RleHQvaHRtbCcpO1xuICogcmV0dXJuIGh0bWwuYm9keS5maXJzdENoaWxkO1xuICpcbiAqIEBtZXRob2QgdG9FbGVtZW50XG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKi9cbmZ1bmN0aW9uIHRvRWxlbWVudChzdHIpIHtcbiAgICBzdHIgPSBzdHIudHJpbSgpO1xuICAgIGlmIChIQVNfVEVNUExBVEVfU1VQUE9SVCkge1xuICAgICAgLy8gYXZvaWQgcmVzdHJpY3Rpb25zIG9uIGNvbnRlbnQgZm9yIHRoaW5ncyBsaWtlIGA8dHI+PHRoPkhpPC90aD48L3RyPmAgd2hpY2hcbiAgICAgIC8vIGNyZWF0ZUNvbnRleHR1YWxGcmFnbWVudCBkb2Vzbid0IHN1cHBvcnRcbiAgICAgIC8vIDx0ZW1wbGF0ZT4gc3VwcG9ydCBub3QgYXZhaWxhYmxlIGluIElFXG4gICAgICByZXR1cm4gY3JlYXRlRnJhZ21lbnRGcm9tVGVtcGxhdGUoc3RyKTtcbiAgICB9IGVsc2UgaWYgKEhBU19SQU5HRV9TVVBQT1JUKSB7XG4gICAgICByZXR1cm4gY3JlYXRlRnJhZ21lbnRGcm9tUmFuZ2Uoc3RyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY3JlYXRlRnJhZ21lbnRGcm9tV3JhcChzdHIpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0d28gbm9kZSdzIG5hbWVzIGFyZSB0aGUgc2FtZS5cbiAqXG4gKiBOT1RFOiBXZSBkb24ndCBib3RoZXIgY2hlY2tpbmcgYG5hbWVzcGFjZVVSSWAgYmVjYXVzZSB5b3Ugd2lsbCBuZXZlciBmaW5kIHR3byBIVE1MIGVsZW1lbnRzIHdpdGggdGhlIHNhbWVcbiAqICAgICAgIG5vZGVOYW1lIGFuZCBkaWZmZXJlbnQgbmFtZXNwYWNlIFVSSXMuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBhXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGIgVGhlIHRhcmdldCBlbGVtZW50XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBjb21wYXJlTm9kZU5hbWVzKGZyb21FbCwgdG9FbCkge1xuICAgIHZhciBmcm9tTm9kZU5hbWUgPSBmcm9tRWwubm9kZU5hbWU7XG4gICAgdmFyIHRvTm9kZU5hbWUgPSB0b0VsLm5vZGVOYW1lO1xuICAgIHZhciBmcm9tQ29kZVN0YXJ0LCB0b0NvZGVTdGFydDtcblxuICAgIGlmIChmcm9tTm9kZU5hbWUgPT09IHRvTm9kZU5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgZnJvbUNvZGVTdGFydCA9IGZyb21Ob2RlTmFtZS5jaGFyQ29kZUF0KDApO1xuICAgIHRvQ29kZVN0YXJ0ID0gdG9Ob2RlTmFtZS5jaGFyQ29kZUF0KDApO1xuXG4gICAgLy8gSWYgdGhlIHRhcmdldCBlbGVtZW50IGlzIGEgdmlydHVhbCBET00gbm9kZSBvciBTVkcgbm9kZSB0aGVuIHdlIG1heVxuICAgIC8vIG5lZWQgdG8gbm9ybWFsaXplIHRoZSB0YWcgbmFtZSBiZWZvcmUgY29tcGFyaW5nLiBOb3JtYWwgSFRNTCBlbGVtZW50cyB0aGF0IGFyZVxuICAgIC8vIGluIHRoZSBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIlxuICAgIC8vIGFyZSBjb252ZXJ0ZWQgdG8gdXBwZXIgY2FzZVxuICAgIGlmIChmcm9tQ29kZVN0YXJ0IDw9IDkwICYmIHRvQ29kZVN0YXJ0ID49IDk3KSB7IC8vIGZyb20gaXMgdXBwZXIgYW5kIHRvIGlzIGxvd2VyXG4gICAgICAgIHJldHVybiBmcm9tTm9kZU5hbWUgPT09IHRvTm9kZU5hbWUudG9VcHBlckNhc2UoKTtcbiAgICB9IGVsc2UgaWYgKHRvQ29kZVN0YXJ0IDw9IDkwICYmIGZyb21Db2RlU3RhcnQgPj0gOTcpIHsgLy8gdG8gaXMgdXBwZXIgYW5kIGZyb20gaXMgbG93ZXJcbiAgICAgICAgcmV0dXJuIHRvTm9kZU5hbWUgPT09IGZyb21Ob2RlTmFtZS50b1VwcGVyQ2FzZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5cbi8qKlxuICogQ3JlYXRlIGFuIGVsZW1lbnQsIG9wdGlvbmFsbHkgd2l0aCBhIGtub3duIG5hbWVzcGFjZSBVUkkuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgdGhlIGVsZW1lbnQgbmFtZSwgZS5nLiAnZGl2JyBvciAnc3ZnJ1xuICogQHBhcmFtIHtzdHJpbmd9IFtuYW1lc3BhY2VVUkldIHRoZSBlbGVtZW50J3MgbmFtZXNwYWNlIFVSSSwgaS5lLiB0aGUgdmFsdWUgb2ZcbiAqIGl0cyBgeG1sbnNgIGF0dHJpYnV0ZSBvciBpdHMgaW5mZXJyZWQgbmFtZXNwYWNlLlxuICpcbiAqIEByZXR1cm4ge0VsZW1lbnR9XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnROUyhuYW1lLCBuYW1lc3BhY2VVUkkpIHtcbiAgICByZXR1cm4gIW5hbWVzcGFjZVVSSSB8fCBuYW1lc3BhY2VVUkkgPT09IE5TX1hIVE1MID9cbiAgICAgICAgZG9jLmNyZWF0ZUVsZW1lbnQobmFtZSkgOlxuICAgICAgICBkb2MuY3JlYXRlRWxlbWVudE5TKG5hbWVzcGFjZVVSSSwgbmFtZSk7XG59XG5cbi8qKlxuICogQ29waWVzIHRoZSBjaGlsZHJlbiBvZiBvbmUgRE9NIGVsZW1lbnQgdG8gYW5vdGhlciBET00gZWxlbWVudFxuICovXG5mdW5jdGlvbiBtb3ZlQ2hpbGRyZW4oZnJvbUVsLCB0b0VsKSB7XG4gICAgdmFyIGN1ckNoaWxkID0gZnJvbUVsLmZpcnN0Q2hpbGQ7XG4gICAgd2hpbGUgKGN1ckNoaWxkKSB7XG4gICAgICAgIHZhciBuZXh0Q2hpbGQgPSBjdXJDaGlsZC5uZXh0U2libGluZztcbiAgICAgICAgdG9FbC5hcHBlbmRDaGlsZChjdXJDaGlsZCk7XG4gICAgICAgIGN1ckNoaWxkID0gbmV4dENoaWxkO1xuICAgIH1cbiAgICByZXR1cm4gdG9FbDtcbn1cblxuZnVuY3Rpb24gc3luY0Jvb2xlYW5BdHRyUHJvcChmcm9tRWwsIHRvRWwsIG5hbWUpIHtcbiAgICBpZiAoZnJvbUVsW25hbWVdICE9PSB0b0VsW25hbWVdKSB7XG4gICAgICAgIGZyb21FbFtuYW1lXSA9IHRvRWxbbmFtZV07XG4gICAgICAgIGlmIChmcm9tRWxbbmFtZV0pIHtcbiAgICAgICAgICAgIGZyb21FbC5zZXRBdHRyaWJ1dGUobmFtZSwgJycpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZnJvbUVsLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxudmFyIHNwZWNpYWxFbEhhbmRsZXJzID0ge1xuICAgIE9QVElPTjogZnVuY3Rpb24oZnJvbUVsLCB0b0VsKSB7XG4gICAgICAgIHZhciBwYXJlbnROb2RlID0gZnJvbUVsLnBhcmVudE5vZGU7XG4gICAgICAgIGlmIChwYXJlbnROb2RlKSB7XG4gICAgICAgICAgICB2YXIgcGFyZW50TmFtZSA9IHBhcmVudE5vZGUubm9kZU5hbWUudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgIGlmIChwYXJlbnROYW1lID09PSAnT1BUR1JPVVAnKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50Tm9kZSA9IHBhcmVudE5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICBwYXJlbnROYW1lID0gcGFyZW50Tm9kZSAmJiBwYXJlbnROb2RlLm5vZGVOYW1lLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFyZW50TmFtZSA9PT0gJ1NFTEVDVCcgJiYgIXBhcmVudE5vZGUuaGFzQXR0cmlidXRlKCdtdWx0aXBsZScpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZyb21FbC5oYXNBdHRyaWJ1dGUoJ3NlbGVjdGVkJykgJiYgIXRvRWwuc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV29ya2Fyb3VuZCBmb3IgTVMgRWRnZSBidWcgd2hlcmUgdGhlICdzZWxlY3RlZCcgYXR0cmlidXRlIGNhbiBvbmx5IGJlXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZWQgaWYgc2V0IHRvIGEgbm9uLWVtcHR5IHZhbHVlOlxuICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5taWNyb3NvZnQuY29tL2VuLXVzL21pY3Jvc29mdC1lZGdlL3BsYXRmb3JtL2lzc3Vlcy8xMjA4NzY3OS9cbiAgICAgICAgICAgICAgICAgICAgZnJvbUVsLnNldEF0dHJpYnV0ZSgnc2VsZWN0ZWQnLCAnc2VsZWN0ZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgZnJvbUVsLnJlbW92ZUF0dHJpYnV0ZSgnc2VsZWN0ZWQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gV2UgaGF2ZSB0byByZXNldCBzZWxlY3QgZWxlbWVudCdzIHNlbGVjdGVkSW5kZXggdG8gLTEsIG90aGVyd2lzZSBzZXR0aW5nXG4gICAgICAgICAgICAgICAgLy8gZnJvbUVsLnNlbGVjdGVkIHVzaW5nIHRoZSBzeW5jQm9vbGVhbkF0dHJQcm9wIGJlbG93IGhhcyBubyBlZmZlY3QuXG4gICAgICAgICAgICAgICAgLy8gVGhlIGNvcnJlY3Qgc2VsZWN0ZWRJbmRleCB3aWxsIGJlIHNldCBpbiB0aGUgU0VMRUNUIHNwZWNpYWwgaGFuZGxlciBiZWxvdy5cbiAgICAgICAgICAgICAgICBwYXJlbnROb2RlLnNlbGVjdGVkSW5kZXggPSAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzeW5jQm9vbGVhbkF0dHJQcm9wKGZyb21FbCwgdG9FbCwgJ3NlbGVjdGVkJyk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUaGUgXCJ2YWx1ZVwiIGF0dHJpYnV0ZSBpcyBzcGVjaWFsIGZvciB0aGUgPGlucHV0PiBlbGVtZW50IHNpbmNlIGl0IHNldHNcbiAgICAgKiB0aGUgaW5pdGlhbCB2YWx1ZS4gQ2hhbmdpbmcgdGhlIFwidmFsdWVcIiBhdHRyaWJ1dGUgd2l0aG91dCBjaGFuZ2luZyB0aGVcbiAgICAgKiBcInZhbHVlXCIgcHJvcGVydHkgd2lsbCBoYXZlIG5vIGVmZmVjdCBzaW5jZSBpdCBpcyBvbmx5IHVzZWQgdG8gdGhlIHNldCB0aGVcbiAgICAgKiBpbml0aWFsIHZhbHVlLiAgU2ltaWxhciBmb3IgdGhlIFwiY2hlY2tlZFwiIGF0dHJpYnV0ZSwgYW5kIFwiZGlzYWJsZWRcIi5cbiAgICAgKi9cbiAgICBJTlBVVDogZnVuY3Rpb24oZnJvbUVsLCB0b0VsKSB7XG4gICAgICAgIHN5bmNCb29sZWFuQXR0clByb3AoZnJvbUVsLCB0b0VsLCAnY2hlY2tlZCcpO1xuICAgICAgICBzeW5jQm9vbGVhbkF0dHJQcm9wKGZyb21FbCwgdG9FbCwgJ2Rpc2FibGVkJyk7XG5cbiAgICAgICAgaWYgKGZyb21FbC52YWx1ZSAhPT0gdG9FbC52YWx1ZSkge1xuICAgICAgICAgICAgZnJvbUVsLnZhbHVlID0gdG9FbC52YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdG9FbC5oYXNBdHRyaWJ1dGUoJ3ZhbHVlJykpIHtcbiAgICAgICAgICAgIGZyb21FbC5yZW1vdmVBdHRyaWJ1dGUoJ3ZhbHVlJyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgVEVYVEFSRUE6IGZ1bmN0aW9uKGZyb21FbCwgdG9FbCkge1xuICAgICAgICB2YXIgbmV3VmFsdWUgPSB0b0VsLnZhbHVlO1xuICAgICAgICBpZiAoZnJvbUVsLnZhbHVlICE9PSBuZXdWYWx1ZSkge1xuICAgICAgICAgICAgZnJvbUVsLnZhbHVlID0gbmV3VmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZmlyc3RDaGlsZCA9IGZyb21FbC5maXJzdENoaWxkO1xuICAgICAgICBpZiAoZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgLy8gTmVlZGVkIGZvciBJRS4gQXBwYXJlbnRseSBJRSBzZXRzIHRoZSBwbGFjZWhvbGRlciBhcyB0aGVcbiAgICAgICAgICAgIC8vIG5vZGUgdmFsdWUgYW5kIHZpc2UgdmVyc2EuIFRoaXMgaWdub3JlcyBhbiBlbXB0eSB1cGRhdGUuXG4gICAgICAgICAgICB2YXIgb2xkVmFsdWUgPSBmaXJzdENoaWxkLm5vZGVWYWx1ZTtcblxuICAgICAgICAgICAgaWYgKG9sZFZhbHVlID09IG5ld1ZhbHVlIHx8ICghbmV3VmFsdWUgJiYgb2xkVmFsdWUgPT0gZnJvbUVsLnBsYWNlaG9sZGVyKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZmlyc3RDaGlsZC5ub2RlVmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgU0VMRUNUOiBmdW5jdGlvbihmcm9tRWwsIHRvRWwpIHtcbiAgICAgICAgaWYgKCF0b0VsLmhhc0F0dHJpYnV0ZSgnbXVsdGlwbGUnKSkge1xuICAgICAgICAgICAgdmFyIHNlbGVjdGVkSW5kZXggPSAtMTtcbiAgICAgICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgICAgIC8vIFdlIGhhdmUgdG8gbG9vcCB0aHJvdWdoIGNoaWxkcmVuIG9mIGZyb21FbCwgbm90IHRvRWwgc2luY2Ugbm9kZXMgY2FuIGJlIG1vdmVkXG4gICAgICAgICAgICAvLyBmcm9tIHRvRWwgdG8gZnJvbUVsIGRpcmVjdGx5IHdoZW4gbW9ycGhpbmcuXG4gICAgICAgICAgICAvLyBBdCB0aGUgdGltZSB0aGlzIHNwZWNpYWwgaGFuZGxlciBpcyBpbnZva2VkLCBhbGwgY2hpbGRyZW4gaGF2ZSBhbHJlYWR5IGJlZW4gbW9ycGhlZFxuICAgICAgICAgICAgLy8gYW5kIGFwcGVuZGVkIHRvIC8gcmVtb3ZlZCBmcm9tIGZyb21FbCwgc28gdXNpbmcgZnJvbUVsIGhlcmUgaXMgc2FmZSBhbmQgY29ycmVjdC5cbiAgICAgICAgICAgIHZhciBjdXJDaGlsZCA9IGZyb21FbC5maXJzdENoaWxkO1xuICAgICAgICAgICAgdmFyIG9wdGdyb3VwO1xuICAgICAgICAgICAgdmFyIG5vZGVOYW1lO1xuICAgICAgICAgICAgd2hpbGUoY3VyQ2hpbGQpIHtcbiAgICAgICAgICAgICAgICBub2RlTmFtZSA9IGN1ckNoaWxkLm5vZGVOYW1lICYmIGN1ckNoaWxkLm5vZGVOYW1lLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGVOYW1lID09PSAnT1BUR1JPVVAnKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGdyb3VwID0gY3VyQ2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgIGN1ckNoaWxkID0gb3B0Z3JvdXAuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZU5hbWUgPT09ICdPUFRJT04nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VyQ2hpbGQuaGFzQXR0cmlidXRlKCdzZWxlY3RlZCcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWRJbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY3VyQ2hpbGQgPSBjdXJDaGlsZC5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjdXJDaGlsZCAmJiBvcHRncm91cCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VyQ2hpbGQgPSBvcHRncm91cC5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGdyb3VwID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnJvbUVsLnNlbGVjdGVkSW5kZXggPSBzZWxlY3RlZEluZGV4O1xuICAgICAgICB9XG4gICAgfVxufTtcblxudmFyIEVMRU1FTlRfTk9ERSA9IDE7XG52YXIgRE9DVU1FTlRfRlJBR01FTlRfTk9ERSQxID0gMTE7XG52YXIgVEVYVF9OT0RFID0gMztcbnZhciBDT01NRU5UX05PREUgPSA4O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxuZnVuY3Rpb24gZGVmYXVsdEdldE5vZGVLZXkobm9kZSkge1xuICBpZiAobm9kZSkge1xuICAgICAgcmV0dXJuIChub2RlLmdldEF0dHJpYnV0ZSAmJiBub2RlLmdldEF0dHJpYnV0ZSgnaWQnKSkgfHwgbm9kZS5pZDtcbiAgfVxufVxuXG5mdW5jdGlvbiBtb3JwaGRvbUZhY3RvcnkobW9ycGhBdHRycykge1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1vcnBoZG9tKGZyb21Ob2RlLCB0b05vZGUsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHRvTm9kZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGlmIChmcm9tTm9kZS5ub2RlTmFtZSA9PT0gJyNkb2N1bWVudCcgfHwgZnJvbU5vZGUubm9kZU5hbWUgPT09ICdIVE1MJyB8fCBmcm9tTm9kZS5ub2RlTmFtZSA9PT0gJ0JPRFknKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRvTm9kZUh0bWwgPSB0b05vZGU7XG4gICAgICAgICAgICAgICAgdG9Ob2RlID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ2h0bWwnKTtcbiAgICAgICAgICAgICAgICB0b05vZGUuaW5uZXJIVE1MID0gdG9Ob2RlSHRtbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdG9Ob2RlID0gdG9FbGVtZW50KHRvTm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZ2V0Tm9kZUtleSA9IG9wdGlvbnMuZ2V0Tm9kZUtleSB8fCBkZWZhdWx0R2V0Tm9kZUtleTtcbiAgICAgICAgdmFyIG9uQmVmb3JlTm9kZUFkZGVkID0gb3B0aW9ucy5vbkJlZm9yZU5vZGVBZGRlZCB8fCBub29wO1xuICAgICAgICB2YXIgb25Ob2RlQWRkZWQgPSBvcHRpb25zLm9uTm9kZUFkZGVkIHx8IG5vb3A7XG4gICAgICAgIHZhciBvbkJlZm9yZUVsVXBkYXRlZCA9IG9wdGlvbnMub25CZWZvcmVFbFVwZGF0ZWQgfHwgbm9vcDtcbiAgICAgICAgdmFyIG9uRWxVcGRhdGVkID0gb3B0aW9ucy5vbkVsVXBkYXRlZCB8fCBub29wO1xuICAgICAgICB2YXIgb25CZWZvcmVOb2RlRGlzY2FyZGVkID0gb3B0aW9ucy5vbkJlZm9yZU5vZGVEaXNjYXJkZWQgfHwgbm9vcDtcbiAgICAgICAgdmFyIG9uTm9kZURpc2NhcmRlZCA9IG9wdGlvbnMub25Ob2RlRGlzY2FyZGVkIHx8IG5vb3A7XG4gICAgICAgIHZhciBvbkJlZm9yZUVsQ2hpbGRyZW5VcGRhdGVkID0gb3B0aW9ucy5vbkJlZm9yZUVsQ2hpbGRyZW5VcGRhdGVkIHx8IG5vb3A7XG4gICAgICAgIHZhciBjaGlsZHJlbk9ubHkgPSBvcHRpb25zLmNoaWxkcmVuT25seSA9PT0gdHJ1ZTtcblxuICAgICAgICAvLyBUaGlzIG9iamVjdCBpcyB1c2VkIGFzIGEgbG9va3VwIHRvIHF1aWNrbHkgZmluZCBhbGwga2V5ZWQgZWxlbWVudHMgaW4gdGhlIG9yaWdpbmFsIERPTSB0cmVlLlxuICAgICAgICB2YXIgZnJvbU5vZGVzTG9va3VwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgdmFyIGtleWVkUmVtb3ZhbExpc3QgPSBbXTtcblxuICAgICAgICBmdW5jdGlvbiBhZGRLZXllZFJlbW92YWwoa2V5KSB7XG4gICAgICAgICAgICBrZXllZFJlbW92YWxMaXN0LnB1c2goa2V5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHdhbGtEaXNjYXJkZWRDaGlsZE5vZGVzKG5vZGUsIHNraXBLZXllZE5vZGVzKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICAgICAgdmFyIGN1ckNoaWxkID0gbm9kZS5maXJzdENoaWxkO1xuICAgICAgICAgICAgICAgIHdoaWxlIChjdXJDaGlsZCkge1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNraXBLZXllZE5vZGVzICYmIChrZXkgPSBnZXROb2RlS2V5KGN1ckNoaWxkKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHdlIGFyZSBza2lwcGluZyBrZXllZCBub2RlcyB0aGVuIHdlIGFkZCB0aGUga2V5XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0byBhIGxpc3Qgc28gdGhhdCBpdCBjYW4gYmUgaGFuZGxlZCBhdCB0aGUgdmVyeSBlbmQuXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRLZXllZFJlbW92YWwoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9ubHkgcmVwb3J0IHRoZSBub2RlIGFzIGRpc2NhcmRlZCBpZiBpdCBpcyBub3Qga2V5ZWQuIFdlIGRvIHRoaXMgYmVjYXVzZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXQgdGhlIGVuZCB3ZSBsb29wIHRocm91Z2ggYWxsIGtleWVkIGVsZW1lbnRzIHRoYXQgd2VyZSB1bm1hdGNoZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFuZCB0aGVuIGRpc2NhcmQgdGhlbSBpbiBvbmUgZmluYWwgcGFzcy5cbiAgICAgICAgICAgICAgICAgICAgICAgIG9uTm9kZURpc2NhcmRlZChjdXJDaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VyQ2hpbGQuZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhbGtEaXNjYXJkZWRDaGlsZE5vZGVzKGN1ckNoaWxkLCBza2lwS2V5ZWROb2Rlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjdXJDaGlsZCA9IGN1ckNoaWxkLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdmVzIGEgRE9NIG5vZGUgb3V0IG9mIHRoZSBvcmlnaW5hbCBET01cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtICB7Tm9kZX0gbm9kZSBUaGUgbm9kZSB0byByZW1vdmVcbiAgICAgICAgICogQHBhcmFtICB7Tm9kZX0gcGFyZW50Tm9kZSBUaGUgbm9kZXMgcGFyZW50XG4gICAgICAgICAqIEBwYXJhbSAge0Jvb2xlYW59IHNraXBLZXllZE5vZGVzIElmIHRydWUgdGhlbiBlbGVtZW50cyB3aXRoIGtleXMgd2lsbCBiZSBza2lwcGVkIGFuZCBub3QgZGlzY2FyZGVkLlxuICAgICAgICAgKiBAcmV0dXJuIHt1bmRlZmluZWR9XG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiByZW1vdmVOb2RlKG5vZGUsIHBhcmVudE5vZGUsIHNraXBLZXllZE5vZGVzKSB7XG4gICAgICAgICAgICBpZiAob25CZWZvcmVOb2RlRGlzY2FyZGVkKG5vZGUpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICBwYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvbk5vZGVEaXNjYXJkZWQobm9kZSk7XG4gICAgICAgICAgICB3YWxrRGlzY2FyZGVkQ2hpbGROb2Rlcyhub2RlLCBza2lwS2V5ZWROb2Rlcyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyAvLyBUcmVlV2Fsa2VyIGltcGxlbWVudGF0aW9uIGlzIG5vIGZhc3RlciwgYnV0IGtlZXBpbmcgdGhpcyBhcm91bmQgaW4gY2FzZSB0aGlzIGNoYW5nZXMgaW4gdGhlIGZ1dHVyZVxuICAgICAgICAvLyBmdW5jdGlvbiBpbmRleFRyZWUocm9vdCkge1xuICAgICAgICAvLyAgICAgdmFyIHRyZWVXYWxrZXIgPSBkb2N1bWVudC5jcmVhdGVUcmVlV2Fsa2VyKFxuICAgICAgICAvLyAgICAgICAgIHJvb3QsXG4gICAgICAgIC8vICAgICAgICAgTm9kZUZpbHRlci5TSE9XX0VMRU1FTlQpO1xuICAgICAgICAvL1xuICAgICAgICAvLyAgICAgdmFyIGVsO1xuICAgICAgICAvLyAgICAgd2hpbGUoKGVsID0gdHJlZVdhbGtlci5uZXh0Tm9kZSgpKSkge1xuICAgICAgICAvLyAgICAgICAgIHZhciBrZXkgPSBnZXROb2RlS2V5KGVsKTtcbiAgICAgICAgLy8gICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgIC8vICAgICAgICAgICAgIGZyb21Ob2Rlc0xvb2t1cFtrZXldID0gZWw7XG4gICAgICAgIC8vICAgICAgICAgfVxuICAgICAgICAvLyAgICAgfVxuICAgICAgICAvLyB9XG5cbiAgICAgICAgLy8gLy8gTm9kZUl0ZXJhdG9yIGltcGxlbWVudGF0aW9uIGlzIG5vIGZhc3RlciwgYnV0IGtlZXBpbmcgdGhpcyBhcm91bmQgaW4gY2FzZSB0aGlzIGNoYW5nZXMgaW4gdGhlIGZ1dHVyZVxuICAgICAgICAvL1xuICAgICAgICAvLyBmdW5jdGlvbiBpbmRleFRyZWUobm9kZSkge1xuICAgICAgICAvLyAgICAgdmFyIG5vZGVJdGVyYXRvciA9IGRvY3VtZW50LmNyZWF0ZU5vZGVJdGVyYXRvcihub2RlLCBOb2RlRmlsdGVyLlNIT1dfRUxFTUVOVCk7XG4gICAgICAgIC8vICAgICB2YXIgZWw7XG4gICAgICAgIC8vICAgICB3aGlsZSgoZWwgPSBub2RlSXRlcmF0b3IubmV4dE5vZGUoKSkpIHtcbiAgICAgICAgLy8gICAgICAgICB2YXIga2V5ID0gZ2V0Tm9kZUtleShlbCk7XG4gICAgICAgIC8vICAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAvLyAgICAgICAgICAgICBmcm9tTm9kZXNMb29rdXBba2V5XSA9IGVsO1xuICAgICAgICAvLyAgICAgICAgIH1cbiAgICAgICAgLy8gICAgIH1cbiAgICAgICAgLy8gfVxuXG4gICAgICAgIGZ1bmN0aW9uIGluZGV4VHJlZShub2RlKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFIHx8IG5vZGUubm9kZVR5cGUgPT09IERPQ1VNRU5UX0ZSQUdNRU5UX05PREUkMSkge1xuICAgICAgICAgICAgICAgIHZhciBjdXJDaGlsZCA9IG5vZGUuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoY3VyQ2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGtleSA9IGdldE5vZGVLZXkoY3VyQ2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmcm9tTm9kZXNMb29rdXBba2V5XSA9IGN1ckNoaWxkO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gV2FsayByZWN1cnNpdmVseVxuICAgICAgICAgICAgICAgICAgICBpbmRleFRyZWUoY3VyQ2hpbGQpO1xuXG4gICAgICAgICAgICAgICAgICAgIGN1ckNoaWxkID0gY3VyQ2hpbGQubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaW5kZXhUcmVlKGZyb21Ob2RlKTtcblxuICAgICAgICBmdW5jdGlvbiBoYW5kbGVOb2RlQWRkZWQoZWwpIHtcbiAgICAgICAgICAgIG9uTm9kZUFkZGVkKGVsKTtcblxuICAgICAgICAgICAgdmFyIGN1ckNoaWxkID0gZWwuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIHdoaWxlIChjdXJDaGlsZCkge1xuICAgICAgICAgICAgICAgIHZhciBuZXh0U2libGluZyA9IGN1ckNoaWxkLm5leHRTaWJsaW5nO1xuXG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IGdldE5vZGVLZXkoY3VyQ2hpbGQpO1xuICAgICAgICAgICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHVubWF0Y2hlZEZyb21FbCA9IGZyb21Ob2Rlc0xvb2t1cFtrZXldO1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiB3ZSBmaW5kIGEgZHVwbGljYXRlICNpZCBub2RlIGluIGNhY2hlLCByZXBsYWNlIGBlbGAgd2l0aCBjYWNoZSB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAvLyBhbmQgbW9ycGggaXQgdG8gdGhlIGNoaWxkIG5vZGUuXG4gICAgICAgICAgICAgICAgICAgIGlmICh1bm1hdGNoZWRGcm9tRWwgJiYgY29tcGFyZU5vZGVOYW1lcyhjdXJDaGlsZCwgdW5tYXRjaGVkRnJvbUVsKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VyQ2hpbGQucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQodW5tYXRjaGVkRnJvbUVsLCBjdXJDaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb3JwaEVsKHVubWF0Y2hlZEZyb21FbCwgY3VyQ2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZU5vZGVBZGRlZChjdXJDaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgLy8gcmVjdXJzaXZlbHkgY2FsbCBmb3IgY3VyQ2hpbGQgYW5kIGl0J3MgY2hpbGRyZW4gdG8gc2VlIGlmIHdlIGZpbmQgc29tZXRoaW5nIGluXG4gICAgICAgICAgICAgICAgICAvLyBmcm9tTm9kZXNMb29rdXBcbiAgICAgICAgICAgICAgICAgIGhhbmRsZU5vZGVBZGRlZChjdXJDaGlsZCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY3VyQ2hpbGQgPSBuZXh0U2libGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGNsZWFudXBGcm9tRWwoZnJvbUVsLCBjdXJGcm9tTm9kZUNoaWxkLCBjdXJGcm9tTm9kZUtleSkge1xuICAgICAgICAgICAgLy8gV2UgaGF2ZSBwcm9jZXNzZWQgYWxsIG9mIHRoZSBcInRvIG5vZGVzXCIuIElmIGN1ckZyb21Ob2RlQ2hpbGQgaXNcbiAgICAgICAgICAgIC8vIG5vbi1udWxsIHRoZW4gd2Ugc3RpbGwgaGF2ZSBzb21lIGZyb20gbm9kZXMgbGVmdCBvdmVyIHRoYXQgbmVlZFxuICAgICAgICAgICAgLy8gdG8gYmUgcmVtb3ZlZFxuICAgICAgICAgICAgd2hpbGUgKGN1ckZyb21Ob2RlQ2hpbGQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZnJvbU5leHRTaWJsaW5nID0gY3VyRnJvbU5vZGVDaGlsZC5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICBpZiAoKGN1ckZyb21Ob2RlS2V5ID0gZ2V0Tm9kZUtleShjdXJGcm9tTm9kZUNoaWxkKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2luY2UgdGhlIG5vZGUgaXMga2V5ZWQgaXQgbWlnaHQgYmUgbWF0Y2hlZCB1cCBsYXRlciBzbyB3ZSBkZWZlclxuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgYWN0dWFsIHJlbW92YWwgdG8gbGF0ZXJcbiAgICAgICAgICAgICAgICAgICAgYWRkS2V5ZWRSZW1vdmFsKGN1ckZyb21Ob2RlS2V5KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBOT1RFOiB3ZSBza2lwIG5lc3RlZCBrZXllZCBub2RlcyBmcm9tIGJlaW5nIHJlbW92ZWQgc2luY2UgdGhlcmUgaXNcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgc3RpbGwgYSBjaGFuY2UgdGhleSB3aWxsIGJlIG1hdGNoZWQgdXAgbGF0ZXJcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlTm9kZShjdXJGcm9tTm9kZUNoaWxkLCBmcm9tRWwsIHRydWUgLyogc2tpcCBrZXllZCBub2RlcyAqLyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN1ckZyb21Ob2RlQ2hpbGQgPSBmcm9tTmV4dFNpYmxpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBtb3JwaEVsKGZyb21FbCwgdG9FbCwgY2hpbGRyZW5Pbmx5KSB7XG4gICAgICAgICAgICB2YXIgdG9FbEtleSA9IGdldE5vZGVLZXkodG9FbCk7XG5cbiAgICAgICAgICAgIGlmICh0b0VsS2V5KSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgYW4gZWxlbWVudCB3aXRoIGFuIElEIGlzIGJlaW5nIG1vcnBoZWQgdGhlbiBpdCB3aWxsIGJlIGluIHRoZSBmaW5hbFxuICAgICAgICAgICAgICAgIC8vIERPTSBzbyBjbGVhciBpdCBvdXQgb2YgdGhlIHNhdmVkIGVsZW1lbnRzIGNvbGxlY3Rpb25cbiAgICAgICAgICAgICAgICBkZWxldGUgZnJvbU5vZGVzTG9va3VwW3RvRWxLZXldO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWNoaWxkcmVuT25seSkge1xuICAgICAgICAgICAgICAgIC8vIG9wdGlvbmFsXG4gICAgICAgICAgICAgICAgaWYgKG9uQmVmb3JlRWxVcGRhdGVkKGZyb21FbCwgdG9FbCkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyB1cGRhdGUgYXR0cmlidXRlcyBvbiBvcmlnaW5hbCBET00gZWxlbWVudCBmaXJzdFxuICAgICAgICAgICAgICAgIG1vcnBoQXR0cnMoZnJvbUVsLCB0b0VsKTtcbiAgICAgICAgICAgICAgICAvLyBvcHRpb25hbFxuICAgICAgICAgICAgICAgIG9uRWxVcGRhdGVkKGZyb21FbCk7XG5cbiAgICAgICAgICAgICAgICBpZiAob25CZWZvcmVFbENoaWxkcmVuVXBkYXRlZChmcm9tRWwsIHRvRWwpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZnJvbUVsLm5vZGVOYW1lICE9PSAnVEVYVEFSRUEnKSB7XG4gICAgICAgICAgICAgIG1vcnBoQ2hpbGRyZW4oZnJvbUVsLCB0b0VsKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHNwZWNpYWxFbEhhbmRsZXJzLlRFWFRBUkVBKGZyb21FbCwgdG9FbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBtb3JwaENoaWxkcmVuKGZyb21FbCwgdG9FbCkge1xuICAgICAgICAgICAgdmFyIGN1clRvTm9kZUNoaWxkID0gdG9FbC5maXJzdENoaWxkO1xuICAgICAgICAgICAgdmFyIGN1ckZyb21Ob2RlQ2hpbGQgPSBmcm9tRWwuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIHZhciBjdXJUb05vZGVLZXk7XG4gICAgICAgICAgICB2YXIgY3VyRnJvbU5vZGVLZXk7XG5cbiAgICAgICAgICAgIHZhciBmcm9tTmV4dFNpYmxpbmc7XG4gICAgICAgICAgICB2YXIgdG9OZXh0U2libGluZztcbiAgICAgICAgICAgIHZhciBtYXRjaGluZ0Zyb21FbDtcblxuICAgICAgICAgICAgLy8gd2FsayB0aGUgY2hpbGRyZW5cbiAgICAgICAgICAgIG91dGVyOiB3aGlsZSAoY3VyVG9Ob2RlQ2hpbGQpIHtcbiAgICAgICAgICAgICAgICB0b05leHRTaWJsaW5nID0gY3VyVG9Ob2RlQ2hpbGQubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgY3VyVG9Ob2RlS2V5ID0gZ2V0Tm9kZUtleShjdXJUb05vZGVDaGlsZCk7XG5cbiAgICAgICAgICAgICAgICAvLyB3YWxrIHRoZSBmcm9tTm9kZSBjaGlsZHJlbiBhbGwgdGhlIHdheSB0aHJvdWdoXG4gICAgICAgICAgICAgICAgd2hpbGUgKGN1ckZyb21Ob2RlQ2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgZnJvbU5leHRTaWJsaW5nID0gY3VyRnJvbU5vZGVDaGlsZC5uZXh0U2libGluZztcblxuICAgICAgICAgICAgICAgICAgICBpZiAoY3VyVG9Ob2RlQ2hpbGQuaXNTYW1lTm9kZSAmJiBjdXJUb05vZGVDaGlsZC5pc1NhbWVOb2RlKGN1ckZyb21Ob2RlQ2hpbGQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJUb05vZGVDaGlsZCA9IHRvTmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJGcm9tTm9kZUNoaWxkID0gZnJvbU5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWUgb3V0ZXI7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjdXJGcm9tTm9kZUtleSA9IGdldE5vZGVLZXkoY3VyRnJvbU5vZGVDaGlsZCk7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGN1ckZyb21Ob2RlVHlwZSA9IGN1ckZyb21Ob2RlQ2hpbGQubm9kZVR5cGU7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBtZWFucyBpZiB0aGUgY3VyRnJvbU5vZGVDaGlsZCBkb2VzbnQgaGF2ZSBhIG1hdGNoIHdpdGggdGhlIGN1clRvTm9kZUNoaWxkXG4gICAgICAgICAgICAgICAgICAgIHZhciBpc0NvbXBhdGlibGUgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1ckZyb21Ob2RlVHlwZSA9PT0gY3VyVG9Ob2RlQ2hpbGQubm9kZVR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJGcm9tTm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJvdGggbm9kZXMgYmVpbmcgY29tcGFyZWQgYXJlIEVsZW1lbnQgbm9kZXNcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJUb05vZGVLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHRhcmdldCBub2RlIGhhcyBhIGtleSBzbyB3ZSB3YW50IHRvIG1hdGNoIGl0IHVwIHdpdGggdGhlIGNvcnJlY3QgZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbiB0aGUgb3JpZ2luYWwgRE9NIHRyZWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1clRvTm9kZUtleSAhPT0gY3VyRnJvbU5vZGVLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBjdXJyZW50IGVsZW1lbnQgaW4gdGhlIG9yaWdpbmFsIERPTSB0cmVlIGRvZXMgbm90IGhhdmUgYSBtYXRjaGluZyBrZXkgc29cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGxldCdzIGNoZWNrIG91ciBsb29rdXAgdG8gc2VlIGlmIHRoZXJlIGlzIGEgbWF0Y2hpbmcgZWxlbWVudCBpbiB0aGUgb3JpZ2luYWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERPTSB0cmVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKG1hdGNoaW5nRnJvbUVsID0gZnJvbU5vZGVzTG9va3VwW2N1clRvTm9kZUtleV0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZyb21OZXh0U2libGluZyA9PT0gbWF0Y2hpbmdGcm9tRWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3BlY2lhbCBjYXNlIGZvciBzaW5nbGUgZWxlbWVudCByZW1vdmFscy4gVG8gYXZvaWQgcmVtb3ZpbmcgdGhlIG9yaWdpbmFsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERPTSBub2RlIG91dCBvZiB0aGUgdHJlZSAoc2luY2UgdGhhdCBjYW4gYnJlYWsgQ1NTIHRyYW5zaXRpb25zLCBldGMuKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2Ugd2lsbCBpbnN0ZWFkIGRpc2NhcmQgdGhlIGN1cnJlbnQgbm9kZSBhbmQgd2FpdCB1bnRpbCB0aGUgbmV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpdGVyYXRpb24gdG8gcHJvcGVybHkgbWF0Y2ggdXAgdGhlIGtleWVkIHRhcmdldCBlbGVtZW50IHdpdGggaXRzIG1hdGNoaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVsZW1lbnQgaW4gdGhlIG9yaWdpbmFsIHRyZWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNDb21wYXRpYmxlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgZm91bmQgYSBtYXRjaGluZyBrZXllZCBlbGVtZW50IHNvbWV3aGVyZSBpbiB0aGUgb3JpZ2luYWwgRE9NIHRyZWUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIExldCdzIG1vdmUgdGhlIG9yaWdpbmFsIERPTSBub2RlIGludG8gdGhlIGN1cnJlbnQgcG9zaXRpb24gYW5kIG1vcnBoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGl0LlxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5PVEU6IFdlIHVzZSBpbnNlcnRCZWZvcmUgaW5zdGVhZCBvZiByZXBsYWNlQ2hpbGQgYmVjYXVzZSB3ZSB3YW50IHRvIGdvIHRocm91Z2hcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGByZW1vdmVOb2RlKClgIGZ1bmN0aW9uIGZvciB0aGUgbm9kZSB0aGF0IGlzIGJlaW5nIGRpc2NhcmRlZCBzbyB0aGF0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFsbCBsaWZlY3ljbGUgaG9va3MgYXJlIGNvcnJlY3RseSBpbnZva2VkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb21FbC5pbnNlcnRCZWZvcmUobWF0Y2hpbmdGcm9tRWwsIGN1ckZyb21Ob2RlQ2hpbGQpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZyb21OZXh0U2libGluZyA9IGN1ckZyb21Ob2RlQ2hpbGQubmV4dFNpYmxpbmc7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1ckZyb21Ob2RlS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTaW5jZSB0aGUgbm9kZSBpcyBrZXllZCBpdCBtaWdodCBiZSBtYXRjaGVkIHVwIGxhdGVyIHNvIHdlIGRlZmVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgYWN0dWFsIHJlbW92YWwgdG8gbGF0ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZEtleWVkUmVtb3ZhbChjdXJGcm9tTm9kZUtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOT1RFOiB3ZSBza2lwIG5lc3RlZCBrZXllZCBub2RlcyBmcm9tIGJlaW5nIHJlbW92ZWQgc2luY2UgdGhlcmUgaXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICAgIHN0aWxsIGEgY2hhbmNlIHRoZXkgd2lsbCBiZSBtYXRjaGVkIHVwIGxhdGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVOb2RlKGN1ckZyb21Ob2RlQ2hpbGQsIGZyb21FbCwgdHJ1ZSAvKiBza2lwIGtleWVkIG5vZGVzICovKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1ckZyb21Ob2RlQ2hpbGQgPSBtYXRjaGluZ0Zyb21FbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBub2RlcyBhcmUgbm90IGNvbXBhdGlibGUgc2luY2UgdGhlIFwidG9cIiBub2RlIGhhcyBhIGtleSBhbmQgdGhlcmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpcyBubyBtYXRjaGluZyBrZXllZCBub2RlIGluIHRoZSBzb3VyY2UgdHJlZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzQ29tcGF0aWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjdXJGcm9tTm9kZUtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgb3JpZ2luYWwgaGFzIGEga2V5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzQ29tcGF0aWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzQ29tcGF0aWJsZSA9IGlzQ29tcGF0aWJsZSAhPT0gZmFsc2UgJiYgY29tcGFyZU5vZGVOYW1lcyhjdXJGcm9tTm9kZUNoaWxkLCBjdXJUb05vZGVDaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzQ29tcGF0aWJsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBmb3VuZCBjb21wYXRpYmxlIERPTSBlbGVtZW50cyBzbyB0cmFuc2Zvcm1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGN1cnJlbnQgXCJmcm9tXCIgbm9kZSB0byBtYXRjaCB0aGUgY3VycmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0YXJnZXQgRE9NIG5vZGUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1PUlBIXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vcnBoRWwoY3VyRnJvbU5vZGVDaGlsZCwgY3VyVG9Ob2RlQ2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjdXJGcm9tTm9kZVR5cGUgPT09IFRFWFRfTk9ERSB8fCBjdXJGcm9tTm9kZVR5cGUgPT0gQ09NTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQm90aCBub2RlcyBiZWluZyBjb21wYXJlZCBhcmUgVGV4dCBvciBDb21tZW50IG5vZGVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNDb21wYXRpYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTaW1wbHkgdXBkYXRlIG5vZGVWYWx1ZSBvbiB0aGUgb3JpZ2luYWwgbm9kZSB0b1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNoYW5nZSB0aGUgdGV4dCB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJGcm9tTm9kZUNoaWxkLm5vZGVWYWx1ZSAhPT0gY3VyVG9Ob2RlQ2hpbGQubm9kZVZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1ckZyb21Ob2RlQ2hpbGQubm9kZVZhbHVlID0gY3VyVG9Ob2RlQ2hpbGQubm9kZVZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzQ29tcGF0aWJsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWR2YW5jZSBib3RoIHRoZSBcInRvXCIgY2hpbGQgYW5kIHRoZSBcImZyb21cIiBjaGlsZCBzaW5jZSB3ZSBmb3VuZCBhIG1hdGNoXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOb3RoaW5nIGVsc2UgdG8gZG8gYXMgd2UgYWxyZWFkeSByZWN1cnNpdmVseSBjYWxsZWQgbW9ycGhDaGlsZHJlbiBhYm92ZVxuICAgICAgICAgICAgICAgICAgICAgICAgY3VyVG9Ob2RlQ2hpbGQgPSB0b05leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VyRnJvbU5vZGVDaGlsZCA9IGZyb21OZXh0U2libGluZztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIG91dGVyO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gTm8gY29tcGF0aWJsZSBtYXRjaCBzbyByZW1vdmUgdGhlIG9sZCBub2RlIGZyb20gdGhlIERPTSBhbmQgY29udGludWUgdHJ5aW5nIHRvIGZpbmQgYVxuICAgICAgICAgICAgICAgICAgICAvLyBtYXRjaCBpbiB0aGUgb3JpZ2luYWwgRE9NLiBIb3dldmVyLCB3ZSBvbmx5IGRvIHRoaXMgaWYgdGhlIGZyb20gbm9kZSBpcyBub3Qga2V5ZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gc2luY2UgaXQgaXMgcG9zc2libGUgdGhhdCBhIGtleWVkIG5vZGUgbWlnaHQgbWF0Y2ggdXAgd2l0aCBhIG5vZGUgc29tZXdoZXJlIGVsc2UgaW4gdGhlXG4gICAgICAgICAgICAgICAgICAgIC8vIHRhcmdldCB0cmVlIGFuZCB3ZSBkb24ndCB3YW50IHRvIGRpc2NhcmQgaXQganVzdCB5ZXQgc2luY2UgaXQgc3RpbGwgbWlnaHQgZmluZCBhXG4gICAgICAgICAgICAgICAgICAgIC8vIGhvbWUgaW4gdGhlIGZpbmFsIERPTSB0cmVlLiBBZnRlciBldmVyeXRoaW5nIGlzIGRvbmUgd2Ugd2lsbCByZW1vdmUgYW55IGtleWVkIG5vZGVzXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoYXQgZGlkbid0IGZpbmQgYSBob21lXG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJGcm9tTm9kZUtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2luY2UgdGhlIG5vZGUgaXMga2V5ZWQgaXQgbWlnaHQgYmUgbWF0Y2hlZCB1cCBsYXRlciBzbyB3ZSBkZWZlclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGFjdHVhbCByZW1vdmFsIHRvIGxhdGVyXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRLZXllZFJlbW92YWwoY3VyRnJvbU5vZGVLZXkpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTk9URTogd2Ugc2tpcCBuZXN0ZWQga2V5ZWQgbm9kZXMgZnJvbSBiZWluZyByZW1vdmVkIHNpbmNlIHRoZXJlIGlzXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgICBzdGlsbCBhIGNoYW5jZSB0aGV5IHdpbGwgYmUgbWF0Y2hlZCB1cCBsYXRlclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlTm9kZShjdXJGcm9tTm9kZUNoaWxkLCBmcm9tRWwsIHRydWUgLyogc2tpcCBrZXllZCBub2RlcyAqLyk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjdXJGcm9tTm9kZUNoaWxkID0gZnJvbU5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgIH0gLy8gRU5EOiB3aGlsZShjdXJGcm9tTm9kZUNoaWxkKSB7fVxuXG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgZ290IHRoaXMgZmFyIHRoZW4gd2UgZGlkIG5vdCBmaW5kIGEgY2FuZGlkYXRlIG1hdGNoIGZvclxuICAgICAgICAgICAgICAgIC8vIG91ciBcInRvIG5vZGVcIiBhbmQgd2UgZXhoYXVzdGVkIGFsbCBvZiB0aGUgY2hpbGRyZW4gXCJmcm9tXCJcbiAgICAgICAgICAgICAgICAvLyBub2Rlcy4gVGhlcmVmb3JlLCB3ZSB3aWxsIGp1c3QgYXBwZW5kIHRoZSBjdXJyZW50IFwidG9cIiBub2RlXG4gICAgICAgICAgICAgICAgLy8gdG8gdGhlIGVuZFxuICAgICAgICAgICAgICAgIGlmIChjdXJUb05vZGVLZXkgJiYgKG1hdGNoaW5nRnJvbUVsID0gZnJvbU5vZGVzTG9va3VwW2N1clRvTm9kZUtleV0pICYmIGNvbXBhcmVOb2RlTmFtZXMobWF0Y2hpbmdGcm9tRWwsIGN1clRvTm9kZUNoaWxkKSkge1xuICAgICAgICAgICAgICAgICAgICBmcm9tRWwuYXBwZW5kQ2hpbGQobWF0Y2hpbmdGcm9tRWwpO1xuICAgICAgICAgICAgICAgICAgICAvLyBNT1JQSFxuICAgICAgICAgICAgICAgICAgICBtb3JwaEVsKG1hdGNoaW5nRnJvbUVsLCBjdXJUb05vZGVDaGlsZCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9uQmVmb3JlTm9kZUFkZGVkUmVzdWx0ID0gb25CZWZvcmVOb2RlQWRkZWQoY3VyVG9Ob2RlQ2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAob25CZWZvcmVOb2RlQWRkZWRSZXN1bHQgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob25CZWZvcmVOb2RlQWRkZWRSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJUb05vZGVDaGlsZCA9IG9uQmVmb3JlTm9kZUFkZGVkUmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VyVG9Ob2RlQ2hpbGQuYWN0dWFsaXplKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VyVG9Ob2RlQ2hpbGQgPSBjdXJUb05vZGVDaGlsZC5hY3R1YWxpemUoZnJvbUVsLm93bmVyRG9jdW1lbnQgfHwgZG9jKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGZyb21FbC5hcHBlbmRDaGlsZChjdXJUb05vZGVDaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVOb2RlQWRkZWQoY3VyVG9Ob2RlQ2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY3VyVG9Ob2RlQ2hpbGQgPSB0b05leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgIGN1ckZyb21Ob2RlQ2hpbGQgPSBmcm9tTmV4dFNpYmxpbmc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNsZWFudXBGcm9tRWwoZnJvbUVsLCBjdXJGcm9tTm9kZUNoaWxkLCBjdXJGcm9tTm9kZUtleSk7XG5cbiAgICAgICAgICAgIHZhciBzcGVjaWFsRWxIYW5kbGVyID0gc3BlY2lhbEVsSGFuZGxlcnNbZnJvbUVsLm5vZGVOYW1lXTtcbiAgICAgICAgICAgIGlmIChzcGVjaWFsRWxIYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgc3BlY2lhbEVsSGFuZGxlcihmcm9tRWwsIHRvRWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IC8vIEVORDogbW9ycGhDaGlsZHJlbiguLi4pXG5cbiAgICAgICAgdmFyIG1vcnBoZWROb2RlID0gZnJvbU5vZGU7XG4gICAgICAgIHZhciBtb3JwaGVkTm9kZVR5cGUgPSBtb3JwaGVkTm9kZS5ub2RlVHlwZTtcbiAgICAgICAgdmFyIHRvTm9kZVR5cGUgPSB0b05vZGUubm9kZVR5cGU7XG5cbiAgICAgICAgaWYgKCFjaGlsZHJlbk9ubHkpIHtcbiAgICAgICAgICAgIC8vIEhhbmRsZSB0aGUgY2FzZSB3aGVyZSB3ZSBhcmUgZ2l2ZW4gdHdvIERPTSBub2RlcyB0aGF0IGFyZSBub3RcbiAgICAgICAgICAgIC8vIGNvbXBhdGlibGUgKGUuZy4gPGRpdj4gLS0+IDxzcGFuPiBvciA8ZGl2PiAtLT4gVEVYVClcbiAgICAgICAgICAgIGlmIChtb3JwaGVkTm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgICAgIGlmICh0b05vZGVUeXBlID09PSBFTEVNRU5UX05PREUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjb21wYXJlTm9kZU5hbWVzKGZyb21Ob2RlLCB0b05vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbk5vZGVEaXNjYXJkZWQoZnJvbU5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9ycGhlZE5vZGUgPSBtb3ZlQ2hpbGRyZW4oZnJvbU5vZGUsIGNyZWF0ZUVsZW1lbnROUyh0b05vZGUubm9kZU5hbWUsIHRvTm9kZS5uYW1lc3BhY2VVUkkpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEdvaW5nIGZyb20gYW4gZWxlbWVudCBub2RlIHRvIGEgdGV4dCBub2RlXG4gICAgICAgICAgICAgICAgICAgIG1vcnBoZWROb2RlID0gdG9Ob2RlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAobW9ycGhlZE5vZGVUeXBlID09PSBURVhUX05PREUgfHwgbW9ycGhlZE5vZGVUeXBlID09PSBDT01NRU5UX05PREUpIHsgLy8gVGV4dCBvciBjb21tZW50IG5vZGVcbiAgICAgICAgICAgICAgICBpZiAodG9Ob2RlVHlwZSA9PT0gbW9ycGhlZE5vZGVUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb3JwaGVkTm9kZS5ub2RlVmFsdWUgIT09IHRvTm9kZS5ub2RlVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vcnBoZWROb2RlLm5vZGVWYWx1ZSA9IHRvTm9kZS5ub2RlVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbW9ycGhlZE5vZGU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGV4dCBub2RlIHRvIHNvbWV0aGluZyBlbHNlXG4gICAgICAgICAgICAgICAgICAgIG1vcnBoZWROb2RlID0gdG9Ob2RlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtb3JwaGVkTm9kZSA9PT0gdG9Ob2RlKSB7XG4gICAgICAgICAgICAvLyBUaGUgXCJ0byBub2RlXCIgd2FzIG5vdCBjb21wYXRpYmxlIHdpdGggdGhlIFwiZnJvbSBub2RlXCIgc28gd2UgaGFkIHRvXG4gICAgICAgICAgICAvLyB0b3NzIG91dCB0aGUgXCJmcm9tIG5vZGVcIiBhbmQgdXNlIHRoZSBcInRvIG5vZGVcIlxuICAgICAgICAgICAgb25Ob2RlRGlzY2FyZGVkKGZyb21Ob2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0b05vZGUuaXNTYW1lTm9kZSAmJiB0b05vZGUuaXNTYW1lTm9kZShtb3JwaGVkTm9kZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1vcnBoRWwobW9ycGhlZE5vZGUsIHRvTm9kZSwgY2hpbGRyZW5Pbmx5KTtcblxuICAgICAgICAgICAgLy8gV2Ugbm93IG5lZWQgdG8gbG9vcCBvdmVyIGFueSBrZXllZCBub2RlcyB0aGF0IG1pZ2h0IG5lZWQgdG8gYmVcbiAgICAgICAgICAgIC8vIHJlbW92ZWQuIFdlIG9ubHkgZG8gdGhlIHJlbW92YWwgaWYgd2Uga25vdyB0aGF0IHRoZSBrZXllZCBub2RlXG4gICAgICAgICAgICAvLyBuZXZlciBmb3VuZCBhIG1hdGNoLiBXaGVuIGEga2V5ZWQgbm9kZSBpcyBtYXRjaGVkIHVwIHdlIHJlbW92ZVxuICAgICAgICAgICAgLy8gaXQgb3V0IG9mIGZyb21Ob2Rlc0xvb2t1cCBhbmQgd2UgdXNlIGZyb21Ob2Rlc0xvb2t1cCB0byBkZXRlcm1pbmVcbiAgICAgICAgICAgIC8vIGlmIGEga2V5ZWQgbm9kZSBoYXMgYmVlbiBtYXRjaGVkIHVwIG9yIG5vdFxuICAgICAgICAgICAgaWYgKGtleWVkUmVtb3ZhbExpc3QpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpPTAsIGxlbj1rZXllZFJlbW92YWxMaXN0Lmxlbmd0aDsgaTxsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZWxUb1JlbW92ZSA9IGZyb21Ob2Rlc0xvb2t1cFtrZXllZFJlbW92YWxMaXN0W2ldXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsVG9SZW1vdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZU5vZGUoZWxUb1JlbW92ZSwgZWxUb1JlbW92ZS5wYXJlbnROb2RlLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWNoaWxkcmVuT25seSAmJiBtb3JwaGVkTm9kZSAhPT0gZnJvbU5vZGUgJiYgZnJvbU5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgaWYgKG1vcnBoZWROb2RlLmFjdHVhbGl6ZSkge1xuICAgICAgICAgICAgICAgIG1vcnBoZWROb2RlID0gbW9ycGhlZE5vZGUuYWN0dWFsaXplKGZyb21Ob2RlLm93bmVyRG9jdW1lbnQgfHwgZG9jKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHdlIGhhZCB0byBzd2FwIG91dCB0aGUgZnJvbSBub2RlIHdpdGggYSBuZXcgbm9kZSBiZWNhdXNlIHRoZSBvbGRcbiAgICAgICAgICAgIC8vIG5vZGUgd2FzIG5vdCBjb21wYXRpYmxlIHdpdGggdGhlIHRhcmdldCBub2RlIHRoZW4gd2UgbmVlZCB0b1xuICAgICAgICAgICAgLy8gcmVwbGFjZSB0aGUgb2xkIERPTSBub2RlIGluIHRoZSBvcmlnaW5hbCBET00gdHJlZS4gVGhpcyBpcyBvbmx5XG4gICAgICAgICAgICAvLyBwb3NzaWJsZSBpZiB0aGUgb3JpZ2luYWwgRE9NIG5vZGUgd2FzIHBhcnQgb2YgYSBET00gdHJlZSB3aGljaFxuICAgICAgICAgICAgLy8gd2Uga25vdyBpcyB0aGUgY2FzZSBpZiBpdCBoYXMgYSBwYXJlbnQgbm9kZS5cbiAgICAgICAgICAgIGZyb21Ob2RlLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKG1vcnBoZWROb2RlLCBmcm9tTm9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbW9ycGhlZE5vZGU7XG4gICAgfTtcbn1cblxudmFyIG1vcnBoZG9tID0gbW9ycGhkb21GYWN0b3J5KG1vcnBoQXR0cnMpO1xuXG5leHBvcnQgZGVmYXVsdCBtb3JwaGRvbTtcbiIsICJpbXBvcnQge1xuICBQSFhfQ09NUE9ORU5ULFxuICBQSFhfRElTQUJMRV9XSVRILFxuICBQSFhfRkVFREJBQ0tfRk9SLFxuICBQSFhfUFJVTkUsXG4gIFBIWF9ST09UX0lELFxuICBQSFhfU0VTU0lPTixcbiAgUEhYX1NLSVAsXG4gIFBIWF9TVEFUSUMsXG4gIFBIWF9UUklHR0VSX0FDVElPTixcbiAgUEhYX1VQREFURVxufSBmcm9tIFwiLi9jb25zdGFudHNcIlxuXG5pbXBvcnQge1xuICBkZXRlY3REdXBsaWNhdGVJZHMsXG4gIGlzQ2lkXG59IGZyb20gXCIuL3V0aWxzXCJcblxuaW1wb3J0IERPTSBmcm9tIFwiLi9kb21cIlxuaW1wb3J0IERPTVBvc3RNb3JwaFJlc3RvcmVyIGZyb20gXCIuL2RvbV9wb3N0X21vcnBoX3Jlc3RvcmVyXCJcbmltcG9ydCBtb3JwaGRvbSBmcm9tIFwibW9ycGhkb21cIlxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBET01QYXRjaCB7XG4gIHN0YXRpYyBwYXRjaEVsKGZyb21FbCwgdG9FbCwgYWN0aXZlRWxlbWVudCl7XG4gICAgbW9ycGhkb20oZnJvbUVsLCB0b0VsLCB7XG4gICAgICBjaGlsZHJlbk9ubHk6IGZhbHNlLFxuICAgICAgb25CZWZvcmVFbFVwZGF0ZWQ6IChmcm9tRWwsIHRvRWwpID0+IHtcbiAgICAgICAgaWYoYWN0aXZlRWxlbWVudCAmJiBhY3RpdmVFbGVtZW50LmlzU2FtZU5vZGUoZnJvbUVsKSAmJiBET00uaXNGb3JtSW5wdXQoZnJvbUVsKSl7XG4gICAgICAgICAgRE9NLm1lcmdlRm9jdXNlZElucHV0KGZyb21FbCwgdG9FbClcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBjb25zdHJ1Y3Rvcih2aWV3LCBjb250YWluZXIsIGlkLCBodG1sLCB0YXJnZXRDSUQpe1xuICAgIHRoaXMudmlldyA9IHZpZXdcbiAgICB0aGlzLmxpdmVTb2NrZXQgPSB2aWV3LmxpdmVTb2NrZXRcbiAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lclxuICAgIHRoaXMuaWQgPSBpZFxuICAgIHRoaXMucm9vdElEID0gdmlldy5yb290LmlkXG4gICAgdGhpcy5odG1sID0gaHRtbFxuICAgIHRoaXMudGFyZ2V0Q0lEID0gdGFyZ2V0Q0lEXG4gICAgdGhpcy5jaWRQYXRjaCA9IGlzQ2lkKHRoaXMudGFyZ2V0Q0lEKVxuICAgIHRoaXMuY2FsbGJhY2tzID0ge1xuICAgICAgYmVmb3JlYWRkZWQ6IFtdLCBiZWZvcmV1cGRhdGVkOiBbXSwgYmVmb3JlcGh4Q2hpbGRBZGRlZDogW10sXG4gICAgICBhZnRlcmFkZGVkOiBbXSwgYWZ0ZXJ1cGRhdGVkOiBbXSwgYWZ0ZXJkaXNjYXJkZWQ6IFtdLCBhZnRlcnBoeENoaWxkQWRkZWQ6IFtdLFxuICAgICAgYWZ0ZXJ0cmFuc2l0aW9uc0Rpc2NhcmRlZDogW11cbiAgICB9XG4gIH1cblxuICBiZWZvcmUoa2luZCwgY2FsbGJhY2speyB0aGlzLmNhbGxiYWNrc1tgYmVmb3JlJHtraW5kfWBdLnB1c2goY2FsbGJhY2spIH1cbiAgYWZ0ZXIoa2luZCwgY2FsbGJhY2speyB0aGlzLmNhbGxiYWNrc1tgYWZ0ZXIke2tpbmR9YF0ucHVzaChjYWxsYmFjaykgfVxuXG4gIHRyYWNrQmVmb3JlKGtpbmQsIC4uLmFyZ3Mpe1xuICAgIHRoaXMuY2FsbGJhY2tzW2BiZWZvcmUke2tpbmR9YF0uZm9yRWFjaChjYWxsYmFjayA9PiBjYWxsYmFjayguLi5hcmdzKSlcbiAgfVxuXG4gIHRyYWNrQWZ0ZXIoa2luZCwgLi4uYXJncyl7XG4gICAgdGhpcy5jYWxsYmFja3NbYGFmdGVyJHtraW5kfWBdLmZvckVhY2goY2FsbGJhY2sgPT4gY2FsbGJhY2soLi4uYXJncykpXG4gIH1cblxuICBtYXJrUHJ1bmFibGVDb250ZW50Rm9yUmVtb3ZhbCgpe1xuICAgIERPTS5hbGwodGhpcy5jb250YWluZXIsIFwiW3BoeC11cGRhdGU9YXBwZW5kXSA+ICosIFtwaHgtdXBkYXRlPXByZXBlbmRdID4gKlwiLCBlbCA9PiB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoUEhYX1BSVU5FLCBcIlwiKVxuICAgIH0pXG4gIH1cblxuICBwZXJmb3JtKCl7XG4gICAgbGV0IHt2aWV3LCBsaXZlU29ja2V0LCBjb250YWluZXIsIGh0bWx9ID0gdGhpc1xuICAgIGxldCB0YXJnZXRDb250YWluZXIgPSB0aGlzLmlzQ0lEUGF0Y2goKSA/IHRoaXMudGFyZ2V0Q0lEQ29udGFpbmVyKGh0bWwpIDogY29udGFpbmVyXG4gICAgaWYodGhpcy5pc0NJRFBhdGNoKCkgJiYgIXRhcmdldENvbnRhaW5lcil7IHJldHVybiB9XG5cbiAgICBsZXQgZm9jdXNlZCA9IGxpdmVTb2NrZXQuZ2V0QWN0aXZlRWxlbWVudCgpXG4gICAgbGV0IHtzZWxlY3Rpb25TdGFydCwgc2VsZWN0aW9uRW5kfSA9IGZvY3VzZWQgJiYgRE9NLmhhc1NlbGVjdGlvblJhbmdlKGZvY3VzZWQpID8gZm9jdXNlZCA6IHt9XG4gICAgbGV0IHBoeFVwZGF0ZSA9IGxpdmVTb2NrZXQuYmluZGluZyhQSFhfVVBEQVRFKVxuICAgIGxldCBwaHhGZWVkYmFja0ZvciA9IGxpdmVTb2NrZXQuYmluZGluZyhQSFhfRkVFREJBQ0tfRk9SKVxuICAgIGxldCBkaXNhYmxlV2l0aCA9IGxpdmVTb2NrZXQuYmluZGluZyhQSFhfRElTQUJMRV9XSVRIKVxuICAgIGxldCBwaHhUcmlnZ2VyRXh0ZXJuYWwgPSBsaXZlU29ja2V0LmJpbmRpbmcoUEhYX1RSSUdHRVJfQUNUSU9OKVxuICAgIGxldCBwaHhSZW1vdmUgPSBsaXZlU29ja2V0LmJpbmRpbmcoXCJyZW1vdmVcIilcbiAgICBsZXQgYWRkZWQgPSBbXVxuICAgIGxldCB1cGRhdGVzID0gW11cbiAgICBsZXQgYXBwZW5kUHJlcGVuZFVwZGF0ZXMgPSBbXVxuICAgIGxldCBwZW5kaW5nUmVtb3ZlcyA9IFtdXG4gICAgbGV0IGV4dGVybmFsRm9ybVRyaWdnZXJlZCA9IG51bGxcblxuICAgIGxldCBkaWZmSFRNTCA9IGxpdmVTb2NrZXQudGltZShcInByZW1vcnBoIGNvbnRhaW5lciBwcmVwXCIsICgpID0+IHtcbiAgICAgIHJldHVybiB0aGlzLmJ1aWxkRGlmZkhUTUwoY29udGFpbmVyLCBodG1sLCBwaHhVcGRhdGUsIHRhcmdldENvbnRhaW5lcilcbiAgICB9KVxuXG4gICAgdGhpcy50cmFja0JlZm9yZShcImFkZGVkXCIsIGNvbnRhaW5lcilcbiAgICB0aGlzLnRyYWNrQmVmb3JlKFwidXBkYXRlZFwiLCBjb250YWluZXIsIGNvbnRhaW5lcilcblxuICAgIGxpdmVTb2NrZXQudGltZShcIm1vcnBoZG9tXCIsICgpID0+IHtcbiAgICAgIG1vcnBoZG9tKHRhcmdldENvbnRhaW5lciwgZGlmZkhUTUwsIHtcbiAgICAgICAgY2hpbGRyZW5Pbmx5OiB0YXJnZXRDb250YWluZXIuZ2V0QXR0cmlidXRlKFBIWF9DT01QT05FTlQpID09PSBudWxsLFxuICAgICAgICBnZXROb2RlS2V5OiAobm9kZSkgPT4ge1xuICAgICAgICAgIHJldHVybiBET00uaXNQaHhEZXN0cm95ZWQobm9kZSkgPyBudWxsIDogbm9kZS5pZFxuICAgICAgICB9LFxuICAgICAgICBvbkJlZm9yZU5vZGVBZGRlZDogKGVsKSA9PiB7XG4gICAgICAgICAgdGhpcy50cmFja0JlZm9yZShcImFkZGVkXCIsIGVsKVxuICAgICAgICAgIHJldHVybiBlbFxuICAgICAgICB9LFxuICAgICAgICBvbk5vZGVBZGRlZDogKGVsKSA9PiB7XG4gICAgICAgICAgLy8gaGFjayB0byBmaXggU2FmYXJpIGhhbmRsaW5nIG9mIGltZyBzcmNzZXQgYW5kIHZpZGVvIHRhZ3NcbiAgICAgICAgICBpZihlbCBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQgJiYgZWwuc3Jjc2V0KXtcbiAgICAgICAgICAgIGVsLnNyY3NldCA9IGVsLnNyY3NldFxuICAgICAgICAgIH0gZWxzZSBpZihlbCBpbnN0YW5jZW9mIEhUTUxWaWRlb0VsZW1lbnQgJiYgZWwuYXV0b3BsYXkpe1xuICAgICAgICAgICAgZWwucGxheSgpXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmKERPTS5pc05vd1RyaWdnZXJGb3JtRXh0ZXJuYWwoZWwsIHBoeFRyaWdnZXJFeHRlcm5hbCkpe1xuICAgICAgICAgICAgZXh0ZXJuYWxGb3JtVHJpZ2dlcmVkID0gZWxcbiAgICAgICAgICB9XG4gICAgICAgICAgLy9pbnB1dCBoYW5kbGluZ1xuICAgICAgICAgIERPTS5kaXNjYXJkRXJyb3IodGFyZ2V0Q29udGFpbmVyLCBlbCwgcGh4RmVlZGJhY2tGb3IpXG4gICAgICAgICAgLy8gbmVzdGVkIHZpZXcgaGFuZGxpbmdcbiAgICAgICAgICBpZigoRE9NLmlzUGh4Q2hpbGQoZWwpICYmIHZpZXcub3duc0VsZW1lbnQoZWwpKSB8fCBET00uaXNQaHhTdGlja3koZWwpICYmIHZpZXcub3duc0VsZW1lbnQoZWwucGFyZW50Tm9kZSkpe1xuICAgICAgICAgICAgdGhpcy50cmFja0FmdGVyKFwicGh4Q2hpbGRBZGRlZFwiLCBlbClcbiAgICAgICAgICB9XG4gICAgICAgICAgYWRkZWQucHVzaChlbClcbiAgICAgICAgfSxcbiAgICAgICAgb25Ob2RlRGlzY2FyZGVkOiAoZWwpID0+IHtcbiAgICAgICAgICAvLyBuZXN0ZWQgdmlldyBoYW5kbGluZ1xuICAgICAgICAgIGlmKERPTS5pc1BoeENoaWxkKGVsKSB8fCBET00uaXNQaHhTdGlja3koZWwpKXsgbGl2ZVNvY2tldC5kZXN0cm95Vmlld0J5RWwoZWwpIH1cbiAgICAgICAgICB0aGlzLnRyYWNrQWZ0ZXIoXCJkaXNjYXJkZWRcIiwgZWwpXG4gICAgICAgIH0sXG4gICAgICAgIG9uQmVmb3JlTm9kZURpc2NhcmRlZDogKGVsKSA9PiB7XG4gICAgICAgICAgaWYoZWwuZ2V0QXR0cmlidXRlICYmIGVsLmdldEF0dHJpYnV0ZShQSFhfUFJVTkUpICE9PSBudWxsKXsgcmV0dXJuIHRydWUgfVxuICAgICAgICAgIGlmKGVsLnBhcmVudE5vZGUgIT09IG51bGwgJiYgRE9NLmlzUGh4VXBkYXRlKGVsLnBhcmVudE5vZGUsIHBoeFVwZGF0ZSwgW1wiYXBwZW5kXCIsIFwicHJlcGVuZFwiXSkgJiYgZWwuaWQpeyByZXR1cm4gZmFsc2UgfVxuICAgICAgICAgIGlmKGVsLmdldEF0dHJpYnV0ZSAmJiBlbC5nZXRBdHRyaWJ1dGUocGh4UmVtb3ZlKSl7XG4gICAgICAgICAgICBwZW5kaW5nUmVtb3Zlcy5wdXNoKGVsKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmKHRoaXMuc2tpcENJRFNpYmxpbmcoZWwpKXsgcmV0dXJuIGZhbHNlIH1cbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICBvbkVsVXBkYXRlZDogKGVsKSA9PiB7XG4gICAgICAgICAgaWYoRE9NLmlzTm93VHJpZ2dlckZvcm1FeHRlcm5hbChlbCwgcGh4VHJpZ2dlckV4dGVybmFsKSl7XG4gICAgICAgICAgICBleHRlcm5hbEZvcm1UcmlnZ2VyZWQgPSBlbFxuICAgICAgICAgIH1cbiAgICAgICAgICB1cGRhdGVzLnB1c2goZWwpXG4gICAgICAgIH0sXG4gICAgICAgIG9uQmVmb3JlRWxVcGRhdGVkOiAoZnJvbUVsLCB0b0VsKSA9PiB7XG4gICAgICAgICAgRE9NLmNsZWFuQ2hpbGROb2Rlcyh0b0VsLCBwaHhVcGRhdGUpXG4gICAgICAgICAgaWYodGhpcy5za2lwQ0lEU2libGluZyh0b0VsKSl7IHJldHVybiBmYWxzZSB9XG4gICAgICAgICAgaWYoRE9NLmlzUGh4U3RpY2t5KGZyb21FbCkpeyByZXR1cm4gZmFsc2UgfVxuICAgICAgICAgIGlmKERPTS5pc0lnbm9yZWQoZnJvbUVsLCBwaHhVcGRhdGUpKXtcbiAgICAgICAgICAgIHRoaXMudHJhY2tCZWZvcmUoXCJ1cGRhdGVkXCIsIGZyb21FbCwgdG9FbClcbiAgICAgICAgICAgIERPTS5tZXJnZUF0dHJzKGZyb21FbCwgdG9FbCwge2lzSWdub3JlZDogdHJ1ZX0pXG4gICAgICAgICAgICB1cGRhdGVzLnB1c2goZnJvbUVsKVxuICAgICAgICAgICAgRE9NLmFwcGx5U3RpY2t5T3BlcmF0aW9ucyhmcm9tRWwpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYoZnJvbUVsLnR5cGUgPT09IFwibnVtYmVyXCIgJiYgKGZyb21FbC52YWxpZGl0eSAmJiBmcm9tRWwudmFsaWRpdHkuYmFkSW5wdXQpKXsgcmV0dXJuIGZhbHNlIH1cbiAgICAgICAgICBpZighRE9NLnN5bmNQZW5kaW5nUmVmKGZyb21FbCwgdG9FbCwgZGlzYWJsZVdpdGgpKXtcbiAgICAgICAgICAgIGlmKERPTS5pc1VwbG9hZElucHV0KGZyb21FbCkpe1xuICAgICAgICAgICAgICB0aGlzLnRyYWNrQmVmb3JlKFwidXBkYXRlZFwiLCBmcm9tRWwsIHRvRWwpXG4gICAgICAgICAgICAgIHVwZGF0ZXMucHVzaChmcm9tRWwpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBET00uYXBwbHlTdGlja3lPcGVyYXRpb25zKGZyb21FbClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIG5lc3RlZCB2aWV3IGhhbmRsaW5nXG4gICAgICAgICAgaWYoRE9NLmlzUGh4Q2hpbGQodG9FbCkpe1xuICAgICAgICAgICAgbGV0IHByZXZTZXNzaW9uID0gZnJvbUVsLmdldEF0dHJpYnV0ZShQSFhfU0VTU0lPTilcbiAgICAgICAgICAgIERPTS5tZXJnZUF0dHJzKGZyb21FbCwgdG9FbCwge2V4Y2x1ZGU6IFtQSFhfU1RBVElDXX0pXG4gICAgICAgICAgICBpZihwcmV2U2Vzc2lvbiAhPT0gXCJcIil7IGZyb21FbC5zZXRBdHRyaWJ1dGUoUEhYX1NFU1NJT04sIHByZXZTZXNzaW9uKSB9XG4gICAgICAgICAgICBmcm9tRWwuc2V0QXR0cmlidXRlKFBIWF9ST09UX0lELCB0aGlzLnJvb3RJRClcbiAgICAgICAgICAgIERPTS5hcHBseVN0aWNreU9wZXJhdGlvbnMoZnJvbUVsKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gaW5wdXQgaGFuZGxpbmdcbiAgICAgICAgICBET00uY29weVByaXZhdGVzKHRvRWwsIGZyb21FbClcbiAgICAgICAgICBET00uZGlzY2FyZEVycm9yKHRhcmdldENvbnRhaW5lciwgdG9FbCwgcGh4RmVlZGJhY2tGb3IpXG5cbiAgICAgICAgICBsZXQgaXNGb2N1c2VkRm9ybUVsID0gZm9jdXNlZCAmJiBmcm9tRWwuaXNTYW1lTm9kZShmb2N1c2VkKSAmJiBET00uaXNGb3JtSW5wdXQoZnJvbUVsKVxuICAgICAgICAgIGlmKGlzRm9jdXNlZEZvcm1FbCl7XG4gICAgICAgICAgICB0aGlzLnRyYWNrQmVmb3JlKFwidXBkYXRlZFwiLCBmcm9tRWwsIHRvRWwpXG4gICAgICAgICAgICBET00ubWVyZ2VGb2N1c2VkSW5wdXQoZnJvbUVsLCB0b0VsKVxuICAgICAgICAgICAgRE9NLnN5bmNBdHRyc1RvUHJvcHMoZnJvbUVsKVxuICAgICAgICAgICAgdXBkYXRlcy5wdXNoKGZyb21FbClcbiAgICAgICAgICAgIERPTS5hcHBseVN0aWNreU9wZXJhdGlvbnMoZnJvbUVsKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmKERPTS5pc1BoeFVwZGF0ZSh0b0VsLCBwaHhVcGRhdGUsIFtcImFwcGVuZFwiLCBcInByZXBlbmRcIl0pKXtcbiAgICAgICAgICAgICAgYXBwZW5kUHJlcGVuZFVwZGF0ZXMucHVzaChuZXcgRE9NUG9zdE1vcnBoUmVzdG9yZXIoZnJvbUVsLCB0b0VsLCB0b0VsLmdldEF0dHJpYnV0ZShwaHhVcGRhdGUpKSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIERPTS5zeW5jQXR0cnNUb1Byb3BzKHRvRWwpXG4gICAgICAgICAgICBET00uYXBwbHlTdGlja3lPcGVyYXRpb25zKHRvRWwpXG4gICAgICAgICAgICB0aGlzLnRyYWNrQmVmb3JlKFwidXBkYXRlZFwiLCBmcm9tRWwsIHRvRWwpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9KVxuXG4gICAgaWYobGl2ZVNvY2tldC5pc0RlYnVnRW5hYmxlZCgpKXsgZGV0ZWN0RHVwbGljYXRlSWRzKCkgfVxuXG4gICAgaWYoYXBwZW5kUHJlcGVuZFVwZGF0ZXMubGVuZ3RoID4gMCl7XG4gICAgICBsaXZlU29ja2V0LnRpbWUoXCJwb3N0LW1vcnBoIGFwcGVuZC9wcmVwZW5kIHJlc3RvcmF0aW9uXCIsICgpID0+IHtcbiAgICAgICAgYXBwZW5kUHJlcGVuZFVwZGF0ZXMuZm9yRWFjaCh1cGRhdGUgPT4gdXBkYXRlLnBlcmZvcm0oKSlcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgbGl2ZVNvY2tldC5zaWxlbmNlRXZlbnRzKCgpID0+IERPTS5yZXN0b3JlRm9jdXMoZm9jdXNlZCwgc2VsZWN0aW9uU3RhcnQsIHNlbGVjdGlvbkVuZCkpXG4gICAgRE9NLmRpc3BhdGNoRXZlbnQoZG9jdW1lbnQsIFwicGh4OnVwZGF0ZVwiKVxuICAgIGFkZGVkLmZvckVhY2goZWwgPT4gdGhpcy50cmFja0FmdGVyKFwiYWRkZWRcIiwgZWwpKVxuICAgIHVwZGF0ZXMuZm9yRWFjaChlbCA9PiB0aGlzLnRyYWNrQWZ0ZXIoXCJ1cGRhdGVkXCIsIGVsKSlcblxuICAgIGlmKHBlbmRpbmdSZW1vdmVzLmxlbmd0aCA+IDApe1xuICAgICAgbGl2ZVNvY2tldC50cmFuc2l0aW9uUmVtb3ZlcyhwZW5kaW5nUmVtb3ZlcylcbiAgICAgIGxpdmVTb2NrZXQucmVxdWVzdERPTVVwZGF0ZSgoKSA9PiB7XG4gICAgICAgIHBlbmRpbmdSZW1vdmVzLmZvckVhY2goZWwgPT4ge1xuICAgICAgICAgIGxldCBjaGlsZCA9IERPTS5maXJzdFBoeENoaWxkKGVsKVxuICAgICAgICAgIGlmKGNoaWxkKXsgbGl2ZVNvY2tldC5kZXN0cm95Vmlld0J5RWwoY2hpbGQpIH1cbiAgICAgICAgICBlbC5yZW1vdmUoKVxuICAgICAgICB9KVxuICAgICAgICB0aGlzLnRyYWNrQWZ0ZXIoXCJ0cmFuc2l0aW9uc0Rpc2NhcmRlZFwiLCBwZW5kaW5nUmVtb3ZlcylcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgaWYoZXh0ZXJuYWxGb3JtVHJpZ2dlcmVkKXtcbiAgICAgIGxpdmVTb2NrZXQuZGlzY29ubmVjdCgpXG4gICAgICBleHRlcm5hbEZvcm1UcmlnZ2VyZWQuc3VibWl0KClcbiAgICB9XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGlzQ0lEUGF0Y2goKXsgcmV0dXJuIHRoaXMuY2lkUGF0Y2ggfVxuXG4gIHNraXBDSURTaWJsaW5nKGVsKXtcbiAgICByZXR1cm4gZWwubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFICYmIGVsLmdldEF0dHJpYnV0ZShQSFhfU0tJUCkgIT09IG51bGxcbiAgfVxuXG4gIHRhcmdldENJRENvbnRhaW5lcihodG1sKXtcbiAgICBpZighdGhpcy5pc0NJRFBhdGNoKCkpeyByZXR1cm4gfVxuICAgIGxldCBbZmlyc3QsIC4uLnJlc3RdID0gRE9NLmZpbmRDb21wb25lbnROb2RlTGlzdCh0aGlzLmNvbnRhaW5lciwgdGhpcy50YXJnZXRDSUQpXG4gICAgaWYocmVzdC5sZW5ndGggPT09IDAgJiYgRE9NLmNoaWxkTm9kZUxlbmd0aChodG1sKSA9PT0gMSl7XG4gICAgICByZXR1cm4gZmlyc3RcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZpcnN0ICYmIGZpcnN0LnBhcmVudE5vZGVcbiAgICB9XG4gIH1cblxuICAvLyBidWlsZHMgSFRNTCBmb3IgbW9ycGhkb20gcGF0Y2hcbiAgLy8gLSBmb3IgZnVsbCBwYXRjaGVzIG9mIExpdmVWaWV3IG9yIGEgY29tcG9uZW50IHdpdGggYSBzaW5nbGVcbiAgLy8gICByb290IG5vZGUsIHNpbXBseSByZXR1cm5zIHRoZSBIVE1MXG4gIC8vIC0gZm9yIHBhdGNoZXMgb2YgYSBjb21wb25lbnQgd2l0aCBtdWx0aXBsZSByb290IG5vZGVzLCB0aGVcbiAgLy8gICBwYXJlbnQgbm9kZSBiZWNvbWVzIHRoZSB0YXJnZXQgY29udGFpbmVyIGFuZCBub24tY29tcG9uZW50XG4gIC8vICAgc2libGluZ3MgYXJlIG1hcmtlZCBhcyBza2lwLlxuICBidWlsZERpZmZIVE1MKGNvbnRhaW5lciwgaHRtbCwgcGh4VXBkYXRlLCB0YXJnZXRDb250YWluZXIpe1xuICAgIGxldCBpc0NJRFBhdGNoID0gdGhpcy5pc0NJRFBhdGNoKClcbiAgICBsZXQgaXNDSURXaXRoU2luZ2xlUm9vdCA9IGlzQ0lEUGF0Y2ggJiYgdGFyZ2V0Q29udGFpbmVyLmdldEF0dHJpYnV0ZShQSFhfQ09NUE9ORU5UKSA9PT0gdGhpcy50YXJnZXRDSUQudG9TdHJpbmcoKVxuICAgIGlmKCFpc0NJRFBhdGNoIHx8IGlzQ0lEV2l0aFNpbmdsZVJvb3Qpe1xuICAgICAgcmV0dXJuIGh0bWxcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gY29tcG9uZW50IHBhdGNoIHdpdGggbXVsdGlwbGUgQ0lEIHJvb3RzXG4gICAgICBsZXQgZGlmZkNvbnRhaW5lciA9IG51bGxcbiAgICAgIGxldCB0ZW1wbGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0ZW1wbGF0ZVwiKVxuICAgICAgZGlmZkNvbnRhaW5lciA9IERPTS5jbG9uZU5vZGUodGFyZ2V0Q29udGFpbmVyKVxuICAgICAgbGV0IFtmaXJzdENvbXBvbmVudCwgLi4ucmVzdF0gPSBET00uZmluZENvbXBvbmVudE5vZGVMaXN0KGRpZmZDb250YWluZXIsIHRoaXMudGFyZ2V0Q0lEKVxuICAgICAgdGVtcGxhdGUuaW5uZXJIVE1MID0gaHRtbFxuICAgICAgcmVzdC5mb3JFYWNoKGVsID0+IGVsLnJlbW92ZSgpKVxuICAgICAgQXJyYXkuZnJvbShkaWZmQ29udGFpbmVyLmNoaWxkTm9kZXMpLmZvckVhY2goY2hpbGQgPT4ge1xuICAgICAgICAvLyB3ZSBjYW4gb25seSBza2lwIHRyYWNrYWJsZSBub2RlcyB3aXRoIGFuIElEXG4gICAgICAgIGlmKGNoaWxkLmlkICYmIGNoaWxkLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSAmJiBjaGlsZC5nZXRBdHRyaWJ1dGUoUEhYX0NPTVBPTkVOVCkgIT09IHRoaXMudGFyZ2V0Q0lELnRvU3RyaW5nKCkpe1xuICAgICAgICAgIGNoaWxkLnNldEF0dHJpYnV0ZShQSFhfU0tJUCwgXCJcIilcbiAgICAgICAgICBjaGlsZC5pbm5lckhUTUwgPSBcIlwiXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICBBcnJheS5mcm9tKHRlbXBsYXRlLmNvbnRlbnQuY2hpbGROb2RlcykuZm9yRWFjaChlbCA9PiBkaWZmQ29udGFpbmVyLmluc2VydEJlZm9yZShlbCwgZmlyc3RDb21wb25lbnQpKVxuICAgICAgZmlyc3RDb21wb25lbnQucmVtb3ZlKClcbiAgICAgIHJldHVybiBkaWZmQ29udGFpbmVyLm91dGVySFRNTFxuICAgIH1cbiAgfVxufVxuIiwgImltcG9ydCB7XG4gIENPTVBPTkVOVFMsXG4gIERZTkFNSUNTLFxuICBURU1QTEFURVMsXG4gIEVWRU5UUyxcbiAgUEhYX0NPTVBPTkVOVCxcbiAgUEhYX1NLSVAsXG4gIFJFUExZLFxuICBTVEFUSUMsXG4gIFRJVExFXG59IGZyb20gXCIuL2NvbnN0YW50c1wiXG5cbmltcG9ydCB7XG4gIGlzT2JqZWN0LFxuICBsb2dFcnJvcixcbiAgaXNDaWQsXG59IGZyb20gXCIuL3V0aWxzXCJcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVuZGVyZWQge1xuICBzdGF0aWMgZXh0cmFjdChkaWZmKXtcbiAgICBsZXQge1tSRVBMWV06IHJlcGx5LCBbRVZFTlRTXTogZXZlbnRzLCBbVElUTEVdOiB0aXRsZX0gPSBkaWZmXG4gICAgZGVsZXRlIGRpZmZbUkVQTFldXG4gICAgZGVsZXRlIGRpZmZbRVZFTlRTXVxuICAgIGRlbGV0ZSBkaWZmW1RJVExFXVxuICAgIHJldHVybiB7ZGlmZiwgdGl0bGUsIHJlcGx5OiByZXBseSB8fCBudWxsLCBldmVudHM6IGV2ZW50cyB8fCBbXX1cbiAgfVxuXG4gIGNvbnN0cnVjdG9yKHZpZXdJZCwgcmVuZGVyZWQpe1xuICAgIHRoaXMudmlld0lkID0gdmlld0lkXG4gICAgdGhpcy5yZW5kZXJlZCA9IHt9XG4gICAgdGhpcy5tZXJnZURpZmYocmVuZGVyZWQpXG4gIH1cblxuICBwYXJlbnRWaWV3SWQoKXsgcmV0dXJuIHRoaXMudmlld0lkIH1cblxuICB0b1N0cmluZyhvbmx5Q2lkcyl7XG4gICAgcmV0dXJuIHRoaXMucmVjdXJzaXZlVG9TdHJpbmcodGhpcy5yZW5kZXJlZCwgdGhpcy5yZW5kZXJlZFtDT01QT05FTlRTXSwgb25seUNpZHMpXG4gIH1cblxuICByZWN1cnNpdmVUb1N0cmluZyhyZW5kZXJlZCwgY29tcG9uZW50cyA9IHJlbmRlcmVkW0NPTVBPTkVOVFNdLCBvbmx5Q2lkcyl7XG4gICAgb25seUNpZHMgPSBvbmx5Q2lkcyA/IG5ldyBTZXQob25seUNpZHMpIDogbnVsbFxuICAgIGxldCBvdXRwdXQgPSB7YnVmZmVyOiBcIlwiLCBjb21wb25lbnRzOiBjb21wb25lbnRzLCBvbmx5Q2lkczogb25seUNpZHN9XG4gICAgdGhpcy50b091dHB1dEJ1ZmZlcihyZW5kZXJlZCwgbnVsbCwgb3V0cHV0KVxuICAgIHJldHVybiBvdXRwdXQuYnVmZmVyXG4gIH1cblxuICBjb21wb25lbnRDSURzKGRpZmYpeyByZXR1cm4gT2JqZWN0LmtleXMoZGlmZltDT01QT05FTlRTXSB8fCB7fSkubWFwKGkgPT4gcGFyc2VJbnQoaSkpIH1cblxuICBpc0NvbXBvbmVudE9ubHlEaWZmKGRpZmYpe1xuICAgIGlmKCFkaWZmW0NPTVBPTkVOVFNdKXsgcmV0dXJuIGZhbHNlIH1cbiAgICByZXR1cm4gT2JqZWN0LmtleXMoZGlmZikubGVuZ3RoID09PSAxXG4gIH1cblxuICBnZXRDb21wb25lbnQoZGlmZiwgY2lkKXsgcmV0dXJuIGRpZmZbQ09NUE9ORU5UU11bY2lkXSB9XG5cbiAgbWVyZ2VEaWZmKGRpZmYpe1xuICAgIGxldCBuZXdjID0gZGlmZltDT01QT05FTlRTXVxuICAgIGxldCBjYWNoZSA9IHt9XG4gICAgZGVsZXRlIGRpZmZbQ09NUE9ORU5UU11cbiAgICB0aGlzLnJlbmRlcmVkID0gdGhpcy5tdXRhYmxlTWVyZ2UodGhpcy5yZW5kZXJlZCwgZGlmZilcbiAgICB0aGlzLnJlbmRlcmVkW0NPTVBPTkVOVFNdID0gdGhpcy5yZW5kZXJlZFtDT01QT05FTlRTXSB8fCB7fVxuXG4gICAgaWYobmV3Yyl7XG4gICAgICBsZXQgb2xkYyA9IHRoaXMucmVuZGVyZWRbQ09NUE9ORU5UU11cblxuICAgICAgZm9yKGxldCBjaWQgaW4gbmV3Yyl7XG4gICAgICAgIG5ld2NbY2lkXSA9IHRoaXMuY2FjaGVkRmluZENvbXBvbmVudChjaWQsIG5ld2NbY2lkXSwgb2xkYywgbmV3YywgY2FjaGUpXG4gICAgICB9XG5cbiAgICAgIGZvcihsZXQgY2lkIGluIG5ld2MpeyBvbGRjW2NpZF0gPSBuZXdjW2NpZF0gfVxuICAgICAgZGlmZltDT01QT05FTlRTXSA9IG5ld2NcbiAgICB9XG4gIH1cblxuICBjYWNoZWRGaW5kQ29tcG9uZW50KGNpZCwgY2RpZmYsIG9sZGMsIG5ld2MsIGNhY2hlKXtcbiAgICBpZihjYWNoZVtjaWRdKXtcbiAgICAgIHJldHVybiBjYWNoZVtjaWRdXG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBuZGlmZiwgc3RhdCwgc2NpZCA9IGNkaWZmW1NUQVRJQ11cblxuICAgICAgaWYoaXNDaWQoc2NpZCkpe1xuICAgICAgICBsZXQgdGRpZmZcblxuICAgICAgICBpZihzY2lkID4gMCl7XG4gICAgICAgICAgdGRpZmYgPSB0aGlzLmNhY2hlZEZpbmRDb21wb25lbnQoc2NpZCwgbmV3Y1tzY2lkXSwgb2xkYywgbmV3YywgY2FjaGUpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGRpZmYgPSBvbGRjWy1zY2lkXVxuICAgICAgICB9XG5cbiAgICAgICAgc3RhdCA9IHRkaWZmW1NUQVRJQ11cbiAgICAgICAgbmRpZmYgPSB0aGlzLmNsb25lTWVyZ2UodGRpZmYsIGNkaWZmKVxuICAgICAgICBuZGlmZltTVEFUSUNdID0gc3RhdFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmRpZmYgPSBjZGlmZltTVEFUSUNdICE9PSB1bmRlZmluZWQgPyBjZGlmZiA6IHRoaXMuY2xvbmVNZXJnZShvbGRjW2NpZF0gfHwge30sIGNkaWZmKVxuICAgICAgfVxuXG4gICAgICBjYWNoZVtjaWRdID0gbmRpZmZcbiAgICAgIHJldHVybiBuZGlmZlxuICAgIH1cbiAgfVxuXG4gIG11dGFibGVNZXJnZSh0YXJnZXQsIHNvdXJjZSl7XG4gICAgaWYoc291cmNlW1NUQVRJQ10gIT09IHVuZGVmaW5lZCl7XG4gICAgICByZXR1cm4gc291cmNlXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZG9NdXRhYmxlTWVyZ2UodGFyZ2V0LCBzb3VyY2UpXG4gICAgICByZXR1cm4gdGFyZ2V0XG4gICAgfVxuICB9XG5cbiAgZG9NdXRhYmxlTWVyZ2UodGFyZ2V0LCBzb3VyY2Upe1xuICAgIGZvcihsZXQga2V5IGluIHNvdXJjZSl7XG4gICAgICBsZXQgdmFsID0gc291cmNlW2tleV1cbiAgICAgIGxldCB0YXJnZXRWYWwgPSB0YXJnZXRba2V5XVxuICAgICAgaWYoaXNPYmplY3QodmFsKSAmJiB2YWxbU1RBVElDXSA9PT0gdW5kZWZpbmVkICYmIGlzT2JqZWN0KHRhcmdldFZhbCkpe1xuICAgICAgICB0aGlzLmRvTXV0YWJsZU1lcmdlKHRhcmdldFZhbCwgdmFsKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGFyZ2V0W2tleV0gPSB2YWxcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjbG9uZU1lcmdlKHRhcmdldCwgc291cmNlKXtcbiAgICBsZXQgbWVyZ2VkID0gey4uLnRhcmdldCwgLi4uc291cmNlfVxuICAgIGZvcihsZXQga2V5IGluIG1lcmdlZCl7XG4gICAgICBsZXQgdmFsID0gc291cmNlW2tleV1cbiAgICAgIGxldCB0YXJnZXRWYWwgPSB0YXJnZXRba2V5XVxuICAgICAgaWYoaXNPYmplY3QodmFsKSAmJiB2YWxbU1RBVElDXSA9PT0gdW5kZWZpbmVkICYmIGlzT2JqZWN0KHRhcmdldFZhbCkpe1xuICAgICAgICBtZXJnZWRba2V5XSA9IHRoaXMuY2xvbmVNZXJnZSh0YXJnZXRWYWwsIHZhbClcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1lcmdlZFxuICB9XG5cbiAgY29tcG9uZW50VG9TdHJpbmcoY2lkKXsgcmV0dXJuIHRoaXMucmVjdXJzaXZlQ0lEVG9TdHJpbmcodGhpcy5yZW5kZXJlZFtDT01QT05FTlRTXSwgY2lkKSB9XG5cbiAgcHJ1bmVDSURzKGNpZHMpe1xuICAgIGNpZHMuZm9yRWFjaChjaWQgPT4gZGVsZXRlIHRoaXMucmVuZGVyZWRbQ09NUE9ORU5UU11bY2lkXSlcbiAgfVxuXG4gIC8vIHByaXZhdGVcblxuICBnZXQoKXsgcmV0dXJuIHRoaXMucmVuZGVyZWQgfVxuXG4gIGlzTmV3RmluZ2VycHJpbnQoZGlmZiA9IHt9KXsgcmV0dXJuICEhZGlmZltTVEFUSUNdIH1cblxuICB0ZW1wbGF0ZVN0YXRpYyhwYXJ0LCB0ZW1wbGF0ZXMpe1xuICAgIGlmKHR5cGVvZiAocGFydCkgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHJldHVybiB0ZW1wbGF0ZXNbcGFydF1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHBhcnRcbiAgICB9XG4gIH1cblxuICB0b091dHB1dEJ1ZmZlcihyZW5kZXJlZCwgdGVtcGxhdGVzLCBvdXRwdXQpe1xuICAgIGlmKHJlbmRlcmVkW0RZTkFNSUNTXSl7IHJldHVybiB0aGlzLmNvbXByZWhlbnNpb25Ub0J1ZmZlcihyZW5kZXJlZCwgdGVtcGxhdGVzLCBvdXRwdXQpIH1cbiAgICBsZXQge1tTVEFUSUNdOiBzdGF0aWNzfSA9IHJlbmRlcmVkXG4gICAgc3RhdGljcyA9IHRoaXMudGVtcGxhdGVTdGF0aWMoc3RhdGljcywgdGVtcGxhdGVzKVxuXG4gICAgb3V0cHV0LmJ1ZmZlciArPSBzdGF0aWNzWzBdXG4gICAgZm9yKGxldCBpID0gMTsgaSA8IHN0YXRpY3MubGVuZ3RoOyBpKyspe1xuICAgICAgdGhpcy5keW5hbWljVG9CdWZmZXIocmVuZGVyZWRbaSAtIDFdLCB0ZW1wbGF0ZXMsIG91dHB1dClcbiAgICAgIG91dHB1dC5idWZmZXIgKz0gc3RhdGljc1tpXVxuICAgIH1cbiAgfVxuXG4gIGNvbXByZWhlbnNpb25Ub0J1ZmZlcihyZW5kZXJlZCwgdGVtcGxhdGVzLCBvdXRwdXQpe1xuICAgIGxldCB7W0RZTkFNSUNTXTogZHluYW1pY3MsIFtTVEFUSUNdOiBzdGF0aWNzfSA9IHJlbmRlcmVkXG4gICAgc3RhdGljcyA9IHRoaXMudGVtcGxhdGVTdGF0aWMoc3RhdGljcywgdGVtcGxhdGVzKVxuICAgIGxldCBjb21wVGVtcGxhdGVzID0gdGVtcGxhdGVzIHx8IHJlbmRlcmVkW1RFTVBMQVRFU11cblxuICAgIGZvcihsZXQgZCA9IDA7IGQgPCBkeW5hbWljcy5sZW5ndGg7IGQrKyl7XG4gICAgICBsZXQgZHluYW1pYyA9IGR5bmFtaWNzW2RdXG4gICAgICBvdXRwdXQuYnVmZmVyICs9IHN0YXRpY3NbMF1cbiAgICAgIGZvcihsZXQgaSA9IDE7IGkgPCBzdGF0aWNzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdGhpcy5keW5hbWljVG9CdWZmZXIoZHluYW1pY1tpIC0gMV0sIGNvbXBUZW1wbGF0ZXMsIG91dHB1dClcbiAgICAgICAgb3V0cHV0LmJ1ZmZlciArPSBzdGF0aWNzW2ldXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZHluYW1pY1RvQnVmZmVyKHJlbmRlcmVkLCB0ZW1wbGF0ZXMsIG91dHB1dCl7XG4gICAgaWYodHlwZW9mIChyZW5kZXJlZCkgPT09IFwibnVtYmVyXCIpe1xuICAgICAgb3V0cHV0LmJ1ZmZlciArPSB0aGlzLnJlY3Vyc2l2ZUNJRFRvU3RyaW5nKG91dHB1dC5jb21wb25lbnRzLCByZW5kZXJlZCwgb3V0cHV0Lm9ubHlDaWRzKVxuICAgIH0gZWxzZSBpZihpc09iamVjdChyZW5kZXJlZCkpe1xuICAgICAgdGhpcy50b091dHB1dEJ1ZmZlcihyZW5kZXJlZCwgdGVtcGxhdGVzLCBvdXRwdXQpXG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dC5idWZmZXIgKz0gcmVuZGVyZWRcbiAgICB9XG4gIH1cblxuICByZWN1cnNpdmVDSURUb1N0cmluZyhjb21wb25lbnRzLCBjaWQsIG9ubHlDaWRzKXtcbiAgICBsZXQgY29tcG9uZW50ID0gY29tcG9uZW50c1tjaWRdIHx8IGxvZ0Vycm9yKGBubyBjb21wb25lbnQgZm9yIENJRCAke2NpZH1gLCBjb21wb25lbnRzKVxuICAgIGxldCB0ZW1wbGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0ZW1wbGF0ZVwiKVxuICAgIHRlbXBsYXRlLmlubmVySFRNTCA9IHRoaXMucmVjdXJzaXZlVG9TdHJpbmcoY29tcG9uZW50LCBjb21wb25lbnRzLCBvbmx5Q2lkcylcbiAgICBsZXQgY29udGFpbmVyID0gdGVtcGxhdGUuY29udGVudFxuICAgIGxldCBza2lwID0gb25seUNpZHMgJiYgIW9ubHlDaWRzLmhhcyhjaWQpXG5cbiAgICBsZXQgW2hhc0NoaWxkTm9kZXMsIGhhc0NoaWxkQ29tcG9uZW50c10gPVxuICAgICAgQXJyYXkuZnJvbShjb250YWluZXIuY2hpbGROb2RlcykucmVkdWNlKChbaGFzTm9kZXMsIGhhc0NvbXBvbmVudHNdLCBjaGlsZCwgaSkgPT4ge1xuICAgICAgICBpZihjaGlsZC5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUpe1xuICAgICAgICAgIGlmKGNoaWxkLmdldEF0dHJpYnV0ZShQSFhfQ09NUE9ORU5UKSl7XG4gICAgICAgICAgICByZXR1cm4gW2hhc05vZGVzLCB0cnVlXVxuICAgICAgICAgIH1cbiAgICAgICAgICBjaGlsZC5zZXRBdHRyaWJ1dGUoUEhYX0NPTVBPTkVOVCwgY2lkKVxuICAgICAgICAgIGlmKCFjaGlsZC5pZCl7IGNoaWxkLmlkID0gYCR7dGhpcy5wYXJlbnRWaWV3SWQoKX0tJHtjaWR9LSR7aX1gIH1cbiAgICAgICAgICBpZihza2lwKXtcbiAgICAgICAgICAgIGNoaWxkLnNldEF0dHJpYnV0ZShQSFhfU0tJUCwgXCJcIilcbiAgICAgICAgICAgIGNoaWxkLmlubmVySFRNTCA9IFwiXCJcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIFt0cnVlLCBoYXNDb21wb25lbnRzXVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmKGNoaWxkLm5vZGVWYWx1ZS50cmltKCkgIT09IFwiXCIpe1xuICAgICAgICAgICAgbG9nRXJyb3IoXCJvbmx5IEhUTUwgZWxlbWVudCB0YWdzIGFyZSBhbGxvd2VkIGF0IHRoZSByb290IG9mIGNvbXBvbmVudHMuXFxuXFxuXCIgK1xuICAgICAgICAgICAgICBgZ290OiBcIiR7Y2hpbGQubm9kZVZhbHVlLnRyaW0oKX1cIlxcblxcbmAgK1xuICAgICAgICAgICAgICBcIndpdGhpbjpcXG5cIiwgdGVtcGxhdGUuaW5uZXJIVE1MLnRyaW0oKSlcbiAgICAgICAgICAgIGNoaWxkLnJlcGxhY2VXaXRoKHRoaXMuY3JlYXRlU3BhbihjaGlsZC5ub2RlVmFsdWUsIGNpZCkpXG4gICAgICAgICAgICByZXR1cm4gW3RydWUsIGhhc0NvbXBvbmVudHNdXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNoaWxkLnJlbW92ZSgpXG4gICAgICAgICAgICByZXR1cm4gW2hhc05vZGVzLCBoYXNDb21wb25lbnRzXVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgW2ZhbHNlLCBmYWxzZV0pXG5cbiAgICBpZighaGFzQ2hpbGROb2RlcyAmJiAhaGFzQ2hpbGRDb21wb25lbnRzKXtcbiAgICAgIGxvZ0Vycm9yKFwiZXhwZWN0ZWQgYXQgbGVhc3Qgb25lIEhUTUwgZWxlbWVudCB0YWcgaW5zaWRlIGEgY29tcG9uZW50LCBidXQgdGhlIGNvbXBvbmVudCBpcyBlbXB0eTpcXG5cIixcbiAgICAgICAgdGVtcGxhdGUuaW5uZXJIVE1MLnRyaW0oKSlcbiAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVNwYW4oXCJcIiwgY2lkKS5vdXRlckhUTUxcbiAgICB9IGVsc2UgaWYoIWhhc0NoaWxkTm9kZXMgJiYgaGFzQ2hpbGRDb21wb25lbnRzKXtcbiAgICAgIGxvZ0Vycm9yKFwiZXhwZWN0ZWQgYXQgbGVhc3Qgb25lIEhUTUwgZWxlbWVudCB0YWcgZGlyZWN0bHkgaW5zaWRlIGEgY29tcG9uZW50LCBidXQgb25seSBzdWJjb21wb25lbnRzIHdlcmUgZm91bmQuIEEgY29tcG9uZW50IG11c3QgcmVuZGVyIGF0IGxlYXN0IG9uZSBIVE1MIHRhZyBkaXJlY3RseSBpbnNpZGUgaXRzZWxmLlwiLFxuICAgICAgICB0ZW1wbGF0ZS5pbm5lckhUTUwudHJpbSgpKVxuICAgICAgcmV0dXJuIHRlbXBsYXRlLmlubmVySFRNTFxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGVtcGxhdGUuaW5uZXJIVE1MXG4gICAgfVxuICB9XG5cbiAgY3JlYXRlU3Bhbih0ZXh0LCBjaWQpe1xuICAgIGxldCBzcGFuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIilcbiAgICBzcGFuLmlubmVyVGV4dCA9IHRleHRcbiAgICBzcGFuLnNldEF0dHJpYnV0ZShQSFhfQ09NUE9ORU5ULCBjaWQpXG4gICAgcmV0dXJuIHNwYW5cbiAgfVxufVxuIiwgImxldCB2aWV3SG9va0lEID0gMVxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVmlld0hvb2sge1xuICBzdGF0aWMgbWFrZUlEKCl7IHJldHVybiB2aWV3SG9va0lEKysgfVxuICBzdGF0aWMgZWxlbWVudElEKGVsKXsgcmV0dXJuIGVsLnBoeEhvb2tJZCB9XG5cbiAgY29uc3RydWN0b3IodmlldywgZWwsIGNhbGxiYWNrcyl7XG4gICAgdGhpcy5fX3ZpZXcgPSB2aWV3XG4gICAgdGhpcy5saXZlU29ja2V0ID0gdmlldy5saXZlU29ja2V0XG4gICAgdGhpcy5fX2NhbGxiYWNrcyA9IGNhbGxiYWNrc1xuICAgIHRoaXMuX19saXN0ZW5lcnMgPSBuZXcgU2V0KClcbiAgICB0aGlzLl9faXNEaXNjb25uZWN0ZWQgPSBmYWxzZVxuICAgIHRoaXMuZWwgPSBlbFxuICAgIHRoaXMuZWwucGh4SG9va0lkID0gdGhpcy5jb25zdHJ1Y3Rvci5tYWtlSUQoKVxuICAgIGZvcihsZXQga2V5IGluIHRoaXMuX19jYWxsYmFja3MpeyB0aGlzW2tleV0gPSB0aGlzLl9fY2FsbGJhY2tzW2tleV0gfVxuICB9XG5cbiAgX19tb3VudGVkKCl7IHRoaXMubW91bnRlZCAmJiB0aGlzLm1vdW50ZWQoKSB9XG4gIF9fdXBkYXRlZCgpeyB0aGlzLnVwZGF0ZWQgJiYgdGhpcy51cGRhdGVkKCkgfVxuICBfX2JlZm9yZVVwZGF0ZSgpeyB0aGlzLmJlZm9yZVVwZGF0ZSAmJiB0aGlzLmJlZm9yZVVwZGF0ZSgpIH1cbiAgX19kZXN0cm95ZWQoKXsgdGhpcy5kZXN0cm95ZWQgJiYgdGhpcy5kZXN0cm95ZWQoKSB9XG4gIF9fcmVjb25uZWN0ZWQoKXtcbiAgICBpZih0aGlzLl9faXNEaXNjb25uZWN0ZWQpe1xuICAgICAgdGhpcy5fX2lzRGlzY29ubmVjdGVkID0gZmFsc2VcbiAgICAgIHRoaXMucmVjb25uZWN0ZWQgJiYgdGhpcy5yZWNvbm5lY3RlZCgpXG4gICAgfVxuICB9XG4gIF9fZGlzY29ubmVjdGVkKCl7XG4gICAgdGhpcy5fX2lzRGlzY29ubmVjdGVkID0gdHJ1ZVxuICAgIHRoaXMuZGlzY29ubmVjdGVkICYmIHRoaXMuZGlzY29ubmVjdGVkKClcbiAgfVxuXG4gIHB1c2hFdmVudChldmVudCwgcGF5bG9hZCA9IHt9LCBvblJlcGx5ID0gZnVuY3Rpb24gKCl7IH0pe1xuICAgIHJldHVybiB0aGlzLl9fdmlldy5wdXNoSG9va0V2ZW50KG51bGwsIGV2ZW50LCBwYXlsb2FkLCBvblJlcGx5KVxuICB9XG5cbiAgcHVzaEV2ZW50VG8ocGh4VGFyZ2V0LCBldmVudCwgcGF5bG9hZCA9IHt9LCBvblJlcGx5ID0gZnVuY3Rpb24gKCl7IH0pe1xuICAgIHJldHVybiB0aGlzLl9fdmlldy53aXRoaW5UYXJnZXRzKHBoeFRhcmdldCwgKHZpZXcsIHRhcmdldEN0eCkgPT4ge1xuICAgICAgcmV0dXJuIHZpZXcucHVzaEhvb2tFdmVudCh0YXJnZXRDdHgsIGV2ZW50LCBwYXlsb2FkLCBvblJlcGx5KVxuICAgIH0pXG4gIH1cblxuICBoYW5kbGVFdmVudChldmVudCwgY2FsbGJhY2spe1xuICAgIGxldCBjYWxsYmFja1JlZiA9IChjdXN0b21FdmVudCwgYnlwYXNzKSA9PiBieXBhc3MgPyBldmVudCA6IGNhbGxiYWNrKGN1c3RvbUV2ZW50LmRldGFpbClcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihgcGh4OiR7ZXZlbnR9YCwgY2FsbGJhY2tSZWYpXG4gICAgdGhpcy5fX2xpc3RlbmVycy5hZGQoY2FsbGJhY2tSZWYpXG4gICAgcmV0dXJuIGNhbGxiYWNrUmVmXG4gIH1cblxuICByZW1vdmVIYW5kbGVFdmVudChjYWxsYmFja1JlZil7XG4gICAgbGV0IGV2ZW50ID0gY2FsbGJhY2tSZWYobnVsbCwgdHJ1ZSlcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihgcGh4OiR7ZXZlbnR9YCwgY2FsbGJhY2tSZWYpXG4gICAgdGhpcy5fX2xpc3RlbmVycy5kZWxldGUoY2FsbGJhY2tSZWYpXG4gIH1cblxuICB1cGxvYWQobmFtZSwgZmlsZXMpe1xuICAgIHJldHVybiB0aGlzLl9fdmlldy5kaXNwYXRjaFVwbG9hZHMobmFtZSwgZmlsZXMpXG4gIH1cblxuICB1cGxvYWRUbyhwaHhUYXJnZXQsIG5hbWUsIGZpbGVzKXtcbiAgICByZXR1cm4gdGhpcy5fX3ZpZXcud2l0aGluVGFyZ2V0cyhwaHhUYXJnZXQsIHZpZXcgPT4gdmlldy5kaXNwYXRjaFVwbG9hZHMobmFtZSwgZmlsZXMpKVxuICB9XG5cbiAgX19jbGVhbnVwX18oKXtcbiAgICB0aGlzLl9fbGlzdGVuZXJzLmZvckVhY2goY2FsbGJhY2tSZWYgPT4gdGhpcy5yZW1vdmVIYW5kbGVFdmVudChjYWxsYmFja1JlZikpXG4gIH1cbn1cbiIsICJpbXBvcnQgRE9NIGZyb20gXCIuL2RvbVwiXG5cbmxldCBKUyA9IHtcbiAgZXhlYyhldmVudFR5cGUsIHBoeEV2ZW50LCB2aWV3LCBzb3VyY2VFbCwgZGVmYXVsdHMpe1xuICAgIGxldCBbZGVmYXVsdEtpbmQsIGRlZmF1bHRBcmdzXSA9IGRlZmF1bHRzIHx8IFtudWxsLCB7fV1cbiAgICBsZXQgY29tbWFuZHMgPSBwaHhFdmVudC5jaGFyQXQoMCkgPT09IFwiW1wiID9cbiAgICAgIEpTT04ucGFyc2UocGh4RXZlbnQpIDogW1tkZWZhdWx0S2luZCwgZGVmYXVsdEFyZ3NdXVxuXG4gICAgY29tbWFuZHMuZm9yRWFjaCgoW2tpbmQsIGFyZ3NdKSA9PiB7XG4gICAgICBpZihraW5kID09PSBkZWZhdWx0S2luZCAmJiBkZWZhdWx0QXJncy5kYXRhKXtcbiAgICAgICAgYXJncy5kYXRhID0gT2JqZWN0LmFzc2lnbihhcmdzLmRhdGEgfHwge30sIGRlZmF1bHRBcmdzLmRhdGEpXG4gICAgICB9XG4gICAgICB0aGlzLmZpbHRlclRvRWxzKHNvdXJjZUVsLCBhcmdzKS5mb3JFYWNoKGVsID0+IHtcbiAgICAgICAgdGhpc1tgZXhlY18ke2tpbmR9YF0oZXZlbnRUeXBlLCBwaHhFdmVudCwgdmlldywgc291cmNlRWwsIGVsLCBhcmdzKVxuICAgICAgfSlcbiAgICB9KVxuICB9LFxuXG4gIGlzVmlzaWJsZShlbCl7XG4gICAgcmV0dXJuICEhKGVsLm9mZnNldFdpZHRoIHx8IGVsLm9mZnNldEhlaWdodCB8fCBlbC5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCA+IDApXG4gIH0sXG5cbiAgLy8gcHJpdmF0ZVxuXG4gIC8vIGNvbW1hbmRzXG5cbiAgZXhlY19kaXNwYXRjaChldmVudFR5cGUsIHBoeEV2ZW50LCB2aWV3LCBzb3VyY2VFbCwgZWwsIHt0bywgZXZlbnQsIGRldGFpbCwgYnViYmxlc30pe1xuICAgIGRldGFpbCA9IGRldGFpbCB8fCB7fVxuICAgIGRldGFpbC5kaXNwYXRjaGVyID0gc291cmNlRWxcbiAgICBET00uZGlzcGF0Y2hFdmVudChlbCwgZXZlbnQsIHtkZXRhaWwsIGJ1YmJsZXN9KVxuICB9LFxuXG4gIGV4ZWNfcHVzaChldmVudFR5cGUsIHBoeEV2ZW50LCB2aWV3LCBzb3VyY2VFbCwgZWwsIGFyZ3Mpe1xuICAgIGlmKCF2aWV3LmlzQ29ubmVjdGVkKCkpeyByZXR1cm4gfVxuXG4gICAgbGV0IHtldmVudCwgZGF0YSwgdGFyZ2V0LCBwYWdlX2xvYWRpbmcsIGxvYWRpbmcsIHZhbHVlLCBkaXNwYXRjaGVyfSA9IGFyZ3NcbiAgICBsZXQgcHVzaE9wdHMgPSB7bG9hZGluZywgdmFsdWUsIHRhcmdldCwgcGFnZV9sb2FkaW5nOiAhIXBhZ2VfbG9hZGluZ31cbiAgICBsZXQgdGFyZ2V0U3JjID0gZXZlbnRUeXBlID09PSBcImNoYW5nZVwiICYmIGRpc3BhdGNoZXIgPyBkaXNwYXRjaGVyIDogc291cmNlRWxcbiAgICBsZXQgcGh4VGFyZ2V0ID0gdGFyZ2V0IHx8IHRhcmdldFNyYy5nZXRBdHRyaWJ1dGUodmlldy5iaW5kaW5nKFwidGFyZ2V0XCIpKSB8fCB0YXJnZXRTcmNcbiAgICB2aWV3LndpdGhpblRhcmdldHMocGh4VGFyZ2V0LCAodGFyZ2V0VmlldywgdGFyZ2V0Q3R4KSA9PiB7XG4gICAgICBpZihldmVudFR5cGUgPT09IFwiY2hhbmdlXCIpe1xuICAgICAgICBsZXQge25ld0NpZCwgX3RhcmdldCwgY2FsbGJhY2t9ID0gYXJnc1xuICAgICAgICBfdGFyZ2V0ID0gX3RhcmdldCB8fCAoc291cmNlRWwgaW5zdGFuY2VvZiBIVE1MSW5wdXRFbGVtZW50ID8gc291cmNlRWwubmFtZSA6IHVuZGVmaW5lZClcbiAgICAgICAgaWYoX3RhcmdldCl7IHB1c2hPcHRzLl90YXJnZXQgPSBfdGFyZ2V0IH1cbiAgICAgICAgdGFyZ2V0Vmlldy5wdXNoSW5wdXQoc291cmNlRWwsIHRhcmdldEN0eCwgbmV3Q2lkLCBldmVudCB8fCBwaHhFdmVudCwgcHVzaE9wdHMsIGNhbGxiYWNrKVxuICAgICAgfSBlbHNlIGlmKGV2ZW50VHlwZSA9PT0gXCJzdWJtaXRcIil7XG4gICAgICAgIHRhcmdldFZpZXcuc3VibWl0Rm9ybShzb3VyY2VFbCwgdGFyZ2V0Q3R4LCBldmVudCB8fCBwaHhFdmVudCwgcHVzaE9wdHMpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0YXJnZXRWaWV3LnB1c2hFdmVudChldmVudFR5cGUsIHNvdXJjZUVsLCB0YXJnZXRDdHgsIGV2ZW50IHx8IHBoeEV2ZW50LCBkYXRhLCBwdXNoT3B0cylcbiAgICAgIH1cbiAgICB9KVxuICB9LFxuXG4gIGV4ZWNfYWRkX2NsYXNzKGV2ZW50VHlwZSwgcGh4RXZlbnQsIHZpZXcsIHNvdXJjZUVsLCBlbCwge25hbWVzLCB0cmFuc2l0aW9uLCB0aW1lfSl7XG4gICAgdGhpcy5hZGRPclJlbW92ZUNsYXNzZXMoZWwsIG5hbWVzLCBbXSwgdHJhbnNpdGlvbiwgdGltZSwgdmlldylcbiAgfSxcblxuICBleGVjX3JlbW92ZV9jbGFzcyhldmVudFR5cGUsIHBoeEV2ZW50LCB2aWV3LCBzb3VyY2VFbCwgZWwsIHtuYW1lcywgdHJhbnNpdGlvbiwgdGltZX0pe1xuICAgIHRoaXMuYWRkT3JSZW1vdmVDbGFzc2VzKGVsLCBbXSwgbmFtZXMsIHRyYW5zaXRpb24sIHRpbWUsIHZpZXcpXG4gIH0sXG5cbiAgZXhlY190cmFuc2l0aW9uKGV2ZW50VHlwZSwgcGh4RXZlbnQsIHZpZXcsIHNvdXJjZUVsLCBlbCwge3RpbWUsIHRyYW5zaXRpb259KXtcbiAgICBsZXQgW3RyYW5zaXRpb25fc3RhcnQsIHJ1bm5pbmcsIHRyYW5zaXRpb25fZW5kXSA9IHRyYW5zaXRpb25cbiAgICBsZXQgb25TdGFydCA9ICgpID0+IHRoaXMuYWRkT3JSZW1vdmVDbGFzc2VzKGVsLCB0cmFuc2l0aW9uX3N0YXJ0LmNvbmNhdChydW5uaW5nKSwgW10pXG4gICAgbGV0IG9uRG9uZSA9ICgpID0+IHRoaXMuYWRkT3JSZW1vdmVDbGFzc2VzKGVsLCB0cmFuc2l0aW9uX2VuZCwgdHJhbnNpdGlvbl9zdGFydC5jb25jYXQocnVubmluZykpXG4gICAgdmlldy50cmFuc2l0aW9uKHRpbWUsIG9uU3RhcnQsIG9uRG9uZSlcbiAgfSxcblxuICBleGVjX3RvZ2dsZShldmVudFR5cGUsIHBoeEV2ZW50LCB2aWV3LCBzb3VyY2VFbCwgZWwsIHtkaXNwbGF5LCBpbnMsIG91dHMsIHRpbWV9KXtcbiAgICB0aGlzLnRvZ2dsZShldmVudFR5cGUsIHZpZXcsIGVsLCBkaXNwbGF5LCBpbnMsIG91dHMsIHRpbWUpXG4gIH0sXG5cbiAgZXhlY19zaG93KGV2ZW50VHlwZSwgcGh4RXZlbnQsIHZpZXcsIHNvdXJjZUVsLCBlbCwge2Rpc3BsYXksIHRyYW5zaXRpb24sIHRpbWV9KXtcbiAgICB0aGlzLnNob3coZXZlbnRUeXBlLCB2aWV3LCBlbCwgZGlzcGxheSwgdHJhbnNpdGlvbiwgdGltZSlcbiAgfSxcblxuICBleGVjX2hpZGUoZXZlbnRUeXBlLCBwaHhFdmVudCwgdmlldywgc291cmNlRWwsIGVsLCB7ZGlzcGxheSwgdHJhbnNpdGlvbiwgdGltZX0pe1xuICAgIHRoaXMuaGlkZShldmVudFR5cGUsIHZpZXcsIGVsLCBkaXNwbGF5LCB0cmFuc2l0aW9uLCB0aW1lKVxuICB9LFxuXG4gIGV4ZWNfc2V0X2F0dHIoZXZlbnRUeXBlLCBwaHhFdmVudCwgdmlldywgc291cmNlRWwsIGVsLCB7YXR0cjogW2F0dHIsIHZhbF19KXtcbiAgICB0aGlzLnNldE9yUmVtb3ZlQXR0cnMoZWwsIFtbYXR0ciwgdmFsXV0sIFtdKVxuICB9LFxuXG4gIGV4ZWNfcmVtb3ZlX2F0dHIoZXZlbnRUeXBlLCBwaHhFdmVudCwgdmlldywgc291cmNlRWwsIGVsLCB7YXR0cn0pe1xuICAgIHRoaXMuc2V0T3JSZW1vdmVBdHRycyhlbCwgW10sIFthdHRyXSlcbiAgfSxcblxuICAvLyB1dGlscyBmb3IgY29tbWFuZHNcblxuICBzaG93KGV2ZW50VHlwZSwgdmlldywgZWwsIGRpc3BsYXksIHRyYW5zaXRpb24sIHRpbWUpe1xuICAgIGlmKCF0aGlzLmlzVmlzaWJsZShlbCkpe1xuICAgICAgdGhpcy50b2dnbGUoZXZlbnRUeXBlLCB2aWV3LCBlbCwgZGlzcGxheSwgdHJhbnNpdGlvbiwgbnVsbCwgdGltZSlcbiAgICB9XG4gIH0sXG5cbiAgaGlkZShldmVudFR5cGUsIHZpZXcsIGVsLCBkaXNwbGF5LCB0cmFuc2l0aW9uLCB0aW1lKXtcbiAgICBpZih0aGlzLmlzVmlzaWJsZShlbCkpe1xuICAgICAgdGhpcy50b2dnbGUoZXZlbnRUeXBlLCB2aWV3LCBlbCwgZGlzcGxheSwgbnVsbCwgdHJhbnNpdGlvbiwgdGltZSlcbiAgICB9XG4gIH0sXG5cbiAgdG9nZ2xlKGV2ZW50VHlwZSwgdmlldywgZWwsIGRpc3BsYXksIGlucywgb3V0cywgdGltZSl7XG4gICAgbGV0IFtpbkNsYXNzZXMsIGluU3RhcnRDbGFzc2VzLCBpbkVuZENsYXNzZXNdID0gaW5zIHx8IFtbXSwgW10sIFtdXVxuICAgIGxldCBbb3V0Q2xhc3Nlcywgb3V0U3RhcnRDbGFzc2VzLCBvdXRFbmRDbGFzc2VzXSA9IG91dHMgfHwgW1tdLCBbXSwgW11dXG4gICAgaWYoaW5DbGFzc2VzLmxlbmd0aCA+IDAgfHwgb3V0Q2xhc3Nlcy5sZW5ndGggPiAwKXtcbiAgICAgIGlmKHRoaXMuaXNWaXNpYmxlKGVsKSl7XG4gICAgICAgIGxldCBvblN0YXJ0ID0gKCkgPT4ge1xuICAgICAgICAgIHRoaXMuYWRkT3JSZW1vdmVDbGFzc2VzKGVsLCBvdXRTdGFydENsYXNzZXMsIGluQ2xhc3Nlcy5jb25jYXQoaW5TdGFydENsYXNzZXMpLmNvbmNhdChpbkVuZENsYXNzZXMpKVxuICAgICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5hZGRPclJlbW92ZUNsYXNzZXMoZWwsIG91dENsYXNzZXMsIFtdKVxuICAgICAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB0aGlzLmFkZE9yUmVtb3ZlQ2xhc3NlcyhlbCwgb3V0RW5kQ2xhc3Nlcywgb3V0U3RhcnRDbGFzc2VzKSlcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICAgIGVsLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KFwicGh4OmhpZGUtc3RhcnRcIikpXG4gICAgICAgIHZpZXcudHJhbnNpdGlvbih0aW1lLCBvblN0YXJ0LCAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5hZGRPclJlbW92ZUNsYXNzZXMoZWwsIFtdLCBvdXRDbGFzc2VzLmNvbmNhdChvdXRFbmRDbGFzc2VzKSlcbiAgICAgICAgICBET00ucHV0U3RpY2t5KGVsLCBcInRvZ2dsZVwiLCBjdXJyZW50RWwgPT4gY3VycmVudEVsLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIilcbiAgICAgICAgICBlbC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChcInBoeDpoaWRlLWVuZFwiKSlcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmKGV2ZW50VHlwZSA9PT0gXCJyZW1vdmVcIil7IHJldHVybiB9XG4gICAgICAgIGxldCBvblN0YXJ0ID0gKCkgPT4ge1xuICAgICAgICAgIHRoaXMuYWRkT3JSZW1vdmVDbGFzc2VzKGVsLCBpblN0YXJ0Q2xhc3Nlcywgb3V0Q2xhc3Nlcy5jb25jYXQob3V0U3RhcnRDbGFzc2VzKS5jb25jYXQob3V0RW5kQ2xhc3NlcykpXG4gICAgICAgICAgRE9NLnB1dFN0aWNreShlbCwgXCJ0b2dnbGVcIiwgY3VycmVudEVsID0+IGN1cnJlbnRFbC5zdHlsZS5kaXNwbGF5ID0gKGRpc3BsYXkgfHwgXCJibG9ja1wiKSlcbiAgICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuYWRkT3JSZW1vdmVDbGFzc2VzKGVsLCBpbkNsYXNzZXMsIFtdKVxuICAgICAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB0aGlzLmFkZE9yUmVtb3ZlQ2xhc3NlcyhlbCwgaW5FbmRDbGFzc2VzLCBpblN0YXJ0Q2xhc3NlcykpXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgICBlbC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChcInBoeDpzaG93LXN0YXJ0XCIpKVxuICAgICAgICB2aWV3LnRyYW5zaXRpb24odGltZSwgb25TdGFydCwgKCkgPT4ge1xuICAgICAgICAgIHRoaXMuYWRkT3JSZW1vdmVDbGFzc2VzKGVsLCBbXSwgaW5DbGFzc2VzLmNvbmNhdChpbkVuZENsYXNzZXMpKVxuICAgICAgICAgIGVsLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KFwicGh4OnNob3ctZW5kXCIpKVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZih0aGlzLmlzVmlzaWJsZShlbCkpe1xuICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICBlbC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChcInBoeDpoaWRlLXN0YXJ0XCIpKVxuICAgICAgICAgIERPTS5wdXRTdGlja3koZWwsIFwidG9nZ2xlXCIsIGN1cnJlbnRFbCA9PiBjdXJyZW50RWwuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiKVxuICAgICAgICAgIGVsLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KFwicGh4OmhpZGUtZW5kXCIpKVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgZWwuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoXCJwaHg6c2hvdy1zdGFydFwiKSlcbiAgICAgICAgICBET00ucHV0U3RpY2t5KGVsLCBcInRvZ2dsZVwiLCBjdXJyZW50RWwgPT4gY3VycmVudEVsLnN0eWxlLmRpc3BsYXkgPSBkaXNwbGF5IHx8IFwiYmxvY2tcIilcbiAgICAgICAgICBlbC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChcInBoeDpzaG93LWVuZFwiKSlcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgYWRkT3JSZW1vdmVDbGFzc2VzKGVsLCBhZGRzLCByZW1vdmVzLCB0cmFuc2l0aW9uLCB0aW1lLCB2aWV3KXtcbiAgICBsZXQgW3RyYW5zaXRpb25fcnVuLCB0cmFuc2l0aW9uX3N0YXJ0LCB0cmFuc2l0aW9uX2VuZF0gPSB0cmFuc2l0aW9uIHx8IFtbXSwgW10sIFtdXVxuICAgIGlmKHRyYW5zaXRpb25fcnVuLmxlbmd0aCA+IDApe1xuICAgICAgbGV0IG9uU3RhcnQgPSAoKSA9PiB0aGlzLmFkZE9yUmVtb3ZlQ2xhc3NlcyhlbCwgdHJhbnNpdGlvbl9zdGFydC5jb25jYXQodHJhbnNpdGlvbl9ydW4pLCBbXSlcbiAgICAgIGxldCBvbkRvbmUgPSAoKSA9PiB0aGlzLmFkZE9yUmVtb3ZlQ2xhc3NlcyhlbCwgYWRkcy5jb25jYXQodHJhbnNpdGlvbl9lbmQpLCByZW1vdmVzLmNvbmNhdCh0cmFuc2l0aW9uX3J1bikuY29uY2F0KHRyYW5zaXRpb25fc3RhcnQpKVxuICAgICAgcmV0dXJuIHZpZXcudHJhbnNpdGlvbih0aW1lLCBvblN0YXJ0LCBvbkRvbmUpXG4gICAgfVxuICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgbGV0IFtwcmV2QWRkcywgcHJldlJlbW92ZXNdID0gRE9NLmdldFN0aWNreShlbCwgXCJjbGFzc2VzXCIsIFtbXSwgW11dKVxuICAgICAgbGV0IGtlZXBBZGRzID0gYWRkcy5maWx0ZXIobmFtZSA9PiBwcmV2QWRkcy5pbmRleE9mKG5hbWUpIDwgMCAmJiAhZWwuY2xhc3NMaXN0LmNvbnRhaW5zKG5hbWUpKVxuICAgICAgbGV0IGtlZXBSZW1vdmVzID0gcmVtb3Zlcy5maWx0ZXIobmFtZSA9PiBwcmV2UmVtb3Zlcy5pbmRleE9mKG5hbWUpIDwgMCAmJiBlbC5jbGFzc0xpc3QuY29udGFpbnMobmFtZSkpXG4gICAgICBsZXQgbmV3QWRkcyA9IHByZXZBZGRzLmZpbHRlcihuYW1lID0+IHJlbW92ZXMuaW5kZXhPZihuYW1lKSA8IDApLmNvbmNhdChrZWVwQWRkcylcbiAgICAgIGxldCBuZXdSZW1vdmVzID0gcHJldlJlbW92ZXMuZmlsdGVyKG5hbWUgPT4gYWRkcy5pbmRleE9mKG5hbWUpIDwgMCkuY29uY2F0KGtlZXBSZW1vdmVzKVxuXG4gICAgICBET00ucHV0U3RpY2t5KGVsLCBcImNsYXNzZXNcIiwgY3VycmVudEVsID0+IHtcbiAgICAgICAgY3VycmVudEVsLmNsYXNzTGlzdC5yZW1vdmUoLi4ubmV3UmVtb3ZlcylcbiAgICAgICAgY3VycmVudEVsLmNsYXNzTGlzdC5hZGQoLi4ubmV3QWRkcylcbiAgICAgICAgcmV0dXJuIFtuZXdBZGRzLCBuZXdSZW1vdmVzXVxuICAgICAgfSlcbiAgICB9KVxuICB9LFxuXG4gIHNldE9yUmVtb3ZlQXR0cnMoZWwsIHNldHMsIHJlbW92ZXMpe1xuICAgIGxldCBbcHJldlNldHMsIHByZXZSZW1vdmVzXSA9IERPTS5nZXRTdGlja3koZWwsIFwiYXR0cnNcIiwgW1tdLCBbXV0pXG5cbiAgICBsZXQgYWx0ZXJlZEF0dHJzID0gc2V0cy5tYXAoKFthdHRyLCBfdmFsXSkgPT4gYXR0cikuY29uY2F0KHJlbW92ZXMpO1xuICAgIGxldCBuZXdTZXRzID0gcHJldlNldHMuZmlsdGVyKChbYXR0ciwgX3ZhbF0pID0+ICFhbHRlcmVkQXR0cnMuaW5jbHVkZXMoYXR0cikpLmNvbmNhdChzZXRzKTtcbiAgICBsZXQgbmV3UmVtb3ZlcyA9IHByZXZSZW1vdmVzLmZpbHRlcigoYXR0cikgPT4gIWFsdGVyZWRBdHRycy5pbmNsdWRlcyhhdHRyKSkuY29uY2F0KHJlbW92ZXMpO1xuXG4gICAgRE9NLnB1dFN0aWNreShlbCwgXCJhdHRyc1wiLCBjdXJyZW50RWwgPT4ge1xuICAgICAgbmV3UmVtb3Zlcy5mb3JFYWNoKGF0dHIgPT4gY3VycmVudEVsLnJlbW92ZUF0dHJpYnV0ZShhdHRyKSlcbiAgICAgIG5ld1NldHMuZm9yRWFjaCgoW2F0dHIsIHZhbF0pID0+IGN1cnJlbnRFbC5zZXRBdHRyaWJ1dGUoYXR0ciwgdmFsKSlcbiAgICAgIHJldHVybiBbbmV3U2V0cywgbmV3UmVtb3Zlc11cbiAgICB9KVxuICB9LFxuXG4gIGhhc0FsbENsYXNzZXMoZWwsIGNsYXNzZXMpeyByZXR1cm4gY2xhc3Nlcy5ldmVyeShuYW1lID0+IGVsLmNsYXNzTGlzdC5jb250YWlucyhuYW1lKSkgfSxcblxuICBpc1RvZ2dsZWRPdXQoZWwsIG91dENsYXNzZXMpe1xuICAgIHJldHVybiAhdGhpcy5pc1Zpc2libGUoZWwpIHx8IHRoaXMuaGFzQWxsQ2xhc3NlcyhlbCwgb3V0Q2xhc3NlcylcbiAgfSxcblxuICBmaWx0ZXJUb0Vscyhzb3VyY2VFbCwge3RvfSl7XG4gICAgcmV0dXJuIHRvID8gRE9NLmFsbChkb2N1bWVudCwgdG8pIDogW3NvdXJjZUVsXVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEpTXG4iLCAiaW1wb3J0IHtcbiAgQkVGT1JFX1VOTE9BRF9MT0FERVJfVElNRU9VVCxcbiAgQ0hFQ0tBQkxFX0lOUFVUUyxcbiAgQ09OU0VDVVRJVkVfUkVMT0FEUyxcbiAgUEhYX0FVVE9fUkVDT1ZFUixcbiAgUEhYX0NPTVBPTkVOVCxcbiAgUEhYX0NPTk5FQ1RFRF9DTEFTUyxcbiAgUEhYX0RJU0FCTEVfV0lUSCxcbiAgUEhYX0RJU0FCTEVfV0lUSF9SRVNUT1JFLFxuICBQSFhfRElTQUJMRUQsXG4gIFBIWF9ESVNDT05ORUNURURfQ0xBU1MsXG4gIFBIWF9FVkVOVF9DTEFTU0VTLFxuICBQSFhfRVJST1JfQ0xBU1MsXG4gIFBIWF9GRUVEQkFDS19GT1IsXG4gIFBIWF9IQVNfU1VCTUlUVEVELFxuICBQSFhfSE9PSyxcbiAgUEhYX1BBR0VfTE9BRElORyxcbiAgUEhYX1BBUkVOVF9JRCxcbiAgUEhYX1BST0dSRVNTLFxuICBQSFhfUkVBRE9OTFksXG4gIFBIWF9SRUYsXG4gIFBIWF9SRUZfU1JDLFxuICBQSFhfUk9PVF9JRCxcbiAgUEhYX1NFU1NJT04sXG4gIFBIWF9TVEFUSUMsXG4gIFBIWF9UUkFDS19TVEFUSUMsXG4gIFBIWF9UUkFDS19VUExPQURTLFxuICBQSFhfVVBEQVRFLFxuICBQSFhfVVBMT0FEX1JFRixcbiAgUEhYX1ZJRVdfU0VMRUNUT1IsXG4gIFBVU0hfVElNRU9VVCxcbiAgUEhYX01BSU4sXG59IGZyb20gXCIuL2NvbnN0YW50c1wiXG5cbmltcG9ydCB7XG4gIGNsb25lLFxuICBjbG9zZXN0UGh4QmluZGluZyxcbiAgaXNFbXB0eSxcbiAgaXNFcXVhbE9iaixcbiAgbG9nRXJyb3IsXG4gIG1heWJlLFxuICBpc0NpZCxcbn0gZnJvbSBcIi4vdXRpbHNcIlxuXG5pbXBvcnQgQnJvd3NlciBmcm9tIFwiLi9icm93c2VyXCJcbmltcG9ydCBET00gZnJvbSBcIi4vZG9tXCJcbmltcG9ydCBET01QYXRjaCBmcm9tIFwiLi9kb21fcGF0Y2hcIlxuaW1wb3J0IExpdmVVcGxvYWRlciBmcm9tIFwiLi9saXZlX3VwbG9hZGVyXCJcbmltcG9ydCBSZW5kZXJlZCBmcm9tIFwiLi9yZW5kZXJlZFwiXG5pbXBvcnQgVmlld0hvb2sgZnJvbSBcIi4vdmlld19ob29rXCJcbmltcG9ydCBKUyBmcm9tIFwiLi9qc1wiXG5cbmxldCBzZXJpYWxpemVGb3JtID0gKGZvcm0sIG1ldGEsIG9ubHlOYW1lcyA9IFtdKSA9PiB7XG4gIGxldCBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YShmb3JtKVxuICBsZXQgdG9SZW1vdmUgPSBbXVxuXG4gIGZvcm1EYXRhLmZvckVhY2goKHZhbCwga2V5LCBfaW5kZXgpID0+IHtcbiAgICBpZih2YWwgaW5zdGFuY2VvZiBGaWxlKXsgdG9SZW1vdmUucHVzaChrZXkpIH1cbiAgfSlcblxuICAvLyBDbGVhbnVwIGFmdGVyIGJ1aWxkaW5nIGZpbGVEYXRhXG4gIHRvUmVtb3ZlLmZvckVhY2goa2V5ID0+IGZvcm1EYXRhLmRlbGV0ZShrZXkpKVxuXG4gIGxldCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKClcbiAgZm9yKGxldCBba2V5LCB2YWxdIG9mIGZvcm1EYXRhLmVudHJpZXMoKSl7XG4gICAgaWYob25seU5hbWVzLmxlbmd0aCA9PT0gMCB8fCBvbmx5TmFtZXMuaW5kZXhPZihrZXkpID49IDApe1xuICAgICAgcGFyYW1zLmFwcGVuZChrZXksIHZhbClcbiAgICB9XG4gIH1cbiAgZm9yKGxldCBtZXRhS2V5IGluIG1ldGEpeyBwYXJhbXMuYXBwZW5kKG1ldGFLZXksIG1ldGFbbWV0YUtleV0pIH1cblxuICByZXR1cm4gcGFyYW1zLnRvU3RyaW5nKClcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVmlldyB7XG4gIGNvbnN0cnVjdG9yKGVsLCBsaXZlU29ja2V0LCBwYXJlbnRWaWV3LCBmbGFzaCl7XG4gICAgdGhpcy5saXZlU29ja2V0ID0gbGl2ZVNvY2tldFxuICAgIHRoaXMuZmxhc2ggPSBmbGFzaFxuICAgIHRoaXMucGFyZW50ID0gcGFyZW50Vmlld1xuICAgIHRoaXMucm9vdCA9IHBhcmVudFZpZXcgPyBwYXJlbnRWaWV3LnJvb3QgOiB0aGlzXG4gICAgdGhpcy5lbCA9IGVsXG4gICAgdGhpcy5pZCA9IHRoaXMuZWwuaWRcbiAgICB0aGlzLnJlZiA9IDBcbiAgICB0aGlzLmNoaWxkSm9pbnMgPSAwXG4gICAgdGhpcy5sb2FkZXJUaW1lciA9IG51bGxcbiAgICB0aGlzLnBlbmRpbmdEaWZmcyA9IFtdXG4gICAgdGhpcy5wcnVuaW5nQ0lEcyA9IFtdXG4gICAgdGhpcy5yZWRpcmVjdCA9IGZhbHNlXG4gICAgdGhpcy5ocmVmID0gbnVsbFxuICAgIHRoaXMuam9pbkNvdW50ID0gdGhpcy5wYXJlbnQgPyB0aGlzLnBhcmVudC5qb2luQ291bnQgLSAxIDogMFxuICAgIHRoaXMuam9pblBlbmRpbmcgPSB0cnVlXG4gICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZVxuICAgIHRoaXMuam9pbkNhbGxiYWNrID0gZnVuY3Rpb24ob25Eb25lKXsgb25Eb25lICYmIG9uRG9uZSgpIH1cbiAgICB0aGlzLnN0b3BDYWxsYmFjayA9IGZ1bmN0aW9uKCl7IH1cbiAgICB0aGlzLnBlbmRpbmdKb2luT3BzID0gdGhpcy5wYXJlbnQgPyBudWxsIDogW11cbiAgICB0aGlzLnZpZXdIb29rcyA9IHt9XG4gICAgdGhpcy51cGxvYWRlcnMgPSB7fVxuICAgIHRoaXMuZm9ybVN1Ym1pdHMgPSBbXVxuICAgIHRoaXMuY2hpbGRyZW4gPSB0aGlzLnBhcmVudCA/IG51bGwgOiB7fVxuICAgIHRoaXMucm9vdC5jaGlsZHJlblt0aGlzLmlkXSA9IHt9XG4gICAgdGhpcy5jaGFubmVsID0gdGhpcy5saXZlU29ja2V0LmNoYW5uZWwoYGx2OiR7dGhpcy5pZH1gLCAoKSA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZWRpcmVjdDogdGhpcy5yZWRpcmVjdCA/IHRoaXMuaHJlZiA6IHVuZGVmaW5lZCxcbiAgICAgICAgdXJsOiB0aGlzLnJlZGlyZWN0ID8gdW5kZWZpbmVkIDogdGhpcy5ocmVmIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgcGFyYW1zOiB0aGlzLmNvbm5lY3RQYXJhbXMoKSxcbiAgICAgICAgc2Vzc2lvbjogdGhpcy5nZXRTZXNzaW9uKCksXG4gICAgICAgIHN0YXRpYzogdGhpcy5nZXRTdGF0aWMoKSxcbiAgICAgICAgZmxhc2g6IHRoaXMuZmxhc2hcbiAgICAgIH1cbiAgICB9KVxuICAgIHRoaXMuc2hvd0xvYWRlcih0aGlzLmxpdmVTb2NrZXQubG9hZGVyVGltZW91dClcbiAgICB0aGlzLmJpbmRDaGFubmVsKClcbiAgfVxuXG4gIHNldEhyZWYoaHJlZil7IHRoaXMuaHJlZiA9IGhyZWYgfVxuXG4gIHNldFJlZGlyZWN0KGhyZWYpe1xuICAgIHRoaXMucmVkaXJlY3QgPSB0cnVlXG4gICAgdGhpcy5ocmVmID0gaHJlZlxuICB9XG5cbiAgaXNNYWluKCl7IHJldHVybiB0aGlzLmVsLmdldEF0dHJpYnV0ZShQSFhfTUFJTikgIT09IG51bGwgfVxuXG4gIGNvbm5lY3RQYXJhbXMoKXtcbiAgICBsZXQgcGFyYW1zID0gdGhpcy5saXZlU29ja2V0LnBhcmFtcyh0aGlzLmVsKVxuICAgIGxldCBtYW5pZmVzdCA9XG4gICAgICBET00uYWxsKGRvY3VtZW50LCBgWyR7dGhpcy5iaW5kaW5nKFBIWF9UUkFDS19TVEFUSUMpfV1gKVxuICAgICAgICAubWFwKG5vZGUgPT4gbm9kZS5zcmMgfHwgbm9kZS5ocmVmKS5maWx0ZXIodXJsID0+IHR5cGVvZiAodXJsKSA9PT0gXCJzdHJpbmdcIilcblxuICAgIGlmKG1hbmlmZXN0Lmxlbmd0aCA+IDApeyBwYXJhbXNbXCJfdHJhY2tfc3RhdGljXCJdID0gbWFuaWZlc3QgfVxuICAgIHBhcmFtc1tcIl9tb3VudHNcIl0gPSB0aGlzLmpvaW5Db3VudFxuXG4gICAgcmV0dXJuIHBhcmFtc1xuICB9XG5cbiAgaXNDb25uZWN0ZWQoKXsgcmV0dXJuIHRoaXMuY2hhbm5lbC5jYW5QdXNoKCkgfVxuXG4gIGdldFNlc3Npb24oKXsgcmV0dXJuIHRoaXMuZWwuZ2V0QXR0cmlidXRlKFBIWF9TRVNTSU9OKSB9XG5cbiAgZ2V0U3RhdGljKCl7XG4gICAgbGV0IHZhbCA9IHRoaXMuZWwuZ2V0QXR0cmlidXRlKFBIWF9TVEFUSUMpXG4gICAgcmV0dXJuIHZhbCA9PT0gXCJcIiA/IG51bGwgOiB2YWxcbiAgfVxuXG4gIGRlc3Ryb3koY2FsbGJhY2sgPSBmdW5jdGlvbiAoKXsgfSl7XG4gICAgdGhpcy5kZXN0cm95QWxsQ2hpbGRyZW4oKVxuICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZVxuICAgIGRlbGV0ZSB0aGlzLnJvb3QuY2hpbGRyZW5bdGhpcy5pZF1cbiAgICBpZih0aGlzLnBhcmVudCl7IGRlbGV0ZSB0aGlzLnJvb3QuY2hpbGRyZW5bdGhpcy5wYXJlbnQuaWRdW3RoaXMuaWRdIH1cbiAgICBjbGVhclRpbWVvdXQodGhpcy5sb2FkZXJUaW1lcilcbiAgICBsZXQgb25GaW5pc2hlZCA9ICgpID0+IHtcbiAgICAgIGNhbGxiYWNrKClcbiAgICAgIGZvcihsZXQgaWQgaW4gdGhpcy52aWV3SG9va3Mpe1xuICAgICAgICB0aGlzLmRlc3Ryb3lIb29rKHRoaXMudmlld0hvb2tzW2lkXSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICBET00ubWFya1BoeENoaWxkRGVzdHJveWVkKHRoaXMuZWwpXG5cbiAgICB0aGlzLmxvZyhcImRlc3Ryb3llZFwiLCAoKSA9PiBbXCJ0aGUgY2hpbGQgaGFzIGJlZW4gcmVtb3ZlZCBmcm9tIHRoZSBwYXJlbnRcIl0pXG4gICAgdGhpcy5jaGFubmVsLmxlYXZlKClcbiAgICAgIC5yZWNlaXZlKFwib2tcIiwgb25GaW5pc2hlZClcbiAgICAgIC5yZWNlaXZlKFwiZXJyb3JcIiwgb25GaW5pc2hlZClcbiAgICAgIC5yZWNlaXZlKFwidGltZW91dFwiLCBvbkZpbmlzaGVkKVxuICB9XG5cbiAgc2V0Q29udGFpbmVyQ2xhc3NlcyguLi5jbGFzc2VzKXtcbiAgICB0aGlzLmVsLmNsYXNzTGlzdC5yZW1vdmUoXG4gICAgICBQSFhfQ09OTkVDVEVEX0NMQVNTLFxuICAgICAgUEhYX0RJU0NPTk5FQ1RFRF9DTEFTUyxcbiAgICAgIFBIWF9FUlJPUl9DTEFTU1xuICAgIClcbiAgICB0aGlzLmVsLmNsYXNzTGlzdC5hZGQoLi4uY2xhc3NlcylcbiAgfVxuXG4gIHNob3dMb2FkZXIodGltZW91dCl7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMubG9hZGVyVGltZXIpXG4gICAgaWYodGltZW91dCl7XG4gICAgICB0aGlzLmxvYWRlclRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB0aGlzLnNob3dMb2FkZXIoKSwgdGltZW91dClcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yKGxldCBpZCBpbiB0aGlzLnZpZXdIb29rcyl7IHRoaXMudmlld0hvb2tzW2lkXS5fX2Rpc2Nvbm5lY3RlZCgpIH1cbiAgICAgIHRoaXMuc2V0Q29udGFpbmVyQ2xhc3NlcyhQSFhfRElTQ09OTkVDVEVEX0NMQVNTKVxuICAgIH1cbiAgfVxuXG4gIGhpZGVMb2FkZXIoKXtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5sb2FkZXJUaW1lcilcbiAgICB0aGlzLnNldENvbnRhaW5lckNsYXNzZXMoUEhYX0NPTk5FQ1RFRF9DTEFTUylcbiAgfVxuXG4gIHRyaWdnZXJSZWNvbm5lY3RlZCgpe1xuICAgIGZvcihsZXQgaWQgaW4gdGhpcy52aWV3SG9va3MpeyB0aGlzLnZpZXdIb29rc1tpZF0uX19yZWNvbm5lY3RlZCgpIH1cbiAgfVxuXG4gIGxvZyhraW5kLCBtc2dDYWxsYmFjayl7XG4gICAgdGhpcy5saXZlU29ja2V0LmxvZyh0aGlzLCBraW5kLCBtc2dDYWxsYmFjaylcbiAgfVxuXG4gIHRyYW5zaXRpb24odGltZSwgb25TdGFydCwgb25Eb25lID0gZnVuY3Rpb24oKXt9KXtcbiAgICB0aGlzLmxpdmVTb2NrZXQudHJhbnNpdGlvbih0aW1lLCBvblN0YXJ0LCBvbkRvbmUpXG4gIH1cblxuICB3aXRoaW5UYXJnZXRzKHBoeFRhcmdldCwgY2FsbGJhY2spe1xuICAgIGlmKHBoeFRhcmdldCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50IHx8IHBoeFRhcmdldCBpbnN0YW5jZW9mIFNWR0VsZW1lbnQpe1xuICAgICAgcmV0dXJuIHRoaXMubGl2ZVNvY2tldC5vd25lcihwaHhUYXJnZXQsIHZpZXcgPT4gY2FsbGJhY2sodmlldywgcGh4VGFyZ2V0KSlcbiAgICB9XG5cbiAgICBpZihpc0NpZChwaHhUYXJnZXQpKXtcbiAgICAgIGxldCB0YXJnZXRzID0gRE9NLmZpbmRDb21wb25lbnROb2RlTGlzdCh0aGlzLmVsLCBwaHhUYXJnZXQpXG4gICAgICBpZih0YXJnZXRzLmxlbmd0aCA9PT0gMCl7XG4gICAgICAgIGxvZ0Vycm9yKGBubyBjb21wb25lbnQgZm91bmQgbWF0Y2hpbmcgcGh4LXRhcmdldCBvZiAke3BoeFRhcmdldH1gKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FsbGJhY2sodGhpcywgcGFyc2VJbnQocGh4VGFyZ2V0KSlcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IHRhcmdldHMgPSBBcnJheS5mcm9tKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwocGh4VGFyZ2V0KSlcbiAgICAgIGlmKHRhcmdldHMubGVuZ3RoID09PSAwKXsgbG9nRXJyb3IoYG5vdGhpbmcgZm91bmQgbWF0Y2hpbmcgdGhlIHBoeC10YXJnZXQgc2VsZWN0b3IgXCIke3BoeFRhcmdldH1cImApIH1cbiAgICAgIHRhcmdldHMuZm9yRWFjaCh0YXJnZXQgPT4gdGhpcy5saXZlU29ja2V0Lm93bmVyKHRhcmdldCwgdmlldyA9PiBjYWxsYmFjayh2aWV3LCB0YXJnZXQpKSlcbiAgICB9XG4gIH1cblxuICBhcHBseURpZmYodHlwZSwgcmF3RGlmZiwgY2FsbGJhY2spe1xuICAgIHRoaXMubG9nKHR5cGUsICgpID0+IFtcIlwiLCBjbG9uZShyYXdEaWZmKV0pXG4gICAgbGV0IHtkaWZmLCByZXBseSwgZXZlbnRzLCB0aXRsZX0gPSBSZW5kZXJlZC5leHRyYWN0KHJhd0RpZmYpXG4gICAgaWYodGl0bGUpeyBET00ucHV0VGl0bGUodGl0bGUpIH1cblxuICAgIGNhbGxiYWNrKHtkaWZmLCByZXBseSwgZXZlbnRzfSlcbiAgICByZXR1cm4gcmVwbHlcbiAgfVxuXG4gIG9uSm9pbihyZXNwKXtcbiAgICBsZXQge3JlbmRlcmVkLCBjb250YWluZXJ9ID0gcmVzcFxuICAgIGlmKGNvbnRhaW5lcil7XG4gICAgICBsZXQgW3RhZywgYXR0cnNdID0gY29udGFpbmVyXG4gICAgICB0aGlzLmVsID0gRE9NLnJlcGxhY2VSb290Q29udGFpbmVyKHRoaXMuZWwsIHRhZywgYXR0cnMpXG4gICAgfVxuICAgIHRoaXMuY2hpbGRKb2lucyA9IDBcbiAgICB0aGlzLmpvaW5QZW5kaW5nID0gdHJ1ZVxuICAgIHRoaXMuZmxhc2ggPSBudWxsXG5cbiAgICBCcm93c2VyLmRyb3BMb2NhbCh0aGlzLmxpdmVTb2NrZXQubG9jYWxTdG9yYWdlLCB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUsIENPTlNFQ1VUSVZFX1JFTE9BRFMpXG4gICAgdGhpcy5hcHBseURpZmYoXCJtb3VudFwiLCByZW5kZXJlZCwgKHtkaWZmLCBldmVudHN9KSA9PiB7XG4gICAgICB0aGlzLnJlbmRlcmVkID0gbmV3IFJlbmRlcmVkKHRoaXMuaWQsIGRpZmYpXG4gICAgICBsZXQgaHRtbCA9IHRoaXMucmVuZGVyQ29udGFpbmVyKG51bGwsIFwiam9pblwiKVxuICAgICAgdGhpcy5kcm9wUGVuZGluZ1JlZnMoKVxuICAgICAgbGV0IGZvcm1zID0gdGhpcy5mb3Jtc0ZvclJlY292ZXJ5KGh0bWwpXG4gICAgICB0aGlzLmpvaW5Db3VudCsrXG5cbiAgICAgIGlmKGZvcm1zLmxlbmd0aCA+IDApe1xuICAgICAgICBmb3Jtcy5mb3JFYWNoKChbZm9ybSwgbmV3Rm9ybSwgbmV3Q2lkXSwgaSkgPT4ge1xuICAgICAgICAgIHRoaXMucHVzaEZvcm1SZWNvdmVyeShmb3JtLCBuZXdDaWQsIHJlc3AgPT4ge1xuICAgICAgICAgICAgaWYoaSA9PT0gZm9ybXMubGVuZ3RoIC0gMSl7XG4gICAgICAgICAgICAgIHRoaXMub25Kb2luQ29tcGxldGUocmVzcCwgaHRtbCwgZXZlbnRzKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm9uSm9pbkNvbXBsZXRlKHJlc3AsIGh0bWwsIGV2ZW50cylcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgZHJvcFBlbmRpbmdSZWZzKCl7XG4gICAgRE9NLmFsbChkb2N1bWVudCwgYFske1BIWF9SRUZfU1JDfT1cIiR7dGhpcy5pZH1cIl1bJHtQSFhfUkVGfV1gLCBlbCA9PiB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoUEhYX1JFRilcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShQSFhfUkVGX1NSQylcbiAgICB9KVxuICB9XG5cbiAgb25Kb2luQ29tcGxldGUoe2xpdmVfcGF0Y2h9LCBodG1sLCBldmVudHMpe1xuICAgIC8vIEluIG9yZGVyIHRvIHByb3ZpZGUgYSBiZXR0ZXIgZXhwZXJpZW5jZSwgd2Ugd2FudCB0byBqb2luXG4gICAgLy8gYWxsIExpdmVWaWV3cyBmaXJzdCBhbmQgb25seSB0aGVuIGFwcGx5IHRoZWlyIHBhdGNoZXMuXG4gICAgaWYodGhpcy5qb2luQ291bnQgPiAxIHx8ICh0aGlzLnBhcmVudCAmJiAhdGhpcy5wYXJlbnQuaXNKb2luUGVuZGluZygpKSl7XG4gICAgICByZXR1cm4gdGhpcy5hcHBseUpvaW5QYXRjaChsaXZlX3BhdGNoLCBodG1sLCBldmVudHMpXG4gICAgfVxuXG4gICAgLy8gT25lIGRvd25zaWRlIG9mIHRoaXMgYXBwcm9hY2ggaXMgdGhhdCB3ZSBuZWVkIHRvIGZpbmQgcGh4Q2hpbGRyZW5cbiAgICAvLyBpbiB0aGUgaHRtbCBmcmFnbWVudCwgaW5zdGVhZCBvZiBkaXJlY3RseSBvbiB0aGUgRE9NLiBUaGUgZnJhZ21lbnRcbiAgICAvLyBhbHNvIGRvZXMgbm90IGluY2x1ZGUgUEhYX1NUQVRJQywgc28gd2UgbmVlZCB0byBjb3B5IGl0IG92ZXIgZnJvbVxuICAgIC8vIHRoZSBET00uXG4gICAgbGV0IG5ld0NoaWxkcmVuID0gRE9NLmZpbmRQaHhDaGlsZHJlbkluRnJhZ21lbnQoaHRtbCwgdGhpcy5pZCkuZmlsdGVyKHRvRWwgPT4ge1xuICAgICAgbGV0IGZyb21FbCA9IHRvRWwuaWQgJiYgdGhpcy5lbC5xdWVyeVNlbGVjdG9yKGBbaWQ9XCIke3RvRWwuaWR9XCJdYClcbiAgICAgIGxldCBwaHhTdGF0aWMgPSBmcm9tRWwgJiYgZnJvbUVsLmdldEF0dHJpYnV0ZShQSFhfU1RBVElDKVxuICAgICAgaWYocGh4U3RhdGljKXsgdG9FbC5zZXRBdHRyaWJ1dGUoUEhYX1NUQVRJQywgcGh4U3RhdGljKSB9XG4gICAgICByZXR1cm4gdGhpcy5qb2luQ2hpbGQodG9FbClcbiAgICB9KVxuXG4gICAgaWYobmV3Q2hpbGRyZW4ubGVuZ3RoID09PSAwKXtcbiAgICAgIGlmKHRoaXMucGFyZW50KXtcbiAgICAgICAgdGhpcy5yb290LnBlbmRpbmdKb2luT3BzLnB1c2goW3RoaXMsICgpID0+IHRoaXMuYXBwbHlKb2luUGF0Y2gobGl2ZV9wYXRjaCwgaHRtbCwgZXZlbnRzKV0pXG4gICAgICAgIHRoaXMucGFyZW50LmFja0pvaW4odGhpcylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMub25BbGxDaGlsZEpvaW5zQ29tcGxldGUoKVxuICAgICAgICB0aGlzLmFwcGx5Sm9pblBhdGNoKGxpdmVfcGF0Y2gsIGh0bWwsIGV2ZW50cylcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yb290LnBlbmRpbmdKb2luT3BzLnB1c2goW3RoaXMsICgpID0+IHRoaXMuYXBwbHlKb2luUGF0Y2gobGl2ZV9wYXRjaCwgaHRtbCwgZXZlbnRzKV0pXG4gICAgfVxuICB9XG5cbiAgYXR0YWNoVHJ1ZURvY0VsKCl7XG4gICAgdGhpcy5lbCA9IERPTS5ieUlkKHRoaXMuaWQpXG4gICAgdGhpcy5lbC5zZXRBdHRyaWJ1dGUoUEhYX1JPT1RfSUQsIHRoaXMucm9vdC5pZClcbiAgfVxuXG4gIGFwcGx5Sm9pblBhdGNoKGxpdmVfcGF0Y2gsIGh0bWwsIGV2ZW50cyl7XG4gICAgdGhpcy5hdHRhY2hUcnVlRG9jRWwoKVxuICAgIGxldCBwYXRjaCA9IG5ldyBET01QYXRjaCh0aGlzLCB0aGlzLmVsLCB0aGlzLmlkLCBodG1sLCBudWxsKVxuICAgIHBhdGNoLm1hcmtQcnVuYWJsZUNvbnRlbnRGb3JSZW1vdmFsKClcbiAgICB0aGlzLnBlcmZvcm1QYXRjaChwYXRjaCwgZmFsc2UpXG4gICAgdGhpcy5qb2luTmV3Q2hpbGRyZW4oKVxuICAgIERPTS5hbGwodGhpcy5lbCwgYFske3RoaXMuYmluZGluZyhQSFhfSE9PSyl9XSwgW2RhdGEtcGh4LSR7UEhYX0hPT0t9XWAsIGhvb2tFbCA9PiB7XG4gICAgICBsZXQgaG9vayA9IHRoaXMuYWRkSG9vayhob29rRWwpXG4gICAgICBpZihob29rKXsgaG9vay5fX21vdW50ZWQoKSB9XG4gICAgfSlcblxuICAgIHRoaXMuam9pblBlbmRpbmcgPSBmYWxzZVxuICAgIHRoaXMubGl2ZVNvY2tldC5kaXNwYXRjaEV2ZW50cyhldmVudHMpXG4gICAgdGhpcy5hcHBseVBlbmRpbmdVcGRhdGVzKClcblxuICAgIGlmKGxpdmVfcGF0Y2gpe1xuICAgICAgbGV0IHtraW5kLCB0b30gPSBsaXZlX3BhdGNoXG4gICAgICB0aGlzLmxpdmVTb2NrZXQuaGlzdG9yeVBhdGNoKHRvLCBraW5kKVxuICAgIH1cbiAgICB0aGlzLmhpZGVMb2FkZXIoKVxuICAgIGlmKHRoaXMuam9pbkNvdW50ID4gMSl7IHRoaXMudHJpZ2dlclJlY29ubmVjdGVkKCkgfVxuICAgIHRoaXMuc3RvcENhbGxiYWNrKClcbiAgfVxuXG4gIHRyaWdnZXJCZWZvcmVVcGRhdGVIb29rKGZyb21FbCwgdG9FbCl7XG4gICAgdGhpcy5saXZlU29ja2V0LnRyaWdnZXJET00oXCJvbkJlZm9yZUVsVXBkYXRlZFwiLCBbZnJvbUVsLCB0b0VsXSlcbiAgICBsZXQgaG9vayA9IHRoaXMuZ2V0SG9vayhmcm9tRWwpXG4gICAgbGV0IGlzSWdub3JlZCA9IGhvb2sgJiYgRE9NLmlzSWdub3JlZChmcm9tRWwsIHRoaXMuYmluZGluZyhQSFhfVVBEQVRFKSlcbiAgICBpZihob29rICYmICFmcm9tRWwuaXNFcXVhbE5vZGUodG9FbCkgJiYgIShpc0lnbm9yZWQgJiYgaXNFcXVhbE9iaihmcm9tRWwuZGF0YXNldCwgdG9FbC5kYXRhc2V0KSkpe1xuICAgICAgaG9vay5fX2JlZm9yZVVwZGF0ZSgpXG4gICAgICByZXR1cm4gaG9va1xuICAgIH1cbiAgfVxuXG4gIHBlcmZvcm1QYXRjaChwYXRjaCwgcHJ1bmVDaWRzKXtcbiAgICBsZXQgcmVtb3ZlZEVscyA9IFtdXG4gICAgbGV0IHBoeENoaWxkcmVuQWRkZWQgPSBmYWxzZVxuICAgIGxldCB1cGRhdGVkSG9va0lkcyA9IG5ldyBTZXQoKVxuXG4gICAgcGF0Y2guYWZ0ZXIoXCJhZGRlZFwiLCBlbCA9PiB7XG4gICAgICB0aGlzLmxpdmVTb2NrZXQudHJpZ2dlckRPTShcIm9uTm9kZUFkZGVkXCIsIFtlbF0pXG5cbiAgICAgIGxldCBuZXdIb29rID0gdGhpcy5hZGRIb29rKGVsKVxuICAgICAgaWYobmV3SG9vayl7IG5ld0hvb2suX19tb3VudGVkKCkgfVxuICAgIH0pXG5cbiAgICBwYXRjaC5hZnRlcihcInBoeENoaWxkQWRkZWRcIiwgZWwgPT4ge1xuICAgICAgaWYoRE9NLmlzUGh4U3RpY2t5KGVsKSl7XG4gICAgICAgIHRoaXMubGl2ZVNvY2tldC5qb2luUm9vdFZpZXdzKClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBoeENoaWxkcmVuQWRkZWQgPSB0cnVlXG4gICAgICB9XG4gICAgfSlcblxuICAgIHBhdGNoLmJlZm9yZShcInVwZGF0ZWRcIiwgKGZyb21FbCwgdG9FbCkgPT4ge1xuICAgICAgbGV0IGhvb2sgPSB0aGlzLnRyaWdnZXJCZWZvcmVVcGRhdGVIb29rKGZyb21FbCwgdG9FbClcbiAgICAgIGlmKGhvb2speyB1cGRhdGVkSG9va0lkcy5hZGQoZnJvbUVsLmlkKSB9XG4gICAgfSlcblxuICAgIHBhdGNoLmFmdGVyKFwidXBkYXRlZFwiLCBlbCA9PiB7XG4gICAgICBpZih1cGRhdGVkSG9va0lkcy5oYXMoZWwuaWQpKXsgdGhpcy5nZXRIb29rKGVsKS5fX3VwZGF0ZWQoKSB9XG4gICAgfSlcblxuICAgIHBhdGNoLmFmdGVyKFwiZGlzY2FyZGVkXCIsIChlbCkgPT4ge1xuICAgICAgaWYoZWwubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFKXsgcmVtb3ZlZEVscy5wdXNoKGVsKSB9XG4gICAgfSlcblxuICAgIHBhdGNoLmFmdGVyKFwidHJhbnNpdGlvbnNEaXNjYXJkZWRcIiwgZWxzID0+IHRoaXMuYWZ0ZXJFbGVtZW50c1JlbW92ZWQoZWxzLCBwcnVuZUNpZHMpKVxuICAgIHBhdGNoLnBlcmZvcm0oKVxuICAgIHRoaXMuYWZ0ZXJFbGVtZW50c1JlbW92ZWQocmVtb3ZlZEVscywgcHJ1bmVDaWRzKVxuXG4gICAgcmV0dXJuIHBoeENoaWxkcmVuQWRkZWRcbiAgfVxuXG4gIGFmdGVyRWxlbWVudHNSZW1vdmVkKGVsZW1lbnRzLCBwcnVuZUNpZHMpe1xuICAgIGxldCBkZXN0cm95ZWRDSURzID0gW11cbiAgICBlbGVtZW50cy5mb3JFYWNoKHBhcmVudCA9PiB7XG4gICAgICBsZXQgY29tcG9uZW50cyA9IERPTS5hbGwocGFyZW50LCBgWyR7UEhYX0NPTVBPTkVOVH1dYClcbiAgICAgIGxldCBob29rcyA9IERPTS5hbGwocGFyZW50LCBgWyR7dGhpcy5iaW5kaW5nKFBIWF9IT09LKX1dYClcbiAgICAgIGNvbXBvbmVudHMuY29uY2F0KHBhcmVudCkuZm9yRWFjaChlbCA9PiB7XG4gICAgICAgIGxldCBjaWQgPSB0aGlzLmNvbXBvbmVudElEKGVsKVxuICAgICAgICBpZihpc0NpZChjaWQpICYmIGRlc3Ryb3llZENJRHMuaW5kZXhPZihjaWQpID09PSAtMSl7IGRlc3Ryb3llZENJRHMucHVzaChjaWQpIH1cbiAgICAgIH0pXG4gICAgICBob29rcy5jb25jYXQocGFyZW50KS5mb3JFYWNoKGhvb2tFbCA9PiB7XG4gICAgICAgIGxldCBob29rID0gdGhpcy5nZXRIb29rKGhvb2tFbClcbiAgICAgICAgaG9vayAmJiB0aGlzLmRlc3Ryb3lIb29rKGhvb2spXG4gICAgICB9KVxuICAgIH0pXG4gICAgLy8gV2Ugc2hvdWxkIG5vdCBwcnVuZUNpZHMgb24gam9pbnMuIE90aGVyd2lzZSwgaW4gY2FzZSBvZlxuICAgIC8vIHJlam9pbnMsIHdlIG1heSBub3RpZnkgY2lkcyB0aGF0IG5vIGxvbmdlciBiZWxvbmcgdG8gdGhlXG4gICAgLy8gY3VycmVudCBMaXZlVmlldyB0byBiZSByZW1vdmVkLlxuICAgIGlmKHBydW5lQ2lkcyl7XG4gICAgICB0aGlzLm1heWJlUHVzaENvbXBvbmVudHNEZXN0cm95ZWQoZGVzdHJveWVkQ0lEcylcbiAgICB9XG4gIH1cblxuICBqb2luTmV3Q2hpbGRyZW4oKXtcbiAgICBET00uZmluZFBoeENoaWxkcmVuKHRoaXMuZWwsIHRoaXMuaWQpLmZvckVhY2goZWwgPT4gdGhpcy5qb2luQ2hpbGQoZWwpKVxuICB9XG5cbiAgZ2V0Q2hpbGRCeUlkKGlkKXsgcmV0dXJuIHRoaXMucm9vdC5jaGlsZHJlblt0aGlzLmlkXVtpZF0gfVxuXG4gIGdldERlc2NlbmRlbnRCeUVsKGVsKXtcbiAgICBpZihlbC5pZCA9PT0gdGhpcy5pZCl7XG4gICAgICByZXR1cm4gdGhpc1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbltlbC5nZXRBdHRyaWJ1dGUoUEhYX1BBUkVOVF9JRCldW2VsLmlkXVxuICAgIH1cbiAgfVxuXG4gIGRlc3Ryb3lEZXNjZW5kZW50KGlkKXtcbiAgICBmb3IobGV0IHBhcmVudElkIGluIHRoaXMucm9vdC5jaGlsZHJlbil7XG4gICAgICBmb3IobGV0IGNoaWxkSWQgaW4gdGhpcy5yb290LmNoaWxkcmVuW3BhcmVudElkXSl7XG4gICAgICAgIGlmKGNoaWxkSWQgPT09IGlkKXsgcmV0dXJuIHRoaXMucm9vdC5jaGlsZHJlbltwYXJlbnRJZF1bY2hpbGRJZF0uZGVzdHJveSgpIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBqb2luQ2hpbGQoZWwpe1xuICAgIGxldCBjaGlsZCA9IHRoaXMuZ2V0Q2hpbGRCeUlkKGVsLmlkKVxuICAgIGlmKCFjaGlsZCl7XG4gICAgICBsZXQgdmlldyA9IG5ldyBWaWV3KGVsLCB0aGlzLmxpdmVTb2NrZXQsIHRoaXMpXG4gICAgICB0aGlzLnJvb3QuY2hpbGRyZW5bdGhpcy5pZF1bdmlldy5pZF0gPSB2aWV3XG4gICAgICB2aWV3LmpvaW4oKVxuICAgICAgdGhpcy5jaGlsZEpvaW5zKytcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG5cbiAgaXNKb2luUGVuZGluZygpeyByZXR1cm4gdGhpcy5qb2luUGVuZGluZyB9XG5cbiAgYWNrSm9pbihfY2hpbGQpe1xuICAgIHRoaXMuY2hpbGRKb2lucy0tXG5cbiAgICBpZih0aGlzLmNoaWxkSm9pbnMgPT09IDApe1xuICAgICAgaWYodGhpcy5wYXJlbnQpe1xuICAgICAgICB0aGlzLnBhcmVudC5hY2tKb2luKHRoaXMpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm9uQWxsQ2hpbGRKb2luc0NvbXBsZXRlKClcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBvbkFsbENoaWxkSm9pbnNDb21wbGV0ZSgpe1xuICAgIHRoaXMuam9pbkNhbGxiYWNrKCgpID0+IHtcbiAgICAgIHRoaXMucGVuZGluZ0pvaW5PcHMuZm9yRWFjaCgoW3ZpZXcsIG9wXSkgPT4ge1xuICAgICAgICBpZighdmlldy5pc0Rlc3Ryb3llZCgpKXsgb3AoKSB9XG4gICAgICB9KVxuICAgICAgdGhpcy5wZW5kaW5nSm9pbk9wcyA9IFtdXG4gICAgfSlcbiAgfVxuXG4gIHVwZGF0ZShkaWZmLCBldmVudHMpe1xuICAgIGlmKHRoaXMuaXNKb2luUGVuZGluZygpIHx8ICh0aGlzLmxpdmVTb2NrZXQuaGFzUGVuZGluZ0xpbmsoKSAmJiAhRE9NLmlzUGh4U3RpY2t5KHRoaXMuZWwpKSl7XG4gICAgICByZXR1cm4gdGhpcy5wZW5kaW5nRGlmZnMucHVzaCh7ZGlmZiwgZXZlbnRzfSlcbiAgICB9XG5cbiAgICB0aGlzLnJlbmRlcmVkLm1lcmdlRGlmZihkaWZmKVxuICAgIGxldCBwaHhDaGlsZHJlbkFkZGVkID0gZmFsc2VcblxuICAgIC8vIFdoZW4gdGhlIGRpZmYgb25seSBjb250YWlucyBjb21wb25lbnQgZGlmZnMsIHRoZW4gd2FsayBjb21wb25lbnRzXG4gICAgLy8gYW5kIHBhdGNoIG9ubHkgdGhlIHBhcmVudCBjb21wb25lbnQgY29udGFpbmVycyBmb3VuZCBpbiB0aGUgZGlmZi5cbiAgICAvLyBPdGhlcndpc2UsIHBhdGNoIGVudGlyZSBMViBjb250YWluZXIuXG4gICAgaWYodGhpcy5yZW5kZXJlZC5pc0NvbXBvbmVudE9ubHlEaWZmKGRpZmYpKXtcbiAgICAgIHRoaXMubGl2ZVNvY2tldC50aW1lKFwiY29tcG9uZW50IHBhdGNoIGNvbXBsZXRlXCIsICgpID0+IHtcbiAgICAgICAgbGV0IHBhcmVudENpZHMgPSBET00uZmluZFBhcmVudENJRHModGhpcy5lbCwgdGhpcy5yZW5kZXJlZC5jb21wb25lbnRDSURzKGRpZmYpKVxuICAgICAgICBwYXJlbnRDaWRzLmZvckVhY2gocGFyZW50Q0lEID0+IHtcbiAgICAgICAgICBpZih0aGlzLmNvbXBvbmVudFBhdGNoKHRoaXMucmVuZGVyZWQuZ2V0Q29tcG9uZW50KGRpZmYsIHBhcmVudENJRCksIHBhcmVudENJRCkpeyBwaHhDaGlsZHJlbkFkZGVkID0gdHJ1ZSB9XG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIH0gZWxzZSBpZighaXNFbXB0eShkaWZmKSl7XG4gICAgICB0aGlzLmxpdmVTb2NrZXQudGltZShcImZ1bGwgcGF0Y2ggY29tcGxldGVcIiwgKCkgPT4ge1xuICAgICAgICBsZXQgaHRtbCA9IHRoaXMucmVuZGVyQ29udGFpbmVyKGRpZmYsIFwidXBkYXRlXCIpXG4gICAgICAgIGxldCBwYXRjaCA9IG5ldyBET01QYXRjaCh0aGlzLCB0aGlzLmVsLCB0aGlzLmlkLCBodG1sLCBudWxsKVxuICAgICAgICBwaHhDaGlsZHJlbkFkZGVkID0gdGhpcy5wZXJmb3JtUGF0Y2gocGF0Y2gsIHRydWUpXG4gICAgICB9KVxuICAgIH1cblxuICAgIHRoaXMubGl2ZVNvY2tldC5kaXNwYXRjaEV2ZW50cyhldmVudHMpXG4gICAgaWYocGh4Q2hpbGRyZW5BZGRlZCl7IHRoaXMuam9pbk5ld0NoaWxkcmVuKCkgfVxuICB9XG5cbiAgcmVuZGVyQ29udGFpbmVyKGRpZmYsIGtpbmQpe1xuICAgIHJldHVybiB0aGlzLmxpdmVTb2NrZXQudGltZShgdG9TdHJpbmcgZGlmZiAoJHtraW5kfSlgLCAoKSA9PiB7XG4gICAgICBsZXQgdGFnID0gdGhpcy5lbC50YWdOYW1lXG4gICAgICAvLyBEb24ndCBza2lwIGFueSBjb21wb25lbnQgaW4gdGhlIGRpZmYgbm9yIGFueSBtYXJrZWQgYXMgcHJ1bmVkXG4gICAgICAvLyAoYXMgdGhleSBtYXkgaGF2ZSBiZWVuIGFkZGVkIGJhY2spXG4gICAgICBsZXQgY2lkcyA9IGRpZmYgPyB0aGlzLnJlbmRlcmVkLmNvbXBvbmVudENJRHMoZGlmZikuY29uY2F0KHRoaXMucHJ1bmluZ0NJRHMpIDogbnVsbFxuICAgICAgbGV0IGh0bWwgPSB0aGlzLnJlbmRlcmVkLnRvU3RyaW5nKGNpZHMpXG4gICAgICByZXR1cm4gYDwke3RhZ30+JHtodG1sfTwvJHt0YWd9PmBcbiAgICB9KVxuICB9XG5cbiAgY29tcG9uZW50UGF0Y2goZGlmZiwgY2lkKXtcbiAgICBpZihpc0VtcHR5KGRpZmYpKSByZXR1cm4gZmFsc2VcbiAgICBsZXQgaHRtbCA9IHRoaXMucmVuZGVyZWQuY29tcG9uZW50VG9TdHJpbmcoY2lkKVxuICAgIGxldCBwYXRjaCA9IG5ldyBET01QYXRjaCh0aGlzLCB0aGlzLmVsLCB0aGlzLmlkLCBodG1sLCBjaWQpXG4gICAgbGV0IGNoaWxkcmVuQWRkZWQgPSB0aGlzLnBlcmZvcm1QYXRjaChwYXRjaCwgdHJ1ZSlcbiAgICByZXR1cm4gY2hpbGRyZW5BZGRlZFxuICB9XG5cbiAgZ2V0SG9vayhlbCl7IHJldHVybiB0aGlzLnZpZXdIb29rc1tWaWV3SG9vay5lbGVtZW50SUQoZWwpXSB9XG5cbiAgYWRkSG9vayhlbCl7XG4gICAgaWYoVmlld0hvb2suZWxlbWVudElEKGVsKSB8fCAhZWwuZ2V0QXR0cmlidXRlKXsgcmV0dXJuIH1cbiAgICBsZXQgaG9va05hbWUgPSBlbC5nZXRBdHRyaWJ1dGUoYGRhdGEtcGh4LSR7UEhYX0hPT0t9YCkgfHwgZWwuZ2V0QXR0cmlidXRlKHRoaXMuYmluZGluZyhQSFhfSE9PSykpXG4gICAgaWYoaG9va05hbWUgJiYgIXRoaXMub3duc0VsZW1lbnQoZWwpKXsgcmV0dXJuIH1cbiAgICBsZXQgY2FsbGJhY2tzID0gdGhpcy5saXZlU29ja2V0LmdldEhvb2tDYWxsYmFja3MoaG9va05hbWUpXG5cbiAgICBpZihjYWxsYmFja3Mpe1xuICAgICAgaWYoIWVsLmlkKXsgbG9nRXJyb3IoYG5vIERPTSBJRCBmb3IgaG9vayBcIiR7aG9va05hbWV9XCIuIEhvb2tzIHJlcXVpcmUgYSB1bmlxdWUgSUQgb24gZWFjaCBlbGVtZW50LmAsIGVsKSB9XG4gICAgICBsZXQgaG9vayA9IG5ldyBWaWV3SG9vayh0aGlzLCBlbCwgY2FsbGJhY2tzKVxuICAgICAgdGhpcy52aWV3SG9va3NbVmlld0hvb2suZWxlbWVudElEKGhvb2suZWwpXSA9IGhvb2tcbiAgICAgIHJldHVybiBob29rXG4gICAgfSBlbHNlIGlmKGhvb2tOYW1lICE9PSBudWxsKXtcbiAgICAgIGxvZ0Vycm9yKGB1bmtub3duIGhvb2sgZm91bmQgZm9yIFwiJHtob29rTmFtZX1cImAsIGVsKVxuICAgIH1cbiAgfVxuXG4gIGRlc3Ryb3lIb29rKGhvb2spe1xuICAgIGhvb2suX19kZXN0cm95ZWQoKVxuICAgIGhvb2suX19jbGVhbnVwX18oKVxuICAgIGRlbGV0ZSB0aGlzLnZpZXdIb29rc1tWaWV3SG9vay5lbGVtZW50SUQoaG9vay5lbCldXG4gIH1cblxuICBhcHBseVBlbmRpbmdVcGRhdGVzKCl7XG4gICAgdGhpcy5wZW5kaW5nRGlmZnMuZm9yRWFjaCgoe2RpZmYsIGV2ZW50c30pID0+IHRoaXMudXBkYXRlKGRpZmYsIGV2ZW50cykpXG4gICAgdGhpcy5wZW5kaW5nRGlmZnMgPSBbXVxuICB9XG5cbiAgb25DaGFubmVsKGV2ZW50LCBjYil7XG4gICAgdGhpcy5saXZlU29ja2V0Lm9uQ2hhbm5lbCh0aGlzLmNoYW5uZWwsIGV2ZW50LCByZXNwID0+IHtcbiAgICAgIGlmKHRoaXMuaXNKb2luUGVuZGluZygpKXtcbiAgICAgICAgdGhpcy5yb290LnBlbmRpbmdKb2luT3BzLnB1c2goW3RoaXMsICgpID0+IGNiKHJlc3ApXSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubGl2ZVNvY2tldC5yZXF1ZXN0RE9NVXBkYXRlKCgpID0+IGNiKHJlc3ApKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBiaW5kQ2hhbm5lbCgpe1xuICAgIC8vIFRoZSBkaWZmIGV2ZW50IHNob3VsZCBiZSBoYW5kbGVkIGJ5IHRoZSByZWd1bGFyIHVwZGF0ZSBvcGVyYXRpb25zLlxuICAgIC8vIEFsbCBvdGhlciBvcGVyYXRpb25zIGFyZSBxdWV1ZWQgdG8gYmUgYXBwbGllZCBvbmx5IGFmdGVyIGpvaW4uXG4gICAgdGhpcy5saXZlU29ja2V0Lm9uQ2hhbm5lbCh0aGlzLmNoYW5uZWwsIFwiZGlmZlwiLCAocmF3RGlmZikgPT4ge1xuICAgICAgdGhpcy5saXZlU29ja2V0LnJlcXVlc3RET01VcGRhdGUoKCkgPT4ge1xuICAgICAgICB0aGlzLmFwcGx5RGlmZihcInVwZGF0ZVwiLCByYXdEaWZmLCAoe2RpZmYsIGV2ZW50c30pID0+IHRoaXMudXBkYXRlKGRpZmYsIGV2ZW50cykpXG4gICAgICB9KVxuICAgIH0pXG4gICAgdGhpcy5vbkNoYW5uZWwoXCJyZWRpcmVjdFwiLCAoe3RvLCBmbGFzaH0pID0+IHRoaXMub25SZWRpcmVjdCh7dG8sIGZsYXNofSkpXG4gICAgdGhpcy5vbkNoYW5uZWwoXCJsaXZlX3BhdGNoXCIsIChyZWRpcikgPT4gdGhpcy5vbkxpdmVQYXRjaChyZWRpcikpXG4gICAgdGhpcy5vbkNoYW5uZWwoXCJsaXZlX3JlZGlyZWN0XCIsIChyZWRpcikgPT4gdGhpcy5vbkxpdmVSZWRpcmVjdChyZWRpcikpXG4gICAgdGhpcy5jaGFubmVsLm9uRXJyb3IocmVhc29uID0+IHRoaXMub25FcnJvcihyZWFzb24pKVxuICAgIHRoaXMuY2hhbm5lbC5vbkNsb3NlKHJlYXNvbiA9PiB0aGlzLm9uQ2xvc2UocmVhc29uKSlcbiAgfVxuXG4gIGRlc3Ryb3lBbGxDaGlsZHJlbigpe1xuICAgIGZvcihsZXQgaWQgaW4gdGhpcy5yb290LmNoaWxkcmVuW3RoaXMuaWRdKXtcbiAgICAgIHRoaXMuZ2V0Q2hpbGRCeUlkKGlkKS5kZXN0cm95KClcbiAgICB9XG4gIH1cblxuICBvbkxpdmVSZWRpcmVjdChyZWRpcil7XG4gICAgbGV0IHt0bywga2luZCwgZmxhc2h9ID0gcmVkaXJcbiAgICBsZXQgdXJsID0gdGhpcy5leHBhbmRVUkwodG8pXG4gICAgdGhpcy5saXZlU29ja2V0Lmhpc3RvcnlSZWRpcmVjdCh1cmwsIGtpbmQsIGZsYXNoKVxuICB9XG5cbiAgb25MaXZlUGF0Y2gocmVkaXIpe1xuICAgIGxldCB7dG8sIGtpbmR9ID0gcmVkaXJcbiAgICB0aGlzLmhyZWYgPSB0aGlzLmV4cGFuZFVSTCh0bylcbiAgICB0aGlzLmxpdmVTb2NrZXQuaGlzdG9yeVBhdGNoKHRvLCBraW5kKVxuICB9XG5cbiAgZXhwYW5kVVJMKHRvKXtcbiAgICByZXR1cm4gdG8uc3RhcnRzV2l0aChcIi9cIikgPyBgJHt3aW5kb3cubG9jYXRpb24ucHJvdG9jb2x9Ly8ke3dpbmRvdy5sb2NhdGlvbi5ob3N0fSR7dG99YCA6IHRvXG4gIH1cblxuICBvblJlZGlyZWN0KHt0bywgZmxhc2h9KXsgdGhpcy5saXZlU29ja2V0LnJlZGlyZWN0KHRvLCBmbGFzaCkgfVxuXG4gIGlzRGVzdHJveWVkKCl7IHJldHVybiB0aGlzLmRlc3Ryb3llZCB9XG5cbiAgam9pbihjYWxsYmFjayl7XG4gICAgaWYodGhpcy5pc01haW4oKSl7XG4gICAgICB0aGlzLnN0b3BDYWxsYmFjayA9IHRoaXMubGl2ZVNvY2tldC53aXRoUGFnZUxvYWRpbmcoe3RvOiB0aGlzLmhyZWYsIGtpbmQ6IFwiaW5pdGlhbFwifSlcbiAgICB9XG4gICAgdGhpcy5qb2luQ2FsbGJhY2sgPSAob25Eb25lKSA9PiB7XG4gICAgICBvbkRvbmUgPSBvbkRvbmUgfHwgZnVuY3Rpb24oKXt9XG4gICAgICBjYWxsYmFjayA/IGNhbGxiYWNrKHRoaXMuam9pbkNvdW50LCBvbkRvbmUpIDogb25Eb25lKClcbiAgICB9XG4gICAgdGhpcy5saXZlU29ja2V0LndyYXBQdXNoKHRoaXMsIHt0aW1lb3V0OiBmYWxzZX0sICgpID0+IHtcbiAgICAgIHJldHVybiB0aGlzLmNoYW5uZWwuam9pbigpXG4gICAgICAgIC5yZWNlaXZlKFwib2tcIiwgZGF0YSA9PiB7XG4gICAgICAgICAgaWYoIXRoaXMuaXNEZXN0cm95ZWQoKSl7XG4gICAgICAgICAgICB0aGlzLmxpdmVTb2NrZXQucmVxdWVzdERPTVVwZGF0ZSgoKSA9PiB0aGlzLm9uSm9pbihkYXRhKSlcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIC5yZWNlaXZlKFwiZXJyb3JcIiwgcmVzcCA9PiAhdGhpcy5pc0Rlc3Ryb3llZCgpICYmIHRoaXMub25Kb2luRXJyb3IocmVzcCkpXG4gICAgICAgIC5yZWNlaXZlKFwidGltZW91dFwiLCAoKSA9PiAhdGhpcy5pc0Rlc3Ryb3llZCgpICYmIHRoaXMub25Kb2luRXJyb3Ioe3JlYXNvbjogXCJ0aW1lb3V0XCJ9KSlcbiAgICB9KVxuICB9XG5cbiAgb25Kb2luRXJyb3IocmVzcCl7XG4gICAgaWYocmVzcC5yZWFzb24gPT09IFwidW5hdXRob3JpemVkXCIgfHwgcmVzcC5yZWFzb24gPT09IFwic3RhbGVcIil7XG4gICAgICB0aGlzLmxvZyhcImVycm9yXCIsICgpID0+IFtcInVuYXV0aG9yaXplZCBsaXZlX3JlZGlyZWN0LiBGYWxsaW5nIGJhY2sgdG8gcGFnZSByZXF1ZXN0XCIsIHJlc3BdKVxuICAgICAgcmV0dXJuIHRoaXMub25SZWRpcmVjdCh7dG86IHRoaXMuaHJlZn0pXG4gICAgfVxuICAgIGlmKHJlc3AucmVkaXJlY3QgfHwgcmVzcC5saXZlX3JlZGlyZWN0KXtcbiAgICAgIHRoaXMuam9pblBlbmRpbmcgPSBmYWxzZVxuICAgICAgdGhpcy5jaGFubmVsLmxlYXZlKClcbiAgICB9XG4gICAgaWYocmVzcC5yZWRpcmVjdCl7IHJldHVybiB0aGlzLm9uUmVkaXJlY3QocmVzcC5yZWRpcmVjdCkgfVxuICAgIGlmKHJlc3AubGl2ZV9yZWRpcmVjdCl7IHJldHVybiB0aGlzLm9uTGl2ZVJlZGlyZWN0KHJlc3AubGl2ZV9yZWRpcmVjdCkgfVxuICAgIHRoaXMubG9nKFwiZXJyb3JcIiwgKCkgPT4gW1widW5hYmxlIHRvIGpvaW5cIiwgcmVzcF0pXG4gICAgcmV0dXJuIHRoaXMubGl2ZVNvY2tldC5yZWxvYWRXaXRoSml0dGVyKHRoaXMpXG4gIH1cblxuICBvbkNsb3NlKHJlYXNvbil7XG4gICAgaWYodGhpcy5pc0Rlc3Ryb3llZCgpKXsgcmV0dXJuIH1cbiAgICBpZigodGhpcy5pc0pvaW5QZW5kaW5nKCkgJiYgZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlICE9PSBcImhpZGRlblwiKSB8fFxuICAgICAgKHRoaXMubGl2ZVNvY2tldC5oYXNQZW5kaW5nTGluaygpICYmIHJlYXNvbiAhPT0gXCJsZWF2ZVwiKSl7XG5cbiAgICAgIHJldHVybiB0aGlzLmxpdmVTb2NrZXQucmVsb2FkV2l0aEppdHRlcih0aGlzKVxuICAgIH1cbiAgICB0aGlzLmRlc3Ryb3lBbGxDaGlsZHJlbigpXG4gICAgdGhpcy5saXZlU29ja2V0LmRyb3BBY3RpdmVFbGVtZW50KHRoaXMpXG4gICAgLy8gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCBjYW4gYmUgbnVsbCBpbiBJbnRlcm5ldCBFeHBsb3JlciAxMVxuICAgIGlmKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpeyBkb2N1bWVudC5hY3RpdmVFbGVtZW50LmJsdXIoKSB9XG4gICAgaWYodGhpcy5saXZlU29ja2V0LmlzVW5sb2FkZWQoKSl7XG4gICAgICB0aGlzLnNob3dMb2FkZXIoQkVGT1JFX1VOTE9BRF9MT0FERVJfVElNRU9VVClcbiAgICB9XG4gIH1cblxuICBvbkVycm9yKHJlYXNvbil7XG4gICAgdGhpcy5vbkNsb3NlKHJlYXNvbilcbiAgICB0aGlzLmxvZyhcImVycm9yXCIsICgpID0+IFtcInZpZXcgY3Jhc2hlZFwiLCByZWFzb25dKVxuICAgIGlmKCF0aGlzLmxpdmVTb2NrZXQuaXNVbmxvYWRlZCgpKXsgdGhpcy5kaXNwbGF5RXJyb3IoKSB9XG4gIH1cblxuICBkaXNwbGF5RXJyb3IoKXtcbiAgICBpZih0aGlzLmlzTWFpbigpKXsgRE9NLmRpc3BhdGNoRXZlbnQod2luZG93LCBcInBoeDpwYWdlLWxvYWRpbmctc3RhcnRcIiwge2RldGFpbDoge3RvOiB0aGlzLmhyZWYsIGtpbmQ6IFwiZXJyb3JcIn19KSB9XG4gICAgdGhpcy5zaG93TG9hZGVyKClcbiAgICB0aGlzLnNldENvbnRhaW5lckNsYXNzZXMoUEhYX0RJU0NPTk5FQ1RFRF9DTEFTUywgUEhYX0VSUk9SX0NMQVNTKVxuICB9XG5cbiAgcHVzaFdpdGhSZXBseShyZWZHZW5lcmF0b3IsIGV2ZW50LCBwYXlsb2FkLCBvblJlcGx5ID0gZnVuY3Rpb24gKCl7IH0pe1xuICAgIGlmKCF0aGlzLmlzQ29ubmVjdGVkKCkpeyByZXR1cm4gfVxuXG4gICAgbGV0IFtyZWYsIFtlbF0sIG9wdHNdID0gcmVmR2VuZXJhdG9yID8gcmVmR2VuZXJhdG9yKCkgOiBbbnVsbCwgW10sIHt9XVxuICAgIGxldCBvbkxvYWRpbmdEb25lID0gZnVuY3Rpb24oKXsgfVxuICAgIGlmKG9wdHMucGFnZV9sb2FkaW5nIHx8IChlbCAmJiAoZWwuZ2V0QXR0cmlidXRlKHRoaXMuYmluZGluZyhQSFhfUEFHRV9MT0FESU5HKSkgIT09IG51bGwpKSl7XG4gICAgICBvbkxvYWRpbmdEb25lID0gdGhpcy5saXZlU29ja2V0LndpdGhQYWdlTG9hZGluZyh7a2luZDogXCJlbGVtZW50XCIsIHRhcmdldDogZWx9KVxuICAgIH1cblxuICAgIGlmKHR5cGVvZiAocGF5bG9hZC5jaWQpICE9PSBcIm51bWJlclwiKXsgZGVsZXRlIHBheWxvYWQuY2lkIH1cbiAgICByZXR1cm4gKFxuICAgICAgdGhpcy5saXZlU29ja2V0LndyYXBQdXNoKHRoaXMsIHt0aW1lb3V0OiB0cnVlfSwgKCkgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGFubmVsLnB1c2goZXZlbnQsIHBheWxvYWQsIFBVU0hfVElNRU9VVCkucmVjZWl2ZShcIm9rXCIsIHJlc3AgPT4ge1xuICAgICAgICAgIGlmKHJlZiAhPT0gbnVsbCl7IHRoaXMudW5kb1JlZnMocmVmKSB9XG4gICAgICAgICAgbGV0IGZpbmlzaCA9IChob29rUmVwbHkpID0+IHtcbiAgICAgICAgICAgIGlmKHJlc3AucmVkaXJlY3QpeyB0aGlzLm9uUmVkaXJlY3QocmVzcC5yZWRpcmVjdCkgfVxuICAgICAgICAgICAgaWYocmVzcC5saXZlX3BhdGNoKXsgdGhpcy5vbkxpdmVQYXRjaChyZXNwLmxpdmVfcGF0Y2gpIH1cbiAgICAgICAgICAgIGlmKHJlc3AubGl2ZV9yZWRpcmVjdCl7IHRoaXMub25MaXZlUmVkaXJlY3QocmVzcC5saXZlX3JlZGlyZWN0KSB9XG4gICAgICAgICAgICBvbkxvYWRpbmdEb25lKClcbiAgICAgICAgICAgIG9uUmVwbHkocmVzcCwgaG9va1JlcGx5KVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZihyZXNwLmRpZmYpe1xuICAgICAgICAgICAgdGhpcy5saXZlU29ja2V0LnJlcXVlc3RET01VcGRhdGUoKCkgPT4ge1xuICAgICAgICAgICAgICBsZXQgaG9va1JlcGx5ID0gdGhpcy5hcHBseURpZmYoXCJ1cGRhdGVcIiwgcmVzcC5kaWZmLCAoe2RpZmYsIGV2ZW50c30pID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZShkaWZmLCBldmVudHMpXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIGZpbmlzaChob29rUmVwbHkpXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmaW5pc2gobnVsbClcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIClcbiAgfVxuXG4gIHVuZG9SZWZzKHJlZil7XG4gICAgRE9NLmFsbChkb2N1bWVudCwgYFske1BIWF9SRUZfU1JDfT1cIiR7dGhpcy5pZH1cIl1bJHtQSFhfUkVGfT1cIiR7cmVmfVwiXWAsIGVsID0+IHtcbiAgICAgIGxldCBkaXNhYmxlZFZhbCA9IGVsLmdldEF0dHJpYnV0ZShQSFhfRElTQUJMRUQpXG4gICAgICAvLyByZW1vdmUgcmVmc1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKFBIWF9SRUYpXG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoUEhYX1JFRl9TUkMpXG4gICAgICAvLyByZXN0b3JlIGlucHV0c1xuICAgICAgaWYoZWwuZ2V0QXR0cmlidXRlKFBIWF9SRUFET05MWSkgIT09IG51bGwpe1xuICAgICAgICBlbC5yZWFkT25seSA9IGZhbHNlXG4gICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShQSFhfUkVBRE9OTFkpXG4gICAgICB9XG4gICAgICBpZihkaXNhYmxlZFZhbCAhPT0gbnVsbCl7XG4gICAgICAgIGVsLmRpc2FibGVkID0gZGlzYWJsZWRWYWwgPT09IFwidHJ1ZVwiID8gdHJ1ZSA6IGZhbHNlXG4gICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShQSFhfRElTQUJMRUQpXG4gICAgICB9XG4gICAgICAvLyByZW1vdmUgY2xhc3Nlc1xuICAgICAgUEhYX0VWRU5UX0NMQVNTRVMuZm9yRWFjaChjbGFzc05hbWUgPT4gRE9NLnJlbW92ZUNsYXNzKGVsLCBjbGFzc05hbWUpKVxuICAgICAgLy8gcmVzdG9yZSBkaXNhYmxlc1xuICAgICAgbGV0IGRpc2FibGVSZXN0b3JlID0gZWwuZ2V0QXR0cmlidXRlKFBIWF9ESVNBQkxFX1dJVEhfUkVTVE9SRSlcbiAgICAgIGlmKGRpc2FibGVSZXN0b3JlICE9PSBudWxsKXtcbiAgICAgICAgZWwuaW5uZXJUZXh0ID0gZGlzYWJsZVJlc3RvcmVcbiAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKFBIWF9ESVNBQkxFX1dJVEhfUkVTVE9SRSlcbiAgICAgIH1cbiAgICAgIGxldCB0b0VsID0gRE9NLnByaXZhdGUoZWwsIFBIWF9SRUYpXG4gICAgICBpZih0b0VsKXtcbiAgICAgICAgbGV0IGhvb2sgPSB0aGlzLnRyaWdnZXJCZWZvcmVVcGRhdGVIb29rKGVsLCB0b0VsKVxuICAgICAgICBET01QYXRjaC5wYXRjaEVsKGVsLCB0b0VsLCB0aGlzLmxpdmVTb2NrZXQuZ2V0QWN0aXZlRWxlbWVudCgpKVxuICAgICAgICBpZihob29rKXsgaG9vay5fX3VwZGF0ZWQoKSB9XG4gICAgICAgIERPTS5kZWxldGVQcml2YXRlKGVsLCBQSFhfUkVGKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBwdXRSZWYoZWxlbWVudHMsIGV2ZW50LCBvcHRzID0ge30pe1xuICAgIGxldCBuZXdSZWYgPSB0aGlzLnJlZisrXG4gICAgbGV0IGRpc2FibGVXaXRoID0gdGhpcy5iaW5kaW5nKFBIWF9ESVNBQkxFX1dJVEgpXG4gICAgaWYob3B0cy5sb2FkaW5nKXsgZWxlbWVudHMgPSBlbGVtZW50cy5jb25jYXQoRE9NLmFsbChkb2N1bWVudCwgb3B0cy5sb2FkaW5nKSl9XG5cbiAgICBlbGVtZW50cy5mb3JFYWNoKGVsID0+IHtcbiAgICAgIGVsLmNsYXNzTGlzdC5hZGQoYHBoeC0ke2V2ZW50fS1sb2FkaW5nYClcbiAgICAgIGVsLnNldEF0dHJpYnV0ZShQSFhfUkVGLCBuZXdSZWYpXG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoUEhYX1JFRl9TUkMsIHRoaXMuZWwuaWQpXG4gICAgICBsZXQgZGlzYWJsZVRleHQgPSBlbC5nZXRBdHRyaWJ1dGUoZGlzYWJsZVdpdGgpXG4gICAgICBpZihkaXNhYmxlVGV4dCAhPT0gbnVsbCl7XG4gICAgICAgIGlmKCFlbC5nZXRBdHRyaWJ1dGUoUEhYX0RJU0FCTEVfV0lUSF9SRVNUT1JFKSl7XG4gICAgICAgICAgZWwuc2V0QXR0cmlidXRlKFBIWF9ESVNBQkxFX1dJVEhfUkVTVE9SRSwgZWwuaW5uZXJUZXh0KVxuICAgICAgICB9XG4gICAgICAgIGlmKGRpc2FibGVUZXh0ICE9PSBcIlwiKXsgZWwuaW5uZXJUZXh0ID0gZGlzYWJsZVRleHQgfVxuICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiLCBcIlwiKVxuICAgICAgfVxuICAgIH0pXG4gICAgcmV0dXJuIFtuZXdSZWYsIGVsZW1lbnRzLCBvcHRzXVxuICB9XG5cbiAgY29tcG9uZW50SUQoZWwpe1xuICAgIGxldCBjaWQgPSBlbC5nZXRBdHRyaWJ1dGUgJiYgZWwuZ2V0QXR0cmlidXRlKFBIWF9DT01QT05FTlQpXG4gICAgcmV0dXJuIGNpZCA/IHBhcnNlSW50KGNpZCkgOiBudWxsXG4gIH1cblxuICB0YXJnZXRDb21wb25lbnRJRCh0YXJnZXQsIHRhcmdldEN0eCwgb3B0cyA9IHt9KXtcbiAgICBpZihpc0NpZCh0YXJnZXRDdHgpKXsgcmV0dXJuIHRhcmdldEN0eCB9XG5cbiAgICBsZXQgY2lkT3JTZWxlY3RvciA9IHRhcmdldC5nZXRBdHRyaWJ1dGUodGhpcy5iaW5kaW5nKFwidGFyZ2V0XCIpKVxuICAgIGlmKGlzQ2lkKGNpZE9yU2VsZWN0b3IpKXtcbiAgICAgIHJldHVybiBwYXJzZUludChjaWRPclNlbGVjdG9yKVxuICAgIH0gZWxzZSBpZih0YXJnZXRDdHggJiYgKGNpZE9yU2VsZWN0b3IgIT09IG51bGwgfHwgb3B0cy50YXJnZXQpKXtcbiAgICAgIHJldHVybiB0aGlzLmNsb3Nlc3RDb21wb25lbnRJRCh0YXJnZXRDdHgpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICB9XG5cbiAgY2xvc2VzdENvbXBvbmVudElEKHRhcmdldEN0eCl7XG4gICAgaWYoaXNDaWQodGFyZ2V0Q3R4KSl7XG4gICAgICByZXR1cm4gdGFyZ2V0Q3R4XG4gICAgfSBlbHNlIGlmKHRhcmdldEN0eCl7XG4gICAgICByZXR1cm4gbWF5YmUodGFyZ2V0Q3R4LmNsb3Nlc3QoYFske1BIWF9DT01QT05FTlR9XWApLCBlbCA9PiB0aGlzLm93bnNFbGVtZW50KGVsKSAmJiB0aGlzLmNvbXBvbmVudElEKGVsKSlcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gIH1cblxuICBwdXNoSG9va0V2ZW50KHRhcmdldEN0eCwgZXZlbnQsIHBheWxvYWQsIG9uUmVwbHkpe1xuICAgIGlmKCF0aGlzLmlzQ29ubmVjdGVkKCkpe1xuICAgICAgdGhpcy5sb2coXCJob29rXCIsICgpID0+IFtcInVuYWJsZSB0byBwdXNoIGhvb2sgZXZlbnQuIExpdmVWaWV3IG5vdCBjb25uZWN0ZWRcIiwgZXZlbnQsIHBheWxvYWRdKVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIGxldCBbcmVmLCBlbHMsIG9wdHNdID0gdGhpcy5wdXRSZWYoW10sIFwiaG9va1wiKVxuICAgIHRoaXMucHVzaFdpdGhSZXBseSgoKSA9PiBbcmVmLCBlbHMsIG9wdHNdLCBcImV2ZW50XCIsIHtcbiAgICAgIHR5cGU6IFwiaG9va1wiLFxuICAgICAgZXZlbnQ6IGV2ZW50LFxuICAgICAgdmFsdWU6IHBheWxvYWQsXG4gICAgICBjaWQ6IHRoaXMuY2xvc2VzdENvbXBvbmVudElEKHRhcmdldEN0eClcbiAgICB9LCAocmVzcCwgcmVwbHkpID0+IG9uUmVwbHkocmVwbHksIHJlZikpXG5cbiAgICByZXR1cm4gcmVmXG4gIH1cblxuICBleHRyYWN0TWV0YShlbCwgbWV0YSwgdmFsdWUpe1xuICAgIGxldCBwcmVmaXggPSB0aGlzLmJpbmRpbmcoXCJ2YWx1ZS1cIilcbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgZWwuYXR0cmlidXRlcy5sZW5ndGg7IGkrKyl7XG4gICAgICBpZighbWV0YSl7IG1ldGEgPSB7fSB9XG4gICAgICBsZXQgbmFtZSA9IGVsLmF0dHJpYnV0ZXNbaV0ubmFtZVxuICAgICAgaWYobmFtZS5zdGFydHNXaXRoKHByZWZpeCkpeyBtZXRhW25hbWUucmVwbGFjZShwcmVmaXgsIFwiXCIpXSA9IGVsLmdldEF0dHJpYnV0ZShuYW1lKSB9XG4gICAgfVxuICAgIGlmKGVsLnZhbHVlICE9PSB1bmRlZmluZWQpe1xuICAgICAgaWYoIW1ldGEpeyBtZXRhID0ge30gfVxuICAgICAgbWV0YS52YWx1ZSA9IGVsLnZhbHVlXG5cbiAgICAgIGlmKGVsLnRhZ05hbWUgPT09IFwiSU5QVVRcIiAmJiBDSEVDS0FCTEVfSU5QVVRTLmluZGV4T2YoZWwudHlwZSkgPj0gMCAmJiAhZWwuY2hlY2tlZCl7XG4gICAgICAgIGRlbGV0ZSBtZXRhLnZhbHVlXG4gICAgICB9XG4gICAgfVxuICAgIGlmKHZhbHVlKXtcbiAgICAgIGlmKCFtZXRhKXsgbWV0YSA9IHt9IH1cbiAgICAgIGZvcihsZXQga2V5IGluIHZhbHVlKXsgbWV0YVtrZXldID0gdmFsdWVba2V5XSB9XG4gICAgfVxuICAgIHJldHVybiBtZXRhXG4gIH1cblxuICBwdXNoRXZlbnQodHlwZSwgZWwsIHRhcmdldEN0eCwgcGh4RXZlbnQsIG1ldGEsIG9wdHMgPSB7fSl7XG4gICAgdGhpcy5wdXNoV2l0aFJlcGx5KCgpID0+IHRoaXMucHV0UmVmKFtlbF0sIHR5cGUsIG9wdHMpLCBcImV2ZW50XCIsIHtcbiAgICAgIHR5cGU6IHR5cGUsXG4gICAgICBldmVudDogcGh4RXZlbnQsXG4gICAgICB2YWx1ZTogdGhpcy5leHRyYWN0TWV0YShlbCwgbWV0YSwgb3B0cy52YWx1ZSksXG4gICAgICBjaWQ6IHRoaXMudGFyZ2V0Q29tcG9uZW50SUQoZWwsIHRhcmdldEN0eCwgb3B0cylcbiAgICB9KVxuICB9XG5cbiAgcHVzaEZpbGVQcm9ncmVzcyhmaWxlRWwsIGVudHJ5UmVmLCBwcm9ncmVzcywgb25SZXBseSA9IGZ1bmN0aW9uICgpeyB9KXtcbiAgICB0aGlzLmxpdmVTb2NrZXQud2l0aGluT3duZXJzKGZpbGVFbC5mb3JtLCAodmlldywgdGFyZ2V0Q3R4KSA9PiB7XG4gICAgICB2aWV3LnB1c2hXaXRoUmVwbHkobnVsbCwgXCJwcm9ncmVzc1wiLCB7XG4gICAgICAgIGV2ZW50OiBmaWxlRWwuZ2V0QXR0cmlidXRlKHZpZXcuYmluZGluZyhQSFhfUFJPR1JFU1MpKSxcbiAgICAgICAgcmVmOiBmaWxlRWwuZ2V0QXR0cmlidXRlKFBIWF9VUExPQURfUkVGKSxcbiAgICAgICAgZW50cnlfcmVmOiBlbnRyeVJlZixcbiAgICAgICAgcHJvZ3Jlc3M6IHByb2dyZXNzLFxuICAgICAgICBjaWQ6IHZpZXcudGFyZ2V0Q29tcG9uZW50SUQoZmlsZUVsLmZvcm0sIHRhcmdldEN0eClcbiAgICAgIH0sIG9uUmVwbHkpXG4gICAgfSlcbiAgfVxuXG4gIHB1c2hJbnB1dChpbnB1dEVsLCB0YXJnZXRDdHgsIGZvcmNlQ2lkLCBwaHhFdmVudCwgb3B0cywgY2FsbGJhY2spe1xuICAgIGxldCB1cGxvYWRzXG4gICAgbGV0IGNpZCA9IGlzQ2lkKGZvcmNlQ2lkKSA/IGZvcmNlQ2lkIDogdGhpcy50YXJnZXRDb21wb25lbnRJRChpbnB1dEVsLmZvcm0sIHRhcmdldEN0eClcbiAgICBsZXQgcmVmR2VuZXJhdG9yID0gKCkgPT4gdGhpcy5wdXRSZWYoW2lucHV0RWwsIGlucHV0RWwuZm9ybV0sIFwiY2hhbmdlXCIsIG9wdHMpXG4gICAgbGV0IGZvcm1EYXRhXG4gICAgaWYoaW5wdXRFbC5nZXRBdHRyaWJ1dGUodGhpcy5iaW5kaW5nKFwiY2hhbmdlXCIpKSl7XG4gICAgICBmb3JtRGF0YSA9IHNlcmlhbGl6ZUZvcm0oaW5wdXRFbC5mb3JtLCB7X3RhcmdldDogb3B0cy5fdGFyZ2V0fSwgW2lucHV0RWwubmFtZV0pXG4gICAgfSBlbHNlIHtcbiAgICAgIGZvcm1EYXRhID0gc2VyaWFsaXplRm9ybShpbnB1dEVsLmZvcm0sIHtfdGFyZ2V0OiBvcHRzLl90YXJnZXR9KVxuICAgIH1cbiAgICBpZihET00uaXNVcGxvYWRJbnB1dChpbnB1dEVsKSAmJiBpbnB1dEVsLmZpbGVzICYmIGlucHV0RWwuZmlsZXMubGVuZ3RoID4gMCl7XG4gICAgICBMaXZlVXBsb2FkZXIudHJhY2tGaWxlcyhpbnB1dEVsLCBBcnJheS5mcm9tKGlucHV0RWwuZmlsZXMpKVxuICAgIH1cbiAgICB1cGxvYWRzID0gTGl2ZVVwbG9hZGVyLnNlcmlhbGl6ZVVwbG9hZHMoaW5wdXRFbClcbiAgICBsZXQgZXZlbnQgPSB7XG4gICAgICB0eXBlOiBcImZvcm1cIixcbiAgICAgIGV2ZW50OiBwaHhFdmVudCxcbiAgICAgIHZhbHVlOiBmb3JtRGF0YSxcbiAgICAgIHVwbG9hZHM6IHVwbG9hZHMsXG4gICAgICBjaWQ6IGNpZFxuICAgIH1cbiAgICB0aGlzLnB1c2hXaXRoUmVwbHkocmVmR2VuZXJhdG9yLCBcImV2ZW50XCIsIGV2ZW50LCByZXNwID0+IHtcbiAgICAgIERPTS5zaG93RXJyb3IoaW5wdXRFbCwgdGhpcy5saXZlU29ja2V0LmJpbmRpbmcoUEhYX0ZFRURCQUNLX0ZPUikpXG4gICAgICBpZihET00uaXNVcGxvYWRJbnB1dChpbnB1dEVsKSAmJiBpbnB1dEVsLmdldEF0dHJpYnV0ZShcImRhdGEtcGh4LWF1dG8tdXBsb2FkXCIpICE9PSBudWxsKXtcbiAgICAgICAgaWYoTGl2ZVVwbG9hZGVyLmZpbGVzQXdhaXRpbmdQcmVmbGlnaHQoaW5wdXRFbCkubGVuZ3RoID4gMCl7XG4gICAgICAgICAgbGV0IFtyZWYsIF9lbHNdID0gcmVmR2VuZXJhdG9yKClcbiAgICAgICAgICB0aGlzLnVwbG9hZEZpbGVzKGlucHV0RWwuZm9ybSwgdGFyZ2V0Q3R4LCByZWYsIGNpZCwgKF91cGxvYWRzKSA9PiB7XG4gICAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhyZXNwKVxuICAgICAgICAgICAgdGhpcy50cmlnZ2VyQXdhaXRpbmdTdWJtaXQoaW5wdXRFbC5mb3JtKVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKHJlc3ApXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIHRyaWdnZXJBd2FpdGluZ1N1Ym1pdChmb3JtRWwpe1xuICAgIGxldCBhd2FpdGluZ1N1Ym1pdCA9IHRoaXMuZ2V0U2NoZWR1bGVkU3VibWl0KGZvcm1FbClcbiAgICBpZihhd2FpdGluZ1N1Ym1pdCl7XG4gICAgICBsZXQgW19lbCwgX3JlZiwgX29wdHMsIGNhbGxiYWNrXSA9IGF3YWl0aW5nU3VibWl0XG4gICAgICB0aGlzLmNhbmNlbFN1Ym1pdChmb3JtRWwpXG4gICAgICBjYWxsYmFjaygpXG4gICAgfVxuICB9XG5cbiAgZ2V0U2NoZWR1bGVkU3VibWl0KGZvcm1FbCl7XG4gICAgcmV0dXJuIHRoaXMuZm9ybVN1Ym1pdHMuZmluZCgoW2VsLCBfcmVmLCBfb3B0cywgX2NhbGxiYWNrXSkgPT4gZWwuaXNTYW1lTm9kZShmb3JtRWwpKVxuICB9XG5cbiAgc2NoZWR1bGVTdWJtaXQoZm9ybUVsLCByZWYsIG9wdHMsIGNhbGxiYWNrKXtcbiAgICBpZih0aGlzLmdldFNjaGVkdWxlZFN1Ym1pdChmb3JtRWwpKXsgcmV0dXJuIHRydWUgfVxuICAgIHRoaXMuZm9ybVN1Ym1pdHMucHVzaChbZm9ybUVsLCByZWYsIG9wdHMsIGNhbGxiYWNrXSlcbiAgfVxuXG4gIGNhbmNlbFN1Ym1pdChmb3JtRWwpe1xuICAgIHRoaXMuZm9ybVN1Ym1pdHMgPSB0aGlzLmZvcm1TdWJtaXRzLmZpbHRlcigoW2VsLCByZWYsIF9jYWxsYmFja10pID0+IHtcbiAgICAgIGlmKGVsLmlzU2FtZU5vZGUoZm9ybUVsKSl7XG4gICAgICAgIHRoaXMudW5kb1JlZnMocmVmKVxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIHB1c2hGb3JtU3VibWl0KGZvcm1FbCwgdGFyZ2V0Q3R4LCBwaHhFdmVudCwgb3B0cywgb25SZXBseSl7XG4gICAgbGV0IGZpbHRlcklnbm9yZWQgPSBlbCA9PiB7XG4gICAgICBsZXQgdXNlcklnbm9yZWQgPSBjbG9zZXN0UGh4QmluZGluZyhlbCwgYCR7dGhpcy5iaW5kaW5nKFBIWF9VUERBVEUpfT1pZ25vcmVgLCBlbC5mb3JtKVxuICAgICAgcmV0dXJuICEodXNlcklnbm9yZWQgfHwgY2xvc2VzdFBoeEJpbmRpbmcoZWwsIFwiZGF0YS1waHgtdXBkYXRlPWlnbm9yZVwiLCBlbC5mb3JtKSlcbiAgICB9XG4gICAgbGV0IGZpbHRlckRpc2FibGVzID0gZWwgPT4ge1xuICAgICAgcmV0dXJuIGVsLmhhc0F0dHJpYnV0ZSh0aGlzLmJpbmRpbmcoUEhYX0RJU0FCTEVfV0lUSCkpXG4gICAgfVxuICAgIGxldCBmaWx0ZXJCdXR0b24gPSBlbCA9PiBlbC50YWdOYW1lID09IFwiQlVUVE9OXCJcblxuICAgIGxldCBmaWx0ZXJJbnB1dCA9IGVsID0+IFtcIklOUFVUXCIsIFwiVEVYVEFSRUFcIiwgXCJTRUxFQ1RcIl0uaW5jbHVkZXMoZWwudGFnTmFtZSlcblxuICAgIGxldCByZWZHZW5lcmF0b3IgPSAoKSA9PiB7XG4gICAgICBsZXQgZm9ybUVsZW1lbnRzID0gQXJyYXkuZnJvbShmb3JtRWwuZWxlbWVudHMpXG4gICAgICBsZXQgZGlzYWJsZXMgPSBmb3JtRWxlbWVudHMuZmlsdGVyKGZpbHRlckRpc2FibGVzKVxuICAgICAgbGV0IGJ1dHRvbnMgPSBmb3JtRWxlbWVudHMuZmlsdGVyKGZpbHRlckJ1dHRvbikuZmlsdGVyKGZpbHRlcklnbm9yZWQpXG4gICAgICBsZXQgaW5wdXRzID0gZm9ybUVsZW1lbnRzLmZpbHRlcihmaWx0ZXJJbnB1dCkuZmlsdGVyKGZpbHRlcklnbm9yZWQpXG5cbiAgICAgIGJ1dHRvbnMuZm9yRWFjaChidXR0b24gPT4ge1xuICAgICAgICBidXR0b24uc2V0QXR0cmlidXRlKFBIWF9ESVNBQkxFRCwgYnV0dG9uLmRpc2FibGVkKVxuICAgICAgICBidXR0b24uZGlzYWJsZWQgPSB0cnVlXG4gICAgICB9KVxuICAgICAgaW5wdXRzLmZvckVhY2goaW5wdXQgPT4ge1xuICAgICAgICBpbnB1dC5zZXRBdHRyaWJ1dGUoUEhYX1JFQURPTkxZLCBpbnB1dC5yZWFkT25seSlcbiAgICAgICAgaW5wdXQucmVhZE9ubHkgPSB0cnVlXG4gICAgICAgIGlmKGlucHV0LmZpbGVzKXtcbiAgICAgICAgICBpbnB1dC5zZXRBdHRyaWJ1dGUoUEhYX0RJU0FCTEVELCBpbnB1dC5kaXNhYmxlZClcbiAgICAgICAgICBpbnB1dC5kaXNhYmxlZCA9IHRydWVcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIGZvcm1FbC5zZXRBdHRyaWJ1dGUodGhpcy5iaW5kaW5nKFBIWF9QQUdFX0xPQURJTkcpLCBcIlwiKVxuICAgICAgcmV0dXJuIHRoaXMucHV0UmVmKFtmb3JtRWxdLmNvbmNhdChkaXNhYmxlcykuY29uY2F0KGJ1dHRvbnMpLmNvbmNhdChpbnB1dHMpLCBcInN1Ym1pdFwiLCBvcHRzKVxuICAgIH1cblxuICAgIGxldCBjaWQgPSB0aGlzLnRhcmdldENvbXBvbmVudElEKGZvcm1FbCwgdGFyZ2V0Q3R4KVxuICAgIGlmKExpdmVVcGxvYWRlci5oYXNVcGxvYWRzSW5Qcm9ncmVzcyhmb3JtRWwpKXtcbiAgICAgIGxldCBbcmVmLCBfZWxzXSA9IHJlZkdlbmVyYXRvcigpXG4gICAgICBsZXQgcHVzaCA9ICgpID0+IHRoaXMucHVzaEZvcm1TdWJtaXQoZm9ybUVsLCB0YXJnZXRDdHgsIHBoeEV2ZW50LCBvcHRzLCBvblJlcGx5KVxuICAgICAgcmV0dXJuIHRoaXMuc2NoZWR1bGVTdWJtaXQoZm9ybUVsLCByZWYsIG9wdHMsIHB1c2gpXG4gICAgfSBlbHNlIGlmKExpdmVVcGxvYWRlci5pbnB1dHNBd2FpdGluZ1ByZWZsaWdodChmb3JtRWwpLmxlbmd0aCA+IDApe1xuICAgICAgbGV0IFtyZWYsIGVsc10gPSByZWZHZW5lcmF0b3IoKVxuICAgICAgbGV0IHByb3h5UmVmR2VuID0gKCkgPT4gW3JlZiwgZWxzLCBvcHRzXVxuICAgICAgdGhpcy51cGxvYWRGaWxlcyhmb3JtRWwsIHRhcmdldEN0eCwgcmVmLCBjaWQsIChfdXBsb2FkcykgPT4ge1xuICAgICAgICBsZXQgZm9ybURhdGEgPSBzZXJpYWxpemVGb3JtKGZvcm1FbCwge30pXG4gICAgICAgIHRoaXMucHVzaFdpdGhSZXBseShwcm94eVJlZkdlbiwgXCJldmVudFwiLCB7XG4gICAgICAgICAgdHlwZTogXCJmb3JtXCIsXG4gICAgICAgICAgZXZlbnQ6IHBoeEV2ZW50LFxuICAgICAgICAgIHZhbHVlOiBmb3JtRGF0YSxcbiAgICAgICAgICBjaWQ6IGNpZFxuICAgICAgICB9LCBvblJlcGx5KVxuICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGZvcm1EYXRhID0gc2VyaWFsaXplRm9ybShmb3JtRWwsIHt9KVxuICAgICAgdGhpcy5wdXNoV2l0aFJlcGx5KHJlZkdlbmVyYXRvciwgXCJldmVudFwiLCB7XG4gICAgICAgIHR5cGU6IFwiZm9ybVwiLFxuICAgICAgICBldmVudDogcGh4RXZlbnQsXG4gICAgICAgIHZhbHVlOiBmb3JtRGF0YSxcbiAgICAgICAgY2lkOiBjaWRcbiAgICAgIH0sIG9uUmVwbHkpXG4gICAgfVxuICB9XG5cbiAgdXBsb2FkRmlsZXMoZm9ybUVsLCB0YXJnZXRDdHgsIHJlZiwgY2lkLCBvbkNvbXBsZXRlKXtcbiAgICBsZXQgam9pbkNvdW50QXRVcGxvYWQgPSB0aGlzLmpvaW5Db3VudFxuICAgIGxldCBpbnB1dEVscyA9IExpdmVVcGxvYWRlci5hY3RpdmVGaWxlSW5wdXRzKGZvcm1FbClcbiAgICBsZXQgbnVtRmlsZUlucHV0c0luUHJvZ3Jlc3MgPSBpbnB1dEVscy5sZW5ndGhcblxuICAgIC8vIGdldCBlYWNoIGZpbGUgaW5wdXRcbiAgICBpbnB1dEVscy5mb3JFYWNoKGlucHV0RWwgPT4ge1xuICAgICAgbGV0IHVwbG9hZGVyID0gbmV3IExpdmVVcGxvYWRlcihpbnB1dEVsLCB0aGlzLCAoKSA9PiB7XG4gICAgICAgIG51bUZpbGVJbnB1dHNJblByb2dyZXNzLS1cbiAgICAgICAgaWYobnVtRmlsZUlucHV0c0luUHJvZ3Jlc3MgPT09IDApeyBvbkNvbXBsZXRlKCkgfVxuICAgICAgfSk7XG5cbiAgICAgIHRoaXMudXBsb2FkZXJzW2lucHV0RWxdID0gdXBsb2FkZXJcbiAgICAgIGxldCBlbnRyaWVzID0gdXBsb2FkZXIuZW50cmllcygpLm1hcChlbnRyeSA9PiBlbnRyeS50b1ByZWZsaWdodFBheWxvYWQoKSlcblxuICAgICAgbGV0IHBheWxvYWQgPSB7XG4gICAgICAgIHJlZjogaW5wdXRFbC5nZXRBdHRyaWJ1dGUoUEhYX1VQTE9BRF9SRUYpLFxuICAgICAgICBlbnRyaWVzOiBlbnRyaWVzLFxuICAgICAgICBjaWQ6IHRoaXMudGFyZ2V0Q29tcG9uZW50SUQoaW5wdXRFbC5mb3JtLCB0YXJnZXRDdHgpXG4gICAgICB9XG5cbiAgICAgIHRoaXMubG9nKFwidXBsb2FkXCIsICgpID0+IFtcInNlbmRpbmcgcHJlZmxpZ2h0IHJlcXVlc3RcIiwgcGF5bG9hZF0pXG5cbiAgICAgIHRoaXMucHVzaFdpdGhSZXBseShudWxsLCBcImFsbG93X3VwbG9hZFwiLCBwYXlsb2FkLCByZXNwID0+IHtcbiAgICAgICAgdGhpcy5sb2coXCJ1cGxvYWRcIiwgKCkgPT4gW1wiZ290IHByZWZsaWdodCByZXNwb25zZVwiLCByZXNwXSlcbiAgICAgICAgaWYocmVzcC5lcnJvcil7XG4gICAgICAgICAgdGhpcy51bmRvUmVmcyhyZWYpXG4gICAgICAgICAgbGV0IFtlbnRyeV9yZWYsIHJlYXNvbl0gPSByZXNwLmVycm9yXG4gICAgICAgICAgdGhpcy5sb2coXCJ1cGxvYWRcIiwgKCkgPT4gW2BlcnJvciBmb3IgZW50cnkgJHtlbnRyeV9yZWZ9YCwgcmVhc29uXSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsZXQgb25FcnJvciA9IChjYWxsYmFjaykgPT4ge1xuICAgICAgICAgICAgdGhpcy5jaGFubmVsLm9uRXJyb3IoKCkgPT4ge1xuICAgICAgICAgICAgICBpZih0aGlzLmpvaW5Db3VudCA9PT0gam9pbkNvdW50QXRVcGxvYWQpeyBjYWxsYmFjaygpIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfVxuICAgICAgICAgIHVwbG9hZGVyLmluaXRBZGFwdGVyVXBsb2FkKHJlc3AsIG9uRXJyb3IsIHRoaXMubGl2ZVNvY2tldClcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9KVxuICB9XG5cbiAgZGlzcGF0Y2hVcGxvYWRzKG5hbWUsIGZpbGVzT3JCbG9icyl7XG4gICAgbGV0IGlucHV0cyA9IERPTS5maW5kVXBsb2FkSW5wdXRzKHRoaXMuZWwpLmZpbHRlcihlbCA9PiBlbC5uYW1lID09PSBuYW1lKVxuICAgIGlmKGlucHV0cy5sZW5ndGggPT09IDApeyBsb2dFcnJvcihgbm8gbGl2ZSBmaWxlIGlucHV0cyBmb3VuZCBtYXRjaGluZyB0aGUgbmFtZSBcIiR7bmFtZX1cImApIH1cbiAgICBlbHNlIGlmKGlucHV0cy5sZW5ndGggPiAxKXsgbG9nRXJyb3IoYGR1cGxpY2F0ZSBsaXZlIGZpbGUgaW5wdXRzIGZvdW5kIG1hdGNoaW5nIHRoZSBuYW1lIFwiJHtuYW1lfVwiYCkgfVxuICAgIGVsc2UgeyBET00uZGlzcGF0Y2hFdmVudChpbnB1dHNbMF0sIFBIWF9UUkFDS19VUExPQURTLCB7ZGV0YWlsOiB7ZmlsZXM6IGZpbGVzT3JCbG9ic319KSB9XG4gIH1cblxuICBwdXNoRm9ybVJlY292ZXJ5KGZvcm0sIG5ld0NpZCwgY2FsbGJhY2spe1xuICAgIHRoaXMubGl2ZVNvY2tldC53aXRoaW5Pd25lcnMoZm9ybSwgKHZpZXcsIHRhcmdldEN0eCkgPT4ge1xuICAgICAgbGV0IGlucHV0ID0gZm9ybS5lbGVtZW50c1swXVxuICAgICAgbGV0IHBoeEV2ZW50ID0gZm9ybS5nZXRBdHRyaWJ1dGUodGhpcy5iaW5kaW5nKFBIWF9BVVRPX1JFQ09WRVIpKSB8fCBmb3JtLmdldEF0dHJpYnV0ZSh0aGlzLmJpbmRpbmcoXCJjaGFuZ2VcIikpXG5cbiAgICAgIEpTLmV4ZWMoXCJjaGFuZ2VcIiwgcGh4RXZlbnQsIHZpZXcsIGlucHV0LCBbXCJwdXNoXCIsIHtfdGFyZ2V0OiBpbnB1dC5uYW1lLCBuZXdDaWQ6IG5ld0NpZCwgY2FsbGJhY2s6IGNhbGxiYWNrfV0pXG4gICAgfSlcbiAgfVxuXG4gIHB1c2hMaW5rUGF0Y2goaHJlZiwgdGFyZ2V0RWwsIGNhbGxiYWNrKXtcbiAgICBsZXQgbGlua1JlZiA9IHRoaXMubGl2ZVNvY2tldC5zZXRQZW5kaW5nTGluayhocmVmKVxuICAgIGxldCByZWZHZW4gPSB0YXJnZXRFbCA/ICgpID0+IHRoaXMucHV0UmVmKFt0YXJnZXRFbF0sIFwiY2xpY2tcIikgOiBudWxsXG4gICAgbGV0IGZhbGxiYWNrID0gKCkgPT4gdGhpcy5saXZlU29ja2V0LnJlZGlyZWN0KHdpbmRvdy5sb2NhdGlvbi5ocmVmKVxuXG4gICAgbGV0IHB1c2ggPSB0aGlzLnB1c2hXaXRoUmVwbHkocmVmR2VuLCBcImxpdmVfcGF0Y2hcIiwge3VybDogaHJlZn0sIHJlc3AgPT4ge1xuICAgICAgdGhpcy5saXZlU29ja2V0LnJlcXVlc3RET01VcGRhdGUoKCkgPT4ge1xuICAgICAgICBpZihyZXNwLmxpbmtfcmVkaXJlY3Qpe1xuICAgICAgICAgIHRoaXMubGl2ZVNvY2tldC5yZXBsYWNlTWFpbihocmVmLCBudWxsLCBjYWxsYmFjaywgbGlua1JlZilcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZih0aGlzLmxpdmVTb2NrZXQuY29tbWl0UGVuZGluZ0xpbmsobGlua1JlZikpe1xuICAgICAgICAgICAgdGhpcy5ocmVmID0gaHJlZlxuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmFwcGx5UGVuZGluZ1VwZGF0ZXMoKVxuICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKGxpbmtSZWYpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSlcblxuICAgIGlmKHB1c2gpe1xuICAgICAgcHVzaC5yZWNlaXZlKFwidGltZW91dFwiLCBmYWxsYmFjaylcbiAgICB9IGVsc2Uge1xuICAgICAgZmFsbGJhY2soKVxuICAgIH1cbiAgfVxuXG4gIGZvcm1zRm9yUmVjb3ZlcnkoaHRtbCl7XG4gICAgaWYodGhpcy5qb2luQ291bnQgPT09IDApeyByZXR1cm4gW10gfVxuXG4gICAgbGV0IHBoeENoYW5nZSA9IHRoaXMuYmluZGluZyhcImNoYW5nZVwiKVxuICAgIGxldCB0ZW1wbGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0ZW1wbGF0ZVwiKVxuICAgIHRlbXBsYXRlLmlubmVySFRNTCA9IGh0bWxcblxuICAgIHJldHVybiAoXG4gICAgICBET00uYWxsKHRoaXMuZWwsIGBmb3JtWyR7cGh4Q2hhbmdlfV1gKVxuICAgICAgICAuZmlsdGVyKGZvcm0gPT4gZm9ybS5pZCAmJiB0aGlzLm93bnNFbGVtZW50KGZvcm0pKVxuICAgICAgICAuZmlsdGVyKGZvcm0gPT4gZm9ybS5lbGVtZW50cy5sZW5ndGggPiAwKVxuICAgICAgICAuZmlsdGVyKGZvcm0gPT4gZm9ybS5nZXRBdHRyaWJ1dGUodGhpcy5iaW5kaW5nKFBIWF9BVVRPX1JFQ09WRVIpKSAhPT0gXCJpZ25vcmVcIilcbiAgICAgICAgLm1hcChmb3JtID0+IHtcbiAgICAgICAgICBsZXQgbmV3Rm9ybSA9IHRlbXBsYXRlLmNvbnRlbnQucXVlcnlTZWxlY3RvcihgZm9ybVtpZD1cIiR7Zm9ybS5pZH1cIl1bJHtwaHhDaGFuZ2V9PVwiJHtmb3JtLmdldEF0dHJpYnV0ZShwaHhDaGFuZ2UpfVwiXWApXG4gICAgICAgICAgaWYobmV3Rm9ybSl7XG4gICAgICAgICAgICByZXR1cm4gW2Zvcm0sIG5ld0Zvcm0sIHRoaXMudGFyZ2V0Q29tcG9uZW50SUQobmV3Rm9ybSldXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBbZm9ybSwgbnVsbCwgbnVsbF1cbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIC5maWx0ZXIoKFtmb3JtLCBuZXdGb3JtLCBuZXdDaWRdKSA9PiBuZXdGb3JtKVxuICAgIClcbiAgfVxuXG4gIG1heWJlUHVzaENvbXBvbmVudHNEZXN0cm95ZWQoZGVzdHJveWVkQ0lEcyl7XG4gICAgbGV0IHdpbGxEZXN0cm95Q0lEcyA9IGRlc3Ryb3llZENJRHMuZmlsdGVyKGNpZCA9PiB7XG4gICAgICByZXR1cm4gRE9NLmZpbmRDb21wb25lbnROb2RlTGlzdCh0aGlzLmVsLCBjaWQpLmxlbmd0aCA9PT0gMFxuICAgIH0pXG4gICAgaWYod2lsbERlc3Ryb3lDSURzLmxlbmd0aCA+IDApe1xuICAgICAgdGhpcy5wcnVuaW5nQ0lEcy5wdXNoKC4uLndpbGxEZXN0cm95Q0lEcylcblxuICAgICAgdGhpcy5wdXNoV2l0aFJlcGx5KG51bGwsIFwiY2lkc193aWxsX2Rlc3Ryb3lcIiwge2NpZHM6IHdpbGxEZXN0cm95Q0lEc30sICgpID0+IHtcbiAgICAgICAgLy8gVGhlIGNpZHMgYXJlIGVpdGhlciBiYWNrIG9uIHRoZSBwYWdlIG9yIHRoZXkgd2lsbCBiZSBmdWxseSByZW1vdmVkLFxuICAgICAgICAvLyBzbyB3ZSBjYW4gcmVtb3ZlIHRoZW0gZnJvbSB0aGUgcHJ1bmluZ0NJRHMuXG4gICAgICAgIHRoaXMucHJ1bmluZ0NJRHMgPSB0aGlzLnBydW5pbmdDSURzLmZpbHRlcihjaWQgPT4gd2lsbERlc3Ryb3lDSURzLmluZGV4T2YoY2lkKSAhPT0gLTEpXG5cbiAgICAgICAgLy8gU2VlIGlmIGFueSBvZiB0aGUgY2lkcyB3ZSB3YW50ZWQgdG8gZGVzdHJveSB3ZXJlIGFkZGVkIGJhY2ssXG4gICAgICAgIC8vIGlmIHRoZXkgd2VyZSBhZGRlZCBiYWNrLCB3ZSBkb24ndCBhY3R1YWxseSBkZXN0cm95IHRoZW0uXG4gICAgICAgIGxldCBjb21wbGV0ZWx5RGVzdHJveUNJRHMgPSB3aWxsRGVzdHJveUNJRHMuZmlsdGVyKGNpZCA9PiB7XG4gICAgICAgICAgcmV0dXJuIERPTS5maW5kQ29tcG9uZW50Tm9kZUxpc3QodGhpcy5lbCwgY2lkKS5sZW5ndGggPT09IDBcbiAgICAgICAgfSlcblxuICAgICAgICBpZihjb21wbGV0ZWx5RGVzdHJveUNJRHMubGVuZ3RoID4gMCl7XG4gICAgICAgICAgdGhpcy5wdXNoV2l0aFJlcGx5KG51bGwsIFwiY2lkc19kZXN0cm95ZWRcIiwge2NpZHM6IGNvbXBsZXRlbHlEZXN0cm95Q0lEc30sIChyZXNwKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVkLnBydW5lQ0lEcyhyZXNwLmNpZHMpXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICBvd25zRWxlbWVudChlbCl7XG4gICAgcmV0dXJuIGVsLmdldEF0dHJpYnV0ZShQSFhfUEFSRU5UX0lEKSA9PT0gdGhpcy5pZCB8fFxuICAgICAgbWF5YmUoZWwuY2xvc2VzdChQSFhfVklFV19TRUxFQ1RPUiksIG5vZGUgPT4gbm9kZS5pZCkgPT09IHRoaXMuaWRcbiAgfVxuXG4gIHN1Ym1pdEZvcm0oZm9ybSwgdGFyZ2V0Q3R4LCBwaHhFdmVudCwgb3B0cyA9IHt9KXtcbiAgICBET00ucHV0UHJpdmF0ZShmb3JtLCBQSFhfSEFTX1NVQk1JVFRFRCwgdHJ1ZSlcbiAgICBsZXQgcGh4RmVlZGJhY2sgPSB0aGlzLmxpdmVTb2NrZXQuYmluZGluZyhQSFhfRkVFREJBQ0tfRk9SKVxuICAgIGxldCBpbnB1dHMgPSBBcnJheS5mcm9tKGZvcm0uZWxlbWVudHMpXG4gICAgdGhpcy5saXZlU29ja2V0LmJsdXJBY3RpdmVFbGVtZW50KHRoaXMpXG4gICAgdGhpcy5wdXNoRm9ybVN1Ym1pdChmb3JtLCB0YXJnZXRDdHgsIHBoeEV2ZW50LCBvcHRzLCAoKSA9PiB7XG4gICAgICBpbnB1dHMuZm9yRWFjaChpbnB1dCA9PiBET00uc2hvd0Vycm9yKGlucHV0LCBwaHhGZWVkYmFjaykpXG4gICAgICB0aGlzLmxpdmVTb2NrZXQucmVzdG9yZVByZXZpb3VzbHlBY3RpdmVGb2N1cygpXG4gICAgfSlcbiAgfVxuXG4gIGJpbmRpbmcoa2luZCl7IHJldHVybiB0aGlzLmxpdmVTb2NrZXQuYmluZGluZyhraW5kKSB9XG59XG4iLCAiLyoqIEluaXRpYWxpemVzIHRoZSBMaXZlU29ja2V0XG4gKlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBlbmRQb2ludCAtIFRoZSBzdHJpbmcgV2ViU29ja2V0IGVuZHBvaW50LCBpZSwgYFwid3NzOi8vZXhhbXBsZS5jb20vbGl2ZVwiYCxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgXCIvbGl2ZVwiYCAoaW5oZXJpdGVkIGhvc3QgJiBwcm90b2NvbClcbiAqIEBwYXJhbSB7UGhvZW5peC5Tb2NrZXR9IHNvY2tldCAtIHRoZSByZXF1aXJlZCBQaG9lbml4IFNvY2tldCBjbGFzcyBpbXBvcnRlZCBmcm9tIFwicGhvZW5peFwiLiBGb3IgZXhhbXBsZTpcbiAqXG4gKiAgICAgaW1wb3J0IHtTb2NrZXR9IGZyb20gXCJwaG9lbml4XCJcbiAqICAgICBpbXBvcnQge0xpdmVTb2NrZXR9IGZyb20gXCJwaG9lbml4X2xpdmVfdmlld1wiXG4gKiAgICAgbGV0IGxpdmVTb2NrZXQgPSBuZXcgTGl2ZVNvY2tldChcIi9saXZlXCIsIFNvY2tldCwgey4uLn0pXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRzXSAtIE9wdGlvbmFsIGNvbmZpZ3VyYXRpb24uIE91dHNpZGUgb2Yga2V5cyBsaXN0ZWQgYmVsb3csIGFsbFxuICogY29uZmlndXJhdGlvbiBpcyBwYXNzZWQgZGlyZWN0bHkgdG8gdGhlIFBob2VuaXggU29ja2V0IGNvbnN0cnVjdG9yLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRzLmRlZmF1bHRzXSAtIFRoZSBvcHRpb25hbCBkZWZhdWx0cyB0byB1c2UgZm9yIHZhcmlvdXMgYmluZGluZ3MsXG4gKiBzdWNoIGFzIGBwaHgtZGVib3VuY2VgLiBTdXBwb3J0cyB0aGUgZm9sbG93aW5nIGtleXM6XG4gKlxuICogICAtIGRlYm91bmNlIC0gdGhlIG1pbGxpc2Vjb25kIHBoeC1kZWJvdW5jZSB0aW1lLiBEZWZhdWx0cyAzMDBcbiAqICAgLSB0aHJvdHRsZSAtIHRoZSBtaWxsaXNlY29uZCBwaHgtdGhyb3R0bGUgdGltZS4gRGVmYXVsdHMgMzAwXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdHMucGFyYW1zXSAtIFRoZSBvcHRpb25hbCBmdW5jdGlvbiBmb3IgcGFzc2luZyBjb25uZWN0IHBhcmFtcy5cbiAqIFRoZSBmdW5jdGlvbiByZWNlaXZlcyB0aGUgZWxlbWVudCBhc3NvY2lhdGVkIHdpdGggYSBnaXZlbiBMaXZlVmlldy4gRm9yIGV4YW1wbGU6XG4gKlxuICogICAgIChlbCkgPT4ge3ZpZXc6IGVsLmdldEF0dHJpYnV0ZShcImRhdGEtbXktdmlldy1uYW1lXCIsIHRva2VuOiB3aW5kb3cubXlUb2tlbn1cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuYmluZGluZ1ByZWZpeF0gLSBUaGUgb3B0aW9uYWwgcHJlZml4IHRvIHVzZSBmb3IgYWxsIHBoeCBET00gYW5ub3RhdGlvbnMuXG4gKiBEZWZhdWx0cyB0byBcInBoeC1cIi5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0cy5ob29rc10gLSBUaGUgb3B0aW9uYWwgb2JqZWN0IGZvciByZWZlcmVuY2luZyBMaXZlVmlldyBob29rIGNhbGxiYWNrcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0cy51cGxvYWRlcnNdIC0gVGhlIG9wdGlvbmFsIG9iamVjdCBmb3IgcmVmZXJlbmNpbmcgTGl2ZVZpZXcgdXBsb2FkZXIgY2FsbGJhY2tzLlxuICogQHBhcmFtIHtpbnRlZ2VyfSBbb3B0cy5sb2FkZXJUaW1lb3V0XSAtIFRoZSBvcHRpb25hbCBkZWxheSBpbiBtaWxsaXNlY29uZHMgdG8gd2FpdCBiZWZvcmUgYXBwbHlcbiAqIGxvYWRpbmcgc3RhdGVzLlxuICogQHBhcmFtIHtpbnRlZ2VyfSBbb3B0cy5tYXhSZWxvYWRzXSAtIFRoZSBtYXhpbXVtIHJlbG9hZHMgYmVmb3JlIGVudGVyaW5nIGZhaWxzYWZlIG1vZGUuXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFtvcHRzLnJlbG9hZEppdHRlck1pbl0gLSBUaGUgbWluaW11bSB0aW1lIGJldHdlZW4gbm9ybWFsIHJlbG9hZCBhdHRlbXB0cy5cbiAqIEBwYXJhbSB7aW50ZWdlcn0gW29wdHMucmVsb2FkSml0dGVyTWF4XSAtIFRoZSBtYXhpbXVtIHRpbWUgYmV0d2VlbiBub3JtYWwgcmVsb2FkIGF0dGVtcHRzLlxuICogQHBhcmFtIHtpbnRlZ2VyfSBbb3B0cy5mYWlsc2FmZUppdHRlcl0gLSBUaGUgdGltZSBiZXR3ZWVuIHJlbG9hZCBhdHRlbXB0cyBpbiBmYWlsc2FmZSBtb2RlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdHMudmlld0xvZ2dlcl0gLSBUaGUgb3B0aW9uYWwgZnVuY3Rpb24gdG8gbG9nIGRlYnVnIGluZm9ybWF0aW9uLiBGb3IgZXhhbXBsZTpcbiAqXG4gKiAgICAgKHZpZXcsIGtpbmQsIG1zZywgb2JqKSA9PiBjb25zb2xlLmxvZyhgJHt2aWV3LmlkfSAke2tpbmR9OiAke21zZ30gLSBgLCBvYmopXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRzLm1ldGFkYXRhXSAtIFRoZSBvcHRpb25hbCBvYmplY3QgbWFwcGluZyBldmVudCBuYW1lcyB0byBmdW5jdGlvbnMgZm9yXG4gKiBwb3B1bGF0aW5nIGV2ZW50IG1ldGFkYXRhLiBGb3IgZXhhbXBsZTpcbiAqXG4gKiAgICAgbWV0YWRhdGE6IHtcbiAqICAgICAgIGNsaWNrOiAoZSwgZWwpID0+IHtcbiAqICAgICAgICAgcmV0dXJuIHtcbiAqICAgICAgICAgICBjdHJsS2V5OiBlLmN0cmxLZXksXG4gKiAgICAgICAgICAgbWV0YUtleTogZS5tZXRhS2V5LFxuICogICAgICAgICAgIGRldGFpbDogZS5kZXRhaWwgfHwgMSxcbiAqICAgICAgICAgfVxuICogICAgICAgfSxcbiAqICAgICAgIGtleWRvd246IChlLCBlbCkgPT4ge1xuICogICAgICAgICByZXR1cm4ge1xuICogICAgICAgICAgIGtleTogZS5rZXksXG4gKiAgICAgICAgICAgY3RybEtleTogZS5jdHJsS2V5LFxuICogICAgICAgICAgIG1ldGFLZXk6IGUubWV0YUtleSxcbiAqICAgICAgICAgICBzaGlmdEtleTogZS5zaGlmdEtleVxuICogICAgICAgICB9XG4gKiAgICAgICB9XG4gKiAgICAgfVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRzLnNlc3Npb25TdG9yYWdlXSAtIEFuIG9wdGlvbmFsIFN0b3JhZ2UgY29tcGF0aWJsZSBvYmplY3RcbiAqIFVzZWZ1bCB3aGVuIExpdmVWaWV3IHdvbid0IGhhdmUgYWNjZXNzIHRvIGBzZXNzaW9uU3RvcmFnZWAuICBGb3IgZXhhbXBsZSwgVGhpcyBjb3VsZFxuICogaGFwcGVuIGlmIGEgc2l0ZSBsb2FkcyBhIGNyb3NzLWRvbWFpbiBMaXZlVmlldyBpbiBhbiBpZnJhbWUuICBFeGFtcGxlIHVzYWdlOlxuICpcbiAqICAgICBjbGFzcyBJbk1lbW9yeVN0b3JhZ2Uge1xuICogICAgICAgY29uc3RydWN0b3IoKSB7IHRoaXMuc3RvcmFnZSA9IHt9IH1cbiAqICAgICAgIGdldEl0ZW0oa2V5TmFtZSkgeyByZXR1cm4gdGhpcy5zdG9yYWdlW2tleU5hbWVdIH1cbiAqICAgICAgIHJlbW92ZUl0ZW0oa2V5TmFtZSkgeyBkZWxldGUgdGhpcy5zdG9yYWdlW2tleU5hbWVdIH1cbiAqICAgICAgIHNldEl0ZW0oa2V5TmFtZSwga2V5VmFsdWUpIHsgdGhpcy5zdG9yYWdlW2tleU5hbWVdID0ga2V5VmFsdWUgfVxuICogICAgIH1cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdHMubG9jYWxTdG9yYWdlXSAtIEFuIG9wdGlvbmFsIFN0b3JhZ2UgY29tcGF0aWJsZSBvYmplY3RcbiAqIFVzZWZ1bCBmb3Igd2hlbiBMaXZlVmlldyB3b24ndCBoYXZlIGFjY2VzcyB0byBgbG9jYWxTdG9yYWdlYC5cbiAqIFNlZSBgb3B0cy5zZXNzaW9uU3RvcmFnZWAgZm9yIGV4YW1wbGVzLlxuKi9cblxuaW1wb3J0IHtcbiAgQklORElOR19QUkVGSVgsXG4gIENPTlNFQ1VUSVZFX1JFTE9BRFMsXG4gIERFRkFVTFRTLFxuICBGQUlMU0FGRV9KSVRURVIsXG4gIExPQURFUl9USU1FT1VULFxuICBNQVhfUkVMT0FEUyxcbiAgUEhYX0RFQk9VTkNFLFxuICBQSFhfRFJPUF9UQVJHRVQsXG4gIFBIWF9IQVNfRk9DVVNFRCxcbiAgUEhYX0tFWSxcbiAgUEhYX0xJTktfU1RBVEUsXG4gIFBIWF9MSVZFX0xJTkssXG4gIFBIWF9MVl9ERUJVRyxcbiAgUEhYX0xWX0xBVEVOQ1lfU0lNLFxuICBQSFhfTFZfUFJPRklMRSxcbiAgUEhYX01BSU4sXG4gIFBIWF9QQVJFTlRfSUQsXG4gIFBIWF9WSUVXX1NFTEVDVE9SLFxuICBQSFhfUk9PVF9JRCxcbiAgUEhYX1RIUk9UVExFLFxuICBQSFhfVFJBQ0tfVVBMT0FEUyxcbiAgUEhYX1NFU1NJT04sXG4gIFJFTE9BRF9KSVRURVJfTUlOLFxuICBSRUxPQURfSklUVEVSX01BWCxcbn0gZnJvbSBcIi4vY29uc3RhbnRzXCJcblxuaW1wb3J0IHtcbiAgY2xvbmUsXG4gIGNsb3Nlc3RQaHhCaW5kaW5nLFxuICBjbG9zdXJlLFxuICBkZWJ1ZyxcbiAgaXNPYmplY3QsXG4gIG1heWJlXG59IGZyb20gXCIuL3V0aWxzXCJcblxuaW1wb3J0IEJyb3dzZXIgZnJvbSBcIi4vYnJvd3NlclwiXG5pbXBvcnQgRE9NIGZyb20gXCIuL2RvbVwiXG5pbXBvcnQgSG9va3MgZnJvbSBcIi4vaG9va3NcIlxuaW1wb3J0IExpdmVVcGxvYWRlciBmcm9tIFwiLi9saXZlX3VwbG9hZGVyXCJcbmltcG9ydCBWaWV3IGZyb20gXCIuL3ZpZXdcIlxuaW1wb3J0IEpTIGZyb20gXCIuL2pzXCJcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGl2ZVNvY2tldCB7XG4gIGNvbnN0cnVjdG9yKHVybCwgcGh4U29ja2V0LCBvcHRzID0ge30pe1xuICAgIHRoaXMudW5sb2FkZWQgPSBmYWxzZVxuICAgIGlmKCFwaHhTb2NrZXQgfHwgcGh4U29ja2V0LmNvbnN0cnVjdG9yLm5hbWUgPT09IFwiT2JqZWN0XCIpe1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBcbiAgICAgIGEgcGhvZW5peCBTb2NrZXQgbXVzdCBiZSBwcm92aWRlZCBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50IHRvIHRoZSBMaXZlU29ja2V0IGNvbnN0cnVjdG9yLiBGb3IgZXhhbXBsZTpcblxuICAgICAgICAgIGltcG9ydCB7U29ja2V0fSBmcm9tIFwicGhvZW5peFwiXG4gICAgICAgICAgaW1wb3J0IHtMaXZlU29ja2V0fSBmcm9tIFwicGhvZW5peF9saXZlX3ZpZXdcIlxuICAgICAgICAgIGxldCBsaXZlU29ja2V0ID0gbmV3IExpdmVTb2NrZXQoXCIvbGl2ZVwiLCBTb2NrZXQsIHsuLi59KVxuICAgICAgYClcbiAgICB9XG4gICAgdGhpcy5zb2NrZXQgPSBuZXcgcGh4U29ja2V0KHVybCwgb3B0cylcbiAgICB0aGlzLmJpbmRpbmdQcmVmaXggPSBvcHRzLmJpbmRpbmdQcmVmaXggfHwgQklORElOR19QUkVGSVhcbiAgICB0aGlzLm9wdHMgPSBvcHRzXG4gICAgdGhpcy5wYXJhbXMgPSBjbG9zdXJlKG9wdHMucGFyYW1zIHx8IHt9KVxuICAgIHRoaXMudmlld0xvZ2dlciA9IG9wdHMudmlld0xvZ2dlclxuICAgIHRoaXMubWV0YWRhdGFDYWxsYmFja3MgPSBvcHRzLm1ldGFkYXRhIHx8IHt9XG4gICAgdGhpcy5kZWZhdWx0cyA9IE9iamVjdC5hc3NpZ24oY2xvbmUoREVGQVVMVFMpLCBvcHRzLmRlZmF1bHRzIHx8IHt9KVxuICAgIHRoaXMuYWN0aXZlRWxlbWVudCA9IG51bGxcbiAgICB0aGlzLnByZXZBY3RpdmUgPSBudWxsXG4gICAgdGhpcy5zaWxlbmNlZCA9IGZhbHNlXG4gICAgdGhpcy5tYWluID0gbnVsbFxuICAgIHRoaXMub3V0Z29pbmdNYWluRWwgPSBudWxsXG4gICAgdGhpcy5jbGlja1N0YXJ0ZWRBdFRhcmdldCA9IG51bGxcbiAgICB0aGlzLmxpbmtSZWYgPSAxXG4gICAgdGhpcy5yb290cyA9IHt9XG4gICAgdGhpcy5ocmVmID0gd2luZG93LmxvY2F0aW9uLmhyZWZcbiAgICB0aGlzLnBlbmRpbmdMaW5rID0gbnVsbFxuICAgIHRoaXMuY3VycmVudExvY2F0aW9uID0gY2xvbmUod2luZG93LmxvY2F0aW9uKVxuICAgIHRoaXMuaG9va3MgPSBvcHRzLmhvb2tzIHx8IHt9XG4gICAgdGhpcy51cGxvYWRlcnMgPSBvcHRzLnVwbG9hZGVycyB8fCB7fVxuICAgIHRoaXMubG9hZGVyVGltZW91dCA9IG9wdHMubG9hZGVyVGltZW91dCB8fCBMT0FERVJfVElNRU9VVFxuICAgIHRoaXMubWF4UmVsb2FkcyA9IG9wdHMubWF4UmVsb2FkcyB8fCBNQVhfUkVMT0FEU1xuICAgIHRoaXMucmVsb2FkSml0dGVyTWluID0gb3B0cy5yZWxvYWRKaXR0ZXJNaW4gfHwgUkVMT0FEX0pJVFRFUl9NSU5cbiAgICB0aGlzLnJlbG9hZEppdHRlck1heCA9IG9wdHMucmVsb2FkSml0dGVyTWF4IHx8IFJFTE9BRF9KSVRURVJfTUFYXG4gICAgdGhpcy5mYWlsc2FmZUppdHRlciA9IG9wdHMuZmFpbHNhZmVKaXR0ZXIgfHwgRkFJTFNBRkVfSklUVEVSXG4gICAgdGhpcy5sb2NhbFN0b3JhZ2UgPSBvcHRzLmxvY2FsU3RvcmFnZSB8fCB3aW5kb3cubG9jYWxTdG9yYWdlXG4gICAgdGhpcy5zZXNzaW9uU3RvcmFnZSA9IG9wdHMuc2Vzc2lvblN0b3JhZ2UgfHwgd2luZG93LnNlc3Npb25TdG9yYWdlXG4gICAgdGhpcy5ib3VuZFRvcExldmVsRXZlbnRzID0gZmFsc2VcbiAgICB0aGlzLmRvbUNhbGxiYWNrcyA9IE9iamVjdC5hc3NpZ24oe29uTm9kZUFkZGVkOiBjbG9zdXJlKCksIG9uQmVmb3JlRWxVcGRhdGVkOiBjbG9zdXJlKCl9LCBvcHRzLmRvbSB8fCB7fSlcbiAgICB0aGlzLnRyYW5zaXRpb25zID0gbmV3IFRyYW5zaXRpb25TZXQoKVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicGFnZWhpZGVcIiwgX2UgPT4ge1xuICAgICAgdGhpcy51bmxvYWRlZCA9IHRydWVcbiAgICB9KVxuICAgIHRoaXMuc29ja2V0Lm9uT3BlbigoKSA9PiB7XG4gICAgICBpZih0aGlzLmlzVW5sb2FkZWQoKSl7XG4gICAgICAgIC8vIHJlbG9hZCBwYWdlIGlmIGJlaW5nIHJlc3RvcmVkIGZyb20gYmFjay9mb3J3YXJkIGNhY2hlIGFuZCBicm93c2VyIGRvZXMgbm90IGVtaXQgXCJwYWdlc2hvd1wiXG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICAvLyBwdWJsaWNcblxuICBpc1Byb2ZpbGVFbmFibGVkKCl7IHJldHVybiB0aGlzLnNlc3Npb25TdG9yYWdlLmdldEl0ZW0oUEhYX0xWX1BST0ZJTEUpID09PSBcInRydWVcIiB9XG5cbiAgaXNEZWJ1Z0VuYWJsZWQoKXsgcmV0dXJuIHRoaXMuc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbShQSFhfTFZfREVCVUcpID09PSBcInRydWVcIiB9XG5cbiAgaXNEZWJ1Z0Rpc2FibGVkKCl7IHJldHVybiB0aGlzLnNlc3Npb25TdG9yYWdlLmdldEl0ZW0oUEhYX0xWX0RFQlVHKSA9PT0gXCJmYWxzZVwiIH1cblxuICBlbmFibGVEZWJ1ZygpeyB0aGlzLnNlc3Npb25TdG9yYWdlLnNldEl0ZW0oUEhYX0xWX0RFQlVHLCBcInRydWVcIikgfVxuXG4gIGVuYWJsZVByb2ZpbGluZygpeyB0aGlzLnNlc3Npb25TdG9yYWdlLnNldEl0ZW0oUEhYX0xWX1BST0ZJTEUsIFwidHJ1ZVwiKSB9XG5cbiAgZGlzYWJsZURlYnVnKCl7IHRoaXMuc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShQSFhfTFZfREVCVUcsIFwiZmFsc2VcIikgfVxuXG4gIGRpc2FibGVQcm9maWxpbmcoKXsgdGhpcy5zZXNzaW9uU3RvcmFnZS5yZW1vdmVJdGVtKFBIWF9MVl9QUk9GSUxFKSB9XG5cbiAgZW5hYmxlTGF0ZW5jeVNpbSh1cHBlckJvdW5kTXMpe1xuICAgIHRoaXMuZW5hYmxlRGVidWcoKVxuICAgIGNvbnNvbGUubG9nKFwibGF0ZW5jeSBzaW11bGF0b3IgZW5hYmxlZCBmb3IgdGhlIGR1cmF0aW9uIG9mIHRoaXMgYnJvd3NlciBzZXNzaW9uLiBDYWxsIGRpc2FibGVMYXRlbmN5U2ltKCkgdG8gZGlzYWJsZVwiKVxuICAgIHRoaXMuc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShQSFhfTFZfTEFURU5DWV9TSU0sIHVwcGVyQm91bmRNcylcbiAgfVxuXG4gIGRpc2FibGVMYXRlbmN5U2ltKCl7IHRoaXMuc2Vzc2lvblN0b3JhZ2UucmVtb3ZlSXRlbShQSFhfTFZfTEFURU5DWV9TSU0pIH1cblxuICBnZXRMYXRlbmN5U2ltKCl7XG4gICAgbGV0IHN0ciA9IHRoaXMuc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbShQSFhfTFZfTEFURU5DWV9TSU0pXG4gICAgcmV0dXJuIHN0ciA/IHBhcnNlSW50KHN0cikgOiBudWxsXG4gIH1cblxuICBnZXRTb2NrZXQoKXsgcmV0dXJuIHRoaXMuc29ja2V0IH1cblxuICBjb25uZWN0KCl7XG4gICAgLy8gZW5hYmxlIGRlYnVnIGJ5IGRlZmF1bHQgaWYgb24gbG9jYWxob3N0IGFuZCBub3QgZXhwbGljaXRseSBkaXNhYmxlZFxuICAgIGlmKHdpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZSA9PT0gXCJsb2NhbGhvc3RcIiAmJiAhdGhpcy5pc0RlYnVnRGlzYWJsZWQoKSl7IHRoaXMuZW5hYmxlRGVidWcoKSB9XG4gICAgbGV0IGRvQ29ubmVjdCA9ICgpID0+IHtcbiAgICAgIGlmKHRoaXMuam9pblJvb3RWaWV3cygpKXtcbiAgICAgICAgdGhpcy5iaW5kVG9wTGV2ZWxFdmVudHMoKVxuICAgICAgICB0aGlzLnNvY2tldC5jb25uZWN0KClcbiAgICAgIH1cbiAgICB9XG4gICAgaWYoW1wiY29tcGxldGVcIiwgXCJsb2FkZWRcIiwgXCJpbnRlcmFjdGl2ZVwiXS5pbmRleE9mKGRvY3VtZW50LnJlYWR5U3RhdGUpID49IDApe1xuICAgICAgZG9Db25uZWN0KClcbiAgICB9IGVsc2Uge1xuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIiwgKCkgPT4gZG9Db25uZWN0KCkpXG4gICAgfVxuICB9XG5cbiAgZGlzY29ubmVjdChjYWxsYmFjayl7IHRoaXMuc29ja2V0LmRpc2Nvbm5lY3QoY2FsbGJhY2spIH1cblxuICBleGVjSlMoZWwsIGVuY29kZWRKUywgZXZlbnRUeXBlID0gbnVsbCl7XG4gICAgdGhpcy5vd25lcihlbCwgdmlldyA9PiBKUy5leGVjKGV2ZW50VHlwZSwgZW5jb2RlZEpTLCB2aWV3LCBlbCkpXG4gIH1cblxuICAvLyBwcml2YXRlXG5cbiAgdHJpZ2dlckRPTShraW5kLCBhcmdzKXsgdGhpcy5kb21DYWxsYmFja3Nba2luZF0oLi4uYXJncykgfVxuXG4gIHRpbWUobmFtZSwgZnVuYyl7XG4gICAgaWYoIXRoaXMuaXNQcm9maWxlRW5hYmxlZCgpIHx8ICFjb25zb2xlLnRpbWUpeyByZXR1cm4gZnVuYygpIH1cbiAgICBjb25zb2xlLnRpbWUobmFtZSlcbiAgICBsZXQgcmVzdWx0ID0gZnVuYygpXG4gICAgY29uc29sZS50aW1lRW5kKG5hbWUpXG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgbG9nKHZpZXcsIGtpbmQsIG1zZ0NhbGxiYWNrKXtcbiAgICBpZih0aGlzLnZpZXdMb2dnZXIpe1xuICAgICAgbGV0IFttc2csIG9ial0gPSBtc2dDYWxsYmFjaygpXG4gICAgICB0aGlzLnZpZXdMb2dnZXIodmlldywga2luZCwgbXNnLCBvYmopXG4gICAgfSBlbHNlIGlmKHRoaXMuaXNEZWJ1Z0VuYWJsZWQoKSl7XG4gICAgICBsZXQgW21zZywgb2JqXSA9IG1zZ0NhbGxiYWNrKClcbiAgICAgIGRlYnVnKHZpZXcsIGtpbmQsIG1zZywgb2JqKVxuICAgIH1cbiAgfVxuXG4gIHJlcXVlc3RET01VcGRhdGUoY2FsbGJhY2spe1xuICAgIHRoaXMudHJhbnNpdGlvbnMuYWZ0ZXIoY2FsbGJhY2spXG4gIH1cblxuICB0cmFuc2l0aW9uKHRpbWUsIG9uU3RhcnQsIG9uRG9uZSA9IGZ1bmN0aW9uKCl7fSl7XG4gICAgdGhpcy50cmFuc2l0aW9ucy5hZGRUcmFuc2l0aW9uKHRpbWUsIG9uU3RhcnQsIG9uRG9uZSlcbiAgfVxuXG4gIG9uQ2hhbm5lbChjaGFubmVsLCBldmVudCwgY2Ipe1xuICAgIGNoYW5uZWwub24oZXZlbnQsIGRhdGEgPT4ge1xuICAgICAgbGV0IGxhdGVuY3kgPSB0aGlzLmdldExhdGVuY3lTaW0oKVxuICAgICAgaWYoIWxhdGVuY3kpe1xuICAgICAgICBjYihkYXRhKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5sb2coYHNpbXVsYXRpbmcgJHtsYXRlbmN5fW1zIG9mIGxhdGVuY3kgZnJvbSBzZXJ2ZXIgdG8gY2xpZW50YClcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiBjYihkYXRhKSwgbGF0ZW5jeSlcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgd3JhcFB1c2godmlldywgb3B0cywgcHVzaCl7XG4gICAgbGV0IGxhdGVuY3kgPSB0aGlzLmdldExhdGVuY3lTaW0oKVxuICAgIGxldCBvbGRKb2luQ291bnQgPSB2aWV3LmpvaW5Db3VudFxuICAgIGlmKCFsYXRlbmN5KXtcbiAgICAgIGlmKHRoaXMuaXNDb25uZWN0ZWQoKSAmJiBvcHRzLnRpbWVvdXQpe1xuICAgICAgICByZXR1cm4gcHVzaCgpLnJlY2VpdmUoXCJ0aW1lb3V0XCIsICgpID0+IHtcbiAgICAgICAgICBpZih2aWV3LmpvaW5Db3VudCA9PT0gb2xkSm9pbkNvdW50ICYmICF2aWV3LmlzRGVzdHJveWVkKCkpe1xuICAgICAgICAgICAgdGhpcy5yZWxvYWRXaXRoSml0dGVyKHZpZXcsICgpID0+IHtcbiAgICAgICAgICAgICAgdGhpcy5sb2codmlldywgXCJ0aW1lb3V0XCIsICgpID0+IFtcInJlY2VpdmVkIHRpbWVvdXQgd2hpbGUgY29tbXVuaWNhdGluZyB3aXRoIHNlcnZlci4gRmFsbGluZyBiYWNrIHRvIGhhcmQgcmVmcmVzaCBmb3IgcmVjb3ZlcnlcIl0pXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBwdXNoKClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zb2xlLmxvZyhgc2ltdWxhdGluZyAke2xhdGVuY3l9bXMgb2YgbGF0ZW5jeSBmcm9tIGNsaWVudCB0byBzZXJ2ZXJgKVxuICAgIGxldCBmYWtlUHVzaCA9IHtcbiAgICAgIHJlY2VpdmVzOiBbXSxcbiAgICAgIHJlY2VpdmUoa2luZCwgY2IpeyB0aGlzLnJlY2VpdmVzLnB1c2goW2tpbmQsIGNiXSkgfVxuICAgIH1cbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGlmKHZpZXcuaXNEZXN0cm95ZWQoKSl7IHJldHVybiB9XG4gICAgICBmYWtlUHVzaC5yZWNlaXZlcy5yZWR1Y2UoKGFjYywgW2tpbmQsIGNiXSkgPT4gYWNjLnJlY2VpdmUoa2luZCwgY2IpLCBwdXNoKCkpXG4gICAgfSwgbGF0ZW5jeSlcbiAgICByZXR1cm4gZmFrZVB1c2hcbiAgfVxuXG4gIHJlbG9hZFdpdGhKaXR0ZXIodmlldywgbG9nKXtcbiAgICB2aWV3LmRlc3Ryb3koKVxuICAgIHRoaXMuZGlzY29ubmVjdCgpXG4gICAgbGV0IG1pbk1zID0gdGhpcy5yZWxvYWRKaXR0ZXJNaW5cbiAgICBsZXQgbWF4TXMgPSB0aGlzLnJlbG9hZEppdHRlck1heFxuICAgIGxldCBhZnRlck1zID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKG1heE1zIC0gbWluTXMgKyAxKSkgKyBtaW5Nc1xuICAgIGxldCB0cmllcyA9IEJyb3dzZXIudXBkYXRlTG9jYWwodGhpcy5sb2NhbFN0b3JhZ2UsIHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZSwgQ09OU0VDVVRJVkVfUkVMT0FEUywgMCwgY291bnQgPT4gY291bnQgKyAxKVxuICAgIGxvZyA/IGxvZygpIDogdGhpcy5sb2codmlldywgXCJqb2luXCIsICgpID0+IFtgZW5jb3VudGVyZWQgJHt0cmllc30gY29uc2VjdXRpdmUgcmVsb2Fkc2BdKVxuICAgIGlmKHRyaWVzID4gdGhpcy5tYXhSZWxvYWRzKXtcbiAgICAgIHRoaXMubG9nKHZpZXcsIFwiam9pblwiLCAoKSA9PiBbYGV4Y2VlZGVkICR7dGhpcy5tYXhSZWxvYWRzfSBjb25zZWN1dGl2ZSByZWxvYWRzLiBFbnRlcmluZyBmYWlsc2FmZSBtb2RlYF0pXG4gICAgICBhZnRlck1zID0gdGhpcy5mYWlsc2FmZUppdHRlclxuICAgIH1cbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGlmKHRoaXMuaGFzUGVuZGluZ0xpbmsoKSl7XG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbiA9IHRoaXMucGVuZGluZ0xpbmtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKVxuICAgICAgfVxuICAgIH0sIGFmdGVyTXMpXG4gIH1cblxuICBnZXRIb29rQ2FsbGJhY2tzKG5hbWUpe1xuICAgIHJldHVybiBuYW1lICYmIG5hbWUuc3RhcnRzV2l0aChcIlBob2VuaXguXCIpID8gSG9va3NbbmFtZS5zcGxpdChcIi5cIilbMV1dIDogdGhpcy5ob29rc1tuYW1lXVxuICB9XG5cbiAgaXNVbmxvYWRlZCgpeyByZXR1cm4gdGhpcy51bmxvYWRlZCB9XG5cbiAgaXNDb25uZWN0ZWQoKXsgcmV0dXJuIHRoaXMuc29ja2V0LmlzQ29ubmVjdGVkKCkgfVxuXG4gIGdldEJpbmRpbmdQcmVmaXgoKXsgcmV0dXJuIHRoaXMuYmluZGluZ1ByZWZpeCB9XG5cbiAgYmluZGluZyhraW5kKXsgcmV0dXJuIGAke3RoaXMuZ2V0QmluZGluZ1ByZWZpeCgpfSR7a2luZH1gIH1cblxuICBjaGFubmVsKHRvcGljLCBwYXJhbXMpeyByZXR1cm4gdGhpcy5zb2NrZXQuY2hhbm5lbCh0b3BpYywgcGFyYW1zKSB9XG5cbiAgam9pblJvb3RWaWV3cygpe1xuICAgIGxldCByb290c0ZvdW5kID0gZmFsc2VcbiAgICBET00uYWxsKGRvY3VtZW50LCBgJHtQSFhfVklFV19TRUxFQ1RPUn06bm90KFske1BIWF9QQVJFTlRfSUR9XSlgLCByb290RWwgPT4ge1xuICAgICAgaWYoIXRoaXMuZ2V0Um9vdEJ5SWQocm9vdEVsLmlkKSl7XG4gICAgICAgIGxldCB2aWV3ID0gdGhpcy5uZXdSb290Vmlldyhyb290RWwpXG4gICAgICAgIHZpZXcuc2V0SHJlZih0aGlzLmdldEhyZWYoKSlcbiAgICAgICAgdmlldy5qb2luKClcbiAgICAgICAgaWYocm9vdEVsLmdldEF0dHJpYnV0ZShQSFhfTUFJTikpeyB0aGlzLm1haW4gPSB2aWV3IH1cbiAgICAgIH1cbiAgICAgIHJvb3RzRm91bmQgPSB0cnVlXG4gICAgfSlcbiAgICByZXR1cm4gcm9vdHNGb3VuZFxuICB9XG5cbiAgcmVkaXJlY3QodG8sIGZsYXNoKXtcbiAgICB0aGlzLmRpc2Nvbm5lY3QoKVxuICAgIEJyb3dzZXIucmVkaXJlY3QodG8sIGZsYXNoKVxuICB9XG5cbiAgcmVwbGFjZU1haW4oaHJlZiwgZmxhc2gsIGNhbGxiYWNrID0gbnVsbCwgbGlua1JlZiA9IHRoaXMuc2V0UGVuZGluZ0xpbmsoaHJlZikpe1xuICAgIHRoaXMub3V0Z29pbmdNYWluRWwgPSB0aGlzLm91dGdvaW5nTWFpbkVsIHx8IHRoaXMubWFpbi5lbFxuICAgIGxldCBuZXdNYWluRWwgPSBET00uY2xvbmVOb2RlKHRoaXMub3V0Z29pbmdNYWluRWwsIFwiXCIpXG4gICAgdGhpcy5tYWluLnNob3dMb2FkZXIodGhpcy5sb2FkZXJUaW1lb3V0KVxuICAgIHRoaXMubWFpbi5kZXN0cm95KClcblxuICAgIHRoaXMubWFpbiA9IHRoaXMubmV3Um9vdFZpZXcobmV3TWFpbkVsLCBmbGFzaClcbiAgICB0aGlzLm1haW4uc2V0UmVkaXJlY3QoaHJlZilcbiAgICB0aGlzLnRyYW5zaXRpb25SZW1vdmVzKClcbiAgICB0aGlzLm1haW4uam9pbigoam9pbkNvdW50LCBvbkRvbmUpID0+IHtcbiAgICAgIGlmKGpvaW5Db3VudCA9PT0gMSAmJiB0aGlzLmNvbW1pdFBlbmRpbmdMaW5rKGxpbmtSZWYpKXtcbiAgICAgICAgdGhpcy5yZXF1ZXN0RE9NVXBkYXRlKCgpID0+IHtcbiAgICAgICAgICBET00uZmluZFBoeFN0aWNreShkb2N1bWVudCkuZm9yRWFjaChlbCA9PiBuZXdNYWluRWwuYXBwZW5kQ2hpbGQoZWwpKVxuICAgICAgICAgIHRoaXMub3V0Z29pbmdNYWluRWwucmVwbGFjZVdpdGgobmV3TWFpbkVsKVxuICAgICAgICAgIHRoaXMub3V0Z29pbmdNYWluRWwgPSBudWxsXG4gICAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soKVxuICAgICAgICAgIG9uRG9uZSgpXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIHRyYW5zaXRpb25SZW1vdmVzKGVsZW1lbnRzKXtcbiAgICBsZXQgcmVtb3ZlQXR0ciA9IHRoaXMuYmluZGluZyhcInJlbW92ZVwiKVxuICAgIGVsZW1lbnRzID0gZWxlbWVudHMgfHwgRE9NLmFsbChkb2N1bWVudCwgYFske3JlbW92ZUF0dHJ9XWApXG4gICAgZWxlbWVudHMuZm9yRWFjaChlbCA9PiB7XG4gICAgICBpZihkb2N1bWVudC5ib2R5LmNvbnRhaW5zKGVsKSl7IC8vIHNraXAgY2hpbGRyZW4gYWxyZWFkeSByZW1vdmVkXG4gICAgICAgIHRoaXMuZXhlY0pTKGVsLCBlbC5nZXRBdHRyaWJ1dGUocmVtb3ZlQXR0ciksIFwicmVtb3ZlXCIpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIGlzUGh4VmlldyhlbCl7IHJldHVybiBlbC5nZXRBdHRyaWJ1dGUgJiYgZWwuZ2V0QXR0cmlidXRlKFBIWF9TRVNTSU9OKSAhPT0gbnVsbCB9XG5cbiAgbmV3Um9vdFZpZXcoZWwsIGZsYXNoKXtcbiAgICBsZXQgdmlldyA9IG5ldyBWaWV3KGVsLCB0aGlzLCBudWxsLCBmbGFzaClcbiAgICB0aGlzLnJvb3RzW3ZpZXcuaWRdID0gdmlld1xuICAgIHJldHVybiB2aWV3XG4gIH1cblxuICBvd25lcihjaGlsZEVsLCBjYWxsYmFjayl7XG4gICAgbGV0IHZpZXcgPSBtYXliZShjaGlsZEVsLmNsb3Nlc3QoUEhYX1ZJRVdfU0VMRUNUT1IpLCBlbCA9PiB0aGlzLmdldFZpZXdCeUVsKGVsKSkgfHwgdGhpcy5tYWluXG4gICAgaWYodmlldyl7IGNhbGxiYWNrKHZpZXcpIH1cbiAgfVxuXG4gIHdpdGhpbk93bmVycyhjaGlsZEVsLCBjYWxsYmFjayl7XG4gICAgdGhpcy5vd25lcihjaGlsZEVsLCB2aWV3ID0+IGNhbGxiYWNrKHZpZXcsIGNoaWxkRWwpKVxuICB9XG5cbiAgZ2V0Vmlld0J5RWwoZWwpe1xuICAgIGxldCByb290SWQgPSBlbC5nZXRBdHRyaWJ1dGUoUEhYX1JPT1RfSUQpXG4gICAgcmV0dXJuIG1heWJlKHRoaXMuZ2V0Um9vdEJ5SWQocm9vdElkKSwgcm9vdCA9PiByb290LmdldERlc2NlbmRlbnRCeUVsKGVsKSlcbiAgfVxuXG4gIGdldFJvb3RCeUlkKGlkKXsgcmV0dXJuIHRoaXMucm9vdHNbaWRdIH1cblxuICBkZXN0cm95QWxsVmlld3MoKXtcbiAgICBmb3IobGV0IGlkIGluIHRoaXMucm9vdHMpe1xuICAgICAgdGhpcy5yb290c1tpZF0uZGVzdHJveSgpXG4gICAgICBkZWxldGUgdGhpcy5yb290c1tpZF1cbiAgICB9XG4gIH1cblxuICBkZXN0cm95Vmlld0J5RWwoZWwpe1xuICAgIGxldCByb290ID0gdGhpcy5nZXRSb290QnlJZChlbC5nZXRBdHRyaWJ1dGUoUEhYX1JPT1RfSUQpKVxuICAgIGlmKHJvb3QgJiYgcm9vdC5pZCA9PT0gZWwuaWQpe1xuICAgICAgcm9vdC5kZXN0cm95KClcbiAgICAgIGRlbGV0ZSB0aGlzLnJvb3RzW3Jvb3QuaWRdXG4gICAgfSBlbHNlIGlmKHJvb3Qpe1xuICAgICAgcm9vdC5kZXN0cm95RGVzY2VuZGVudChlbC5pZClcbiAgICB9XG4gIH1cblxuICBzZXRBY3RpdmVFbGVtZW50KHRhcmdldCl7XG4gICAgaWYodGhpcy5hY3RpdmVFbGVtZW50ID09PSB0YXJnZXQpeyByZXR1cm4gfVxuICAgIHRoaXMuYWN0aXZlRWxlbWVudCA9IHRhcmdldFxuICAgIGxldCBjYW5jZWwgPSAoKSA9PiB7XG4gICAgICBpZih0YXJnZXQgPT09IHRoaXMuYWN0aXZlRWxlbWVudCl7IHRoaXMuYWN0aXZlRWxlbWVudCA9IG51bGwgfVxuICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIHRoaXMpXG4gICAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsIHRoaXMpXG4gICAgfVxuICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCBjYW5jZWwpXG4gICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCBjYW5jZWwpXG4gIH1cblxuICBnZXRBY3RpdmVFbGVtZW50KCl7XG4gICAgaWYoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gZG9jdW1lbnQuYm9keSl7XG4gICAgICByZXR1cm4gdGhpcy5hY3RpdmVFbGVtZW50IHx8IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnRcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCBjYW4gYmUgbnVsbCBpbiBJbnRlcm5ldCBFeHBsb3JlciAxMVxuICAgICAgcmV0dXJuIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgfHwgZG9jdW1lbnQuYm9keVxuICAgIH1cbiAgfVxuXG4gIGRyb3BBY3RpdmVFbGVtZW50KHZpZXcpe1xuICAgIGlmKHRoaXMucHJldkFjdGl2ZSAmJiB2aWV3Lm93bnNFbGVtZW50KHRoaXMucHJldkFjdGl2ZSkpe1xuICAgICAgdGhpcy5wcmV2QWN0aXZlID0gbnVsbFxuICAgIH1cbiAgfVxuXG4gIHJlc3RvcmVQcmV2aW91c2x5QWN0aXZlRm9jdXMoKXtcbiAgICBpZih0aGlzLnByZXZBY3RpdmUgJiYgdGhpcy5wcmV2QWN0aXZlICE9PSBkb2N1bWVudC5ib2R5KXtcbiAgICAgIHRoaXMucHJldkFjdGl2ZS5mb2N1cygpXG4gICAgfVxuICB9XG5cbiAgYmx1ckFjdGl2ZUVsZW1lbnQoKXtcbiAgICB0aGlzLnByZXZBY3RpdmUgPSB0aGlzLmdldEFjdGl2ZUVsZW1lbnQoKVxuICAgIGlmKHRoaXMucHJldkFjdGl2ZSAhPT0gZG9jdW1lbnQuYm9keSl7IHRoaXMucHJldkFjdGl2ZS5ibHVyKCkgfVxuICB9XG5cbiAgYmluZFRvcExldmVsRXZlbnRzKCl7XG4gICAgaWYodGhpcy5ib3VuZFRvcExldmVsRXZlbnRzKXsgcmV0dXJuIH1cblxuICAgIHRoaXMuYm91bmRUb3BMZXZlbEV2ZW50cyA9IHRydWVcbiAgICAvLyBlbnRlciBmYWlsc2FmZSByZWxvYWQgaWYgc2VydmVyIGhhcyBnb25lIGF3YXkgaW50ZW50aW9uYWxseSwgc3VjaCBhcyBcImRpc2Nvbm5lY3RcIiBicm9hZGNhc3RcbiAgICB0aGlzLnNvY2tldC5vbkNsb3NlKGV2ZW50ID0+IHtcbiAgICAgIGlmKGV2ZW50ICYmIGV2ZW50LmNvZGUgPT09IDEwMDAgJiYgdGhpcy5tYWluKXtcbiAgICAgICAgdGhpcy5yZWxvYWRXaXRoSml0dGVyKHRoaXMubWFpbilcbiAgICAgIH1cbiAgICB9KVxuICAgIGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGZ1bmN0aW9uICgpeyB9KSAvLyBlbnN1cmUgYWxsIGNsaWNrIGV2ZW50cyBidWJibGUgZm9yIG1vYmlsZSBTYWZhcmlcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBhZ2VzaG93XCIsIGUgPT4ge1xuICAgICAgaWYoZS5wZXJzaXN0ZWQpeyAvLyByZWxvYWQgcGFnZSBpZiBiZWluZyByZXN0b3JlZCBmcm9tIGJhY2svZm9yd2FyZCBjYWNoZVxuICAgICAgICB0aGlzLmdldFNvY2tldCgpLmRpc2Nvbm5lY3QoKVxuICAgICAgICB0aGlzLndpdGhQYWdlTG9hZGluZyh7dG86IHdpbmRvdy5sb2NhdGlvbi5ocmVmLCBraW5kOiBcInJlZGlyZWN0XCJ9KVxuICAgICAgICB3aW5kb3cubG9jYXRpb24ucmVsb2FkKClcbiAgICAgIH1cbiAgICB9LCB0cnVlKVxuICAgIHRoaXMuYmluZE5hdigpXG4gICAgdGhpcy5iaW5kQ2xpY2tzKClcbiAgICB0aGlzLmJpbmRGb3JtcygpXG4gICAgdGhpcy5iaW5kKHtrZXl1cDogXCJrZXl1cFwiLCBrZXlkb3duOiBcImtleWRvd25cIn0sIChlLCB0eXBlLCB2aWV3LCB0YXJnZXRFbCwgcGh4RXZlbnQsIGV2ZW50VGFyZ2V0KSA9PiB7XG4gICAgICBsZXQgbWF0Y2hLZXkgPSB0YXJnZXRFbC5nZXRBdHRyaWJ1dGUodGhpcy5iaW5kaW5nKFBIWF9LRVkpKVxuICAgICAgbGV0IHByZXNzZWRLZXkgPSBlLmtleSAmJiBlLmtleS50b0xvd2VyQ2FzZSgpIC8vIGNocm9tZSBjbGlja2VkIGF1dG9jb21wbGV0ZXMgc2VuZCBhIGtleWRvd24gd2l0aG91dCBrZXlcbiAgICAgIGlmKG1hdGNoS2V5ICYmIG1hdGNoS2V5LnRvTG93ZXJDYXNlKCkgIT09IHByZXNzZWRLZXkpeyByZXR1cm4gfVxuXG4gICAgICBsZXQgZGF0YSA9IHtrZXk6IGUua2V5LCAuLi50aGlzLmV2ZW50TWV0YSh0eXBlLCBlLCB0YXJnZXRFbCl9XG4gICAgICBKUy5leGVjKHR5cGUsIHBoeEV2ZW50LCB2aWV3LCB0YXJnZXRFbCwgW1wicHVzaFwiLCB7ZGF0YX1dKVxuICAgIH0pXG4gICAgdGhpcy5iaW5kKHtibHVyOiBcImZvY3Vzb3V0XCIsIGZvY3VzOiBcImZvY3VzaW5cIn0sIChlLCB0eXBlLCB2aWV3LCB0YXJnZXRFbCwgcGh4RXZlbnQsIGV2ZW50VGFyZ2V0KSA9PiB7XG4gICAgICBpZighZXZlbnRUYXJnZXQpe1xuICAgICAgICBsZXQgZGF0YSA9IHtrZXk6IGUua2V5LCAuLi50aGlzLmV2ZW50TWV0YSh0eXBlLCBlLCB0YXJnZXRFbCl9XG4gICAgICAgIEpTLmV4ZWModHlwZSwgcGh4RXZlbnQsIHZpZXcsIHRhcmdldEVsLCBbXCJwdXNoXCIsIHtkYXRhfV0pXG4gICAgICB9XG4gICAgfSlcbiAgICB0aGlzLmJpbmQoe2JsdXI6IFwiYmx1clwiLCBmb2N1czogXCJmb2N1c1wifSwgKGUsIHR5cGUsIHZpZXcsIHRhcmdldEVsLCB0YXJnZXRDdHgsIHBoeEV2ZW50LCBwaHhUYXJnZXQpID0+IHtcbiAgICAgIC8vIGJsdXIgYW5kIGZvY3VzIGFyZSB0cmlnZ2VyZWQgb24gZG9jdW1lbnQgYW5kIHdpbmRvdy4gRGlzY2FyZCBvbmUgdG8gYXZvaWQgZHVwc1xuICAgICAgaWYocGh4VGFyZ2V0ID09PSBcIndpbmRvd1wiKXtcbiAgICAgICAgbGV0IGRhdGEgPSB0aGlzLmV2ZW50TWV0YSh0eXBlLCBlLCB0YXJnZXRFbClcbiAgICAgICAgSlMuZXhlYyh0eXBlLCBwaHhFdmVudCwgdmlldywgdGFyZ2V0RWwsIFtcInB1c2hcIiwge2RhdGF9XSlcbiAgICAgIH1cbiAgICB9KVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiZHJhZ292ZXJcIiwgZSA9PiBlLnByZXZlbnREZWZhdWx0KCkpXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJkcm9wXCIsIGUgPT4ge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICBsZXQgZHJvcFRhcmdldElkID0gbWF5YmUoY2xvc2VzdFBoeEJpbmRpbmcoZS50YXJnZXQsIHRoaXMuYmluZGluZyhQSFhfRFJPUF9UQVJHRVQpKSwgdHJ1ZVRhcmdldCA9PiB7XG4gICAgICAgIHJldHVybiB0cnVlVGFyZ2V0LmdldEF0dHJpYnV0ZSh0aGlzLmJpbmRpbmcoUEhYX0RST1BfVEFSR0VUKSlcbiAgICAgIH0pXG4gICAgICBsZXQgZHJvcFRhcmdldCA9IGRyb3BUYXJnZXRJZCAmJiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChkcm9wVGFyZ2V0SWQpXG4gICAgICBsZXQgZmlsZXMgPSBBcnJheS5mcm9tKGUuZGF0YVRyYW5zZmVyLmZpbGVzIHx8IFtdKVxuICAgICAgaWYoIWRyb3BUYXJnZXQgfHwgZHJvcFRhcmdldC5kaXNhYmxlZCB8fCBmaWxlcy5sZW5ndGggPT09IDAgfHwgIShkcm9wVGFyZ2V0LmZpbGVzIGluc3RhbmNlb2YgRmlsZUxpc3QpKXsgcmV0dXJuIH1cblxuICAgICAgTGl2ZVVwbG9hZGVyLnRyYWNrRmlsZXMoZHJvcFRhcmdldCwgZmlsZXMpXG4gICAgICBkcm9wVGFyZ2V0LmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KFwiaW5wdXRcIiwge2J1YmJsZXM6IHRydWV9KSlcbiAgICB9KVxuICAgIHRoaXMub24oUEhYX1RSQUNLX1VQTE9BRFMsIGUgPT4ge1xuICAgICAgbGV0IHVwbG9hZFRhcmdldCA9IGUudGFyZ2V0XG4gICAgICBpZighRE9NLmlzVXBsb2FkSW5wdXQodXBsb2FkVGFyZ2V0KSl7IHJldHVybiB9XG4gICAgICBsZXQgZmlsZXMgPSBBcnJheS5mcm9tKGUuZGV0YWlsLmZpbGVzIHx8IFtdKS5maWx0ZXIoZiA9PiBmIGluc3RhbmNlb2YgRmlsZSB8fCBmIGluc3RhbmNlb2YgQmxvYilcbiAgICAgIExpdmVVcGxvYWRlci50cmFja0ZpbGVzKHVwbG9hZFRhcmdldCwgZmlsZXMpXG4gICAgICB1cGxvYWRUYXJnZXQuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoXCJpbnB1dFwiLCB7YnViYmxlczogdHJ1ZX0pKVxuICAgIH0pXG4gIH1cblxuICBldmVudE1ldGEoZXZlbnROYW1lLCBlLCB0YXJnZXRFbCl7XG4gICAgbGV0IGNhbGxiYWNrID0gdGhpcy5tZXRhZGF0YUNhbGxiYWNrc1tldmVudE5hbWVdXG4gICAgcmV0dXJuIGNhbGxiYWNrID8gY2FsbGJhY2soZSwgdGFyZ2V0RWwpIDoge31cbiAgfVxuXG4gIHNldFBlbmRpbmdMaW5rKGhyZWYpe1xuICAgIHRoaXMubGlua1JlZisrXG4gICAgdGhpcy5wZW5kaW5nTGluayA9IGhyZWZcbiAgICByZXR1cm4gdGhpcy5saW5rUmVmXG4gIH1cblxuICBjb21taXRQZW5kaW5nTGluayhsaW5rUmVmKXtcbiAgICBpZih0aGlzLmxpbmtSZWYgIT09IGxpbmtSZWYpe1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaHJlZiA9IHRoaXMucGVuZGluZ0xpbmtcbiAgICAgIHRoaXMucGVuZGluZ0xpbmsgPSBudWxsXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuXG4gIGdldEhyZWYoKXsgcmV0dXJuIHRoaXMuaHJlZiB9XG5cbiAgaGFzUGVuZGluZ0xpbmsoKXsgcmV0dXJuICEhdGhpcy5wZW5kaW5nTGluayB9XG5cbiAgYmluZChldmVudHMsIGNhbGxiYWNrKXtcbiAgICBmb3IobGV0IGV2ZW50IGluIGV2ZW50cyl7XG4gICAgICBsZXQgYnJvd3NlckV2ZW50TmFtZSA9IGV2ZW50c1tldmVudF1cblxuICAgICAgdGhpcy5vbihicm93c2VyRXZlbnROYW1lLCBlID0+IHtcbiAgICAgICAgbGV0IGJpbmRpbmcgPSB0aGlzLmJpbmRpbmcoZXZlbnQpXG4gICAgICAgIGxldCB3aW5kb3dCaW5kaW5nID0gdGhpcy5iaW5kaW5nKGB3aW5kb3ctJHtldmVudH1gKVxuICAgICAgICBsZXQgdGFyZ2V0UGh4RXZlbnQgPSBlLnRhcmdldC5nZXRBdHRyaWJ1dGUgJiYgZS50YXJnZXQuZ2V0QXR0cmlidXRlKGJpbmRpbmcpXG4gICAgICAgIGlmKHRhcmdldFBoeEV2ZW50KXtcbiAgICAgICAgICB0aGlzLmRlYm91bmNlKGUudGFyZ2V0LCBlLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLndpdGhpbk93bmVycyhlLnRhcmdldCwgdmlldyA9PiB7XG4gICAgICAgICAgICAgIGNhbGxiYWNrKGUsIGV2ZW50LCB2aWV3LCBlLnRhcmdldCwgdGFyZ2V0UGh4RXZlbnQsIG51bGwpXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgRE9NLmFsbChkb2N1bWVudCwgYFske3dpbmRvd0JpbmRpbmd9XWAsIGVsID0+IHtcbiAgICAgICAgICAgIGxldCBwaHhFdmVudCA9IGVsLmdldEF0dHJpYnV0ZSh3aW5kb3dCaW5kaW5nKVxuICAgICAgICAgICAgdGhpcy5kZWJvdW5jZShlbCwgZSwgKCkgPT4ge1xuICAgICAgICAgICAgICB0aGlzLndpdGhpbk93bmVycyhlbCwgdmlldyA9PiB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZSwgZXZlbnQsIHZpZXcsIGVsLCBwaHhFdmVudCwgXCJ3aW5kb3dcIilcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICBiaW5kQ2xpY2tzKCl7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgZSA9PiB0aGlzLmNsaWNrU3RhcnRlZEF0VGFyZ2V0ID0gZS50YXJnZXQpXG4gICAgdGhpcy5iaW5kQ2xpY2soXCJjbGlja1wiLCBcImNsaWNrXCIsIGZhbHNlKVxuICAgIHRoaXMuYmluZENsaWNrKFwibW91c2Vkb3duXCIsIFwiY2FwdHVyZS1jbGlja1wiLCB0cnVlKVxuICB9XG5cbiAgYmluZENsaWNrKGV2ZW50TmFtZSwgYmluZGluZ05hbWUsIGNhcHR1cmUpe1xuICAgIGxldCBjbGljayA9IHRoaXMuYmluZGluZyhiaW5kaW5nTmFtZSlcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGUgPT4ge1xuICAgICAgbGV0IHRhcmdldCA9IG51bGxcbiAgICAgIGlmKGNhcHR1cmUpe1xuICAgICAgICB0YXJnZXQgPSBlLnRhcmdldC5tYXRjaGVzKGBbJHtjbGlja31dYCkgPyBlLnRhcmdldCA6IGUudGFyZ2V0LnF1ZXJ5U2VsZWN0b3IoYFske2NsaWNrfV1gKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IGNsaWNrU3RhcnRlZEF0VGFyZ2V0ID0gdGhpcy5jbGlja1N0YXJ0ZWRBdFRhcmdldCB8fCBlLnRhcmdldFxuICAgICAgICB0YXJnZXQgPSBjbG9zZXN0UGh4QmluZGluZyhjbGlja1N0YXJ0ZWRBdFRhcmdldCwgY2xpY2spXG4gICAgICAgIHRoaXMuZGlzcGF0Y2hDbGlja0F3YXkoZSwgY2xpY2tTdGFydGVkQXRUYXJnZXQpXG4gICAgICAgIHRoaXMuY2xpY2tTdGFydGVkQXRUYXJnZXQgPSBudWxsXG4gICAgICB9XG4gICAgICBsZXQgcGh4RXZlbnQgPSB0YXJnZXQgJiYgdGFyZ2V0LmdldEF0dHJpYnV0ZShjbGljaylcbiAgICAgIGlmKCFwaHhFdmVudCl7IHJldHVybiB9XG4gICAgICBpZih0YXJnZXQuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKSA9PT0gXCIjXCIpeyBlLnByZXZlbnREZWZhdWx0KCkgfVxuXG4gICAgICB0aGlzLmRlYm91bmNlKHRhcmdldCwgZSwgKCkgPT4ge1xuICAgICAgICB0aGlzLndpdGhpbk93bmVycyh0YXJnZXQsIHZpZXcgPT4ge1xuICAgICAgICAgIEpTLmV4ZWMoXCJjbGlja1wiLCBwaHhFdmVudCwgdmlldywgdGFyZ2V0LCBbXCJwdXNoXCIsIHtkYXRhOiB0aGlzLmV2ZW50TWV0YShcImNsaWNrXCIsIGUsIHRhcmdldCl9XSlcbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgfSwgY2FwdHVyZSlcbiAgfVxuXG4gIGRpc3BhdGNoQ2xpY2tBd2F5KGUsIGNsaWNrU3RhcnRlZEF0KXtcbiAgICBsZXQgcGh4Q2xpY2tBd2F5ID0gdGhpcy5iaW5kaW5nKFwiY2xpY2stYXdheVwiKVxuICAgIERPTS5hbGwoZG9jdW1lbnQsIGBbJHtwaHhDbGlja0F3YXl9XWAsIGVsID0+IHtcbiAgICAgIGlmKCEoZWwuaXNTYW1lTm9kZShjbGlja1N0YXJ0ZWRBdCkgfHwgZWwuY29udGFpbnMoY2xpY2tTdGFydGVkQXQpKSl7XG4gICAgICAgIHRoaXMud2l0aGluT3duZXJzKGUudGFyZ2V0LCB2aWV3ID0+IHtcbiAgICAgICAgICBsZXQgcGh4RXZlbnQgPSBlbC5nZXRBdHRyaWJ1dGUocGh4Q2xpY2tBd2F5KVxuICAgICAgICAgIGlmKEpTLmlzVmlzaWJsZShlbCkpe1xuICAgICAgICAgICAgSlMuZXhlYyhcImNsaWNrXCIsIHBoeEV2ZW50LCB2aWV3LCBlbCwgW1wicHVzaFwiLCB7ZGF0YTogdGhpcy5ldmVudE1ldGEoXCJjbGlja1wiLCBlLCBlLnRhcmdldCl9XSlcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIGJpbmROYXYoKXtcbiAgICBpZighQnJvd3Nlci5jYW5QdXNoU3RhdGUoKSl7IHJldHVybiB9XG4gICAgaWYoaGlzdG9yeS5zY3JvbGxSZXN0b3JhdGlvbil7IGhpc3Rvcnkuc2Nyb2xsUmVzdG9yYXRpb24gPSBcIm1hbnVhbFwiIH1cbiAgICBsZXQgc2Nyb2xsVGltZXIgPSBudWxsXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgX2UgPT4ge1xuICAgICAgY2xlYXJUaW1lb3V0KHNjcm9sbFRpbWVyKVxuICAgICAgc2Nyb2xsVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgQnJvd3Nlci51cGRhdGVDdXJyZW50U3RhdGUoc3RhdGUgPT4gT2JqZWN0LmFzc2lnbihzdGF0ZSwge3Njcm9sbDogd2luZG93LnNjcm9sbFl9KSlcbiAgICAgIH0sIDEwMClcbiAgICB9KVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicG9wc3RhdGVcIiwgZXZlbnQgPT4ge1xuICAgICAgaWYoIXRoaXMucmVnaXN0ZXJOZXdMb2NhdGlvbih3aW5kb3cubG9jYXRpb24pKXsgcmV0dXJuIH1cbiAgICAgIGxldCB7dHlwZSwgaWQsIHJvb3QsIHNjcm9sbH0gPSBldmVudC5zdGF0ZSB8fCB7fVxuICAgICAgbGV0IGhyZWYgPSB3aW5kb3cubG9jYXRpb24uaHJlZlxuXG4gICAgICB0aGlzLnJlcXVlc3RET01VcGRhdGUoKCkgPT4ge1xuICAgICAgICBpZih0aGlzLm1haW4uaXNDb25uZWN0ZWQoKSAmJiAodHlwZSA9PT0gXCJwYXRjaFwiICYmIGlkID09PSB0aGlzLm1haW4uaWQpKXtcbiAgICAgICAgICB0aGlzLm1haW4ucHVzaExpbmtQYXRjaChocmVmLCBudWxsKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucmVwbGFjZU1haW4oaHJlZiwgbnVsbCwgKCkgPT4ge1xuICAgICAgICAgICAgaWYocm9vdCl7IHRoaXMucmVwbGFjZVJvb3RIaXN0b3J5KCkgfVxuICAgICAgICAgICAgaWYodHlwZW9mKHNjcm9sbCkgPT09IFwibnVtYmVyXCIpe1xuICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB3aW5kb3cuc2Nyb2xsVG8oMCwgc2Nyb2xsKVxuICAgICAgICAgICAgICB9LCAwKSAvLyB0aGUgYm9keSBuZWVkcyB0byByZW5kZXIgYmVmb3JlIHdlIHNjcm9sbC5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0sIGZhbHNlKVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZSA9PiB7XG4gICAgICBsZXQgdGFyZ2V0ID0gY2xvc2VzdFBoeEJpbmRpbmcoZS50YXJnZXQsIFBIWF9MSVZFX0xJTkspXG4gICAgICBsZXQgdHlwZSA9IHRhcmdldCAmJiB0YXJnZXQuZ2V0QXR0cmlidXRlKFBIWF9MSVZFX0xJTkspXG4gICAgICBsZXQgd2FudHNOZXdUYWIgPSBlLm1ldGFLZXkgfHwgZS5jdHJsS2V5IHx8IGUuYnV0dG9uID09PSAxXG4gICAgICBpZighdHlwZSB8fCAhdGhpcy5pc0Nvbm5lY3RlZCgpIHx8ICF0aGlzLm1haW4gfHwgd2FudHNOZXdUYWIpeyByZXR1cm4gfVxuXG4gICAgICBsZXQgaHJlZiA9IHRhcmdldC5ocmVmXG4gICAgICBsZXQgbGlua1N0YXRlID0gdGFyZ2V0LmdldEF0dHJpYnV0ZShQSFhfTElOS19TVEFURSlcbiAgICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKSAvLyBkbyBub3QgYnViYmxlIGNsaWNrIHRvIHJlZ3VsYXIgcGh4LWNsaWNrIGJpbmRpbmdzXG4gICAgICBpZih0aGlzLnBlbmRpbmdMaW5rID09PSBocmVmKXsgcmV0dXJuIH1cblxuICAgICAgdGhpcy5yZXF1ZXN0RE9NVXBkYXRlKCgpID0+IHtcbiAgICAgICAgaWYodHlwZSA9PT0gXCJwYXRjaFwiKXtcbiAgICAgICAgICB0aGlzLnB1c2hIaXN0b3J5UGF0Y2goaHJlZiwgbGlua1N0YXRlLCB0YXJnZXQpXG4gICAgICAgIH0gZWxzZSBpZih0eXBlID09PSBcInJlZGlyZWN0XCIpe1xuICAgICAgICAgIHRoaXMuaGlzdG9yeVJlZGlyZWN0KGhyZWYsIGxpbmtTdGF0ZSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGV4cGVjdGVkICR7UEhYX0xJVkVfTElOS30gdG8gYmUgXCJwYXRjaFwiIG9yIFwicmVkaXJlY3RcIiwgZ290OiAke3R5cGV9YClcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9LCBmYWxzZSlcbiAgfVxuXG4gIGRpc3BhdGNoRXZlbnQoZXZlbnQsIHBheWxvYWQgPSB7fSl7XG4gICAgRE9NLmRpc3BhdGNoRXZlbnQod2luZG93LCBgcGh4OiR7ZXZlbnR9YCwge2RldGFpbDogcGF5bG9hZH0pXG4gIH1cblxuICBkaXNwYXRjaEV2ZW50cyhldmVudHMpe1xuICAgIGV2ZW50cy5mb3JFYWNoKChbZXZlbnQsIHBheWxvYWRdKSA9PiB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQsIHBheWxvYWQpKVxuICB9XG5cbiAgd2l0aFBhZ2VMb2FkaW5nKGluZm8sIGNhbGxiYWNrKXtcbiAgICBET00uZGlzcGF0Y2hFdmVudCh3aW5kb3csIFwicGh4OnBhZ2UtbG9hZGluZy1zdGFydFwiLCB7ZGV0YWlsOiBpbmZvfSlcbiAgICBsZXQgZG9uZSA9ICgpID0+IERPTS5kaXNwYXRjaEV2ZW50KHdpbmRvdywgXCJwaHg6cGFnZS1sb2FkaW5nLXN0b3BcIiwge2RldGFpbDogaW5mb30pXG4gICAgcmV0dXJuIGNhbGxiYWNrID8gY2FsbGJhY2soZG9uZSkgOiBkb25lXG4gIH1cblxuICBwdXNoSGlzdG9yeVBhdGNoKGhyZWYsIGxpbmtTdGF0ZSwgdGFyZ2V0RWwpe1xuICAgIHRoaXMud2l0aFBhZ2VMb2FkaW5nKHt0bzogaHJlZiwga2luZDogXCJwYXRjaFwifSwgZG9uZSA9PiB7XG4gICAgICB0aGlzLm1haW4ucHVzaExpbmtQYXRjaChocmVmLCB0YXJnZXRFbCwgbGlua1JlZiA9PiB7XG4gICAgICAgIHRoaXMuaGlzdG9yeVBhdGNoKGhyZWYsIGxpbmtTdGF0ZSwgbGlua1JlZilcbiAgICAgICAgZG9uZSgpXG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICBoaXN0b3J5UGF0Y2goaHJlZiwgbGlua1N0YXRlLCBsaW5rUmVmID0gdGhpcy5zZXRQZW5kaW5nTGluayhocmVmKSl7XG4gICAgaWYoIXRoaXMuY29tbWl0UGVuZGluZ0xpbmsobGlua1JlZikpeyByZXR1cm4gfVxuXG4gICAgQnJvd3Nlci5wdXNoU3RhdGUobGlua1N0YXRlLCB7dHlwZTogXCJwYXRjaFwiLCBpZDogdGhpcy5tYWluLmlkfSwgaHJlZilcbiAgICB0aGlzLnJlZ2lzdGVyTmV3TG9jYXRpb24od2luZG93LmxvY2F0aW9uKVxuICB9XG5cbiAgaGlzdG9yeVJlZGlyZWN0KGhyZWYsIGxpbmtTdGF0ZSwgZmxhc2gpe1xuICAgIGxldCBzY3JvbGwgPSB3aW5kb3cuc2Nyb2xsWVxuICAgIHRoaXMud2l0aFBhZ2VMb2FkaW5nKHt0bzogaHJlZiwga2luZDogXCJyZWRpcmVjdFwifSwgZG9uZSA9PiB7XG4gICAgICB0aGlzLnJlcGxhY2VNYWluKGhyZWYsIGZsYXNoLCAoKSA9PiB7XG4gICAgICAgIEJyb3dzZXIucHVzaFN0YXRlKGxpbmtTdGF0ZSwge3R5cGU6IFwicmVkaXJlY3RcIiwgaWQ6IHRoaXMubWFpbi5pZCwgc2Nyb2xsOiBzY3JvbGx9LCBocmVmKVxuICAgICAgICB0aGlzLnJlZ2lzdGVyTmV3TG9jYXRpb24od2luZG93LmxvY2F0aW9uKVxuICAgICAgICBkb25lKClcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIHJlcGxhY2VSb290SGlzdG9yeSgpe1xuICAgIEJyb3dzZXIucHVzaFN0YXRlKFwicmVwbGFjZVwiLCB7cm9vdDogdHJ1ZSwgdHlwZTogXCJwYXRjaFwiLCBpZDogdGhpcy5tYWluLmlkfSlcbiAgfVxuXG4gIHJlZ2lzdGVyTmV3TG9jYXRpb24obmV3TG9jYXRpb24pe1xuICAgIGxldCB7cGF0aG5hbWUsIHNlYXJjaH0gPSB0aGlzLmN1cnJlbnRMb2NhdGlvblxuICAgIGlmKHBhdGhuYW1lICsgc2VhcmNoID09PSBuZXdMb2NhdGlvbi5wYXRobmFtZSArIG5ld0xvY2F0aW9uLnNlYXJjaCl7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jdXJyZW50TG9jYXRpb24gPSBjbG9uZShuZXdMb2NhdGlvbilcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG5cbiAgYmluZEZvcm1zKCl7XG4gICAgbGV0IGl0ZXJhdGlvbnMgPSAwXG4gICAgdGhpcy5vbihcInN1Ym1pdFwiLCBlID0+IHtcbiAgICAgIGxldCBwaHhFdmVudCA9IGUudGFyZ2V0LmdldEF0dHJpYnV0ZSh0aGlzLmJpbmRpbmcoXCJzdWJtaXRcIikpXG4gICAgICBpZighcGh4RXZlbnQpeyByZXR1cm4gfVxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICBlLnRhcmdldC5kaXNhYmxlZCA9IHRydWVcbiAgICAgIHRoaXMud2l0aGluT3duZXJzKGUudGFyZ2V0LCB2aWV3ID0+IHtcbiAgICAgICAgSlMuZXhlYyhcInN1Ym1pdFwiLCBwaHhFdmVudCwgdmlldywgZS50YXJnZXQsIFtcInB1c2hcIiwge31dKVxuICAgICAgfSlcbiAgICB9LCBmYWxzZSlcblxuICAgIGZvcihsZXQgdHlwZSBvZiBbXCJjaGFuZ2VcIiwgXCJpbnB1dFwiXSl7XG4gICAgICB0aGlzLm9uKHR5cGUsIGUgPT4ge1xuICAgICAgICBsZXQgcGh4Q2hhbmdlID0gdGhpcy5iaW5kaW5nKFwiY2hhbmdlXCIpXG4gICAgICAgIGxldCBpbnB1dCA9IGUudGFyZ2V0XG4gICAgICAgIGxldCBpbnB1dEV2ZW50ID0gaW5wdXQuZ2V0QXR0cmlidXRlKHBoeENoYW5nZSlcbiAgICAgICAgbGV0IGZvcm1FdmVudCA9IGlucHV0LmZvcm0gJiYgaW5wdXQuZm9ybS5nZXRBdHRyaWJ1dGUocGh4Q2hhbmdlKVxuICAgICAgICBsZXQgcGh4RXZlbnQgPSBpbnB1dEV2ZW50IHx8IGZvcm1FdmVudFxuICAgICAgICBpZighcGh4RXZlbnQpeyByZXR1cm4gfVxuICAgICAgICBpZihpbnB1dC50eXBlID09PSBcIm51bWJlclwiICYmIGlucHV0LnZhbGlkaXR5ICYmIGlucHV0LnZhbGlkaXR5LmJhZElucHV0KXsgcmV0dXJuIH1cblxuICAgICAgICBsZXQgZGlzcGF0Y2hlciA9IGlucHV0RXZlbnQgPyBpbnB1dCA6IGlucHV0LmZvcm1cbiAgICAgICAgbGV0IGN1cnJlbnRJdGVyYXRpb25zID0gaXRlcmF0aW9uc1xuICAgICAgICBpdGVyYXRpb25zKytcbiAgICAgICAgbGV0IHthdDogYXQsIHR5cGU6IGxhc3RUeXBlfSA9IERPTS5wcml2YXRlKGlucHV0LCBcInByZXYtaXRlcmF0aW9uXCIpIHx8IHt9XG4gICAgICAgIC8vIGRldGVjdCBkdXAgYmVjYXVzZSBzb21lIGJyb3dzZXJzIGRpc3BhdGNoIGJvdGggXCJpbnB1dFwiIGFuZCBcImNoYW5nZVwiXG4gICAgICAgIGlmKGF0ID09PSBjdXJyZW50SXRlcmF0aW9ucyAtIDEgJiYgdHlwZSAhPT0gbGFzdFR5cGUpeyByZXR1cm4gfVxuXG4gICAgICAgIERPTS5wdXRQcml2YXRlKGlucHV0LCBcInByZXYtaXRlcmF0aW9uXCIsIHthdDogY3VycmVudEl0ZXJhdGlvbnMsIHR5cGU6IHR5cGV9KVxuXG4gICAgICAgIHRoaXMuZGVib3VuY2UoaW5wdXQsIGUsICgpID0+IHtcbiAgICAgICAgICB0aGlzLndpdGhpbk93bmVycyhkaXNwYXRjaGVyLCB2aWV3ID0+IHtcbiAgICAgICAgICAgIERPTS5wdXRQcml2YXRlKGlucHV0LCBQSFhfSEFTX0ZPQ1VTRUQsIHRydWUpXG4gICAgICAgICAgICBpZighRE9NLmlzVGV4dHVhbElucHV0KGlucHV0KSl7XG4gICAgICAgICAgICAgIHRoaXMuc2V0QWN0aXZlRWxlbWVudChpbnB1dClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIEpTLmV4ZWMoXCJjaGFuZ2VcIiwgcGh4RXZlbnQsIHZpZXcsIGlucHV0LCBbXCJwdXNoXCIsIHtfdGFyZ2V0OiBlLnRhcmdldC5uYW1lLCBkaXNwYXRjaGVyOiBkaXNwYXRjaGVyfV0pXG4gICAgICAgICAgfSlcbiAgICAgICAgfSlcbiAgICAgIH0sIGZhbHNlKVxuICAgIH1cbiAgfVxuXG4gIGRlYm91bmNlKGVsLCBldmVudCwgY2FsbGJhY2spe1xuICAgIGxldCBwaHhEZWJvdW5jZSA9IHRoaXMuYmluZGluZyhQSFhfREVCT1VOQ0UpXG4gICAgbGV0IHBoeFRocm90dGxlID0gdGhpcy5iaW5kaW5nKFBIWF9USFJPVFRMRSlcbiAgICBsZXQgZGVmYXVsdERlYm91bmNlID0gdGhpcy5kZWZhdWx0cy5kZWJvdW5jZS50b1N0cmluZygpXG4gICAgbGV0IGRlZmF1bHRUaHJvdHRsZSA9IHRoaXMuZGVmYXVsdHMudGhyb3R0bGUudG9TdHJpbmcoKVxuICAgIERPTS5kZWJvdW5jZShlbCwgZXZlbnQsIHBoeERlYm91bmNlLCBkZWZhdWx0RGVib3VuY2UsIHBoeFRocm90dGxlLCBkZWZhdWx0VGhyb3R0bGUsIGNhbGxiYWNrKVxuICB9XG5cbiAgc2lsZW5jZUV2ZW50cyhjYWxsYmFjayl7XG4gICAgdGhpcy5zaWxlbmNlZCA9IHRydWVcbiAgICBjYWxsYmFjaygpXG4gICAgdGhpcy5zaWxlbmNlZCA9IGZhbHNlXG4gIH1cblxuICBvbihldmVudCwgY2FsbGJhY2spe1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBlID0+IHtcbiAgICAgIGlmKCF0aGlzLnNpbGVuY2VkKXsgY2FsbGJhY2soZSkgfVxuICAgIH0pXG4gIH1cbn1cblxuY2xhc3MgVHJhbnNpdGlvblNldCB7XG4gIGNvbnN0cnVjdG9yKCl7XG4gICAgdGhpcy50cmFuc2l0aW9ucyA9IG5ldyBTZXQoKVxuICAgIHRoaXMucGVuZGluZ09wcyA9IFtdXG4gICAgdGhpcy5yZXNldCgpXG4gIH1cblxuICByZXNldCgpe1xuICAgIHRoaXMudHJhbnNpdGlvbnMuZm9yRWFjaCh0aW1lciA9PiB7XG4gICAgICBjYW5jZWxUaW1lb3V0KHRpbWVyKVxuICAgICAgdGhpcy50cmFuc2l0aW9ucy5kZWxldGUodGltZXIpXG4gICAgfSlcbiAgICB0aGlzLmZsdXNoUGVuZGluZ09wcygpXG4gIH1cblxuICBhZnRlcihjYWxsYmFjayl7XG4gICAgaWYodGhpcy5zaXplKCkgPT09IDApe1xuICAgICAgY2FsbGJhY2soKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnB1c2hQZW5kaW5nT3AoY2FsbGJhY2spXG4gICAgfVxuICB9XG5cbiAgYWRkVHJhbnNpdGlvbih0aW1lLCBvblN0YXJ0LCBvbkRvbmUpe1xuICAgIG9uU3RhcnQoKVxuICAgIGxldCB0aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy50cmFuc2l0aW9ucy5kZWxldGUodGltZXIpXG4gICAgICBvbkRvbmUoKVxuICAgICAgaWYodGhpcy5zaXplKCkgPT09IDApeyB0aGlzLmZsdXNoUGVuZGluZ09wcygpIH1cbiAgICB9LCB0aW1lKVxuICAgIHRoaXMudHJhbnNpdGlvbnMuYWRkKHRpbWVyKVxuICB9XG5cbiAgcHVzaFBlbmRpbmdPcChvcCl7IHRoaXMucGVuZGluZ09wcy5wdXNoKG9wKSB9XG5cbiAgc2l6ZSgpeyByZXR1cm4gdGhpcy50cmFuc2l0aW9ucy5zaXplIH1cblxuICBmbHVzaFBlbmRpbmdPcHMoKXtcbiAgICB0aGlzLnBlbmRpbmdPcHMuZm9yRWFjaChvcCA9PiBvcCgpKVxuICAgIHRoaXMucGVuZGluZ09wcyA9IFtdXG4gIH1cbn1cbiIsICIvLyBXZSBpbXBvcnQgdGhlIENTUyB3aGljaCBpcyBleHRyYWN0ZWQgdG8gaXRzIG93biBmaWxlIGJ5IGVzYnVpbGQuXG4vLyBSZW1vdmUgdGhpcyBsaW5lIGlmIHlvdSBhZGQgYSB5b3VyIG93biBDU1MgYnVpbGQgcGlwZWxpbmUgKGUuZyBwb3N0Y3NzKS5cblxuLy8gSWYgeW91IHdhbnQgdG8gdXNlIFBob2VuaXggY2hhbm5lbHMsIHJ1biBgbWl4IGhlbHAgcGh4Lmdlbi5jaGFubmVsYFxuLy8gdG8gZ2V0IHN0YXJ0ZWQgYW5kIHRoZW4gdW5jb21tZW50IHRoZSBsaW5lIGJlbG93LlxuLy8gaW1wb3J0IFwiLi91c2VyX3NvY2tldC5qc1wiXG5cbi8vIFlvdSBjYW4gaW5jbHVkZSBkZXBlbmRlbmNpZXMgaW4gdHdvIHdheXMuXG4vL1xuLy8gVGhlIHNpbXBsZXN0IG9wdGlvbiBpcyB0byBwdXQgdGhlbSBpbiBhc3NldHMvdmVuZG9yIGFuZFxuLy8gaW1wb3J0IHRoZW0gdXNpbmcgcmVsYXRpdmUgcGF0aHM6XG4vL1xuLy8gICAgIGltcG9ydCBcIi4uL3ZlbmRvci9zb21lLXBhY2thZ2UuanNcIlxuLy9cbi8vIEFsdGVybmF0aXZlbHksIHlvdSBjYW4gYG5wbSBpbnN0YWxsIHNvbWUtcGFja2FnZSAtLXByZWZpeCBhc3NldHNgIGFuZCBpbXBvcnRcbi8vIHRoZW0gdXNpbmcgYSBwYXRoIHN0YXJ0aW5nIHdpdGggdGhlIHBhY2thZ2UgbmFtZTpcbi8vXG4vLyAgICAgaW1wb3J0IFwic29tZS1wYWNrYWdlXCJcbi8vXG5cbi8vIEluY2x1ZGUgcGhvZW5peF9odG1sIHRvIGhhbmRsZSBtZXRob2Q9UFVUL0RFTEVURSBpbiBmb3JtcyBhbmQgYnV0dG9ucy5cbmltcG9ydCBcInBob2VuaXhfaHRtbFwiXG4vLyBFc3RhYmxpc2ggUGhvZW5peCBTb2NrZXQgYW5kIExpdmVWaWV3IGNvbmZpZ3VyYXRpb24uXG5pbXBvcnQgeyBTb2NrZXQgfSBmcm9tIFwicGhvZW5peFwiXG5pbXBvcnQgeyBMaXZlU29ja2V0IH0gZnJvbSBcInBob2VuaXhfbGl2ZV92aWV3XCJcbmltcG9ydCB0b3BiYXIgZnJvbSBcIi4uL3ZlbmRvci90b3BiYXJcIlxuaW1wb3J0IGluaXRfdGVtcGxldCBmcm9tIFwiLi90ZW1wbGF0ZVwiXG5cblxuaW1wb3J0IEFscGluZSBmcm9tIFwiYWxwaW5lanNcIlxuaW1wb3J0IHBlcnNpc3QgZnJvbSAnQGFscGluZWpzL3BlcnNpc3QnXG5pbXBvcnQgVGltZUFnbyBmcm9tIFwiLi90aW1lYWdvLmpzXCJcbmltcG9ydCB7IGVzIH0gZnJvbSAnZGF0ZS1mbnMvbG9jYWxlJztcblxuXG53aW5kb3cuQWxwaW5lID0gQWxwaW5lXG5BbHBpbmUucGx1Z2luKHBlcnNpc3QpO1xuQWxwaW5lLnBsdWdpbihUaW1lQWdvLmNvbmZpZ3VyZSh7XG4gICAgbG9jYWxlOiBlcyxcbn0pKTtcbkFscGluZS5zdGFydCgpO1xuY29uc29sZS5sb2coXCJBbHBpbmVcIik7XG5cblxuXG5jb25zb2xlLmxvZyhcIk91dCBIb29rc1wiLCB3aW5kb3cub3V0SG9va3MpO1xuXG5sZXQgSG9va3MgPSAod2luZG93Lm91dEhvb2tzKSA/IHdpbmRvdy5vdXRIb29rcyA6IHt9O1xuXG5Ib29rcy5QaG9uZU51bWJlciA9IHtcbiAgICBtb3VudGVkKCkge1xuICAgICAgICB0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCBlID0+IHtcbiAgICAgICAgICAgIHRoaXMuZWwudmFsdWUgPSB0aGlzLmVsLnZhbHVlLnJlcGxhY2UoL1teXFxkXSsvZywgJycpO1xuICAgICAgICAgICAgbGV0IG1hdGNoID0gdGhpcy5lbC52YWx1ZS5yZXBsYWNlKC9cXEQvZywgXCJcIikubWF0Y2goL14oXFxkezN9KShcXGR7M30pKFxcZHs0fSkkLylcbiAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZWwudmFsdWUgPSBgJHttYXRjaFsxXX0tJHttYXRjaFsyXX0tJHttYXRjaFszXX1gXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgfVxufVxuSG9va3MuU2Nyb2xsQm90dG9tID0ge1xuICAgIG1vdW50ZWQoKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKHRoaXMuZWwuaWQpO1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5lbC5pZCk7XG4gICAgICAgIGVsZW1lbnQuc2Nyb2xsVG9wID0gZWxlbWVudC5zY3JvbGxIZWlnaHQ7XG4gICAgfSxcbiAgICB1cGRhdGVkKCkge1xuICAgICAgICBjb25zb2xlLmxvZyh0aGlzLmVsLmlkKTtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMuZWwuaWQpO1xuICAgICAgICBlbGVtZW50LnNjcm9sbFRvcCA9IGVsZW1lbnQuc2Nyb2xsSGVpZ2h0O1xuICAgIH1cbn1cblxuLypcblxuPGRpdiBpZD1cImluZmluaXRlLXNjcm9sbFwiIHBoeC1ob29rPVwiSW5maW5pdGVTY3JvbGxcIiBkYXRhLXBhZ2U9e0BwYWdlfT5cblxuKi9cbkhvb2tzLkluZmluaXRlU2Nyb2xsID0ge1xuICAgIHBhZ2UoKSB7IHJldHVybiB0aGlzLmVsLmRhdGFzZXQucGFnZSB9LFxuICAgIG1vdW50ZWQoKSB7XG4gICAgICAgIHRoaXMucGVuZGluZyA9IHRoaXMucGFnZSgpXG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIGUgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMucGVuZGluZyA9PSB0aGlzLnBhZ2UoKSAmJiBzY3JvbGxBdCgpID4gOTApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmcgPSB0aGlzLnBhZ2UoKSArIDFcbiAgICAgICAgICAgICAgICB0aGlzLnB1c2hFdmVudChcImxvYWQtbW9yZVwiLCB7fSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICB9LFxuICAgIHVwZGF0ZWQoKSB7IHRoaXMucGVuZGluZyA9IHRoaXMucGFnZSgpIH1cbn1cblxuXG5pbXBvcnQgeyBIdG1sNVFyY29kZVNjYW5uZXIgfSBmcm9tICdodG1sNS1xcmNvZGUnO1xuXG5cbkhvb2tzLlNjYW5RciA9IHtcbiAgICBtb3VudGVkKCkge1xuICAgICAgICAvL2NvbnNvbGUubG9nKHRoaXMuZWwuaWQpO1xuICAgICAgICAvL2NvbnNvbGUubG9nKHRoaXMuZWwuZGF0YXNldCk7XG4gICAgICAgIC8vdGhpcy5wdXNoRXZlbnQoXCJyZWFkcXJcIiwgeyBoaTogXCJoaSAhXCIgfSwgKHJlcGx5LCByZWYpID0+IGNvbnNvbGUubG9nKHJlcGx5KSk7XG4gICAgICAgIGNvbnN0IF90aGlzID0gdGhpcztcblxuICAgICAgICBmdW5jdGlvbiBvblNjYW5TdWNjZXNzKGRlY29kZWRUZXh0LCBkZWNvZGVkUmVzdWx0KSB7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKGBDb2RlIHNjYW5uZWQgPSAke2RlY29kZWRUZXh0fWAsIGRlY29kZWRSZXN1bHQpO1xuICAgICAgICAgICAgX3RoaXMucHVzaEV2ZW50KFwicmVhZHFyXCIsIHsgZGVjb2RlZFRleHQ6IGRlY29kZWRUZXh0LCBkZWNvZGVkUmVzdWx0OiBkZWNvZGVkUmVzdWx0IH0sIChyZXBseSwgcmVmKSA9PiBjb25zb2xlLmxvZyhyZXBseSkpO1xuICAgICAgICB9XG4gICAgICAgIC8vY29uc29sZS5sb2coeyBmcHM6IHBhcnNlSW50KHRoaXMuZWwuZGF0YXNldC5mcHMgfHwgMTApLCBxcmJveDogcGFyc2VJbnQodGhpcy5lbC5kYXRhc2V0LndpZHRoIHx8IDQwMCksIHNob3dUb3JjaEJ1dHRvbklmU3VwcG9ydGVkOiB0cnVlLCBzaG93Wm9vbVNsaWRlcklmU3VwcG9ydGVkOiB0cnVlLCBkZWZhdWx0Wm9vbVZhbHVlSWZTdXBwb3J0ZWQ6IHRydWUgfSk7XG4gICAgICAgIHZhciBodG1sNVFyY29kZVNjYW5uZXIgPSBuZXcgSHRtbDVRcmNvZGVTY2FubmVyKFxuICAgICAgICAgICAgdGhpcy5lbC5pZCwgeyBmcHM6IDIwLCBxcmJveDogcGFyc2VJbnQodGhpcy5lbC5kYXRhc2V0LndpZHRoIHx8IDQwMCksIHNob3dUb3JjaEJ1dHRvbklmU3VwcG9ydGVkOiB0cnVlLCBzaG93Wm9vbVNsaWRlcklmU3VwcG9ydGVkOiB0cnVlLCBkZWZhdWx0Wm9vbVZhbHVlSWZTdXBwb3J0ZWQ6IHRydWUgfSk7XG4gICAgICAgIGh0bWw1UXJjb2RlU2Nhbm5lci5yZW5kZXIob25TY2FuU3VjY2Vzcyk7XG4gICAgfSxcbiAgICB1cGRhdGVkKCkge1xuICAgICAgICBjb25zb2xlLmxvZyh0aGlzLmVsLmlkKTtcbiAgICB9XG59XG5cblxubGV0IGNzcmZUb2tlbiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCJtZXRhW25hbWU9J2NzcmYtdG9rZW4nXVwiKS5nZXRBdHRyaWJ1dGUoXCJjb250ZW50XCIpXG5sZXQgbGl2ZVNvY2tldCA9IG5ldyBMaXZlU29ja2V0KFwiL2xpdmVcIiwgU29ja2V0LCB7XG4gICAgcGFyYW1zOiB7IF9jc3JmX3Rva2VuOiBjc3JmVG9rZW4gfSxcbiAgICBob29rczogSG9va3MsXG4gICAgZG9tOiB7XG4gICAgICAgIG9uQmVmb3JlRWxVcGRhdGVkKGZyb20sIHRvKSB7XG4gICAgICAgICAgICBpZiAoZnJvbS5feF9kYXRhU3RhY2spIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cuQWxwaW5lLmNsb25lKGZyb20sIHRvKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufSlcblxuLy8gU2hvdyBwcm9ncmVzcyBiYXIgb24gbGl2ZSBuYXZpZ2F0aW9uIGFuZCBmb3JtIHN1Ym1pdHNcbnRvcGJhci5jb25maWcoeyBiYXJDb2xvcnM6IHsgMDogXCIjMjlkXCIgfSwgc2hhZG93Q29sb3I6IFwicmdiYSgwLCAwLCAwLCAuMylcIiB9KVxuXG53aW5kb3cucGFnZVN0YXRlID0ge1xuICAgIHN0YXJ0OiBmYWxzZSxcbiAgICBzdGFydF9vbmU6IGZhbHNlLFxuICAgIHN0b3A6IGZhbHNlLFxuICAgIHN0b3Bfb25lOiBmYWxzZVxufTtcblxuXG5cbmZ1bmN0aW9uIGNoYW5nZV9wc19jbGFzcyhuYW1lLCB2YWx1ZSkge1xuICAgIGxldCBlID0gd2luZG93LmRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUobmFtZSk7XG4gICAgLy9jb25zb2xlLmxvZyhcImNoYW5nZV9wc19jbGFzc1wiLCBuYW1lLCB2YWx1ZSwgZSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGVsID0gZVtpXTtcbiAgICAgICAgLy9jb25zb2xlLmxvZyhcImNoYW5nZV9wc19jbGFzc1wiLCBuYW1lLCB2YWx1ZSwgZWwpO1xuICAgICAgICAvL3NsZWVwKDgwKVxuICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICB3aW5kb3cuZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZWwuaWQpLmNsYXNzTGlzdC5yZW1vdmUoXCJvcGFjaXR5LTBcIiwgXCJoLTBcIiwgXCJ3LTBcIiwgXCJoaWRkZW5cIik7XG4gICAgICAgICAgICB3aW5kb3cuZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZWwuaWQpLmNsYXNzTGlzdC5hZGQoXCJvcGFjaXR5LTEwMFwiLCBcImgtc2NyZWVuXCIsIFwidy1zY3JlZW5cIiwgXCJpbmxpbmVcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3aW5kb3cuZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZWwuaWQpLmNsYXNzTGlzdC5yZW1vdmUoXCJvcGFjaXR5LTEwMFwiLCBcImgtc2NyZWVuXCIsIFwidy1zY3JlZW5cIiwgXCJpbmxpbmVcIik7XG4gICAgICAgICAgICB3aW5kb3cuZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZWwuaWQpLmNsYXNzTGlzdC5hZGQoXCJvcGFjaXR5LTBcIiwgXCJoLTBcIiwgXCJ3LTBcIiwgXCJoaWRkZW5cIik7XG4gICAgICAgIH1cblxuICAgIH1cbn1cblxuZnVuY3Rpb24gY2hhbmdlX3BzKHN0YXRlLCB2YWx1ZSkge1xuICAgIGlmIChbXCJzdGFydF9vbmVcIiwgXCJzdG9wX29uZVwiXS5pbmNsdWRlcyhzdGF0ZSkpIHtcbiAgICAgICAgaWYgKHdpbmRvdy5wYWdlU3RhdGVbc3RhdGVdID09IGZhbHNlKSB7XG4gICAgICAgICAgICB3aW5kb3cucGFnZVN0YXRlW3N0YXRlXSA9IHZhbHVlO1xuICAgICAgICAgICAgY2hhbmdlX3BzX2NsYXNzKFwiY2hhbmdlX3BzX2NsYXNzX1wiICsgc3RhdGUsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHdpbmRvdy5wYWdlU3RhdGVbc3RhdGVdID0gdmFsdWU7XG4gICAgICAgIGNoYW5nZV9wc19jbGFzcyhcImNoYW5nZV9wc19jbGFzc19cIiArIHN0YXRlLCB2YWx1ZSk7XG4gICAgfVxuXG59XG53aW5kb3cudG9wYmFyRm4gPSB7XG4gICAgc3RhcnQ6IChpbmZvKSA9PiB7XG4gICAgICAgIGNoYW5nZV9wcyhcInN0YXJ0XCIsIHRydWUpO1xuICAgICAgICBjaGFuZ2VfcHMoXCJzdGFydF9vbmVcIiwgdHJ1ZSk7XG4gICAgICAgIGNoYW5nZV9wcyhcInN0b3BcIiwgZmFsc2UpO1xuICAgICAgICBjaGFuZ2VfcHMoXCJzdG9wX29uZVwiLCBmYWxzZSk7XG4gICAgICAgIHRvcGJhci5zaG93KCk7XG4gICAgfSxcbiAgICBzdG9wOiAoaW5mbykgPT4ge1xuICAgICAgICBjaGFuZ2VfcHMoXCJzdGFydFwiLCBmYWxzZSk7XG4gICAgICAgIGNoYW5nZV9wcyhcInN0YXJ0X29uZVwiLCBmYWxzZSk7XG4gICAgICAgIGNoYW5nZV9wcyhcInN0b3BcIiwgdHJ1ZSk7XG4gICAgICAgIGNoYW5nZV9wcyhcInN0b3Bfb25lXCIsIHRydWUpO1xuICAgICAgICB0b3BiYXIuaGlkZSgpO1xuICAgIH1cbn1cbndpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicGh4OnBhZ2UtbG9hZGluZy1zdGFydFwiLCBpbmZvID0+IHdpbmRvdy50b3BiYXJGbi5zdGFydChpbmZvKSlcbndpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicGh4OnBhZ2UtbG9hZGluZy1zdG9wXCIsIGluZm8gPT4gd2luZG93LnRvcGJhckZuLnN0b3AoaW5mbykpXG5cbi8vIGNvbm5lY3QgaWYgdGhlcmUgYXJlIGFueSBMaXZlVmlld3Mgb24gdGhlIHBhZ2VcbmxpdmVTb2NrZXQuY29ubmVjdCgpXG5cbi8vIGV4cG9zZSBsaXZlU29ja2V0IG9uIHdpbmRvdyBmb3Igd2ViIGNvbnNvbGUgZGVidWcgbG9ncyBhbmQgbGF0ZW5jeSBzaW11bGF0aW9uOlxuLy8gPj4gbGl2ZVNvY2tldC5lbmFibGVEZWJ1ZygpXG4vLyA+PiBsaXZlU29ja2V0LmVuYWJsZUxhdGVuY3lTaW0oMTAwMCkgIC8vIGVuYWJsZWQgZm9yIGR1cmF0aW9uIG9mIGJyb3dzZXIgc2Vzc2lvblxuLy8gPj4gbGl2ZVNvY2tldC5kaXNhYmxlTGF0ZW5jeVNpbSgpXG53aW5kb3cubGl2ZVNvY2tldCA9IGxpdmVTb2NrZXRcbndpbmRvdy50b3BiYXIgPSB0b3BiYXI7XG53aW5kb3cuY2hhbmdlX3BzID0gY2hhbmdlX3BzO1xuaW5pdF90ZW1wbGV0KCk7XG5cbmNvbnNvbGUubG9nKFwiaGkhIDpEXCIpOyIsICJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpbml0X3RlbXBsZXQoKSB7XG5cbiAgICBpZiAobG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2NvbG9yLXRoZW1lJykgPT09ICdkYXJrJyB8fCAoISgnY29sb3ItdGhlbWUnIGluIGxvY2FsU3RvcmFnZSkgJiYgd2luZG93Lm1hdGNoTWVkaWEoJyhwcmVmZXJzLWNvbG9yLXNjaGVtZTogZGFyayknKS5tYXRjaGVzKSkge1xuICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnZGFyaycpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKCdkYXJrJylcbiAgICB9XG5cbiAgICB2YXIgdGhlbWVUb2dnbGVEYXJrSWNvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd0aGVtZS10b2dnbGUtZGFyay1pY29uJyk7XG4gICAgdmFyIHRoZW1lVG9nZ2xlTGlnaHRJY29uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3RoZW1lLXRvZ2dsZS1saWdodC1pY29uJyk7XG5cbiAgICBpZiAodGhlbWVUb2dnbGVEYXJrSWNvbiAhPSB1bmRlZmluZWQgJiYgdGhlbWVUb2dnbGVMaWdodEljb24gIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIENoYW5nZSB0aGUgaWNvbnMgaW5zaWRlIHRoZSBidXR0b24gYmFzZWQgb24gcHJldmlvdXMgc2V0dGluZ3NcbiAgICAgICAgaWYgKGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdjb2xvci10aGVtZScpID09PSAnZGFyaycgfHwgKCEoJ2NvbG9yLXRoZW1lJyBpbiBsb2NhbFN0b3JhZ2UpICYmIHdpbmRvdy5tYXRjaE1lZGlhKCcocHJlZmVycy1jb2xvci1zY2hlbWU6IGRhcmspJykubWF0Y2hlcykpIHtcbiAgICAgICAgICAgIHRoZW1lVG9nZ2xlTGlnaHRJY29uLmNsYXNzTGlzdC5yZW1vdmUoJ2hpZGRlbicpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhlbWVUb2dnbGVEYXJrSWNvbi5jbGFzc0xpc3QucmVtb3ZlKCdoaWRkZW4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0aGVtZVRvZ2dsZUJ0biA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd0aGVtZS10b2dnbGUnKTtcblxuICAgICAgICB0aGVtZVRvZ2dsZUJ0bi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICAvLyB0b2dnbGUgaWNvbnMgaW5zaWRlIGJ1dHRvblxuICAgICAgICAgICAgdGhlbWVUb2dnbGVEYXJrSWNvbi5jbGFzc0xpc3QudG9nZ2xlKCdoaWRkZW4nKTtcbiAgICAgICAgICAgIHRoZW1lVG9nZ2xlTGlnaHRJY29uLmNsYXNzTGlzdC50b2dnbGUoJ2hpZGRlbicpO1xuXG4gICAgICAgICAgICAvLyBpZiBzZXQgdmlhIGxvY2FsIHN0b3JhZ2UgcHJldmlvdXNseVxuICAgICAgICAgICAgaWYgKGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdjb2xvci10aGVtZScpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdjb2xvci10aGVtZScpID09PSAnbGlnaHQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGFzc0xpc3QuYWRkKCdkYXJrJyk7XG4gICAgICAgICAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdjb2xvci10aGVtZScsICdkYXJrJyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoJ2RhcmsnKTtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ2NvbG9yLXRoZW1lJywgJ2xpZ2h0Jyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gaWYgTk9UIHNldCB2aWEgbG9jYWwgc3RvcmFnZSBwcmV2aW91c2x5XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKCdkYXJrJykpIHtcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoJ2RhcmsnKTtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ2NvbG9yLXRoZW1lJywgJ2xpZ2h0Jyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsYXNzTGlzdC5hZGQoJ2RhcmsnKTtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ2NvbG9yLXRoZW1lJywgJ2RhcmsnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSk7XG4gICAgfVxufSIsICIvLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvc2NoZWR1bGVyLmpzXG52YXIgZmx1c2hQZW5kaW5nID0gZmFsc2U7XG52YXIgZmx1c2hpbmcgPSBmYWxzZTtcbnZhciBxdWV1ZSA9IFtdO1xuZnVuY3Rpb24gc2NoZWR1bGVyKGNhbGxiYWNrKSB7XG4gIHF1ZXVlSm9iKGNhbGxiYWNrKTtcbn1cbmZ1bmN0aW9uIHF1ZXVlSm9iKGpvYikge1xuICBpZiAoIXF1ZXVlLmluY2x1ZGVzKGpvYikpXG4gICAgcXVldWUucHVzaChqb2IpO1xuICBxdWV1ZUZsdXNoKCk7XG59XG5mdW5jdGlvbiBkZXF1ZXVlSm9iKGpvYikge1xuICBsZXQgaW5kZXggPSBxdWV1ZS5pbmRleE9mKGpvYik7XG4gIGlmIChpbmRleCAhPT0gLTEpXG4gICAgcXVldWUuc3BsaWNlKGluZGV4LCAxKTtcbn1cbmZ1bmN0aW9uIHF1ZXVlRmx1c2goKSB7XG4gIGlmICghZmx1c2hpbmcgJiYgIWZsdXNoUGVuZGluZykge1xuICAgIGZsdXNoUGVuZGluZyA9IHRydWU7XG4gICAgcXVldWVNaWNyb3Rhc2soZmx1c2hKb2JzKTtcbiAgfVxufVxuZnVuY3Rpb24gZmx1c2hKb2JzKCkge1xuICBmbHVzaFBlbmRpbmcgPSBmYWxzZTtcbiAgZmx1c2hpbmcgPSB0cnVlO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgcXVldWVbaV0oKTtcbiAgfVxuICBxdWV1ZS5sZW5ndGggPSAwO1xuICBmbHVzaGluZyA9IGZhbHNlO1xufVxuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvcmVhY3Rpdml0eS5qc1xudmFyIHJlYWN0aXZlO1xudmFyIGVmZmVjdDtcbnZhciByZWxlYXNlO1xudmFyIHJhdztcbnZhciBzaG91bGRTY2hlZHVsZSA9IHRydWU7XG5mdW5jdGlvbiBkaXNhYmxlRWZmZWN0U2NoZWR1bGluZyhjYWxsYmFjaykge1xuICBzaG91bGRTY2hlZHVsZSA9IGZhbHNlO1xuICBjYWxsYmFjaygpO1xuICBzaG91bGRTY2hlZHVsZSA9IHRydWU7XG59XG5mdW5jdGlvbiBzZXRSZWFjdGl2aXR5RW5naW5lKGVuZ2luZSkge1xuICByZWFjdGl2ZSA9IGVuZ2luZS5yZWFjdGl2ZTtcbiAgcmVsZWFzZSA9IGVuZ2luZS5yZWxlYXNlO1xuICBlZmZlY3QgPSAoY2FsbGJhY2spID0+IGVuZ2luZS5lZmZlY3QoY2FsbGJhY2ssIHtzY2hlZHVsZXI6ICh0YXNrKSA9PiB7XG4gICAgaWYgKHNob3VsZFNjaGVkdWxlKSB7XG4gICAgICBzY2hlZHVsZXIodGFzayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhc2soKTtcbiAgICB9XG4gIH19KTtcbiAgcmF3ID0gZW5naW5lLnJhdztcbn1cbmZ1bmN0aW9uIG92ZXJyaWRlRWZmZWN0KG92ZXJyaWRlKSB7XG4gIGVmZmVjdCA9IG92ZXJyaWRlO1xufVxuZnVuY3Rpb24gZWxlbWVudEJvdW5kRWZmZWN0KGVsKSB7XG4gIGxldCBjbGVhbnVwMiA9ICgpID0+IHtcbiAgfTtcbiAgbGV0IHdyYXBwZWRFZmZlY3QgPSAoY2FsbGJhY2spID0+IHtcbiAgICBsZXQgZWZmZWN0UmVmZXJlbmNlID0gZWZmZWN0KGNhbGxiYWNrKTtcbiAgICBpZiAoIWVsLl94X2VmZmVjdHMpIHtcbiAgICAgIGVsLl94X2VmZmVjdHMgPSBuZXcgU2V0KCk7XG4gICAgICBlbC5feF9ydW5FZmZlY3RzID0gKCkgPT4ge1xuICAgICAgICBlbC5feF9lZmZlY3RzLmZvckVhY2goKGkpID0+IGkoKSk7XG4gICAgICB9O1xuICAgIH1cbiAgICBlbC5feF9lZmZlY3RzLmFkZChlZmZlY3RSZWZlcmVuY2UpO1xuICAgIGNsZWFudXAyID0gKCkgPT4ge1xuICAgICAgaWYgKGVmZmVjdFJlZmVyZW5jZSA9PT0gdm9pZCAwKVxuICAgICAgICByZXR1cm47XG4gICAgICBlbC5feF9lZmZlY3RzLmRlbGV0ZShlZmZlY3RSZWZlcmVuY2UpO1xuICAgICAgcmVsZWFzZShlZmZlY3RSZWZlcmVuY2UpO1xuICAgIH07XG4gICAgcmV0dXJuIGVmZmVjdFJlZmVyZW5jZTtcbiAgfTtcbiAgcmV0dXJuIFt3cmFwcGVkRWZmZWN0LCAoKSA9PiB7XG4gICAgY2xlYW51cDIoKTtcbiAgfV07XG59XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy9tdXRhdGlvbi5qc1xudmFyIG9uQXR0cmlidXRlQWRkZWRzID0gW107XG52YXIgb25FbFJlbW92ZWRzID0gW107XG52YXIgb25FbEFkZGVkcyA9IFtdO1xuZnVuY3Rpb24gb25FbEFkZGVkKGNhbGxiYWNrKSB7XG4gIG9uRWxBZGRlZHMucHVzaChjYWxsYmFjayk7XG59XG5mdW5jdGlvbiBvbkVsUmVtb3ZlZChlbCwgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgaWYgKCFlbC5feF9jbGVhbnVwcylcbiAgICAgIGVsLl94X2NsZWFudXBzID0gW107XG4gICAgZWwuX3hfY2xlYW51cHMucHVzaChjYWxsYmFjayk7XG4gIH0gZWxzZSB7XG4gICAgY2FsbGJhY2sgPSBlbDtcbiAgICBvbkVsUmVtb3ZlZHMucHVzaChjYWxsYmFjayk7XG4gIH1cbn1cbmZ1bmN0aW9uIG9uQXR0cmlidXRlc0FkZGVkKGNhbGxiYWNrKSB7XG4gIG9uQXR0cmlidXRlQWRkZWRzLnB1c2goY2FsbGJhY2spO1xufVxuZnVuY3Rpb24gb25BdHRyaWJ1dGVSZW1vdmVkKGVsLCBuYW1lLCBjYWxsYmFjaykge1xuICBpZiAoIWVsLl94X2F0dHJpYnV0ZUNsZWFudXBzKVxuICAgIGVsLl94X2F0dHJpYnV0ZUNsZWFudXBzID0ge307XG4gIGlmICghZWwuX3hfYXR0cmlidXRlQ2xlYW51cHNbbmFtZV0pXG4gICAgZWwuX3hfYXR0cmlidXRlQ2xlYW51cHNbbmFtZV0gPSBbXTtcbiAgZWwuX3hfYXR0cmlidXRlQ2xlYW51cHNbbmFtZV0ucHVzaChjYWxsYmFjayk7XG59XG5mdW5jdGlvbiBjbGVhbnVwQXR0cmlidXRlcyhlbCwgbmFtZXMpIHtcbiAgaWYgKCFlbC5feF9hdHRyaWJ1dGVDbGVhbnVwcylcbiAgICByZXR1cm47XG4gIE9iamVjdC5lbnRyaWVzKGVsLl94X2F0dHJpYnV0ZUNsZWFudXBzKS5mb3JFYWNoKChbbmFtZSwgdmFsdWVdKSA9PiB7XG4gICAgaWYgKG5hbWVzID09PSB2b2lkIDAgfHwgbmFtZXMuaW5jbHVkZXMobmFtZSkpIHtcbiAgICAgIHZhbHVlLmZvckVhY2goKGkpID0+IGkoKSk7XG4gICAgICBkZWxldGUgZWwuX3hfYXR0cmlidXRlQ2xlYW51cHNbbmFtZV07XG4gICAgfVxuICB9KTtcbn1cbnZhciBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKG9uTXV0YXRlKTtcbnZhciBjdXJyZW50bHlPYnNlcnZpbmcgPSBmYWxzZTtcbmZ1bmN0aW9uIHN0YXJ0T2JzZXJ2aW5nTXV0YXRpb25zKCkge1xuICBvYnNlcnZlci5vYnNlcnZlKGRvY3VtZW50LCB7c3VidHJlZTogdHJ1ZSwgY2hpbGRMaXN0OiB0cnVlLCBhdHRyaWJ1dGVzOiB0cnVlLCBhdHRyaWJ1dGVPbGRWYWx1ZTogdHJ1ZX0pO1xuICBjdXJyZW50bHlPYnNlcnZpbmcgPSB0cnVlO1xufVxuZnVuY3Rpb24gc3RvcE9ic2VydmluZ011dGF0aW9ucygpIHtcbiAgZmx1c2hPYnNlcnZlcigpO1xuICBvYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gIGN1cnJlbnRseU9ic2VydmluZyA9IGZhbHNlO1xufVxudmFyIHJlY29yZFF1ZXVlID0gW107XG52YXIgd2lsbFByb2Nlc3NSZWNvcmRRdWV1ZSA9IGZhbHNlO1xuZnVuY3Rpb24gZmx1c2hPYnNlcnZlcigpIHtcbiAgcmVjb3JkUXVldWUgPSByZWNvcmRRdWV1ZS5jb25jYXQob2JzZXJ2ZXIudGFrZVJlY29yZHMoKSk7XG4gIGlmIChyZWNvcmRRdWV1ZS5sZW5ndGggJiYgIXdpbGxQcm9jZXNzUmVjb3JkUXVldWUpIHtcbiAgICB3aWxsUHJvY2Vzc1JlY29yZFF1ZXVlID0gdHJ1ZTtcbiAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgICBwcm9jZXNzUmVjb3JkUXVldWUoKTtcbiAgICAgIHdpbGxQcm9jZXNzUmVjb3JkUXVldWUgPSBmYWxzZTtcbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gcHJvY2Vzc1JlY29yZFF1ZXVlKCkge1xuICBvbk11dGF0ZShyZWNvcmRRdWV1ZSk7XG4gIHJlY29yZFF1ZXVlLmxlbmd0aCA9IDA7XG59XG5mdW5jdGlvbiBtdXRhdGVEb20oY2FsbGJhY2spIHtcbiAgaWYgKCFjdXJyZW50bHlPYnNlcnZpbmcpXG4gICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gIHN0b3BPYnNlcnZpbmdNdXRhdGlvbnMoKTtcbiAgbGV0IHJlc3VsdCA9IGNhbGxiYWNrKCk7XG4gIHN0YXJ0T2JzZXJ2aW5nTXV0YXRpb25zKCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG52YXIgaXNDb2xsZWN0aW5nID0gZmFsc2U7XG52YXIgZGVmZXJyZWRNdXRhdGlvbnMgPSBbXTtcbmZ1bmN0aW9uIGRlZmVyTXV0YXRpb25zKCkge1xuICBpc0NvbGxlY3RpbmcgPSB0cnVlO1xufVxuZnVuY3Rpb24gZmx1c2hBbmRTdG9wRGVmZXJyaW5nTXV0YXRpb25zKCkge1xuICBpc0NvbGxlY3RpbmcgPSBmYWxzZTtcbiAgb25NdXRhdGUoZGVmZXJyZWRNdXRhdGlvbnMpO1xuICBkZWZlcnJlZE11dGF0aW9ucyA9IFtdO1xufVxuZnVuY3Rpb24gb25NdXRhdGUobXV0YXRpb25zKSB7XG4gIGlmIChpc0NvbGxlY3RpbmcpIHtcbiAgICBkZWZlcnJlZE11dGF0aW9ucyA9IGRlZmVycmVkTXV0YXRpb25zLmNvbmNhdChtdXRhdGlvbnMpO1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgYWRkZWROb2RlcyA9IFtdO1xuICBsZXQgcmVtb3ZlZE5vZGVzID0gW107XG4gIGxldCBhZGRlZEF0dHJpYnV0ZXMgPSBuZXcgTWFwKCk7XG4gIGxldCByZW1vdmVkQXR0cmlidXRlcyA9IG5ldyBNYXAoKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBtdXRhdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAobXV0YXRpb25zW2ldLnRhcmdldC5feF9pZ25vcmVNdXRhdGlvbk9ic2VydmVyKVxuICAgICAgY29udGludWU7XG4gICAgaWYgKG11dGF0aW9uc1tpXS50eXBlID09PSBcImNoaWxkTGlzdFwiKSB7XG4gICAgICBtdXRhdGlvbnNbaV0uYWRkZWROb2Rlcy5mb3JFYWNoKChub2RlKSA9PiBub2RlLm5vZGVUeXBlID09PSAxICYmIGFkZGVkTm9kZXMucHVzaChub2RlKSk7XG4gICAgICBtdXRhdGlvbnNbaV0ucmVtb3ZlZE5vZGVzLmZvckVhY2goKG5vZGUpID0+IG5vZGUubm9kZVR5cGUgPT09IDEgJiYgcmVtb3ZlZE5vZGVzLnB1c2gobm9kZSkpO1xuICAgIH1cbiAgICBpZiAobXV0YXRpb25zW2ldLnR5cGUgPT09IFwiYXR0cmlidXRlc1wiKSB7XG4gICAgICBsZXQgZWwgPSBtdXRhdGlvbnNbaV0udGFyZ2V0O1xuICAgICAgbGV0IG5hbWUgPSBtdXRhdGlvbnNbaV0uYXR0cmlidXRlTmFtZTtcbiAgICAgIGxldCBvbGRWYWx1ZSA9IG11dGF0aW9uc1tpXS5vbGRWYWx1ZTtcbiAgICAgIGxldCBhZGQyID0gKCkgPT4ge1xuICAgICAgICBpZiAoIWFkZGVkQXR0cmlidXRlcy5oYXMoZWwpKVxuICAgICAgICAgIGFkZGVkQXR0cmlidXRlcy5zZXQoZWwsIFtdKTtcbiAgICAgICAgYWRkZWRBdHRyaWJ1dGVzLmdldChlbCkucHVzaCh7bmFtZSwgdmFsdWU6IGVsLmdldEF0dHJpYnV0ZShuYW1lKX0pO1xuICAgICAgfTtcbiAgICAgIGxldCByZW1vdmUgPSAoKSA9PiB7XG4gICAgICAgIGlmICghcmVtb3ZlZEF0dHJpYnV0ZXMuaGFzKGVsKSlcbiAgICAgICAgICByZW1vdmVkQXR0cmlidXRlcy5zZXQoZWwsIFtdKTtcbiAgICAgICAgcmVtb3ZlZEF0dHJpYnV0ZXMuZ2V0KGVsKS5wdXNoKG5hbWUpO1xuICAgICAgfTtcbiAgICAgIGlmIChlbC5oYXNBdHRyaWJ1dGUobmFtZSkgJiYgb2xkVmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgYWRkMigpO1xuICAgICAgfSBlbHNlIGlmIChlbC5oYXNBdHRyaWJ1dGUobmFtZSkpIHtcbiAgICAgICAgcmVtb3ZlKCk7XG4gICAgICAgIGFkZDIoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlbW92ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZW1vdmVkQXR0cmlidXRlcy5mb3JFYWNoKChhdHRycywgZWwpID0+IHtcbiAgICBjbGVhbnVwQXR0cmlidXRlcyhlbCwgYXR0cnMpO1xuICB9KTtcbiAgYWRkZWRBdHRyaWJ1dGVzLmZvckVhY2goKGF0dHJzLCBlbCkgPT4ge1xuICAgIG9uQXR0cmlidXRlQWRkZWRzLmZvckVhY2goKGkpID0+IGkoZWwsIGF0dHJzKSk7XG4gIH0pO1xuICBmb3IgKGxldCBub2RlIG9mIHJlbW92ZWROb2Rlcykge1xuICAgIGlmIChhZGRlZE5vZGVzLmluY2x1ZGVzKG5vZGUpKVxuICAgICAgY29udGludWU7XG4gICAgb25FbFJlbW92ZWRzLmZvckVhY2goKGkpID0+IGkobm9kZSkpO1xuICAgIGlmIChub2RlLl94X2NsZWFudXBzKSB7XG4gICAgICB3aGlsZSAobm9kZS5feF9jbGVhbnVwcy5sZW5ndGgpXG4gICAgICAgIG5vZGUuX3hfY2xlYW51cHMucG9wKCkoKTtcbiAgICB9XG4gIH1cbiAgYWRkZWROb2Rlcy5mb3JFYWNoKChub2RlKSA9PiB7XG4gICAgbm9kZS5feF9pZ25vcmVTZWxmID0gdHJ1ZTtcbiAgICBub2RlLl94X2lnbm9yZSA9IHRydWU7XG4gIH0pO1xuICBmb3IgKGxldCBub2RlIG9mIGFkZGVkTm9kZXMpIHtcbiAgICBpZiAocmVtb3ZlZE5vZGVzLmluY2x1ZGVzKG5vZGUpKVxuICAgICAgY29udGludWU7XG4gICAgaWYgKCFub2RlLmlzQ29ubmVjdGVkKVxuICAgICAgY29udGludWU7XG4gICAgZGVsZXRlIG5vZGUuX3hfaWdub3JlU2VsZjtcbiAgICBkZWxldGUgbm9kZS5feF9pZ25vcmU7XG4gICAgb25FbEFkZGVkcy5mb3JFYWNoKChpKSA9PiBpKG5vZGUpKTtcbiAgICBub2RlLl94X2lnbm9yZSA9IHRydWU7XG4gICAgbm9kZS5feF9pZ25vcmVTZWxmID0gdHJ1ZTtcbiAgfVxuICBhZGRlZE5vZGVzLmZvckVhY2goKG5vZGUpID0+IHtcbiAgICBkZWxldGUgbm9kZS5feF9pZ25vcmVTZWxmO1xuICAgIGRlbGV0ZSBub2RlLl94X2lnbm9yZTtcbiAgfSk7XG4gIGFkZGVkTm9kZXMgPSBudWxsO1xuICByZW1vdmVkTm9kZXMgPSBudWxsO1xuICBhZGRlZEF0dHJpYnV0ZXMgPSBudWxsO1xuICByZW1vdmVkQXR0cmlidXRlcyA9IG51bGw7XG59XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy9zY29wZS5qc1xuZnVuY3Rpb24gc2NvcGUobm9kZSkge1xuICByZXR1cm4gbWVyZ2VQcm94aWVzKGNsb3Nlc3REYXRhU3RhY2sobm9kZSkpO1xufVxuZnVuY3Rpb24gYWRkU2NvcGVUb05vZGUobm9kZSwgZGF0YTIsIHJlZmVyZW5jZU5vZGUpIHtcbiAgbm9kZS5feF9kYXRhU3RhY2sgPSBbZGF0YTIsIC4uLmNsb3Nlc3REYXRhU3RhY2socmVmZXJlbmNlTm9kZSB8fCBub2RlKV07XG4gIHJldHVybiAoKSA9PiB7XG4gICAgbm9kZS5feF9kYXRhU3RhY2sgPSBub2RlLl94X2RhdGFTdGFjay5maWx0ZXIoKGkpID0+IGkgIT09IGRhdGEyKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIHJlZnJlc2hTY29wZShlbGVtZW50LCBzY29wZTIpIHtcbiAgbGV0IGV4aXN0aW5nU2NvcGUgPSBlbGVtZW50Ll94X2RhdGFTdGFja1swXTtcbiAgT2JqZWN0LmVudHJpZXMoc2NvcGUyKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICBleGlzdGluZ1Njb3BlW2tleV0gPSB2YWx1ZTtcbiAgfSk7XG59XG5mdW5jdGlvbiBjbG9zZXN0RGF0YVN0YWNrKG5vZGUpIHtcbiAgaWYgKG5vZGUuX3hfZGF0YVN0YWNrKVxuICAgIHJldHVybiBub2RlLl94X2RhdGFTdGFjaztcbiAgaWYgKHR5cGVvZiBTaGFkb3dSb290ID09PSBcImZ1bmN0aW9uXCIgJiYgbm9kZSBpbnN0YW5jZW9mIFNoYWRvd1Jvb3QpIHtcbiAgICByZXR1cm4gY2xvc2VzdERhdGFTdGFjayhub2RlLmhvc3QpO1xuICB9XG4gIGlmICghbm9kZS5wYXJlbnROb2RlKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIHJldHVybiBjbG9zZXN0RGF0YVN0YWNrKG5vZGUucGFyZW50Tm9kZSk7XG59XG5mdW5jdGlvbiBtZXJnZVByb3hpZXMob2JqZWN0cykge1xuICBsZXQgdGhpc1Byb3h5ID0gbmV3IFByb3h5KHt9LCB7XG4gICAgb3duS2V5czogKCkgPT4ge1xuICAgICAgcmV0dXJuIEFycmF5LmZyb20obmV3IFNldChvYmplY3RzLmZsYXRNYXAoKGkpID0+IE9iamVjdC5rZXlzKGkpKSkpO1xuICAgIH0sXG4gICAgaGFzOiAodGFyZ2V0LCBuYW1lKSA9PiB7XG4gICAgICByZXR1cm4gb2JqZWN0cy5zb21lKChvYmopID0+IG9iai5oYXNPd25Qcm9wZXJ0eShuYW1lKSk7XG4gICAgfSxcbiAgICBnZXQ6ICh0YXJnZXQsIG5hbWUpID0+IHtcbiAgICAgIHJldHVybiAob2JqZWN0cy5maW5kKChvYmopID0+IHtcbiAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgIGxldCBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIG5hbWUpO1xuICAgICAgICAgIGlmIChkZXNjcmlwdG9yLmdldCAmJiBkZXNjcmlwdG9yLmdldC5feF9hbHJlYWR5Qm91bmQgfHwgZGVzY3JpcHRvci5zZXQgJiYgZGVzY3JpcHRvci5zZXQuX3hfYWxyZWFkeUJvdW5kKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKChkZXNjcmlwdG9yLmdldCB8fCBkZXNjcmlwdG9yLnNldCkgJiYgZGVzY3JpcHRvci5lbnVtZXJhYmxlKSB7XG4gICAgICAgICAgICBsZXQgZ2V0dGVyID0gZGVzY3JpcHRvci5nZXQ7XG4gICAgICAgICAgICBsZXQgc2V0dGVyID0gZGVzY3JpcHRvci5zZXQ7XG4gICAgICAgICAgICBsZXQgcHJvcGVydHkgPSBkZXNjcmlwdG9yO1xuICAgICAgICAgICAgZ2V0dGVyID0gZ2V0dGVyICYmIGdldHRlci5iaW5kKHRoaXNQcm94eSk7XG4gICAgICAgICAgICBzZXR0ZXIgPSBzZXR0ZXIgJiYgc2V0dGVyLmJpbmQodGhpc1Byb3h5KTtcbiAgICAgICAgICAgIGlmIChnZXR0ZXIpXG4gICAgICAgICAgICAgIGdldHRlci5feF9hbHJlYWR5Qm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHNldHRlcilcbiAgICAgICAgICAgICAgc2V0dGVyLl94X2FscmVhZHlCb3VuZCA9IHRydWU7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBuYW1lLCB7XG4gICAgICAgICAgICAgIC4uLnByb3BlcnR5LFxuICAgICAgICAgICAgICBnZXQ6IGdldHRlcixcbiAgICAgICAgICAgICAgc2V0OiBzZXR0ZXJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9KSB8fCB7fSlbbmFtZV07XG4gICAgfSxcbiAgICBzZXQ6ICh0YXJnZXQsIG5hbWUsIHZhbHVlKSA9PiB7XG4gICAgICBsZXQgY2xvc2VzdE9iamVjdFdpdGhLZXkgPSBvYmplY3RzLmZpbmQoKG9iaikgPT4gb2JqLmhhc093blByb3BlcnR5KG5hbWUpKTtcbiAgICAgIGlmIChjbG9zZXN0T2JqZWN0V2l0aEtleSkge1xuICAgICAgICBjbG9zZXN0T2JqZWN0V2l0aEtleVtuYW1lXSA9IHZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2JqZWN0c1tvYmplY3RzLmxlbmd0aCAtIDFdW25hbWVdID0gdmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gdGhpc1Byb3h5O1xufVxuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvaW50ZXJjZXB0b3IuanNcbmZ1bmN0aW9uIGluaXRJbnRlcmNlcHRvcnMoZGF0YTIpIHtcbiAgbGV0IGlzT2JqZWN0MiA9ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09IFwib2JqZWN0XCIgJiYgIUFycmF5LmlzQXJyYXkodmFsKSAmJiB2YWwgIT09IG51bGw7XG4gIGxldCByZWN1cnNlID0gKG9iaiwgYmFzZVBhdGggPSBcIlwiKSA9PiB7XG4gICAgT2JqZWN0LmVudHJpZXMoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMob2JqKSkuZm9yRWFjaCgoW2tleSwge3ZhbHVlLCBlbnVtZXJhYmxlfV0pID0+IHtcbiAgICAgIGlmIChlbnVtZXJhYmxlID09PSBmYWxzZSB8fCB2YWx1ZSA9PT0gdm9pZCAwKVxuICAgICAgICByZXR1cm47XG4gICAgICBsZXQgcGF0aCA9IGJhc2VQYXRoID09PSBcIlwiID8ga2V5IDogYCR7YmFzZVBhdGh9LiR7a2V5fWA7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIHZhbHVlICE9PSBudWxsICYmIHZhbHVlLl94X2ludGVyY2VwdG9yKSB7XG4gICAgICAgIG9ialtrZXldID0gdmFsdWUuaW5pdGlhbGl6ZShkYXRhMiwgcGF0aCwga2V5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc09iamVjdDIodmFsdWUpICYmIHZhbHVlICE9PSBvYmogJiYgISh2YWx1ZSBpbnN0YW5jZW9mIEVsZW1lbnQpKSB7XG4gICAgICAgICAgcmVjdXJzZSh2YWx1ZSwgcGF0aCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbiAgcmV0dXJuIHJlY3Vyc2UoZGF0YTIpO1xufVxuZnVuY3Rpb24gaW50ZXJjZXB0b3IoY2FsbGJhY2ssIG11dGF0ZU9iaiA9ICgpID0+IHtcbn0pIHtcbiAgbGV0IG9iaiA9IHtcbiAgICBpbml0aWFsVmFsdWU6IHZvaWQgMCxcbiAgICBfeF9pbnRlcmNlcHRvcjogdHJ1ZSxcbiAgICBpbml0aWFsaXplKGRhdGEyLCBwYXRoLCBrZXkpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayh0aGlzLmluaXRpYWxWYWx1ZSwgKCkgPT4gZ2V0KGRhdGEyLCBwYXRoKSwgKHZhbHVlKSA9PiBzZXQoZGF0YTIsIHBhdGgsIHZhbHVlKSwgcGF0aCwga2V5KTtcbiAgICB9XG4gIH07XG4gIG11dGF0ZU9iaihvYmopO1xuICByZXR1cm4gKGluaXRpYWxWYWx1ZSkgPT4ge1xuICAgIGlmICh0eXBlb2YgaW5pdGlhbFZhbHVlID09PSBcIm9iamVjdFwiICYmIGluaXRpYWxWYWx1ZSAhPT0gbnVsbCAmJiBpbml0aWFsVmFsdWUuX3hfaW50ZXJjZXB0b3IpIHtcbiAgICAgIGxldCBpbml0aWFsaXplID0gb2JqLmluaXRpYWxpemUuYmluZChvYmopO1xuICAgICAgb2JqLmluaXRpYWxpemUgPSAoZGF0YTIsIHBhdGgsIGtleSkgPT4ge1xuICAgICAgICBsZXQgaW5uZXJWYWx1ZSA9IGluaXRpYWxWYWx1ZS5pbml0aWFsaXplKGRhdGEyLCBwYXRoLCBrZXkpO1xuICAgICAgICBvYmouaW5pdGlhbFZhbHVlID0gaW5uZXJWYWx1ZTtcbiAgICAgICAgcmV0dXJuIGluaXRpYWxpemUoZGF0YTIsIHBhdGgsIGtleSk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBvYmouaW5pdGlhbFZhbHVlID0gaW5pdGlhbFZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gb2JqO1xuICB9O1xufVxuZnVuY3Rpb24gZ2V0KG9iaiwgcGF0aCkge1xuICByZXR1cm4gcGF0aC5zcGxpdChcIi5cIikucmVkdWNlKChjYXJyeSwgc2VnbWVudCkgPT4gY2Fycnlbc2VnbWVudF0sIG9iaik7XG59XG5mdW5jdGlvbiBzZXQob2JqLCBwYXRoLCB2YWx1ZSkge1xuICBpZiAodHlwZW9mIHBhdGggPT09IFwic3RyaW5nXCIpXG4gICAgcGF0aCA9IHBhdGguc3BsaXQoXCIuXCIpO1xuICBpZiAocGF0aC5sZW5ndGggPT09IDEpXG4gICAgb2JqW3BhdGhbMF1dID0gdmFsdWU7XG4gIGVsc2UgaWYgKHBhdGgubGVuZ3RoID09PSAwKVxuICAgIHRocm93IGVycm9yO1xuICBlbHNlIHtcbiAgICBpZiAob2JqW3BhdGhbMF1dKVxuICAgICAgcmV0dXJuIHNldChvYmpbcGF0aFswXV0sIHBhdGguc2xpY2UoMSksIHZhbHVlKTtcbiAgICBlbHNlIHtcbiAgICAgIG9ialtwYXRoWzBdXSA9IHt9O1xuICAgICAgcmV0dXJuIHNldChvYmpbcGF0aFswXV0sIHBhdGguc2xpY2UoMSksIHZhbHVlKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL21hZ2ljcy5qc1xudmFyIG1hZ2ljcyA9IHt9O1xuZnVuY3Rpb24gbWFnaWMobmFtZSwgY2FsbGJhY2spIHtcbiAgbWFnaWNzW25hbWVdID0gY2FsbGJhY2s7XG59XG5mdW5jdGlvbiBpbmplY3RNYWdpY3Mob2JqLCBlbCkge1xuICBPYmplY3QuZW50cmllcyhtYWdpY3MpLmZvckVhY2goKFtuYW1lLCBjYWxsYmFja10pID0+IHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBgJCR7bmFtZX1gLCB7XG4gICAgICBnZXQoKSB7XG4gICAgICAgIGxldCBbdXRpbGl0aWVzLCBjbGVhbnVwMl0gPSBnZXRFbGVtZW50Qm91bmRVdGlsaXRpZXMoZWwpO1xuICAgICAgICB1dGlsaXRpZXMgPSB7aW50ZXJjZXB0b3IsIC4uLnV0aWxpdGllc307XG4gICAgICAgIG9uRWxSZW1vdmVkKGVsLCBjbGVhbnVwMik7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlbCwgdXRpbGl0aWVzKTtcbiAgICAgIH0sXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIG9iajtcbn1cblxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL3V0aWxzL2Vycm9yLmpzXG5mdW5jdGlvbiB0cnlDYXRjaChlbCwgZXhwcmVzc2lvbiwgY2FsbGJhY2ssIC4uLmFyZ3MpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gY2FsbGJhY2soLi4uYXJncyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBoYW5kbGVFcnJvcihlLCBlbCwgZXhwcmVzc2lvbik7XG4gIH1cbn1cbmZ1bmN0aW9uIGhhbmRsZUVycm9yKGVycm9yMiwgZWwsIGV4cHJlc3Npb24gPSB2b2lkIDApIHtcbiAgT2JqZWN0LmFzc2lnbihlcnJvcjIsIHtlbCwgZXhwcmVzc2lvbn0pO1xuICBjb25zb2xlLndhcm4oYEFscGluZSBFeHByZXNzaW9uIEVycm9yOiAke2Vycm9yMi5tZXNzYWdlfVxuXG4ke2V4cHJlc3Npb24gPyAnRXhwcmVzc2lvbjogXCInICsgZXhwcmVzc2lvbiArICdcIlxcblxcbicgOiBcIlwifWAsIGVsKTtcbiAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgdGhyb3cgZXJyb3IyO1xuICB9LCAwKTtcbn1cblxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL2V2YWx1YXRvci5qc1xudmFyIHNob3VsZEF1dG9FdmFsdWF0ZUZ1bmN0aW9ucyA9IHRydWU7XG5mdW5jdGlvbiBkb250QXV0b0V2YWx1YXRlRnVuY3Rpb25zKGNhbGxiYWNrKSB7XG4gIGxldCBjYWNoZSA9IHNob3VsZEF1dG9FdmFsdWF0ZUZ1bmN0aW9ucztcbiAgc2hvdWxkQXV0b0V2YWx1YXRlRnVuY3Rpb25zID0gZmFsc2U7XG4gIGNhbGxiYWNrKCk7XG4gIHNob3VsZEF1dG9FdmFsdWF0ZUZ1bmN0aW9ucyA9IGNhY2hlO1xufVxuZnVuY3Rpb24gZXZhbHVhdGUoZWwsIGV4cHJlc3Npb24sIGV4dHJhcyA9IHt9KSB7XG4gIGxldCByZXN1bHQ7XG4gIGV2YWx1YXRlTGF0ZXIoZWwsIGV4cHJlc3Npb24pKCh2YWx1ZSkgPT4gcmVzdWx0ID0gdmFsdWUsIGV4dHJhcyk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBldmFsdWF0ZUxhdGVyKC4uLmFyZ3MpIHtcbiAgcmV0dXJuIHRoZUV2YWx1YXRvckZ1bmN0aW9uKC4uLmFyZ3MpO1xufVxudmFyIHRoZUV2YWx1YXRvckZ1bmN0aW9uID0gbm9ybWFsRXZhbHVhdG9yO1xuZnVuY3Rpb24gc2V0RXZhbHVhdG9yKG5ld0V2YWx1YXRvcikge1xuICB0aGVFdmFsdWF0b3JGdW5jdGlvbiA9IG5ld0V2YWx1YXRvcjtcbn1cbmZ1bmN0aW9uIG5vcm1hbEV2YWx1YXRvcihlbCwgZXhwcmVzc2lvbikge1xuICBsZXQgb3ZlcnJpZGRlbk1hZ2ljcyA9IHt9O1xuICBpbmplY3RNYWdpY3Mob3ZlcnJpZGRlbk1hZ2ljcywgZWwpO1xuICBsZXQgZGF0YVN0YWNrID0gW292ZXJyaWRkZW5NYWdpY3MsIC4uLmNsb3Nlc3REYXRhU3RhY2soZWwpXTtcbiAgaWYgKHR5cGVvZiBleHByZXNzaW9uID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICByZXR1cm4gZ2VuZXJhdGVFdmFsdWF0b3JGcm9tRnVuY3Rpb24oZGF0YVN0YWNrLCBleHByZXNzaW9uKTtcbiAgfVxuICBsZXQgZXZhbHVhdG9yID0gZ2VuZXJhdGVFdmFsdWF0b3JGcm9tU3RyaW5nKGRhdGFTdGFjaywgZXhwcmVzc2lvbiwgZWwpO1xuICByZXR1cm4gdHJ5Q2F0Y2guYmluZChudWxsLCBlbCwgZXhwcmVzc2lvbiwgZXZhbHVhdG9yKTtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlRXZhbHVhdG9yRnJvbUZ1bmN0aW9uKGRhdGFTdGFjaywgZnVuYykge1xuICByZXR1cm4gKHJlY2VpdmVyID0gKCkgPT4ge1xuICB9LCB7c2NvcGU6IHNjb3BlMiA9IHt9LCBwYXJhbXMgPSBbXX0gPSB7fSkgPT4ge1xuICAgIGxldCByZXN1bHQgPSBmdW5jLmFwcGx5KG1lcmdlUHJveGllcyhbc2NvcGUyLCAuLi5kYXRhU3RhY2tdKSwgcGFyYW1zKTtcbiAgICBydW5JZlR5cGVPZkZ1bmN0aW9uKHJlY2VpdmVyLCByZXN1bHQpO1xuICB9O1xufVxudmFyIGV2YWx1YXRvck1lbW8gPSB7fTtcbmZ1bmN0aW9uIGdlbmVyYXRlRnVuY3Rpb25Gcm9tU3RyaW5nKGV4cHJlc3Npb24sIGVsKSB7XG4gIGlmIChldmFsdWF0b3JNZW1vW2V4cHJlc3Npb25dKSB7XG4gICAgcmV0dXJuIGV2YWx1YXRvck1lbW9bZXhwcmVzc2lvbl07XG4gIH1cbiAgbGV0IEFzeW5jRnVuY3Rpb24gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoYXN5bmMgZnVuY3Rpb24oKSB7XG4gIH0pLmNvbnN0cnVjdG9yO1xuICBsZXQgcmlnaHRTaWRlU2FmZUV4cHJlc3Npb24gPSAvXltcXG5cXHNdKmlmLipcXCguKlxcKS8udGVzdChleHByZXNzaW9uKSB8fCAvXihsZXR8Y29uc3QpXFxzLy50ZXN0KGV4cHJlc3Npb24pID8gYCgoKSA9PiB7ICR7ZXhwcmVzc2lvbn0gfSkoKWAgOiBleHByZXNzaW9uO1xuICBjb25zdCBzYWZlQXN5bmNGdW5jdGlvbiA9ICgpID0+IHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIG5ldyBBc3luY0Z1bmN0aW9uKFtcIl9fc2VsZlwiLCBcInNjb3BlXCJdLCBgd2l0aCAoc2NvcGUpIHsgX19zZWxmLnJlc3VsdCA9ICR7cmlnaHRTaWRlU2FmZUV4cHJlc3Npb259IH07IF9fc2VsZi5maW5pc2hlZCA9IHRydWU7IHJldHVybiBfX3NlbGYucmVzdWx0O2ApO1xuICAgIH0gY2F0Y2ggKGVycm9yMikge1xuICAgICAgaGFuZGxlRXJyb3IoZXJyb3IyLCBlbCwgZXhwcmVzc2lvbik7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICB9O1xuICBsZXQgZnVuYyA9IHNhZmVBc3luY0Z1bmN0aW9uKCk7XG4gIGV2YWx1YXRvck1lbW9bZXhwcmVzc2lvbl0gPSBmdW5jO1xuICByZXR1cm4gZnVuYztcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlRXZhbHVhdG9yRnJvbVN0cmluZyhkYXRhU3RhY2ssIGV4cHJlc3Npb24sIGVsKSB7XG4gIGxldCBmdW5jID0gZ2VuZXJhdGVGdW5jdGlvbkZyb21TdHJpbmcoZXhwcmVzc2lvbiwgZWwpO1xuICByZXR1cm4gKHJlY2VpdmVyID0gKCkgPT4ge1xuICB9LCB7c2NvcGU6IHNjb3BlMiA9IHt9LCBwYXJhbXMgPSBbXX0gPSB7fSkgPT4ge1xuICAgIGZ1bmMucmVzdWx0ID0gdm9pZCAwO1xuICAgIGZ1bmMuZmluaXNoZWQgPSBmYWxzZTtcbiAgICBsZXQgY29tcGxldGVTY29wZSA9IG1lcmdlUHJveGllcyhbc2NvcGUyLCAuLi5kYXRhU3RhY2tdKTtcbiAgICBpZiAodHlwZW9mIGZ1bmMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgbGV0IHByb21pc2UgPSBmdW5jKGZ1bmMsIGNvbXBsZXRlU2NvcGUpLmNhdGNoKChlcnJvcjIpID0+IGhhbmRsZUVycm9yKGVycm9yMiwgZWwsIGV4cHJlc3Npb24pKTtcbiAgICAgIGlmIChmdW5jLmZpbmlzaGVkKSB7XG4gICAgICAgIHJ1bklmVHlwZU9mRnVuY3Rpb24ocmVjZWl2ZXIsIGZ1bmMucmVzdWx0LCBjb21wbGV0ZVNjb3BlLCBwYXJhbXMsIGVsKTtcbiAgICAgICAgZnVuYy5yZXN1bHQgPSB2b2lkIDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9taXNlLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICAgIHJ1bklmVHlwZU9mRnVuY3Rpb24ocmVjZWl2ZXIsIHJlc3VsdCwgY29tcGxldGVTY29wZSwgcGFyYW1zLCBlbCk7XG4gICAgICAgIH0pLmNhdGNoKChlcnJvcjIpID0+IGhhbmRsZUVycm9yKGVycm9yMiwgZWwsIGV4cHJlc3Npb24pKS5maW5hbGx5KCgpID0+IGZ1bmMucmVzdWx0ID0gdm9pZCAwKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBydW5JZlR5cGVPZkZ1bmN0aW9uKHJlY2VpdmVyLCB2YWx1ZSwgc2NvcGUyLCBwYXJhbXMsIGVsKSB7XG4gIGlmIChzaG91bGRBdXRvRXZhbHVhdGVGdW5jdGlvbnMgJiYgdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBsZXQgcmVzdWx0ID0gdmFsdWUuYXBwbHkoc2NvcGUyLCBwYXJhbXMpO1xuICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICByZXN1bHQudGhlbigoaSkgPT4gcnVuSWZUeXBlT2ZGdW5jdGlvbihyZWNlaXZlciwgaSwgc2NvcGUyLCBwYXJhbXMpKS5jYXRjaCgoZXJyb3IyKSA9PiBoYW5kbGVFcnJvcihlcnJvcjIsIGVsLCB2YWx1ZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZWNlaXZlcihyZXN1bHQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZWNlaXZlcih2YWx1ZSk7XG4gIH1cbn1cblxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL2RpcmVjdGl2ZXMuanNcbnZhciBwcmVmaXhBc1N0cmluZyA9IFwieC1cIjtcbmZ1bmN0aW9uIHByZWZpeChzdWJqZWN0ID0gXCJcIikge1xuICByZXR1cm4gcHJlZml4QXNTdHJpbmcgKyBzdWJqZWN0O1xufVxuZnVuY3Rpb24gc2V0UHJlZml4KG5ld1ByZWZpeCkge1xuICBwcmVmaXhBc1N0cmluZyA9IG5ld1ByZWZpeDtcbn1cbnZhciBkaXJlY3RpdmVIYW5kbGVycyA9IHt9O1xuZnVuY3Rpb24gZGlyZWN0aXZlKG5hbWUsIGNhbGxiYWNrKSB7XG4gIGRpcmVjdGl2ZUhhbmRsZXJzW25hbWVdID0gY2FsbGJhY2s7XG59XG5mdW5jdGlvbiBkaXJlY3RpdmVzKGVsLCBhdHRyaWJ1dGVzLCBvcmlnaW5hbEF0dHJpYnV0ZU92ZXJyaWRlKSB7XG4gIGxldCB0cmFuc2Zvcm1lZEF0dHJpYnV0ZU1hcCA9IHt9O1xuICBsZXQgZGlyZWN0aXZlczIgPSBBcnJheS5mcm9tKGF0dHJpYnV0ZXMpLm1hcCh0b1RyYW5zZm9ybWVkQXR0cmlidXRlcygobmV3TmFtZSwgb2xkTmFtZSkgPT4gdHJhbnNmb3JtZWRBdHRyaWJ1dGVNYXBbbmV3TmFtZV0gPSBvbGROYW1lKSkuZmlsdGVyKG91dE5vbkFscGluZUF0dHJpYnV0ZXMpLm1hcCh0b1BhcnNlZERpcmVjdGl2ZXModHJhbnNmb3JtZWRBdHRyaWJ1dGVNYXAsIG9yaWdpbmFsQXR0cmlidXRlT3ZlcnJpZGUpKS5zb3J0KGJ5UHJpb3JpdHkpO1xuICByZXR1cm4gZGlyZWN0aXZlczIubWFwKChkaXJlY3RpdmUyKSA9PiB7XG4gICAgcmV0dXJuIGdldERpcmVjdGl2ZUhhbmRsZXIoZWwsIGRpcmVjdGl2ZTIpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGF0dHJpYnV0ZXNPbmx5KGF0dHJpYnV0ZXMpIHtcbiAgcmV0dXJuIEFycmF5LmZyb20oYXR0cmlidXRlcykubWFwKHRvVHJhbnNmb3JtZWRBdHRyaWJ1dGVzKCkpLmZpbHRlcigoYXR0cikgPT4gIW91dE5vbkFscGluZUF0dHJpYnV0ZXMoYXR0cikpO1xufVxudmFyIGlzRGVmZXJyaW5nSGFuZGxlcnMgPSBmYWxzZTtcbnZhciBkaXJlY3RpdmVIYW5kbGVyU3RhY2tzID0gbmV3IE1hcCgpO1xudmFyIGN1cnJlbnRIYW5kbGVyU3RhY2tLZXkgPSBTeW1ib2woKTtcbmZ1bmN0aW9uIGRlZmVySGFuZGxpbmdEaXJlY3RpdmVzKGNhbGxiYWNrKSB7XG4gIGlzRGVmZXJyaW5nSGFuZGxlcnMgPSB0cnVlO1xuICBsZXQga2V5ID0gU3ltYm9sKCk7XG4gIGN1cnJlbnRIYW5kbGVyU3RhY2tLZXkgPSBrZXk7XG4gIGRpcmVjdGl2ZUhhbmRsZXJTdGFja3Muc2V0KGtleSwgW10pO1xuICBsZXQgZmx1c2hIYW5kbGVycyA9ICgpID0+IHtcbiAgICB3aGlsZSAoZGlyZWN0aXZlSGFuZGxlclN0YWNrcy5nZXQoa2V5KS5sZW5ndGgpXG4gICAgICBkaXJlY3RpdmVIYW5kbGVyU3RhY2tzLmdldChrZXkpLnNoaWZ0KCkoKTtcbiAgICBkaXJlY3RpdmVIYW5kbGVyU3RhY2tzLmRlbGV0ZShrZXkpO1xuICB9O1xuICBsZXQgc3RvcERlZmVycmluZyA9ICgpID0+IHtcbiAgICBpc0RlZmVycmluZ0hhbmRsZXJzID0gZmFsc2U7XG4gICAgZmx1c2hIYW5kbGVycygpO1xuICB9O1xuICBjYWxsYmFjayhmbHVzaEhhbmRsZXJzKTtcbiAgc3RvcERlZmVycmluZygpO1xufVxuZnVuY3Rpb24gZ2V0RWxlbWVudEJvdW5kVXRpbGl0aWVzKGVsKSB7XG4gIGxldCBjbGVhbnVwcyA9IFtdO1xuICBsZXQgY2xlYW51cDIgPSAoY2FsbGJhY2spID0+IGNsZWFudXBzLnB1c2goY2FsbGJhY2spO1xuICBsZXQgW2VmZmVjdDMsIGNsZWFudXBFZmZlY3RdID0gZWxlbWVudEJvdW5kRWZmZWN0KGVsKTtcbiAgY2xlYW51cHMucHVzaChjbGVhbnVwRWZmZWN0KTtcbiAgbGV0IHV0aWxpdGllcyA9IHtcbiAgICBBbHBpbmU6IGFscGluZV9kZWZhdWx0LFxuICAgIGVmZmVjdDogZWZmZWN0MyxcbiAgICBjbGVhbnVwOiBjbGVhbnVwMixcbiAgICBldmFsdWF0ZUxhdGVyOiBldmFsdWF0ZUxhdGVyLmJpbmQoZXZhbHVhdGVMYXRlciwgZWwpLFxuICAgIGV2YWx1YXRlOiBldmFsdWF0ZS5iaW5kKGV2YWx1YXRlLCBlbClcbiAgfTtcbiAgbGV0IGRvQ2xlYW51cCA9ICgpID0+IGNsZWFudXBzLmZvckVhY2goKGkpID0+IGkoKSk7XG4gIHJldHVybiBbdXRpbGl0aWVzLCBkb0NsZWFudXBdO1xufVxuZnVuY3Rpb24gZ2V0RGlyZWN0aXZlSGFuZGxlcihlbCwgZGlyZWN0aXZlMikge1xuICBsZXQgbm9vcCA9ICgpID0+IHtcbiAgfTtcbiAgbGV0IGhhbmRsZXIzID0gZGlyZWN0aXZlSGFuZGxlcnNbZGlyZWN0aXZlMi50eXBlXSB8fCBub29wO1xuICBsZXQgW3V0aWxpdGllcywgY2xlYW51cDJdID0gZ2V0RWxlbWVudEJvdW5kVXRpbGl0aWVzKGVsKTtcbiAgb25BdHRyaWJ1dGVSZW1vdmVkKGVsLCBkaXJlY3RpdmUyLm9yaWdpbmFsLCBjbGVhbnVwMik7XG4gIGxldCBmdWxsSGFuZGxlciA9ICgpID0+IHtcbiAgICBpZiAoZWwuX3hfaWdub3JlIHx8IGVsLl94X2lnbm9yZVNlbGYpXG4gICAgICByZXR1cm47XG4gICAgaGFuZGxlcjMuaW5saW5lICYmIGhhbmRsZXIzLmlubGluZShlbCwgZGlyZWN0aXZlMiwgdXRpbGl0aWVzKTtcbiAgICBoYW5kbGVyMyA9IGhhbmRsZXIzLmJpbmQoaGFuZGxlcjMsIGVsLCBkaXJlY3RpdmUyLCB1dGlsaXRpZXMpO1xuICAgIGlzRGVmZXJyaW5nSGFuZGxlcnMgPyBkaXJlY3RpdmVIYW5kbGVyU3RhY2tzLmdldChjdXJyZW50SGFuZGxlclN0YWNrS2V5KS5wdXNoKGhhbmRsZXIzKSA6IGhhbmRsZXIzKCk7XG4gIH07XG4gIGZ1bGxIYW5kbGVyLnJ1bkNsZWFudXBzID0gY2xlYW51cDI7XG4gIHJldHVybiBmdWxsSGFuZGxlcjtcbn1cbnZhciBzdGFydGluZ1dpdGggPSAoc3ViamVjdCwgcmVwbGFjZW1lbnQpID0+ICh7bmFtZSwgdmFsdWV9KSA9PiB7XG4gIGlmIChuYW1lLnN0YXJ0c1dpdGgoc3ViamVjdCkpXG4gICAgbmFtZSA9IG5hbWUucmVwbGFjZShzdWJqZWN0LCByZXBsYWNlbWVudCk7XG4gIHJldHVybiB7bmFtZSwgdmFsdWV9O1xufTtcbnZhciBpbnRvID0gKGkpID0+IGk7XG5mdW5jdGlvbiB0b1RyYW5zZm9ybWVkQXR0cmlidXRlcyhjYWxsYmFjayA9ICgpID0+IHtcbn0pIHtcbiAgcmV0dXJuICh7bmFtZSwgdmFsdWV9KSA9PiB7XG4gICAgbGV0IHtuYW1lOiBuZXdOYW1lLCB2YWx1ZTogbmV3VmFsdWV9ID0gYXR0cmlidXRlVHJhbnNmb3JtZXJzLnJlZHVjZSgoY2FycnksIHRyYW5zZm9ybSkgPT4ge1xuICAgICAgcmV0dXJuIHRyYW5zZm9ybShjYXJyeSk7XG4gICAgfSwge25hbWUsIHZhbHVlfSk7XG4gICAgaWYgKG5ld05hbWUgIT09IG5hbWUpXG4gICAgICBjYWxsYmFjayhuZXdOYW1lLCBuYW1lKTtcbiAgICByZXR1cm4ge25hbWU6IG5ld05hbWUsIHZhbHVlOiBuZXdWYWx1ZX07XG4gIH07XG59XG52YXIgYXR0cmlidXRlVHJhbnNmb3JtZXJzID0gW107XG5mdW5jdGlvbiBtYXBBdHRyaWJ1dGVzKGNhbGxiYWNrKSB7XG4gIGF0dHJpYnV0ZVRyYW5zZm9ybWVycy5wdXNoKGNhbGxiYWNrKTtcbn1cbmZ1bmN0aW9uIG91dE5vbkFscGluZUF0dHJpYnV0ZXMoe25hbWV9KSB7XG4gIHJldHVybiBhbHBpbmVBdHRyaWJ1dGVSZWdleCgpLnRlc3QobmFtZSk7XG59XG52YXIgYWxwaW5lQXR0cmlidXRlUmVnZXggPSAoKSA9PiBuZXcgUmVnRXhwKGBeJHtwcmVmaXhBc1N0cmluZ30oW146Xi5dKylcXFxcYmApO1xuZnVuY3Rpb24gdG9QYXJzZWREaXJlY3RpdmVzKHRyYW5zZm9ybWVkQXR0cmlidXRlTWFwLCBvcmlnaW5hbEF0dHJpYnV0ZU92ZXJyaWRlKSB7XG4gIHJldHVybiAoe25hbWUsIHZhbHVlfSkgPT4ge1xuICAgIGxldCB0eXBlTWF0Y2ggPSBuYW1lLm1hdGNoKGFscGluZUF0dHJpYnV0ZVJlZ2V4KCkpO1xuICAgIGxldCB2YWx1ZU1hdGNoID0gbmFtZS5tYXRjaCgvOihbYS16QS1aMC05XFwtOl0rKS8pO1xuICAgIGxldCBtb2RpZmllcnMgPSBuYW1lLm1hdGNoKC9cXC5bXi5cXF1dKyg/PVteXFxdXSokKS9nKSB8fCBbXTtcbiAgICBsZXQgb3JpZ2luYWwgPSBvcmlnaW5hbEF0dHJpYnV0ZU92ZXJyaWRlIHx8IHRyYW5zZm9ybWVkQXR0cmlidXRlTWFwW25hbWVdIHx8IG5hbWU7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IHR5cGVNYXRjaCA/IHR5cGVNYXRjaFsxXSA6IG51bGwsXG4gICAgICB2YWx1ZTogdmFsdWVNYXRjaCA/IHZhbHVlTWF0Y2hbMV0gOiBudWxsLFxuICAgICAgbW9kaWZpZXJzOiBtb2RpZmllcnMubWFwKChpKSA9PiBpLnJlcGxhY2UoXCIuXCIsIFwiXCIpKSxcbiAgICAgIGV4cHJlc3Npb246IHZhbHVlLFxuICAgICAgb3JpZ2luYWxcbiAgICB9O1xuICB9O1xufVxudmFyIERFRkFVTFQgPSBcIkRFRkFVTFRcIjtcbnZhciBkaXJlY3RpdmVPcmRlciA9IFtcbiAgXCJpZ25vcmVcIixcbiAgXCJyZWZcIixcbiAgXCJkYXRhXCIsXG4gIFwiaWRcIixcbiAgXCJiaW5kXCIsXG4gIFwiaW5pdFwiLFxuICBcImZvclwiLFxuICBcIm1hc2tcIixcbiAgXCJtb2RlbFwiLFxuICBcIm1vZGVsYWJsZVwiLFxuICBcInRyYW5zaXRpb25cIixcbiAgXCJzaG93XCIsXG4gIFwiaWZcIixcbiAgREVGQVVMVCxcbiAgXCJ0ZWxlcG9ydFwiLFxuICBcImVsZW1lbnRcIlxuXTtcbmZ1bmN0aW9uIGJ5UHJpb3JpdHkoYSwgYikge1xuICBsZXQgdHlwZUEgPSBkaXJlY3RpdmVPcmRlci5pbmRleE9mKGEudHlwZSkgPT09IC0xID8gREVGQVVMVCA6IGEudHlwZTtcbiAgbGV0IHR5cGVCID0gZGlyZWN0aXZlT3JkZXIuaW5kZXhPZihiLnR5cGUpID09PSAtMSA/IERFRkFVTFQgOiBiLnR5cGU7XG4gIHJldHVybiBkaXJlY3RpdmVPcmRlci5pbmRleE9mKHR5cGVBKSAtIGRpcmVjdGl2ZU9yZGVyLmluZGV4T2YodHlwZUIpO1xufVxuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvdXRpbHMvZGlzcGF0Y2guanNcbmZ1bmN0aW9uIGRpc3BhdGNoKGVsLCBuYW1lLCBkZXRhaWwgPSB7fSkge1xuICBlbC5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudChuYW1lLCB7XG4gICAgZGV0YWlsLFxuICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgY29tcG9zZWQ6IHRydWUsXG4gICAgY2FuY2VsYWJsZTogdHJ1ZVxuICB9KSk7XG59XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy9uZXh0VGljay5qc1xudmFyIHRpY2tTdGFjayA9IFtdO1xudmFyIGlzSG9sZGluZyA9IGZhbHNlO1xuZnVuY3Rpb24gbmV4dFRpY2soY2FsbGJhY2sgPSAoKSA9PiB7XG59KSB7XG4gIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICBpc0hvbGRpbmcgfHwgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICByZWxlYXNlTmV4dFRpY2tzKCk7XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlcykgPT4ge1xuICAgIHRpY2tTdGFjay5wdXNoKCgpID0+IHtcbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgICByZXMoKTtcbiAgICB9KTtcbiAgfSk7XG59XG5mdW5jdGlvbiByZWxlYXNlTmV4dFRpY2tzKCkge1xuICBpc0hvbGRpbmcgPSBmYWxzZTtcbiAgd2hpbGUgKHRpY2tTdGFjay5sZW5ndGgpXG4gICAgdGlja1N0YWNrLnNoaWZ0KCkoKTtcbn1cbmZ1bmN0aW9uIGhvbGROZXh0VGlja3MoKSB7XG4gIGlzSG9sZGluZyA9IHRydWU7XG59XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy91dGlscy93YWxrLmpzXG5mdW5jdGlvbiB3YWxrKGVsLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIFNoYWRvd1Jvb3QgPT09IFwiZnVuY3Rpb25cIiAmJiBlbCBpbnN0YW5jZW9mIFNoYWRvd1Jvb3QpIHtcbiAgICBBcnJheS5mcm9tKGVsLmNoaWxkcmVuKS5mb3JFYWNoKChlbDIpID0+IHdhbGsoZWwyLCBjYWxsYmFjaykpO1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgc2tpcCA9IGZhbHNlO1xuICBjYWxsYmFjayhlbCwgKCkgPT4gc2tpcCA9IHRydWUpO1xuICBpZiAoc2tpcClcbiAgICByZXR1cm47XG4gIGxldCBub2RlID0gZWwuZmlyc3RFbGVtZW50Q2hpbGQ7XG4gIHdoaWxlIChub2RlKSB7XG4gICAgd2Fsayhub2RlLCBjYWxsYmFjaywgZmFsc2UpO1xuICAgIG5vZGUgPSBub2RlLm5leHRFbGVtZW50U2libGluZztcbiAgfVxufVxuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvdXRpbHMvd2Fybi5qc1xuZnVuY3Rpb24gd2FybihtZXNzYWdlLCAuLi5hcmdzKSB7XG4gIGNvbnNvbGUud2FybihgQWxwaW5lIFdhcm5pbmc6ICR7bWVzc2FnZX1gLCAuLi5hcmdzKTtcbn1cblxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL2xpZmVjeWNsZS5qc1xuZnVuY3Rpb24gc3RhcnQoKSB7XG4gIGlmICghZG9jdW1lbnQuYm9keSlcbiAgICB3YXJuKFwiVW5hYmxlIHRvIGluaXRpYWxpemUuIFRyeWluZyB0byBsb2FkIEFscGluZSBiZWZvcmUgYDxib2R5PmAgaXMgYXZhaWxhYmxlLiBEaWQgeW91IGZvcmdldCB0byBhZGQgYGRlZmVyYCBpbiBBbHBpbmUncyBgPHNjcmlwdD5gIHRhZz9cIik7XG4gIGRpc3BhdGNoKGRvY3VtZW50LCBcImFscGluZTppbml0XCIpO1xuICBkaXNwYXRjaChkb2N1bWVudCwgXCJhbHBpbmU6aW5pdGlhbGl6aW5nXCIpO1xuICBzdGFydE9ic2VydmluZ011dGF0aW9ucygpO1xuICBvbkVsQWRkZWQoKGVsKSA9PiBpbml0VHJlZShlbCwgd2FsaykpO1xuICBvbkVsUmVtb3ZlZCgoZWwpID0+IGRlc3Ryb3lUcmVlKGVsKSk7XG4gIG9uQXR0cmlidXRlc0FkZGVkKChlbCwgYXR0cnMpID0+IHtcbiAgICBkaXJlY3RpdmVzKGVsLCBhdHRycykuZm9yRWFjaCgoaGFuZGxlKSA9PiBoYW5kbGUoKSk7XG4gIH0pO1xuICBsZXQgb3V0TmVzdGVkQ29tcG9uZW50cyA9IChlbCkgPT4gIWNsb3Nlc3RSb290KGVsLnBhcmVudEVsZW1lbnQsIHRydWUpO1xuICBBcnJheS5mcm9tKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoYWxsU2VsZWN0b3JzKCkpKS5maWx0ZXIob3V0TmVzdGVkQ29tcG9uZW50cykuZm9yRWFjaCgoZWwpID0+IHtcbiAgICBpbml0VHJlZShlbCk7XG4gIH0pO1xuICBkaXNwYXRjaChkb2N1bWVudCwgXCJhbHBpbmU6aW5pdGlhbGl6ZWRcIik7XG59XG52YXIgcm9vdFNlbGVjdG9yQ2FsbGJhY2tzID0gW107XG52YXIgaW5pdFNlbGVjdG9yQ2FsbGJhY2tzID0gW107XG5mdW5jdGlvbiByb290U2VsZWN0b3JzKCkge1xuICByZXR1cm4gcm9vdFNlbGVjdG9yQ2FsbGJhY2tzLm1hcCgoZm4pID0+IGZuKCkpO1xufVxuZnVuY3Rpb24gYWxsU2VsZWN0b3JzKCkge1xuICByZXR1cm4gcm9vdFNlbGVjdG9yQ2FsbGJhY2tzLmNvbmNhdChpbml0U2VsZWN0b3JDYWxsYmFja3MpLm1hcCgoZm4pID0+IGZuKCkpO1xufVxuZnVuY3Rpb24gYWRkUm9vdFNlbGVjdG9yKHNlbGVjdG9yQ2FsbGJhY2spIHtcbiAgcm9vdFNlbGVjdG9yQ2FsbGJhY2tzLnB1c2goc2VsZWN0b3JDYWxsYmFjayk7XG59XG5mdW5jdGlvbiBhZGRJbml0U2VsZWN0b3Ioc2VsZWN0b3JDYWxsYmFjaykge1xuICBpbml0U2VsZWN0b3JDYWxsYmFja3MucHVzaChzZWxlY3RvckNhbGxiYWNrKTtcbn1cbmZ1bmN0aW9uIGNsb3Nlc3RSb290KGVsLCBpbmNsdWRlSW5pdFNlbGVjdG9ycyA9IGZhbHNlKSB7XG4gIHJldHVybiBmaW5kQ2xvc2VzdChlbCwgKGVsZW1lbnQpID0+IHtcbiAgICBjb25zdCBzZWxlY3RvcnMgPSBpbmNsdWRlSW5pdFNlbGVjdG9ycyA/IGFsbFNlbGVjdG9ycygpIDogcm9vdFNlbGVjdG9ycygpO1xuICAgIGlmIChzZWxlY3RvcnMuc29tZSgoc2VsZWN0b3IpID0+IGVsZW1lbnQubWF0Y2hlcyhzZWxlY3RvcikpKVxuICAgICAgcmV0dXJuIHRydWU7XG4gIH0pO1xufVxuZnVuY3Rpb24gZmluZENsb3Nlc3QoZWwsIGNhbGxiYWNrKSB7XG4gIGlmICghZWwpXG4gICAgcmV0dXJuO1xuICBpZiAoY2FsbGJhY2soZWwpKVxuICAgIHJldHVybiBlbDtcbiAgaWYgKGVsLl94X3RlbGVwb3J0QmFjaylcbiAgICBlbCA9IGVsLl94X3RlbGVwb3J0QmFjaztcbiAgaWYgKCFlbC5wYXJlbnRFbGVtZW50KVxuICAgIHJldHVybjtcbiAgcmV0dXJuIGZpbmRDbG9zZXN0KGVsLnBhcmVudEVsZW1lbnQsIGNhbGxiYWNrKTtcbn1cbmZ1bmN0aW9uIGlzUm9vdChlbCkge1xuICByZXR1cm4gcm9vdFNlbGVjdG9ycygpLnNvbWUoKHNlbGVjdG9yKSA9PiBlbC5tYXRjaGVzKHNlbGVjdG9yKSk7XG59XG5mdW5jdGlvbiBpbml0VHJlZShlbCwgd2Fsa2VyID0gd2Fsaykge1xuICBkZWZlckhhbmRsaW5nRGlyZWN0aXZlcygoKSA9PiB7XG4gICAgd2Fsa2VyKGVsLCAoZWwyLCBza2lwKSA9PiB7XG4gICAgICBkaXJlY3RpdmVzKGVsMiwgZWwyLmF0dHJpYnV0ZXMpLmZvckVhY2goKGhhbmRsZSkgPT4gaGFuZGxlKCkpO1xuICAgICAgZWwyLl94X2lnbm9yZSAmJiBza2lwKCk7XG4gICAgfSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gZGVzdHJveVRyZWUocm9vdCkge1xuICB3YWxrKHJvb3QsIChlbCkgPT4gY2xlYW51cEF0dHJpYnV0ZXMoZWwpKTtcbn1cblxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL3V0aWxzL2NsYXNzZXMuanNcbmZ1bmN0aW9uIHNldENsYXNzZXMoZWwsIHZhbHVlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiBzZXRDbGFzc2VzRnJvbVN0cmluZyhlbCwgdmFsdWUuam9pbihcIiBcIikpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiB2YWx1ZSAhPT0gbnVsbCkge1xuICAgIHJldHVybiBzZXRDbGFzc2VzRnJvbU9iamVjdChlbCwgdmFsdWUpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgcmV0dXJuIHNldENsYXNzZXMoZWwsIHZhbHVlKCkpO1xuICB9XG4gIHJldHVybiBzZXRDbGFzc2VzRnJvbVN0cmluZyhlbCwgdmFsdWUpO1xufVxuZnVuY3Rpb24gc2V0Q2xhc3Nlc0Zyb21TdHJpbmcoZWwsIGNsYXNzU3RyaW5nKSB7XG4gIGxldCBzcGxpdCA9IChjbGFzc1N0cmluZzIpID0+IGNsYXNzU3RyaW5nMi5zcGxpdChcIiBcIikuZmlsdGVyKEJvb2xlYW4pO1xuICBsZXQgbWlzc2luZ0NsYXNzZXMgPSAoY2xhc3NTdHJpbmcyKSA9PiBjbGFzc1N0cmluZzIuc3BsaXQoXCIgXCIpLmZpbHRlcigoaSkgPT4gIWVsLmNsYXNzTGlzdC5jb250YWlucyhpKSkuZmlsdGVyKEJvb2xlYW4pO1xuICBsZXQgYWRkQ2xhc3Nlc0FuZFJldHVyblVuZG8gPSAoY2xhc3NlcykgPT4ge1xuICAgIGVsLmNsYXNzTGlzdC5hZGQoLi4uY2xhc3Nlcyk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoLi4uY2xhc3Nlcyk7XG4gICAgfTtcbiAgfTtcbiAgY2xhc3NTdHJpbmcgPSBjbGFzc1N0cmluZyA9PT0gdHJ1ZSA/IGNsYXNzU3RyaW5nID0gXCJcIiA6IGNsYXNzU3RyaW5nIHx8IFwiXCI7XG4gIHJldHVybiBhZGRDbGFzc2VzQW5kUmV0dXJuVW5kbyhtaXNzaW5nQ2xhc3NlcyhjbGFzc1N0cmluZykpO1xufVxuZnVuY3Rpb24gc2V0Q2xhc3Nlc0Zyb21PYmplY3QoZWwsIGNsYXNzT2JqZWN0KSB7XG4gIGxldCBzcGxpdCA9IChjbGFzc1N0cmluZykgPT4gY2xhc3NTdHJpbmcuc3BsaXQoXCIgXCIpLmZpbHRlcihCb29sZWFuKTtcbiAgbGV0IGZvckFkZCA9IE9iamVjdC5lbnRyaWVzKGNsYXNzT2JqZWN0KS5mbGF0TWFwKChbY2xhc3NTdHJpbmcsIGJvb2xdKSA9PiBib29sID8gc3BsaXQoY2xhc3NTdHJpbmcpIDogZmFsc2UpLmZpbHRlcihCb29sZWFuKTtcbiAgbGV0IGZvclJlbW92ZSA9IE9iamVjdC5lbnRyaWVzKGNsYXNzT2JqZWN0KS5mbGF0TWFwKChbY2xhc3NTdHJpbmcsIGJvb2xdKSA9PiAhYm9vbCA/IHNwbGl0KGNsYXNzU3RyaW5nKSA6IGZhbHNlKS5maWx0ZXIoQm9vbGVhbik7XG4gIGxldCBhZGRlZCA9IFtdO1xuICBsZXQgcmVtb3ZlZCA9IFtdO1xuICBmb3JSZW1vdmUuZm9yRWFjaCgoaSkgPT4ge1xuICAgIGlmIChlbC5jbGFzc0xpc3QuY29udGFpbnMoaSkpIHtcbiAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoaSk7XG4gICAgICByZW1vdmVkLnB1c2goaSk7XG4gICAgfVxuICB9KTtcbiAgZm9yQWRkLmZvckVhY2goKGkpID0+IHtcbiAgICBpZiAoIWVsLmNsYXNzTGlzdC5jb250YWlucyhpKSkge1xuICAgICAgZWwuY2xhc3NMaXN0LmFkZChpKTtcbiAgICAgIGFkZGVkLnB1c2goaSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICByZW1vdmVkLmZvckVhY2goKGkpID0+IGVsLmNsYXNzTGlzdC5hZGQoaSkpO1xuICAgIGFkZGVkLmZvckVhY2goKGkpID0+IGVsLmNsYXNzTGlzdC5yZW1vdmUoaSkpO1xuICB9O1xufVxuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvdXRpbHMvc3R5bGVzLmpzXG5mdW5jdGlvbiBzZXRTdHlsZXMoZWwsIHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgdmFsdWUgIT09IG51bGwpIHtcbiAgICByZXR1cm4gc2V0U3R5bGVzRnJvbU9iamVjdChlbCwgdmFsdWUpO1xuICB9XG4gIHJldHVybiBzZXRTdHlsZXNGcm9tU3RyaW5nKGVsLCB2YWx1ZSk7XG59XG5mdW5jdGlvbiBzZXRTdHlsZXNGcm9tT2JqZWN0KGVsLCB2YWx1ZSkge1xuICBsZXQgcHJldmlvdXNTdHlsZXMgPSB7fTtcbiAgT2JqZWN0LmVudHJpZXModmFsdWUpLmZvckVhY2goKFtrZXksIHZhbHVlMl0pID0+IHtcbiAgICBwcmV2aW91c1N0eWxlc1trZXldID0gZWwuc3R5bGVba2V5XTtcbiAgICBpZiAoIWtleS5zdGFydHNXaXRoKFwiLS1cIikpIHtcbiAgICAgIGtleSA9IGtlYmFiQ2FzZShrZXkpO1xuICAgIH1cbiAgICBlbC5zdHlsZS5zZXRQcm9wZXJ0eShrZXksIHZhbHVlMik7XG4gIH0pO1xuICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICBpZiAoZWwuc3R5bGUubGVuZ3RoID09PSAwKSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoXCJzdHlsZVwiKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIHNldFN0eWxlcyhlbCwgcHJldmlvdXNTdHlsZXMpO1xuICB9O1xufVxuZnVuY3Rpb24gc2V0U3R5bGVzRnJvbVN0cmluZyhlbCwgdmFsdWUpIHtcbiAgbGV0IGNhY2hlID0gZWwuZ2V0QXR0cmlidXRlKFwic3R5bGVcIiwgdmFsdWUpO1xuICBlbC5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCB2YWx1ZSk7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgZWwuc2V0QXR0cmlidXRlKFwic3R5bGVcIiwgY2FjaGUgfHwgXCJcIik7XG4gIH07XG59XG5mdW5jdGlvbiBrZWJhYkNhc2Uoc3ViamVjdCkge1xuICByZXR1cm4gc3ViamVjdC5yZXBsYWNlKC8oW2Etel0pKFtBLVpdKS9nLCBcIiQxLSQyXCIpLnRvTG93ZXJDYXNlKCk7XG59XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy91dGlscy9vbmNlLmpzXG5mdW5jdGlvbiBvbmNlKGNhbGxiYWNrLCBmYWxsYmFjayA9ICgpID0+IHtcbn0pIHtcbiAgbGV0IGNhbGxlZCA9IGZhbHNlO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCFjYWxsZWQpIHtcbiAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICBjYWxsYmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmYWxsYmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL2RpcmVjdGl2ZXMveC10cmFuc2l0aW9uLmpzXG5kaXJlY3RpdmUoXCJ0cmFuc2l0aW9uXCIsIChlbCwge3ZhbHVlLCBtb2RpZmllcnMsIGV4cHJlc3Npb259LCB7ZXZhbHVhdGU6IGV2YWx1YXRlMn0pID0+IHtcbiAgaWYgKHR5cGVvZiBleHByZXNzaW9uID09PSBcImZ1bmN0aW9uXCIpXG4gICAgZXhwcmVzc2lvbiA9IGV2YWx1YXRlMihleHByZXNzaW9uKTtcbiAgaWYgKCFleHByZXNzaW9uKSB7XG4gICAgcmVnaXN0ZXJUcmFuc2l0aW9uc0Zyb21IZWxwZXIoZWwsIG1vZGlmaWVycywgdmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIHJlZ2lzdGVyVHJhbnNpdGlvbnNGcm9tQ2xhc3NTdHJpbmcoZWwsIGV4cHJlc3Npb24sIHZhbHVlKTtcbiAgfVxufSk7XG5mdW5jdGlvbiByZWdpc3RlclRyYW5zaXRpb25zRnJvbUNsYXNzU3RyaW5nKGVsLCBjbGFzc1N0cmluZywgc3RhZ2UpIHtcbiAgcmVnaXN0ZXJUcmFuc2l0aW9uT2JqZWN0KGVsLCBzZXRDbGFzc2VzLCBcIlwiKTtcbiAgbGV0IGRpcmVjdGl2ZVN0b3JhZ2VNYXAgPSB7XG4gICAgZW50ZXI6IChjbGFzc2VzKSA9PiB7XG4gICAgICBlbC5feF90cmFuc2l0aW9uLmVudGVyLmR1cmluZyA9IGNsYXNzZXM7XG4gICAgfSxcbiAgICBcImVudGVyLXN0YXJ0XCI6IChjbGFzc2VzKSA9PiB7XG4gICAgICBlbC5feF90cmFuc2l0aW9uLmVudGVyLnN0YXJ0ID0gY2xhc3NlcztcbiAgICB9LFxuICAgIFwiZW50ZXItZW5kXCI6IChjbGFzc2VzKSA9PiB7XG4gICAgICBlbC5feF90cmFuc2l0aW9uLmVudGVyLmVuZCA9IGNsYXNzZXM7XG4gICAgfSxcbiAgICBsZWF2ZTogKGNsYXNzZXMpID0+IHtcbiAgICAgIGVsLl94X3RyYW5zaXRpb24ubGVhdmUuZHVyaW5nID0gY2xhc3NlcztcbiAgICB9LFxuICAgIFwibGVhdmUtc3RhcnRcIjogKGNsYXNzZXMpID0+IHtcbiAgICAgIGVsLl94X3RyYW5zaXRpb24ubGVhdmUuc3RhcnQgPSBjbGFzc2VzO1xuICAgIH0sXG4gICAgXCJsZWF2ZS1lbmRcIjogKGNsYXNzZXMpID0+IHtcbiAgICAgIGVsLl94X3RyYW5zaXRpb24ubGVhdmUuZW5kID0gY2xhc3NlcztcbiAgICB9XG4gIH07XG4gIGRpcmVjdGl2ZVN0b3JhZ2VNYXBbc3RhZ2VdKGNsYXNzU3RyaW5nKTtcbn1cbmZ1bmN0aW9uIHJlZ2lzdGVyVHJhbnNpdGlvbnNGcm9tSGVscGVyKGVsLCBtb2RpZmllcnMsIHN0YWdlKSB7XG4gIHJlZ2lzdGVyVHJhbnNpdGlvbk9iamVjdChlbCwgc2V0U3R5bGVzKTtcbiAgbGV0IGRvZXNudFNwZWNpZnkgPSAhbW9kaWZpZXJzLmluY2x1ZGVzKFwiaW5cIikgJiYgIW1vZGlmaWVycy5pbmNsdWRlcyhcIm91dFwiKSAmJiAhc3RhZ2U7XG4gIGxldCB0cmFuc2l0aW9uaW5nSW4gPSBkb2VzbnRTcGVjaWZ5IHx8IG1vZGlmaWVycy5pbmNsdWRlcyhcImluXCIpIHx8IFtcImVudGVyXCJdLmluY2x1ZGVzKHN0YWdlKTtcbiAgbGV0IHRyYW5zaXRpb25pbmdPdXQgPSBkb2VzbnRTcGVjaWZ5IHx8IG1vZGlmaWVycy5pbmNsdWRlcyhcIm91dFwiKSB8fCBbXCJsZWF2ZVwiXS5pbmNsdWRlcyhzdGFnZSk7XG4gIGlmIChtb2RpZmllcnMuaW5jbHVkZXMoXCJpblwiKSAmJiAhZG9lc250U3BlY2lmeSkge1xuICAgIG1vZGlmaWVycyA9IG1vZGlmaWVycy5maWx0ZXIoKGksIGluZGV4KSA9PiBpbmRleCA8IG1vZGlmaWVycy5pbmRleE9mKFwib3V0XCIpKTtcbiAgfVxuICBpZiAobW9kaWZpZXJzLmluY2x1ZGVzKFwib3V0XCIpICYmICFkb2VzbnRTcGVjaWZ5KSB7XG4gICAgbW9kaWZpZXJzID0gbW9kaWZpZXJzLmZpbHRlcigoaSwgaW5kZXgpID0+IGluZGV4ID4gbW9kaWZpZXJzLmluZGV4T2YoXCJvdXRcIikpO1xuICB9XG4gIGxldCB3YW50c0FsbCA9ICFtb2RpZmllcnMuaW5jbHVkZXMoXCJvcGFjaXR5XCIpICYmICFtb2RpZmllcnMuaW5jbHVkZXMoXCJzY2FsZVwiKTtcbiAgbGV0IHdhbnRzT3BhY2l0eSA9IHdhbnRzQWxsIHx8IG1vZGlmaWVycy5pbmNsdWRlcyhcIm9wYWNpdHlcIik7XG4gIGxldCB3YW50c1NjYWxlID0gd2FudHNBbGwgfHwgbW9kaWZpZXJzLmluY2x1ZGVzKFwic2NhbGVcIik7XG4gIGxldCBvcGFjaXR5VmFsdWUgPSB3YW50c09wYWNpdHkgPyAwIDogMTtcbiAgbGV0IHNjYWxlVmFsdWUgPSB3YW50c1NjYWxlID8gbW9kaWZpZXJWYWx1ZShtb2RpZmllcnMsIFwic2NhbGVcIiwgOTUpIC8gMTAwIDogMTtcbiAgbGV0IGRlbGF5ID0gbW9kaWZpZXJWYWx1ZShtb2RpZmllcnMsIFwiZGVsYXlcIiwgMCk7XG4gIGxldCBvcmlnaW4gPSBtb2RpZmllclZhbHVlKG1vZGlmaWVycywgXCJvcmlnaW5cIiwgXCJjZW50ZXJcIik7XG4gIGxldCBwcm9wZXJ0eSA9IFwib3BhY2l0eSwgdHJhbnNmb3JtXCI7XG4gIGxldCBkdXJhdGlvbkluID0gbW9kaWZpZXJWYWx1ZShtb2RpZmllcnMsIFwiZHVyYXRpb25cIiwgMTUwKSAvIDFlMztcbiAgbGV0IGR1cmF0aW9uT3V0ID0gbW9kaWZpZXJWYWx1ZShtb2RpZmllcnMsIFwiZHVyYXRpb25cIiwgNzUpIC8gMWUzO1xuICBsZXQgZWFzaW5nID0gYGN1YmljLWJlemllcigwLjQsIDAuMCwgMC4yLCAxKWA7XG4gIGlmICh0cmFuc2l0aW9uaW5nSW4pIHtcbiAgICBlbC5feF90cmFuc2l0aW9uLmVudGVyLmR1cmluZyA9IHtcbiAgICAgIHRyYW5zZm9ybU9yaWdpbjogb3JpZ2luLFxuICAgICAgdHJhbnNpdGlvbkRlbGF5OiBkZWxheSxcbiAgICAgIHRyYW5zaXRpb25Qcm9wZXJ0eTogcHJvcGVydHksXG4gICAgICB0cmFuc2l0aW9uRHVyYXRpb246IGAke2R1cmF0aW9uSW59c2AsXG4gICAgICB0cmFuc2l0aW9uVGltaW5nRnVuY3Rpb246IGVhc2luZ1xuICAgIH07XG4gICAgZWwuX3hfdHJhbnNpdGlvbi5lbnRlci5zdGFydCA9IHtcbiAgICAgIG9wYWNpdHk6IG9wYWNpdHlWYWx1ZSxcbiAgICAgIHRyYW5zZm9ybTogYHNjYWxlKCR7c2NhbGVWYWx1ZX0pYFxuICAgIH07XG4gICAgZWwuX3hfdHJhbnNpdGlvbi5lbnRlci5lbmQgPSB7XG4gICAgICBvcGFjaXR5OiAxLFxuICAgICAgdHJhbnNmb3JtOiBgc2NhbGUoMSlgXG4gICAgfTtcbiAgfVxuICBpZiAodHJhbnNpdGlvbmluZ091dCkge1xuICAgIGVsLl94X3RyYW5zaXRpb24ubGVhdmUuZHVyaW5nID0ge1xuICAgICAgdHJhbnNmb3JtT3JpZ2luOiBvcmlnaW4sXG4gICAgICB0cmFuc2l0aW9uRGVsYXk6IGRlbGF5LFxuICAgICAgdHJhbnNpdGlvblByb3BlcnR5OiBwcm9wZXJ0eSxcbiAgICAgIHRyYW5zaXRpb25EdXJhdGlvbjogYCR7ZHVyYXRpb25PdXR9c2AsXG4gICAgICB0cmFuc2l0aW9uVGltaW5nRnVuY3Rpb246IGVhc2luZ1xuICAgIH07XG4gICAgZWwuX3hfdHJhbnNpdGlvbi5sZWF2ZS5zdGFydCA9IHtcbiAgICAgIG9wYWNpdHk6IDEsXG4gICAgICB0cmFuc2Zvcm06IGBzY2FsZSgxKWBcbiAgICB9O1xuICAgIGVsLl94X3RyYW5zaXRpb24ubGVhdmUuZW5kID0ge1xuICAgICAgb3BhY2l0eTogb3BhY2l0eVZhbHVlLFxuICAgICAgdHJhbnNmb3JtOiBgc2NhbGUoJHtzY2FsZVZhbHVlfSlgXG4gICAgfTtcbiAgfVxufVxuZnVuY3Rpb24gcmVnaXN0ZXJUcmFuc2l0aW9uT2JqZWN0KGVsLCBzZXRGdW5jdGlvbiwgZGVmYXVsdFZhbHVlID0ge30pIHtcbiAgaWYgKCFlbC5feF90cmFuc2l0aW9uKVxuICAgIGVsLl94X3RyYW5zaXRpb24gPSB7XG4gICAgICBlbnRlcjoge2R1cmluZzogZGVmYXVsdFZhbHVlLCBzdGFydDogZGVmYXVsdFZhbHVlLCBlbmQ6IGRlZmF1bHRWYWx1ZX0sXG4gICAgICBsZWF2ZToge2R1cmluZzogZGVmYXVsdFZhbHVlLCBzdGFydDogZGVmYXVsdFZhbHVlLCBlbmQ6IGRlZmF1bHRWYWx1ZX0sXG4gICAgICBpbihiZWZvcmUgPSAoKSA9PiB7XG4gICAgICB9LCBhZnRlciA9ICgpID0+IHtcbiAgICAgIH0pIHtcbiAgICAgICAgdHJhbnNpdGlvbihlbCwgc2V0RnVuY3Rpb24sIHtcbiAgICAgICAgICBkdXJpbmc6IHRoaXMuZW50ZXIuZHVyaW5nLFxuICAgICAgICAgIHN0YXJ0OiB0aGlzLmVudGVyLnN0YXJ0LFxuICAgICAgICAgIGVuZDogdGhpcy5lbnRlci5lbmRcbiAgICAgICAgfSwgYmVmb3JlLCBhZnRlcik7XG4gICAgICB9LFxuICAgICAgb3V0KGJlZm9yZSA9ICgpID0+IHtcbiAgICAgIH0sIGFmdGVyID0gKCkgPT4ge1xuICAgICAgfSkge1xuICAgICAgICB0cmFuc2l0aW9uKGVsLCBzZXRGdW5jdGlvbiwge1xuICAgICAgICAgIGR1cmluZzogdGhpcy5sZWF2ZS5kdXJpbmcsXG4gICAgICAgICAgc3RhcnQ6IHRoaXMubGVhdmUuc3RhcnQsXG4gICAgICAgICAgZW5kOiB0aGlzLmxlYXZlLmVuZFxuICAgICAgICB9LCBiZWZvcmUsIGFmdGVyKTtcbiAgICAgIH1cbiAgICB9O1xufVxud2luZG93LkVsZW1lbnQucHJvdG90eXBlLl94X3RvZ2dsZUFuZENhc2NhZGVXaXRoVHJhbnNpdGlvbnMgPSBmdW5jdGlvbihlbCwgdmFsdWUsIHNob3csIGhpZGUpIHtcbiAgbGV0IGNsaWNrQXdheUNvbXBhdGlibGVTaG93ID0gKCkgPT4ge1xuICAgIGRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZSA9PT0gXCJ2aXNpYmxlXCIgPyByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoc2hvdykgOiBzZXRUaW1lb3V0KHNob3cpO1xuICB9O1xuICBpZiAodmFsdWUpIHtcbiAgICBpZiAoZWwuX3hfdHJhbnNpdGlvbiAmJiAoZWwuX3hfdHJhbnNpdGlvbi5lbnRlciB8fCBlbC5feF90cmFuc2l0aW9uLmxlYXZlKSkge1xuICAgICAgZWwuX3hfdHJhbnNpdGlvbi5lbnRlciAmJiAoT2JqZWN0LmVudHJpZXMoZWwuX3hfdHJhbnNpdGlvbi5lbnRlci5kdXJpbmcpLmxlbmd0aCB8fCBPYmplY3QuZW50cmllcyhlbC5feF90cmFuc2l0aW9uLmVudGVyLnN0YXJ0KS5sZW5ndGggfHwgT2JqZWN0LmVudHJpZXMoZWwuX3hfdHJhbnNpdGlvbi5lbnRlci5lbmQpLmxlbmd0aCkgPyBlbC5feF90cmFuc2l0aW9uLmluKHNob3cpIDogY2xpY2tBd2F5Q29tcGF0aWJsZVNob3coKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuX3hfdHJhbnNpdGlvbiA/IGVsLl94X3RyYW5zaXRpb24uaW4oc2hvdykgOiBjbGlja0F3YXlDb21wYXRpYmxlU2hvdygpO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cbiAgZWwuX3hfaGlkZVByb21pc2UgPSBlbC5feF90cmFuc2l0aW9uID8gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGVsLl94X3RyYW5zaXRpb24ub3V0KCgpID0+IHtcbiAgICB9LCAoKSA9PiByZXNvbHZlKGhpZGUpKTtcbiAgICBlbC5feF90cmFuc2l0aW9uaW5nLmJlZm9yZUNhbmNlbCgoKSA9PiByZWplY3Qoe2lzRnJvbUNhbmNlbGxlZFRyYW5zaXRpb246IHRydWV9KSk7XG4gIH0pIDogUHJvbWlzZS5yZXNvbHZlKGhpZGUpO1xuICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgbGV0IGNsb3Nlc3QgPSBjbG9zZXN0SGlkZShlbCk7XG4gICAgaWYgKGNsb3Nlc3QpIHtcbiAgICAgIGlmICghY2xvc2VzdC5feF9oaWRlQ2hpbGRyZW4pXG4gICAgICAgIGNsb3Nlc3QuX3hfaGlkZUNoaWxkcmVuID0gW107XG4gICAgICBjbG9zZXN0Ll94X2hpZGVDaGlsZHJlbi5wdXNoKGVsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgICBsZXQgaGlkZUFmdGVyQ2hpbGRyZW4gPSAoZWwyKSA9PiB7XG4gICAgICAgICAgbGV0IGNhcnJ5ID0gUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgZWwyLl94X2hpZGVQcm9taXNlLFxuICAgICAgICAgICAgLi4uKGVsMi5feF9oaWRlQ2hpbGRyZW4gfHwgW10pLm1hcChoaWRlQWZ0ZXJDaGlsZHJlbilcbiAgICAgICAgICBdKS50aGVuKChbaV0pID0+IGkoKSk7XG4gICAgICAgICAgZGVsZXRlIGVsMi5feF9oaWRlUHJvbWlzZTtcbiAgICAgICAgICBkZWxldGUgZWwyLl94X2hpZGVDaGlsZHJlbjtcbiAgICAgICAgICByZXR1cm4gY2Fycnk7XG4gICAgICAgIH07XG4gICAgICAgIGhpZGVBZnRlckNoaWxkcmVuKGVsKS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgIGlmICghZS5pc0Zyb21DYW5jZWxsZWRUcmFuc2l0aW9uKVxuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xufTtcbmZ1bmN0aW9uIGNsb3Nlc3RIaWRlKGVsKSB7XG4gIGxldCBwYXJlbnQgPSBlbC5wYXJlbnROb2RlO1xuICBpZiAoIXBhcmVudClcbiAgICByZXR1cm47XG4gIHJldHVybiBwYXJlbnQuX3hfaGlkZVByb21pc2UgPyBwYXJlbnQgOiBjbG9zZXN0SGlkZShwYXJlbnQpO1xufVxuZnVuY3Rpb24gdHJhbnNpdGlvbihlbCwgc2V0RnVuY3Rpb24sIHtkdXJpbmcsIHN0YXJ0OiBzdGFydDIsIGVuZH0gPSB7fSwgYmVmb3JlID0gKCkgPT4ge1xufSwgYWZ0ZXIgPSAoKSA9PiB7XG59KSB7XG4gIGlmIChlbC5feF90cmFuc2l0aW9uaW5nKVxuICAgIGVsLl94X3RyYW5zaXRpb25pbmcuY2FuY2VsKCk7XG4gIGlmIChPYmplY3Qua2V5cyhkdXJpbmcpLmxlbmd0aCA9PT0gMCAmJiBPYmplY3Qua2V5cyhzdGFydDIpLmxlbmd0aCA9PT0gMCAmJiBPYmplY3Qua2V5cyhlbmQpLmxlbmd0aCA9PT0gMCkge1xuICAgIGJlZm9yZSgpO1xuICAgIGFmdGVyKCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGxldCB1bmRvU3RhcnQsIHVuZG9EdXJpbmcsIHVuZG9FbmQ7XG4gIHBlcmZvcm1UcmFuc2l0aW9uKGVsLCB7XG4gICAgc3RhcnQoKSB7XG4gICAgICB1bmRvU3RhcnQgPSBzZXRGdW5jdGlvbihlbCwgc3RhcnQyKTtcbiAgICB9LFxuICAgIGR1cmluZygpIHtcbiAgICAgIHVuZG9EdXJpbmcgPSBzZXRGdW5jdGlvbihlbCwgZHVyaW5nKTtcbiAgICB9LFxuICAgIGJlZm9yZSxcbiAgICBlbmQoKSB7XG4gICAgICB1bmRvU3RhcnQoKTtcbiAgICAgIHVuZG9FbmQgPSBzZXRGdW5jdGlvbihlbCwgZW5kKTtcbiAgICB9LFxuICAgIGFmdGVyLFxuICAgIGNsZWFudXAoKSB7XG4gICAgICB1bmRvRHVyaW5nKCk7XG4gICAgICB1bmRvRW5kKCk7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIHBlcmZvcm1UcmFuc2l0aW9uKGVsLCBzdGFnZXMpIHtcbiAgbGV0IGludGVycnVwdGVkLCByZWFjaGVkQmVmb3JlLCByZWFjaGVkRW5kO1xuICBsZXQgZmluaXNoID0gb25jZSgoKSA9PiB7XG4gICAgbXV0YXRlRG9tKCgpID0+IHtcbiAgICAgIGludGVycnVwdGVkID0gdHJ1ZTtcbiAgICAgIGlmICghcmVhY2hlZEJlZm9yZSlcbiAgICAgICAgc3RhZ2VzLmJlZm9yZSgpO1xuICAgICAgaWYgKCFyZWFjaGVkRW5kKSB7XG4gICAgICAgIHN0YWdlcy5lbmQoKTtcbiAgICAgICAgcmVsZWFzZU5leHRUaWNrcygpO1xuICAgICAgfVxuICAgICAgc3RhZ2VzLmFmdGVyKCk7XG4gICAgICBpZiAoZWwuaXNDb25uZWN0ZWQpXG4gICAgICAgIHN0YWdlcy5jbGVhbnVwKCk7XG4gICAgICBkZWxldGUgZWwuX3hfdHJhbnNpdGlvbmluZztcbiAgICB9KTtcbiAgfSk7XG4gIGVsLl94X3RyYW5zaXRpb25pbmcgPSB7XG4gICAgYmVmb3JlQ2FuY2VsczogW10sXG4gICAgYmVmb3JlQ2FuY2VsKGNhbGxiYWNrKSB7XG4gICAgICB0aGlzLmJlZm9yZUNhbmNlbHMucHVzaChjYWxsYmFjayk7XG4gICAgfSxcbiAgICBjYW5jZWw6IG9uY2UoZnVuY3Rpb24oKSB7XG4gICAgICB3aGlsZSAodGhpcy5iZWZvcmVDYW5jZWxzLmxlbmd0aCkge1xuICAgICAgICB0aGlzLmJlZm9yZUNhbmNlbHMuc2hpZnQoKSgpO1xuICAgICAgfVxuICAgICAgO1xuICAgICAgZmluaXNoKCk7XG4gICAgfSksXG4gICAgZmluaXNoXG4gIH07XG4gIG11dGF0ZURvbSgoKSA9PiB7XG4gICAgc3RhZ2VzLnN0YXJ0KCk7XG4gICAgc3RhZ2VzLmR1cmluZygpO1xuICB9KTtcbiAgaG9sZE5leHRUaWNrcygpO1xuICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgIGlmIChpbnRlcnJ1cHRlZClcbiAgICAgIHJldHVybjtcbiAgICBsZXQgZHVyYXRpb24gPSBOdW1iZXIoZ2V0Q29tcHV0ZWRTdHlsZShlbCkudHJhbnNpdGlvbkR1cmF0aW9uLnJlcGxhY2UoLywuKi8sIFwiXCIpLnJlcGxhY2UoXCJzXCIsIFwiXCIpKSAqIDFlMztcbiAgICBsZXQgZGVsYXkgPSBOdW1iZXIoZ2V0Q29tcHV0ZWRTdHlsZShlbCkudHJhbnNpdGlvbkRlbGF5LnJlcGxhY2UoLywuKi8sIFwiXCIpLnJlcGxhY2UoXCJzXCIsIFwiXCIpKSAqIDFlMztcbiAgICBpZiAoZHVyYXRpb24gPT09IDApXG4gICAgICBkdXJhdGlvbiA9IE51bWJlcihnZXRDb21wdXRlZFN0eWxlKGVsKS5hbmltYXRpb25EdXJhdGlvbi5yZXBsYWNlKFwic1wiLCBcIlwiKSkgKiAxZTM7XG4gICAgbXV0YXRlRG9tKCgpID0+IHtcbiAgICAgIHN0YWdlcy5iZWZvcmUoKTtcbiAgICB9KTtcbiAgICByZWFjaGVkQmVmb3JlID0gdHJ1ZTtcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgaWYgKGludGVycnVwdGVkKVxuICAgICAgICByZXR1cm47XG4gICAgICBtdXRhdGVEb20oKCkgPT4ge1xuICAgICAgICBzdGFnZXMuZW5kKCk7XG4gICAgICB9KTtcbiAgICAgIHJlbGVhc2VOZXh0VGlja3MoKTtcbiAgICAgIHNldFRpbWVvdXQoZWwuX3hfdHJhbnNpdGlvbmluZy5maW5pc2gsIGR1cmF0aW9uICsgZGVsYXkpO1xuICAgICAgcmVhY2hlZEVuZCA9IHRydWU7XG4gICAgfSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gbW9kaWZpZXJWYWx1ZShtb2RpZmllcnMsIGtleSwgZmFsbGJhY2spIHtcbiAgaWYgKG1vZGlmaWVycy5pbmRleE9mKGtleSkgPT09IC0xKVxuICAgIHJldHVybiBmYWxsYmFjaztcbiAgY29uc3QgcmF3VmFsdWUgPSBtb2RpZmllcnNbbW9kaWZpZXJzLmluZGV4T2Yoa2V5KSArIDFdO1xuICBpZiAoIXJhd1ZhbHVlKVxuICAgIHJldHVybiBmYWxsYmFjaztcbiAgaWYgKGtleSA9PT0gXCJzY2FsZVwiKSB7XG4gICAgaWYgKGlzTmFOKHJhd1ZhbHVlKSlcbiAgICAgIHJldHVybiBmYWxsYmFjaztcbiAgfVxuICBpZiAoa2V5ID09PSBcImR1cmF0aW9uXCIpIHtcbiAgICBsZXQgbWF0Y2ggPSByYXdWYWx1ZS5tYXRjaCgvKFswLTldKyltcy8pO1xuICAgIGlmIChtYXRjaClcbiAgICAgIHJldHVybiBtYXRjaFsxXTtcbiAgfVxuICBpZiAoa2V5ID09PSBcIm9yaWdpblwiKSB7XG4gICAgaWYgKFtcInRvcFwiLCBcInJpZ2h0XCIsIFwibGVmdFwiLCBcImNlbnRlclwiLCBcImJvdHRvbVwiXS5pbmNsdWRlcyhtb2RpZmllcnNbbW9kaWZpZXJzLmluZGV4T2Yoa2V5KSArIDJdKSkge1xuICAgICAgcmV0dXJuIFtyYXdWYWx1ZSwgbW9kaWZpZXJzW21vZGlmaWVycy5pbmRleE9mKGtleSkgKyAyXV0uam9pbihcIiBcIik7XG4gICAgfVxuICB9XG4gIHJldHVybiByYXdWYWx1ZTtcbn1cblxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL2Nsb25lLmpzXG52YXIgaXNDbG9uaW5nID0gZmFsc2U7XG5mdW5jdGlvbiBza2lwRHVyaW5nQ2xvbmUoY2FsbGJhY2ssIGZhbGxiYWNrID0gKCkgPT4ge1xufSkge1xuICByZXR1cm4gKC4uLmFyZ3MpID0+IGlzQ2xvbmluZyA/IGZhbGxiYWNrKC4uLmFyZ3MpIDogY2FsbGJhY2soLi4uYXJncyk7XG59XG5mdW5jdGlvbiBjbG9uZShvbGRFbCwgbmV3RWwpIHtcbiAgaWYgKCFuZXdFbC5feF9kYXRhU3RhY2spXG4gICAgbmV3RWwuX3hfZGF0YVN0YWNrID0gb2xkRWwuX3hfZGF0YVN0YWNrO1xuICBpc0Nsb25pbmcgPSB0cnVlO1xuICBkb250UmVnaXN0ZXJSZWFjdGl2ZVNpZGVFZmZlY3RzKCgpID0+IHtcbiAgICBjbG9uZVRyZWUobmV3RWwpO1xuICB9KTtcbiAgaXNDbG9uaW5nID0gZmFsc2U7XG59XG5mdW5jdGlvbiBjbG9uZVRyZWUoZWwpIHtcbiAgbGV0IGhhc1J1blRocm91Z2hGaXJzdEVsID0gZmFsc2U7XG4gIGxldCBzaGFsbG93V2Fsa2VyID0gKGVsMiwgY2FsbGJhY2spID0+IHtcbiAgICB3YWxrKGVsMiwgKGVsMywgc2tpcCkgPT4ge1xuICAgICAgaWYgKGhhc1J1blRocm91Z2hGaXJzdEVsICYmIGlzUm9vdChlbDMpKVxuICAgICAgICByZXR1cm4gc2tpcCgpO1xuICAgICAgaGFzUnVuVGhyb3VnaEZpcnN0RWwgPSB0cnVlO1xuICAgICAgY2FsbGJhY2soZWwzLCBza2lwKTtcbiAgICB9KTtcbiAgfTtcbiAgaW5pdFRyZWUoZWwsIHNoYWxsb3dXYWxrZXIpO1xufVxuZnVuY3Rpb24gZG9udFJlZ2lzdGVyUmVhY3RpdmVTaWRlRWZmZWN0cyhjYWxsYmFjaykge1xuICBsZXQgY2FjaGUgPSBlZmZlY3Q7XG4gIG92ZXJyaWRlRWZmZWN0KChjYWxsYmFjazIsIGVsKSA9PiB7XG4gICAgbGV0IHN0b3JlZEVmZmVjdCA9IGNhY2hlKGNhbGxiYWNrMik7XG4gICAgcmVsZWFzZShzdG9yZWRFZmZlY3QpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgfTtcbiAgfSk7XG4gIGNhbGxiYWNrKCk7XG4gIG92ZXJyaWRlRWZmZWN0KGNhY2hlKTtcbn1cblxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL3V0aWxzL2JpbmQuanNcbmZ1bmN0aW9uIGJpbmQoZWwsIG5hbWUsIHZhbHVlLCBtb2RpZmllcnMgPSBbXSkge1xuICBpZiAoIWVsLl94X2JpbmRpbmdzKVxuICAgIGVsLl94X2JpbmRpbmdzID0gcmVhY3RpdmUoe30pO1xuICBlbC5feF9iaW5kaW5nc1tuYW1lXSA9IHZhbHVlO1xuICBuYW1lID0gbW9kaWZpZXJzLmluY2x1ZGVzKFwiY2FtZWxcIikgPyBjYW1lbENhc2UobmFtZSkgOiBuYW1lO1xuICBzd2l0Y2ggKG5hbWUpIHtcbiAgICBjYXNlIFwidmFsdWVcIjpcbiAgICAgIGJpbmRJbnB1dFZhbHVlKGVsLCB2YWx1ZSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwic3R5bGVcIjpcbiAgICAgIGJpbmRTdHlsZXMoZWwsIHZhbHVlKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJjbGFzc1wiOlxuICAgICAgYmluZENsYXNzZXMoZWwsIHZhbHVlKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBiaW5kQXR0cmlidXRlKGVsLCBuYW1lLCB2YWx1ZSk7XG4gICAgICBicmVhaztcbiAgfVxufVxuZnVuY3Rpb24gYmluZElucHV0VmFsdWUoZWwsIHZhbHVlKSB7XG4gIGlmIChlbC50eXBlID09PSBcInJhZGlvXCIpIHtcbiAgICBpZiAoZWwuYXR0cmlidXRlcy52YWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICBlbC52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICBpZiAod2luZG93LmZyb21Nb2RlbCkge1xuICAgICAgZWwuY2hlY2tlZCA9IGNoZWNrZWRBdHRyTG9vc2VDb21wYXJlKGVsLnZhbHVlLCB2YWx1ZSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGVsLnR5cGUgPT09IFwiY2hlY2tib3hcIikge1xuICAgIGlmIChOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlKSkge1xuICAgICAgZWwudmFsdWUgPSB2YWx1ZTtcbiAgICB9IGVsc2UgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlKSAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdHlwZW9mIHZhbHVlICE9PSBcImJvb2xlYW5cIiAmJiAhW251bGwsIHZvaWQgMF0uaW5jbHVkZXModmFsdWUpKSB7XG4gICAgICBlbC52YWx1ZSA9IFN0cmluZyh2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICBlbC5jaGVja2VkID0gdmFsdWUuc29tZSgodmFsKSA9PiBjaGVja2VkQXR0ckxvb3NlQ29tcGFyZSh2YWwsIGVsLnZhbHVlKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbC5jaGVja2VkID0gISF2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoZWwudGFnTmFtZSA9PT0gXCJTRUxFQ1RcIikge1xuICAgIHVwZGF0ZVNlbGVjdChlbCwgdmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIGlmIChlbC52YWx1ZSA9PT0gdmFsdWUpXG4gICAgICByZXR1cm47XG4gICAgZWwudmFsdWUgPSB2YWx1ZTtcbiAgfVxufVxuZnVuY3Rpb24gYmluZENsYXNzZXMoZWwsIHZhbHVlKSB7XG4gIGlmIChlbC5feF91bmRvQWRkZWRDbGFzc2VzKVxuICAgIGVsLl94X3VuZG9BZGRlZENsYXNzZXMoKTtcbiAgZWwuX3hfdW5kb0FkZGVkQ2xhc3NlcyA9IHNldENsYXNzZXMoZWwsIHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGJpbmRTdHlsZXMoZWwsIHZhbHVlKSB7XG4gIGlmIChlbC5feF91bmRvQWRkZWRTdHlsZXMpXG4gICAgZWwuX3hfdW5kb0FkZGVkU3R5bGVzKCk7XG4gIGVsLl94X3VuZG9BZGRlZFN0eWxlcyA9IHNldFN0eWxlcyhlbCwgdmFsdWUpO1xufVxuZnVuY3Rpb24gYmluZEF0dHJpYnV0ZShlbCwgbmFtZSwgdmFsdWUpIHtcbiAgaWYgKFtudWxsLCB2b2lkIDAsIGZhbHNlXS5pbmNsdWRlcyh2YWx1ZSkgJiYgYXR0cmlidXRlU2hvdWxkbnRCZVByZXNlcnZlZElmRmFsc3kobmFtZSkpIHtcbiAgICBlbC5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKGlzQm9vbGVhbkF0dHIobmFtZSkpXG4gICAgICB2YWx1ZSA9IG5hbWU7XG4gICAgc2V0SWZDaGFuZ2VkKGVsLCBuYW1lLCB2YWx1ZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHNldElmQ2hhbmdlZChlbCwgYXR0ck5hbWUsIHZhbHVlKSB7XG4gIGlmIChlbC5nZXRBdHRyaWJ1dGUoYXR0ck5hbWUpICE9IHZhbHVlKSB7XG4gICAgZWwuc2V0QXR0cmlidXRlKGF0dHJOYW1lLCB2YWx1ZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHVwZGF0ZVNlbGVjdChlbCwgdmFsdWUpIHtcbiAgY29uc3QgYXJyYXlXcmFwcGVkVmFsdWUgPSBbXS5jb25jYXQodmFsdWUpLm1hcCgodmFsdWUyKSA9PiB7XG4gICAgcmV0dXJuIHZhbHVlMiArIFwiXCI7XG4gIH0pO1xuICBBcnJheS5mcm9tKGVsLm9wdGlvbnMpLmZvckVhY2goKG9wdGlvbikgPT4ge1xuICAgIG9wdGlvbi5zZWxlY3RlZCA9IGFycmF5V3JhcHBlZFZhbHVlLmluY2x1ZGVzKG9wdGlvbi52YWx1ZSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gY2FtZWxDYXNlKHN1YmplY3QpIHtcbiAgcmV0dXJuIHN1YmplY3QudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC8tKFxcdykvZywgKG1hdGNoLCBjaGFyKSA9PiBjaGFyLnRvVXBwZXJDYXNlKCkpO1xufVxuZnVuY3Rpb24gY2hlY2tlZEF0dHJMb29zZUNvbXBhcmUodmFsdWVBLCB2YWx1ZUIpIHtcbiAgcmV0dXJuIHZhbHVlQSA9PSB2YWx1ZUI7XG59XG5mdW5jdGlvbiBpc0Jvb2xlYW5BdHRyKGF0dHJOYW1lKSB7XG4gIGNvbnN0IGJvb2xlYW5BdHRyaWJ1dGVzID0gW1xuICAgIFwiZGlzYWJsZWRcIixcbiAgICBcImNoZWNrZWRcIixcbiAgICBcInJlcXVpcmVkXCIsXG4gICAgXCJyZWFkb25seVwiLFxuICAgIFwiaGlkZGVuXCIsXG4gICAgXCJvcGVuXCIsXG4gICAgXCJzZWxlY3RlZFwiLFxuICAgIFwiYXV0b2ZvY3VzXCIsXG4gICAgXCJpdGVtc2NvcGVcIixcbiAgICBcIm11bHRpcGxlXCIsXG4gICAgXCJub3ZhbGlkYXRlXCIsXG4gICAgXCJhbGxvd2Z1bGxzY3JlZW5cIixcbiAgICBcImFsbG93cGF5bWVudHJlcXVlc3RcIixcbiAgICBcImZvcm1ub3ZhbGlkYXRlXCIsXG4gICAgXCJhdXRvcGxheVwiLFxuICAgIFwiY29udHJvbHNcIixcbiAgICBcImxvb3BcIixcbiAgICBcIm11dGVkXCIsXG4gICAgXCJwbGF5c2lubGluZVwiLFxuICAgIFwiZGVmYXVsdFwiLFxuICAgIFwiaXNtYXBcIixcbiAgICBcInJldmVyc2VkXCIsXG4gICAgXCJhc3luY1wiLFxuICAgIFwiZGVmZXJcIixcbiAgICBcIm5vbW9kdWxlXCJcbiAgXTtcbiAgcmV0dXJuIGJvb2xlYW5BdHRyaWJ1dGVzLmluY2x1ZGVzKGF0dHJOYW1lKTtcbn1cbmZ1bmN0aW9uIGF0dHJpYnV0ZVNob3VsZG50QmVQcmVzZXJ2ZWRJZkZhbHN5KG5hbWUpIHtcbiAgcmV0dXJuICFbXCJhcmlhLXByZXNzZWRcIiwgXCJhcmlhLWNoZWNrZWRcIiwgXCJhcmlhLWV4cGFuZGVkXCIsIFwiYXJpYS1zZWxlY3RlZFwiXS5pbmNsdWRlcyhuYW1lKTtcbn1cbmZ1bmN0aW9uIGdldEJpbmRpbmcoZWwsIG5hbWUsIGZhbGxiYWNrKSB7XG4gIGlmIChlbC5feF9iaW5kaW5ncyAmJiBlbC5feF9iaW5kaW5nc1tuYW1lXSAhPT0gdm9pZCAwKVxuICAgIHJldHVybiBlbC5feF9iaW5kaW5nc1tuYW1lXTtcbiAgbGV0IGF0dHIgPSBlbC5nZXRBdHRyaWJ1dGUobmFtZSk7XG4gIGlmIChhdHRyID09PSBudWxsKVxuICAgIHJldHVybiB0eXBlb2YgZmFsbGJhY2sgPT09IFwiZnVuY3Rpb25cIiA/IGZhbGxiYWNrKCkgOiBmYWxsYmFjaztcbiAgaWYgKGlzQm9vbGVhbkF0dHIobmFtZSkpIHtcbiAgICByZXR1cm4gISFbbmFtZSwgXCJ0cnVlXCJdLmluY2x1ZGVzKGF0dHIpO1xuICB9XG4gIGlmIChhdHRyID09PSBcIlwiKVxuICAgIHJldHVybiB0cnVlO1xuICByZXR1cm4gYXR0cjtcbn1cblxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL3V0aWxzL2RlYm91bmNlLmpzXG5mdW5jdGlvbiBkZWJvdW5jZShmdW5jLCB3YWl0KSB7XG4gIHZhciB0aW1lb3V0O1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGNvbnRleHQgPSB0aGlzLCBhcmdzID0gYXJndW1lbnRzO1xuICAgIHZhciBsYXRlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgIH07XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCB3YWl0KTtcbiAgfTtcbn1cblxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL3V0aWxzL3Rocm90dGxlLmpzXG5mdW5jdGlvbiB0aHJvdHRsZShmdW5jLCBsaW1pdCkge1xuICBsZXQgaW5UaHJvdHRsZTtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIGxldCBjb250ZXh0ID0gdGhpcywgYXJncyA9IGFyZ3VtZW50cztcbiAgICBpZiAoIWluVGhyb3R0bGUpIHtcbiAgICAgIGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICBpblRocm90dGxlID0gdHJ1ZTtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4gaW5UaHJvdHRsZSA9IGZhbHNlLCBsaW1pdCk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvcGx1Z2luLmpzXG5mdW5jdGlvbiBwbHVnaW4oY2FsbGJhY2spIHtcbiAgY2FsbGJhY2soYWxwaW5lX2RlZmF1bHQpO1xufVxuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvc3RvcmUuanNcbnZhciBzdG9yZXMgPSB7fTtcbnZhciBpc1JlYWN0aXZlID0gZmFsc2U7XG5mdW5jdGlvbiBzdG9yZShuYW1lLCB2YWx1ZSkge1xuICBpZiAoIWlzUmVhY3RpdmUpIHtcbiAgICBzdG9yZXMgPSByZWFjdGl2ZShzdG9yZXMpO1xuICAgIGlzUmVhY3RpdmUgPSB0cnVlO1xuICB9XG4gIGlmICh2YWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIHN0b3Jlc1tuYW1lXTtcbiAgfVxuICBzdG9yZXNbbmFtZV0gPSB2YWx1ZTtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiB2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZS5oYXNPd25Qcm9wZXJ0eShcImluaXRcIikgJiYgdHlwZW9mIHZhbHVlLmluaXQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHN0b3Jlc1tuYW1lXS5pbml0KCk7XG4gIH1cbiAgaW5pdEludGVyY2VwdG9ycyhzdG9yZXNbbmFtZV0pO1xufVxuZnVuY3Rpb24gZ2V0U3RvcmVzKCkge1xuICByZXR1cm4gc3RvcmVzO1xufVxuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvYmluZHMuanNcbnZhciBiaW5kcyA9IHt9O1xuZnVuY3Rpb24gYmluZDIobmFtZSwgb2JqZWN0KSB7XG4gIGJpbmRzW25hbWVdID0gdHlwZW9mIG9iamVjdCAhPT0gXCJmdW5jdGlvblwiID8gKCkgPT4gb2JqZWN0IDogb2JqZWN0O1xufVxuZnVuY3Rpb24gaW5qZWN0QmluZGluZ1Byb3ZpZGVycyhvYmopIHtcbiAgT2JqZWN0LmVudHJpZXMoYmluZHMpLmZvckVhY2goKFtuYW1lLCBjYWxsYmFja10pID0+IHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBuYW1lLCB7XG4gICAgICBnZXQoKSB7XG4gICAgICAgIHJldHVybiAoLi4uYXJncykgPT4ge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayguLi5hcmdzKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiBvYmo7XG59XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy9kYXRhcy5qc1xudmFyIGRhdGFzID0ge307XG5mdW5jdGlvbiBkYXRhKG5hbWUsIGNhbGxiYWNrKSB7XG4gIGRhdGFzW25hbWVdID0gY2FsbGJhY2s7XG59XG5mdW5jdGlvbiBpbmplY3REYXRhUHJvdmlkZXJzKG9iaiwgY29udGV4dCkge1xuICBPYmplY3QuZW50cmllcyhkYXRhcykuZm9yRWFjaCgoW25hbWUsIGNhbGxiYWNrXSkgPT4ge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIG5hbWUsIHtcbiAgICAgIGdldCgpIHtcbiAgICAgICAgcmV0dXJuICguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmJpbmQoY29udGV4dCkoLi4uYXJncyk7XG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiBvYmo7XG59XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy9hbHBpbmUuanNcbnZhciBBbHBpbmUgPSB7XG4gIGdldCByZWFjdGl2ZSgpIHtcbiAgICByZXR1cm4gcmVhY3RpdmU7XG4gIH0sXG4gIGdldCByZWxlYXNlKCkge1xuICAgIHJldHVybiByZWxlYXNlO1xuICB9LFxuICBnZXQgZWZmZWN0KCkge1xuICAgIHJldHVybiBlZmZlY3Q7XG4gIH0sXG4gIGdldCByYXcoKSB7XG4gICAgcmV0dXJuIHJhdztcbiAgfSxcbiAgdmVyc2lvbjogXCIzLjEwLjBcIixcbiAgZmx1c2hBbmRTdG9wRGVmZXJyaW5nTXV0YXRpb25zLFxuICBkb250QXV0b0V2YWx1YXRlRnVuY3Rpb25zLFxuICBkaXNhYmxlRWZmZWN0U2NoZWR1bGluZyxcbiAgc2V0UmVhY3Rpdml0eUVuZ2luZSxcbiAgY2xvc2VzdERhdGFTdGFjayxcbiAgc2tpcER1cmluZ0Nsb25lLFxuICBhZGRSb290U2VsZWN0b3IsXG4gIGFkZEluaXRTZWxlY3RvcixcbiAgYWRkU2NvcGVUb05vZGUsXG4gIGRlZmVyTXV0YXRpb25zLFxuICBtYXBBdHRyaWJ1dGVzLFxuICBldmFsdWF0ZUxhdGVyLFxuICBzZXRFdmFsdWF0b3IsXG4gIG1lcmdlUHJveGllcyxcbiAgZmluZENsb3Nlc3QsXG4gIGNsb3Nlc3RSb290LFxuICBpbnRlcmNlcHRvcixcbiAgdHJhbnNpdGlvbixcbiAgc2V0U3R5bGVzLFxuICBtdXRhdGVEb20sXG4gIGRpcmVjdGl2ZSxcbiAgdGhyb3R0bGUsXG4gIGRlYm91bmNlLFxuICBldmFsdWF0ZSxcbiAgaW5pdFRyZWUsXG4gIG5leHRUaWNrLFxuICBwcmVmaXhlZDogcHJlZml4LFxuICBwcmVmaXg6IHNldFByZWZpeCxcbiAgcGx1Z2luLFxuICBtYWdpYyxcbiAgc3RvcmUsXG4gIHN0YXJ0LFxuICBjbG9uZSxcbiAgYm91bmQ6IGdldEJpbmRpbmcsXG4gICRkYXRhOiBzY29wZSxcbiAgZGF0YSxcbiAgYmluZDogYmluZDJcbn07XG52YXIgYWxwaW5lX2RlZmF1bHQgPSBBbHBpbmU7XG5cbi8vIG5vZGVfbW9kdWxlcy9AdnVlL3NoYXJlZC9kaXN0L3NoYXJlZC5lc20tYnVuZGxlci5qc1xuZnVuY3Rpb24gbWFrZU1hcChzdHIsIGV4cGVjdHNMb3dlckNhc2UpIHtcbiAgY29uc3QgbWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgY29uc3QgbGlzdCA9IHN0ci5zcGxpdChcIixcIik7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIG1hcFtsaXN0W2ldXSA9IHRydWU7XG4gIH1cbiAgcmV0dXJuIGV4cGVjdHNMb3dlckNhc2UgPyAodmFsKSA9PiAhIW1hcFt2YWwudG9Mb3dlckNhc2UoKV0gOiAodmFsKSA9PiAhIW1hcFt2YWxdO1xufVxudmFyIFBhdGNoRmxhZ05hbWVzID0ge1xuICBbMV06IGBURVhUYCxcbiAgWzJdOiBgQ0xBU1NgLFxuICBbNF06IGBTVFlMRWAsXG4gIFs4XTogYFBST1BTYCxcbiAgWzE2XTogYEZVTExfUFJPUFNgLFxuICBbMzJdOiBgSFlEUkFURV9FVkVOVFNgLFxuICBbNjRdOiBgU1RBQkxFX0ZSQUdNRU5UYCxcbiAgWzEyOF06IGBLRVlFRF9GUkFHTUVOVGAsXG4gIFsyNTZdOiBgVU5LRVlFRF9GUkFHTUVOVGAsXG4gIFs1MTJdOiBgTkVFRF9QQVRDSGAsXG4gIFsxMDI0XTogYERZTkFNSUNfU0xPVFNgLFxuICBbMjA0OF06IGBERVZfUk9PVF9GUkFHTUVOVGAsXG4gIFstMV06IGBIT0lTVEVEYCxcbiAgWy0yXTogYEJBSUxgXG59O1xudmFyIHNsb3RGbGFnc1RleHQgPSB7XG4gIFsxXTogXCJTVEFCTEVcIixcbiAgWzJdOiBcIkRZTkFNSUNcIixcbiAgWzNdOiBcIkZPUldBUkRFRFwiXG59O1xudmFyIHNwZWNpYWxCb29sZWFuQXR0cnMgPSBgaXRlbXNjb3BlLGFsbG93ZnVsbHNjcmVlbixmb3Jtbm92YWxpZGF0ZSxpc21hcCxub21vZHVsZSxub3ZhbGlkYXRlLHJlYWRvbmx5YDtcbnZhciBpc0Jvb2xlYW5BdHRyMiA9IC8qIEBfX1BVUkVfXyAqLyBtYWtlTWFwKHNwZWNpYWxCb29sZWFuQXR0cnMgKyBgLGFzeW5jLGF1dG9mb2N1cyxhdXRvcGxheSxjb250cm9scyxkZWZhdWx0LGRlZmVyLGRpc2FibGVkLGhpZGRlbixsb29wLG9wZW4scmVxdWlyZWQscmV2ZXJzZWQsc2NvcGVkLHNlYW1sZXNzLGNoZWNrZWQsbXV0ZWQsbXVsdGlwbGUsc2VsZWN0ZWRgKTtcbnZhciBFTVBUWV9PQkogPSBmYWxzZSA/IE9iamVjdC5mcmVlemUoe30pIDoge307XG52YXIgRU1QVFlfQVJSID0gZmFsc2UgPyBPYmplY3QuZnJlZXplKFtdKSA6IFtdO1xudmFyIGV4dGVuZCA9IE9iamVjdC5hc3NpZ247XG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIGhhc093biA9ICh2YWwsIGtleSkgPT4gaGFzT3duUHJvcGVydHkuY2FsbCh2YWwsIGtleSk7XG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG52YXIgaXNNYXAgPSAodmFsKSA9PiB0b1R5cGVTdHJpbmcodmFsKSA9PT0gXCJbb2JqZWN0IE1hcF1cIjtcbnZhciBpc1N0cmluZyA9ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09IFwic3RyaW5nXCI7XG52YXIgaXNTeW1ib2wgPSAodmFsKSA9PiB0eXBlb2YgdmFsID09PSBcInN5bWJvbFwiO1xudmFyIGlzT2JqZWN0ID0gKHZhbCkgPT4gdmFsICE9PSBudWxsICYmIHR5cGVvZiB2YWwgPT09IFwib2JqZWN0XCI7XG52YXIgb2JqZWN0VG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIHRvVHlwZVN0cmluZyA9ICh2YWx1ZSkgPT4gb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG52YXIgdG9SYXdUeXBlID0gKHZhbHVlKSA9PiB7XG4gIHJldHVybiB0b1R5cGVTdHJpbmcodmFsdWUpLnNsaWNlKDgsIC0xKTtcbn07XG52YXIgaXNJbnRlZ2VyS2V5ID0gKGtleSkgPT4gaXNTdHJpbmcoa2V5KSAmJiBrZXkgIT09IFwiTmFOXCIgJiYga2V5WzBdICE9PSBcIi1cIiAmJiBcIlwiICsgcGFyc2VJbnQoa2V5LCAxMCkgPT09IGtleTtcbnZhciBjYWNoZVN0cmluZ0Z1bmN0aW9uID0gKGZuKSA9PiB7XG4gIGNvbnN0IGNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgcmV0dXJuIChzdHIpID0+IHtcbiAgICBjb25zdCBoaXQgPSBjYWNoZVtzdHJdO1xuICAgIHJldHVybiBoaXQgfHwgKGNhY2hlW3N0cl0gPSBmbihzdHIpKTtcbiAgfTtcbn07XG52YXIgY2FtZWxpemVSRSA9IC8tKFxcdykvZztcbnZhciBjYW1lbGl6ZSA9IGNhY2hlU3RyaW5nRnVuY3Rpb24oKHN0cikgPT4ge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoY2FtZWxpemVSRSwgKF8sIGMpID0+IGMgPyBjLnRvVXBwZXJDYXNlKCkgOiBcIlwiKTtcbn0pO1xudmFyIGh5cGhlbmF0ZVJFID0gL1xcQihbQS1aXSkvZztcbnZhciBoeXBoZW5hdGUgPSBjYWNoZVN0cmluZ0Z1bmN0aW9uKChzdHIpID0+IHN0ci5yZXBsYWNlKGh5cGhlbmF0ZVJFLCBcIi0kMVwiKS50b0xvd2VyQ2FzZSgpKTtcbnZhciBjYXBpdGFsaXplID0gY2FjaGVTdHJpbmdGdW5jdGlvbigoc3RyKSA9PiBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSkpO1xudmFyIHRvSGFuZGxlcktleSA9IGNhY2hlU3RyaW5nRnVuY3Rpb24oKHN0cikgPT4gc3RyID8gYG9uJHtjYXBpdGFsaXplKHN0cil9YCA6IGBgKTtcbnZhciBoYXNDaGFuZ2VkID0gKHZhbHVlLCBvbGRWYWx1ZSkgPT4gdmFsdWUgIT09IG9sZFZhbHVlICYmICh2YWx1ZSA9PT0gdmFsdWUgfHwgb2xkVmFsdWUgPT09IG9sZFZhbHVlKTtcblxuLy8gbm9kZV9tb2R1bGVzL0B2dWUvcmVhY3Rpdml0eS9kaXN0L3JlYWN0aXZpdHkuZXNtLWJ1bmRsZXIuanNcbnZhciB0YXJnZXRNYXAgPSBuZXcgV2Vha01hcCgpO1xudmFyIGVmZmVjdFN0YWNrID0gW107XG52YXIgYWN0aXZlRWZmZWN0O1xudmFyIElURVJBVEVfS0VZID0gU3ltYm9sKGZhbHNlID8gXCJpdGVyYXRlXCIgOiBcIlwiKTtcbnZhciBNQVBfS0VZX0lURVJBVEVfS0VZID0gU3ltYm9sKGZhbHNlID8gXCJNYXAga2V5IGl0ZXJhdGVcIiA6IFwiXCIpO1xuZnVuY3Rpb24gaXNFZmZlY3QoZm4pIHtcbiAgcmV0dXJuIGZuICYmIGZuLl9pc0VmZmVjdCA9PT0gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGVmZmVjdDIoZm4sIG9wdGlvbnMgPSBFTVBUWV9PQkopIHtcbiAgaWYgKGlzRWZmZWN0KGZuKSkge1xuICAgIGZuID0gZm4ucmF3O1xuICB9XG4gIGNvbnN0IGVmZmVjdDMgPSBjcmVhdGVSZWFjdGl2ZUVmZmVjdChmbiwgb3B0aW9ucyk7XG4gIGlmICghb3B0aW9ucy5sYXp5KSB7XG4gICAgZWZmZWN0MygpO1xuICB9XG4gIHJldHVybiBlZmZlY3QzO1xufVxuZnVuY3Rpb24gc3RvcChlZmZlY3QzKSB7XG4gIGlmIChlZmZlY3QzLmFjdGl2ZSkge1xuICAgIGNsZWFudXAoZWZmZWN0Myk7XG4gICAgaWYgKGVmZmVjdDMub3B0aW9ucy5vblN0b3ApIHtcbiAgICAgIGVmZmVjdDMub3B0aW9ucy5vblN0b3AoKTtcbiAgICB9XG4gICAgZWZmZWN0My5hY3RpdmUgPSBmYWxzZTtcbiAgfVxufVxudmFyIHVpZCA9IDA7XG5mdW5jdGlvbiBjcmVhdGVSZWFjdGl2ZUVmZmVjdChmbiwgb3B0aW9ucykge1xuICBjb25zdCBlZmZlY3QzID0gZnVuY3Rpb24gcmVhY3RpdmVFZmZlY3QoKSB7XG4gICAgaWYgKCFlZmZlY3QzLmFjdGl2ZSkge1xuICAgICAgcmV0dXJuIGZuKCk7XG4gICAgfVxuICAgIGlmICghZWZmZWN0U3RhY2suaW5jbHVkZXMoZWZmZWN0MykpIHtcbiAgICAgIGNsZWFudXAoZWZmZWN0Myk7XG4gICAgICB0cnkge1xuICAgICAgICBlbmFibGVUcmFja2luZygpO1xuICAgICAgICBlZmZlY3RTdGFjay5wdXNoKGVmZmVjdDMpO1xuICAgICAgICBhY3RpdmVFZmZlY3QgPSBlZmZlY3QzO1xuICAgICAgICByZXR1cm4gZm4oKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGVmZmVjdFN0YWNrLnBvcCgpO1xuICAgICAgICByZXNldFRyYWNraW5nKCk7XG4gICAgICAgIGFjdGl2ZUVmZmVjdCA9IGVmZmVjdFN0YWNrW2VmZmVjdFN0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgZWZmZWN0My5pZCA9IHVpZCsrO1xuICBlZmZlY3QzLmFsbG93UmVjdXJzZSA9ICEhb3B0aW9ucy5hbGxvd1JlY3Vyc2U7XG4gIGVmZmVjdDMuX2lzRWZmZWN0ID0gdHJ1ZTtcbiAgZWZmZWN0My5hY3RpdmUgPSB0cnVlO1xuICBlZmZlY3QzLnJhdyA9IGZuO1xuICBlZmZlY3QzLmRlcHMgPSBbXTtcbiAgZWZmZWN0My5vcHRpb25zID0gb3B0aW9ucztcbiAgcmV0dXJuIGVmZmVjdDM7XG59XG5mdW5jdGlvbiBjbGVhbnVwKGVmZmVjdDMpIHtcbiAgY29uc3Qge2RlcHN9ID0gZWZmZWN0MztcbiAgaWYgKGRlcHMubGVuZ3RoKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBkZXBzW2ldLmRlbGV0ZShlZmZlY3QzKTtcbiAgICB9XG4gICAgZGVwcy5sZW5ndGggPSAwO1xuICB9XG59XG52YXIgc2hvdWxkVHJhY2sgPSB0cnVlO1xudmFyIHRyYWNrU3RhY2sgPSBbXTtcbmZ1bmN0aW9uIHBhdXNlVHJhY2tpbmcoKSB7XG4gIHRyYWNrU3RhY2sucHVzaChzaG91bGRUcmFjayk7XG4gIHNob3VsZFRyYWNrID0gZmFsc2U7XG59XG5mdW5jdGlvbiBlbmFibGVUcmFja2luZygpIHtcbiAgdHJhY2tTdGFjay5wdXNoKHNob3VsZFRyYWNrKTtcbiAgc2hvdWxkVHJhY2sgPSB0cnVlO1xufVxuZnVuY3Rpb24gcmVzZXRUcmFja2luZygpIHtcbiAgY29uc3QgbGFzdCA9IHRyYWNrU3RhY2sucG9wKCk7XG4gIHNob3VsZFRyYWNrID0gbGFzdCA9PT0gdm9pZCAwID8gdHJ1ZSA6IGxhc3Q7XG59XG5mdW5jdGlvbiB0cmFjayh0YXJnZXQsIHR5cGUsIGtleSkge1xuICBpZiAoIXNob3VsZFRyYWNrIHx8IGFjdGl2ZUVmZmVjdCA9PT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGxldCBkZXBzTWFwID0gdGFyZ2V0TWFwLmdldCh0YXJnZXQpO1xuICBpZiAoIWRlcHNNYXApIHtcbiAgICB0YXJnZXRNYXAuc2V0KHRhcmdldCwgZGVwc01hcCA9IG5ldyBNYXAoKSk7XG4gIH1cbiAgbGV0IGRlcCA9IGRlcHNNYXAuZ2V0KGtleSk7XG4gIGlmICghZGVwKSB7XG4gICAgZGVwc01hcC5zZXQoa2V5LCBkZXAgPSBuZXcgU2V0KCkpO1xuICB9XG4gIGlmICghZGVwLmhhcyhhY3RpdmVFZmZlY3QpKSB7XG4gICAgZGVwLmFkZChhY3RpdmVFZmZlY3QpO1xuICAgIGFjdGl2ZUVmZmVjdC5kZXBzLnB1c2goZGVwKTtcbiAgICBpZiAoZmFsc2UpIHtcbiAgICAgIGFjdGl2ZUVmZmVjdC5vcHRpb25zLm9uVHJhY2soe1xuICAgICAgICBlZmZlY3Q6IGFjdGl2ZUVmZmVjdCxcbiAgICAgICAgdGFyZ2V0LFxuICAgICAgICB0eXBlLFxuICAgICAgICBrZXlcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gdHJpZ2dlcih0YXJnZXQsIHR5cGUsIGtleSwgbmV3VmFsdWUsIG9sZFZhbHVlLCBvbGRUYXJnZXQpIHtcbiAgY29uc3QgZGVwc01hcCA9IHRhcmdldE1hcC5nZXQodGFyZ2V0KTtcbiAgaWYgKCFkZXBzTWFwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGVmZmVjdHMgPSBuZXcgU2V0KCk7XG4gIGNvbnN0IGFkZDIgPSAoZWZmZWN0c1RvQWRkKSA9PiB7XG4gICAgaWYgKGVmZmVjdHNUb0FkZCkge1xuICAgICAgZWZmZWN0c1RvQWRkLmZvckVhY2goKGVmZmVjdDMpID0+IHtcbiAgICAgICAgaWYgKGVmZmVjdDMgIT09IGFjdGl2ZUVmZmVjdCB8fCBlZmZlY3QzLmFsbG93UmVjdXJzZSkge1xuICAgICAgICAgIGVmZmVjdHMuYWRkKGVmZmVjdDMpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG4gIGlmICh0eXBlID09PSBcImNsZWFyXCIpIHtcbiAgICBkZXBzTWFwLmZvckVhY2goYWRkMik7XG4gIH0gZWxzZSBpZiAoa2V5ID09PSBcImxlbmd0aFwiICYmIGlzQXJyYXkodGFyZ2V0KSkge1xuICAgIGRlcHNNYXAuZm9yRWFjaCgoZGVwLCBrZXkyKSA9PiB7XG4gICAgICBpZiAoa2V5MiA9PT0gXCJsZW5ndGhcIiB8fCBrZXkyID49IG5ld1ZhbHVlKSB7XG4gICAgICAgIGFkZDIoZGVwKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoa2V5ICE9PSB2b2lkIDApIHtcbiAgICAgIGFkZDIoZGVwc01hcC5nZXQoa2V5KSk7XG4gICAgfVxuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBcImFkZFwiOlxuICAgICAgICBpZiAoIWlzQXJyYXkodGFyZ2V0KSkge1xuICAgICAgICAgIGFkZDIoZGVwc01hcC5nZXQoSVRFUkFURV9LRVkpKTtcbiAgICAgICAgICBpZiAoaXNNYXAodGFyZ2V0KSkge1xuICAgICAgICAgICAgYWRkMihkZXBzTWFwLmdldChNQVBfS0VZX0lURVJBVEVfS0VZKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGlzSW50ZWdlcktleShrZXkpKSB7XG4gICAgICAgICAgYWRkMihkZXBzTWFwLmdldChcImxlbmd0aFwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiZGVsZXRlXCI6XG4gICAgICAgIGlmICghaXNBcnJheSh0YXJnZXQpKSB7XG4gICAgICAgICAgYWRkMihkZXBzTWFwLmdldChJVEVSQVRFX0tFWSkpO1xuICAgICAgICAgIGlmIChpc01hcCh0YXJnZXQpKSB7XG4gICAgICAgICAgICBhZGQyKGRlcHNNYXAuZ2V0KE1BUF9LRVlfSVRFUkFURV9LRVkpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwic2V0XCI6XG4gICAgICAgIGlmIChpc01hcCh0YXJnZXQpKSB7XG4gICAgICAgICAgYWRkMihkZXBzTWFwLmdldChJVEVSQVRFX0tFWSkpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBjb25zdCBydW4gPSAoZWZmZWN0MykgPT4ge1xuICAgIGlmIChmYWxzZSkge1xuICAgICAgZWZmZWN0My5vcHRpb25zLm9uVHJpZ2dlcih7XG4gICAgICAgIGVmZmVjdDogZWZmZWN0MyxcbiAgICAgICAgdGFyZ2V0LFxuICAgICAgICBrZXksXG4gICAgICAgIHR5cGUsXG4gICAgICAgIG5ld1ZhbHVlLFxuICAgICAgICBvbGRWYWx1ZSxcbiAgICAgICAgb2xkVGFyZ2V0XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGVmZmVjdDMub3B0aW9ucy5zY2hlZHVsZXIpIHtcbiAgICAgIGVmZmVjdDMub3B0aW9ucy5zY2hlZHVsZXIoZWZmZWN0Myk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVmZmVjdDMoKTtcbiAgICB9XG4gIH07XG4gIGVmZmVjdHMuZm9yRWFjaChydW4pO1xufVxudmFyIGlzTm9uVHJhY2thYmxlS2V5cyA9IC8qIEBfX1BVUkVfXyAqLyBtYWtlTWFwKGBfX3Byb3RvX18sX192X2lzUmVmLF9faXNWdWVgKTtcbnZhciBidWlsdEluU3ltYm9scyA9IG5ldyBTZXQoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoU3ltYm9sKS5tYXAoKGtleSkgPT4gU3ltYm9sW2tleV0pLmZpbHRlcihpc1N5bWJvbCkpO1xudmFyIGdldDIgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlR2V0dGVyKCk7XG52YXIgc2hhbGxvd0dldCA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVHZXR0ZXIoZmFsc2UsIHRydWUpO1xudmFyIHJlYWRvbmx5R2V0ID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZUdldHRlcih0cnVlKTtcbnZhciBzaGFsbG93UmVhZG9ubHlHZXQgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlR2V0dGVyKHRydWUsIHRydWUpO1xudmFyIGFycmF5SW5zdHJ1bWVudGF0aW9ucyA9IHt9O1xuW1wiaW5jbHVkZXNcIiwgXCJpbmRleE9mXCIsIFwibGFzdEluZGV4T2ZcIl0uZm9yRWFjaCgoa2V5KSA9PiB7XG4gIGNvbnN0IG1ldGhvZCA9IEFycmF5LnByb3RvdHlwZVtrZXldO1xuICBhcnJheUluc3RydW1lbnRhdGlvbnNba2V5XSA9IGZ1bmN0aW9uKC4uLmFyZ3MpIHtcbiAgICBjb25zdCBhcnIgPSB0b1Jhdyh0aGlzKTtcbiAgICBmb3IgKGxldCBpID0gMCwgbCA9IHRoaXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB0cmFjayhhcnIsIFwiZ2V0XCIsIGkgKyBcIlwiKTtcbiAgICB9XG4gICAgY29uc3QgcmVzID0gbWV0aG9kLmFwcGx5KGFyciwgYXJncyk7XG4gICAgaWYgKHJlcyA9PT0gLTEgfHwgcmVzID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIG1ldGhvZC5hcHBseShhcnIsIGFyZ3MubWFwKHRvUmF3KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICB9O1xufSk7XG5bXCJwdXNoXCIsIFwicG9wXCIsIFwic2hpZnRcIiwgXCJ1bnNoaWZ0XCIsIFwic3BsaWNlXCJdLmZvckVhY2goKGtleSkgPT4ge1xuICBjb25zdCBtZXRob2QgPSBBcnJheS5wcm90b3R5cGVba2V5XTtcbiAgYXJyYXlJbnN0cnVtZW50YXRpb25zW2tleV0gPSBmdW5jdGlvbiguLi5hcmdzKSB7XG4gICAgcGF1c2VUcmFja2luZygpO1xuICAgIGNvbnN0IHJlcyA9IG1ldGhvZC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICByZXNldFRyYWNraW5nKCk7XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcbn0pO1xuZnVuY3Rpb24gY3JlYXRlR2V0dGVyKGlzUmVhZG9ubHkgPSBmYWxzZSwgc2hhbGxvdyA9IGZhbHNlKSB7XG4gIHJldHVybiBmdW5jdGlvbiBnZXQzKHRhcmdldCwga2V5LCByZWNlaXZlcikge1xuICAgIGlmIChrZXkgPT09IFwiX192X2lzUmVhY3RpdmVcIikge1xuICAgICAgcmV0dXJuICFpc1JlYWRvbmx5O1xuICAgIH0gZWxzZSBpZiAoa2V5ID09PSBcIl9fdl9pc1JlYWRvbmx5XCIpIHtcbiAgICAgIHJldHVybiBpc1JlYWRvbmx5O1xuICAgIH0gZWxzZSBpZiAoa2V5ID09PSBcIl9fdl9yYXdcIiAmJiByZWNlaXZlciA9PT0gKGlzUmVhZG9ubHkgPyBzaGFsbG93ID8gc2hhbGxvd1JlYWRvbmx5TWFwIDogcmVhZG9ubHlNYXAgOiBzaGFsbG93ID8gc2hhbGxvd1JlYWN0aXZlTWFwIDogcmVhY3RpdmVNYXApLmdldCh0YXJnZXQpKSB7XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbiAgICBjb25zdCB0YXJnZXRJc0FycmF5ID0gaXNBcnJheSh0YXJnZXQpO1xuICAgIGlmICghaXNSZWFkb25seSAmJiB0YXJnZXRJc0FycmF5ICYmIGhhc093bihhcnJheUluc3RydW1lbnRhdGlvbnMsIGtleSkpIHtcbiAgICAgIHJldHVybiBSZWZsZWN0LmdldChhcnJheUluc3RydW1lbnRhdGlvbnMsIGtleSwgcmVjZWl2ZXIpO1xuICAgIH1cbiAgICBjb25zdCByZXMgPSBSZWZsZWN0LmdldCh0YXJnZXQsIGtleSwgcmVjZWl2ZXIpO1xuICAgIGlmIChpc1N5bWJvbChrZXkpID8gYnVpbHRJblN5bWJvbHMuaGFzKGtleSkgOiBpc05vblRyYWNrYWJsZUtleXMoa2V5KSkge1xuICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgaWYgKCFpc1JlYWRvbmx5KSB7XG4gICAgICB0cmFjayh0YXJnZXQsIFwiZ2V0XCIsIGtleSk7XG4gICAgfVxuICAgIGlmIChzaGFsbG93KSB7XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICBpZiAoaXNSZWYocmVzKSkge1xuICAgICAgY29uc3Qgc2hvdWxkVW53cmFwID0gIXRhcmdldElzQXJyYXkgfHwgIWlzSW50ZWdlcktleShrZXkpO1xuICAgICAgcmV0dXJuIHNob3VsZFVud3JhcCA/IHJlcy52YWx1ZSA6IHJlcztcbiAgICB9XG4gICAgaWYgKGlzT2JqZWN0KHJlcykpIHtcbiAgICAgIHJldHVybiBpc1JlYWRvbmx5ID8gcmVhZG9ubHkocmVzKSA6IHJlYWN0aXZlMihyZXMpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9O1xufVxudmFyIHNldDIgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlU2V0dGVyKCk7XG52YXIgc2hhbGxvd1NldCA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVTZXR0ZXIodHJ1ZSk7XG5mdW5jdGlvbiBjcmVhdGVTZXR0ZXIoc2hhbGxvdyA9IGZhbHNlKSB7XG4gIHJldHVybiBmdW5jdGlvbiBzZXQzKHRhcmdldCwga2V5LCB2YWx1ZSwgcmVjZWl2ZXIpIHtcbiAgICBsZXQgb2xkVmFsdWUgPSB0YXJnZXRba2V5XTtcbiAgICBpZiAoIXNoYWxsb3cpIHtcbiAgICAgIHZhbHVlID0gdG9SYXcodmFsdWUpO1xuICAgICAgb2xkVmFsdWUgPSB0b1JhdyhvbGRWYWx1ZSk7XG4gICAgICBpZiAoIWlzQXJyYXkodGFyZ2V0KSAmJiBpc1JlZihvbGRWYWx1ZSkgJiYgIWlzUmVmKHZhbHVlKSkge1xuICAgICAgICBvbGRWYWx1ZS52YWx1ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgaGFkS2V5ID0gaXNBcnJheSh0YXJnZXQpICYmIGlzSW50ZWdlcktleShrZXkpID8gTnVtYmVyKGtleSkgPCB0YXJnZXQubGVuZ3RoIDogaGFzT3duKHRhcmdldCwga2V5KTtcbiAgICBjb25zdCByZXN1bHQgPSBSZWZsZWN0LnNldCh0YXJnZXQsIGtleSwgdmFsdWUsIHJlY2VpdmVyKTtcbiAgICBpZiAodGFyZ2V0ID09PSB0b1JhdyhyZWNlaXZlcikpIHtcbiAgICAgIGlmICghaGFkS2V5KSB7XG4gICAgICAgIHRyaWdnZXIodGFyZ2V0LCBcImFkZFwiLCBrZXksIHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAoaGFzQ2hhbmdlZCh2YWx1ZSwgb2xkVmFsdWUpKSB7XG4gICAgICAgIHRyaWdnZXIodGFyZ2V0LCBcInNldFwiLCBrZXksIHZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59XG5mdW5jdGlvbiBkZWxldGVQcm9wZXJ0eSh0YXJnZXQsIGtleSkge1xuICBjb25zdCBoYWRLZXkgPSBoYXNPd24odGFyZ2V0LCBrZXkpO1xuICBjb25zdCBvbGRWYWx1ZSA9IHRhcmdldFtrZXldO1xuICBjb25zdCByZXN1bHQgPSBSZWZsZWN0LmRlbGV0ZVByb3BlcnR5KHRhcmdldCwga2V5KTtcbiAgaWYgKHJlc3VsdCAmJiBoYWRLZXkpIHtcbiAgICB0cmlnZ2VyKHRhcmdldCwgXCJkZWxldGVcIiwga2V5LCB2b2lkIDAsIG9sZFZhbHVlKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gaGFzKHRhcmdldCwga2V5KSB7XG4gIGNvbnN0IHJlc3VsdCA9IFJlZmxlY3QuaGFzKHRhcmdldCwga2V5KTtcbiAgaWYgKCFpc1N5bWJvbChrZXkpIHx8ICFidWlsdEluU3ltYm9scy5oYXMoa2V5KSkge1xuICAgIHRyYWNrKHRhcmdldCwgXCJoYXNcIiwga2V5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gb3duS2V5cyh0YXJnZXQpIHtcbiAgdHJhY2sodGFyZ2V0LCBcIml0ZXJhdGVcIiwgaXNBcnJheSh0YXJnZXQpID8gXCJsZW5ndGhcIiA6IElURVJBVEVfS0VZKTtcbiAgcmV0dXJuIFJlZmxlY3Qub3duS2V5cyh0YXJnZXQpO1xufVxudmFyIG11dGFibGVIYW5kbGVycyA9IHtcbiAgZ2V0OiBnZXQyLFxuICBzZXQ6IHNldDIsXG4gIGRlbGV0ZVByb3BlcnR5LFxuICBoYXMsXG4gIG93bktleXNcbn07XG52YXIgcmVhZG9ubHlIYW5kbGVycyA9IHtcbiAgZ2V0OiByZWFkb25seUdldCxcbiAgc2V0KHRhcmdldCwga2V5KSB7XG4gICAgaWYgKGZhbHNlKSB7XG4gICAgICBjb25zb2xlLndhcm4oYFNldCBvcGVyYXRpb24gb24ga2V5IFwiJHtTdHJpbmcoa2V5KX1cIiBmYWlsZWQ6IHRhcmdldCBpcyByZWFkb25seS5gLCB0YXJnZXQpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcbiAgZGVsZXRlUHJvcGVydHkodGFyZ2V0LCBrZXkpIHtcbiAgICBpZiAoZmFsc2UpIHtcbiAgICAgIGNvbnNvbGUud2FybihgRGVsZXRlIG9wZXJhdGlvbiBvbiBrZXkgXCIke1N0cmluZyhrZXkpfVwiIGZhaWxlZDogdGFyZ2V0IGlzIHJlYWRvbmx5LmAsIHRhcmdldCk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xudmFyIHNoYWxsb3dSZWFjdGl2ZUhhbmRsZXJzID0gZXh0ZW5kKHt9LCBtdXRhYmxlSGFuZGxlcnMsIHtcbiAgZ2V0OiBzaGFsbG93R2V0LFxuICBzZXQ6IHNoYWxsb3dTZXRcbn0pO1xudmFyIHNoYWxsb3dSZWFkb25seUhhbmRsZXJzID0gZXh0ZW5kKHt9LCByZWFkb25seUhhbmRsZXJzLCB7XG4gIGdldDogc2hhbGxvd1JlYWRvbmx5R2V0XG59KTtcbnZhciB0b1JlYWN0aXZlID0gKHZhbHVlKSA9PiBpc09iamVjdCh2YWx1ZSkgPyByZWFjdGl2ZTIodmFsdWUpIDogdmFsdWU7XG52YXIgdG9SZWFkb25seSA9ICh2YWx1ZSkgPT4gaXNPYmplY3QodmFsdWUpID8gcmVhZG9ubHkodmFsdWUpIDogdmFsdWU7XG52YXIgdG9TaGFsbG93ID0gKHZhbHVlKSA9PiB2YWx1ZTtcbnZhciBnZXRQcm90byA9ICh2KSA9PiBSZWZsZWN0LmdldFByb3RvdHlwZU9mKHYpO1xuZnVuY3Rpb24gZ2V0JDEodGFyZ2V0LCBrZXksIGlzUmVhZG9ubHkgPSBmYWxzZSwgaXNTaGFsbG93ID0gZmFsc2UpIHtcbiAgdGFyZ2V0ID0gdGFyZ2V0W1wiX192X3Jhd1wiXTtcbiAgY29uc3QgcmF3VGFyZ2V0ID0gdG9SYXcodGFyZ2V0KTtcbiAgY29uc3QgcmF3S2V5ID0gdG9SYXcoa2V5KTtcbiAgaWYgKGtleSAhPT0gcmF3S2V5KSB7XG4gICAgIWlzUmVhZG9ubHkgJiYgdHJhY2socmF3VGFyZ2V0LCBcImdldFwiLCBrZXkpO1xuICB9XG4gICFpc1JlYWRvbmx5ICYmIHRyYWNrKHJhd1RhcmdldCwgXCJnZXRcIiwgcmF3S2V5KTtcbiAgY29uc3Qge2hhczogaGFzMn0gPSBnZXRQcm90byhyYXdUYXJnZXQpO1xuICBjb25zdCB3cmFwID0gaXNTaGFsbG93ID8gdG9TaGFsbG93IDogaXNSZWFkb25seSA/IHRvUmVhZG9ubHkgOiB0b1JlYWN0aXZlO1xuICBpZiAoaGFzMi5jYWxsKHJhd1RhcmdldCwga2V5KSkge1xuICAgIHJldHVybiB3cmFwKHRhcmdldC5nZXQoa2V5KSk7XG4gIH0gZWxzZSBpZiAoaGFzMi5jYWxsKHJhd1RhcmdldCwgcmF3S2V5KSkge1xuICAgIHJldHVybiB3cmFwKHRhcmdldC5nZXQocmF3S2V5KSk7XG4gIH0gZWxzZSBpZiAodGFyZ2V0ICE9PSByYXdUYXJnZXQpIHtcbiAgICB0YXJnZXQuZ2V0KGtleSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGhhcyQxKGtleSwgaXNSZWFkb25seSA9IGZhbHNlKSB7XG4gIGNvbnN0IHRhcmdldCA9IHRoaXNbXCJfX3ZfcmF3XCJdO1xuICBjb25zdCByYXdUYXJnZXQgPSB0b1Jhdyh0YXJnZXQpO1xuICBjb25zdCByYXdLZXkgPSB0b1JhdyhrZXkpO1xuICBpZiAoa2V5ICE9PSByYXdLZXkpIHtcbiAgICAhaXNSZWFkb25seSAmJiB0cmFjayhyYXdUYXJnZXQsIFwiaGFzXCIsIGtleSk7XG4gIH1cbiAgIWlzUmVhZG9ubHkgJiYgdHJhY2socmF3VGFyZ2V0LCBcImhhc1wiLCByYXdLZXkpO1xuICByZXR1cm4ga2V5ID09PSByYXdLZXkgPyB0YXJnZXQuaGFzKGtleSkgOiB0YXJnZXQuaGFzKGtleSkgfHwgdGFyZ2V0LmhhcyhyYXdLZXkpO1xufVxuZnVuY3Rpb24gc2l6ZSh0YXJnZXQsIGlzUmVhZG9ubHkgPSBmYWxzZSkge1xuICB0YXJnZXQgPSB0YXJnZXRbXCJfX3ZfcmF3XCJdO1xuICAhaXNSZWFkb25seSAmJiB0cmFjayh0b1Jhdyh0YXJnZXQpLCBcIml0ZXJhdGVcIiwgSVRFUkFURV9LRVkpO1xuICByZXR1cm4gUmVmbGVjdC5nZXQodGFyZ2V0LCBcInNpemVcIiwgdGFyZ2V0KTtcbn1cbmZ1bmN0aW9uIGFkZCh2YWx1ZSkge1xuICB2YWx1ZSA9IHRvUmF3KHZhbHVlKTtcbiAgY29uc3QgdGFyZ2V0ID0gdG9SYXcodGhpcyk7XG4gIGNvbnN0IHByb3RvID0gZ2V0UHJvdG8odGFyZ2V0KTtcbiAgY29uc3QgaGFkS2V5ID0gcHJvdG8uaGFzLmNhbGwodGFyZ2V0LCB2YWx1ZSk7XG4gIGlmICghaGFkS2V5KSB7XG4gICAgdGFyZ2V0LmFkZCh2YWx1ZSk7XG4gICAgdHJpZ2dlcih0YXJnZXQsIFwiYWRkXCIsIHZhbHVlLCB2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG5mdW5jdGlvbiBzZXQkMShrZXksIHZhbHVlKSB7XG4gIHZhbHVlID0gdG9SYXcodmFsdWUpO1xuICBjb25zdCB0YXJnZXQgPSB0b1Jhdyh0aGlzKTtcbiAgY29uc3Qge2hhczogaGFzMiwgZ2V0OiBnZXQzfSA9IGdldFByb3RvKHRhcmdldCk7XG4gIGxldCBoYWRLZXkgPSBoYXMyLmNhbGwodGFyZ2V0LCBrZXkpO1xuICBpZiAoIWhhZEtleSkge1xuICAgIGtleSA9IHRvUmF3KGtleSk7XG4gICAgaGFkS2V5ID0gaGFzMi5jYWxsKHRhcmdldCwga2V5KTtcbiAgfSBlbHNlIGlmIChmYWxzZSkge1xuICAgIGNoZWNrSWRlbnRpdHlLZXlzKHRhcmdldCwgaGFzMiwga2V5KTtcbiAgfVxuICBjb25zdCBvbGRWYWx1ZSA9IGdldDMuY2FsbCh0YXJnZXQsIGtleSk7XG4gIHRhcmdldC5zZXQoa2V5LCB2YWx1ZSk7XG4gIGlmICghaGFkS2V5KSB7XG4gICAgdHJpZ2dlcih0YXJnZXQsIFwiYWRkXCIsIGtleSwgdmFsdWUpO1xuICB9IGVsc2UgaWYgKGhhc0NoYW5nZWQodmFsdWUsIG9sZFZhbHVlKSkge1xuICAgIHRyaWdnZXIodGFyZ2V0LCBcInNldFwiLCBrZXksIHZhbHVlLCBvbGRWYWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG5mdW5jdGlvbiBkZWxldGVFbnRyeShrZXkpIHtcbiAgY29uc3QgdGFyZ2V0ID0gdG9SYXcodGhpcyk7XG4gIGNvbnN0IHtoYXM6IGhhczIsIGdldDogZ2V0M30gPSBnZXRQcm90byh0YXJnZXQpO1xuICBsZXQgaGFkS2V5ID0gaGFzMi5jYWxsKHRhcmdldCwga2V5KTtcbiAgaWYgKCFoYWRLZXkpIHtcbiAgICBrZXkgPSB0b1JhdyhrZXkpO1xuICAgIGhhZEtleSA9IGhhczIuY2FsbCh0YXJnZXQsIGtleSk7XG4gIH0gZWxzZSBpZiAoZmFsc2UpIHtcbiAgICBjaGVja0lkZW50aXR5S2V5cyh0YXJnZXQsIGhhczIsIGtleSk7XG4gIH1cbiAgY29uc3Qgb2xkVmFsdWUgPSBnZXQzID8gZ2V0My5jYWxsKHRhcmdldCwga2V5KSA6IHZvaWQgMDtcbiAgY29uc3QgcmVzdWx0ID0gdGFyZ2V0LmRlbGV0ZShrZXkpO1xuICBpZiAoaGFkS2V5KSB7XG4gICAgdHJpZ2dlcih0YXJnZXQsIFwiZGVsZXRlXCIsIGtleSwgdm9pZCAwLCBvbGRWYWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGNsZWFyKCkge1xuICBjb25zdCB0YXJnZXQgPSB0b1Jhdyh0aGlzKTtcbiAgY29uc3QgaGFkSXRlbXMgPSB0YXJnZXQuc2l6ZSAhPT0gMDtcbiAgY29uc3Qgb2xkVGFyZ2V0ID0gZmFsc2UgPyBpc01hcCh0YXJnZXQpID8gbmV3IE1hcCh0YXJnZXQpIDogbmV3IFNldCh0YXJnZXQpIDogdm9pZCAwO1xuICBjb25zdCByZXN1bHQgPSB0YXJnZXQuY2xlYXIoKTtcbiAgaWYgKGhhZEl0ZW1zKSB7XG4gICAgdHJpZ2dlcih0YXJnZXQsIFwiY2xlYXJcIiwgdm9pZCAwLCB2b2lkIDAsIG9sZFRhcmdldCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUZvckVhY2goaXNSZWFkb25seSwgaXNTaGFsbG93KSB7XG4gIHJldHVybiBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgY29uc3Qgb2JzZXJ2ZWQgPSB0aGlzO1xuICAgIGNvbnN0IHRhcmdldCA9IG9ic2VydmVkW1wiX192X3Jhd1wiXTtcbiAgICBjb25zdCByYXdUYXJnZXQgPSB0b1Jhdyh0YXJnZXQpO1xuICAgIGNvbnN0IHdyYXAgPSBpc1NoYWxsb3cgPyB0b1NoYWxsb3cgOiBpc1JlYWRvbmx5ID8gdG9SZWFkb25seSA6IHRvUmVhY3RpdmU7XG4gICAgIWlzUmVhZG9ubHkgJiYgdHJhY2socmF3VGFyZ2V0LCBcIml0ZXJhdGVcIiwgSVRFUkFURV9LRVkpO1xuICAgIHJldHVybiB0YXJnZXQuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrLmNhbGwodGhpc0FyZywgd3JhcCh2YWx1ZSksIHdyYXAoa2V5KSwgb2JzZXJ2ZWQpO1xuICAgIH0pO1xuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlSXRlcmFibGVNZXRob2QobWV0aG9kLCBpc1JlYWRvbmx5LCBpc1NoYWxsb3cpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKC4uLmFyZ3MpIHtcbiAgICBjb25zdCB0YXJnZXQgPSB0aGlzW1wiX192X3Jhd1wiXTtcbiAgICBjb25zdCByYXdUYXJnZXQgPSB0b1Jhdyh0YXJnZXQpO1xuICAgIGNvbnN0IHRhcmdldElzTWFwID0gaXNNYXAocmF3VGFyZ2V0KTtcbiAgICBjb25zdCBpc1BhaXIgPSBtZXRob2QgPT09IFwiZW50cmllc1wiIHx8IG1ldGhvZCA9PT0gU3ltYm9sLml0ZXJhdG9yICYmIHRhcmdldElzTWFwO1xuICAgIGNvbnN0IGlzS2V5T25seSA9IG1ldGhvZCA9PT0gXCJrZXlzXCIgJiYgdGFyZ2V0SXNNYXA7XG4gICAgY29uc3QgaW5uZXJJdGVyYXRvciA9IHRhcmdldFttZXRob2RdKC4uLmFyZ3MpO1xuICAgIGNvbnN0IHdyYXAgPSBpc1NoYWxsb3cgPyB0b1NoYWxsb3cgOiBpc1JlYWRvbmx5ID8gdG9SZWFkb25seSA6IHRvUmVhY3RpdmU7XG4gICAgIWlzUmVhZG9ubHkgJiYgdHJhY2socmF3VGFyZ2V0LCBcIml0ZXJhdGVcIiwgaXNLZXlPbmx5ID8gTUFQX0tFWV9JVEVSQVRFX0tFWSA6IElURVJBVEVfS0VZKTtcbiAgICByZXR1cm4ge1xuICAgICAgbmV4dCgpIHtcbiAgICAgICAgY29uc3Qge3ZhbHVlLCBkb25lfSA9IGlubmVySXRlcmF0b3IubmV4dCgpO1xuICAgICAgICByZXR1cm4gZG9uZSA/IHt2YWx1ZSwgZG9uZX0gOiB7XG4gICAgICAgICAgdmFsdWU6IGlzUGFpciA/IFt3cmFwKHZhbHVlWzBdKSwgd3JhcCh2YWx1ZVsxXSldIDogd3JhcCh2YWx1ZSksXG4gICAgICAgICAgZG9uZVxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICB9O1xuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlUmVhZG9ubHlNZXRob2QodHlwZSkge1xuICByZXR1cm4gZnVuY3Rpb24oLi4uYXJncykge1xuICAgIGlmIChmYWxzZSkge1xuICAgICAgY29uc3Qga2V5ID0gYXJnc1swXSA/IGBvbiBrZXkgXCIke2FyZ3NbMF19XCIgYCA6IGBgO1xuICAgICAgY29uc29sZS53YXJuKGAke2NhcGl0YWxpemUodHlwZSl9IG9wZXJhdGlvbiAke2tleX1mYWlsZWQ6IHRhcmdldCBpcyByZWFkb25seS5gLCB0b1Jhdyh0aGlzKSk7XG4gICAgfVxuICAgIHJldHVybiB0eXBlID09PSBcImRlbGV0ZVwiID8gZmFsc2UgOiB0aGlzO1xuICB9O1xufVxudmFyIG11dGFibGVJbnN0cnVtZW50YXRpb25zID0ge1xuICBnZXQoa2V5KSB7XG4gICAgcmV0dXJuIGdldCQxKHRoaXMsIGtleSk7XG4gIH0sXG4gIGdldCBzaXplKCkge1xuICAgIHJldHVybiBzaXplKHRoaXMpO1xuICB9LFxuICBoYXM6IGhhcyQxLFxuICBhZGQsXG4gIHNldDogc2V0JDEsXG4gIGRlbGV0ZTogZGVsZXRlRW50cnksXG4gIGNsZWFyLFxuICBmb3JFYWNoOiBjcmVhdGVGb3JFYWNoKGZhbHNlLCBmYWxzZSlcbn07XG52YXIgc2hhbGxvd0luc3RydW1lbnRhdGlvbnMgPSB7XG4gIGdldChrZXkpIHtcbiAgICByZXR1cm4gZ2V0JDEodGhpcywga2V5LCBmYWxzZSwgdHJ1ZSk7XG4gIH0sXG4gIGdldCBzaXplKCkge1xuICAgIHJldHVybiBzaXplKHRoaXMpO1xuICB9LFxuICBoYXM6IGhhcyQxLFxuICBhZGQsXG4gIHNldDogc2V0JDEsXG4gIGRlbGV0ZTogZGVsZXRlRW50cnksXG4gIGNsZWFyLFxuICBmb3JFYWNoOiBjcmVhdGVGb3JFYWNoKGZhbHNlLCB0cnVlKVxufTtcbnZhciByZWFkb25seUluc3RydW1lbnRhdGlvbnMgPSB7XG4gIGdldChrZXkpIHtcbiAgICByZXR1cm4gZ2V0JDEodGhpcywga2V5LCB0cnVlKTtcbiAgfSxcbiAgZ2V0IHNpemUoKSB7XG4gICAgcmV0dXJuIHNpemUodGhpcywgdHJ1ZSk7XG4gIH0sXG4gIGhhcyhrZXkpIHtcbiAgICByZXR1cm4gaGFzJDEuY2FsbCh0aGlzLCBrZXksIHRydWUpO1xuICB9LFxuICBhZGQ6IGNyZWF0ZVJlYWRvbmx5TWV0aG9kKFwiYWRkXCIpLFxuICBzZXQ6IGNyZWF0ZVJlYWRvbmx5TWV0aG9kKFwic2V0XCIpLFxuICBkZWxldGU6IGNyZWF0ZVJlYWRvbmx5TWV0aG9kKFwiZGVsZXRlXCIpLFxuICBjbGVhcjogY3JlYXRlUmVhZG9ubHlNZXRob2QoXCJjbGVhclwiKSxcbiAgZm9yRWFjaDogY3JlYXRlRm9yRWFjaCh0cnVlLCBmYWxzZSlcbn07XG52YXIgc2hhbGxvd1JlYWRvbmx5SW5zdHJ1bWVudGF0aW9ucyA9IHtcbiAgZ2V0KGtleSkge1xuICAgIHJldHVybiBnZXQkMSh0aGlzLCBrZXksIHRydWUsIHRydWUpO1xuICB9LFxuICBnZXQgc2l6ZSgpIHtcbiAgICByZXR1cm4gc2l6ZSh0aGlzLCB0cnVlKTtcbiAgfSxcbiAgaGFzKGtleSkge1xuICAgIHJldHVybiBoYXMkMS5jYWxsKHRoaXMsIGtleSwgdHJ1ZSk7XG4gIH0sXG4gIGFkZDogY3JlYXRlUmVhZG9ubHlNZXRob2QoXCJhZGRcIiksXG4gIHNldDogY3JlYXRlUmVhZG9ubHlNZXRob2QoXCJzZXRcIiksXG4gIGRlbGV0ZTogY3JlYXRlUmVhZG9ubHlNZXRob2QoXCJkZWxldGVcIiksXG4gIGNsZWFyOiBjcmVhdGVSZWFkb25seU1ldGhvZChcImNsZWFyXCIpLFxuICBmb3JFYWNoOiBjcmVhdGVGb3JFYWNoKHRydWUsIHRydWUpXG59O1xudmFyIGl0ZXJhdG9yTWV0aG9kcyA9IFtcImtleXNcIiwgXCJ2YWx1ZXNcIiwgXCJlbnRyaWVzXCIsIFN5bWJvbC5pdGVyYXRvcl07XG5pdGVyYXRvck1ldGhvZHMuZm9yRWFjaCgobWV0aG9kKSA9PiB7XG4gIG11dGFibGVJbnN0cnVtZW50YXRpb25zW21ldGhvZF0gPSBjcmVhdGVJdGVyYWJsZU1ldGhvZChtZXRob2QsIGZhbHNlLCBmYWxzZSk7XG4gIHJlYWRvbmx5SW5zdHJ1bWVudGF0aW9uc1ttZXRob2RdID0gY3JlYXRlSXRlcmFibGVNZXRob2QobWV0aG9kLCB0cnVlLCBmYWxzZSk7XG4gIHNoYWxsb3dJbnN0cnVtZW50YXRpb25zW21ldGhvZF0gPSBjcmVhdGVJdGVyYWJsZU1ldGhvZChtZXRob2QsIGZhbHNlLCB0cnVlKTtcbiAgc2hhbGxvd1JlYWRvbmx5SW5zdHJ1bWVudGF0aW9uc1ttZXRob2RdID0gY3JlYXRlSXRlcmFibGVNZXRob2QobWV0aG9kLCB0cnVlLCB0cnVlKTtcbn0pO1xuZnVuY3Rpb24gY3JlYXRlSW5zdHJ1bWVudGF0aW9uR2V0dGVyKGlzUmVhZG9ubHksIHNoYWxsb3cpIHtcbiAgY29uc3QgaW5zdHJ1bWVudGF0aW9ucyA9IHNoYWxsb3cgPyBpc1JlYWRvbmx5ID8gc2hhbGxvd1JlYWRvbmx5SW5zdHJ1bWVudGF0aW9ucyA6IHNoYWxsb3dJbnN0cnVtZW50YXRpb25zIDogaXNSZWFkb25seSA/IHJlYWRvbmx5SW5zdHJ1bWVudGF0aW9ucyA6IG11dGFibGVJbnN0cnVtZW50YXRpb25zO1xuICByZXR1cm4gKHRhcmdldCwga2V5LCByZWNlaXZlcikgPT4ge1xuICAgIGlmIChrZXkgPT09IFwiX192X2lzUmVhY3RpdmVcIikge1xuICAgICAgcmV0dXJuICFpc1JlYWRvbmx5O1xuICAgIH0gZWxzZSBpZiAoa2V5ID09PSBcIl9fdl9pc1JlYWRvbmx5XCIpIHtcbiAgICAgIHJldHVybiBpc1JlYWRvbmx5O1xuICAgIH0gZWxzZSBpZiAoa2V5ID09PSBcIl9fdl9yYXdcIikge1xuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG4gICAgcmV0dXJuIFJlZmxlY3QuZ2V0KGhhc093bihpbnN0cnVtZW50YXRpb25zLCBrZXkpICYmIGtleSBpbiB0YXJnZXQgPyBpbnN0cnVtZW50YXRpb25zIDogdGFyZ2V0LCBrZXksIHJlY2VpdmVyKTtcbiAgfTtcbn1cbnZhciBtdXRhYmxlQ29sbGVjdGlvbkhhbmRsZXJzID0ge1xuICBnZXQ6IGNyZWF0ZUluc3RydW1lbnRhdGlvbkdldHRlcihmYWxzZSwgZmFsc2UpXG59O1xudmFyIHNoYWxsb3dDb2xsZWN0aW9uSGFuZGxlcnMgPSB7XG4gIGdldDogY3JlYXRlSW5zdHJ1bWVudGF0aW9uR2V0dGVyKGZhbHNlLCB0cnVlKVxufTtcbnZhciByZWFkb25seUNvbGxlY3Rpb25IYW5kbGVycyA9IHtcbiAgZ2V0OiBjcmVhdGVJbnN0cnVtZW50YXRpb25HZXR0ZXIodHJ1ZSwgZmFsc2UpXG59O1xudmFyIHNoYWxsb3dSZWFkb25seUNvbGxlY3Rpb25IYW5kbGVycyA9IHtcbiAgZ2V0OiBjcmVhdGVJbnN0cnVtZW50YXRpb25HZXR0ZXIodHJ1ZSwgdHJ1ZSlcbn07XG52YXIgcmVhY3RpdmVNYXAgPSBuZXcgV2Vha01hcCgpO1xudmFyIHNoYWxsb3dSZWFjdGl2ZU1hcCA9IG5ldyBXZWFrTWFwKCk7XG52YXIgcmVhZG9ubHlNYXAgPSBuZXcgV2Vha01hcCgpO1xudmFyIHNoYWxsb3dSZWFkb25seU1hcCA9IG5ldyBXZWFrTWFwKCk7XG5mdW5jdGlvbiB0YXJnZXRUeXBlTWFwKHJhd1R5cGUpIHtcbiAgc3dpdGNoIChyYXdUeXBlKSB7XG4gICAgY2FzZSBcIk9iamVjdFwiOlxuICAgIGNhc2UgXCJBcnJheVwiOlxuICAgICAgcmV0dXJuIDE7XG4gICAgY2FzZSBcIk1hcFwiOlxuICAgIGNhc2UgXCJTZXRcIjpcbiAgICBjYXNlIFwiV2Vha01hcFwiOlxuICAgIGNhc2UgXCJXZWFrU2V0XCI6XG4gICAgICByZXR1cm4gMjtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIDA7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFRhcmdldFR5cGUodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlW1wiX192X3NraXBcIl0gfHwgIU9iamVjdC5pc0V4dGVuc2libGUodmFsdWUpID8gMCA6IHRhcmdldFR5cGVNYXAodG9SYXdUeXBlKHZhbHVlKSk7XG59XG5mdW5jdGlvbiByZWFjdGl2ZTIodGFyZ2V0KSB7XG4gIGlmICh0YXJnZXQgJiYgdGFyZ2V0W1wiX192X2lzUmVhZG9ubHlcIl0pIHtcbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG4gIHJldHVybiBjcmVhdGVSZWFjdGl2ZU9iamVjdCh0YXJnZXQsIGZhbHNlLCBtdXRhYmxlSGFuZGxlcnMsIG11dGFibGVDb2xsZWN0aW9uSGFuZGxlcnMsIHJlYWN0aXZlTWFwKTtcbn1cbmZ1bmN0aW9uIHJlYWRvbmx5KHRhcmdldCkge1xuICByZXR1cm4gY3JlYXRlUmVhY3RpdmVPYmplY3QodGFyZ2V0LCB0cnVlLCByZWFkb25seUhhbmRsZXJzLCByZWFkb25seUNvbGxlY3Rpb25IYW5kbGVycywgcmVhZG9ubHlNYXApO1xufVxuZnVuY3Rpb24gY3JlYXRlUmVhY3RpdmVPYmplY3QodGFyZ2V0LCBpc1JlYWRvbmx5LCBiYXNlSGFuZGxlcnMsIGNvbGxlY3Rpb25IYW5kbGVycywgcHJveHlNYXApIHtcbiAgaWYgKCFpc09iamVjdCh0YXJnZXQpKSB7XG4gICAgaWYgKGZhbHNlKSB7XG4gICAgICBjb25zb2xlLndhcm4oYHZhbHVlIGNhbm5vdCBiZSBtYWRlIHJlYWN0aXZlOiAke1N0cmluZyh0YXJnZXQpfWApO1xuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG4gIGlmICh0YXJnZXRbXCJfX3ZfcmF3XCJdICYmICEoaXNSZWFkb25seSAmJiB0YXJnZXRbXCJfX3ZfaXNSZWFjdGl2ZVwiXSkpIHtcbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG4gIGNvbnN0IGV4aXN0aW5nUHJveHkgPSBwcm94eU1hcC5nZXQodGFyZ2V0KTtcbiAgaWYgKGV4aXN0aW5nUHJveHkpIHtcbiAgICByZXR1cm4gZXhpc3RpbmdQcm94eTtcbiAgfVxuICBjb25zdCB0YXJnZXRUeXBlID0gZ2V0VGFyZ2V0VHlwZSh0YXJnZXQpO1xuICBpZiAodGFyZ2V0VHlwZSA9PT0gMCkge1xuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cbiAgY29uc3QgcHJveHkgPSBuZXcgUHJveHkodGFyZ2V0LCB0YXJnZXRUeXBlID09PSAyID8gY29sbGVjdGlvbkhhbmRsZXJzIDogYmFzZUhhbmRsZXJzKTtcbiAgcHJveHlNYXAuc2V0KHRhcmdldCwgcHJveHkpO1xuICByZXR1cm4gcHJveHk7XG59XG5mdW5jdGlvbiB0b1JhdyhvYnNlcnZlZCkge1xuICByZXR1cm4gb2JzZXJ2ZWQgJiYgdG9SYXcob2JzZXJ2ZWRbXCJfX3ZfcmF3XCJdKSB8fCBvYnNlcnZlZDtcbn1cbmZ1bmN0aW9uIGlzUmVmKHIpIHtcbiAgcmV0dXJuIEJvb2xlYW4ociAmJiByLl9fdl9pc1JlZiA9PT0gdHJ1ZSk7XG59XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy9tYWdpY3MvJG5leHRUaWNrLmpzXG5tYWdpYyhcIm5leHRUaWNrXCIsICgpID0+IG5leHRUaWNrKTtcblxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL21hZ2ljcy8kZGlzcGF0Y2guanNcbm1hZ2ljKFwiZGlzcGF0Y2hcIiwgKGVsKSA9PiBkaXNwYXRjaC5iaW5kKGRpc3BhdGNoLCBlbCkpO1xuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvbWFnaWNzLyR3YXRjaC5qc1xubWFnaWMoXCJ3YXRjaFwiLCAoZWwsIHtldmFsdWF0ZUxhdGVyOiBldmFsdWF0ZUxhdGVyMiwgZWZmZWN0OiBlZmZlY3QzfSkgPT4gKGtleSwgY2FsbGJhY2spID0+IHtcbiAgbGV0IGV2YWx1YXRlMiA9IGV2YWx1YXRlTGF0ZXIyKGtleSk7XG4gIGxldCBmaXJzdFRpbWUgPSB0cnVlO1xuICBsZXQgb2xkVmFsdWU7XG4gIGxldCBlZmZlY3RSZWZlcmVuY2UgPSBlZmZlY3QzKCgpID0+IGV2YWx1YXRlMigodmFsdWUpID0+IHtcbiAgICBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgaWYgKCFmaXJzdFRpbWUpIHtcbiAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgICAgY2FsbGJhY2sodmFsdWUsIG9sZFZhbHVlKTtcbiAgICAgICAgb2xkVmFsdWUgPSB2YWx1ZTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBvbGRWYWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICBmaXJzdFRpbWUgPSBmYWxzZTtcbiAgfSkpO1xuICBlbC5feF9lZmZlY3RzLmRlbGV0ZShlZmZlY3RSZWZlcmVuY2UpO1xufSk7XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy9tYWdpY3MvJHN0b3JlLmpzXG5tYWdpYyhcInN0b3JlXCIsIGdldFN0b3Jlcyk7XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy9tYWdpY3MvJGRhdGEuanNcbm1hZ2ljKFwiZGF0YVwiLCAoZWwpID0+IHNjb3BlKGVsKSk7XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy9tYWdpY3MvJHJvb3QuanNcbm1hZ2ljKFwicm9vdFwiLCAoZWwpID0+IGNsb3Nlc3RSb290KGVsKSk7XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy9tYWdpY3MvJHJlZnMuanNcbm1hZ2ljKFwicmVmc1wiLCAoZWwpID0+IHtcbiAgaWYgKGVsLl94X3JlZnNfcHJveHkpXG4gICAgcmV0dXJuIGVsLl94X3JlZnNfcHJveHk7XG4gIGVsLl94X3JlZnNfcHJveHkgPSBtZXJnZVByb3hpZXMoZ2V0QXJyYXlPZlJlZk9iamVjdChlbCkpO1xuICByZXR1cm4gZWwuX3hfcmVmc19wcm94eTtcbn0pO1xuZnVuY3Rpb24gZ2V0QXJyYXlPZlJlZk9iamVjdChlbCkge1xuICBsZXQgcmVmT2JqZWN0cyA9IFtdO1xuICBsZXQgY3VycmVudEVsID0gZWw7XG4gIHdoaWxlIChjdXJyZW50RWwpIHtcbiAgICBpZiAoY3VycmVudEVsLl94X3JlZnMpXG4gICAgICByZWZPYmplY3RzLnB1c2goY3VycmVudEVsLl94X3JlZnMpO1xuICAgIGN1cnJlbnRFbCA9IGN1cnJlbnRFbC5wYXJlbnROb2RlO1xuICB9XG4gIHJldHVybiByZWZPYmplY3RzO1xufVxuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvaWRzLmpzXG52YXIgZ2xvYmFsSWRNZW1vID0ge307XG5mdW5jdGlvbiBmaW5kQW5kSW5jcmVtZW50SWQobmFtZSkge1xuICBpZiAoIWdsb2JhbElkTWVtb1tuYW1lXSlcbiAgICBnbG9iYWxJZE1lbW9bbmFtZV0gPSAwO1xuICByZXR1cm4gKytnbG9iYWxJZE1lbW9bbmFtZV07XG59XG5mdW5jdGlvbiBjbG9zZXN0SWRSb290KGVsLCBuYW1lKSB7XG4gIHJldHVybiBmaW5kQ2xvc2VzdChlbCwgKGVsZW1lbnQpID0+IHtcbiAgICBpZiAoZWxlbWVudC5feF9pZHMgJiYgZWxlbWVudC5feF9pZHNbbmFtZV0pXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgfSk7XG59XG5mdW5jdGlvbiBzZXRJZFJvb3QoZWwsIG5hbWUpIHtcbiAgaWYgKCFlbC5feF9pZHMpXG4gICAgZWwuX3hfaWRzID0ge307XG4gIGlmICghZWwuX3hfaWRzW25hbWVdKVxuICAgIGVsLl94X2lkc1tuYW1lXSA9IGZpbmRBbmRJbmNyZW1lbnRJZChuYW1lKTtcbn1cblxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL21hZ2ljcy8kaWQuanNcbm1hZ2ljKFwiaWRcIiwgKGVsKSA9PiAobmFtZSwga2V5ID0gbnVsbCkgPT4ge1xuICBsZXQgcm9vdCA9IGNsb3Nlc3RJZFJvb3QoZWwsIG5hbWUpO1xuICBsZXQgaWQgPSByb290ID8gcm9vdC5feF9pZHNbbmFtZV0gOiBmaW5kQW5kSW5jcmVtZW50SWQobmFtZSk7XG4gIHJldHVybiBrZXkgPyBgJHtuYW1lfS0ke2lkfS0ke2tleX1gIDogYCR7bmFtZX0tJHtpZH1gO1xufSk7XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy9tYWdpY3MvJGVsLmpzXG5tYWdpYyhcImVsXCIsIChlbCkgPT4gZWwpO1xuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvbWFnaWNzL2luZGV4LmpzXG53YXJuTWlzc2luZ1BsdWdpbk1hZ2ljKFwiRm9jdXNcIiwgXCJmb2N1c1wiLCBcImZvY3VzXCIpO1xud2Fybk1pc3NpbmdQbHVnaW5NYWdpYyhcIlBlcnNpc3RcIiwgXCJwZXJzaXN0XCIsIFwicGVyc2lzdFwiKTtcbmZ1bmN0aW9uIHdhcm5NaXNzaW5nUGx1Z2luTWFnaWMobmFtZSwgbWFnaWNOYW1lLCBzbHVnKSB7XG4gIG1hZ2ljKG1hZ2ljTmFtZSwgKGVsKSA9PiB3YXJuKGBZb3UgY2FuJ3QgdXNlIFskJHtkaXJlY3RpdmVOYW1lfV0gd2l0aG91dCBmaXJzdCBpbnN0YWxsaW5nIHRoZSBcIiR7bmFtZX1cIiBwbHVnaW4gaGVyZTogaHR0cHM6Ly9hbHBpbmVqcy5kZXYvcGx1Z2lucy8ke3NsdWd9YCwgZWwpKTtcbn1cblxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL2RpcmVjdGl2ZXMveC1tb2RlbGFibGUuanNcbmRpcmVjdGl2ZShcIm1vZGVsYWJsZVwiLCAoZWwsIHtleHByZXNzaW9ufSwge2VmZmVjdDogZWZmZWN0MywgZXZhbHVhdGVMYXRlcjogZXZhbHVhdGVMYXRlcjJ9KSA9PiB7XG4gIGxldCBmdW5jID0gZXZhbHVhdGVMYXRlcjIoZXhwcmVzc2lvbik7XG4gIGxldCBpbm5lckdldCA9ICgpID0+IHtcbiAgICBsZXQgcmVzdWx0O1xuICAgIGZ1bmMoKGkpID0+IHJlc3VsdCA9IGkpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIGxldCBldmFsdWF0ZUlubmVyU2V0ID0gZXZhbHVhdGVMYXRlcjIoYCR7ZXhwcmVzc2lvbn0gPSBfX3BsYWNlaG9sZGVyYCk7XG4gIGxldCBpbm5lclNldCA9ICh2YWwpID0+IGV2YWx1YXRlSW5uZXJTZXQoKCkgPT4ge1xuICB9LCB7c2NvcGU6IHtfX3BsYWNlaG9sZGVyOiB2YWx9fSk7XG4gIGxldCBpbml0aWFsVmFsdWUgPSBpbm5lckdldCgpO1xuICBpbm5lclNldChpbml0aWFsVmFsdWUpO1xuICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgaWYgKCFlbC5feF9tb2RlbClcbiAgICAgIHJldHVybjtcbiAgICBlbC5feF9yZW1vdmVNb2RlbExpc3RlbmVyc1tcImRlZmF1bHRcIl0oKTtcbiAgICBsZXQgb3V0ZXJHZXQgPSBlbC5feF9tb2RlbC5nZXQ7XG4gICAgbGV0IG91dGVyU2V0ID0gZWwuX3hfbW9kZWwuc2V0O1xuICAgIGVmZmVjdDMoKCkgPT4gaW5uZXJTZXQob3V0ZXJHZXQoKSkpO1xuICAgIGVmZmVjdDMoKCkgPT4gb3V0ZXJTZXQoaW5uZXJHZXQoKSkpO1xuICB9KTtcbn0pO1xuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvZGlyZWN0aXZlcy94LXRlbGVwb3J0LmpzXG5kaXJlY3RpdmUoXCJ0ZWxlcG9ydFwiLCAoZWwsIHtleHByZXNzaW9ufSwge2NsZWFudXA6IGNsZWFudXAyfSkgPT4ge1xuICBpZiAoZWwudGFnTmFtZS50b0xvd2VyQ2FzZSgpICE9PSBcInRlbXBsYXRlXCIpXG4gICAgd2FybihcIngtdGVsZXBvcnQgY2FuIG9ubHkgYmUgdXNlZCBvbiBhIDx0ZW1wbGF0ZT4gdGFnXCIsIGVsKTtcbiAgbGV0IHRhcmdldCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoZXhwcmVzc2lvbik7XG4gIGlmICghdGFyZ2V0KVxuICAgIHdhcm4oYENhbm5vdCBmaW5kIHgtdGVsZXBvcnQgZWxlbWVudCBmb3Igc2VsZWN0b3I6IFwiJHtleHByZXNzaW9ufVwiYCk7XG4gIGxldCBjbG9uZTIgPSBlbC5jb250ZW50LmNsb25lTm9kZSh0cnVlKS5maXJzdEVsZW1lbnRDaGlsZDtcbiAgZWwuX3hfdGVsZXBvcnQgPSBjbG9uZTI7XG4gIGNsb25lMi5feF90ZWxlcG9ydEJhY2sgPSBlbDtcbiAgaWYgKGVsLl94X2ZvcndhcmRFdmVudHMpIHtcbiAgICBlbC5feF9mb3J3YXJkRXZlbnRzLmZvckVhY2goKGV2ZW50TmFtZSkgPT4ge1xuICAgICAgY2xvbmUyLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCAoZSkgPT4ge1xuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBlbC5kaXNwYXRjaEV2ZW50KG5ldyBlLmNvbnN0cnVjdG9yKGUudHlwZSwgZSkpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgYWRkU2NvcGVUb05vZGUoY2xvbmUyLCB7fSwgZWwpO1xuICBtdXRhdGVEb20oKCkgPT4ge1xuICAgIHRhcmdldC5hcHBlbmRDaGlsZChjbG9uZTIpO1xuICAgIGluaXRUcmVlKGNsb25lMik7XG4gICAgY2xvbmUyLl94X2lnbm9yZSA9IHRydWU7XG4gIH0pO1xuICBjbGVhbnVwMigoKSA9PiBjbG9uZTIucmVtb3ZlKCkpO1xufSk7XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy9kaXJlY3RpdmVzL3gtaWdub3JlLmpzXG52YXIgaGFuZGxlciA9ICgpID0+IHtcbn07XG5oYW5kbGVyLmlubGluZSA9IChlbCwge21vZGlmaWVyc30sIHtjbGVhbnVwOiBjbGVhbnVwMn0pID0+IHtcbiAgbW9kaWZpZXJzLmluY2x1ZGVzKFwic2VsZlwiKSA/IGVsLl94X2lnbm9yZVNlbGYgPSB0cnVlIDogZWwuX3hfaWdub3JlID0gdHJ1ZTtcbiAgY2xlYW51cDIoKCkgPT4ge1xuICAgIG1vZGlmaWVycy5pbmNsdWRlcyhcInNlbGZcIikgPyBkZWxldGUgZWwuX3hfaWdub3JlU2VsZiA6IGRlbGV0ZSBlbC5feF9pZ25vcmU7XG4gIH0pO1xufTtcbmRpcmVjdGl2ZShcImlnbm9yZVwiLCBoYW5kbGVyKTtcblxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL2RpcmVjdGl2ZXMveC1lZmZlY3QuanNcbmRpcmVjdGl2ZShcImVmZmVjdFwiLCAoZWwsIHtleHByZXNzaW9ufSwge2VmZmVjdDogZWZmZWN0M30pID0+IGVmZmVjdDMoZXZhbHVhdGVMYXRlcihlbCwgZXhwcmVzc2lvbikpKTtcblxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL3V0aWxzL29uLmpzXG5mdW5jdGlvbiBvbihlbCwgZXZlbnQsIG1vZGlmaWVycywgY2FsbGJhY2spIHtcbiAgbGV0IGxpc3RlbmVyVGFyZ2V0ID0gZWw7XG4gIGxldCBoYW5kbGVyMyA9IChlKSA9PiBjYWxsYmFjayhlKTtcbiAgbGV0IG9wdGlvbnMgPSB7fTtcbiAgbGV0IHdyYXBIYW5kbGVyID0gKGNhbGxiYWNrMiwgd3JhcHBlcikgPT4gKGUpID0+IHdyYXBwZXIoY2FsbGJhY2syLCBlKTtcbiAgaWYgKG1vZGlmaWVycy5pbmNsdWRlcyhcImRvdFwiKSlcbiAgICBldmVudCA9IGRvdFN5bnRheChldmVudCk7XG4gIGlmIChtb2RpZmllcnMuaW5jbHVkZXMoXCJjYW1lbFwiKSlcbiAgICBldmVudCA9IGNhbWVsQ2FzZTIoZXZlbnQpO1xuICBpZiAobW9kaWZpZXJzLmluY2x1ZGVzKFwicGFzc2l2ZVwiKSlcbiAgICBvcHRpb25zLnBhc3NpdmUgPSB0cnVlO1xuICBpZiAobW9kaWZpZXJzLmluY2x1ZGVzKFwiY2FwdHVyZVwiKSlcbiAgICBvcHRpb25zLmNhcHR1cmUgPSB0cnVlO1xuICBpZiAobW9kaWZpZXJzLmluY2x1ZGVzKFwid2luZG93XCIpKVxuICAgIGxpc3RlbmVyVGFyZ2V0ID0gd2luZG93O1xuICBpZiAobW9kaWZpZXJzLmluY2x1ZGVzKFwiZG9jdW1lbnRcIikpXG4gICAgbGlzdGVuZXJUYXJnZXQgPSBkb2N1bWVudDtcbiAgaWYgKG1vZGlmaWVycy5pbmNsdWRlcyhcInByZXZlbnRcIikpXG4gICAgaGFuZGxlcjMgPSB3cmFwSGFuZGxlcihoYW5kbGVyMywgKG5leHQsIGUpID0+IHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIG5leHQoZSk7XG4gICAgfSk7XG4gIGlmIChtb2RpZmllcnMuaW5jbHVkZXMoXCJzdG9wXCIpKVxuICAgIGhhbmRsZXIzID0gd3JhcEhhbmRsZXIoaGFuZGxlcjMsIChuZXh0LCBlKSA9PiB7XG4gICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgbmV4dChlKTtcbiAgICB9KTtcbiAgaWYgKG1vZGlmaWVycy5pbmNsdWRlcyhcInNlbGZcIikpXG4gICAgaGFuZGxlcjMgPSB3cmFwSGFuZGxlcihoYW5kbGVyMywgKG5leHQsIGUpID0+IHtcbiAgICAgIGUudGFyZ2V0ID09PSBlbCAmJiBuZXh0KGUpO1xuICAgIH0pO1xuICBpZiAobW9kaWZpZXJzLmluY2x1ZGVzKFwiYXdheVwiKSB8fCBtb2RpZmllcnMuaW5jbHVkZXMoXCJvdXRzaWRlXCIpKSB7XG4gICAgbGlzdGVuZXJUYXJnZXQgPSBkb2N1bWVudDtcbiAgICBoYW5kbGVyMyA9IHdyYXBIYW5kbGVyKGhhbmRsZXIzLCAobmV4dCwgZSkgPT4ge1xuICAgICAgaWYgKGVsLmNvbnRhaW5zKGUudGFyZ2V0KSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgaWYgKGUudGFyZ2V0LmlzQ29ubmVjdGVkID09PSBmYWxzZSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgaWYgKGVsLm9mZnNldFdpZHRoIDwgMSAmJiBlbC5vZmZzZXRIZWlnaHQgPCAxKVxuICAgICAgICByZXR1cm47XG4gICAgICBpZiAoZWwuX3hfaXNTaG93biA9PT0gZmFsc2UpXG4gICAgICAgIHJldHVybjtcbiAgICAgIG5leHQoZSk7XG4gICAgfSk7XG4gIH1cbiAgaWYgKG1vZGlmaWVycy5pbmNsdWRlcyhcIm9uY2VcIikpIHtcbiAgICBoYW5kbGVyMyA9IHdyYXBIYW5kbGVyKGhhbmRsZXIzLCAobmV4dCwgZSkgPT4ge1xuICAgICAgbmV4dChlKTtcbiAgICAgIGxpc3RlbmVyVGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIzLCBvcHRpb25zKTtcbiAgICB9KTtcbiAgfVxuICBoYW5kbGVyMyA9IHdyYXBIYW5kbGVyKGhhbmRsZXIzLCAobmV4dCwgZSkgPT4ge1xuICAgIGlmIChpc0tleUV2ZW50KGV2ZW50KSkge1xuICAgICAgaWYgKGlzTGlzdGVuaW5nRm9yQVNwZWNpZmljS2V5VGhhdEhhc250QmVlblByZXNzZWQoZSwgbW9kaWZpZXJzKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIG5leHQoZSk7XG4gIH0pO1xuICBpZiAobW9kaWZpZXJzLmluY2x1ZGVzKFwiZGVib3VuY2VcIikpIHtcbiAgICBsZXQgbmV4dE1vZGlmaWVyID0gbW9kaWZpZXJzW21vZGlmaWVycy5pbmRleE9mKFwiZGVib3VuY2VcIikgKyAxXSB8fCBcImludmFsaWQtd2FpdFwiO1xuICAgIGxldCB3YWl0ID0gaXNOdW1lcmljKG5leHRNb2RpZmllci5zcGxpdChcIm1zXCIpWzBdKSA/IE51bWJlcihuZXh0TW9kaWZpZXIuc3BsaXQoXCJtc1wiKVswXSkgOiAyNTA7XG4gICAgaGFuZGxlcjMgPSBkZWJvdW5jZShoYW5kbGVyMywgd2FpdCk7XG4gIH1cbiAgaWYgKG1vZGlmaWVycy5pbmNsdWRlcyhcInRocm90dGxlXCIpKSB7XG4gICAgbGV0IG5leHRNb2RpZmllciA9IG1vZGlmaWVyc1ttb2RpZmllcnMuaW5kZXhPZihcInRocm90dGxlXCIpICsgMV0gfHwgXCJpbnZhbGlkLXdhaXRcIjtcbiAgICBsZXQgd2FpdCA9IGlzTnVtZXJpYyhuZXh0TW9kaWZpZXIuc3BsaXQoXCJtc1wiKVswXSkgPyBOdW1iZXIobmV4dE1vZGlmaWVyLnNwbGl0KFwibXNcIilbMF0pIDogMjUwO1xuICAgIGhhbmRsZXIzID0gdGhyb3R0bGUoaGFuZGxlcjMsIHdhaXQpO1xuICB9XG4gIGxpc3RlbmVyVGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIzLCBvcHRpb25zKTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBsaXN0ZW5lclRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyMywgb3B0aW9ucyk7XG4gIH07XG59XG5mdW5jdGlvbiBkb3RTeW50YXgoc3ViamVjdCkge1xuICByZXR1cm4gc3ViamVjdC5yZXBsYWNlKC8tL2csIFwiLlwiKTtcbn1cbmZ1bmN0aW9uIGNhbWVsQ2FzZTIoc3ViamVjdCkge1xuICByZXR1cm4gc3ViamVjdC50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoLy0oXFx3KS9nLCAobWF0Y2gsIGNoYXIpID0+IGNoYXIudG9VcHBlckNhc2UoKSk7XG59XG5mdW5jdGlvbiBpc051bWVyaWMoc3ViamVjdCkge1xuICByZXR1cm4gIUFycmF5LmlzQXJyYXkoc3ViamVjdCkgJiYgIWlzTmFOKHN1YmplY3QpO1xufVxuZnVuY3Rpb24ga2ViYWJDYXNlMihzdWJqZWN0KSB7XG4gIHJldHVybiBzdWJqZWN0LnJlcGxhY2UoLyhbYS16XSkoW0EtWl0pL2csIFwiJDEtJDJcIikucmVwbGFjZSgvW19cXHNdLywgXCItXCIpLnRvTG93ZXJDYXNlKCk7XG59XG5mdW5jdGlvbiBpc0tleUV2ZW50KGV2ZW50KSB7XG4gIHJldHVybiBbXCJrZXlkb3duXCIsIFwia2V5dXBcIl0uaW5jbHVkZXMoZXZlbnQpO1xufVxuZnVuY3Rpb24gaXNMaXN0ZW5pbmdGb3JBU3BlY2lmaWNLZXlUaGF0SGFzbnRCZWVuUHJlc3NlZChlLCBtb2RpZmllcnMpIHtcbiAgbGV0IGtleU1vZGlmaWVycyA9IG1vZGlmaWVycy5maWx0ZXIoKGkpID0+IHtcbiAgICByZXR1cm4gIVtcIndpbmRvd1wiLCBcImRvY3VtZW50XCIsIFwicHJldmVudFwiLCBcInN0b3BcIiwgXCJvbmNlXCJdLmluY2x1ZGVzKGkpO1xuICB9KTtcbiAgaWYgKGtleU1vZGlmaWVycy5pbmNsdWRlcyhcImRlYm91bmNlXCIpKSB7XG4gICAgbGV0IGRlYm91bmNlSW5kZXggPSBrZXlNb2RpZmllcnMuaW5kZXhPZihcImRlYm91bmNlXCIpO1xuICAgIGtleU1vZGlmaWVycy5zcGxpY2UoZGVib3VuY2VJbmRleCwgaXNOdW1lcmljKChrZXlNb2RpZmllcnNbZGVib3VuY2VJbmRleCArIDFdIHx8IFwiaW52YWxpZC13YWl0XCIpLnNwbGl0KFwibXNcIilbMF0pID8gMiA6IDEpO1xuICB9XG4gIGlmIChrZXlNb2RpZmllcnMubGVuZ3RoID09PSAwKVxuICAgIHJldHVybiBmYWxzZTtcbiAgaWYgKGtleU1vZGlmaWVycy5sZW5ndGggPT09IDEgJiYga2V5VG9Nb2RpZmllcnMoZS5rZXkpLmluY2x1ZGVzKGtleU1vZGlmaWVyc1swXSkpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBzeXN0ZW1LZXlNb2RpZmllcnMgPSBbXCJjdHJsXCIsIFwic2hpZnRcIiwgXCJhbHRcIiwgXCJtZXRhXCIsIFwiY21kXCIsIFwic3VwZXJcIl07XG4gIGNvbnN0IHNlbGVjdGVkU3lzdGVtS2V5TW9kaWZpZXJzID0gc3lzdGVtS2V5TW9kaWZpZXJzLmZpbHRlcigobW9kaWZpZXIpID0+IGtleU1vZGlmaWVycy5pbmNsdWRlcyhtb2RpZmllcikpO1xuICBrZXlNb2RpZmllcnMgPSBrZXlNb2RpZmllcnMuZmlsdGVyKChpKSA9PiAhc2VsZWN0ZWRTeXN0ZW1LZXlNb2RpZmllcnMuaW5jbHVkZXMoaSkpO1xuICBpZiAoc2VsZWN0ZWRTeXN0ZW1LZXlNb2RpZmllcnMubGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IGFjdGl2ZWx5UHJlc3NlZEtleU1vZGlmaWVycyA9IHNlbGVjdGVkU3lzdGVtS2V5TW9kaWZpZXJzLmZpbHRlcigobW9kaWZpZXIpID0+IHtcbiAgICAgIGlmIChtb2RpZmllciA9PT0gXCJjbWRcIiB8fCBtb2RpZmllciA9PT0gXCJzdXBlclwiKVxuICAgICAgICBtb2RpZmllciA9IFwibWV0YVwiO1xuICAgICAgcmV0dXJuIGVbYCR7bW9kaWZpZXJ9S2V5YF07XG4gICAgfSk7XG4gICAgaWYgKGFjdGl2ZWx5UHJlc3NlZEtleU1vZGlmaWVycy5sZW5ndGggPT09IHNlbGVjdGVkU3lzdGVtS2V5TW9kaWZpZXJzLmxlbmd0aCkge1xuICAgICAgaWYgKGtleVRvTW9kaWZpZXJzKGUua2V5KS5pbmNsdWRlcyhrZXlNb2RpZmllcnNbMF0pKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24ga2V5VG9Nb2RpZmllcnMoa2V5KSB7XG4gIGlmICgha2V5KVxuICAgIHJldHVybiBbXTtcbiAga2V5ID0ga2ViYWJDYXNlMihrZXkpO1xuICBsZXQgbW9kaWZpZXJUb0tleU1hcCA9IHtcbiAgICBjdHJsOiBcImNvbnRyb2xcIixcbiAgICBzbGFzaDogXCIvXCIsXG4gICAgc3BhY2U6IFwiLVwiLFxuICAgIHNwYWNlYmFyOiBcIi1cIixcbiAgICBjbWQ6IFwibWV0YVwiLFxuICAgIGVzYzogXCJlc2NhcGVcIixcbiAgICB1cDogXCJhcnJvdy11cFwiLFxuICAgIGRvd246IFwiYXJyb3ctZG93blwiLFxuICAgIGxlZnQ6IFwiYXJyb3ctbGVmdFwiLFxuICAgIHJpZ2h0OiBcImFycm93LXJpZ2h0XCIsXG4gICAgcGVyaW9kOiBcIi5cIixcbiAgICBlcXVhbDogXCI9XCJcbiAgfTtcbiAgbW9kaWZpZXJUb0tleU1hcFtrZXldID0ga2V5O1xuICByZXR1cm4gT2JqZWN0LmtleXMobW9kaWZpZXJUb0tleU1hcCkubWFwKChtb2RpZmllcikgPT4ge1xuICAgIGlmIChtb2RpZmllclRvS2V5TWFwW21vZGlmaWVyXSA9PT0ga2V5KVxuICAgICAgcmV0dXJuIG1vZGlmaWVyO1xuICB9KS5maWx0ZXIoKG1vZGlmaWVyKSA9PiBtb2RpZmllcik7XG59XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy9kaXJlY3RpdmVzL3gtbW9kZWwuanNcbmRpcmVjdGl2ZShcIm1vZGVsXCIsIChlbCwge21vZGlmaWVycywgZXhwcmVzc2lvbn0sIHtlZmZlY3Q6IGVmZmVjdDMsIGNsZWFudXA6IGNsZWFudXAyfSkgPT4ge1xuICBsZXQgZXZhbHVhdGUyID0gZXZhbHVhdGVMYXRlcihlbCwgZXhwcmVzc2lvbik7XG4gIGxldCBhc3NpZ25tZW50RXhwcmVzc2lvbiA9IGAke2V4cHJlc3Npb259ID0gcmlnaHRTaWRlT2ZFeHByZXNzaW9uKCRldmVudCwgJHtleHByZXNzaW9ufSlgO1xuICBsZXQgZXZhbHVhdGVBc3NpZ25tZW50ID0gZXZhbHVhdGVMYXRlcihlbCwgYXNzaWdubWVudEV4cHJlc3Npb24pO1xuICB2YXIgZXZlbnQgPSBlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwic2VsZWN0XCIgfHwgW1wiY2hlY2tib3hcIiwgXCJyYWRpb1wiXS5pbmNsdWRlcyhlbC50eXBlKSB8fCBtb2RpZmllcnMuaW5jbHVkZXMoXCJsYXp5XCIpID8gXCJjaGFuZ2VcIiA6IFwiaW5wdXRcIjtcbiAgbGV0IGFzc2lnbWVudEZ1bmN0aW9uID0gZ2VuZXJhdGVBc3NpZ25tZW50RnVuY3Rpb24oZWwsIG1vZGlmaWVycywgZXhwcmVzc2lvbik7XG4gIGxldCByZW1vdmVMaXN0ZW5lciA9IG9uKGVsLCBldmVudCwgbW9kaWZpZXJzLCAoZSkgPT4ge1xuICAgIGV2YWx1YXRlQXNzaWdubWVudCgoKSA9PiB7XG4gICAgfSwge3Njb3BlOiB7XG4gICAgICAkZXZlbnQ6IGUsXG4gICAgICByaWdodFNpZGVPZkV4cHJlc3Npb246IGFzc2lnbWVudEZ1bmN0aW9uXG4gICAgfX0pO1xuICB9KTtcbiAgaWYgKCFlbC5feF9yZW1vdmVNb2RlbExpc3RlbmVycylcbiAgICBlbC5feF9yZW1vdmVNb2RlbExpc3RlbmVycyA9IHt9O1xuICBlbC5feF9yZW1vdmVNb2RlbExpc3RlbmVyc1tcImRlZmF1bHRcIl0gPSByZW1vdmVMaXN0ZW5lcjtcbiAgY2xlYW51cDIoKCkgPT4gZWwuX3hfcmVtb3ZlTW9kZWxMaXN0ZW5lcnNbXCJkZWZhdWx0XCJdKCkpO1xuICBsZXQgZXZhbHVhdGVTZXRNb2RlbCA9IGV2YWx1YXRlTGF0ZXIoZWwsIGAke2V4cHJlc3Npb259ID0gX19wbGFjZWhvbGRlcmApO1xuICBlbC5feF9tb2RlbCA9IHtcbiAgICBnZXQoKSB7XG4gICAgICBsZXQgcmVzdWx0O1xuICAgICAgZXZhbHVhdGUyKCh2YWx1ZSkgPT4gcmVzdWx0ID0gdmFsdWUpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuICAgIHNldCh2YWx1ZSkge1xuICAgICAgZXZhbHVhdGVTZXRNb2RlbCgoKSA9PiB7XG4gICAgICB9LCB7c2NvcGU6IHtfX3BsYWNlaG9sZGVyOiB2YWx1ZX19KTtcbiAgICB9XG4gIH07XG4gIGVsLl94X2ZvcmNlTW9kZWxVcGRhdGUgPSAoKSA9PiB7XG4gICAgZXZhbHVhdGUyKCh2YWx1ZSkgPT4ge1xuICAgICAgaWYgKHZhbHVlID09PSB2b2lkIDAgJiYgZXhwcmVzc2lvbi5tYXRjaCgvXFwuLykpXG4gICAgICAgIHZhbHVlID0gXCJcIjtcbiAgICAgIHdpbmRvdy5mcm9tTW9kZWwgPSB0cnVlO1xuICAgICAgbXV0YXRlRG9tKCgpID0+IGJpbmQoZWwsIFwidmFsdWVcIiwgdmFsdWUpKTtcbiAgICAgIGRlbGV0ZSB3aW5kb3cuZnJvbU1vZGVsO1xuICAgIH0pO1xuICB9O1xuICBlZmZlY3QzKCgpID0+IHtcbiAgICBpZiAobW9kaWZpZXJzLmluY2x1ZGVzKFwidW5pbnRydXNpdmVcIikgJiYgZG9jdW1lbnQuYWN0aXZlRWxlbWVudC5pc1NhbWVOb2RlKGVsKSlcbiAgICAgIHJldHVybjtcbiAgICBlbC5feF9mb3JjZU1vZGVsVXBkYXRlKCk7XG4gIH0pO1xufSk7XG5mdW5jdGlvbiBnZW5lcmF0ZUFzc2lnbm1lbnRGdW5jdGlvbihlbCwgbW9kaWZpZXJzLCBleHByZXNzaW9uKSB7XG4gIGlmIChlbC50eXBlID09PSBcInJhZGlvXCIpIHtcbiAgICBtdXRhdGVEb20oKCkgPT4ge1xuICAgICAgaWYgKCFlbC5oYXNBdHRyaWJ1dGUoXCJuYW1lXCIpKVxuICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoXCJuYW1lXCIsIGV4cHJlc3Npb24pO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiAoZXZlbnQsIGN1cnJlbnRWYWx1ZSkgPT4ge1xuICAgIHJldHVybiBtdXRhdGVEb20oKCkgPT4ge1xuICAgICAgaWYgKGV2ZW50IGluc3RhbmNlb2YgQ3VzdG9tRXZlbnQgJiYgZXZlbnQuZGV0YWlsICE9PSB2b2lkIDApIHtcbiAgICAgICAgcmV0dXJuIGV2ZW50LmRldGFpbCB8fCBldmVudC50YXJnZXQudmFsdWU7XG4gICAgICB9IGVsc2UgaWYgKGVsLnR5cGUgPT09IFwiY2hlY2tib3hcIikge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjdXJyZW50VmFsdWUpKSB7XG4gICAgICAgICAgbGV0IG5ld1ZhbHVlID0gbW9kaWZpZXJzLmluY2x1ZGVzKFwibnVtYmVyXCIpID8gc2FmZVBhcnNlTnVtYmVyKGV2ZW50LnRhcmdldC52YWx1ZSkgOiBldmVudC50YXJnZXQudmFsdWU7XG4gICAgICAgICAgcmV0dXJuIGV2ZW50LnRhcmdldC5jaGVja2VkID8gY3VycmVudFZhbHVlLmNvbmNhdChbbmV3VmFsdWVdKSA6IGN1cnJlbnRWYWx1ZS5maWx0ZXIoKGVsMikgPT4gIWNoZWNrZWRBdHRyTG9vc2VDb21wYXJlMihlbDIsIG5ld1ZhbHVlKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGV2ZW50LnRhcmdldC5jaGVja2VkO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJzZWxlY3RcIiAmJiBlbC5tdWx0aXBsZSkge1xuICAgICAgICByZXR1cm4gbW9kaWZpZXJzLmluY2x1ZGVzKFwibnVtYmVyXCIpID8gQXJyYXkuZnJvbShldmVudC50YXJnZXQuc2VsZWN0ZWRPcHRpb25zKS5tYXAoKG9wdGlvbikgPT4ge1xuICAgICAgICAgIGxldCByYXdWYWx1ZSA9IG9wdGlvbi52YWx1ZSB8fCBvcHRpb24udGV4dDtcbiAgICAgICAgICByZXR1cm4gc2FmZVBhcnNlTnVtYmVyKHJhd1ZhbHVlKTtcbiAgICAgICAgfSkgOiBBcnJheS5mcm9tKGV2ZW50LnRhcmdldC5zZWxlY3RlZE9wdGlvbnMpLm1hcCgob3B0aW9uKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIG9wdGlvbi52YWx1ZSB8fCBvcHRpb24udGV4dDtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgcmF3VmFsdWUgPSBldmVudC50YXJnZXQudmFsdWU7XG4gICAgICAgIHJldHVybiBtb2RpZmllcnMuaW5jbHVkZXMoXCJudW1iZXJcIikgPyBzYWZlUGFyc2VOdW1iZXIocmF3VmFsdWUpIDogbW9kaWZpZXJzLmluY2x1ZGVzKFwidHJpbVwiKSA/IHJhd1ZhbHVlLnRyaW0oKSA6IHJhd1ZhbHVlO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xufVxuZnVuY3Rpb24gc2FmZVBhcnNlTnVtYmVyKHJhd1ZhbHVlKSB7XG4gIGxldCBudW1iZXIgPSByYXdWYWx1ZSA/IHBhcnNlRmxvYXQocmF3VmFsdWUpIDogbnVsbDtcbiAgcmV0dXJuIGlzTnVtZXJpYzIobnVtYmVyKSA/IG51bWJlciA6IHJhd1ZhbHVlO1xufVxuZnVuY3Rpb24gY2hlY2tlZEF0dHJMb29zZUNvbXBhcmUyKHZhbHVlQSwgdmFsdWVCKSB7XG4gIHJldHVybiB2YWx1ZUEgPT0gdmFsdWVCO1xufVxuZnVuY3Rpb24gaXNOdW1lcmljMihzdWJqZWN0KSB7XG4gIHJldHVybiAhQXJyYXkuaXNBcnJheShzdWJqZWN0KSAmJiAhaXNOYU4oc3ViamVjdCk7XG59XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy9kaXJlY3RpdmVzL3gtY2xvYWsuanNcbmRpcmVjdGl2ZShcImNsb2FrXCIsIChlbCkgPT4gcXVldWVNaWNyb3Rhc2soKCkgPT4gbXV0YXRlRG9tKCgpID0+IGVsLnJlbW92ZUF0dHJpYnV0ZShwcmVmaXgoXCJjbG9ha1wiKSkpKSk7XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy9kaXJlY3RpdmVzL3gtaW5pdC5qc1xuYWRkSW5pdFNlbGVjdG9yKCgpID0+IGBbJHtwcmVmaXgoXCJpbml0XCIpfV1gKTtcbmRpcmVjdGl2ZShcImluaXRcIiwgc2tpcER1cmluZ0Nsb25lKChlbCwge2V4cHJlc3Npb259LCB7ZXZhbHVhdGU6IGV2YWx1YXRlMn0pID0+IHtcbiAgaWYgKHR5cGVvZiBleHByZXNzaW9uID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuICEhZXhwcmVzc2lvbi50cmltKCkgJiYgZXZhbHVhdGUyKGV4cHJlc3Npb24sIHt9LCBmYWxzZSk7XG4gIH1cbiAgcmV0dXJuIGV2YWx1YXRlMihleHByZXNzaW9uLCB7fSwgZmFsc2UpO1xufSkpO1xuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvZGlyZWN0aXZlcy94LXRleHQuanNcbmRpcmVjdGl2ZShcInRleHRcIiwgKGVsLCB7ZXhwcmVzc2lvbn0sIHtlZmZlY3Q6IGVmZmVjdDMsIGV2YWx1YXRlTGF0ZXI6IGV2YWx1YXRlTGF0ZXIyfSkgPT4ge1xuICBsZXQgZXZhbHVhdGUyID0gZXZhbHVhdGVMYXRlcjIoZXhwcmVzc2lvbik7XG4gIGVmZmVjdDMoKCkgPT4ge1xuICAgIGV2YWx1YXRlMigodmFsdWUpID0+IHtcbiAgICAgIG11dGF0ZURvbSgoKSA9PiB7XG4gICAgICAgIGVsLnRleHRDb250ZW50ID0gdmFsdWU7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG59KTtcblxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL2RpcmVjdGl2ZXMveC1odG1sLmpzXG5kaXJlY3RpdmUoXCJodG1sXCIsIChlbCwge2V4cHJlc3Npb259LCB7ZWZmZWN0OiBlZmZlY3QzLCBldmFsdWF0ZUxhdGVyOiBldmFsdWF0ZUxhdGVyMn0pID0+IHtcbiAgbGV0IGV2YWx1YXRlMiA9IGV2YWx1YXRlTGF0ZXIyKGV4cHJlc3Npb24pO1xuICBlZmZlY3QzKCgpID0+IHtcbiAgICBldmFsdWF0ZTIoKHZhbHVlKSA9PiB7XG4gICAgICBtdXRhdGVEb20oKCkgPT4ge1xuICAgICAgICBlbC5pbm5lckhUTUwgPSB2YWx1ZTtcbiAgICAgICAgZWwuX3hfaWdub3JlU2VsZiA9IHRydWU7XG4gICAgICAgIGluaXRUcmVlKGVsKTtcbiAgICAgICAgZGVsZXRlIGVsLl94X2lnbm9yZVNlbGY7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG59KTtcblxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL2RpcmVjdGl2ZXMveC1iaW5kLmpzXG5tYXBBdHRyaWJ1dGVzKHN0YXJ0aW5nV2l0aChcIjpcIiwgaW50byhwcmVmaXgoXCJiaW5kOlwiKSkpKTtcbmRpcmVjdGl2ZShcImJpbmRcIiwgKGVsLCB7dmFsdWUsIG1vZGlmaWVycywgZXhwcmVzc2lvbiwgb3JpZ2luYWx9LCB7ZWZmZWN0OiBlZmZlY3QzfSkgPT4ge1xuICBpZiAoIXZhbHVlKSB7XG4gICAgcmV0dXJuIGFwcGx5QmluZGluZ3NPYmplY3QoZWwsIGV4cHJlc3Npb24sIG9yaWdpbmFsLCBlZmZlY3QzKTtcbiAgfVxuICBpZiAodmFsdWUgPT09IFwia2V5XCIpXG4gICAgcmV0dXJuIHN0b3JlS2V5Rm9yWEZvcihlbCwgZXhwcmVzc2lvbik7XG4gIGxldCBldmFsdWF0ZTIgPSBldmFsdWF0ZUxhdGVyKGVsLCBleHByZXNzaW9uKTtcbiAgZWZmZWN0MygoKSA9PiBldmFsdWF0ZTIoKHJlc3VsdCkgPT4ge1xuICAgIGlmIChyZXN1bHQgPT09IHZvaWQgMCAmJiBleHByZXNzaW9uLm1hdGNoKC9cXC4vKSlcbiAgICAgIHJlc3VsdCA9IFwiXCI7XG4gICAgbXV0YXRlRG9tKCgpID0+IGJpbmQoZWwsIHZhbHVlLCByZXN1bHQsIG1vZGlmaWVycykpO1xuICB9KSk7XG59KTtcbmZ1bmN0aW9uIGFwcGx5QmluZGluZ3NPYmplY3QoZWwsIGV4cHJlc3Npb24sIG9yaWdpbmFsLCBlZmZlY3QzKSB7XG4gIGxldCBiaW5kaW5nUHJvdmlkZXJzID0ge307XG4gIGluamVjdEJpbmRpbmdQcm92aWRlcnMoYmluZGluZ1Byb3ZpZGVycyk7XG4gIGxldCBnZXRCaW5kaW5ncyA9IGV2YWx1YXRlTGF0ZXIoZWwsIGV4cHJlc3Npb24pO1xuICBsZXQgY2xlYW51cFJ1bm5lcnMgPSBbXTtcbiAgd2hpbGUgKGNsZWFudXBSdW5uZXJzLmxlbmd0aClcbiAgICBjbGVhbnVwUnVubmVycy5wb3AoKSgpO1xuICBnZXRCaW5kaW5ncygoYmluZGluZ3MpID0+IHtcbiAgICBsZXQgYXR0cmlidXRlcyA9IE9iamVjdC5lbnRyaWVzKGJpbmRpbmdzKS5tYXAoKFtuYW1lLCB2YWx1ZV0pID0+ICh7bmFtZSwgdmFsdWV9KSk7XG4gICAgbGV0IHN0YXRpY0F0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzT25seShhdHRyaWJ1dGVzKTtcbiAgICBhdHRyaWJ1dGVzID0gYXR0cmlidXRlcy5tYXAoKGF0dHJpYnV0ZSkgPT4ge1xuICAgICAgaWYgKHN0YXRpY0F0dHJpYnV0ZXMuZmluZCgoYXR0cikgPT4gYXR0ci5uYW1lID09PSBhdHRyaWJ1dGUubmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBuYW1lOiBgeC1iaW5kOiR7YXR0cmlidXRlLm5hbWV9YCxcbiAgICAgICAgICB2YWx1ZTogYFwiJHthdHRyaWJ1dGUudmFsdWV9XCJgXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4gYXR0cmlidXRlO1xuICAgIH0pO1xuICAgIGRpcmVjdGl2ZXMoZWwsIGF0dHJpYnV0ZXMsIG9yaWdpbmFsKS5tYXAoKGhhbmRsZSkgPT4ge1xuICAgICAgY2xlYW51cFJ1bm5lcnMucHVzaChoYW5kbGUucnVuQ2xlYW51cHMpO1xuICAgICAgaGFuZGxlKCk7XG4gICAgfSk7XG4gIH0sIHtzY29wZTogYmluZGluZ1Byb3ZpZGVyc30pO1xufVxuZnVuY3Rpb24gc3RvcmVLZXlGb3JYRm9yKGVsLCBleHByZXNzaW9uKSB7XG4gIGVsLl94X2tleUV4cHJlc3Npb24gPSBleHByZXNzaW9uO1xufVxuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvZGlyZWN0aXZlcy94LWRhdGEuanNcbmFkZFJvb3RTZWxlY3RvcigoKSA9PiBgWyR7cHJlZml4KFwiZGF0YVwiKX1dYCk7XG5kaXJlY3RpdmUoXCJkYXRhXCIsIHNraXBEdXJpbmdDbG9uZSgoZWwsIHtleHByZXNzaW9ufSwge2NsZWFudXA6IGNsZWFudXAyfSkgPT4ge1xuICBleHByZXNzaW9uID0gZXhwcmVzc2lvbiA9PT0gXCJcIiA/IFwie31cIiA6IGV4cHJlc3Npb247XG4gIGxldCBtYWdpY0NvbnRleHQgPSB7fTtcbiAgaW5qZWN0TWFnaWNzKG1hZ2ljQ29udGV4dCwgZWwpO1xuICBsZXQgZGF0YVByb3ZpZGVyQ29udGV4dCA9IHt9O1xuICBpbmplY3REYXRhUHJvdmlkZXJzKGRhdGFQcm92aWRlckNvbnRleHQsIG1hZ2ljQ29udGV4dCk7XG4gIGxldCBkYXRhMiA9IGV2YWx1YXRlKGVsLCBleHByZXNzaW9uLCB7c2NvcGU6IGRhdGFQcm92aWRlckNvbnRleHR9KTtcbiAgaWYgKGRhdGEyID09PSB2b2lkIDApXG4gICAgZGF0YTIgPSB7fTtcbiAgaW5qZWN0TWFnaWNzKGRhdGEyLCBlbCk7XG4gIGxldCByZWFjdGl2ZURhdGEgPSByZWFjdGl2ZShkYXRhMik7XG4gIGluaXRJbnRlcmNlcHRvcnMocmVhY3RpdmVEYXRhKTtcbiAgbGV0IHVuZG8gPSBhZGRTY29wZVRvTm9kZShlbCwgcmVhY3RpdmVEYXRhKTtcbiAgcmVhY3RpdmVEYXRhW1wiaW5pdFwiXSAmJiBldmFsdWF0ZShlbCwgcmVhY3RpdmVEYXRhW1wiaW5pdFwiXSk7XG4gIGNsZWFudXAyKCgpID0+IHtcbiAgICByZWFjdGl2ZURhdGFbXCJkZXN0cm95XCJdICYmIGV2YWx1YXRlKGVsLCByZWFjdGl2ZURhdGFbXCJkZXN0cm95XCJdKTtcbiAgICB1bmRvKCk7XG4gIH0pO1xufSkpO1xuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvZGlyZWN0aXZlcy94LXNob3cuanNcbmRpcmVjdGl2ZShcInNob3dcIiwgKGVsLCB7bW9kaWZpZXJzLCBleHByZXNzaW9ufSwge2VmZmVjdDogZWZmZWN0M30pID0+IHtcbiAgbGV0IGV2YWx1YXRlMiA9IGV2YWx1YXRlTGF0ZXIoZWwsIGV4cHJlc3Npb24pO1xuICBpZiAoIWVsLl94X2RvSGlkZSlcbiAgICBlbC5feF9kb0hpZGUgPSAoKSA9PiB7XG4gICAgICBtdXRhdGVEb20oKCkgPT4gZWwuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiKTtcbiAgICB9O1xuICBpZiAoIWVsLl94X2RvU2hvdylcbiAgICBlbC5feF9kb1Nob3cgPSAoKSA9PiB7XG4gICAgICBtdXRhdGVEb20oKCkgPT4ge1xuICAgICAgICBpZiAoZWwuc3R5bGUubGVuZ3RoID09PSAxICYmIGVsLnN0eWxlLmRpc3BsYXkgPT09IFwibm9uZVwiKSB7XG4gICAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKFwic3R5bGVcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZWwuc3R5bGUucmVtb3ZlUHJvcGVydHkoXCJkaXNwbGF5XCIpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICBsZXQgaGlkZSA9ICgpID0+IHtcbiAgICBlbC5feF9kb0hpZGUoKTtcbiAgICBlbC5feF9pc1Nob3duID0gZmFsc2U7XG4gIH07XG4gIGxldCBzaG93ID0gKCkgPT4ge1xuICAgIGVsLl94X2RvU2hvdygpO1xuICAgIGVsLl94X2lzU2hvd24gPSB0cnVlO1xuICB9O1xuICBsZXQgY2xpY2tBd2F5Q29tcGF0aWJsZVNob3cgPSAoKSA9PiBzZXRUaW1lb3V0KHNob3cpO1xuICBsZXQgdG9nZ2xlID0gb25jZSgodmFsdWUpID0+IHZhbHVlID8gc2hvdygpIDogaGlkZSgpLCAodmFsdWUpID0+IHtcbiAgICBpZiAodHlwZW9mIGVsLl94X3RvZ2dsZUFuZENhc2NhZGVXaXRoVHJhbnNpdGlvbnMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgZWwuX3hfdG9nZ2xlQW5kQ2FzY2FkZVdpdGhUcmFuc2l0aW9ucyhlbCwgdmFsdWUsIHNob3csIGhpZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSA/IGNsaWNrQXdheUNvbXBhdGlibGVTaG93KCkgOiBoaWRlKCk7XG4gICAgfVxuICB9KTtcbiAgbGV0IG9sZFZhbHVlO1xuICBsZXQgZmlyc3RUaW1lID0gdHJ1ZTtcbiAgZWZmZWN0MygoKSA9PiBldmFsdWF0ZTIoKHZhbHVlKSA9PiB7XG4gICAgaWYgKCFmaXJzdFRpbWUgJiYgdmFsdWUgPT09IG9sZFZhbHVlKVxuICAgICAgcmV0dXJuO1xuICAgIGlmIChtb2RpZmllcnMuaW5jbHVkZXMoXCJpbW1lZGlhdGVcIikpXG4gICAgICB2YWx1ZSA/IGNsaWNrQXdheUNvbXBhdGlibGVTaG93KCkgOiBoaWRlKCk7XG4gICAgdG9nZ2xlKHZhbHVlKTtcbiAgICBvbGRWYWx1ZSA9IHZhbHVlO1xuICAgIGZpcnN0VGltZSA9IGZhbHNlO1xuICB9KSk7XG59KTtcblxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL2RpcmVjdGl2ZXMveC1mb3IuanNcbmRpcmVjdGl2ZShcImZvclwiLCAoZWwsIHtleHByZXNzaW9ufSwge2VmZmVjdDogZWZmZWN0MywgY2xlYW51cDogY2xlYW51cDJ9KSA9PiB7XG4gIGxldCBpdGVyYXRvck5hbWVzID0gcGFyc2VGb3JFeHByZXNzaW9uKGV4cHJlc3Npb24pO1xuICBsZXQgZXZhbHVhdGVJdGVtcyA9IGV2YWx1YXRlTGF0ZXIoZWwsIGl0ZXJhdG9yTmFtZXMuaXRlbXMpO1xuICBsZXQgZXZhbHVhdGVLZXkgPSBldmFsdWF0ZUxhdGVyKGVsLCBlbC5feF9rZXlFeHByZXNzaW9uIHx8IFwiaW5kZXhcIik7XG4gIGVsLl94X3ByZXZLZXlzID0gW107XG4gIGVsLl94X2xvb2t1cCA9IHt9O1xuICBlZmZlY3QzKCgpID0+IGxvb3AoZWwsIGl0ZXJhdG9yTmFtZXMsIGV2YWx1YXRlSXRlbXMsIGV2YWx1YXRlS2V5KSk7XG4gIGNsZWFudXAyKCgpID0+IHtcbiAgICBPYmplY3QudmFsdWVzKGVsLl94X2xvb2t1cCkuZm9yRWFjaCgoZWwyKSA9PiBlbDIucmVtb3ZlKCkpO1xuICAgIGRlbGV0ZSBlbC5feF9wcmV2S2V5cztcbiAgICBkZWxldGUgZWwuX3hfbG9va3VwO1xuICB9KTtcbn0pO1xuZnVuY3Rpb24gbG9vcChlbCwgaXRlcmF0b3JOYW1lcywgZXZhbHVhdGVJdGVtcywgZXZhbHVhdGVLZXkpIHtcbiAgbGV0IGlzT2JqZWN0MiA9IChpKSA9PiB0eXBlb2YgaSA9PT0gXCJvYmplY3RcIiAmJiAhQXJyYXkuaXNBcnJheShpKTtcbiAgbGV0IHRlbXBsYXRlRWwgPSBlbDtcbiAgZXZhbHVhdGVJdGVtcygoaXRlbXMpID0+IHtcbiAgICBpZiAoaXNOdW1lcmljMyhpdGVtcykgJiYgaXRlbXMgPj0gMCkge1xuICAgICAgaXRlbXMgPSBBcnJheS5mcm9tKEFycmF5KGl0ZW1zKS5rZXlzKCksIChpKSA9PiBpICsgMSk7XG4gICAgfVxuICAgIGlmIChpdGVtcyA9PT0gdm9pZCAwKVxuICAgICAgaXRlbXMgPSBbXTtcbiAgICBsZXQgbG9va3VwID0gZWwuX3hfbG9va3VwO1xuICAgIGxldCBwcmV2S2V5cyA9IGVsLl94X3ByZXZLZXlzO1xuICAgIGxldCBzY29wZXMgPSBbXTtcbiAgICBsZXQga2V5cyA9IFtdO1xuICAgIGlmIChpc09iamVjdDIoaXRlbXMpKSB7XG4gICAgICBpdGVtcyA9IE9iamVjdC5lbnRyaWVzKGl0ZW1zKS5tYXAoKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICBsZXQgc2NvcGUyID0gZ2V0SXRlcmF0aW9uU2NvcGVWYXJpYWJsZXMoaXRlcmF0b3JOYW1lcywgdmFsdWUsIGtleSwgaXRlbXMpO1xuICAgICAgICBldmFsdWF0ZUtleSgodmFsdWUyKSA9PiBrZXlzLnB1c2godmFsdWUyKSwge3Njb3BlOiB7aW5kZXg6IGtleSwgLi4uc2NvcGUyfX0pO1xuICAgICAgICBzY29wZXMucHVzaChzY29wZTIpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IHNjb3BlMiA9IGdldEl0ZXJhdGlvblNjb3BlVmFyaWFibGVzKGl0ZXJhdG9yTmFtZXMsIGl0ZW1zW2ldLCBpLCBpdGVtcyk7XG4gICAgICAgIGV2YWx1YXRlS2V5KCh2YWx1ZSkgPT4ga2V5cy5wdXNoKHZhbHVlKSwge3Njb3BlOiB7aW5kZXg6IGksIC4uLnNjb3BlMn19KTtcbiAgICAgICAgc2NvcGVzLnB1c2goc2NvcGUyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IGFkZHMgPSBbXTtcbiAgICBsZXQgbW92ZXMgPSBbXTtcbiAgICBsZXQgcmVtb3ZlcyA9IFtdO1xuICAgIGxldCBzYW1lcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJldktleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBrZXkgPSBwcmV2S2V5c1tpXTtcbiAgICAgIGlmIChrZXlzLmluZGV4T2Yoa2V5KSA9PT0gLTEpXG4gICAgICAgIHJlbW92ZXMucHVzaChrZXkpO1xuICAgIH1cbiAgICBwcmV2S2V5cyA9IHByZXZLZXlzLmZpbHRlcigoa2V5KSA9PiAhcmVtb3Zlcy5pbmNsdWRlcyhrZXkpKTtcbiAgICBsZXQgbGFzdEtleSA9IFwidGVtcGxhdGVcIjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBrZXkgPSBrZXlzW2ldO1xuICAgICAgbGV0IHByZXZJbmRleCA9IHByZXZLZXlzLmluZGV4T2Yoa2V5KTtcbiAgICAgIGlmIChwcmV2SW5kZXggPT09IC0xKSB7XG4gICAgICAgIHByZXZLZXlzLnNwbGljZShpLCAwLCBrZXkpO1xuICAgICAgICBhZGRzLnB1c2goW2xhc3RLZXksIGldKTtcbiAgICAgIH0gZWxzZSBpZiAocHJldkluZGV4ICE9PSBpKSB7XG4gICAgICAgIGxldCBrZXlJblNwb3QgPSBwcmV2S2V5cy5zcGxpY2UoaSwgMSlbMF07XG4gICAgICAgIGxldCBrZXlGb3JTcG90ID0gcHJldktleXMuc3BsaWNlKHByZXZJbmRleCAtIDEsIDEpWzBdO1xuICAgICAgICBwcmV2S2V5cy5zcGxpY2UoaSwgMCwga2V5Rm9yU3BvdCk7XG4gICAgICAgIHByZXZLZXlzLnNwbGljZShwcmV2SW5kZXgsIDAsIGtleUluU3BvdCk7XG4gICAgICAgIG1vdmVzLnB1c2goW2tleUluU3BvdCwga2V5Rm9yU3BvdF0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2FtZXMucHVzaChrZXkpO1xuICAgICAgfVxuICAgICAgbGFzdEtleSA9IGtleTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZW1vdmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQga2V5ID0gcmVtb3Zlc1tpXTtcbiAgICAgIGlmICghIWxvb2t1cFtrZXldLl94X2VmZmVjdHMpIHtcbiAgICAgICAgbG9va3VwW2tleV0uX3hfZWZmZWN0cy5mb3JFYWNoKGRlcXVldWVKb2IpO1xuICAgICAgfVxuICAgICAgbG9va3VwW2tleV0ucmVtb3ZlKCk7XG4gICAgICBsb29rdXBba2V5XSA9IG51bGw7XG4gICAgICBkZWxldGUgbG9va3VwW2tleV07XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbW92ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBba2V5SW5TcG90LCBrZXlGb3JTcG90XSA9IG1vdmVzW2ldO1xuICAgICAgbGV0IGVsSW5TcG90ID0gbG9va3VwW2tleUluU3BvdF07XG4gICAgICBsZXQgZWxGb3JTcG90ID0gbG9va3VwW2tleUZvclNwb3RdO1xuICAgICAgbGV0IG1hcmtlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICBtdXRhdGVEb20oKCkgPT4ge1xuICAgICAgICBlbEZvclNwb3QuYWZ0ZXIobWFya2VyKTtcbiAgICAgICAgZWxJblNwb3QuYWZ0ZXIoZWxGb3JTcG90KTtcbiAgICAgICAgZWxGb3JTcG90Ll94X2N1cnJlbnRJZkVsICYmIGVsRm9yU3BvdC5hZnRlcihlbEZvclNwb3QuX3hfY3VycmVudElmRWwpO1xuICAgICAgICBtYXJrZXIuYmVmb3JlKGVsSW5TcG90KTtcbiAgICAgICAgZWxJblNwb3QuX3hfY3VycmVudElmRWwgJiYgZWxJblNwb3QuYWZ0ZXIoZWxJblNwb3QuX3hfY3VycmVudElmRWwpO1xuICAgICAgICBtYXJrZXIucmVtb3ZlKCk7XG4gICAgICB9KTtcbiAgICAgIHJlZnJlc2hTY29wZShlbEZvclNwb3QsIHNjb3Blc1trZXlzLmluZGV4T2Yoa2V5Rm9yU3BvdCldKTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhZGRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgW2xhc3RLZXkyLCBpbmRleF0gPSBhZGRzW2ldO1xuICAgICAgbGV0IGxhc3RFbCA9IGxhc3RLZXkyID09PSBcInRlbXBsYXRlXCIgPyB0ZW1wbGF0ZUVsIDogbG9va3VwW2xhc3RLZXkyXTtcbiAgICAgIGlmIChsYXN0RWwuX3hfY3VycmVudElmRWwpXG4gICAgICAgIGxhc3RFbCA9IGxhc3RFbC5feF9jdXJyZW50SWZFbDtcbiAgICAgIGxldCBzY29wZTIgPSBzY29wZXNbaW5kZXhdO1xuICAgICAgbGV0IGtleSA9IGtleXNbaW5kZXhdO1xuICAgICAgbGV0IGNsb25lMiA9IGRvY3VtZW50LmltcG9ydE5vZGUodGVtcGxhdGVFbC5jb250ZW50LCB0cnVlKS5maXJzdEVsZW1lbnRDaGlsZDtcbiAgICAgIGFkZFNjb3BlVG9Ob2RlKGNsb25lMiwgcmVhY3RpdmUoc2NvcGUyKSwgdGVtcGxhdGVFbCk7XG4gICAgICBtdXRhdGVEb20oKCkgPT4ge1xuICAgICAgICBsYXN0RWwuYWZ0ZXIoY2xvbmUyKTtcbiAgICAgICAgaW5pdFRyZWUoY2xvbmUyKTtcbiAgICAgIH0pO1xuICAgICAgaWYgKHR5cGVvZiBrZXkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgd2FybihcIngtZm9yIGtleSBjYW5ub3QgYmUgYW4gb2JqZWN0LCBpdCBtdXN0IGJlIGEgc3RyaW5nIG9yIGFuIGludGVnZXJcIiwgdGVtcGxhdGVFbCk7XG4gICAgICB9XG4gICAgICBsb29rdXBba2V5XSA9IGNsb25lMjtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgcmVmcmVzaFNjb3BlKGxvb2t1cFtzYW1lc1tpXV0sIHNjb3Blc1trZXlzLmluZGV4T2Yoc2FtZXNbaV0pXSk7XG4gICAgfVxuICAgIHRlbXBsYXRlRWwuX3hfcHJldktleXMgPSBrZXlzO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHBhcnNlRm9yRXhwcmVzc2lvbihleHByZXNzaW9uKSB7XG4gIGxldCBmb3JJdGVyYXRvclJFID0gLywoW14sXFx9XFxdXSopKD86LChbXixcXH1cXF1dKikpPyQvO1xuICBsZXQgc3RyaXBQYXJlbnNSRSA9IC9eXFxzKlxcKHxcXClcXHMqJC9nO1xuICBsZXQgZm9yQWxpYXNSRSA9IC8oW1xcc1xcU10qPylcXHMrKD86aW58b2YpXFxzKyhbXFxzXFxTXSopLztcbiAgbGV0IGluTWF0Y2ggPSBleHByZXNzaW9uLm1hdGNoKGZvckFsaWFzUkUpO1xuICBpZiAoIWluTWF0Y2gpXG4gICAgcmV0dXJuO1xuICBsZXQgcmVzID0ge307XG4gIHJlcy5pdGVtcyA9IGluTWF0Y2hbMl0udHJpbSgpO1xuICBsZXQgaXRlbSA9IGluTWF0Y2hbMV0ucmVwbGFjZShzdHJpcFBhcmVuc1JFLCBcIlwiKS50cmltKCk7XG4gIGxldCBpdGVyYXRvck1hdGNoID0gaXRlbS5tYXRjaChmb3JJdGVyYXRvclJFKTtcbiAgaWYgKGl0ZXJhdG9yTWF0Y2gpIHtcbiAgICByZXMuaXRlbSA9IGl0ZW0ucmVwbGFjZShmb3JJdGVyYXRvclJFLCBcIlwiKS50cmltKCk7XG4gICAgcmVzLmluZGV4ID0gaXRlcmF0b3JNYXRjaFsxXS50cmltKCk7XG4gICAgaWYgKGl0ZXJhdG9yTWF0Y2hbMl0pIHtcbiAgICAgIHJlcy5jb2xsZWN0aW9uID0gaXRlcmF0b3JNYXRjaFsyXS50cmltKCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJlcy5pdGVtID0gaXRlbTtcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gZ2V0SXRlcmF0aW9uU2NvcGVWYXJpYWJsZXMoaXRlcmF0b3JOYW1lcywgaXRlbSwgaW5kZXgsIGl0ZW1zKSB7XG4gIGxldCBzY29wZVZhcmlhYmxlcyA9IHt9O1xuICBpZiAoL15cXFsuKlxcXSQvLnRlc3QoaXRlcmF0b3JOYW1lcy5pdGVtKSAmJiBBcnJheS5pc0FycmF5KGl0ZW0pKSB7XG4gICAgbGV0IG5hbWVzID0gaXRlcmF0b3JOYW1lcy5pdGVtLnJlcGxhY2UoXCJbXCIsIFwiXCIpLnJlcGxhY2UoXCJdXCIsIFwiXCIpLnNwbGl0KFwiLFwiKS5tYXAoKGkpID0+IGkudHJpbSgpKTtcbiAgICBuYW1lcy5mb3JFYWNoKChuYW1lLCBpKSA9PiB7XG4gICAgICBzY29wZVZhcmlhYmxlc1tuYW1lXSA9IGl0ZW1baV07XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoL15cXHsuKlxcfSQvLnRlc3QoaXRlcmF0b3JOYW1lcy5pdGVtKSAmJiAhQXJyYXkuaXNBcnJheShpdGVtKSAmJiB0eXBlb2YgaXRlbSA9PT0gXCJvYmplY3RcIikge1xuICAgIGxldCBuYW1lcyA9IGl0ZXJhdG9yTmFtZXMuaXRlbS5yZXBsYWNlKFwie1wiLCBcIlwiKS5yZXBsYWNlKFwifVwiLCBcIlwiKS5zcGxpdChcIixcIikubWFwKChpKSA9PiBpLnRyaW0oKSk7XG4gICAgbmFtZXMuZm9yRWFjaCgobmFtZSkgPT4ge1xuICAgICAgc2NvcGVWYXJpYWJsZXNbbmFtZV0gPSBpdGVtW25hbWVdO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHNjb3BlVmFyaWFibGVzW2l0ZXJhdG9yTmFtZXMuaXRlbV0gPSBpdGVtO1xuICB9XG4gIGlmIChpdGVyYXRvck5hbWVzLmluZGV4KVxuICAgIHNjb3BlVmFyaWFibGVzW2l0ZXJhdG9yTmFtZXMuaW5kZXhdID0gaW5kZXg7XG4gIGlmIChpdGVyYXRvck5hbWVzLmNvbGxlY3Rpb24pXG4gICAgc2NvcGVWYXJpYWJsZXNbaXRlcmF0b3JOYW1lcy5jb2xsZWN0aW9uXSA9IGl0ZW1zO1xuICByZXR1cm4gc2NvcGVWYXJpYWJsZXM7XG59XG5mdW5jdGlvbiBpc051bWVyaWMzKHN1YmplY3QpIHtcbiAgcmV0dXJuICFBcnJheS5pc0FycmF5KHN1YmplY3QpICYmICFpc05hTihzdWJqZWN0KTtcbn1cblxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL2RpcmVjdGl2ZXMveC1yZWYuanNcbmZ1bmN0aW9uIGhhbmRsZXIyKCkge1xufVxuaGFuZGxlcjIuaW5saW5lID0gKGVsLCB7ZXhwcmVzc2lvbn0sIHtjbGVhbnVwOiBjbGVhbnVwMn0pID0+IHtcbiAgbGV0IHJvb3QgPSBjbG9zZXN0Um9vdChlbCk7XG4gIGlmICghcm9vdC5feF9yZWZzKVxuICAgIHJvb3QuX3hfcmVmcyA9IHt9O1xuICByb290Ll94X3JlZnNbZXhwcmVzc2lvbl0gPSBlbDtcbiAgY2xlYW51cDIoKCkgPT4gZGVsZXRlIHJvb3QuX3hfcmVmc1tleHByZXNzaW9uXSk7XG59O1xuZGlyZWN0aXZlKFwicmVmXCIsIGhhbmRsZXIyKTtcblxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL2RpcmVjdGl2ZXMveC1pZi5qc1xuZGlyZWN0aXZlKFwiaWZcIiwgKGVsLCB7ZXhwcmVzc2lvbn0sIHtlZmZlY3Q6IGVmZmVjdDMsIGNsZWFudXA6IGNsZWFudXAyfSkgPT4ge1xuICBsZXQgZXZhbHVhdGUyID0gZXZhbHVhdGVMYXRlcihlbCwgZXhwcmVzc2lvbik7XG4gIGxldCBzaG93ID0gKCkgPT4ge1xuICAgIGlmIChlbC5feF9jdXJyZW50SWZFbClcbiAgICAgIHJldHVybiBlbC5feF9jdXJyZW50SWZFbDtcbiAgICBsZXQgY2xvbmUyID0gZWwuY29udGVudC5jbG9uZU5vZGUodHJ1ZSkuZmlyc3RFbGVtZW50Q2hpbGQ7XG4gICAgYWRkU2NvcGVUb05vZGUoY2xvbmUyLCB7fSwgZWwpO1xuICAgIG11dGF0ZURvbSgoKSA9PiB7XG4gICAgICBlbC5hZnRlcihjbG9uZTIpO1xuICAgICAgaW5pdFRyZWUoY2xvbmUyKTtcbiAgICB9KTtcbiAgICBlbC5feF9jdXJyZW50SWZFbCA9IGNsb25lMjtcbiAgICBlbC5feF91bmRvSWYgPSAoKSA9PiB7XG4gICAgICB3YWxrKGNsb25lMiwgKG5vZGUpID0+IHtcbiAgICAgICAgaWYgKCEhbm9kZS5feF9lZmZlY3RzKSB7XG4gICAgICAgICAgbm9kZS5feF9lZmZlY3RzLmZvckVhY2goZGVxdWV1ZUpvYik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgY2xvbmUyLnJlbW92ZSgpO1xuICAgICAgZGVsZXRlIGVsLl94X2N1cnJlbnRJZkVsO1xuICAgIH07XG4gICAgcmV0dXJuIGNsb25lMjtcbiAgfTtcbiAgbGV0IGhpZGUgPSAoKSA9PiB7XG4gICAgaWYgKCFlbC5feF91bmRvSWYpXG4gICAgICByZXR1cm47XG4gICAgZWwuX3hfdW5kb0lmKCk7XG4gICAgZGVsZXRlIGVsLl94X3VuZG9JZjtcbiAgfTtcbiAgZWZmZWN0MygoKSA9PiBldmFsdWF0ZTIoKHZhbHVlKSA9PiB7XG4gICAgdmFsdWUgPyBzaG93KCkgOiBoaWRlKCk7XG4gIH0pKTtcbiAgY2xlYW51cDIoKCkgPT4gZWwuX3hfdW5kb0lmICYmIGVsLl94X3VuZG9JZigpKTtcbn0pO1xuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvZGlyZWN0aXZlcy94LWlkLmpzXG5kaXJlY3RpdmUoXCJpZFwiLCAoZWwsIHtleHByZXNzaW9ufSwge2V2YWx1YXRlOiBldmFsdWF0ZTJ9KSA9PiB7XG4gIGxldCBuYW1lcyA9IGV2YWx1YXRlMihleHByZXNzaW9uKTtcbiAgbmFtZXMuZm9yRWFjaCgobmFtZSkgPT4gc2V0SWRSb290KGVsLCBuYW1lKSk7XG59KTtcblxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL2RpcmVjdGl2ZXMveC1vbi5qc1xubWFwQXR0cmlidXRlcyhzdGFydGluZ1dpdGgoXCJAXCIsIGludG8ocHJlZml4KFwib246XCIpKSkpO1xuZGlyZWN0aXZlKFwib25cIiwgc2tpcER1cmluZ0Nsb25lKChlbCwge3ZhbHVlLCBtb2RpZmllcnMsIGV4cHJlc3Npb259LCB7Y2xlYW51cDogY2xlYW51cDJ9KSA9PiB7XG4gIGxldCBldmFsdWF0ZTIgPSBleHByZXNzaW9uID8gZXZhbHVhdGVMYXRlcihlbCwgZXhwcmVzc2lvbikgOiAoKSA9PiB7XG4gIH07XG4gIGlmIChlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwidGVtcGxhdGVcIikge1xuICAgIGlmICghZWwuX3hfZm9yd2FyZEV2ZW50cylcbiAgICAgIGVsLl94X2ZvcndhcmRFdmVudHMgPSBbXTtcbiAgICBpZiAoIWVsLl94X2ZvcndhcmRFdmVudHMuaW5jbHVkZXModmFsdWUpKVxuICAgICAgZWwuX3hfZm9yd2FyZEV2ZW50cy5wdXNoKHZhbHVlKTtcbiAgfVxuICBsZXQgcmVtb3ZlTGlzdGVuZXIgPSBvbihlbCwgdmFsdWUsIG1vZGlmaWVycywgKGUpID0+IHtcbiAgICBldmFsdWF0ZTIoKCkgPT4ge1xuICAgIH0sIHtzY29wZTogeyRldmVudDogZX0sIHBhcmFtczogW2VdfSk7XG4gIH0pO1xuICBjbGVhbnVwMigoKSA9PiByZW1vdmVMaXN0ZW5lcigpKTtcbn0pKTtcblxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL2RpcmVjdGl2ZXMvaW5kZXguanNcbndhcm5NaXNzaW5nUGx1Z2luRGlyZWN0aXZlKFwiQ29sbGFwc2VcIiwgXCJjb2xsYXBzZVwiLCBcImNvbGxhcHNlXCIpO1xud2Fybk1pc3NpbmdQbHVnaW5EaXJlY3RpdmUoXCJJbnRlcnNlY3RcIiwgXCJpbnRlcnNlY3RcIiwgXCJpbnRlcnNlY3RcIik7XG53YXJuTWlzc2luZ1BsdWdpbkRpcmVjdGl2ZShcIkZvY3VzXCIsIFwidHJhcFwiLCBcImZvY3VzXCIpO1xud2Fybk1pc3NpbmdQbHVnaW5EaXJlY3RpdmUoXCJNYXNrXCIsIFwibWFza1wiLCBcIm1hc2tcIik7XG5mdW5jdGlvbiB3YXJuTWlzc2luZ1BsdWdpbkRpcmVjdGl2ZShuYW1lLCBkaXJlY3RpdmVOYW1lMiwgc2x1Zykge1xuICBkaXJlY3RpdmUoZGlyZWN0aXZlTmFtZTIsIChlbCkgPT4gd2FybihgWW91IGNhbid0IHVzZSBbeC0ke2RpcmVjdGl2ZU5hbWUyfV0gd2l0aG91dCBmaXJzdCBpbnN0YWxsaW5nIHRoZSBcIiR7bmFtZX1cIiBwbHVnaW4gaGVyZTogaHR0cHM6Ly9hbHBpbmVqcy5kZXYvcGx1Z2lucy8ke3NsdWd9YCwgZWwpKTtcbn1cblxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL2luZGV4LmpzXG5hbHBpbmVfZGVmYXVsdC5zZXRFdmFsdWF0b3Iobm9ybWFsRXZhbHVhdG9yKTtcbmFscGluZV9kZWZhdWx0LnNldFJlYWN0aXZpdHlFbmdpbmUoe3JlYWN0aXZlOiByZWFjdGl2ZTIsIGVmZmVjdDogZWZmZWN0MiwgcmVsZWFzZTogc3RvcCwgcmF3OiB0b1Jhd30pO1xudmFyIHNyY19kZWZhdWx0ID0gYWxwaW5lX2RlZmF1bHQ7XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL2J1aWxkcy9tb2R1bGUuanNcbnZhciBtb2R1bGVfZGVmYXVsdCA9IHNyY19kZWZhdWx0O1xuZXhwb3J0IHtcbiAgbW9kdWxlX2RlZmF1bHQgYXMgZGVmYXVsdFxufTtcbiIsICIvLyBwYWNrYWdlcy9wZXJzaXN0L3NyYy9pbmRleC5qc1xuZnVuY3Rpb24gc3JjX2RlZmF1bHQoQWxwaW5lKSB7XG4gIGxldCBwZXJzaXN0ID0gKCkgPT4ge1xuICAgIGxldCBhbGlhcztcbiAgICBsZXQgc3RvcmFnZSA9IGxvY2FsU3RvcmFnZTtcbiAgICByZXR1cm4gQWxwaW5lLmludGVyY2VwdG9yKChpbml0aWFsVmFsdWUsIGdldHRlciwgc2V0dGVyLCBwYXRoLCBrZXkpID0+IHtcbiAgICAgIGxldCBsb29rdXAgPSBhbGlhcyB8fCBgX3hfJHtwYXRofWA7XG4gICAgICBsZXQgaW5pdGlhbCA9IHN0b3JhZ2VIYXMobG9va3VwLCBzdG9yYWdlKSA/IHN0b3JhZ2VHZXQobG9va3VwLCBzdG9yYWdlKSA6IGluaXRpYWxWYWx1ZTtcbiAgICAgIHNldHRlcihpbml0aWFsKTtcbiAgICAgIEFscGluZS5lZmZlY3QoKCkgPT4ge1xuICAgICAgICBsZXQgdmFsdWUgPSBnZXR0ZXIoKTtcbiAgICAgICAgc3RvcmFnZVNldChsb29rdXAsIHZhbHVlLCBzdG9yYWdlKTtcbiAgICAgICAgc2V0dGVyKHZhbHVlKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGluaXRpYWw7XG4gICAgfSwgKGZ1bmMpID0+IHtcbiAgICAgIGZ1bmMuYXMgPSAoa2V5KSA9PiB7XG4gICAgICAgIGFsaWFzID0ga2V5O1xuICAgICAgICByZXR1cm4gZnVuYztcbiAgICAgIH0sIGZ1bmMudXNpbmcgPSAodGFyZ2V0KSA9PiB7XG4gICAgICAgIHN0b3JhZ2UgPSB0YXJnZXQ7XG4gICAgICAgIHJldHVybiBmdW5jO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFscGluZSwgXCIkcGVyc2lzdFwiLCB7Z2V0OiAoKSA9PiBwZXJzaXN0KCl9KTtcbiAgQWxwaW5lLm1hZ2ljKFwicGVyc2lzdFwiLCBwZXJzaXN0KTtcbn1cbmZ1bmN0aW9uIHN0b3JhZ2VIYXMoa2V5LCBzdG9yYWdlKSB7XG4gIHJldHVybiBzdG9yYWdlLmdldEl0ZW0oa2V5KSAhPT0gbnVsbDtcbn1cbmZ1bmN0aW9uIHN0b3JhZ2VHZXQoa2V5LCBzdG9yYWdlKSB7XG4gIHJldHVybiBKU09OLnBhcnNlKHN0b3JhZ2UuZ2V0SXRlbShrZXksIHN0b3JhZ2UpKTtcbn1cbmZ1bmN0aW9uIHN0b3JhZ2VTZXQoa2V5LCB2YWx1ZSwgc3RvcmFnZSkge1xuICBzdG9yYWdlLnNldEl0ZW0oa2V5LCBKU09OLnN0cmluZ2lmeSh2YWx1ZSkpO1xufVxuXG4vLyBwYWNrYWdlcy9wZXJzaXN0L2J1aWxkcy9tb2R1bGUuanNcbnZhciBtb2R1bGVfZGVmYXVsdCA9IHNyY19kZWZhdWx0O1xuZXhwb3J0IHtcbiAgbW9kdWxlX2RlZmF1bHQgYXMgZGVmYXVsdFxufTtcbiIsICJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB0b0ludGVnZXIoZGlydHlOdW1iZXIpIHtcbiAgaWYgKGRpcnR5TnVtYmVyID09PSBudWxsIHx8IGRpcnR5TnVtYmVyID09PSB0cnVlIHx8IGRpcnR5TnVtYmVyID09PSBmYWxzZSkge1xuICAgIHJldHVybiBOYU47XG4gIH1cblxuICB2YXIgbnVtYmVyID0gTnVtYmVyKGRpcnR5TnVtYmVyKTtcblxuICBpZiAoaXNOYU4obnVtYmVyKSkge1xuICAgIHJldHVybiBudW1iZXI7XG4gIH1cblxuICByZXR1cm4gbnVtYmVyIDwgMCA/IE1hdGguY2VpbChudW1iZXIpIDogTWF0aC5mbG9vcihudW1iZXIpO1xufSIsICJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiByZXF1aXJlZEFyZ3MocmVxdWlyZWQsIGFyZ3MpIHtcbiAgaWYgKGFyZ3MubGVuZ3RoIDwgcmVxdWlyZWQpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHJlcXVpcmVkICsgJyBhcmd1bWVudCcgKyAocmVxdWlyZWQgPiAxID8gJ3MnIDogJycpICsgJyByZXF1aXJlZCwgYnV0IG9ubHkgJyArIGFyZ3MubGVuZ3RoICsgJyBwcmVzZW50Jyk7XG4gIH1cbn0iLCAiaW1wb3J0IHJlcXVpcmVkQXJncyBmcm9tIFwiLi4vX2xpYi9yZXF1aXJlZEFyZ3MvaW5kZXguanNcIjtcbi8qKlxuICogQG5hbWUgdG9EYXRlXG4gKiBAY2F0ZWdvcnkgQ29tbW9uIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IENvbnZlcnQgdGhlIGdpdmVuIGFyZ3VtZW50IHRvIGFuIGluc3RhbmNlIG9mIERhdGUuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBDb252ZXJ0IHRoZSBnaXZlbiBhcmd1bWVudCB0byBhbiBpbnN0YW5jZSBvZiBEYXRlLlxuICpcbiAqIElmIHRoZSBhcmd1bWVudCBpcyBhbiBpbnN0YW5jZSBvZiBEYXRlLCB0aGUgZnVuY3Rpb24gcmV0dXJucyBpdHMgY2xvbmUuXG4gKlxuICogSWYgdGhlIGFyZ3VtZW50IGlzIGEgbnVtYmVyLCBpdCBpcyB0cmVhdGVkIGFzIGEgdGltZXN0YW1wLlxuICpcbiAqIElmIHRoZSBhcmd1bWVudCBpcyBub25lIG9mIHRoZSBhYm92ZSwgdGhlIGZ1bmN0aW9uIHJldHVybnMgSW52YWxpZCBEYXRlLlxuICpcbiAqICoqTm90ZSoqOiAqYWxsKiBEYXRlIGFyZ3VtZW50cyBwYXNzZWQgdG8gYW55ICpkYXRlLWZucyogZnVuY3Rpb24gaXMgcHJvY2Vzc2VkIGJ5IGB0b0RhdGVgLlxuICpcbiAqIEBwYXJhbSB7RGF0ZXxOdW1iZXJ9IGFyZ3VtZW50IC0gdGhlIHZhbHVlIHRvIGNvbnZlcnRcbiAqIEByZXR1cm5zIHtEYXRlfSB0aGUgcGFyc2VkIGRhdGUgaW4gdGhlIGxvY2FsIHRpbWUgem9uZVxuICogQHRocm93cyB7VHlwZUVycm9yfSAxIGFyZ3VtZW50IHJlcXVpcmVkXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIENsb25lIHRoZSBkYXRlOlxuICogY29uc3QgcmVzdWx0ID0gdG9EYXRlKG5ldyBEYXRlKDIwMTQsIDEsIDExLCAxMSwgMzAsIDMwKSlcbiAqIC8vPT4gVHVlIEZlYiAxMSAyMDE0IDExOjMwOjMwXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIENvbnZlcnQgdGhlIHRpbWVzdGFtcCB0byBkYXRlOlxuICogY29uc3QgcmVzdWx0ID0gdG9EYXRlKDEzOTIwOTg0MzAwMDApXG4gKiAvLz0+IFR1ZSBGZWIgMTEgMjAxNCAxMTozMDozMFxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHRvRGF0ZShhcmd1bWVudCkge1xuICByZXF1aXJlZEFyZ3MoMSwgYXJndW1lbnRzKTtcbiAgdmFyIGFyZ1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcmd1bWVudCk7IC8vIENsb25lIHRoZSBkYXRlXG5cbiAgaWYgKGFyZ3VtZW50IGluc3RhbmNlb2YgRGF0ZSB8fCB0eXBlb2YgYXJndW1lbnQgPT09ICdvYmplY3QnICYmIGFyZ1N0ciA9PT0gJ1tvYmplY3QgRGF0ZV0nKSB7XG4gICAgLy8gUHJldmVudCB0aGUgZGF0ZSB0byBsb3NlIHRoZSBtaWxsaXNlY29uZHMgd2hlbiBwYXNzZWQgdG8gbmV3IERhdGUoKSBpbiBJRTEwXG4gICAgcmV0dXJuIG5ldyBEYXRlKGFyZ3VtZW50LmdldFRpbWUoKSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGFyZ3VtZW50ID09PSAnbnVtYmVyJyB8fCBhcmdTdHIgPT09ICdbb2JqZWN0IE51bWJlcl0nKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKGFyZ3VtZW50KTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoKHR5cGVvZiBhcmd1bWVudCA9PT0gJ3N0cmluZycgfHwgYXJnU3RyID09PSAnW29iamVjdCBTdHJpbmddJykgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgY29uc29sZS53YXJuKFwiU3RhcnRpbmcgd2l0aCB2Mi4wLjAtYmV0YS4xIGRhdGUtZm5zIGRvZXNuJ3QgYWNjZXB0IHN0cmluZ3MgYXMgZGF0ZSBhcmd1bWVudHMuIFBsZWFzZSB1c2UgYHBhcnNlSVNPYCB0byBwYXJzZSBzdHJpbmdzLiBTZWU6IGh0dHBzOi8vZ2l0LmlvL2ZqdWxlXCIpOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuXG4gICAgICBjb25zb2xlLndhcm4obmV3IEVycm9yKCkuc3RhY2spO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgRGF0ZShOYU4pO1xuICB9XG59IiwgIi8qKlxuICogR29vZ2xlIENocm9tZSBhcyBvZiA2Ny4wLjMzOTYuODcgaW50cm9kdWNlZCB0aW1lem9uZXMgd2l0aCBvZmZzZXQgdGhhdCBpbmNsdWRlcyBzZWNvbmRzLlxuICogVGhleSB1c3VhbGx5IGFwcGVhciBmb3IgZGF0ZXMgdGhhdCBkZW5vdGUgdGltZSBiZWZvcmUgdGhlIHRpbWV6b25lcyB3ZXJlIGludHJvZHVjZWRcbiAqIChlLmcuIGZvciAnRXVyb3BlL1ByYWd1ZScgdGltZXpvbmUgdGhlIG9mZnNldCBpcyBHTVQrMDA6NTc6NDQgYmVmb3JlIDEgT2N0b2JlciAxODkxXG4gKiBhbmQgR01UKzAxOjAwOjAwIGFmdGVyIHRoYXQgZGF0ZSlcbiAqXG4gKiBEYXRlI2dldFRpbWV6b25lT2Zmc2V0IHJldHVybnMgdGhlIG9mZnNldCBpbiBtaW51dGVzIGFuZCB3b3VsZCByZXR1cm4gNTcgZm9yIHRoZSBleGFtcGxlIGFib3ZlLFxuICogd2hpY2ggd291bGQgbGVhZCB0byBpbmNvcnJlY3QgY2FsY3VsYXRpb25zLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gcmV0dXJucyB0aGUgdGltZXpvbmUgb2Zmc2V0IGluIG1pbGxpc2Vjb25kcyB0aGF0IHRha2VzIHNlY29uZHMgaW4gYWNjb3VudC5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0VGltZXpvbmVPZmZzZXRJbk1pbGxpc2Vjb25kcyhkYXRlKSB7XG4gIHZhciB1dGNEYXRlID0gbmV3IERhdGUoRGF0ZS5VVEMoZGF0ZS5nZXRGdWxsWWVhcigpLCBkYXRlLmdldE1vbnRoKCksIGRhdGUuZ2V0RGF0ZSgpLCBkYXRlLmdldEhvdXJzKCksIGRhdGUuZ2V0TWludXRlcygpLCBkYXRlLmdldFNlY29uZHMoKSwgZGF0ZS5nZXRNaWxsaXNlY29uZHMoKSkpO1xuICB1dGNEYXRlLnNldFVUQ0Z1bGxZZWFyKGRhdGUuZ2V0RnVsbFllYXIoKSk7XG4gIHJldHVybiBkYXRlLmdldFRpbWUoKSAtIHV0Y0RhdGUuZ2V0VGltZSgpO1xufSIsICJpbXBvcnQgdG9EYXRlIGZyb20gXCIuLi90b0RhdGUvaW5kZXguanNcIjtcbmltcG9ydCByZXF1aXJlZEFyZ3MgZnJvbSBcIi4uL19saWIvcmVxdWlyZWRBcmdzL2luZGV4LmpzXCI7XG4vKipcbiAqIEBuYW1lIGNvbXBhcmVBc2NcbiAqIEBjYXRlZ29yeSBDb21tb24gSGVscGVyc1xuICogQHN1bW1hcnkgQ29tcGFyZSB0aGUgdHdvIGRhdGVzIGFuZCByZXR1cm4gLTEsIDAgb3IgMS5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIENvbXBhcmUgdGhlIHR3byBkYXRlcyBhbmQgcmV0dXJuIDEgaWYgdGhlIGZpcnN0IGRhdGUgaXMgYWZ0ZXIgdGhlIHNlY29uZCxcbiAqIC0xIGlmIHRoZSBmaXJzdCBkYXRlIGlzIGJlZm9yZSB0aGUgc2Vjb25kIG9yIDAgaWYgZGF0ZXMgYXJlIGVxdWFsLlxuICpcbiAqICMjIyB2Mi4wLjAgYnJlYWtpbmcgY2hhbmdlczpcbiAqXG4gKiAtIFtDaGFuZ2VzIHRoYXQgYXJlIGNvbW1vbiBmb3IgdGhlIHdob2xlIGxpYnJhcnldKGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy9kYXRlLWZucy9ibG9iL21hc3Rlci9kb2NzL3VwZ3JhZGVHdWlkZS5tZCNDb21tb24tQ2hhbmdlcykuXG4gKlxuICogQHBhcmFtIHtEYXRlfE51bWJlcn0gZGF0ZUxlZnQgLSB0aGUgZmlyc3QgZGF0ZSB0byBjb21wYXJlXG4gKiBAcGFyYW0ge0RhdGV8TnVtYmVyfSBkYXRlUmlnaHQgLSB0aGUgc2Vjb25kIGRhdGUgdG8gY29tcGFyZVxuICogQHJldHVybnMge051bWJlcn0gdGhlIHJlc3VsdCBvZiB0aGUgY29tcGFyaXNvblxuICogQHRocm93cyB7VHlwZUVycm9yfSAyIGFyZ3VtZW50cyByZXF1aXJlZFxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBDb21wYXJlIDExIEZlYnJ1YXJ5IDE5ODcgYW5kIDEwIEp1bHkgMTk4OTpcbiAqIGNvbnN0IHJlc3VsdCA9IGNvbXBhcmVBc2MobmV3IERhdGUoMTk4NywgMSwgMTEpLCBuZXcgRGF0ZSgxOTg5LCA2LCAxMCkpXG4gKiAvLz0+IC0xXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFNvcnQgdGhlIGFycmF5IG9mIGRhdGVzOlxuICogY29uc3QgcmVzdWx0ID0gW1xuICogICBuZXcgRGF0ZSgxOTk1LCA2LCAyKSxcbiAqICAgbmV3IERhdGUoMTk4NywgMSwgMTEpLFxuICogICBuZXcgRGF0ZSgxOTg5LCA2LCAxMClcbiAqIF0uc29ydChjb21wYXJlQXNjKVxuICogLy89PiBbXG4gKiAvLyAgIFdlZCBGZWIgMTEgMTk4NyAwMDowMDowMCxcbiAqIC8vICAgTW9uIEp1bCAxMCAxOTg5IDAwOjAwOjAwLFxuICogLy8gICBTdW4gSnVsIDAyIDE5OTUgMDA6MDA6MDBcbiAqIC8vIF1cbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb21wYXJlQXNjKGRpcnR5RGF0ZUxlZnQsIGRpcnR5RGF0ZVJpZ2h0KSB7XG4gIHJlcXVpcmVkQXJncygyLCBhcmd1bWVudHMpO1xuICB2YXIgZGF0ZUxlZnQgPSB0b0RhdGUoZGlydHlEYXRlTGVmdCk7XG4gIHZhciBkYXRlUmlnaHQgPSB0b0RhdGUoZGlydHlEYXRlUmlnaHQpO1xuICB2YXIgZGlmZiA9IGRhdGVMZWZ0LmdldFRpbWUoKSAtIGRhdGVSaWdodC5nZXRUaW1lKCk7XG5cbiAgaWYgKGRpZmYgPCAwKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9IGVsc2UgaWYgKGRpZmYgPiAwKSB7XG4gICAgcmV0dXJuIDE7IC8vIFJldHVybiAwIGlmIGRpZmYgaXMgMDsgcmV0dXJuIE5hTiBpZiBkaWZmIGlzIE5hTlxuICB9IGVsc2Uge1xuICAgIHJldHVybiBkaWZmO1xuICB9XG59IiwgIi8qKlxuICogRGF5cyBpbiAxIHdlZWsuXG4gKlxuICogQG5hbWUgZGF5c0luV2Vla1xuICogQGNvbnN0YW50XG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGRlZmF1bHRcbiAqL1xuZXhwb3J0IHZhciBkYXlzSW5XZWVrID0gNztcbi8qKlxuICogTWF4aW11bSBhbGxvd2VkIHRpbWUuXG4gKlxuICogQG5hbWUgbWF4VGltZVxuICogQGNvbnN0YW50XG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGRlZmF1bHRcbiAqL1xuXG5leHBvcnQgdmFyIG1heFRpbWUgPSBNYXRoLnBvdygxMCwgOCkgKiAyNCAqIDYwICogNjAgKiAxMDAwO1xuLyoqXG4gKiBNaWxsaXNlY29uZHMgaW4gMSBtaW51dGVcbiAqXG4gKiBAbmFtZSBtaWxsaXNlY29uZHNJbk1pbnV0ZVxuICogQGNvbnN0YW50XG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGRlZmF1bHRcbiAqL1xuXG5leHBvcnQgdmFyIG1pbGxpc2Vjb25kc0luTWludXRlID0gNjAwMDA7XG4vKipcbiAqIE1pbGxpc2Vjb25kcyBpbiAxIGhvdXJcbiAqXG4gKiBAbmFtZSBtaWxsaXNlY29uZHNJbkhvdXJcbiAqIEBjb25zdGFudFxuICogQHR5cGUge251bWJlcn1cbiAqIEBkZWZhdWx0XG4gKi9cblxuZXhwb3J0IHZhciBtaWxsaXNlY29uZHNJbkhvdXIgPSAzNjAwMDAwO1xuLyoqXG4gKiBNaWxsaXNlY29uZHMgaW4gMSBzZWNvbmRcbiAqXG4gKiBAbmFtZSBtaWxsaXNlY29uZHNJblNlY29uZFxuICogQGNvbnN0YW50XG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGRlZmF1bHRcbiAqL1xuXG5leHBvcnQgdmFyIG1pbGxpc2Vjb25kc0luU2Vjb25kID0gMTAwMDtcbi8qKlxuICogTWluaW11bSBhbGxvd2VkIHRpbWUuXG4gKlxuICogQG5hbWUgbWluVGltZVxuICogQGNvbnN0YW50XG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGRlZmF1bHRcbiAqL1xuXG5leHBvcnQgdmFyIG1pblRpbWUgPSAtbWF4VGltZTtcbi8qKlxuICogTWludXRlcyBpbiAxIGhvdXJcbiAqXG4gKiBAbmFtZSBtaW51dGVzSW5Ib3VyXG4gKiBAY29uc3RhbnRcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAZGVmYXVsdFxuICovXG5cbmV4cG9ydCB2YXIgbWludXRlc0luSG91ciA9IDYwO1xuLyoqXG4gKiBNb250aHMgaW4gMSBxdWFydGVyXG4gKlxuICogQG5hbWUgbW9udGhzSW5RdWFydGVyXG4gKiBAY29uc3RhbnRcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAZGVmYXVsdFxuICovXG5cbmV4cG9ydCB2YXIgbW9udGhzSW5RdWFydGVyID0gMztcbi8qKlxuICogTW9udGhzIGluIDEgeWVhclxuICpcbiAqIEBuYW1lIG1vbnRoc0luWWVhclxuICogQGNvbnN0YW50XG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGRlZmF1bHRcbiAqL1xuXG5leHBvcnQgdmFyIG1vbnRoc0luWWVhciA9IDEyO1xuLyoqXG4gKiBRdWFydGVycyBpbiAxIHllYXJcbiAqXG4gKiBAbmFtZSBxdWFydGVyc0luWWVhclxuICogQGNvbnN0YW50XG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGRlZmF1bHRcbiAqL1xuXG5leHBvcnQgdmFyIHF1YXJ0ZXJzSW5ZZWFyID0gNDtcbi8qKlxuICogU2Vjb25kcyBpbiAxIGhvdXJcbiAqXG4gKiBAbmFtZSBzZWNvbmRzSW5Ib3VyXG4gKiBAY29uc3RhbnRcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAZGVmYXVsdFxuICovXG5cbmV4cG9ydCB2YXIgc2Vjb25kc0luSG91ciA9IDM2MDA7XG4vKipcbiAqIFNlY29uZHMgaW4gMSBtaW51dGVcbiAqXG4gKiBAbmFtZSBzZWNvbmRzSW5NaW51dGVcbiAqIEBjb25zdGFudFxuICogQHR5cGUge251bWJlcn1cbiAqIEBkZWZhdWx0XG4gKi9cblxuZXhwb3J0IHZhciBzZWNvbmRzSW5NaW51dGUgPSA2MDsiLCAiaW1wb3J0IHRvRGF0ZSBmcm9tIFwiLi4vdG9EYXRlL2luZGV4LmpzXCI7XG5pbXBvcnQgcmVxdWlyZWRBcmdzIGZyb20gXCIuLi9fbGliL3JlcXVpcmVkQXJncy9pbmRleC5qc1wiO1xuLyoqXG4gKiBAbmFtZSBkaWZmZXJlbmNlSW5DYWxlbmRhck1vbnRoc1xuICogQGNhdGVnb3J5IE1vbnRoIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IEdldCB0aGUgbnVtYmVyIG9mIGNhbGVuZGFyIG1vbnRocyBiZXR3ZWVuIHRoZSBnaXZlbiBkYXRlcy5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIEdldCB0aGUgbnVtYmVyIG9mIGNhbGVuZGFyIG1vbnRocyBiZXR3ZWVuIHRoZSBnaXZlbiBkYXRlcy5cbiAqXG4gKiAjIyMgdjIuMC4wIGJyZWFraW5nIGNoYW5nZXM6XG4gKlxuICogLSBbQ2hhbmdlcyB0aGF0IGFyZSBjb21tb24gZm9yIHRoZSB3aG9sZSBsaWJyYXJ5XShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvZGF0ZS1mbnMvYmxvYi9tYXN0ZXIvZG9jcy91cGdyYWRlR3VpZGUubWQjQ29tbW9uLUNoYW5nZXMpLlxuICpcbiAqIEBwYXJhbSB7RGF0ZXxOdW1iZXJ9IGRhdGVMZWZ0IC0gdGhlIGxhdGVyIGRhdGVcbiAqIEBwYXJhbSB7RGF0ZXxOdW1iZXJ9IGRhdGVSaWdodCAtIHRoZSBlYXJsaWVyIGRhdGVcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHRoZSBudW1iZXIgb2YgY2FsZW5kYXIgbW9udGhzXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IDIgYXJndW1lbnRzIHJlcXVpcmVkXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIEhvdyBtYW55IGNhbGVuZGFyIG1vbnRocyBhcmUgYmV0d2VlbiAzMSBKYW51YXJ5IDIwMTQgYW5kIDEgU2VwdGVtYmVyIDIwMTQ/XG4gKiB2YXIgcmVzdWx0ID0gZGlmZmVyZW5jZUluQ2FsZW5kYXJNb250aHMoXG4gKiAgIG5ldyBEYXRlKDIwMTQsIDgsIDEpLFxuICogICBuZXcgRGF0ZSgyMDE0LCAwLCAzMSlcbiAqIClcbiAqIC8vPT4gOFxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGRpZmZlcmVuY2VJbkNhbGVuZGFyTW9udGhzKGRpcnR5RGF0ZUxlZnQsIGRpcnR5RGF0ZVJpZ2h0KSB7XG4gIHJlcXVpcmVkQXJncygyLCBhcmd1bWVudHMpO1xuICB2YXIgZGF0ZUxlZnQgPSB0b0RhdGUoZGlydHlEYXRlTGVmdCk7XG4gIHZhciBkYXRlUmlnaHQgPSB0b0RhdGUoZGlydHlEYXRlUmlnaHQpO1xuICB2YXIgeWVhckRpZmYgPSBkYXRlTGVmdC5nZXRGdWxsWWVhcigpIC0gZGF0ZVJpZ2h0LmdldEZ1bGxZZWFyKCk7XG4gIHZhciBtb250aERpZmYgPSBkYXRlTGVmdC5nZXRNb250aCgpIC0gZGF0ZVJpZ2h0LmdldE1vbnRoKCk7XG4gIHJldHVybiB5ZWFyRGlmZiAqIDEyICsgbW9udGhEaWZmO1xufSIsICJpbXBvcnQgdG9EYXRlIGZyb20gXCIuLi90b0RhdGUvaW5kZXguanNcIjtcbmltcG9ydCByZXF1aXJlZEFyZ3MgZnJvbSBcIi4uL19saWIvcmVxdWlyZWRBcmdzL2luZGV4LmpzXCI7XG4vKipcbiAqIEBuYW1lIGRpZmZlcmVuY2VJbk1pbGxpc2Vjb25kc1xuICogQGNhdGVnb3J5IE1pbGxpc2Vjb25kIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IEdldCB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBiZXR3ZWVuIHRoZSBnaXZlbiBkYXRlcy5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIEdldCB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBiZXR3ZWVuIHRoZSBnaXZlbiBkYXRlcy5cbiAqXG4gKiAjIyMgdjIuMC4wIGJyZWFraW5nIGNoYW5nZXM6XG4gKlxuICogLSBbQ2hhbmdlcyB0aGF0IGFyZSBjb21tb24gZm9yIHRoZSB3aG9sZSBsaWJyYXJ5XShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvZGF0ZS1mbnMvYmxvYi9tYXN0ZXIvZG9jcy91cGdyYWRlR3VpZGUubWQjQ29tbW9uLUNoYW5nZXMpLlxuICpcbiAqIEBwYXJhbSB7RGF0ZXxOdW1iZXJ9IGRhdGVMZWZ0IC0gdGhlIGxhdGVyIGRhdGVcbiAqIEBwYXJhbSB7RGF0ZXxOdW1iZXJ9IGRhdGVSaWdodCAtIHRoZSBlYXJsaWVyIGRhdGVcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IDIgYXJndW1lbnRzIHJlcXVpcmVkXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIEhvdyBtYW55IG1pbGxpc2Vjb25kcyBhcmUgYmV0d2VlblxuICogLy8gMiBKdWx5IDIwMTQgMTI6MzA6MjAuNjAwIGFuZCAyIEp1bHkgMjAxNCAxMjozMDoyMS43MDA/XG4gKiBjb25zdCByZXN1bHQgPSBkaWZmZXJlbmNlSW5NaWxsaXNlY29uZHMoXG4gKiAgIG5ldyBEYXRlKDIwMTQsIDYsIDIsIDEyLCAzMCwgMjEsIDcwMCksXG4gKiAgIG5ldyBEYXRlKDIwMTQsIDYsIDIsIDEyLCAzMCwgMjAsIDYwMClcbiAqIClcbiAqIC8vPT4gMTEwMFxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGRpZmZlcmVuY2VJbk1pbGxpc2Vjb25kcyhkYXRlTGVmdCwgZGF0ZVJpZ2h0KSB7XG4gIHJlcXVpcmVkQXJncygyLCBhcmd1bWVudHMpO1xuICByZXR1cm4gdG9EYXRlKGRhdGVMZWZ0KS5nZXRUaW1lKCkgLSB0b0RhdGUoZGF0ZVJpZ2h0KS5nZXRUaW1lKCk7XG59IiwgInZhciByb3VuZGluZ01hcCA9IHtcbiAgY2VpbDogTWF0aC5jZWlsLFxuICByb3VuZDogTWF0aC5yb3VuZCxcbiAgZmxvb3I6IE1hdGguZmxvb3IsXG4gIHRydW5jOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPCAwID8gTWF0aC5jZWlsKHZhbHVlKSA6IE1hdGguZmxvb3IodmFsdWUpO1xuICB9IC8vIE1hdGgudHJ1bmMgaXMgbm90IHN1cHBvcnRlZCBieSBJRVxuXG59O1xudmFyIGRlZmF1bHRSb3VuZGluZ01ldGhvZCA9ICd0cnVuYyc7XG5leHBvcnQgZnVuY3Rpb24gZ2V0Um91bmRpbmdNZXRob2QobWV0aG9kKSB7XG4gIHJldHVybiBtZXRob2QgPyByb3VuZGluZ01hcFttZXRob2RdIDogcm91bmRpbmdNYXBbZGVmYXVsdFJvdW5kaW5nTWV0aG9kXTtcbn0iLCAiaW1wb3J0IHRvRGF0ZSBmcm9tIFwiLi4vdG9EYXRlL2luZGV4LmpzXCI7XG5pbXBvcnQgcmVxdWlyZWRBcmdzIGZyb20gXCIuLi9fbGliL3JlcXVpcmVkQXJncy9pbmRleC5qc1wiO1xuLyoqXG4gKiBAbmFtZSBlbmRPZkRheVxuICogQGNhdGVnb3J5IERheSBIZWxwZXJzXG4gKiBAc3VtbWFyeSBSZXR1cm4gdGhlIGVuZCBvZiBhIGRheSBmb3IgdGhlIGdpdmVuIGRhdGUuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBSZXR1cm4gdGhlIGVuZCBvZiBhIGRheSBmb3IgdGhlIGdpdmVuIGRhdGUuXG4gKiBUaGUgcmVzdWx0IHdpbGwgYmUgaW4gdGhlIGxvY2FsIHRpbWV6b25lLlxuICpcbiAqICMjIyB2Mi4wLjAgYnJlYWtpbmcgY2hhbmdlczpcbiAqXG4gKiAtIFtDaGFuZ2VzIHRoYXQgYXJlIGNvbW1vbiBmb3IgdGhlIHdob2xlIGxpYnJhcnldKGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy9kYXRlLWZucy9ibG9iL21hc3Rlci9kb2NzL3VwZ3JhZGVHdWlkZS5tZCNDb21tb24tQ2hhbmdlcykuXG4gKlxuICogQHBhcmFtIHtEYXRlfE51bWJlcn0gZGF0ZSAtIHRoZSBvcmlnaW5hbCBkYXRlXG4gKiBAcmV0dXJucyB7RGF0ZX0gdGhlIGVuZCBvZiBhIGRheVxuICogQHRocm93cyB7VHlwZUVycm9yfSAxIGFyZ3VtZW50IHJlcXVpcmVkXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFRoZSBlbmQgb2YgYSBkYXkgZm9yIDIgU2VwdGVtYmVyIDIwMTQgMTE6NTU6MDA6XG4gKiBjb25zdCByZXN1bHQgPSBlbmRPZkRheShuZXcgRGF0ZSgyMDE0LCA4LCAyLCAxMSwgNTUsIDApKVxuICogLy89PiBUdWUgU2VwIDAyIDIwMTQgMjM6NTk6NTkuOTk5XG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZW5kT2ZEYXkoZGlydHlEYXRlKSB7XG4gIHJlcXVpcmVkQXJncygxLCBhcmd1bWVudHMpO1xuICB2YXIgZGF0ZSA9IHRvRGF0ZShkaXJ0eURhdGUpO1xuICBkYXRlLnNldEhvdXJzKDIzLCA1OSwgNTksIDk5OSk7XG4gIHJldHVybiBkYXRlO1xufSIsICJpbXBvcnQgdG9EYXRlIGZyb20gXCIuLi90b0RhdGUvaW5kZXguanNcIjtcbmltcG9ydCByZXF1aXJlZEFyZ3MgZnJvbSBcIi4uL19saWIvcmVxdWlyZWRBcmdzL2luZGV4LmpzXCI7XG4vKipcbiAqIEBuYW1lIGVuZE9mTW9udGhcbiAqIEBjYXRlZ29yeSBNb250aCBIZWxwZXJzXG4gKiBAc3VtbWFyeSBSZXR1cm4gdGhlIGVuZCBvZiBhIG1vbnRoIGZvciB0aGUgZ2l2ZW4gZGF0ZS5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFJldHVybiB0aGUgZW5kIG9mIGEgbW9udGggZm9yIHRoZSBnaXZlbiBkYXRlLlxuICogVGhlIHJlc3VsdCB3aWxsIGJlIGluIHRoZSBsb2NhbCB0aW1lem9uZS5cbiAqXG4gKiAjIyMgdjIuMC4wIGJyZWFraW5nIGNoYW5nZXM6XG4gKlxuICogLSBbQ2hhbmdlcyB0aGF0IGFyZSBjb21tb24gZm9yIHRoZSB3aG9sZSBsaWJyYXJ5XShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvZGF0ZS1mbnMvYmxvYi9tYXN0ZXIvZG9jcy91cGdyYWRlR3VpZGUubWQjQ29tbW9uLUNoYW5nZXMpLlxuICpcbiAqIEBwYXJhbSB7RGF0ZXxOdW1iZXJ9IGRhdGUgLSB0aGUgb3JpZ2luYWwgZGF0ZVxuICogQHJldHVybnMge0RhdGV9IHRoZSBlbmQgb2YgYSBtb250aFxuICogQHRocm93cyB7VHlwZUVycm9yfSAxIGFyZ3VtZW50IHJlcXVpcmVkXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFRoZSBlbmQgb2YgYSBtb250aCBmb3IgMiBTZXB0ZW1iZXIgMjAxNCAxMTo1NTowMDpcbiAqIGNvbnN0IHJlc3VsdCA9IGVuZE9mTW9udGgobmV3IERhdGUoMjAxNCwgOCwgMiwgMTEsIDU1LCAwKSlcbiAqIC8vPT4gVHVlIFNlcCAzMCAyMDE0IDIzOjU5OjU5Ljk5OVxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGVuZE9mTW9udGgoZGlydHlEYXRlKSB7XG4gIHJlcXVpcmVkQXJncygxLCBhcmd1bWVudHMpO1xuICB2YXIgZGF0ZSA9IHRvRGF0ZShkaXJ0eURhdGUpO1xuICB2YXIgbW9udGggPSBkYXRlLmdldE1vbnRoKCk7XG4gIGRhdGUuc2V0RnVsbFllYXIoZGF0ZS5nZXRGdWxsWWVhcigpLCBtb250aCArIDEsIDApO1xuICBkYXRlLnNldEhvdXJzKDIzLCA1OSwgNTksIDk5OSk7XG4gIHJldHVybiBkYXRlO1xufSIsICJpbXBvcnQgdG9EYXRlIGZyb20gXCIuLi90b0RhdGUvaW5kZXguanNcIjtcbmltcG9ydCBlbmRPZkRheSBmcm9tIFwiLi4vZW5kT2ZEYXkvaW5kZXguanNcIjtcbmltcG9ydCBlbmRPZk1vbnRoIGZyb20gXCIuLi9lbmRPZk1vbnRoL2luZGV4LmpzXCI7XG5pbXBvcnQgcmVxdWlyZWRBcmdzIGZyb20gXCIuLi9fbGliL3JlcXVpcmVkQXJncy9pbmRleC5qc1wiO1xuLyoqXG4gKiBAbmFtZSBpc0xhc3REYXlPZk1vbnRoXG4gKiBAY2F0ZWdvcnkgTW9udGggSGVscGVyc1xuICogQHN1bW1hcnkgSXMgdGhlIGdpdmVuIGRhdGUgdGhlIGxhc3QgZGF5IG9mIGEgbW9udGg/XG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBJcyB0aGUgZ2l2ZW4gZGF0ZSB0aGUgbGFzdCBkYXkgb2YgYSBtb250aD9cbiAqXG4gKiAjIyMgdjIuMC4wIGJyZWFraW5nIGNoYW5nZXM6XG4gKlxuICogLSBbQ2hhbmdlcyB0aGF0IGFyZSBjb21tb24gZm9yIHRoZSB3aG9sZSBsaWJyYXJ5XShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvZGF0ZS1mbnMvYmxvYi9tYXN0ZXIvZG9jcy91cGdyYWRlR3VpZGUubWQjQ29tbW9uLUNoYW5nZXMpLlxuICpcbiAqIEBwYXJhbSB7RGF0ZXxOdW1iZXJ9IGRhdGUgLSB0aGUgZGF0ZSB0byBjaGVja1xuICogQHJldHVybnMge0Jvb2xlYW59IHRoZSBkYXRlIGlzIHRoZSBsYXN0IGRheSBvZiBhIG1vbnRoXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IDEgYXJndW1lbnQgcmVxdWlyZWRcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gSXMgMjggRmVicnVhcnkgMjAxNCB0aGUgbGFzdCBkYXkgb2YgYSBtb250aD9cbiAqIHZhciByZXN1bHQgPSBpc0xhc3REYXlPZk1vbnRoKG5ldyBEYXRlKDIwMTQsIDEsIDI4KSlcbiAqIC8vPT4gdHJ1ZVxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGlzTGFzdERheU9mTW9udGgoZGlydHlEYXRlKSB7XG4gIHJlcXVpcmVkQXJncygxLCBhcmd1bWVudHMpO1xuICB2YXIgZGF0ZSA9IHRvRGF0ZShkaXJ0eURhdGUpO1xuICByZXR1cm4gZW5kT2ZEYXkoZGF0ZSkuZ2V0VGltZSgpID09PSBlbmRPZk1vbnRoKGRhdGUpLmdldFRpbWUoKTtcbn0iLCAiaW1wb3J0IHRvRGF0ZSBmcm9tIFwiLi4vdG9EYXRlL2luZGV4LmpzXCI7XG5pbXBvcnQgZGlmZmVyZW5jZUluQ2FsZW5kYXJNb250aHMgZnJvbSBcIi4uL2RpZmZlcmVuY2VJbkNhbGVuZGFyTW9udGhzL2luZGV4LmpzXCI7XG5pbXBvcnQgY29tcGFyZUFzYyBmcm9tIFwiLi4vY29tcGFyZUFzYy9pbmRleC5qc1wiO1xuaW1wb3J0IHJlcXVpcmVkQXJncyBmcm9tIFwiLi4vX2xpYi9yZXF1aXJlZEFyZ3MvaW5kZXguanNcIjtcbmltcG9ydCBpc0xhc3REYXlPZk1vbnRoIGZyb20gXCIuLi9pc0xhc3REYXlPZk1vbnRoL2luZGV4LmpzXCI7XG4vKipcbiAqIEBuYW1lIGRpZmZlcmVuY2VJbk1vbnRoc1xuICogQGNhdGVnb3J5IE1vbnRoIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IEdldCB0aGUgbnVtYmVyIG9mIGZ1bGwgbW9udGhzIGJldHdlZW4gdGhlIGdpdmVuIGRhdGVzLlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogR2V0IHRoZSBudW1iZXIgb2YgZnVsbCBtb250aHMgYmV0d2VlbiB0aGUgZ2l2ZW4gZGF0ZXMgdXNpbmcgdHJ1bmMgYXMgYSBkZWZhdWx0IHJvdW5kaW5nIG1ldGhvZC5cbiAqXG4gKiAjIyMgdjIuMC4wIGJyZWFraW5nIGNoYW5nZXM6XG4gKlxuICogLSBbQ2hhbmdlcyB0aGF0IGFyZSBjb21tb24gZm9yIHRoZSB3aG9sZSBsaWJyYXJ5XShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvZGF0ZS1mbnMvYmxvYi9tYXN0ZXIvZG9jcy91cGdyYWRlR3VpZGUubWQjQ29tbW9uLUNoYW5nZXMpLlxuICpcbiAqIEBwYXJhbSB7RGF0ZXxOdW1iZXJ9IGRhdGVMZWZ0IC0gdGhlIGxhdGVyIGRhdGVcbiAqIEBwYXJhbSB7RGF0ZXxOdW1iZXJ9IGRhdGVSaWdodCAtIHRoZSBlYXJsaWVyIGRhdGVcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHRoZSBudW1iZXIgb2YgZnVsbCBtb250aHNcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gMiBhcmd1bWVudHMgcmVxdWlyZWRcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gSG93IG1hbnkgZnVsbCBtb250aHMgYXJlIGJldHdlZW4gMzEgSmFudWFyeSAyMDE0IGFuZCAxIFNlcHRlbWJlciAyMDE0P1xuICogY29uc3QgcmVzdWx0ID0gZGlmZmVyZW5jZUluTW9udGhzKG5ldyBEYXRlKDIwMTQsIDgsIDEpLCBuZXcgRGF0ZSgyMDE0LCAwLCAzMSkpXG4gKiAvLz0+IDdcbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBkaWZmZXJlbmNlSW5Nb250aHMoZGlydHlEYXRlTGVmdCwgZGlydHlEYXRlUmlnaHQpIHtcbiAgcmVxdWlyZWRBcmdzKDIsIGFyZ3VtZW50cyk7XG4gIHZhciBkYXRlTGVmdCA9IHRvRGF0ZShkaXJ0eURhdGVMZWZ0KTtcbiAgdmFyIGRhdGVSaWdodCA9IHRvRGF0ZShkaXJ0eURhdGVSaWdodCk7XG4gIHZhciBzaWduID0gY29tcGFyZUFzYyhkYXRlTGVmdCwgZGF0ZVJpZ2h0KTtcbiAgdmFyIGRpZmZlcmVuY2UgPSBNYXRoLmFicyhkaWZmZXJlbmNlSW5DYWxlbmRhck1vbnRocyhkYXRlTGVmdCwgZGF0ZVJpZ2h0KSk7XG4gIHZhciByZXN1bHQ7IC8vIENoZWNrIGZvciB0aGUgZGlmZmVyZW5jZSBvZiBsZXNzIHRoYW4gbW9udGhcblxuICBpZiAoZGlmZmVyZW5jZSA8IDEpIHtcbiAgICByZXN1bHQgPSAwO1xuICB9IGVsc2Uge1xuICAgIGlmIChkYXRlTGVmdC5nZXRNb250aCgpID09PSAxICYmIGRhdGVMZWZ0LmdldERhdGUoKSA+IDI3KSB7XG4gICAgICAvLyBUaGlzIHdpbGwgY2hlY2sgaWYgdGhlIGRhdGUgaXMgZW5kIG9mIEZlYiBhbmQgYXNzaWduIGEgaGlnaGVyIGVuZCBvZiBtb250aCBkYXRlXG4gICAgICAvLyB0byBjb21wYXJlIGl0IHdpdGggSmFuXG4gICAgICBkYXRlTGVmdC5zZXREYXRlKDMwKTtcbiAgICB9XG5cbiAgICBkYXRlTGVmdC5zZXRNb250aChkYXRlTGVmdC5nZXRNb250aCgpIC0gc2lnbiAqIGRpZmZlcmVuY2UpOyAvLyBNYXRoLmFicyhkaWZmIGluIGZ1bGwgbW9udGhzIC0gZGlmZiBpbiBjYWxlbmRhciBtb250aHMpID09PSAxIGlmIGxhc3QgY2FsZW5kYXIgbW9udGggaXMgbm90IGZ1bGxcbiAgICAvLyBJZiBzbywgcmVzdWx0IG11c3QgYmUgZGVjcmVhc2VkIGJ5IDEgaW4gYWJzb2x1dGUgdmFsdWVcblxuICAgIHZhciBpc0xhc3RNb250aE5vdEZ1bGwgPSBjb21wYXJlQXNjKGRhdGVMZWZ0LCBkYXRlUmlnaHQpID09PSAtc2lnbjsgLy8gQ2hlY2sgZm9yIGNhc2VzIG9mIG9uZSBmdWxsIGNhbGVuZGFyIG1vbnRoXG5cbiAgICBpZiAoaXNMYXN0RGF5T2ZNb250aCh0b0RhdGUoZGlydHlEYXRlTGVmdCkpICYmIGRpZmZlcmVuY2UgPT09IDEgJiYgY29tcGFyZUFzYyhkaXJ0eURhdGVMZWZ0LCBkYXRlUmlnaHQpID09PSAxKSB7XG4gICAgICBpc0xhc3RNb250aE5vdEZ1bGwgPSBmYWxzZTtcbiAgICB9XG5cbiAgICByZXN1bHQgPSBzaWduICogKGRpZmZlcmVuY2UgLSBOdW1iZXIoaXNMYXN0TW9udGhOb3RGdWxsKSk7XG4gIH0gLy8gUHJldmVudCBuZWdhdGl2ZSB6ZXJvXG5cblxuICByZXR1cm4gcmVzdWx0ID09PSAwID8gMCA6IHJlc3VsdDtcbn0iLCAiaW1wb3J0IGRpZmZlcmVuY2VJbk1pbGxpc2Vjb25kcyBmcm9tIFwiLi4vZGlmZmVyZW5jZUluTWlsbGlzZWNvbmRzL2luZGV4LmpzXCI7XG5pbXBvcnQgcmVxdWlyZWRBcmdzIGZyb20gXCIuLi9fbGliL3JlcXVpcmVkQXJncy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgZ2V0Um91bmRpbmdNZXRob2QgfSBmcm9tIFwiLi4vX2xpYi9yb3VuZGluZ01ldGhvZHMvaW5kZXguanNcIjtcbi8qKlxuICogQG5hbWUgZGlmZmVyZW5jZUluU2Vjb25kc1xuICogQGNhdGVnb3J5IFNlY29uZCBIZWxwZXJzXG4gKiBAc3VtbWFyeSBHZXQgdGhlIG51bWJlciBvZiBzZWNvbmRzIGJldHdlZW4gdGhlIGdpdmVuIGRhdGVzLlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogR2V0IHRoZSBudW1iZXIgb2Ygc2Vjb25kcyBiZXR3ZWVuIHRoZSBnaXZlbiBkYXRlcy5cbiAqXG4gKiAjIyMgdjIuMC4wIGJyZWFraW5nIGNoYW5nZXM6XG4gKlxuICogLSBbQ2hhbmdlcyB0aGF0IGFyZSBjb21tb24gZm9yIHRoZSB3aG9sZSBsaWJyYXJ5XShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvZGF0ZS1mbnMvYmxvYi9tYXN0ZXIvZG9jcy91cGdyYWRlR3VpZGUubWQjQ29tbW9uLUNoYW5nZXMpLlxuICpcbiAqIEBwYXJhbSB7RGF0ZXxOdW1iZXJ9IGRhdGVMZWZ0IC0gdGhlIGxhdGVyIGRhdGVcbiAqIEBwYXJhbSB7RGF0ZXxOdW1iZXJ9IGRhdGVSaWdodCAtIHRoZSBlYXJsaWVyIGRhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBhbiBvYmplY3Qgd2l0aCBvcHRpb25zLlxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnJvdW5kaW5nTWV0aG9kPSd0cnVuYyddIC0gYSByb3VuZGluZyBtZXRob2QgKGBjZWlsYCwgYGZsb29yYCwgYHJvdW5kYCBvciBgdHJ1bmNgKVxuICogQHJldHVybnMge051bWJlcn0gdGhlIG51bWJlciBvZiBzZWNvbmRzXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IDIgYXJndW1lbnRzIHJlcXVpcmVkXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIEhvdyBtYW55IHNlY29uZHMgYXJlIGJldHdlZW5cbiAqIC8vIDIgSnVseSAyMDE0IDEyOjMwOjA3Ljk5OSBhbmQgMiBKdWx5IDIwMTQgMTI6MzA6MjAuMDAwP1xuICogY29uc3QgcmVzdWx0ID0gZGlmZmVyZW5jZUluU2Vjb25kcyhcbiAqICAgbmV3IERhdGUoMjAxNCwgNiwgMiwgMTIsIDMwLCAyMCwgMCksXG4gKiAgIG5ldyBEYXRlKDIwMTQsIDYsIDIsIDEyLCAzMCwgNywgOTk5KVxuICogKVxuICogLy89PiAxMlxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGRpZmZlcmVuY2VJblNlY29uZHMoZGF0ZUxlZnQsIGRhdGVSaWdodCwgb3B0aW9ucykge1xuICByZXF1aXJlZEFyZ3MoMiwgYXJndW1lbnRzKTtcbiAgdmFyIGRpZmYgPSBkaWZmZXJlbmNlSW5NaWxsaXNlY29uZHMoZGF0ZUxlZnQsIGRhdGVSaWdodCkgLyAxMDAwO1xuICByZXR1cm4gZ2V0Um91bmRpbmdNZXRob2Qob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnJvdW5kaW5nTWV0aG9kKShkaWZmKTtcbn0iLCAidmFyIGZvcm1hdERpc3RhbmNlTG9jYWxlID0ge1xuICBsZXNzVGhhblhTZWNvbmRzOiB7XG4gICAgb25lOiAnbGVzcyB0aGFuIGEgc2Vjb25kJyxcbiAgICBvdGhlcjogJ2xlc3MgdGhhbiB7e2NvdW50fX0gc2Vjb25kcydcbiAgfSxcbiAgeFNlY29uZHM6IHtcbiAgICBvbmU6ICcxIHNlY29uZCcsXG4gICAgb3RoZXI6ICd7e2NvdW50fX0gc2Vjb25kcydcbiAgfSxcbiAgaGFsZkFNaW51dGU6ICdoYWxmIGEgbWludXRlJyxcbiAgbGVzc1RoYW5YTWludXRlczoge1xuICAgIG9uZTogJ2xlc3MgdGhhbiBhIG1pbnV0ZScsXG4gICAgb3RoZXI6ICdsZXNzIHRoYW4ge3tjb3VudH19IG1pbnV0ZXMnXG4gIH0sXG4gIHhNaW51dGVzOiB7XG4gICAgb25lOiAnMSBtaW51dGUnLFxuICAgIG90aGVyOiAne3tjb3VudH19IG1pbnV0ZXMnXG4gIH0sXG4gIGFib3V0WEhvdXJzOiB7XG4gICAgb25lOiAnYWJvdXQgMSBob3VyJyxcbiAgICBvdGhlcjogJ2Fib3V0IHt7Y291bnR9fSBob3VycydcbiAgfSxcbiAgeEhvdXJzOiB7XG4gICAgb25lOiAnMSBob3VyJyxcbiAgICBvdGhlcjogJ3t7Y291bnR9fSBob3VycydcbiAgfSxcbiAgeERheXM6IHtcbiAgICBvbmU6ICcxIGRheScsXG4gICAgb3RoZXI6ICd7e2NvdW50fX0gZGF5cydcbiAgfSxcbiAgYWJvdXRYV2Vla3M6IHtcbiAgICBvbmU6ICdhYm91dCAxIHdlZWsnLFxuICAgIG90aGVyOiAnYWJvdXQge3tjb3VudH19IHdlZWtzJ1xuICB9LFxuICB4V2Vla3M6IHtcbiAgICBvbmU6ICcxIHdlZWsnLFxuICAgIG90aGVyOiAne3tjb3VudH19IHdlZWtzJ1xuICB9LFxuICBhYm91dFhNb250aHM6IHtcbiAgICBvbmU6ICdhYm91dCAxIG1vbnRoJyxcbiAgICBvdGhlcjogJ2Fib3V0IHt7Y291bnR9fSBtb250aHMnXG4gIH0sXG4gIHhNb250aHM6IHtcbiAgICBvbmU6ICcxIG1vbnRoJyxcbiAgICBvdGhlcjogJ3t7Y291bnR9fSBtb250aHMnXG4gIH0sXG4gIGFib3V0WFllYXJzOiB7XG4gICAgb25lOiAnYWJvdXQgMSB5ZWFyJyxcbiAgICBvdGhlcjogJ2Fib3V0IHt7Y291bnR9fSB5ZWFycydcbiAgfSxcbiAgeFllYXJzOiB7XG4gICAgb25lOiAnMSB5ZWFyJyxcbiAgICBvdGhlcjogJ3t7Y291bnR9fSB5ZWFycydcbiAgfSxcbiAgb3ZlclhZZWFyczoge1xuICAgIG9uZTogJ292ZXIgMSB5ZWFyJyxcbiAgICBvdGhlcjogJ292ZXIge3tjb3VudH19IHllYXJzJ1xuICB9LFxuICBhbG1vc3RYWWVhcnM6IHtcbiAgICBvbmU6ICdhbG1vc3QgMSB5ZWFyJyxcbiAgICBvdGhlcjogJ2FsbW9zdCB7e2NvdW50fX0geWVhcnMnXG4gIH1cbn07XG5cbnZhciBmb3JtYXREaXN0YW5jZSA9IGZ1bmN0aW9uICh0b2tlbiwgY291bnQsIG9wdGlvbnMpIHtcbiAgdmFyIHJlc3VsdDtcbiAgdmFyIHRva2VuVmFsdWUgPSBmb3JtYXREaXN0YW5jZUxvY2FsZVt0b2tlbl07XG5cbiAgaWYgKHR5cGVvZiB0b2tlblZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJlc3VsdCA9IHRva2VuVmFsdWU7XG4gIH0gZWxzZSBpZiAoY291bnQgPT09IDEpIHtcbiAgICByZXN1bHQgPSB0b2tlblZhbHVlLm9uZTtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQgPSB0b2tlblZhbHVlLm90aGVyLnJlcGxhY2UoJ3t7Y291bnR9fScsIGNvdW50LnRvU3RyaW5nKCkpO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMgIT09IG51bGwgJiYgb3B0aW9ucyAhPT0gdm9pZCAwICYmIG9wdGlvbnMuYWRkU3VmZml4KSB7XG4gICAgaWYgKG9wdGlvbnMuY29tcGFyaXNvbiAmJiBvcHRpb25zLmNvbXBhcmlzb24gPiAwKSB7XG4gICAgICByZXR1cm4gJ2luICcgKyByZXN1bHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiByZXN1bHQgKyAnIGFnbyc7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGZvcm1hdERpc3RhbmNlOyIsICJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBidWlsZEZvcm1hdExvbmdGbihhcmdzKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIC8vIFRPRE86IFJlbW92ZSBTdHJpbmcoKVxuICAgIHZhciB3aWR0aCA9IG9wdGlvbnMud2lkdGggPyBTdHJpbmcob3B0aW9ucy53aWR0aCkgOiBhcmdzLmRlZmF1bHRXaWR0aDtcbiAgICB2YXIgZm9ybWF0ID0gYXJncy5mb3JtYXRzW3dpZHRoXSB8fCBhcmdzLmZvcm1hdHNbYXJncy5kZWZhdWx0V2lkdGhdO1xuICAgIHJldHVybiBmb3JtYXQ7XG4gIH07XG59IiwgImltcG9ydCBidWlsZEZvcm1hdExvbmdGbiBmcm9tIFwiLi4vLi4vLi4vX2xpYi9idWlsZEZvcm1hdExvbmdGbi9pbmRleC5qc1wiO1xudmFyIGRhdGVGb3JtYXRzID0ge1xuICBmdWxsOiAnRUVFRSwgTU1NTSBkbywgeScsXG4gIGxvbmc6ICdNTU1NIGRvLCB5JyxcbiAgbWVkaXVtOiAnTU1NIGQsIHknLFxuICBzaG9ydDogJ01NL2RkL3l5eXknXG59O1xudmFyIHRpbWVGb3JtYXRzID0ge1xuICBmdWxsOiAnaDptbTpzcyBhIHp6enonLFxuICBsb25nOiAnaDptbTpzcyBhIHonLFxuICBtZWRpdW06ICdoOm1tOnNzIGEnLFxuICBzaG9ydDogJ2g6bW0gYSdcbn07XG52YXIgZGF0ZVRpbWVGb3JtYXRzID0ge1xuICBmdWxsOiBcInt7ZGF0ZX19ICdhdCcge3t0aW1lfX1cIixcbiAgbG9uZzogXCJ7e2RhdGV9fSAnYXQnIHt7dGltZX19XCIsXG4gIG1lZGl1bTogJ3t7ZGF0ZX19LCB7e3RpbWV9fScsXG4gIHNob3J0OiAne3tkYXRlfX0sIHt7dGltZX19J1xufTtcbnZhciBmb3JtYXRMb25nID0ge1xuICBkYXRlOiBidWlsZEZvcm1hdExvbmdGbih7XG4gICAgZm9ybWF0czogZGF0ZUZvcm1hdHMsXG4gICAgZGVmYXVsdFdpZHRoOiAnZnVsbCdcbiAgfSksXG4gIHRpbWU6IGJ1aWxkRm9ybWF0TG9uZ0ZuKHtcbiAgICBmb3JtYXRzOiB0aW1lRm9ybWF0cyxcbiAgICBkZWZhdWx0V2lkdGg6ICdmdWxsJ1xuICB9KSxcbiAgZGF0ZVRpbWU6IGJ1aWxkRm9ybWF0TG9uZ0ZuKHtcbiAgICBmb3JtYXRzOiBkYXRlVGltZUZvcm1hdHMsXG4gICAgZGVmYXVsdFdpZHRoOiAnZnVsbCdcbiAgfSlcbn07XG5leHBvcnQgZGVmYXVsdCBmb3JtYXRMb25nOyIsICJ2YXIgZm9ybWF0UmVsYXRpdmVMb2NhbGUgPSB7XG4gIGxhc3RXZWVrOiBcIidsYXN0JyBlZWVlICdhdCcgcFwiLFxuICB5ZXN0ZXJkYXk6IFwiJ3llc3RlcmRheSBhdCcgcFwiLFxuICB0b2RheTogXCIndG9kYXkgYXQnIHBcIixcbiAgdG9tb3Jyb3c6IFwiJ3RvbW9ycm93IGF0JyBwXCIsXG4gIG5leHRXZWVrOiBcImVlZWUgJ2F0JyBwXCIsXG4gIG90aGVyOiAnUCdcbn07XG5cbnZhciBmb3JtYXRSZWxhdGl2ZSA9IGZ1bmN0aW9uICh0b2tlbiwgX2RhdGUsIF9iYXNlRGF0ZSwgX29wdGlvbnMpIHtcbiAgcmV0dXJuIGZvcm1hdFJlbGF0aXZlTG9jYWxlW3Rva2VuXTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGZvcm1hdFJlbGF0aXZlOyIsICJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBidWlsZExvY2FsaXplRm4oYXJncykge1xuICByZXR1cm4gZnVuY3Rpb24gKGRpcnR5SW5kZXgsIGRpcnR5T3B0aW9ucykge1xuICAgIHZhciBvcHRpb25zID0gZGlydHlPcHRpb25zIHx8IHt9O1xuICAgIHZhciBjb250ZXh0ID0gb3B0aW9ucy5jb250ZXh0ID8gU3RyaW5nKG9wdGlvbnMuY29udGV4dCkgOiAnc3RhbmRhbG9uZSc7XG4gICAgdmFyIHZhbHVlc0FycmF5O1xuXG4gICAgaWYgKGNvbnRleHQgPT09ICdmb3JtYXR0aW5nJyAmJiBhcmdzLmZvcm1hdHRpbmdWYWx1ZXMpIHtcbiAgICAgIHZhciBkZWZhdWx0V2lkdGggPSBhcmdzLmRlZmF1bHRGb3JtYXR0aW5nV2lkdGggfHwgYXJncy5kZWZhdWx0V2lkdGg7XG4gICAgICB2YXIgd2lkdGggPSBvcHRpb25zLndpZHRoID8gU3RyaW5nKG9wdGlvbnMud2lkdGgpIDogZGVmYXVsdFdpZHRoO1xuICAgICAgdmFsdWVzQXJyYXkgPSBhcmdzLmZvcm1hdHRpbmdWYWx1ZXNbd2lkdGhdIHx8IGFyZ3MuZm9ybWF0dGluZ1ZhbHVlc1tkZWZhdWx0V2lkdGhdO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgX2RlZmF1bHRXaWR0aCA9IGFyZ3MuZGVmYXVsdFdpZHRoO1xuXG4gICAgICB2YXIgX3dpZHRoID0gb3B0aW9ucy53aWR0aCA/IFN0cmluZyhvcHRpb25zLndpZHRoKSA6IGFyZ3MuZGVmYXVsdFdpZHRoO1xuXG4gICAgICB2YWx1ZXNBcnJheSA9IGFyZ3MudmFsdWVzW193aWR0aF0gfHwgYXJncy52YWx1ZXNbX2RlZmF1bHRXaWR0aF07XG4gICAgfVxuXG4gICAgdmFyIGluZGV4ID0gYXJncy5hcmd1bWVudENhbGxiYWNrID8gYXJncy5hcmd1bWVudENhbGxiYWNrKGRpcnR5SW5kZXgpIDogZGlydHlJbmRleDsgLy8gQHRzLWlnbm9yZTogRm9yIHNvbWUgcmVhc29uIFR5cGVTY3JpcHQganVzdCBkb24ndCB3YW50IHRvIG1hdGNoIGl0LCBubyBtYXR0ZXIgaG93IGhhcmQgd2UgdHJ5LiBJIGNoYWxsZW5nZSB5b3UgdG8gdHJ5IHRvIHJlbW92ZSBpdCFcblxuICAgIHJldHVybiB2YWx1ZXNBcnJheVtpbmRleF07XG4gIH07XG59IiwgImltcG9ydCBidWlsZExvY2FsaXplRm4gZnJvbSBcIi4uLy4uLy4uL19saWIvYnVpbGRMb2NhbGl6ZUZuL2luZGV4LmpzXCI7XG52YXIgZXJhVmFsdWVzID0ge1xuICBuYXJyb3c6IFsnQicsICdBJ10sXG4gIGFiYnJldmlhdGVkOiBbJ0JDJywgJ0FEJ10sXG4gIHdpZGU6IFsnQmVmb3JlIENocmlzdCcsICdBbm5vIERvbWluaSddXG59O1xudmFyIHF1YXJ0ZXJWYWx1ZXMgPSB7XG4gIG5hcnJvdzogWycxJywgJzInLCAnMycsICc0J10sXG4gIGFiYnJldmlhdGVkOiBbJ1ExJywgJ1EyJywgJ1EzJywgJ1E0J10sXG4gIHdpZGU6IFsnMXN0IHF1YXJ0ZXInLCAnMm5kIHF1YXJ0ZXInLCAnM3JkIHF1YXJ0ZXInLCAnNHRoIHF1YXJ0ZXInXVxufTsgLy8gTm90ZTogaW4gRW5nbGlzaCwgdGhlIG5hbWVzIG9mIGRheXMgb2YgdGhlIHdlZWsgYW5kIG1vbnRocyBhcmUgY2FwaXRhbGl6ZWQuXG4vLyBJZiB5b3UgYXJlIG1ha2luZyBhIG5ldyBsb2NhbGUgYmFzZWQgb24gdGhpcyBvbmUsIGNoZWNrIGlmIHRoZSBzYW1lIGlzIHRydWUgZm9yIHRoZSBsYW5ndWFnZSB5b3UncmUgd29ya2luZyBvbi5cbi8vIEdlbmVyYWxseSwgZm9ybWF0dGVkIGRhdGVzIHNob3VsZCBsb29rIGxpa2UgdGhleSBhcmUgaW4gdGhlIG1pZGRsZSBvZiBhIHNlbnRlbmNlLFxuLy8gZS5nLiBpbiBTcGFuaXNoIGxhbmd1YWdlIHRoZSB3ZWVrZGF5cyBhbmQgbW9udGhzIHNob3VsZCBiZSBpbiB0aGUgbG93ZXJjYXNlLlxuXG52YXIgbW9udGhWYWx1ZXMgPSB7XG4gIG5hcnJvdzogWydKJywgJ0YnLCAnTScsICdBJywgJ00nLCAnSicsICdKJywgJ0EnLCAnUycsICdPJywgJ04nLCAnRCddLFxuICBhYmJyZXZpYXRlZDogWydKYW4nLCAnRmViJywgJ01hcicsICdBcHInLCAnTWF5JywgJ0p1bicsICdKdWwnLCAnQXVnJywgJ1NlcCcsICdPY3QnLCAnTm92JywgJ0RlYyddLFxuICB3aWRlOiBbJ0phbnVhcnknLCAnRmVicnVhcnknLCAnTWFyY2gnLCAnQXByaWwnLCAnTWF5JywgJ0p1bmUnLCAnSnVseScsICdBdWd1c3QnLCAnU2VwdGVtYmVyJywgJ09jdG9iZXInLCAnTm92ZW1iZXInLCAnRGVjZW1iZXInXVxufTtcbnZhciBkYXlWYWx1ZXMgPSB7XG4gIG5hcnJvdzogWydTJywgJ00nLCAnVCcsICdXJywgJ1QnLCAnRicsICdTJ10sXG4gIHNob3J0OiBbJ1N1JywgJ01vJywgJ1R1JywgJ1dlJywgJ1RoJywgJ0ZyJywgJ1NhJ10sXG4gIGFiYnJldmlhdGVkOiBbJ1N1bicsICdNb24nLCAnVHVlJywgJ1dlZCcsICdUaHUnLCAnRnJpJywgJ1NhdCddLFxuICB3aWRlOiBbJ1N1bmRheScsICdNb25kYXknLCAnVHVlc2RheScsICdXZWRuZXNkYXknLCAnVGh1cnNkYXknLCAnRnJpZGF5JywgJ1NhdHVyZGF5J11cbn07XG52YXIgZGF5UGVyaW9kVmFsdWVzID0ge1xuICBuYXJyb3c6IHtcbiAgICBhbTogJ2EnLFxuICAgIHBtOiAncCcsXG4gICAgbWlkbmlnaHQ6ICdtaScsXG4gICAgbm9vbjogJ24nLFxuICAgIG1vcm5pbmc6ICdtb3JuaW5nJyxcbiAgICBhZnRlcm5vb246ICdhZnRlcm5vb24nLFxuICAgIGV2ZW5pbmc6ICdldmVuaW5nJyxcbiAgICBuaWdodDogJ25pZ2h0J1xuICB9LFxuICBhYmJyZXZpYXRlZDoge1xuICAgIGFtOiAnQU0nLFxuICAgIHBtOiAnUE0nLFxuICAgIG1pZG5pZ2h0OiAnbWlkbmlnaHQnLFxuICAgIG5vb246ICdub29uJyxcbiAgICBtb3JuaW5nOiAnbW9ybmluZycsXG4gICAgYWZ0ZXJub29uOiAnYWZ0ZXJub29uJyxcbiAgICBldmVuaW5nOiAnZXZlbmluZycsXG4gICAgbmlnaHQ6ICduaWdodCdcbiAgfSxcbiAgd2lkZToge1xuICAgIGFtOiAnYS5tLicsXG4gICAgcG06ICdwLm0uJyxcbiAgICBtaWRuaWdodDogJ21pZG5pZ2h0JyxcbiAgICBub29uOiAnbm9vbicsXG4gICAgbW9ybmluZzogJ21vcm5pbmcnLFxuICAgIGFmdGVybm9vbjogJ2FmdGVybm9vbicsXG4gICAgZXZlbmluZzogJ2V2ZW5pbmcnLFxuICAgIG5pZ2h0OiAnbmlnaHQnXG4gIH1cbn07XG52YXIgZm9ybWF0dGluZ0RheVBlcmlvZFZhbHVlcyA9IHtcbiAgbmFycm93OiB7XG4gICAgYW06ICdhJyxcbiAgICBwbTogJ3AnLFxuICAgIG1pZG5pZ2h0OiAnbWknLFxuICAgIG5vb246ICduJyxcbiAgICBtb3JuaW5nOiAnaW4gdGhlIG1vcm5pbmcnLFxuICAgIGFmdGVybm9vbjogJ2luIHRoZSBhZnRlcm5vb24nLFxuICAgIGV2ZW5pbmc6ICdpbiB0aGUgZXZlbmluZycsXG4gICAgbmlnaHQ6ICdhdCBuaWdodCdcbiAgfSxcbiAgYWJicmV2aWF0ZWQ6IHtcbiAgICBhbTogJ0FNJyxcbiAgICBwbTogJ1BNJyxcbiAgICBtaWRuaWdodDogJ21pZG5pZ2h0JyxcbiAgICBub29uOiAnbm9vbicsXG4gICAgbW9ybmluZzogJ2luIHRoZSBtb3JuaW5nJyxcbiAgICBhZnRlcm5vb246ICdpbiB0aGUgYWZ0ZXJub29uJyxcbiAgICBldmVuaW5nOiAnaW4gdGhlIGV2ZW5pbmcnLFxuICAgIG5pZ2h0OiAnYXQgbmlnaHQnXG4gIH0sXG4gIHdpZGU6IHtcbiAgICBhbTogJ2EubS4nLFxuICAgIHBtOiAncC5tLicsXG4gICAgbWlkbmlnaHQ6ICdtaWRuaWdodCcsXG4gICAgbm9vbjogJ25vb24nLFxuICAgIG1vcm5pbmc6ICdpbiB0aGUgbW9ybmluZycsXG4gICAgYWZ0ZXJub29uOiAnaW4gdGhlIGFmdGVybm9vbicsXG4gICAgZXZlbmluZzogJ2luIHRoZSBldmVuaW5nJyxcbiAgICBuaWdodDogJ2F0IG5pZ2h0J1xuICB9XG59O1xuXG52YXIgb3JkaW5hbE51bWJlciA9IGZ1bmN0aW9uIChkaXJ0eU51bWJlciwgX29wdGlvbnMpIHtcbiAgdmFyIG51bWJlciA9IE51bWJlcihkaXJ0eU51bWJlcik7IC8vIElmIG9yZGluYWwgbnVtYmVycyBkZXBlbmQgb24gY29udGV4dCwgZm9yIGV4YW1wbGUsXG4gIC8vIGlmIHRoZXkgYXJlIGRpZmZlcmVudCBmb3IgZGlmZmVyZW50IGdyYW1tYXRpY2FsIGdlbmRlcnMsXG4gIC8vIHVzZSBgb3B0aW9ucy51bml0YC5cbiAgLy9cbiAgLy8gYHVuaXRgIGNhbiBiZSAneWVhcicsICdxdWFydGVyJywgJ21vbnRoJywgJ3dlZWsnLCAnZGF0ZScsICdkYXlPZlllYXInLFxuICAvLyAnZGF5JywgJ2hvdXInLCAnbWludXRlJywgJ3NlY29uZCcuXG5cbiAgdmFyIHJlbTEwMCA9IG51bWJlciAlIDEwMDtcblxuICBpZiAocmVtMTAwID4gMjAgfHwgcmVtMTAwIDwgMTApIHtcbiAgICBzd2l0Y2ggKHJlbTEwMCAlIDEwKSB7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIHJldHVybiBudW1iZXIgKyAnc3QnO1xuXG4gICAgICBjYXNlIDI6XG4gICAgICAgIHJldHVybiBudW1iZXIgKyAnbmQnO1xuXG4gICAgICBjYXNlIDM6XG4gICAgICAgIHJldHVybiBudW1iZXIgKyAncmQnO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudW1iZXIgKyAndGgnO1xufTtcblxudmFyIGxvY2FsaXplID0ge1xuICBvcmRpbmFsTnVtYmVyOiBvcmRpbmFsTnVtYmVyLFxuICBlcmE6IGJ1aWxkTG9jYWxpemVGbih7XG4gICAgdmFsdWVzOiBlcmFWYWx1ZXMsXG4gICAgZGVmYXVsdFdpZHRoOiAnd2lkZSdcbiAgfSksXG4gIHF1YXJ0ZXI6IGJ1aWxkTG9jYWxpemVGbih7XG4gICAgdmFsdWVzOiBxdWFydGVyVmFsdWVzLFxuICAgIGRlZmF1bHRXaWR0aDogJ3dpZGUnLFxuICAgIGFyZ3VtZW50Q2FsbGJhY2s6IGZ1bmN0aW9uIChxdWFydGVyKSB7XG4gICAgICByZXR1cm4gcXVhcnRlciAtIDE7XG4gICAgfVxuICB9KSxcbiAgbW9udGg6IGJ1aWxkTG9jYWxpemVGbih7XG4gICAgdmFsdWVzOiBtb250aFZhbHVlcyxcbiAgICBkZWZhdWx0V2lkdGg6ICd3aWRlJ1xuICB9KSxcbiAgZGF5OiBidWlsZExvY2FsaXplRm4oe1xuICAgIHZhbHVlczogZGF5VmFsdWVzLFxuICAgIGRlZmF1bHRXaWR0aDogJ3dpZGUnXG4gIH0pLFxuICBkYXlQZXJpb2Q6IGJ1aWxkTG9jYWxpemVGbih7XG4gICAgdmFsdWVzOiBkYXlQZXJpb2RWYWx1ZXMsXG4gICAgZGVmYXVsdFdpZHRoOiAnd2lkZScsXG4gICAgZm9ybWF0dGluZ1ZhbHVlczogZm9ybWF0dGluZ0RheVBlcmlvZFZhbHVlcyxcbiAgICBkZWZhdWx0Rm9ybWF0dGluZ1dpZHRoOiAnd2lkZSdcbiAgfSlcbn07XG5leHBvcnQgZGVmYXVsdCBsb2NhbGl6ZTsiLCAiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYnVpbGRNYXRjaEZuKGFyZ3MpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgdmFyIHdpZHRoID0gb3B0aW9ucy53aWR0aDtcbiAgICB2YXIgbWF0Y2hQYXR0ZXJuID0gd2lkdGggJiYgYXJncy5tYXRjaFBhdHRlcm5zW3dpZHRoXSB8fCBhcmdzLm1hdGNoUGF0dGVybnNbYXJncy5kZWZhdWx0TWF0Y2hXaWR0aF07XG4gICAgdmFyIG1hdGNoUmVzdWx0ID0gc3RyaW5nLm1hdGNoKG1hdGNoUGF0dGVybik7XG5cbiAgICBpZiAoIW1hdGNoUmVzdWx0KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgbWF0Y2hlZFN0cmluZyA9IG1hdGNoUmVzdWx0WzBdO1xuICAgIHZhciBwYXJzZVBhdHRlcm5zID0gd2lkdGggJiYgYXJncy5wYXJzZVBhdHRlcm5zW3dpZHRoXSB8fCBhcmdzLnBhcnNlUGF0dGVybnNbYXJncy5kZWZhdWx0UGFyc2VXaWR0aF07XG4gICAgdmFyIGtleSA9IEFycmF5LmlzQXJyYXkocGFyc2VQYXR0ZXJucykgPyBmaW5kSW5kZXgocGFyc2VQYXR0ZXJucywgZnVuY3Rpb24gKHBhdHRlcm4pIHtcbiAgICAgIHJldHVybiBwYXR0ZXJuLnRlc3QobWF0Y2hlZFN0cmluZyk7XG4gICAgfSkgOiBmaW5kS2V5KHBhcnNlUGF0dGVybnMsIGZ1bmN0aW9uIChwYXR0ZXJuKSB7XG4gICAgICByZXR1cm4gcGF0dGVybi50ZXN0KG1hdGNoZWRTdHJpbmcpO1xuICAgIH0pO1xuICAgIHZhciB2YWx1ZTtcbiAgICB2YWx1ZSA9IGFyZ3MudmFsdWVDYWxsYmFjayA/IGFyZ3MudmFsdWVDYWxsYmFjayhrZXkpIDoga2V5O1xuICAgIHZhbHVlID0gb3B0aW9ucy52YWx1ZUNhbGxiYWNrID8gb3B0aW9ucy52YWx1ZUNhbGxiYWNrKHZhbHVlKSA6IHZhbHVlO1xuICAgIHZhciByZXN0ID0gc3RyaW5nLnNsaWNlKG1hdGNoZWRTdHJpbmcubGVuZ3RoKTtcbiAgICByZXR1cm4ge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgcmVzdDogcmVzdFxuICAgIH07XG4gIH07XG59XG5cbmZ1bmN0aW9uIGZpbmRLZXkob2JqZWN0LCBwcmVkaWNhdGUpIHtcbiAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgIGlmIChvYmplY3QuaGFzT3duUHJvcGVydHkoa2V5KSAmJiBwcmVkaWNhdGUob2JqZWN0W2tleV0pKSB7XG4gICAgICByZXR1cm4ga2V5O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGZpbmRJbmRleChhcnJheSwgcHJlZGljYXRlKSB7XG4gIGZvciAodmFyIGtleSA9IDA7IGtleSA8IGFycmF5Lmxlbmd0aDsga2V5KyspIHtcbiAgICBpZiAocHJlZGljYXRlKGFycmF5W2tleV0pKSB7XG4gICAgICByZXR1cm4ga2V5O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWQ7XG59IiwgImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGJ1aWxkTWF0Y2hQYXR0ZXJuRm4oYXJncykge1xuICByZXR1cm4gZnVuY3Rpb24gKHN0cmluZykge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICB2YXIgbWF0Y2hSZXN1bHQgPSBzdHJpbmcubWF0Y2goYXJncy5tYXRjaFBhdHRlcm4pO1xuICAgIGlmICghbWF0Y2hSZXN1bHQpIHJldHVybiBudWxsO1xuICAgIHZhciBtYXRjaGVkU3RyaW5nID0gbWF0Y2hSZXN1bHRbMF07XG4gICAgdmFyIHBhcnNlUmVzdWx0ID0gc3RyaW5nLm1hdGNoKGFyZ3MucGFyc2VQYXR0ZXJuKTtcbiAgICBpZiAoIXBhcnNlUmVzdWx0KSByZXR1cm4gbnVsbDtcbiAgICB2YXIgdmFsdWUgPSBhcmdzLnZhbHVlQ2FsbGJhY2sgPyBhcmdzLnZhbHVlQ2FsbGJhY2socGFyc2VSZXN1bHRbMF0pIDogcGFyc2VSZXN1bHRbMF07XG4gICAgdmFsdWUgPSBvcHRpb25zLnZhbHVlQ2FsbGJhY2sgPyBvcHRpb25zLnZhbHVlQ2FsbGJhY2sodmFsdWUpIDogdmFsdWU7XG4gICAgdmFyIHJlc3QgPSBzdHJpbmcuc2xpY2UobWF0Y2hlZFN0cmluZy5sZW5ndGgpO1xuICAgIHJldHVybiB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICByZXN0OiByZXN0XG4gICAgfTtcbiAgfTtcbn0iLCAiaW1wb3J0IGJ1aWxkTWF0Y2hGbiBmcm9tIFwiLi4vLi4vLi4vX2xpYi9idWlsZE1hdGNoRm4vaW5kZXguanNcIjtcbmltcG9ydCBidWlsZE1hdGNoUGF0dGVybkZuIGZyb20gXCIuLi8uLi8uLi9fbGliL2J1aWxkTWF0Y2hQYXR0ZXJuRm4vaW5kZXguanNcIjtcbnZhciBtYXRjaE9yZGluYWxOdW1iZXJQYXR0ZXJuID0gL14oXFxkKykodGh8c3R8bmR8cmQpPy9pO1xudmFyIHBhcnNlT3JkaW5hbE51bWJlclBhdHRlcm4gPSAvXFxkKy9pO1xudmFyIG1hdGNoRXJhUGF0dGVybnMgPSB7XG4gIG5hcnJvdzogL14oYnxhKS9pLFxuICBhYmJyZXZpYXRlZDogL14oYlxcLj9cXHM/Y1xcLj98YlxcLj9cXHM/Y1xcLj9cXHM/ZVxcLj98YVxcLj9cXHM/ZFxcLj98Y1xcLj9cXHM/ZVxcLj8pL2ksXG4gIHdpZGU6IC9eKGJlZm9yZSBjaHJpc3R8YmVmb3JlIGNvbW1vbiBlcmF8YW5ubyBkb21pbml8Y29tbW9uIGVyYSkvaVxufTtcbnZhciBwYXJzZUVyYVBhdHRlcm5zID0ge1xuICBhbnk6IFsvXmIvaSwgL14oYXxjKS9pXVxufTtcbnZhciBtYXRjaFF1YXJ0ZXJQYXR0ZXJucyA9IHtcbiAgbmFycm93OiAvXlsxMjM0XS9pLFxuICBhYmJyZXZpYXRlZDogL15xWzEyMzRdL2ksXG4gIHdpZGU6IC9eWzEyMzRdKHRofHN0fG5kfHJkKT8gcXVhcnRlci9pXG59O1xudmFyIHBhcnNlUXVhcnRlclBhdHRlcm5zID0ge1xuICBhbnk6IFsvMS9pLCAvMi9pLCAvMy9pLCAvNC9pXVxufTtcbnZhciBtYXRjaE1vbnRoUGF0dGVybnMgPSB7XG4gIG5hcnJvdzogL15bamZtYXNvbmRdL2ksXG4gIGFiYnJldmlhdGVkOiAvXihqYW58ZmVifG1hcnxhcHJ8bWF5fGp1bnxqdWx8YXVnfHNlcHxvY3R8bm92fGRlYykvaSxcbiAgd2lkZTogL14oamFudWFyeXxmZWJydWFyeXxtYXJjaHxhcHJpbHxtYXl8anVuZXxqdWx5fGF1Z3VzdHxzZXB0ZW1iZXJ8b2N0b2Jlcnxub3ZlbWJlcnxkZWNlbWJlcikvaVxufTtcbnZhciBwYXJzZU1vbnRoUGF0dGVybnMgPSB7XG4gIG5hcnJvdzogWy9eai9pLCAvXmYvaSwgL15tL2ksIC9eYS9pLCAvXm0vaSwgL15qL2ksIC9eai9pLCAvXmEvaSwgL15zL2ksIC9eby9pLCAvXm4vaSwgL15kL2ldLFxuICBhbnk6IFsvXmphL2ksIC9eZi9pLCAvXm1hci9pLCAvXmFwL2ksIC9ebWF5L2ksIC9eanVuL2ksIC9eanVsL2ksIC9eYXUvaSwgL15zL2ksIC9eby9pLCAvXm4vaSwgL15kL2ldXG59O1xudmFyIG1hdGNoRGF5UGF0dGVybnMgPSB7XG4gIG5hcnJvdzogL15bc210d2ZdL2ksXG4gIHNob3J0OiAvXihzdXxtb3x0dXx3ZXx0aHxmcnxzYSkvaSxcbiAgYWJicmV2aWF0ZWQ6IC9eKHN1bnxtb258dHVlfHdlZHx0aHV8ZnJpfHNhdCkvaSxcbiAgd2lkZTogL14oc3VuZGF5fG1vbmRheXx0dWVzZGF5fHdlZG5lc2RheXx0aHVyc2RheXxmcmlkYXl8c2F0dXJkYXkpL2lcbn07XG52YXIgcGFyc2VEYXlQYXR0ZXJucyA9IHtcbiAgbmFycm93OiBbL15zL2ksIC9ebS9pLCAvXnQvaSwgL153L2ksIC9edC9pLCAvXmYvaSwgL15zL2ldLFxuICBhbnk6IFsvXnN1L2ksIC9ebS9pLCAvXnR1L2ksIC9edy9pLCAvXnRoL2ksIC9eZi9pLCAvXnNhL2ldXG59O1xudmFyIG1hdGNoRGF5UGVyaW9kUGF0dGVybnMgPSB7XG4gIG5hcnJvdzogL14oYXxwfG1pfG58KGluIHRoZXxhdCkgKG1vcm5pbmd8YWZ0ZXJub29ufGV2ZW5pbmd8bmlnaHQpKS9pLFxuICBhbnk6IC9eKFthcF1cXC4/XFxzP21cXC4/fG1pZG5pZ2h0fG5vb258KGluIHRoZXxhdCkgKG1vcm5pbmd8YWZ0ZXJub29ufGV2ZW5pbmd8bmlnaHQpKS9pXG59O1xudmFyIHBhcnNlRGF5UGVyaW9kUGF0dGVybnMgPSB7XG4gIGFueToge1xuICAgIGFtOiAvXmEvaSxcbiAgICBwbTogL15wL2ksXG4gICAgbWlkbmlnaHQ6IC9ebWkvaSxcbiAgICBub29uOiAvXm5vL2ksXG4gICAgbW9ybmluZzogL21vcm5pbmcvaSxcbiAgICBhZnRlcm5vb246IC9hZnRlcm5vb24vaSxcbiAgICBldmVuaW5nOiAvZXZlbmluZy9pLFxuICAgIG5pZ2h0OiAvbmlnaHQvaVxuICB9XG59O1xudmFyIG1hdGNoID0ge1xuICBvcmRpbmFsTnVtYmVyOiBidWlsZE1hdGNoUGF0dGVybkZuKHtcbiAgICBtYXRjaFBhdHRlcm46IG1hdGNoT3JkaW5hbE51bWJlclBhdHRlcm4sXG4gICAgcGFyc2VQYXR0ZXJuOiBwYXJzZU9yZGluYWxOdW1iZXJQYXR0ZXJuLFxuICAgIHZhbHVlQ2FsbGJhY2s6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHBhcnNlSW50KHZhbHVlLCAxMCk7XG4gICAgfVxuICB9KSxcbiAgZXJhOiBidWlsZE1hdGNoRm4oe1xuICAgIG1hdGNoUGF0dGVybnM6IG1hdGNoRXJhUGF0dGVybnMsXG4gICAgZGVmYXVsdE1hdGNoV2lkdGg6ICd3aWRlJyxcbiAgICBwYXJzZVBhdHRlcm5zOiBwYXJzZUVyYVBhdHRlcm5zLFxuICAgIGRlZmF1bHRQYXJzZVdpZHRoOiAnYW55J1xuICB9KSxcbiAgcXVhcnRlcjogYnVpbGRNYXRjaEZuKHtcbiAgICBtYXRjaFBhdHRlcm5zOiBtYXRjaFF1YXJ0ZXJQYXR0ZXJucyxcbiAgICBkZWZhdWx0TWF0Y2hXaWR0aDogJ3dpZGUnLFxuICAgIHBhcnNlUGF0dGVybnM6IHBhcnNlUXVhcnRlclBhdHRlcm5zLFxuICAgIGRlZmF1bHRQYXJzZVdpZHRoOiAnYW55JyxcbiAgICB2YWx1ZUNhbGxiYWNrOiBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgIHJldHVybiBpbmRleCArIDE7XG4gICAgfVxuICB9KSxcbiAgbW9udGg6IGJ1aWxkTWF0Y2hGbih7XG4gICAgbWF0Y2hQYXR0ZXJuczogbWF0Y2hNb250aFBhdHRlcm5zLFxuICAgIGRlZmF1bHRNYXRjaFdpZHRoOiAnd2lkZScsXG4gICAgcGFyc2VQYXR0ZXJuczogcGFyc2VNb250aFBhdHRlcm5zLFxuICAgIGRlZmF1bHRQYXJzZVdpZHRoOiAnYW55J1xuICB9KSxcbiAgZGF5OiBidWlsZE1hdGNoRm4oe1xuICAgIG1hdGNoUGF0dGVybnM6IG1hdGNoRGF5UGF0dGVybnMsXG4gICAgZGVmYXVsdE1hdGNoV2lkdGg6ICd3aWRlJyxcbiAgICBwYXJzZVBhdHRlcm5zOiBwYXJzZURheVBhdHRlcm5zLFxuICAgIGRlZmF1bHRQYXJzZVdpZHRoOiAnYW55J1xuICB9KSxcbiAgZGF5UGVyaW9kOiBidWlsZE1hdGNoRm4oe1xuICAgIG1hdGNoUGF0dGVybnM6IG1hdGNoRGF5UGVyaW9kUGF0dGVybnMsXG4gICAgZGVmYXVsdE1hdGNoV2lkdGg6ICdhbnknLFxuICAgIHBhcnNlUGF0dGVybnM6IHBhcnNlRGF5UGVyaW9kUGF0dGVybnMsXG4gICAgZGVmYXVsdFBhcnNlV2lkdGg6ICdhbnknXG4gIH0pXG59O1xuZXhwb3J0IGRlZmF1bHQgbWF0Y2g7IiwgImltcG9ydCBmb3JtYXREaXN0YW5jZSBmcm9tIFwiLi9fbGliL2Zvcm1hdERpc3RhbmNlL2luZGV4LmpzXCI7XG5pbXBvcnQgZm9ybWF0TG9uZyBmcm9tIFwiLi9fbGliL2Zvcm1hdExvbmcvaW5kZXguanNcIjtcbmltcG9ydCBmb3JtYXRSZWxhdGl2ZSBmcm9tIFwiLi9fbGliL2Zvcm1hdFJlbGF0aXZlL2luZGV4LmpzXCI7XG5pbXBvcnQgbG9jYWxpemUgZnJvbSBcIi4vX2xpYi9sb2NhbGl6ZS9pbmRleC5qc1wiO1xuaW1wb3J0IG1hdGNoIGZyb20gXCIuL19saWIvbWF0Y2gvaW5kZXguanNcIjtcblxuLyoqXG4gKiBAdHlwZSB7TG9jYWxlfVxuICogQGNhdGVnb3J5IExvY2FsZXNcbiAqIEBzdW1tYXJ5IEVuZ2xpc2ggbG9jYWxlIChVbml0ZWQgU3RhdGVzKS5cbiAqIEBsYW5ndWFnZSBFbmdsaXNoXG4gKiBAaXNvLTYzOS0yIGVuZ1xuICogQGF1dGhvciBTYXNoYSBLb3NzIFtAa29zc25vY29ycF17QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2tvc3Nub2NvcnB9XG4gKiBAYXV0aG9yIExlc2hhIEtvc3MgW0BsZXNoYWtvc3Nde0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9sZXNoYWtvc3N9XG4gKi9cbnZhciBsb2NhbGUgPSB7XG4gIGNvZGU6ICdlbi1VUycsXG4gIGZvcm1hdERpc3RhbmNlOiBmb3JtYXREaXN0YW5jZSxcbiAgZm9ybWF0TG9uZzogZm9ybWF0TG9uZyxcbiAgZm9ybWF0UmVsYXRpdmU6IGZvcm1hdFJlbGF0aXZlLFxuICBsb2NhbGl6ZTogbG9jYWxpemUsXG4gIG1hdGNoOiBtYXRjaCxcbiAgb3B0aW9uczoge1xuICAgIHdlZWtTdGFydHNPbjogMFxuICAgIC8qIFN1bmRheSAqL1xuICAgICxcbiAgICBmaXJzdFdlZWtDb250YWluc0RhdGU6IDFcbiAgfVxufTtcbmV4cG9ydCBkZWZhdWx0IGxvY2FsZTsiLCAiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYXNzaWduKHRhcmdldCwgZGlydHlPYmplY3QpIHtcbiAgaWYgKHRhcmdldCA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYXNzaWduIHJlcXVpcmVzIHRoYXQgaW5wdXQgcGFyYW1ldGVyIG5vdCBiZSBudWxsIG9yIHVuZGVmaW5lZCcpO1xuICB9XG5cbiAgZGlydHlPYmplY3QgPSBkaXJ0eU9iamVjdCB8fCB7fTtcblxuICBmb3IgKHZhciBwcm9wZXJ0eSBpbiBkaXJ0eU9iamVjdCkge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZGlydHlPYmplY3QsIHByb3BlcnR5KSkge1xuICAgICAgdGFyZ2V0W3Byb3BlcnR5XSA9IGRpcnR5T2JqZWN0W3Byb3BlcnR5XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufSIsICJpbXBvcnQgYXNzaWduIGZyb20gXCIuLi9hc3NpZ24vaW5kZXguanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNsb25lT2JqZWN0KGRpcnR5T2JqZWN0KSB7XG4gIHJldHVybiBhc3NpZ24oe30sIGRpcnR5T2JqZWN0KTtcbn0iLCAiaW1wb3J0IGNvbXBhcmVBc2MgZnJvbSBcIi4uL2NvbXBhcmVBc2MvaW5kZXguanNcIjtcbmltcG9ydCBkaWZmZXJlbmNlSW5Nb250aHMgZnJvbSBcIi4uL2RpZmZlcmVuY2VJbk1vbnRocy9pbmRleC5qc1wiO1xuaW1wb3J0IGRpZmZlcmVuY2VJblNlY29uZHMgZnJvbSBcIi4uL2RpZmZlcmVuY2VJblNlY29uZHMvaW5kZXguanNcIjtcbmltcG9ydCBkZWZhdWx0TG9jYWxlIGZyb20gXCIuLi9sb2NhbGUvZW4tVVMvaW5kZXguanNcIjtcbmltcG9ydCB0b0RhdGUgZnJvbSBcIi4uL3RvRGF0ZS9pbmRleC5qc1wiO1xuaW1wb3J0IGNsb25lT2JqZWN0IGZyb20gXCIuLi9fbGliL2Nsb25lT2JqZWN0L2luZGV4LmpzXCI7XG5pbXBvcnQgZ2V0VGltZXpvbmVPZmZzZXRJbk1pbGxpc2Vjb25kcyBmcm9tIFwiLi4vX2xpYi9nZXRUaW1lem9uZU9mZnNldEluTWlsbGlzZWNvbmRzL2luZGV4LmpzXCI7XG5pbXBvcnQgcmVxdWlyZWRBcmdzIGZyb20gXCIuLi9fbGliL3JlcXVpcmVkQXJncy9pbmRleC5qc1wiO1xudmFyIE1JTlVURVNfSU5fREFZID0gMTQ0MDtcbnZhciBNSU5VVEVTX0lOX0FMTU9TVF9UV09fREFZUyA9IDI1MjA7XG52YXIgTUlOVVRFU19JTl9NT05USCA9IDQzMjAwO1xudmFyIE1JTlVURVNfSU5fVFdPX01PTlRIUyA9IDg2NDAwO1xuLyoqXG4gKiBAbmFtZSBmb3JtYXREaXN0YW5jZVxuICogQGNhdGVnb3J5IENvbW1vbiBIZWxwZXJzXG4gKiBAc3VtbWFyeSBSZXR1cm4gdGhlIGRpc3RhbmNlIGJldHdlZW4gdGhlIGdpdmVuIGRhdGVzIGluIHdvcmRzLlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogUmV0dXJuIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBnaXZlbiBkYXRlcyBpbiB3b3Jkcy5cbiAqXG4gKiB8IERpc3RhbmNlIGJldHdlZW4gZGF0ZXMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgUmVzdWx0ICAgICAgICAgICAgICB8XG4gKiB8LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tLS0tLS0tLS18XG4gKiB8IDAgLi4uIDMwIHNlY3MgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgbGVzcyB0aGFuIGEgbWludXRlICB8XG4gKiB8IDMwIHNlY3MgLi4uIDEgbWluIDMwIHNlY3MgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgMSBtaW51dGUgICAgICAgICAgICB8XG4gKiB8IDEgbWluIDMwIHNlY3MgLi4uIDQ0IG1pbnMgMzAgc2VjcyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgWzIuLjQ0XSBtaW51dGVzICAgICB8XG4gKiB8IDQ0IG1pbnMgLi4uIDMwIHNlY3MgLi4uIDg5IG1pbnMgMzAgc2VjcyAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgYWJvdXQgMSBob3VyICAgICAgICB8XG4gKiB8IDg5IG1pbnMgMzAgc2VjcyAuLi4gMjMgaHJzIDU5IG1pbnMgMzAgc2VjcyAgICAgICAgICAgICAgICAgICAgICAgIHwgYWJvdXQgWzIuLjI0XSBob3VycyB8XG4gKiB8IDIzIGhycyA1OSBtaW5zIDMwIHNlY3MgLi4uIDQxIGhycyA1OSBtaW5zIDMwIHNlY3MgICAgICAgICAgICAgICAgIHwgMSBkYXkgICAgICAgICAgICAgICB8XG4gKiB8IDQxIGhycyA1OSBtaW5zIDMwIHNlY3MgLi4uIDI5IGRheXMgMjMgaHJzIDU5IG1pbnMgMzAgc2VjcyAgICAgICAgIHwgWzIuLjMwXSBkYXlzICAgICAgICB8XG4gKiB8IDI5IGRheXMgMjMgaHJzIDU5IG1pbnMgMzAgc2VjcyAuLi4gNDQgZGF5cyAyMyBocnMgNTkgbWlucyAzMCBzZWNzIHwgYWJvdXQgMSBtb250aCAgICAgICB8XG4gKiB8IDQ0IGRheXMgMjMgaHJzIDU5IG1pbnMgMzAgc2VjcyAuLi4gNTkgZGF5cyAyMyBocnMgNTkgbWlucyAzMCBzZWNzIHwgYWJvdXQgMiBtb250aHMgICAgICB8XG4gKiB8IDU5IGRheXMgMjMgaHJzIDU5IG1pbnMgMzAgc2VjcyAuLi4gMSB5ciAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgWzIuLjEyXSBtb250aHMgICAgICB8XG4gKiB8IDEgeXIgLi4uIDEgeXIgMyBtb250aHMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgYWJvdXQgMSB5ZWFyICAgICAgICB8XG4gKiB8IDEgeXIgMyBtb250aHMgLi4uIDEgeXIgOSBtb250aCBzICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgb3ZlciAxIHllYXIgICAgICAgICB8XG4gKiB8IDEgeXIgOSBtb250aHMgLi4uIDIgeXJzICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgYWxtb3N0IDIgeWVhcnMgICAgICB8XG4gKiB8IE4geXJzIC4uLiBOIHlycyAzIG1vbnRocyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgYWJvdXQgTiB5ZWFycyAgICAgICB8XG4gKiB8IE4geXJzIDMgbW9udGhzIC4uLiBOIHlycyA5IG1vbnRocyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgb3ZlciBOIHllYXJzICAgICAgICB8XG4gKiB8IE4geXJzIDkgbW9udGhzIC4uLiBOKzEgeXJzICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgYWxtb3N0IE4rMSB5ZWFycyAgICB8XG4gKlxuICogV2l0aCBgb3B0aW9ucy5pbmNsdWRlU2Vjb25kcyA9PSB0cnVlYDpcbiAqIHwgRGlzdGFuY2UgYmV0d2VlbiBkYXRlcyB8IFJlc3VsdCAgICAgICAgICAgICAgIHxcbiAqIHwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18LS0tLS0tLS0tLS0tLS0tLS0tLS0tLXxcbiAqIHwgMCBzZWNzIC4uLiA1IHNlY3MgICAgICB8IGxlc3MgdGhhbiA1IHNlY29uZHMgIHxcbiAqIHwgNSBzZWNzIC4uLiAxMCBzZWNzICAgICB8IGxlc3MgdGhhbiAxMCBzZWNvbmRzIHxcbiAqIHwgMTAgc2VjcyAuLi4gMjAgc2VjcyAgICB8IGxlc3MgdGhhbiAyMCBzZWNvbmRzIHxcbiAqIHwgMjAgc2VjcyAuLi4gNDAgc2VjcyAgICB8IGhhbGYgYSBtaW51dGUgICAgICAgIHxcbiAqIHwgNDAgc2VjcyAuLi4gNjAgc2VjcyAgICB8IGxlc3MgdGhhbiBhIG1pbnV0ZSAgIHxcbiAqIHwgNjAgc2VjcyAuLi4gOTAgc2VjcyAgICB8IDEgbWludXRlICAgICAgICAgICAgIHxcbiAqXG4gKiAjIyMgdjIuMC4wIGJyZWFraW5nIGNoYW5nZXM6XG4gKlxuICogLSBbQ2hhbmdlcyB0aGF0IGFyZSBjb21tb24gZm9yIHRoZSB3aG9sZSBsaWJyYXJ5XShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvZGF0ZS1mbnMvYmxvYi9tYXN0ZXIvZG9jcy91cGdyYWRlR3VpZGUubWQjQ29tbW9uLUNoYW5nZXMpLlxuICpcbiAqIC0gVGhlIGZ1bmN0aW9uIHdhcyByZW5hbWVkIGZyb20gYGRpc3RhbmNlSW5Xb3JkcyBgIHRvIGBmb3JtYXREaXN0YW5jZWBcbiAqICAgdG8gbWFrZSBpdHMgbmFtZSBjb25zaXN0ZW50IHdpdGggYGZvcm1hdGAgYW5kIGBmb3JtYXRSZWxhdGl2ZWAuXG4gKlxuICogLSBUaGUgb3JkZXIgb2YgYXJndW1lbnRzIGlzIHN3YXBwZWQgdG8gbWFrZSB0aGUgZnVuY3Rpb25cbiAqICAgY29uc2lzdGVudCB3aXRoIGBkaWZmZXJlbmNlSW4uLi5gIGZ1bmN0aW9ucy5cbiAqXG4gKiAgIGBgYGphdmFzY3JpcHRcbiAqICAgLy8gQmVmb3JlIHYyLjAuMFxuICpcbiAqICAgZGlzdGFuY2VJbldvcmRzKFxuICogICAgIG5ldyBEYXRlKDE5ODYsIDMsIDQsIDEwLCAzMiwgMCksXG4gKiAgICAgbmV3IERhdGUoMTk4NiwgMywgNCwgMTEsIDMyLCAwKSxcbiAqICAgICB7IGFkZFN1ZmZpeDogdHJ1ZSB9XG4gKiAgICkgLy89PiAnaW4gYWJvdXQgMSBob3VyJ1xuICpcbiAqICAgLy8gdjIuMC4wIG9ud2FyZFxuICpcbiAqICAgZm9ybWF0RGlzdGFuY2UoXG4gKiAgICAgbmV3IERhdGUoMTk4NiwgMywgNCwgMTEsIDMyLCAwKSxcbiAqICAgICBuZXcgRGF0ZSgxOTg2LCAzLCA0LCAxMCwgMzIsIDApLFxuICogICAgIHsgYWRkU3VmZml4OiB0cnVlIH1cbiAqICAgKSAvLz0+ICdpbiBhYm91dCAxIGhvdXInXG4gKiAgIGBgYFxuICpcbiAqIEBwYXJhbSB7RGF0ZXxOdW1iZXJ9IGRhdGUgLSB0aGUgZGF0ZVxuICogQHBhcmFtIHtEYXRlfE51bWJlcn0gYmFzZURhdGUgLSB0aGUgZGF0ZSB0byBjb21wYXJlIHdpdGhcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBhbiBvYmplY3Qgd2l0aCBvcHRpb25zLlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5pbmNsdWRlU2Vjb25kcz1mYWxzZV0gLSBkaXN0YW5jZXMgbGVzcyB0aGFuIGEgbWludXRlIGFyZSBtb3JlIGRldGFpbGVkXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmFkZFN1ZmZpeD1mYWxzZV0gLSByZXN1bHQgaW5kaWNhdGVzIGlmIHRoZSBzZWNvbmQgZGF0ZSBpcyBlYXJsaWVyIG9yIGxhdGVyIHRoYW4gdGhlIGZpcnN0XG4gKiBAcGFyYW0ge0xvY2FsZX0gW29wdGlvbnMubG9jYWxlPWRlZmF1bHRMb2NhbGVdIC0gdGhlIGxvY2FsZSBvYmplY3QuIFNlZSBbTG9jYWxlXXtAbGluayBodHRwczovL2RhdGUtZm5zLm9yZy9kb2NzL0xvY2FsZX1cbiAqIEByZXR1cm5zIHtTdHJpbmd9IHRoZSBkaXN0YW5jZSBpbiB3b3Jkc1xuICogQHRocm93cyB7VHlwZUVycm9yfSAyIGFyZ3VtZW50cyByZXF1aXJlZFxuICogQHRocm93cyB7UmFuZ2VFcnJvcn0gYGRhdGVgIG11c3Qgbm90IGJlIEludmFsaWQgRGF0ZVxuICogQHRocm93cyB7UmFuZ2VFcnJvcn0gYGJhc2VEYXRlYCBtdXN0IG5vdCBiZSBJbnZhbGlkIERhdGVcbiAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9IGBvcHRpb25zLmxvY2FsZWAgbXVzdCBjb250YWluIGBmb3JtYXREaXN0YW5jZWAgcHJvcGVydHlcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gV2hhdCBpcyB0aGUgZGlzdGFuY2UgYmV0d2VlbiAyIEp1bHkgMjAxNCBhbmQgMSBKYW51YXJ5IDIwMTU/XG4gKiBjb25zdCByZXN1bHQgPSBmb3JtYXREaXN0YW5jZShuZXcgRGF0ZSgyMDE0LCA2LCAyKSwgbmV3IERhdGUoMjAxNSwgMCwgMSkpXG4gKiAvLz0+ICc2IG1vbnRocydcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gV2hhdCBpcyB0aGUgZGlzdGFuY2UgYmV0d2VlbiAxIEphbnVhcnkgMjAxNSAwMDowMDoxNVxuICogLy8gYW5kIDEgSmFudWFyeSAyMDE1IDAwOjAwOjAwLCBpbmNsdWRpbmcgc2Vjb25kcz9cbiAqIGNvbnN0IHJlc3VsdCA9IGZvcm1hdERpc3RhbmNlKFxuICogICBuZXcgRGF0ZSgyMDE1LCAwLCAxLCAwLCAwLCAxNSksXG4gKiAgIG5ldyBEYXRlKDIwMTUsIDAsIDEsIDAsIDAsIDApLFxuICogICB7IGluY2x1ZGVTZWNvbmRzOiB0cnVlIH1cbiAqIClcbiAqIC8vPT4gJ2xlc3MgdGhhbiAyMCBzZWNvbmRzJ1xuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBXaGF0IGlzIHRoZSBkaXN0YW5jZSBmcm9tIDEgSmFudWFyeSAyMDE2XG4gKiAvLyB0byAxIEphbnVhcnkgMjAxNSwgd2l0aCBhIHN1ZmZpeD9cbiAqIGNvbnN0IHJlc3VsdCA9IGZvcm1hdERpc3RhbmNlKG5ldyBEYXRlKDIwMTUsIDAsIDEpLCBuZXcgRGF0ZSgyMDE2LCAwLCAxKSwge1xuICogICBhZGRTdWZmaXg6IHRydWVcbiAqIH0pXG4gKiAvLz0+ICdhYm91dCAxIHllYXIgYWdvJ1xuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBXaGF0IGlzIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIDEgQXVndXN0IDIwMTYgYW5kIDEgSmFudWFyeSAyMDE1IGluIEVzcGVyYW50bz9cbiAqIGltcG9ydCB7IGVvTG9jYWxlIH0gZnJvbSAnZGF0ZS1mbnMvbG9jYWxlL2VvJ1xuICogY29uc3QgcmVzdWx0ID0gZm9ybWF0RGlzdGFuY2UobmV3IERhdGUoMjAxNiwgNywgMSksIG5ldyBEYXRlKDIwMTUsIDAsIDEpLCB7XG4gKiAgIGxvY2FsZTogZW9Mb2NhbGVcbiAqIH0pXG4gKiAvLz0+ICdwbGkgb2wgMSBqYXJvJ1xuICovXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGZvcm1hdERpc3RhbmNlKGRpcnR5RGF0ZSwgZGlydHlCYXNlRGF0ZSkge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gIHJlcXVpcmVkQXJncygyLCBhcmd1bWVudHMpO1xuICB2YXIgbG9jYWxlID0gb3B0aW9ucy5sb2NhbGUgfHwgZGVmYXVsdExvY2FsZTtcblxuICBpZiAoIWxvY2FsZS5mb3JtYXREaXN0YW5jZSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdsb2NhbGUgbXVzdCBjb250YWluIGZvcm1hdERpc3RhbmNlIHByb3BlcnR5Jyk7XG4gIH1cblxuICB2YXIgY29tcGFyaXNvbiA9IGNvbXBhcmVBc2MoZGlydHlEYXRlLCBkaXJ0eUJhc2VEYXRlKTtcblxuICBpZiAoaXNOYU4oY29tcGFyaXNvbikpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCB0aW1lIHZhbHVlJyk7XG4gIH1cblxuICB2YXIgbG9jYWxpemVPcHRpb25zID0gY2xvbmVPYmplY3Qob3B0aW9ucyk7XG4gIGxvY2FsaXplT3B0aW9ucy5hZGRTdWZmaXggPSBCb29sZWFuKG9wdGlvbnMuYWRkU3VmZml4KTtcbiAgbG9jYWxpemVPcHRpb25zLmNvbXBhcmlzb24gPSBjb21wYXJpc29uO1xuICB2YXIgZGF0ZUxlZnQ7XG4gIHZhciBkYXRlUmlnaHQ7XG5cbiAgaWYgKGNvbXBhcmlzb24gPiAwKSB7XG4gICAgZGF0ZUxlZnQgPSB0b0RhdGUoZGlydHlCYXNlRGF0ZSk7XG4gICAgZGF0ZVJpZ2h0ID0gdG9EYXRlKGRpcnR5RGF0ZSk7XG4gIH0gZWxzZSB7XG4gICAgZGF0ZUxlZnQgPSB0b0RhdGUoZGlydHlEYXRlKTtcbiAgICBkYXRlUmlnaHQgPSB0b0RhdGUoZGlydHlCYXNlRGF0ZSk7XG4gIH1cblxuICB2YXIgc2Vjb25kcyA9IGRpZmZlcmVuY2VJblNlY29uZHMoZGF0ZVJpZ2h0LCBkYXRlTGVmdCk7XG4gIHZhciBvZmZzZXRJblNlY29uZHMgPSAoZ2V0VGltZXpvbmVPZmZzZXRJbk1pbGxpc2Vjb25kcyhkYXRlUmlnaHQpIC0gZ2V0VGltZXpvbmVPZmZzZXRJbk1pbGxpc2Vjb25kcyhkYXRlTGVmdCkpIC8gMTAwMDtcbiAgdmFyIG1pbnV0ZXMgPSBNYXRoLnJvdW5kKChzZWNvbmRzIC0gb2Zmc2V0SW5TZWNvbmRzKSAvIDYwKTtcbiAgdmFyIG1vbnRoczsgLy8gMCB1cCB0byAyIG1pbnNcblxuICBpZiAobWludXRlcyA8IDIpIHtcbiAgICBpZiAob3B0aW9ucy5pbmNsdWRlU2Vjb25kcykge1xuICAgICAgaWYgKHNlY29uZHMgPCA1KSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUuZm9ybWF0RGlzdGFuY2UoJ2xlc3NUaGFuWFNlY29uZHMnLCA1LCBsb2NhbGl6ZU9wdGlvbnMpO1xuICAgICAgfSBlbHNlIGlmIChzZWNvbmRzIDwgMTApIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS5mb3JtYXREaXN0YW5jZSgnbGVzc1RoYW5YU2Vjb25kcycsIDEwLCBsb2NhbGl6ZU9wdGlvbnMpO1xuICAgICAgfSBlbHNlIGlmIChzZWNvbmRzIDwgMjApIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS5mb3JtYXREaXN0YW5jZSgnbGVzc1RoYW5YU2Vjb25kcycsIDIwLCBsb2NhbGl6ZU9wdGlvbnMpO1xuICAgICAgfSBlbHNlIGlmIChzZWNvbmRzIDwgNDApIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS5mb3JtYXREaXN0YW5jZSgnaGFsZkFNaW51dGUnLCBudWxsLCBsb2NhbGl6ZU9wdGlvbnMpO1xuICAgICAgfSBlbHNlIGlmIChzZWNvbmRzIDwgNjApIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS5mb3JtYXREaXN0YW5jZSgnbGVzc1RoYW5YTWludXRlcycsIDEsIGxvY2FsaXplT3B0aW9ucyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbG9jYWxlLmZvcm1hdERpc3RhbmNlKCd4TWludXRlcycsIDEsIGxvY2FsaXplT3B0aW9ucyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChtaW51dGVzID09PSAwKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUuZm9ybWF0RGlzdGFuY2UoJ2xlc3NUaGFuWE1pbnV0ZXMnLCAxLCBsb2NhbGl6ZU9wdGlvbnMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS5mb3JtYXREaXN0YW5jZSgneE1pbnV0ZXMnLCBtaW51dGVzLCBsb2NhbGl6ZU9wdGlvbnMpO1xuICAgICAgfVxuICAgIH0gLy8gMiBtaW5zIHVwIHRvIDAuNzUgaHJzXG5cbiAgfSBlbHNlIGlmIChtaW51dGVzIDwgNDUpIHtcbiAgICByZXR1cm4gbG9jYWxlLmZvcm1hdERpc3RhbmNlKCd4TWludXRlcycsIG1pbnV0ZXMsIGxvY2FsaXplT3B0aW9ucyk7IC8vIDAuNzUgaHJzIHVwIHRvIDEuNSBocnNcbiAgfSBlbHNlIGlmIChtaW51dGVzIDwgOTApIHtcbiAgICByZXR1cm4gbG9jYWxlLmZvcm1hdERpc3RhbmNlKCdhYm91dFhIb3VycycsIDEsIGxvY2FsaXplT3B0aW9ucyk7IC8vIDEuNSBocnMgdXAgdG8gMjQgaHJzXG4gIH0gZWxzZSBpZiAobWludXRlcyA8IE1JTlVURVNfSU5fREFZKSB7XG4gICAgdmFyIGhvdXJzID0gTWF0aC5yb3VuZChtaW51dGVzIC8gNjApO1xuICAgIHJldHVybiBsb2NhbGUuZm9ybWF0RGlzdGFuY2UoJ2Fib3V0WEhvdXJzJywgaG91cnMsIGxvY2FsaXplT3B0aW9ucyk7IC8vIDEgZGF5IHVwIHRvIDEuNzUgZGF5c1xuICB9IGVsc2UgaWYgKG1pbnV0ZXMgPCBNSU5VVEVTX0lOX0FMTU9TVF9UV09fREFZUykge1xuICAgIHJldHVybiBsb2NhbGUuZm9ybWF0RGlzdGFuY2UoJ3hEYXlzJywgMSwgbG9jYWxpemVPcHRpb25zKTsgLy8gMS43NSBkYXlzIHVwIHRvIDMwIGRheXNcbiAgfSBlbHNlIGlmIChtaW51dGVzIDwgTUlOVVRFU19JTl9NT05USCkge1xuICAgIHZhciBkYXlzID0gTWF0aC5yb3VuZChtaW51dGVzIC8gTUlOVVRFU19JTl9EQVkpO1xuICAgIHJldHVybiBsb2NhbGUuZm9ybWF0RGlzdGFuY2UoJ3hEYXlzJywgZGF5cywgbG9jYWxpemVPcHRpb25zKTsgLy8gMSBtb250aCB1cCB0byAyIG1vbnRoc1xuICB9IGVsc2UgaWYgKG1pbnV0ZXMgPCBNSU5VVEVTX0lOX1RXT19NT05USFMpIHtcbiAgICBtb250aHMgPSBNYXRoLnJvdW5kKG1pbnV0ZXMgLyBNSU5VVEVTX0lOX01PTlRIKTtcbiAgICByZXR1cm4gbG9jYWxlLmZvcm1hdERpc3RhbmNlKCdhYm91dFhNb250aHMnLCBtb250aHMsIGxvY2FsaXplT3B0aW9ucyk7XG4gIH1cblxuICBtb250aHMgPSBkaWZmZXJlbmNlSW5Nb250aHMoZGF0ZVJpZ2h0LCBkYXRlTGVmdCk7IC8vIDIgbW9udGhzIHVwIHRvIDEyIG1vbnRoc1xuXG4gIGlmIChtb250aHMgPCAxMikge1xuICAgIHZhciBuZWFyZXN0TW9udGggPSBNYXRoLnJvdW5kKG1pbnV0ZXMgLyBNSU5VVEVTX0lOX01PTlRIKTtcbiAgICByZXR1cm4gbG9jYWxlLmZvcm1hdERpc3RhbmNlKCd4TW9udGhzJywgbmVhcmVzdE1vbnRoLCBsb2NhbGl6ZU9wdGlvbnMpOyAvLyAxIHllYXIgdXAgdG8gbWF4IERhdGVcbiAgfSBlbHNlIHtcbiAgICB2YXIgbW9udGhzU2luY2VTdGFydE9mWWVhciA9IG1vbnRocyAlIDEyO1xuICAgIHZhciB5ZWFycyA9IE1hdGguZmxvb3IobW9udGhzIC8gMTIpOyAvLyBOIHllYXJzIHVwIHRvIDEgeWVhcnMgMyBtb250aHNcblxuICAgIGlmIChtb250aHNTaW5jZVN0YXJ0T2ZZZWFyIDwgMykge1xuICAgICAgcmV0dXJuIGxvY2FsZS5mb3JtYXREaXN0YW5jZSgnYWJvdXRYWWVhcnMnLCB5ZWFycywgbG9jYWxpemVPcHRpb25zKTsgLy8gTiB5ZWFycyAzIG1vbnRocyB1cCB0byBOIHllYXJzIDkgbW9udGhzXG4gICAgfSBlbHNlIGlmIChtb250aHNTaW5jZVN0YXJ0T2ZZZWFyIDwgOSkge1xuICAgICAgcmV0dXJuIGxvY2FsZS5mb3JtYXREaXN0YW5jZSgnb3ZlclhZZWFycycsIHllYXJzLCBsb2NhbGl6ZU9wdGlvbnMpOyAvLyBOIHllYXJzIDkgbW9udGhzIHVwIHRvIE4geWVhciAxMiBtb250aHNcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGxvY2FsZS5mb3JtYXREaXN0YW5jZSgnYWxtb3N0WFllYXJzJywgeWVhcnMgKyAxLCBsb2NhbGl6ZU9wdGlvbnMpO1xuICAgIH1cbiAgfVxufSIsICJpbXBvcnQgZGlzdGFuY2VJbldvcmRzIGZyb20gXCIuLi9mb3JtYXREaXN0YW5jZS9pbmRleC5qc1wiO1xuaW1wb3J0IHJlcXVpcmVkQXJncyBmcm9tIFwiLi4vX2xpYi9yZXF1aXJlZEFyZ3MvaW5kZXguanNcIjtcbi8qKlxuICogQG5hbWUgZm9ybWF0RGlzdGFuY2VUb05vd1xuICogQGNhdGVnb3J5IENvbW1vbiBIZWxwZXJzXG4gKiBAc3VtbWFyeSBSZXR1cm4gdGhlIGRpc3RhbmNlIGJldHdlZW4gdGhlIGdpdmVuIGRhdGUgYW5kIG5vdyBpbiB3b3Jkcy5cbiAqIEBwdXJlIGZhbHNlXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBSZXR1cm4gdGhlIGRpc3RhbmNlIGJldHdlZW4gdGhlIGdpdmVuIGRhdGUgYW5kIG5vdyBpbiB3b3Jkcy5cbiAqXG4gKiB8IERpc3RhbmNlIHRvIG5vdyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgUmVzdWx0ICAgICAgICAgICAgICB8XG4gKiB8LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tLS0tLS0tLS18XG4gKiB8IDAgLi4uIDMwIHNlY3MgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgbGVzcyB0aGFuIGEgbWludXRlICB8XG4gKiB8IDMwIHNlY3MgLi4uIDEgbWluIDMwIHNlY3MgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgMSBtaW51dGUgICAgICAgICAgICB8XG4gKiB8IDEgbWluIDMwIHNlY3MgLi4uIDQ0IG1pbnMgMzAgc2VjcyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgWzIuLjQ0XSBtaW51dGVzICAgICB8XG4gKiB8IDQ0IG1pbnMgLi4uIDMwIHNlY3MgLi4uIDg5IG1pbnMgMzAgc2VjcyAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgYWJvdXQgMSBob3VyICAgICAgICB8XG4gKiB8IDg5IG1pbnMgMzAgc2VjcyAuLi4gMjMgaHJzIDU5IG1pbnMgMzAgc2VjcyAgICAgICAgICAgICAgICAgICAgICAgIHwgYWJvdXQgWzIuLjI0XSBob3VycyB8XG4gKiB8IDIzIGhycyA1OSBtaW5zIDMwIHNlY3MgLi4uIDQxIGhycyA1OSBtaW5zIDMwIHNlY3MgICAgICAgICAgICAgICAgIHwgMSBkYXkgICAgICAgICAgICAgICB8XG4gKiB8IDQxIGhycyA1OSBtaW5zIDMwIHNlY3MgLi4uIDI5IGRheXMgMjMgaHJzIDU5IG1pbnMgMzAgc2VjcyAgICAgICAgIHwgWzIuLjMwXSBkYXlzICAgICAgICB8XG4gKiB8IDI5IGRheXMgMjMgaHJzIDU5IG1pbnMgMzAgc2VjcyAuLi4gNDQgZGF5cyAyMyBocnMgNTkgbWlucyAzMCBzZWNzIHwgYWJvdXQgMSBtb250aCAgICAgICB8XG4gKiB8IDQ0IGRheXMgMjMgaHJzIDU5IG1pbnMgMzAgc2VjcyAuLi4gNTkgZGF5cyAyMyBocnMgNTkgbWlucyAzMCBzZWNzIHwgYWJvdXQgMiBtb250aHMgICAgICB8XG4gKiB8IDU5IGRheXMgMjMgaHJzIDU5IG1pbnMgMzAgc2VjcyAuLi4gMSB5ciAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgWzIuLjEyXSBtb250aHMgICAgICB8XG4gKiB8IDEgeXIgLi4uIDEgeXIgMyBtb250aHMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgYWJvdXQgMSB5ZWFyICAgICAgICB8XG4gKiB8IDEgeXIgMyBtb250aHMgLi4uIDEgeXIgOSBtb250aCBzICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgb3ZlciAxIHllYXIgICAgICAgICB8XG4gKiB8IDEgeXIgOSBtb250aHMgLi4uIDIgeXJzICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgYWxtb3N0IDIgeWVhcnMgICAgICB8XG4gKiB8IE4geXJzIC4uLiBOIHlycyAzIG1vbnRocyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgYWJvdXQgTiB5ZWFycyAgICAgICB8XG4gKiB8IE4geXJzIDMgbW9udGhzIC4uLiBOIHlycyA5IG1vbnRocyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgb3ZlciBOIHllYXJzICAgICAgICB8XG4gKiB8IE4geXJzIDkgbW9udGhzIC4uLiBOKzEgeXJzICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgYWxtb3N0IE4rMSB5ZWFycyAgICB8XG4gKlxuICogV2l0aCBgb3B0aW9ucy5pbmNsdWRlU2Vjb25kcyA9PSB0cnVlYDpcbiAqIHwgRGlzdGFuY2UgdG8gbm93ICAgICB8IFJlc3VsdCAgICAgICAgICAgICAgIHxcbiAqIHwtLS0tLS0tLS0tLS0tLS0tLS0tLS18LS0tLS0tLS0tLS0tLS0tLS0tLS0tLXxcbiAqIHwgMCBzZWNzIC4uLiA1IHNlY3MgICB8IGxlc3MgdGhhbiA1IHNlY29uZHMgIHxcbiAqIHwgNSBzZWNzIC4uLiAxMCBzZWNzICB8IGxlc3MgdGhhbiAxMCBzZWNvbmRzIHxcbiAqIHwgMTAgc2VjcyAuLi4gMjAgc2VjcyB8IGxlc3MgdGhhbiAyMCBzZWNvbmRzIHxcbiAqIHwgMjAgc2VjcyAuLi4gNDAgc2VjcyB8IGhhbGYgYSBtaW51dGUgICAgICAgIHxcbiAqIHwgNDAgc2VjcyAuLi4gNjAgc2VjcyB8IGxlc3MgdGhhbiBhIG1pbnV0ZSAgIHxcbiAqIHwgNjAgc2VjcyAuLi4gOTAgc2VjcyB8IDEgbWludXRlICAgICAgICAgICAgIHxcbiAqXG4gKiA+IFx1MjZBMFx1RkUwRiBQbGVhc2Ugbm90ZSB0aGF0IHRoaXMgZnVuY3Rpb24gaXMgbm90IHByZXNlbnQgaW4gdGhlIEZQIHN1Ym1vZHVsZSBhc1xuICogPiBpdCB1c2VzIGBEYXRlLm5vdygpYCBpbnRlcm5hbGx5IGhlbmNlIGltcHVyZSBhbmQgY2FuJ3QgYmUgc2FmZWx5IGN1cnJpZWQuXG4gKlxuICogIyMjIHYyLjAuMCBicmVha2luZyBjaGFuZ2VzOlxuICpcbiAqIC0gW0NoYW5nZXMgdGhhdCBhcmUgY29tbW9uIGZvciB0aGUgd2hvbGUgbGlicmFyeV0oaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL2RhdGUtZm5zL2Jsb2IvbWFzdGVyL2RvY3MvdXBncmFkZUd1aWRlLm1kI0NvbW1vbi1DaGFuZ2VzKS5cbiAqXG4gKiAtIFRoZSBmdW5jdGlvbiB3YXMgcmVuYW1lZCBmcm9tIGBkaXN0YW5jZUluV29yZHNUb05vdyBgIHRvIGBmb3JtYXREaXN0YW5jZVRvTm93YFxuICogICB0byBtYWtlIGl0cyBuYW1lIGNvbnNpc3RlbnQgd2l0aCBgZm9ybWF0YCBhbmQgYGZvcm1hdFJlbGF0aXZlYC5cbiAqXG4gKiAgIGBgYGphdmFzY3JpcHRcbiAqICAgLy8gQmVmb3JlIHYyLjAuMFxuICpcbiAqICAgZGlzdGFuY2VJbldvcmRzVG9Ob3cobmV3IERhdGUoMjAxNCwgNiwgMiksIHsgYWRkU3VmZml4OiB0cnVlIH0pXG4gKiAgIC8vPT4gJ2luIDYgbW9udGhzJ1xuICpcbiAqICAgLy8gdjIuMC4wIG9ud2FyZFxuICpcbiAqICAgZm9ybWF0RGlzdGFuY2VUb05vdyhuZXcgRGF0ZSgyMDE0LCA2LCAyKSwgeyBhZGRTdWZmaXg6IHRydWUgfSlcbiAqICAgLy89PiAnaW4gNiBtb250aHMnXG4gKiAgIGBgYFxuICpcbiAqIEBwYXJhbSB7RGF0ZXxOdW1iZXJ9IGRhdGUgLSB0aGUgZ2l2ZW4gZGF0ZVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIHRoZSBvYmplY3Qgd2l0aCBvcHRpb25zXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmluY2x1ZGVTZWNvbmRzPWZhbHNlXSAtIGRpc3RhbmNlcyBsZXNzIHRoYW4gYSBtaW51dGUgYXJlIG1vcmUgZGV0YWlsZWRcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYWRkU3VmZml4PWZhbHNlXSAtIHJlc3VsdCBzcGVjaWZpZXMgaWYgbm93IGlzIGVhcmxpZXIgb3IgbGF0ZXIgdGhhbiB0aGUgcGFzc2VkIGRhdGVcbiAqIEBwYXJhbSB7TG9jYWxlfSBbb3B0aW9ucy5sb2NhbGU9ZGVmYXVsdExvY2FsZV0gLSB0aGUgbG9jYWxlIG9iamVjdC4gU2VlIFtMb2NhbGVde0BsaW5rIGh0dHBzOi8vZGF0ZS1mbnMub3JnL2RvY3MvTG9jYWxlfVxuICogQHJldHVybnMge1N0cmluZ30gdGhlIGRpc3RhbmNlIGluIHdvcmRzXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IDEgYXJndW1lbnQgcmVxdWlyZWRcbiAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9IGBkYXRlYCBtdXN0IG5vdCBiZSBJbnZhbGlkIERhdGVcbiAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9IGBvcHRpb25zLmxvY2FsZWAgbXVzdCBjb250YWluIGBmb3JtYXREaXN0YW5jZWAgcHJvcGVydHlcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gSWYgdG9kYXkgaXMgMSBKYW51YXJ5IDIwMTUsIHdoYXQgaXMgdGhlIGRpc3RhbmNlIHRvIDIgSnVseSAyMDE0P1xuICogdmFyIHJlc3VsdCA9IGZvcm1hdERpc3RhbmNlVG9Ob3coXG4gKiAgIG5ldyBEYXRlKDIwMTQsIDYsIDIpXG4gKiApXG4gKiAvLz0+ICc2IG1vbnRocydcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gSWYgbm93IGlzIDEgSmFudWFyeSAyMDE1IDAwOjAwOjAwLFxuICogLy8gd2hhdCBpcyB0aGUgZGlzdGFuY2UgdG8gMSBKYW51YXJ5IDIwMTUgMDA6MDA6MTUsIGluY2x1ZGluZyBzZWNvbmRzP1xuICogdmFyIHJlc3VsdCA9IGZvcm1hdERpc3RhbmNlVG9Ob3coXG4gKiAgIG5ldyBEYXRlKDIwMTUsIDAsIDEsIDAsIDAsIDE1KSxcbiAqICAge2luY2x1ZGVTZWNvbmRzOiB0cnVlfVxuICogKVxuICogLy89PiAnbGVzcyB0aGFuIDIwIHNlY29uZHMnXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIElmIHRvZGF5IGlzIDEgSmFudWFyeSAyMDE1LFxuICogLy8gd2hhdCBpcyB0aGUgZGlzdGFuY2UgdG8gMSBKYW51YXJ5IDIwMTYsIHdpdGggYSBzdWZmaXg/XG4gKiB2YXIgcmVzdWx0ID0gZm9ybWF0RGlzdGFuY2VUb05vdyhcbiAqICAgbmV3IERhdGUoMjAxNiwgMCwgMSksXG4gKiAgIHthZGRTdWZmaXg6IHRydWV9XG4gKiApXG4gKiAvLz0+ICdpbiBhYm91dCAxIHllYXInXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIElmIHRvZGF5IGlzIDEgSmFudWFyeSAyMDE1LFxuICogLy8gd2hhdCBpcyB0aGUgZGlzdGFuY2UgdG8gMSBBdWd1c3QgMjAxNiBpbiBFc3BlcmFudG8/XG4gKiB2YXIgZW9Mb2NhbGUgPSByZXF1aXJlKCdkYXRlLWZucy9sb2NhbGUvZW8nKVxuICogdmFyIHJlc3VsdCA9IGZvcm1hdERpc3RhbmNlVG9Ob3coXG4gKiAgIG5ldyBEYXRlKDIwMTYsIDcsIDEpLFxuICogICB7bG9jYWxlOiBlb0xvY2FsZX1cbiAqIClcbiAqIC8vPT4gJ3BsaSBvbCAxIGphcm8nXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZm9ybWF0RGlzdGFuY2VUb05vdyhkaXJ0eURhdGUsIGRpcnR5T3B0aW9ucykge1xuICByZXF1aXJlZEFyZ3MoMSwgYXJndW1lbnRzKTtcbiAgcmV0dXJuIGRpc3RhbmNlSW5Xb3JkcyhkaXJ0eURhdGUsIERhdGUubm93KCksIGRpcnR5T3B0aW9ucyk7XG59IiwgImltcG9ydCB7IG1pbGxpc2Vjb25kc0luSG91ciwgbWlsbGlzZWNvbmRzSW5NaW51dGUgfSBmcm9tIFwiLi4vY29uc3RhbnRzL2luZGV4LmpzXCI7XG5pbXBvcnQgcmVxdWlyZWRBcmdzIGZyb20gXCIuLi9fbGliL3JlcXVpcmVkQXJncy9pbmRleC5qc1wiO1xuaW1wb3J0IHRvSW50ZWdlciBmcm9tIFwiLi4vX2xpYi90b0ludGVnZXIvaW5kZXguanNcIjtcbi8qKlxuICogQG5hbWUgcGFyc2VJU09cbiAqIEBjYXRlZ29yeSBDb21tb24gSGVscGVyc1xuICogQHN1bW1hcnkgUGFyc2UgSVNPIHN0cmluZ1xuICpcbiAqIEBkZXNjcmlwdGlvblxuICogUGFyc2UgdGhlIGdpdmVuIHN0cmluZyBpbiBJU08gODYwMSBmb3JtYXQgYW5kIHJldHVybiBhbiBpbnN0YW5jZSBvZiBEYXRlLlxuICpcbiAqIEZ1bmN0aW9uIGFjY2VwdHMgY29tcGxldGUgSVNPIDg2MDEgZm9ybWF0cyBhcyB3ZWxsIGFzIHBhcnRpYWwgaW1wbGVtZW50YXRpb25zLlxuICogSVNPIDg2MDE6IGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPXzg2MDFcbiAqXG4gKiBJZiB0aGUgYXJndW1lbnQgaXNuJ3QgYSBzdHJpbmcsIHRoZSBmdW5jdGlvbiBjYW5ub3QgcGFyc2UgdGhlIHN0cmluZyBvclxuICogdGhlIHZhbHVlcyBhcmUgaW52YWxpZCwgaXQgcmV0dXJucyBJbnZhbGlkIERhdGUuXG4gKlxuICogIyMjIHYyLjAuMCBicmVha2luZyBjaGFuZ2VzOlxuICpcbiAqIC0gW0NoYW5nZXMgdGhhdCBhcmUgY29tbW9uIGZvciB0aGUgd2hvbGUgbGlicmFyeV0oaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL2RhdGUtZm5zL2Jsb2IvbWFzdGVyL2RvY3MvdXBncmFkZUd1aWRlLm1kI0NvbW1vbi1DaGFuZ2VzKS5cbiAqXG4gKiAtIFRoZSBwcmV2aW91cyBgcGFyc2VgIGltcGxlbWVudGF0aW9uIHdhcyByZW5hbWVkIHRvIGBwYXJzZUlTT2AuXG4gKlxuICogICBgYGBqYXZhc2NyaXB0XG4gKiAgIC8vIEJlZm9yZSB2Mi4wLjBcbiAqICAgcGFyc2UoJzIwMTYtMDEtMDEnKVxuICpcbiAqICAgLy8gdjIuMC4wIG9ud2FyZFxuICogICBwYXJzZUlTTygnMjAxNi0wMS0wMScpXG4gKiAgIGBgYFxuICpcbiAqIC0gYHBhcnNlSVNPYCBub3cgdmFsaWRhdGVzIHNlcGFyYXRlIGRhdGUgYW5kIHRpbWUgdmFsdWVzIGluIElTTy04NjAxIHN0cmluZ3NcbiAqICAgYW5kIHJldHVybnMgYEludmFsaWQgRGF0ZWAgaWYgdGhlIGRhdGUgaXMgaW52YWxpZC5cbiAqXG4gKiAgIGBgYGphdmFzY3JpcHRcbiAqICAgcGFyc2VJU08oJzIwMTgtMTMtMzInKVxuICogICAvLz0+IEludmFsaWQgRGF0ZVxuICogICBgYGBcbiAqXG4gKiAtIGBwYXJzZUlTT2Agbm93IGRvZXNuJ3QgZmFsbCBiYWNrIHRvIGBuZXcgRGF0ZWAgY29uc3RydWN0b3JcbiAqICAgaWYgaXQgZmFpbHMgdG8gcGFyc2UgYSBzdHJpbmcgYXJndW1lbnQuIEluc3RlYWQsIGl0IHJldHVybnMgYEludmFsaWQgRGF0ZWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGFyZ3VtZW50IC0gdGhlIHZhbHVlIHRvIGNvbnZlcnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBhbiBvYmplY3Qgd2l0aCBvcHRpb25zLlxuICogQHBhcmFtIHswfDF8Mn0gW29wdGlvbnMuYWRkaXRpb25hbERpZ2l0cz0yXSAtIHRoZSBhZGRpdGlvbmFsIG51bWJlciBvZiBkaWdpdHMgaW4gdGhlIGV4dGVuZGVkIHllYXIgZm9ybWF0XG4gKiBAcmV0dXJucyB7RGF0ZX0gdGhlIHBhcnNlZCBkYXRlIGluIHRoZSBsb2NhbCB0aW1lIHpvbmVcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gMSBhcmd1bWVudCByZXF1aXJlZFxuICogQHRocm93cyB7UmFuZ2VFcnJvcn0gYG9wdGlvbnMuYWRkaXRpb25hbERpZ2l0c2AgbXVzdCBiZSAwLCAxIG9yIDJcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gQ29udmVydCBzdHJpbmcgJzIwMTQtMDItMTFUMTE6MzA6MzAnIHRvIGRhdGU6XG4gKiBjb25zdCByZXN1bHQgPSBwYXJzZUlTTygnMjAxNC0wMi0xMVQxMTozMDozMCcpXG4gKiAvLz0+IFR1ZSBGZWIgMTEgMjAxNCAxMTozMDozMFxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBDb252ZXJ0IHN0cmluZyAnKzAyMDE0MTAxJyB0byBkYXRlLFxuICogLy8gaWYgdGhlIGFkZGl0aW9uYWwgbnVtYmVyIG9mIGRpZ2l0cyBpbiB0aGUgZXh0ZW5kZWQgeWVhciBmb3JtYXQgaXMgMTpcbiAqIGNvbnN0IHJlc3VsdCA9IHBhcnNlSVNPKCcrMDIwMTQxMDEnLCB7IGFkZGl0aW9uYWxEaWdpdHM6IDEgfSlcbiAqIC8vPT4gRnJpIEFwciAxMSAyMDE0IDAwOjAwOjAwXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcGFyc2VJU08oYXJndW1lbnQsIGRpcnR5T3B0aW9ucykge1xuICByZXF1aXJlZEFyZ3MoMSwgYXJndW1lbnRzKTtcbiAgdmFyIG9wdGlvbnMgPSBkaXJ0eU9wdGlvbnMgfHwge307XG4gIHZhciBhZGRpdGlvbmFsRGlnaXRzID0gb3B0aW9ucy5hZGRpdGlvbmFsRGlnaXRzID09IG51bGwgPyAyIDogdG9JbnRlZ2VyKG9wdGlvbnMuYWRkaXRpb25hbERpZ2l0cyk7XG5cbiAgaWYgKGFkZGl0aW9uYWxEaWdpdHMgIT09IDIgJiYgYWRkaXRpb25hbERpZ2l0cyAhPT0gMSAmJiBhZGRpdGlvbmFsRGlnaXRzICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2FkZGl0aW9uYWxEaWdpdHMgbXVzdCBiZSAwLCAxIG9yIDInKTtcbiAgfVxuXG4gIGlmICghKHR5cGVvZiBhcmd1bWVudCA9PT0gJ3N0cmluZycgfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFyZ3VtZW50KSA9PT0gJ1tvYmplY3QgU3RyaW5nXScpKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKE5hTik7XG4gIH1cblxuICB2YXIgZGF0ZVN0cmluZ3MgPSBzcGxpdERhdGVTdHJpbmcoYXJndW1lbnQpO1xuICB2YXIgZGF0ZTtcblxuICBpZiAoZGF0ZVN0cmluZ3MuZGF0ZSkge1xuICAgIHZhciBwYXJzZVllYXJSZXN1bHQgPSBwYXJzZVllYXIoZGF0ZVN0cmluZ3MuZGF0ZSwgYWRkaXRpb25hbERpZ2l0cyk7XG4gICAgZGF0ZSA9IHBhcnNlRGF0ZShwYXJzZVllYXJSZXN1bHQucmVzdERhdGVTdHJpbmcsIHBhcnNlWWVhclJlc3VsdC55ZWFyKTtcbiAgfVxuXG4gIGlmICghZGF0ZSB8fCBpc05hTihkYXRlLmdldFRpbWUoKSkpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoTmFOKTtcbiAgfVxuXG4gIHZhciB0aW1lc3RhbXAgPSBkYXRlLmdldFRpbWUoKTtcbiAgdmFyIHRpbWUgPSAwO1xuICB2YXIgb2Zmc2V0O1xuXG4gIGlmIChkYXRlU3RyaW5ncy50aW1lKSB7XG4gICAgdGltZSA9IHBhcnNlVGltZShkYXRlU3RyaW5ncy50aW1lKTtcblxuICAgIGlmIChpc05hTih0aW1lKSkge1xuICAgICAgcmV0dXJuIG5ldyBEYXRlKE5hTik7XG4gICAgfVxuICB9XG5cbiAgaWYgKGRhdGVTdHJpbmdzLnRpbWV6b25lKSB7XG4gICAgb2Zmc2V0ID0gcGFyc2VUaW1lem9uZShkYXRlU3RyaW5ncy50aW1lem9uZSk7XG5cbiAgICBpZiAoaXNOYU4ob2Zmc2V0KSkge1xuICAgICAgcmV0dXJuIG5ldyBEYXRlKE5hTik7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBkaXJ0eURhdGUgPSBuZXcgRGF0ZSh0aW1lc3RhbXAgKyB0aW1lKTsgLy8ganMgcGFyc2VkIHN0cmluZyBhc3N1bWluZyBpdCdzIGluIFVUQyB0aW1lem9uZVxuICAgIC8vIGJ1dCB3ZSBuZWVkIGl0IHRvIGJlIHBhcnNlZCBpbiBvdXIgdGltZXpvbmVcbiAgICAvLyBzbyB3ZSB1c2UgdXRjIHZhbHVlcyB0byBidWlsZCBkYXRlIGluIG91ciB0aW1lem9uZS5cbiAgICAvLyBZZWFyIHZhbHVlcyBmcm9tIDAgdG8gOTkgbWFwIHRvIHRoZSB5ZWFycyAxOTAwIHRvIDE5OTlcbiAgICAvLyBzbyBzZXQgeWVhciBleHBsaWNpdGx5IHdpdGggc2V0RnVsbFllYXIuXG5cbiAgICB2YXIgcmVzdWx0ID0gbmV3IERhdGUoMCk7XG4gICAgcmVzdWx0LnNldEZ1bGxZZWFyKGRpcnR5RGF0ZS5nZXRVVENGdWxsWWVhcigpLCBkaXJ0eURhdGUuZ2V0VVRDTW9udGgoKSwgZGlydHlEYXRlLmdldFVUQ0RhdGUoKSk7XG4gICAgcmVzdWx0LnNldEhvdXJzKGRpcnR5RGF0ZS5nZXRVVENIb3VycygpLCBkaXJ0eURhdGUuZ2V0VVRDTWludXRlcygpLCBkaXJ0eURhdGUuZ2V0VVRDU2Vjb25kcygpLCBkaXJ0eURhdGUuZ2V0VVRDTWlsbGlzZWNvbmRzKCkpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICByZXR1cm4gbmV3IERhdGUodGltZXN0YW1wICsgdGltZSArIG9mZnNldCk7XG59XG52YXIgcGF0dGVybnMgPSB7XG4gIGRhdGVUaW1lRGVsaW1pdGVyOiAvW1QgXS8sXG4gIHRpbWVab25lRGVsaW1pdGVyOiAvW1ogXS9pLFxuICB0aW1lem9uZTogLyhbWistXS4qKSQvXG59O1xudmFyIGRhdGVSZWdleCA9IC9eLT8oPzooXFxkezN9KXwoXFxkezJ9KSg/Oi0/KFxcZHsyfSkpP3xXKFxcZHsyfSkoPzotPyhcXGR7MX0pKT98KSQvO1xudmFyIHRpbWVSZWdleCA9IC9eKFxcZHsyfSg/OlsuLF1cXGQqKT8pKD86Oj8oXFxkezJ9KD86Wy4sXVxcZCopPykpPyg/Ojo/KFxcZHsyfSg/OlsuLF1cXGQqKT8pKT8kLztcbnZhciB0aW1lem9uZVJlZ2V4ID0gL14oWystXSkoXFxkezJ9KSg/Ojo/KFxcZHsyfSkpPyQvO1xuXG5mdW5jdGlvbiBzcGxpdERhdGVTdHJpbmcoZGF0ZVN0cmluZykge1xuICB2YXIgZGF0ZVN0cmluZ3MgPSB7fTtcbiAgdmFyIGFycmF5ID0gZGF0ZVN0cmluZy5zcGxpdChwYXR0ZXJucy5kYXRlVGltZURlbGltaXRlcik7XG4gIHZhciB0aW1lU3RyaW5nOyAvLyBUaGUgcmVnZXggbWF0Y2ggc2hvdWxkIG9ubHkgcmV0dXJuIGF0IG1heGltdW0gdHdvIGFycmF5IGVsZW1lbnRzLlxuICAvLyBbZGF0ZV0sIFt0aW1lXSwgb3IgW2RhdGUsIHRpbWVdLlxuXG4gIGlmIChhcnJheS5sZW5ndGggPiAyKSB7XG4gICAgcmV0dXJuIGRhdGVTdHJpbmdzO1xuICB9XG5cbiAgaWYgKC86Ly50ZXN0KGFycmF5WzBdKSkge1xuICAgIHRpbWVTdHJpbmcgPSBhcnJheVswXTtcbiAgfSBlbHNlIHtcbiAgICBkYXRlU3RyaW5ncy5kYXRlID0gYXJyYXlbMF07XG4gICAgdGltZVN0cmluZyA9IGFycmF5WzFdO1xuXG4gICAgaWYgKHBhdHRlcm5zLnRpbWVab25lRGVsaW1pdGVyLnRlc3QoZGF0ZVN0cmluZ3MuZGF0ZSkpIHtcbiAgICAgIGRhdGVTdHJpbmdzLmRhdGUgPSBkYXRlU3RyaW5nLnNwbGl0KHBhdHRlcm5zLnRpbWVab25lRGVsaW1pdGVyKVswXTtcbiAgICAgIHRpbWVTdHJpbmcgPSBkYXRlU3RyaW5nLnN1YnN0cihkYXRlU3RyaW5ncy5kYXRlLmxlbmd0aCwgZGF0ZVN0cmluZy5sZW5ndGgpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0aW1lU3RyaW5nKSB7XG4gICAgdmFyIHRva2VuID0gcGF0dGVybnMudGltZXpvbmUuZXhlYyh0aW1lU3RyaW5nKTtcblxuICAgIGlmICh0b2tlbikge1xuICAgICAgZGF0ZVN0cmluZ3MudGltZSA9IHRpbWVTdHJpbmcucmVwbGFjZSh0b2tlblsxXSwgJycpO1xuICAgICAgZGF0ZVN0cmluZ3MudGltZXpvbmUgPSB0b2tlblsxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGF0ZVN0cmluZ3MudGltZSA9IHRpbWVTdHJpbmc7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRhdGVTdHJpbmdzO1xufVxuXG5mdW5jdGlvbiBwYXJzZVllYXIoZGF0ZVN0cmluZywgYWRkaXRpb25hbERpZ2l0cykge1xuICB2YXIgcmVnZXggPSBuZXcgUmVnRXhwKCdeKD86KFxcXFxkezR9fFsrLV1cXFxcZHsnICsgKDQgKyBhZGRpdGlvbmFsRGlnaXRzKSArICd9KXwoXFxcXGR7Mn18WystXVxcXFxkeycgKyAoMiArIGFkZGl0aW9uYWxEaWdpdHMpICsgJ30pJCknKTtcbiAgdmFyIGNhcHR1cmVzID0gZGF0ZVN0cmluZy5tYXRjaChyZWdleCk7IC8vIEludmFsaWQgSVNPLWZvcm1hdHRlZCB5ZWFyXG5cbiAgaWYgKCFjYXB0dXJlcykgcmV0dXJuIHtcbiAgICB5ZWFyOiBOYU4sXG4gICAgcmVzdERhdGVTdHJpbmc6ICcnXG4gIH07XG4gIHZhciB5ZWFyID0gY2FwdHVyZXNbMV0gPyBwYXJzZUludChjYXB0dXJlc1sxXSkgOiBudWxsO1xuICB2YXIgY2VudHVyeSA9IGNhcHR1cmVzWzJdID8gcGFyc2VJbnQoY2FwdHVyZXNbMl0pIDogbnVsbDsgLy8gZWl0aGVyIHllYXIgb3IgY2VudHVyeSBpcyBudWxsLCBub3QgYm90aFxuXG4gIHJldHVybiB7XG4gICAgeWVhcjogY2VudHVyeSA9PT0gbnVsbCA/IHllYXIgOiBjZW50dXJ5ICogMTAwLFxuICAgIHJlc3REYXRlU3RyaW5nOiBkYXRlU3RyaW5nLnNsaWNlKChjYXB0dXJlc1sxXSB8fCBjYXB0dXJlc1syXSkubGVuZ3RoKVxuICB9O1xufVxuXG5mdW5jdGlvbiBwYXJzZURhdGUoZGF0ZVN0cmluZywgeWVhcikge1xuICAvLyBJbnZhbGlkIElTTy1mb3JtYXR0ZWQgeWVhclxuICBpZiAoeWVhciA9PT0gbnVsbCkgcmV0dXJuIG5ldyBEYXRlKE5hTik7XG4gIHZhciBjYXB0dXJlcyA9IGRhdGVTdHJpbmcubWF0Y2goZGF0ZVJlZ2V4KTsgLy8gSW52YWxpZCBJU08tZm9ybWF0dGVkIHN0cmluZ1xuXG4gIGlmICghY2FwdHVyZXMpIHJldHVybiBuZXcgRGF0ZShOYU4pO1xuICB2YXIgaXNXZWVrRGF0ZSA9ICEhY2FwdHVyZXNbNF07XG4gIHZhciBkYXlPZlllYXIgPSBwYXJzZURhdGVVbml0KGNhcHR1cmVzWzFdKTtcbiAgdmFyIG1vbnRoID0gcGFyc2VEYXRlVW5pdChjYXB0dXJlc1syXSkgLSAxO1xuICB2YXIgZGF5ID0gcGFyc2VEYXRlVW5pdChjYXB0dXJlc1szXSk7XG4gIHZhciB3ZWVrID0gcGFyc2VEYXRlVW5pdChjYXB0dXJlc1s0XSk7XG4gIHZhciBkYXlPZldlZWsgPSBwYXJzZURhdGVVbml0KGNhcHR1cmVzWzVdKSAtIDE7XG5cbiAgaWYgKGlzV2Vla0RhdGUpIHtcbiAgICBpZiAoIXZhbGlkYXRlV2Vla0RhdGUoeWVhciwgd2VlaywgZGF5T2ZXZWVrKSkge1xuICAgICAgcmV0dXJuIG5ldyBEYXRlKE5hTik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRheU9mSVNPV2Vla1llYXIoeWVhciwgd2VlaywgZGF5T2ZXZWVrKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKDApO1xuXG4gICAgaWYgKCF2YWxpZGF0ZURhdGUoeWVhciwgbW9udGgsIGRheSkgfHwgIXZhbGlkYXRlRGF5T2ZZZWFyRGF0ZSh5ZWFyLCBkYXlPZlllYXIpKSB7XG4gICAgICByZXR1cm4gbmV3IERhdGUoTmFOKTtcbiAgICB9XG5cbiAgICBkYXRlLnNldFVUQ0Z1bGxZZWFyKHllYXIsIG1vbnRoLCBNYXRoLm1heChkYXlPZlllYXIsIGRheSkpO1xuICAgIHJldHVybiBkYXRlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBhcnNlRGF0ZVVuaXQodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID8gcGFyc2VJbnQodmFsdWUpIDogMTtcbn1cblxuZnVuY3Rpb24gcGFyc2VUaW1lKHRpbWVTdHJpbmcpIHtcbiAgdmFyIGNhcHR1cmVzID0gdGltZVN0cmluZy5tYXRjaCh0aW1lUmVnZXgpO1xuICBpZiAoIWNhcHR1cmVzKSByZXR1cm4gTmFOOyAvLyBJbnZhbGlkIElTTy1mb3JtYXR0ZWQgdGltZVxuXG4gIHZhciBob3VycyA9IHBhcnNlVGltZVVuaXQoY2FwdHVyZXNbMV0pO1xuICB2YXIgbWludXRlcyA9IHBhcnNlVGltZVVuaXQoY2FwdHVyZXNbMl0pO1xuICB2YXIgc2Vjb25kcyA9IHBhcnNlVGltZVVuaXQoY2FwdHVyZXNbM10pO1xuXG4gIGlmICghdmFsaWRhdGVUaW1lKGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzKSkge1xuICAgIHJldHVybiBOYU47XG4gIH1cblxuICByZXR1cm4gaG91cnMgKiBtaWxsaXNlY29uZHNJbkhvdXIgKyBtaW51dGVzICogbWlsbGlzZWNvbmRzSW5NaW51dGUgKyBzZWNvbmRzICogMTAwMDtcbn1cblxuZnVuY3Rpb24gcGFyc2VUaW1lVW5pdCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgJiYgcGFyc2VGbG9hdCh2YWx1ZS5yZXBsYWNlKCcsJywgJy4nKSkgfHwgMDtcbn1cblxuZnVuY3Rpb24gcGFyc2VUaW1lem9uZSh0aW1lem9uZVN0cmluZykge1xuICBpZiAodGltZXpvbmVTdHJpbmcgPT09ICdaJykgcmV0dXJuIDA7XG4gIHZhciBjYXB0dXJlcyA9IHRpbWV6b25lU3RyaW5nLm1hdGNoKHRpbWV6b25lUmVnZXgpO1xuICBpZiAoIWNhcHR1cmVzKSByZXR1cm4gMDtcbiAgdmFyIHNpZ24gPSBjYXB0dXJlc1sxXSA9PT0gJysnID8gLTEgOiAxO1xuICB2YXIgaG91cnMgPSBwYXJzZUludChjYXB0dXJlc1syXSk7XG4gIHZhciBtaW51dGVzID0gY2FwdHVyZXNbM10gJiYgcGFyc2VJbnQoY2FwdHVyZXNbM10pIHx8IDA7XG5cbiAgaWYgKCF2YWxpZGF0ZVRpbWV6b25lKGhvdXJzLCBtaW51dGVzKSkge1xuICAgIHJldHVybiBOYU47XG4gIH1cblxuICByZXR1cm4gc2lnbiAqIChob3VycyAqIG1pbGxpc2Vjb25kc0luSG91ciArIG1pbnV0ZXMgKiBtaWxsaXNlY29uZHNJbk1pbnV0ZSk7XG59XG5cbmZ1bmN0aW9uIGRheU9mSVNPV2Vla1llYXIoaXNvV2Vla1llYXIsIHdlZWssIGRheSkge1xuICB2YXIgZGF0ZSA9IG5ldyBEYXRlKDApO1xuICBkYXRlLnNldFVUQ0Z1bGxZZWFyKGlzb1dlZWtZZWFyLCAwLCA0KTtcbiAgdmFyIGZvdXJ0aE9mSmFudWFyeURheSA9IGRhdGUuZ2V0VVRDRGF5KCkgfHwgNztcbiAgdmFyIGRpZmYgPSAod2VlayAtIDEpICogNyArIGRheSArIDEgLSBmb3VydGhPZkphbnVhcnlEYXk7XG4gIGRhdGUuc2V0VVRDRGF0ZShkYXRlLmdldFVUQ0RhdGUoKSArIGRpZmYpO1xuICByZXR1cm4gZGF0ZTtcbn0gLy8gVmFsaWRhdGlvbiBmdW5jdGlvbnNcbi8vIEZlYnJ1YXJ5IGlzIG51bGwgdG8gaGFuZGxlIHRoZSBsZWFwIHllYXIgKHVzaW5nIHx8KVxuXG5cbnZhciBkYXlzSW5Nb250aHMgPSBbMzEsIG51bGwsIDMxLCAzMCwgMzEsIDMwLCAzMSwgMzEsIDMwLCAzMSwgMzAsIDMxXTtcblxuZnVuY3Rpb24gaXNMZWFwWWVhckluZGV4KHllYXIpIHtcbiAgcmV0dXJuIHllYXIgJSA0MDAgPT09IDAgfHwgeWVhciAlIDQgPT09IDAgJiYgeWVhciAlIDEwMCAhPT0gMDtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVEYXRlKHllYXIsIG1vbnRoLCBkYXRlKSB7XG4gIHJldHVybiBtb250aCA+PSAwICYmIG1vbnRoIDw9IDExICYmIGRhdGUgPj0gMSAmJiBkYXRlIDw9IChkYXlzSW5Nb250aHNbbW9udGhdIHx8IChpc0xlYXBZZWFySW5kZXgoeWVhcikgPyAyOSA6IDI4KSk7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlRGF5T2ZZZWFyRGF0ZSh5ZWFyLCBkYXlPZlllYXIpIHtcbiAgcmV0dXJuIGRheU9mWWVhciA+PSAxICYmIGRheU9mWWVhciA8PSAoaXNMZWFwWWVhckluZGV4KHllYXIpID8gMzY2IDogMzY1KTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVXZWVrRGF0ZShfeWVhciwgd2VlaywgZGF5KSB7XG4gIHJldHVybiB3ZWVrID49IDEgJiYgd2VlayA8PSA1MyAmJiBkYXkgPj0gMCAmJiBkYXkgPD0gNjtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVUaW1lKGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzKSB7XG4gIGlmIChob3VycyA9PT0gMjQpIHtcbiAgICByZXR1cm4gbWludXRlcyA9PT0gMCAmJiBzZWNvbmRzID09PSAwO1xuICB9XG5cbiAgcmV0dXJuIHNlY29uZHMgPj0gMCAmJiBzZWNvbmRzIDwgNjAgJiYgbWludXRlcyA+PSAwICYmIG1pbnV0ZXMgPCA2MCAmJiBob3VycyA+PSAwICYmIGhvdXJzIDwgMjU7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlVGltZXpvbmUoX2hvdXJzLCBtaW51dGVzKSB7XG4gIHJldHVybiBtaW51dGVzID49IDAgJiYgbWludXRlcyA8PSA1OTtcbn0iLCAiaW1wb3J0IHsgZm9ybWF0RGlzdGFuY2VUb05vdywgcGFyc2VJU08gfSBmcm9tICdkYXRlLWZucyc7XG5cbmxldCBsb2NhbGUgPSBudWxsO1xuXG5mdW5jdGlvbiBUaW1lQWdvKEFscGluZSkge1xuICAgIEFscGluZS5kaXJlY3RpdmUoJ3RpbWVhZ28nLCAoZWwsIHsgZXhwcmVzc2lvbiwgbW9kaWZpZXJzIH0sIHsgZXZhbHVhdGVMYXRlciwgZWZmZWN0LCBjbGVhbnVwIH0pID0+IHtcbiAgICAgICAgbGV0IGV2YWx1YXRlRGF0ZSA9IGV2YWx1YXRlTGF0ZXIoZXhwcmVzc2lvbik7XG5cbiAgICAgICAgY29uc3QgcmVuZGVyID0gKGRhdGUpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkYXRlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICBkYXRlID0gcGFyc2VJU08oZGF0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsLnRleHRDb250ZW50ID0gZm9ybWF0RGlzdGFuY2VUb05vdyhkYXRlLCB7XG4gICAgICAgICAgICAgICAgICAgIGFkZFN1ZmZpeDogIW1vZGlmaWVycy5pbmNsdWRlcygncHVyZScpLFxuICAgICAgICAgICAgICAgICAgICBsb2NhbGUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBpbnRlcnZhbDtcblxuICAgICAgICBlZmZlY3QoKCkgPT4ge1xuICAgICAgICAgICAgZXZhbHVhdGVEYXRlKChkYXRlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGludGVydmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJlbmRlcihkYXRlKTtcblxuICAgICAgICAgICAgICAgIGludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZW5kZXIoZGF0ZSk7XG4gICAgICAgICAgICAgICAgfSwgMzAwMDApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNsZWFudXAoKCkgPT4gY2xlYXJJbnRlcnZhbChpbnRlcnZhbCkpO1xuICAgIH0pO1xufVxuXG5UaW1lQWdvLmNvbmZpZ3VyZSA9IChjb25maWcpID0+IHtcbiAgICBpZiAoY29uZmlnLmhhc093blByb3BlcnR5KCdsb2NhbGUnKSAmJiB0eXBlb2YgY29uZmlnLmxvY2FsZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgaWYgKGNvbmZpZy5sb2NhbGUuaGFzT3duUHJvcGVydHkoJ2Zvcm1hdERpc3RhbmNlJykpIHtcbiAgICAgICAgICAgIGxvY2FsZSA9IGNvbmZpZy5sb2NhbGU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gVGltZUFnbztcbn1cblxuZXhwb3J0IGRlZmF1bHQgVGltZUFnbzsiLCAidmFyIGZvcm1hdERpc3RhbmNlTG9jYWxlID0ge1xuICBsZXNzVGhhblhTZWNvbmRzOiB7XG4gICAgb25lOiAnbWVub3MgZGUgdW4gc2VndW5kbycsXG4gICAgb3RoZXI6ICdtZW5vcyBkZSB7e2NvdW50fX0gc2VndW5kb3MnXG4gIH0sXG4gIHhTZWNvbmRzOiB7XG4gICAgb25lOiAnMSBzZWd1bmRvJyxcbiAgICBvdGhlcjogJ3t7Y291bnR9fSBzZWd1bmRvcydcbiAgfSxcbiAgaGFsZkFNaW51dGU6ICdtZWRpbyBtaW51dG8nLFxuICBsZXNzVGhhblhNaW51dGVzOiB7XG4gICAgb25lOiAnbWVub3MgZGUgdW4gbWludXRvJyxcbiAgICBvdGhlcjogJ21lbm9zIGRlIHt7Y291bnR9fSBtaW51dG9zJ1xuICB9LFxuICB4TWludXRlczoge1xuICAgIG9uZTogJzEgbWludXRvJyxcbiAgICBvdGhlcjogJ3t7Y291bnR9fSBtaW51dG9zJ1xuICB9LFxuICBhYm91dFhIb3Vyczoge1xuICAgIG9uZTogJ2FscmVkZWRvciBkZSAxIGhvcmEnLFxuICAgIG90aGVyOiAnYWxyZWRlZG9yIGRlIHt7Y291bnR9fSBob3JhcydcbiAgfSxcbiAgeEhvdXJzOiB7XG4gICAgb25lOiAnMSBob3JhJyxcbiAgICBvdGhlcjogJ3t7Y291bnR9fSBob3JhcydcbiAgfSxcbiAgeERheXM6IHtcbiAgICBvbmU6ICcxIGRcdTAwRURhJyxcbiAgICBvdGhlcjogJ3t7Y291bnR9fSBkXHUwMEVEYXMnXG4gIH0sXG4gIGFib3V0WFdlZWtzOiB7XG4gICAgb25lOiAnYWxyZWRlZG9yIGRlIDEgc2VtYW5hJyxcbiAgICBvdGhlcjogJ2FscmVkZWRvciBkZSB7e2NvdW50fX0gc2VtYW5hcydcbiAgfSxcbiAgeFdlZWtzOiB7XG4gICAgb25lOiAnMSBzZW1hbmEnLFxuICAgIG90aGVyOiAne3tjb3VudH19IHNlbWFuYXMnXG4gIH0sXG4gIGFib3V0WE1vbnRoczoge1xuICAgIG9uZTogJ2FscmVkZWRvciBkZSAxIG1lcycsXG4gICAgb3RoZXI6ICdhbHJlZGVkb3IgZGUge3tjb3VudH19IG1lc2VzJ1xuICB9LFxuICB4TW9udGhzOiB7XG4gICAgb25lOiAnMSBtZXMnLFxuICAgIG90aGVyOiAne3tjb3VudH19IG1lc2VzJ1xuICB9LFxuICBhYm91dFhZZWFyczoge1xuICAgIG9uZTogJ2FscmVkZWRvciBkZSAxIGFcdTAwRjFvJyxcbiAgICBvdGhlcjogJ2FscmVkZWRvciBkZSB7e2NvdW50fX0gYVx1MDBGMW9zJ1xuICB9LFxuICB4WWVhcnM6IHtcbiAgICBvbmU6ICcxIGFcdTAwRjFvJyxcbiAgICBvdGhlcjogJ3t7Y291bnR9fSBhXHUwMEYxb3MnXG4gIH0sXG4gIG92ZXJYWWVhcnM6IHtcbiAgICBvbmU6ICdtXHUwMEUxcyBkZSAxIGFcdTAwRjFvJyxcbiAgICBvdGhlcjogJ21cdTAwRTFzIGRlIHt7Y291bnR9fSBhXHUwMEYxb3MnXG4gIH0sXG4gIGFsbW9zdFhZZWFyczoge1xuICAgIG9uZTogJ2Nhc2kgMSBhXHUwMEYxbycsXG4gICAgb3RoZXI6ICdjYXNpIHt7Y291bnR9fSBhXHUwMEYxb3MnXG4gIH1cbn07XG5cbnZhciBmb3JtYXREaXN0YW5jZSA9IGZ1bmN0aW9uICh0b2tlbiwgY291bnQsIG9wdGlvbnMpIHtcbiAgdmFyIHJlc3VsdDtcbiAgdmFyIHRva2VuVmFsdWUgPSBmb3JtYXREaXN0YW5jZUxvY2FsZVt0b2tlbl07XG5cbiAgaWYgKHR5cGVvZiB0b2tlblZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJlc3VsdCA9IHRva2VuVmFsdWU7XG4gIH0gZWxzZSBpZiAoY291bnQgPT09IDEpIHtcbiAgICByZXN1bHQgPSB0b2tlblZhbHVlLm9uZTtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQgPSB0b2tlblZhbHVlLm90aGVyLnJlcGxhY2UoJ3t7Y291bnR9fScsIGNvdW50LnRvU3RyaW5nKCkpO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMgIT09IG51bGwgJiYgb3B0aW9ucyAhPT0gdm9pZCAwICYmIG9wdGlvbnMuYWRkU3VmZml4KSB7XG4gICAgaWYgKG9wdGlvbnMuY29tcGFyaXNvbiAmJiBvcHRpb25zLmNvbXBhcmlzb24gPiAwKSB7XG4gICAgICByZXR1cm4gJ2VuICcgKyByZXN1bHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAnaGFjZSAnICsgcmVzdWx0O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBmb3JtYXREaXN0YW5jZTsiLCAiaW1wb3J0IGJ1aWxkRm9ybWF0TG9uZ0ZuIGZyb20gXCIuLi8uLi8uLi9fbGliL2J1aWxkRm9ybWF0TG9uZ0ZuL2luZGV4LmpzXCI7XG52YXIgZGF0ZUZvcm1hdHMgPSB7XG4gIGZ1bGw6IFwiRUVFRSwgZCAnZGUnIE1NTU0gJ2RlJyB5XCIsXG4gIGxvbmc6IFwiZCAnZGUnIE1NTU0gJ2RlJyB5XCIsXG4gIG1lZGl1bTogJ2QgTU1NIHknLFxuICBzaG9ydDogJ2RkL01NL3knXG59O1xudmFyIHRpbWVGb3JtYXRzID0ge1xuICBmdWxsOiAnSEg6bW06c3Mgenp6eicsXG4gIGxvbmc6ICdISDptbTpzcyB6JyxcbiAgbWVkaXVtOiAnSEg6bW06c3MnLFxuICBzaG9ydDogJ0hIOm1tJ1xufTtcbnZhciBkYXRlVGltZUZvcm1hdHMgPSB7XG4gIGZ1bGw6IFwie3tkYXRlfX0gJ2EgbGFzJyB7e3RpbWV9fVwiLFxuICBsb25nOiBcInt7ZGF0ZX19ICdhIGxhcycge3t0aW1lfX1cIixcbiAgbWVkaXVtOiAne3tkYXRlfX0sIHt7dGltZX19JyxcbiAgc2hvcnQ6ICd7e2RhdGV9fSwge3t0aW1lfX0nXG59O1xudmFyIGZvcm1hdExvbmcgPSB7XG4gIGRhdGU6IGJ1aWxkRm9ybWF0TG9uZ0ZuKHtcbiAgICBmb3JtYXRzOiBkYXRlRm9ybWF0cyxcbiAgICBkZWZhdWx0V2lkdGg6ICdmdWxsJ1xuICB9KSxcbiAgdGltZTogYnVpbGRGb3JtYXRMb25nRm4oe1xuICAgIGZvcm1hdHM6IHRpbWVGb3JtYXRzLFxuICAgIGRlZmF1bHRXaWR0aDogJ2Z1bGwnXG4gIH0pLFxuICBkYXRlVGltZTogYnVpbGRGb3JtYXRMb25nRm4oe1xuICAgIGZvcm1hdHM6IGRhdGVUaW1lRm9ybWF0cyxcbiAgICBkZWZhdWx0V2lkdGg6ICdmdWxsJ1xuICB9KVxufTtcbmV4cG9ydCBkZWZhdWx0IGZvcm1hdExvbmc7IiwgInZhciBmb3JtYXRSZWxhdGl2ZUxvY2FsZSA9IHtcbiAgbGFzdFdlZWs6IFwiJ2VsJyBlZWVlICdwYXNhZG8gYSBsYScgcFwiLFxuICB5ZXN0ZXJkYXk6IFwiJ2F5ZXIgYSBsYScgcFwiLFxuICB0b2RheTogXCInaG95IGEgbGEnIHBcIixcbiAgdG9tb3Jyb3c6IFwiJ21hXHUwMEYxYW5hIGEgbGEnIHBcIixcbiAgbmV4dFdlZWs6IFwiZWVlZSAnYSBsYScgcFwiLFxuICBvdGhlcjogJ1AnXG59O1xudmFyIGZvcm1hdFJlbGF0aXZlTG9jYWxlUGx1cmFsID0ge1xuICBsYXN0V2VlazogXCInZWwnIGVlZWUgJ3Bhc2FkbyBhIGxhcycgcFwiLFxuICB5ZXN0ZXJkYXk6IFwiJ2F5ZXIgYSBsYXMnIHBcIixcbiAgdG9kYXk6IFwiJ2hveSBhIGxhcycgcFwiLFxuICB0b21vcnJvdzogXCInbWFcdTAwRjFhbmEgYSBsYXMnIHBcIixcbiAgbmV4dFdlZWs6IFwiZWVlZSAnYSBsYXMnIHBcIixcbiAgb3RoZXI6ICdQJ1xufTtcblxudmFyIGZvcm1hdFJlbGF0aXZlID0gZnVuY3Rpb24gKHRva2VuLCBkYXRlLCBfYmFzZURhdGUsIF9vcHRpb25zKSB7XG4gIGlmIChkYXRlLmdldFVUQ0hvdXJzKCkgIT09IDEpIHtcbiAgICByZXR1cm4gZm9ybWF0UmVsYXRpdmVMb2NhbGVQbHVyYWxbdG9rZW5dO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmb3JtYXRSZWxhdGl2ZUxvY2FsZVt0b2tlbl07XG4gIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IGZvcm1hdFJlbGF0aXZlOyIsICJpbXBvcnQgYnVpbGRMb2NhbGl6ZUZuIGZyb20gXCIuLi8uLi8uLi9fbGliL2J1aWxkTG9jYWxpemVGbi9pbmRleC5qc1wiO1xudmFyIGVyYVZhbHVlcyA9IHtcbiAgbmFycm93OiBbJ0FDJywgJ0RDJ10sXG4gIGFiYnJldmlhdGVkOiBbJ0FDJywgJ0RDJ10sXG4gIHdpZGU6IFsnYW50ZXMgZGUgY3Jpc3RvJywgJ2Rlc3B1XHUwMEU5cyBkZSBjcmlzdG8nXVxufTtcbnZhciBxdWFydGVyVmFsdWVzID0ge1xuICBuYXJyb3c6IFsnMScsICcyJywgJzMnLCAnNCddLFxuICBhYmJyZXZpYXRlZDogWydUMScsICdUMicsICdUMycsICdUNCddLFxuICB3aWRlOiBbJzFcdTAwQkEgdHJpbWVzdHJlJywgJzJcdTAwQkEgdHJpbWVzdHJlJywgJzNcdTAwQkEgdHJpbWVzdHJlJywgJzRcdTAwQkEgdHJpbWVzdHJlJ11cbn07XG52YXIgbW9udGhWYWx1ZXMgPSB7XG4gIG5hcnJvdzogWydlJywgJ2YnLCAnbScsICdhJywgJ20nLCAnaicsICdqJywgJ2EnLCAncycsICdvJywgJ24nLCAnZCddLFxuICBhYmJyZXZpYXRlZDogWydlbmUnLCAnZmViJywgJ21hcicsICdhYnInLCAnbWF5JywgJ2p1bicsICdqdWwnLCAnYWdvJywgJ3NlcCcsICdvY3QnLCAnbm92JywgJ2RpYyddLFxuICB3aWRlOiBbJ2VuZXJvJywgJ2ZlYnJlcm8nLCAnbWFyem8nLCAnYWJyaWwnLCAnbWF5bycsICdqdW5pbycsICdqdWxpbycsICdhZ29zdG8nLCAnc2VwdGllbWJyZScsICdvY3R1YnJlJywgJ25vdmllbWJyZScsICdkaWNpZW1icmUnXVxufTtcbnZhciBkYXlWYWx1ZXMgPSB7XG4gIG5hcnJvdzogWydkJywgJ2wnLCAnbScsICdtJywgJ2onLCAndicsICdzJ10sXG4gIHNob3J0OiBbJ2RvJywgJ2x1JywgJ21hJywgJ21pJywgJ2p1JywgJ3ZpJywgJ3NcdTAwRTEnXSxcbiAgYWJicmV2aWF0ZWQ6IFsnZG9tJywgJ2x1bicsICdtYXInLCAnbWlcdTAwRTknLCAnanVlJywgJ3ZpZScsICdzXHUwMEUxYiddLFxuICB3aWRlOiBbJ2RvbWluZ28nLCAnbHVuZXMnLCAnbWFydGVzJywgJ21pXHUwMEU5cmNvbGVzJywgJ2p1ZXZlcycsICd2aWVybmVzJywgJ3NcdTAwRTFiYWRvJ11cbn07XG52YXIgZGF5UGVyaW9kVmFsdWVzID0ge1xuICBuYXJyb3c6IHtcbiAgICBhbTogJ2EnLFxuICAgIHBtOiAncCcsXG4gICAgbWlkbmlnaHQ6ICdtbicsXG4gICAgbm9vbjogJ21kJyxcbiAgICBtb3JuaW5nOiAnbWFcdTAwRjFhbmEnLFxuICAgIGFmdGVybm9vbjogJ3RhcmRlJyxcbiAgICBldmVuaW5nOiAndGFyZGUnLFxuICAgIG5pZ2h0OiAnbm9jaGUnXG4gIH0sXG4gIGFiYnJldmlhdGVkOiB7XG4gICAgYW06ICdBTScsXG4gICAgcG06ICdQTScsXG4gICAgbWlkbmlnaHQ6ICdtZWRpYW5vY2hlJyxcbiAgICBub29uOiAnbWVkaW9kaWEnLFxuICAgIG1vcm5pbmc6ICdtYVx1MDBGMWFuYScsXG4gICAgYWZ0ZXJub29uOiAndGFyZGUnLFxuICAgIGV2ZW5pbmc6ICd0YXJkZScsXG4gICAgbmlnaHQ6ICdub2NoZSdcbiAgfSxcbiAgd2lkZToge1xuICAgIGFtOiAnYS5tLicsXG4gICAgcG06ICdwLm0uJyxcbiAgICBtaWRuaWdodDogJ21lZGlhbm9jaGUnLFxuICAgIG5vb246ICdtZWRpb2RpYScsXG4gICAgbW9ybmluZzogJ21hXHUwMEYxYW5hJyxcbiAgICBhZnRlcm5vb246ICd0YXJkZScsXG4gICAgZXZlbmluZzogJ3RhcmRlJyxcbiAgICBuaWdodDogJ25vY2hlJ1xuICB9XG59O1xudmFyIGZvcm1hdHRpbmdEYXlQZXJpb2RWYWx1ZXMgPSB7XG4gIG5hcnJvdzoge1xuICAgIGFtOiAnYScsXG4gICAgcG06ICdwJyxcbiAgICBtaWRuaWdodDogJ21uJyxcbiAgICBub29uOiAnbWQnLFxuICAgIG1vcm5pbmc6ICdkZSBsYSBtYVx1MDBGMWFuYScsXG4gICAgYWZ0ZXJub29uOiAnZGUgbGEgdGFyZGUnLFxuICAgIGV2ZW5pbmc6ICdkZSBsYSB0YXJkZScsXG4gICAgbmlnaHQ6ICdkZSBsYSBub2NoZSdcbiAgfSxcbiAgYWJicmV2aWF0ZWQ6IHtcbiAgICBhbTogJ0FNJyxcbiAgICBwbTogJ1BNJyxcbiAgICBtaWRuaWdodDogJ21lZGlhbm9jaGUnLFxuICAgIG5vb246ICdtZWRpb2RpYScsXG4gICAgbW9ybmluZzogJ2RlIGxhIG1hXHUwMEYxYW5hJyxcbiAgICBhZnRlcm5vb246ICdkZSBsYSB0YXJkZScsXG4gICAgZXZlbmluZzogJ2RlIGxhIHRhcmRlJyxcbiAgICBuaWdodDogJ2RlIGxhIG5vY2hlJ1xuICB9LFxuICB3aWRlOiB7XG4gICAgYW06ICdhLm0uJyxcbiAgICBwbTogJ3AubS4nLFxuICAgIG1pZG5pZ2h0OiAnbWVkaWFub2NoZScsXG4gICAgbm9vbjogJ21lZGlvZGlhJyxcbiAgICBtb3JuaW5nOiAnZGUgbGEgbWFcdTAwRjFhbmEnLFxuICAgIGFmdGVybm9vbjogJ2RlIGxhIHRhcmRlJyxcbiAgICBldmVuaW5nOiAnZGUgbGEgdGFyZGUnLFxuICAgIG5pZ2h0OiAnZGUgbGEgbm9jaGUnXG4gIH1cbn07XG5cbnZhciBvcmRpbmFsTnVtYmVyID0gZnVuY3Rpb24gKGRpcnR5TnVtYmVyLCBfb3B0aW9ucykge1xuICB2YXIgbnVtYmVyID0gTnVtYmVyKGRpcnR5TnVtYmVyKTtcbiAgcmV0dXJuIG51bWJlciArICdcdTAwQkEnO1xufTtcblxudmFyIGxvY2FsaXplID0ge1xuICBvcmRpbmFsTnVtYmVyOiBvcmRpbmFsTnVtYmVyLFxuICBlcmE6IGJ1aWxkTG9jYWxpemVGbih7XG4gICAgdmFsdWVzOiBlcmFWYWx1ZXMsXG4gICAgZGVmYXVsdFdpZHRoOiAnd2lkZSdcbiAgfSksXG4gIHF1YXJ0ZXI6IGJ1aWxkTG9jYWxpemVGbih7XG4gICAgdmFsdWVzOiBxdWFydGVyVmFsdWVzLFxuICAgIGRlZmF1bHRXaWR0aDogJ3dpZGUnLFxuICAgIGFyZ3VtZW50Q2FsbGJhY2s6IGZ1bmN0aW9uIChxdWFydGVyKSB7XG4gICAgICByZXR1cm4gTnVtYmVyKHF1YXJ0ZXIpIC0gMTtcbiAgICB9XG4gIH0pLFxuICBtb250aDogYnVpbGRMb2NhbGl6ZUZuKHtcbiAgICB2YWx1ZXM6IG1vbnRoVmFsdWVzLFxuICAgIGRlZmF1bHRXaWR0aDogJ3dpZGUnXG4gIH0pLFxuICBkYXk6IGJ1aWxkTG9jYWxpemVGbih7XG4gICAgdmFsdWVzOiBkYXlWYWx1ZXMsXG4gICAgZGVmYXVsdFdpZHRoOiAnd2lkZSdcbiAgfSksXG4gIGRheVBlcmlvZDogYnVpbGRMb2NhbGl6ZUZuKHtcbiAgICB2YWx1ZXM6IGRheVBlcmlvZFZhbHVlcyxcbiAgICBkZWZhdWx0V2lkdGg6ICd3aWRlJyxcbiAgICBmb3JtYXR0aW5nVmFsdWVzOiBmb3JtYXR0aW5nRGF5UGVyaW9kVmFsdWVzLFxuICAgIGRlZmF1bHRGb3JtYXR0aW5nV2lkdGg6ICd3aWRlJ1xuICB9KVxufTtcbmV4cG9ydCBkZWZhdWx0IGxvY2FsaXplOyIsICJpbXBvcnQgYnVpbGRNYXRjaFBhdHRlcm5GbiBmcm9tIFwiLi4vLi4vLi4vX2xpYi9idWlsZE1hdGNoUGF0dGVybkZuL2luZGV4LmpzXCI7XG5pbXBvcnQgYnVpbGRNYXRjaEZuIGZyb20gXCIuLi8uLi8uLi9fbGliL2J1aWxkTWF0Y2hGbi9pbmRleC5qc1wiO1xudmFyIG1hdGNoT3JkaW5hbE51bWJlclBhdHRlcm4gPSAvXihcXGQrKShcdTAwQkEpPy9pO1xudmFyIHBhcnNlT3JkaW5hbE51bWJlclBhdHRlcm4gPSAvXFxkKy9pO1xudmFyIG1hdGNoRXJhUGF0dGVybnMgPSB7XG4gIG5hcnJvdzogL14oYWN8ZGN8YXxkKS9pLFxuICBhYmJyZXZpYXRlZDogL14oYVxcLj9cXHM/Y1xcLj98YVxcLj9cXHM/ZVxcLj9cXHM/Y1xcLj98ZFxcLj9cXHM/Y1xcLj98ZVxcLj9cXHM/Y1xcLj8pL2ksXG4gIHdpZGU6IC9eKGFudGVzIGRlIGNyaXN0b3xhbnRlcyBkZSBsYSBlcmEgY29tW3VcdTAwRkFdbnxkZXNwdVtlXHUwMEU5XXMgZGUgY3Jpc3RvfGVyYSBjb21bdVx1MDBGQV1uKS9pXG59O1xudmFyIHBhcnNlRXJhUGF0dGVybnMgPSB7XG4gIGFueTogWy9eYWMvaSwgL15kYy9pXSxcbiAgd2lkZTogWy9eKGFudGVzIGRlIGNyaXN0b3xhbnRlcyBkZSBsYSBlcmEgY29tW3VcdTAwRkFdbikvaSwgL14oZGVzcHVbZVx1MDBFOV1zIGRlIGNyaXN0b3xlcmEgY29tW3VcdTAwRkFdbikvaV1cbn07XG52YXIgbWF0Y2hRdWFydGVyUGF0dGVybnMgPSB7XG4gIG5hcnJvdzogL15bMTIzNF0vaSxcbiAgYWJicmV2aWF0ZWQ6IC9eVFsxMjM0XS9pLFxuICB3aWRlOiAvXlsxMjM0XShcdTAwQkEpPyB0cmltZXN0cmUvaVxufTtcbnZhciBwYXJzZVF1YXJ0ZXJQYXR0ZXJucyA9IHtcbiAgYW55OiBbLzEvaSwgLzIvaSwgLzMvaSwgLzQvaV1cbn07XG52YXIgbWF0Y2hNb250aFBhdHRlcm5zID0ge1xuICBuYXJyb3c6IC9eW2VmbWFqc29uZF0vaSxcbiAgYWJicmV2aWF0ZWQ6IC9eKGVuZXxmZWJ8bWFyfGFicnxtYXl8anVufGp1bHxhZ298c2VwfG9jdHxub3Z8ZGljKS9pLFxuICB3aWRlOiAvXihlbmVyb3xmZWJyZXJvfG1hcnpvfGFicmlsfG1heW98anVuaW98anVsaW98YWdvc3RvfHNlcHRpZW1icmV8b2N0dWJyZXxub3ZpZW1icmV8ZGljaWVtYnJlKS9pXG59O1xudmFyIHBhcnNlTW9udGhQYXR0ZXJucyA9IHtcbiAgbmFycm93OiBbL15lL2ksIC9eZi9pLCAvXm0vaSwgL15hL2ksIC9ebS9pLCAvXmovaSwgL15qL2ksIC9eYS9pLCAvXnMvaSwgL15vL2ksIC9ebi9pLCAvXmQvaV0sXG4gIGFueTogWy9eZW4vaSwgL15mZWIvaSwgL15tYXIvaSwgL15hYnIvaSwgL15tYXkvaSwgL15qdW4vaSwgL15qdWwvaSwgL15hZ28vaSwgL15zZXAvaSwgL15vY3QvaSwgL15ub3YvaSwgL15kaWMvaV1cbn07XG52YXIgbWF0Y2hEYXlQYXR0ZXJucyA9IHtcbiAgbmFycm93OiAvXltkbG1qdnNdL2ksXG4gIHNob3J0OiAvXihkb3xsdXxtYXxtaXxqdXx2aXxzW1x1MDBFMWFdKS9pLFxuICBhYmJyZXZpYXRlZDogL14oZG9tfGx1bnxtYXJ8bWlbXHUwMEU5ZV18anVlfHZpZXxzW1x1MDBFMWFdYikvaSxcbiAgd2lkZTogL14oZG9taW5nb3xsdW5lc3xtYXJ0ZXN8bWlbXHUwMEU5ZV1yY29sZXN8anVldmVzfHZpZXJuZXN8c1tcdTAwRTFhXWJhZG8pL2lcbn07XG52YXIgcGFyc2VEYXlQYXR0ZXJucyA9IHtcbiAgbmFycm93OiBbL15kL2ksIC9ebC9pLCAvXm0vaSwgL15tL2ksIC9eai9pLCAvXnYvaSwgL15zL2ldLFxuICBhbnk6IFsvXmRvL2ksIC9ebHUvaSwgL15tYS9pLCAvXm1pL2ksIC9eanUvaSwgL152aS9pLCAvXnNhL2ldXG59O1xudmFyIG1hdGNoRGF5UGVyaW9kUGF0dGVybnMgPSB7XG4gIG5hcnJvdzogL14oYXxwfG1ufG1kfChkZSBsYXxhIGxhcykgKG1hXHUwMEYxYW5hfHRhcmRlfG5vY2hlKSkvaSxcbiAgYW55OiAvXihbYXBdXFwuP1xccz9tXFwuP3xtZWRpYW5vY2hlfG1lZGlvZGlhfChkZSBsYXxhIGxhcykgKG1hXHUwMEYxYW5hfHRhcmRlfG5vY2hlKSkvaVxufTtcbnZhciBwYXJzZURheVBlcmlvZFBhdHRlcm5zID0ge1xuICBhbnk6IHtcbiAgICBhbTogL15hL2ksXG4gICAgcG06IC9ecC9pLFxuICAgIG1pZG5pZ2h0OiAvXm1uL2ksXG4gICAgbm9vbjogL15tZC9pLFxuICAgIG1vcm5pbmc6IC9tYVx1MDBGMWFuYS9pLFxuICAgIGFmdGVybm9vbjogL3RhcmRlL2ksXG4gICAgZXZlbmluZzogL3RhcmRlL2ksXG4gICAgbmlnaHQ6IC9ub2NoZS9pXG4gIH1cbn07XG52YXIgbWF0Y2ggPSB7XG4gIG9yZGluYWxOdW1iZXI6IGJ1aWxkTWF0Y2hQYXR0ZXJuRm4oe1xuICAgIG1hdGNoUGF0dGVybjogbWF0Y2hPcmRpbmFsTnVtYmVyUGF0dGVybixcbiAgICBwYXJzZVBhdHRlcm46IHBhcnNlT3JkaW5hbE51bWJlclBhdHRlcm4sXG4gICAgdmFsdWVDYWxsYmFjazogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICByZXR1cm4gcGFyc2VJbnQodmFsdWUsIDEwKTtcbiAgICB9XG4gIH0pLFxuICBlcmE6IGJ1aWxkTWF0Y2hGbih7XG4gICAgbWF0Y2hQYXR0ZXJuczogbWF0Y2hFcmFQYXR0ZXJucyxcbiAgICBkZWZhdWx0TWF0Y2hXaWR0aDogJ3dpZGUnLFxuICAgIHBhcnNlUGF0dGVybnM6IHBhcnNlRXJhUGF0dGVybnMsXG4gICAgZGVmYXVsdFBhcnNlV2lkdGg6ICdhbnknXG4gIH0pLFxuICBxdWFydGVyOiBidWlsZE1hdGNoRm4oe1xuICAgIG1hdGNoUGF0dGVybnM6IG1hdGNoUXVhcnRlclBhdHRlcm5zLFxuICAgIGRlZmF1bHRNYXRjaFdpZHRoOiAnd2lkZScsXG4gICAgcGFyc2VQYXR0ZXJuczogcGFyc2VRdWFydGVyUGF0dGVybnMsXG4gICAgZGVmYXVsdFBhcnNlV2lkdGg6ICdhbnknLFxuICAgIHZhbHVlQ2FsbGJhY2s6IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgcmV0dXJuIGluZGV4ICsgMTtcbiAgICB9XG4gIH0pLFxuICBtb250aDogYnVpbGRNYXRjaEZuKHtcbiAgICBtYXRjaFBhdHRlcm5zOiBtYXRjaE1vbnRoUGF0dGVybnMsXG4gICAgZGVmYXVsdE1hdGNoV2lkdGg6ICd3aWRlJyxcbiAgICBwYXJzZVBhdHRlcm5zOiBwYXJzZU1vbnRoUGF0dGVybnMsXG4gICAgZGVmYXVsdFBhcnNlV2lkdGg6ICdhbnknXG4gIH0pLFxuICBkYXk6IGJ1aWxkTWF0Y2hGbih7XG4gICAgbWF0Y2hQYXR0ZXJuczogbWF0Y2hEYXlQYXR0ZXJucyxcbiAgICBkZWZhdWx0TWF0Y2hXaWR0aDogJ3dpZGUnLFxuICAgIHBhcnNlUGF0dGVybnM6IHBhcnNlRGF5UGF0dGVybnMsXG4gICAgZGVmYXVsdFBhcnNlV2lkdGg6ICdhbnknXG4gIH0pLFxuICBkYXlQZXJpb2Q6IGJ1aWxkTWF0Y2hGbih7XG4gICAgbWF0Y2hQYXR0ZXJuczogbWF0Y2hEYXlQZXJpb2RQYXR0ZXJucyxcbiAgICBkZWZhdWx0TWF0Y2hXaWR0aDogJ2FueScsXG4gICAgcGFyc2VQYXR0ZXJuczogcGFyc2VEYXlQZXJpb2RQYXR0ZXJucyxcbiAgICBkZWZhdWx0UGFyc2VXaWR0aDogJ2FueSdcbiAgfSlcbn07XG5leHBvcnQgZGVmYXVsdCBtYXRjaDsiLCAiaW1wb3J0IGZvcm1hdERpc3RhbmNlIGZyb20gXCIuL19saWIvZm9ybWF0RGlzdGFuY2UvaW5kZXguanNcIjtcbmltcG9ydCBmb3JtYXRMb25nIGZyb20gXCIuL19saWIvZm9ybWF0TG9uZy9pbmRleC5qc1wiO1xuaW1wb3J0IGZvcm1hdFJlbGF0aXZlIGZyb20gXCIuL19saWIvZm9ybWF0UmVsYXRpdmUvaW5kZXguanNcIjtcbmltcG9ydCBsb2NhbGl6ZSBmcm9tIFwiLi9fbGliL2xvY2FsaXplL2luZGV4LmpzXCI7XG5pbXBvcnQgbWF0Y2ggZnJvbSBcIi4vX2xpYi9tYXRjaC9pbmRleC5qc1wiO1xuXG4vKipcbiAqIEB0eXBlIHtMb2NhbGV9XG4gKiBAY2F0ZWdvcnkgTG9jYWxlc1xuICogQHN1bW1hcnkgU3BhbmlzaCBsb2NhbGUuXG4gKiBAbGFuZ3VhZ2UgU3BhbmlzaFxuICogQGlzby02MzktMiBzcGFcbiAqIEBhdXRob3IgSnVhbiBBbmdvc3RvIFtAanVhbmFuZ29zdG9de0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9qdWFuYW5nb3N0b31cbiAqIEBhdXRob3IgR3VpbGxlcm1vIEdyYXUgW0BndWlncnBhXXtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZ3VpZ3JwYX1cbiAqIEBhdXRob3IgRmVybmFuZG8gQWdcdTAwRkNlcm8gW0BmamFndWVyb117QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2ZqYWd1ZXJvfVxuICogQGF1dGhvciBHYXN0XHUwMEYzbiBIYXJvIFtAaGFyb2dhc3Rvbl17QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2hhcm9nYXN0b259XG4gKiBAYXV0aG9yIFlhZ28gQ2FyYmFsbG8gW0BZYWdvQ2FyYmFsbG9de0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9ZYWdvQ2FyYmFsbG99XG4gKi9cbnZhciBsb2NhbGUgPSB7XG4gIGNvZGU6ICdlcycsXG4gIGZvcm1hdERpc3RhbmNlOiBmb3JtYXREaXN0YW5jZSxcbiAgZm9ybWF0TG9uZzogZm9ybWF0TG9uZyxcbiAgZm9ybWF0UmVsYXRpdmU6IGZvcm1hdFJlbGF0aXZlLFxuICBsb2NhbGl6ZTogbG9jYWxpemUsXG4gIG1hdGNoOiBtYXRjaCxcbiAgb3B0aW9uczoge1xuICAgIHdlZWtTdGFydHNPbjogMVxuICAgIC8qIE1vbmRheSAqL1xuICAgICxcbiAgICBmaXJzdFdlZWtDb250YWluc0RhdGU6IDFcbiAgfVxufTtcbmV4cG9ydCBkZWZhdWx0IGxvY2FsZTsiLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsXSwKICAibWFwcGluZ3MiOiAiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQUE7QUFNQSxNQUFDLFVBQVUsU0FBUSxXQUFVO0FBQzNCO0FBR0EsUUFBQyxZQUFZO0FBQ1gsY0FBSSxXQUFXO0FBQ2YsY0FBSSxVQUFVLENBQUMsTUFBTSxPQUFPLFVBQVU7QUFDdEMsbUJBQVMsSUFBSSxHQUFHLElBQUksUUFBUSxVQUFVLENBQUMsUUFBTyx1QkFBdUIsRUFBRSxHQUFHO0FBQ3hFLG9CQUFPLHdCQUNMLFFBQU8sUUFBUSxLQUFLO0FBQ3RCLG9CQUFPLHVCQUNMLFFBQU8sUUFBUSxLQUFLLDJCQUNwQixRQUFPLFFBQVEsS0FBSztBQUFBO0FBRXhCLGNBQUksQ0FBQyxRQUFPO0FBQ1Ysb0JBQU8sd0JBQXdCLFNBQVUsVUFBVSxTQUFTO0FBQzFELGtCQUFJLFdBQVcsSUFBSSxPQUFPO0FBQzFCLGtCQUFJLGFBQWEsS0FBSyxJQUFJLEdBQUcsS0FBTSxZQUFXO0FBQzlDLGtCQUFJLEtBQUssUUFBTyxXQUFXLFdBQVk7QUFDckMseUJBQVMsV0FBVztBQUFBLGlCQUNuQjtBQUNILHlCQUFXLFdBQVc7QUFDdEIscUJBQU87QUFBQTtBQUVYLGNBQUksQ0FBQyxRQUFPO0FBQ1Ysb0JBQU8sdUJBQXVCLFNBQVUsSUFBSTtBQUMxQywy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Z0IsWUFBWSxJQUFJLGdCQUFnQiw2QkFBNkIsV0FBVyxXQUFXLEtBQUssQ0FBQyxHQUFHLEtBQUssY0FBYyxZQUFZO0FBQzNJLHdCQUFnQixZQUFZLElBQUksZ0JBQWdCLDZCQUE2QixXQUFXLEdBQUcsY0FBYyxZQUFZO0FBQ3JILHdCQUFnQixZQUFZLElBQUksZ0JBQWdCLDZCQUE2QixXQUFXLEdBQUcsY0FBYyxZQUFZO0FBQ3JILHdCQUFnQixZQUFZLElBQUksZ0JBQWdCLDZCQUE2QixXQUFXLEdBQUcsY0FBYyxZQUFZO0FBQ3JILHdCQUFnQixZQUFZLElBQUksZ0JBQWdCLDZCQUE2QixXQUFXLEdBQUcsY0FBYyxZQUFZO0FBQ3JILHdCQUFnQixZQUFZLElBQUksZ0JBQWdCLDZCQUE2QixXQUFXLEdBQUcsY0FBYyxZQUFZO0FBQ3JILHdCQUFnQixZQUFZLElBQUksZ0JBQWdCLDZCQUE2QixXQUFXLEdBQUcsY0FBYyxZQUFZO0FBQ3JILHdCQUFnQixZQUFZLElBQUksZ0JBQWdCLDZCQUE2QixXQUFXLElBQUksY0FBYyxZQUFZO0FBQ3RILHdCQUFnQixZQUFZLElBQUksZ0JBQWdCLDZCQUE2QixXQUFXLElBQUksY0FBYyxZQUFZO0FBQ3RILHdCQUFnQixhQUFhLElBQUksZ0JBQWdCLDZCQUE2QixZQUFZLElBQUksZUFBZSxhQUFhO0FBQzFILHdCQUFnQixhQUFhLElBQUksZ0JBQWdCLDZCQUE2QixZQUFZLElBQUksZUFBZSxhQUFhO0FBQzFILHdCQUFnQixhQUFhLElBQUksZ0JBQWdCLDZCQUE2QixZQUFZLElBQUksZUFBZSxhQUFhO0FBQzFILHdCQUFnQixhQUFhLElBQUksZ0JBQWdCLDZCQUE2QixZQUFZLElBQUksZUFBZSxhQUFhO0FBQzFILHdCQUFnQixhQUFhLElBQUksZ0JBQWdCLDZCQUE2QixZQUFZLElBQUksZUFBZSxhQUFhO0FBQzFILHdCQUFnQixhQUFhLElBQUksZ0JBQWdCLDZCQUE2QixZQUFZLElBQUksZUFBZSxhQUFhO0FBQzFILHdCQUFnQixPQUFPLElBQUksZ0JBQWdCLDZCQUE2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QUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQVc7QUFBQSxVQUFXO0FBQUEsVUFBVztBQUFBO0FBRXZGLGdCQUFRLGNBQWM7QUFBQSxVQUNsQjtBQUFBLFVBQVc7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFDM0Y7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBVztBQUFBLFVBQVc7QUFBQSxVQUFXO0FBQUE7QUFFdkYsZ0JBQVEsY0FBYztBQUFBLFVBR2xCO0FBQUEsVUFBVztBQUFBLFVBQUs7QUFBQSxVQUFPO0FBQUEsVUFBTztBQUFBLFVBQU87QUFBQSxVQUFPO0FBQUEsVUFBTztBQUFBLFVBQU87QUFBQSxVQUFPO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUM3RTtBQUFBLFVBQVE7QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQVE7QUFBQSxVQUFRO0FBQUEsVUFBUTtBQUFBLFVBQVE7QUFBQSxVQUFRO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFDNUU7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFTO0FBQUEsVUFBVztBQUFBLFVBQVc7QUFBQSxVQUFXO0FBQUE7QUFFN0QsZ0JBQVEsY0FBYztBQUFBLFVBQ2xCO0FBQUEsVUFBSTtBQUFBLFVBQU07QUFBQSxVQUFRO0FBQUEsVUFBTTtBQUFBLFVBQU07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QUFBQTtBQUc1RixzQkFBYyxnQkFBZ0I7QUFBQSxVQUMxQixXQUFXLEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFBQSxVQUNoQyxXQUFXLEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFBQSxVQUNoQyxXQUFXLEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFBQSxVQUNoQyxXQUFXLEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFBQSxVQUNoQyxXQUFXLEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFBQSxVQUNoQyxXQUFXLEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFBQSxVQUNoQyxXQUFXLEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFBQSxVQUNoQyxXQUFXLEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFBQSxVQUNoQyxXQUFXLEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFBQSxVQUNoQyxXQUFXLEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFBQSxVQUNoQyxXQUFXLEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFBQSxVQUNoQyxXQUFXLEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFBQSxVQUNoQyxXQUFXLEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFBQSxVQUNoQyxXQUFXLEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFBQSxVQUNoQyxXQUFXLEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFBQSxVQUNoQyxXQUFXLEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFBQSxVQUNoQyxXQUFXLEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFBQSxVQUNoQyxXQUFXLEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFBQSxVQUNoQyxXQUFXLEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFBQSxVQUNoQyxXQUFXLEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFBQSxVQUNoQyxXQUFXLEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFBQSxVQUNoQyxXQUFXLEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFBQSxVQUNoQyxXQUFXLEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFBQSxVQUNoQyxXQUFXLEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFBQSxVQUNoQyxXQUFXLEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFBQSxVQUNoQyxXQUFXLEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFBQSxVQUNoQyxXQUFXLEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFBQSxVQUNoQyxXQUFXLEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFBQSxVQUNoQyxXQUFXLEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFBQSxVQUNoQyxXQUFXLEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFBQSxVQUNoQyxXQUFXLEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFBQSxVQUNoQyxXQUFXLEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFBQSxVQUNoQyxXQUFXLEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFBQSxVQUNoQyxXQUFXLEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFBQSxVQUNoQyxXQUFXLEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFBQSxVQUNoQyxXQUFXLEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFBQSxVQUNoQyxXQUFXLEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFBQSxVQUNoQyxXQUFXLEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFBQSxVQUNoQyxXQUFXLEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFBQSxVQUNoQyxXQUFXLEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFBQSxVQUNoQyxXQUFXLEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFBQSxVQUNoQyxXQUFXLEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFBQSxVQUNoQyxXQUFXLEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFBQSxVQUNoQyxXQUFXLEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFBQSxVQUNoQyxXQUFXLEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFBQSxVQUNoQyxXQUFXLEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFBQSxVQUNoQyxXQUFXLEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFBQSxVQUNoQyxXQUFXLEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFBQSxVQUNoQyxXQUFXLEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFBQSxVQUNoQyxXQUFXLEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFBQSxVQUNoQyxXQUFXLEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFBQSxVQUNoQyxXQUFXLEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFBQSxVQUNoQyxXQUFXLEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFBQSxVQUNoQyxXQUFXLEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFBQSxVQUNoQyxXQUFXLEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFBQSxVQUNoQyxXQUFXLEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFBQSxVQUNoQyxXQUFXLEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFBQSxVQUNoQyxXQUFXLEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFBQSxVQUNoQyxXQUFXLEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFBQSxVQUNoQyxXQUFXLEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFBQSxVQUNoQyxXQUFXLEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFBQSxVQUNoQyxXQUFXLEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFBQSxVQUNoQyxXQUFXLEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFBQSxVQUNoQyxXQUFXLEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFBQSxVQUNoQyxXQUFXLEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFBQSxVQUNoQyxXQUFXLEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFBQSxVQUNoQyxXQUFXLEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFBQSxVQUNoQyxXQUFXLEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFBQSxVQUNoQyxXQUFXLEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFBQSxVQUNoQyxXQUFXLEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFBQSxVQUNoQyxXQUFXLEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFBQSxVQUNoQyxXQUFXLEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFBQSxVQUNoQyxXQUFXLEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFBQSxVQUNoQyxXQUFXLEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFBQSxVQUNoQyxXQUFXLEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFBQSxVQUNoQyxXQUFXLEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFBQSxVQUNoQyxXQUFXLEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFBQSxVQUNoQyxXQUFXLEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFBQSxVQUNoQyxXQUFXLEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFBQSxVQUNoQyxXQUFXLEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFBQSxVQUNoQyxXQUFXLEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFBQSxVQUNoQyxXQUFXLEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFBQSxVQUNoQyxXQUFXLEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFBQSxVQUNoQyxXQUFXLEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFBQSxVQUNoQyxXQUFXLEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFBQSxVQUNoQyxXQUFXLEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFBQSxVQUNoQyxXQUFXLEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFBQSxVQUNoQyxXQUFXLEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFBQSxVQUNoQyxXQUFXLEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFBQSxVQUNoQyxXQUFXLEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFBQSxVQUNoQyxXQUFXLEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFBQSxVQUNoQyxXQUFXLEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFBQSxVQUNoQyxXQUFXLEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFBQSxVQUNoQyxXQUFXLEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFBQSxVQUNoQyxXQUFXLEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFBQSxVQUNoQyxXQUFXLEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFBQSxVQUNoQyxXQUFXLEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFBQSxVQUNoQyxXQUFXLEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFBQSxVQUNoQyxXQUFXLEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFBQSxVQUNoQyxXQUFXLEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFBQSxVQUNoQyxXQUFXLEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFBQSxVQUNoQyxXQUFXLEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFBQSxVQUNoQyxXQUFXLEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFBQSxVQUNoQyxXQUFXLEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFBQSxVQUNoQyxXQUFXLEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFBQSxVQUNoQyxXQUFXLEtBQUss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RyxHQUFHLEdBQUc7QUFBQSxVQUM3QixXQUFXLEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHO0FBQUEsVUFDN0IsV0FBVyxLQUFLLENBQUMsR0FBRyxHQUFHLEdBQUcsR0FBRztBQUFBLFVBQzdCLFdBQVcsS0FBSyxDQUFDLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFBQSxVQUM3QixXQUFXLEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHO0FBQUEsVUFDN0IsV0FBVyxLQUFLLENBQUMsR0FBRyxHQUFHLEdBQUcsR0FBRztBQUFBLFVBQzdCLFdBQVcsS0FBSyxDQUFDLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFBQSxVQUM3QixXQUFXLEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHO0FBQUEsVUFDN0IsV0FBVyxLQUFLLENBQUMsR0FBRyxHQUFHLEdBQUcsR0FBRztBQUFBLFVBQzdCLFdBQVcsS0FBSyxDQUFDLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFBQSxVQUM3QixXQUFXLEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHO0FBQUEsVUFDN0IsV0FBVyxLQUFLLENBQUMsR0FBRyxHQUFHLEdBQUcsR0FBRztBQUFBLFVBQzdCLFdBQVcsS0FBSyxDQUFDLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFBQSxVQUM3QixXQUFXLEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHO0FBQUEsVUFDN0IsV0FBVyxLQUFLLENBQUMsR0FBRyxHQUFHLEdBQUcsR0FBRztBQUFBLFVBQzdCLFdBQVcsS0FBSyxDQUFDLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFBQSxVQUM3QixXQUFXLEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHO0FBQUEsVUFDN0IsV0FBVyxLQUFLLENBQUMsR0FBRyxHQUFHLEdBQUcsR0FBRztBQUFBLFVBQzdCLFdBQVcsS0FBSyxDQUFDLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFBQTtBQUVqQyxrQkFBVSxtQkFBbUI7QUFDN0Isa0JBQVUsMEJBQTBCO0FBRXBDLGtCQUFVLDBCQUEw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QkFBaUI7QUFBQSxVQUNwQyxDQUFDLE1BQU07QUFBQSxVQUNQLENBQUMsTUFBTTtBQUFBLFVBQ1AsQ0FBQyxNQUFNO0FBQUEsVUFDUCxDQUFDLE1BQU07QUFBQSxVQUNQLENBQUMsTUFBTTtBQUFBLFVBQ1AsQ0FBQyxNQUFNO0FBQUEsVUFDUCxDQUFDLE1BQU0sWUFBWSxpQkFBaUI7QUFBQSxVQUNwQyxDQUFDLE1BQU0sWUFBWSxpQkFBaUI7QUFBQSxVQUNwQyxDQUFDLE1BQU0sWUFBWSxpQkFBaUI7QUFBQSxVQUNwQyxDQUFDLE1BQU0sWUFBWSxpQkFBaUI7QUFBQSxVQUVwQyxDQUFDLE1BQU0sWUFBWSxpQkFBaUI7QUFBQSxVQUNwQyxDQUFDLE1BQU0sWUFBWSxpQkFBaUI7QUFBQSxVQUNwQyxDQUFDLE1BQU0sWUFBWSxpQkFBaUI7QUFBQSxVQUNwQyxDQUFDLE1BQU0sWUFBWSxpQkFBaUI7QUFBQSxVQUNwQyxDQUFDLE1BQU0sWUFBWSxpQkFBaUI7QUFBQSxVQUNwQyxDQUFDLE1BQU0sWUFBWSxpQkFBaUI7QUFBQSxVQUNwQyxDQUFDLE1BQU0sWUFBWSxpQkFBaUI7QUFBQSxVQUNwQyxDQUFDLE1BQU0sWUFBWSxpQkFBaUI7QUFBQSxVQUNwQyxDQUFDLE1BQU0sWUFBWSxpQkFBaUI7QUFBQSxVQUNwQyxDQUFDLE1BQU0sWUFBWSxpQkFBaUI7QUFBQTtBQUV4QyxvQkFBWSwwQkFBMEI7QUFBQSxVQUVsQyxDQUFDLE9BQU8sWUFBWSxpQkFBaUI7QUFBQSxVQUNyQyxDQUFDLE9BQU8sWUFBWSxpQkFBaUI7QUFBQSxVQUNyQyxDQUFDLE9BQU8sWUFBWSxpQkFBaUI7QUFBQSxVQUNyQyxDQUFDLE9BQU8sWUFBWSxpQkFBaUI7QUFBQSxVQUNyQyxDQUFDLE9BQU8sWUFBWSxpQkFBaUI7QUFBQSxVQUNyQyxDQUFDLE9BQU8sWUFBWSxpQkFBaUI7QUFBQSxVQUNyQyxDQUFDLE9BQU8sWUFBWSxpQkFBaUI7QUFBQSxVQUNyQyxDQUFDLE9BQU8sWUFBWSxpQkFBaUI7QUFBQSxVQUNyQyxDQUFDLE9BQU8sWUFBWSxpQkFBaUI7QUFBQSxVQUNyQyxDQUFDLE9BQU87QUFBQSxVQUNSLENBQUMsT0FBTyxZQUFZLGlCQUFpQjtBQUFBLFVBQ3JDLENBQUMsT0FBTztBQUFBLFVBQ1IsQ0FBQyxPQUFPO0FBQUEsVUFDUixDQUFDLE9BQU87QUFBQSxVQUNSLENBQUMsT0FBTztBQUFBLFVBQ1IsQ0FBQyxPQUFPO0FBQUEsVUFDUixDQUFDLE9BQU8sWUFBWSxpQkFBaUI7QUFBQSxVQUNyQyxDQUFDLE9BQU8sWUFBWSxpQkFBaUI7QUFBQSxVQUNyQyxDQUFDLE9BQU87QUFBQSxVQUNSLENBQUMsT0FBTyxZQUFZLGlCQUFpQjtBQUFBLFVBQ3JDLENBQUMsT0FBTztBQUFBLFVBQ1IsQ0FBQyxPQUFPO0FBQUEsVUFDUixDQUFDLE9BQU87QUFBQTtBQUVaLG9CQUFZLHFDQUFxQztBQUFBLFVBRTdDLENBQUMsT0FBTztBQUFBLFVBQ1IsQ0FBQyxPQUFPO0FBQUEsVUFDUixDQUFDLE9BQU87QUFBQSxVQUNSLENBQUMsT0FBTztBQUFBLFVBQ1IsQ0FBQyxPQUFPO0FBQUEsVUFDUixDQUFDLE9BQU87QUFBQSxVQUNSLENBQUMsT0FBTztBQUFBLFVBQ1IsQ0FBQyxPQUFPO0FBQUEsVUFDUixDQUFDLE9BQU87QUFBQSxVQUNSLENBQUMsT0FBTztBQUFBLFVBQ1IsQ0FBQyxPQUFPO0FBQUEsVUFDUixDQUFDLE9BQU87QUFBQSxVQUNSLENBQUMsT0FBTztBQUFBLFVBQ1IsQ0FBQyxPQUFPO0FBQUEsVUFDUixDQUFDLE9BQU87QUFBQSxVQUNSLENBQUMsT0FBTztBQUFBLFVBQ1IsQ0FBQyxPQUFPO0FBQUEsVUFDUixDQUFDLE9BQU87QUFBQSxVQUNSLENBQUMsT0FBTztBQUFBLFVBQ1IsQ0FBQyxPQUFPO0FBQUEsVUFDUixDQUFDLE9BQU87QUFBQSxVQUNSLENBQUMsT0FBTztBQUFBLFVBQ1IsQ0FBQyxPQUFPO0FBQUEsVUFDUixDQUFDLE9BQU87QUFBQSxVQUNSLENBQUMsT0FBTztBQUFBLFVBQ1IsQ0FBQyxPQUFPO0FBQUEsVUFDUixDQUFDLE9BQU87QUFBQSxVQUNSLENBQUMsT0FBTztBQUFBLFVBQ1IsQ0FBQyxPQUFPO0FBQUEsVUFDUixDQUFDLE9BQU87QUFBQSxVQUNSLENBQUMsT0FBTztBQUFBLFVBQ1IsQ0FBQyxPQUFPO0FBQUEsVUFDUixDQUFDLE9BQU87QUFBQSxVQUNSLENBQUMsT0FBTztBQUFBLFVBQ1IsQ0FBQyxPQUFPO0FBQUEsVUFDUixDQUFDLE9BQU87QUFBQSxVQUNSLENBQUMsT0FBTztBQUFBLFVBQ1IsQ0FBQyxPQUFPO0FBQUEsVUFDUixDQUFDLE9BQU87QUFBQSxVQUNSLENBQUMsT0FBTztBQUFBLFVBQ1IsQ0FBQyxPQUFPO0FBQUEsVUFDUixDQUFDLE9BQU87QUFBQSxVQUNSLENBQUMsT0FBTztBQUFBLFVBQ1IsQ0FBQyxPQUFPO0FBQUEsVUFDUixDQUFDLE9BQU87QUFBQSxVQUNSLENBQUMsT0FBTztBQUFBLFVBQ1IsQ0FBQyxPQUFPO0FBQUEsVUFDUixDQUFDLE9BQU87QUFBQSxVQUNSLENBQUMsT0FBTztBQUFBLFVBQ1IsQ0FBQyxPQUFPO0FBQUEsVUFDUixDQUFDLE9BQU87QUFBQSxVQUNSLENBQUMsT0FBTztBQUFBLFVBQ1IsQ0FBQyxPQUFPLFlBQVksaUJBQWlCO0FBQUEsVUFDckMsQ0FBQyxPQUFPLFlBQVksaUJBQWlCO0FBQUEsVUFDckMsQ0FBQyxPQUFPLFlBQVksaUJBQWlCO0FBQUEsVUFDckMsQ0FBQyxPQUFPLFlBQVksaUJBQWlCO0FBQUEsVUFDckMsQ0FBQyxPQUFPLFlBQVksaUJBQWlCO0FBQUE7QUFFekMsb0JBQVkseUJBQXlCO0FBQUEsVUFFakMsQ0FBQyxRQUFRO0FBQUEsVUFDVCxDQUFDLFFBQVEsWUFBWSxpQkFBaUI7QUFBQSxVQUN0QyxDQUFDLFFBQVE7QUFBQSxVQUNULENBQUMsUUFBUTtBQUFBLFVBQ1QsQ0FBQyxRQUFRLFlBQVksaUJBQWlCO0FBQUEsVUFDdEMsQ0FBQyxRQUFRLFlBQVksaUJBQWlCO0FBQUEsVUFDdEMsQ0FBQyxRQUFRLFlBQVksaUJBQWlCO0FBQUEsVUFDdEMsQ0FBQyxRQUFRO0FBQUEsVUFDVCxDQUFDLFFBQVE7QUFBQSxVQUNULENBQUMsUUFBUSxZQUFZLGlCQUFpQjtBQUFBLFVBQ3RDLENBQUMsUUFBUSxZQUFZLGlCQUFpQjtBQUFBLFVBQ3RDLENBQUMsUUFBUTtBQUFBLFVBQ1QsQ0FBQyxRQUFRLFlBQVksaUJBQWlCO0FBQUEsVUFDdEMsQ0FBQyxRQUFRO0FBQUEsVUFDVCxDQUFDLFFBQVE7QUFBQSxVQUNULENBQUMsUUFBUTtBQUFBLFVBQ1QsQ0FBQyxRQUFRLFlBQVksaUJBQWlCO0FBQUEsVUFDdEMsQ0FBQyxRQUFRLFlBQVksaUJBQWlCO0FBQUE7QUFHMUMsa0NBQTBCO0FBQUEsVUFDdEIsWUFBWSxhQUFhO0FBQ3JCLGlCQUFLLFNBQVMsSUFBSTtBQUNsQixpQkFBSyxjQUFjO0FBQUE7QUFBQSxVQUV2QixlQUFlLE1BQU0saUJBQWlCO0FBQ2xDLGdCQUFJLGtCQUFrQjtBQUN0QixnQkFBSSxZQUFZO0FBQ2hCLGVBQUc7QUFDQyxrQkFBSSxPQUFPLEtBQUssMEJBQTBCLGlCQUFpQjtBQUMzRCxrQkFBSSxlQUFlLFlBQVksNEJBQTRCLEtBQUs7QUFDaEUsa0JBQUksZ0JBQWdCLE1BQU07QUFDdEIscUJBQUssT0FBTztBQUFBO0FBRWhCLGtCQUFJLEtBQUssZUFBZTtBQUNwQiw0QkFBWSxLQUFLLEtBQUs7QUFBQSxxQkFFckI7QUFDRCw0QkFBWTtBQUFBO0FBRWhCLGtCQUFJLG9CQUFvQixLQUFLLGtCQUFrQjtBQUMzQztBQUFBO0FBRUosZ0NBQWtCLEtBQUs7QUFBQSxxQkFDbEI7QUFDVCxtQkFBTyxLQUFLO0FBQUE7QUFBQSxVQUVoQixlQUFlLEtBQUs7QUFHaEIsZ0JBQUksTUFBTSxJQUFJLEtBQUssWUFBWSxXQUFXO0FBQ3RDLHFCQUFPLE1BQU0sS0FBSyxLQUFLLFlBQVk7QUFBQTtBQUV2QyxxQkFBUyxJQUFJLEtBQUssSUFBSSxNQUFNLEdBQUcsRUFBRSxHQUFHO0FBQ2hDLGtCQUFJLEtBQUssWUFBWSxJQUFJLElBQUk7QUFDekIsdUJBQU87QUFBQTtBQUFBO0FBR2YsbUJBQU8sS0FBSyxZQUFZLElBQUksTUFBTTtBQUFBO0FBQUEsVUFFdEMsY0FBYyxLQUFLO0FBQ2YsZ0JBQUksTUFBTSxJQUFJLEtBQUssWUFBWSxXQUFXO0FBQ3RDLGtCQUFJLFdBQVUsS0FBSyxnQ0FBZ0MsS0FBSztBQUN4RCxrQkFBSSxhQUFZLEdBQUc7QUFDZix1QkFBTyxJQUFJLGVBQWUsS0FBSyxZQUFZLFdBQVcsZUFBZSxNQUFNLGVBQWU7QUFBQTtBQUU5RixxQkFBTyxJQUFJLGVBQWUsS0FBSyxZQUFZLFdBQVcsV0FBVSxHQUFHLGVBQWU7QUFBQTtBQUV0RixnQkFBSSxVQUFVLEtBQUssZ0NBQWdDLEtBQUs7QUFDeEQsZ0JBQUksU0FBVSxXQUFVLEtBQUs7QUFDN0IsZ0JBQUksU0FBVSxXQUFVLEtBQUs7QUFDN0IsbUJBQU8sSUFBSSxlQUFlLE1BQU0sR0FBRyxRQUFRO0FBQUE7QUFBQSxVQUUvQyxnQ0FBZ0MsS0FBSyxNQUFNO0FBQ3ZDLG1CQUFPLG9CQUFvQixnQ0FBZ0MsS0FBSyxhQUFhLEtBQUs7QUFBQTtBQUFBLGlCQUUvRSxnQ0FBZ0MsYUFBYSxLQUFLLE1BQU07QUFDM0QsZ0JBQUksUUFBUTtBQUNaLHFCQUFTLElBQUksR0FBRyxJQUFJLE1BQU0sRUFBRSxHQUFHO0FBQzNCLGtCQUFJLFlBQVksSUFBSSxNQUFNLElBQUk7QUFDMUIseUJBQVMsS0FBTSxPQUFPLElBQUk7QUFBQTtBQUFBO0FBR2xDLG1CQUFPO0FBQUE7QUFBQSxVQUVYLDBCQUEwQixLQUFLLFdBQVc7QUFFdEMsaUJBQUssT0FBTztBQUNaLGdCQUFJLGFBQWEsTUFBTTtBQUNuQixtQkFBSyxPQUFPLE9BQU87QUFBQTtBQUV2QixpQkFBSyxRQUFRLFlBQVk7QUFDekIsZ0JBQUksY0FBYyxLQUFLO0FBQ3ZCLGdCQUFJLGVBQWUsUUFBUSxZQUFZLGVBQWU7QUFDbEQscUJBQU8sSUFBSSxtQkFBbUIsS0FBSyxRQUFRLGVBQWUsS0FBSyxPQUFPLFlBQVksWUFBWTtBQUFBO0FBRWxHLG1CQUFPLElBQUksbUJBQW1CLEtBQUssUUFBUSxlQUFlLEtBQUssT0FBTztBQUFBO0FBQUEsVUFFMUUsY0FBYztBQUNWLGdCQUFJO0FBQ0osZ0JBQUk7QUFDSixlQUFHO0FBQ0Msa0JBQUksa0JBQWtCLEtBQUssUUFBUTtBQUNuQyxrQkFBSSxLQUFLLFFBQVEsV0FBVztBQUN4Qix5QkFBUyxLQUFLO0FBQ2QsNkJBQWEsT0FBTztBQUFBLHlCQUVmLEtBQUssUUFBUSxlQUFlO0FBQ2pDLHlCQUFTLEtBQUs7QUFDZCw2QkFBYSxPQUFPO0FBQUEscUJBRW5CO0FBQ0QseUJBQVMsS0FBSztBQUNkLDZCQUFhLE9BQU87QUFBQTtBQUV4QixrQkFBSSxrQkFBa0Isb0JBQW9CLEtBQUssUUFBUTtBQUN2RCxrQkFBSSxDQUFDLG1CQUFtQixDQUFDLFlBQVk7QUFDakM7QUFBQTtBQUFBLHFCQUVDLENBQUM7QUFDVixtQkFBTyxPQUFPO0FBQUE7QUFBQSxVQUVsQixvQkFBb0I7QUFDaEIsbUJBQU8sS0FBSyxlQUFlLEtBQUssUUFBUSxnQkFBZ0I7QUFDcEQsa0JBQUksVUFBVSxLQUFLLGNBQWMsS0FBSyxRQUFRO0FBQzlDLG1CQUFLLFFBQVEsWUFBWSxRQUFRO0FBQ2pDLGtCQUFJLFFBQVEsb0JBQW9CO0FBQzVCLG9CQUFJO0FBQ0osb0JBQUksUUFBUSxxQkFBcUI7QUFDN0IsZ0NBQWMsSUFBSSxtQkFBbUIsS0FBSyxRQUFRLGVBQWUsS0FBSyxPQUFPO0FBQUEsdUJBRTVFO0FBQ0QsZ0NBQWMsSUFBSSxtQkFBbUIsS0FBSyxRQUFRLGVBQWUsS0FBSyxPQUFPLFlBQVksUUFBUTtBQUFBO0FBRXJHLHVCQUFPLElBQUksa0JBQWtCLE1BQU07QUFBQTtBQUV2QyxtQkFBSyxPQUFPLE9BQU8sUUFBUTtBQUMzQixrQkFBSSxRQUFRLHFCQUFxQjtBQUM3QixvQkFBSSxjQUFjLElBQUksbUJBQW1CLEtBQUssUUFBUSxlQUFlLEtBQUssT0FBTztBQUNqRix1QkFBTyxJQUFJLGtCQUFrQixNQUFNO0FBQUE7QUFFdkMsbUJBQUssT0FBTyxPQUFPLFFBQVE7QUFBQTtBQUUvQixnQkFBSSxLQUFLLDZCQUE2QixLQUFLLFFBQVEsZ0JBQWdCO0FBQy9ELG1CQUFLLFFBQVE7QUFDYixtQkFBSyxRQUFRLGtCQUFrQjtBQUFBO0FBRW5DLG1CQUFPLElBQUksa0JBQWtCO0FBQUE7QUFBQSxVQUVqQyxzQkFBc0I7QUFDbEIsbUJBQU8sS0FBSyxpQkFBaUIsS0FBSyxRQUFRLGdCQUFnQjtBQUN0RCxrQkFBSSxNQUFNLEtBQUssZ0JBQWdCLEtBQUssUUFBUTtBQUM1QyxtQkFBSyxRQUFRLFlBQVksSUFBSTtBQUM3QixrQkFBSSxJQUFJLFVBQVU7QUFDZCxvQkFBSSxjQUFjLElBQUksbUJBQW1CLEtBQUssUUFBUSxlQUFlLEtBQUssT0FBTztBQUNqRix1QkFBTyxJQUFJLGtCQUFrQixNQUFNO0FBQUE7QUFFdkMsbUJBQUssT0FBTyxPQUFPLElBQUk7QUFBQTtBQUUzQixnQkFBSSxLQUFLLDJCQUEyQixLQUFLLFFBQVEsZ0JBQWdCO0FBQzdELG1CQUFLLFFBQVEsa0JBQWtCO0FBQy9CLG1CQUFLLFFBQVE7QUFBQSx1QkFFUixLQUFLLHlCQUF5QixLQUFLLFFBQVEsZ0JBQWdCO0FBQ2hFLGtCQUFJLEtBQUssUUFBUSxnQkFBZ0IsSUFBSSxLQUFLLFlBQVksV0FBVztBQUM3RCxxQkFBSyxRQUFRLGtCQUFrQjtBQUFBLHFCQUU5QjtBQUNELHFCQUFLLFFBQVEsWUFBWSxLQUFLLFlBQVk7QUFBQTtBQUU5QyxtQkFBSyxRQUFRO0FBQUE7QUFFakIsbUJBQU8sSUFBSSxrQkFBa0I7QUFBQTtBQUFBLFVBRWpDLGtCQUFrQjtBQUNkLG1CQUFPLEtBQUssYUFBYSxLQUFLLFFBQVEsZ0JBQWdCO0FBQ2xELGtCQUFJLFFBQVEsS0FBSyxtQkFBbUIsS0FBSyxRQUFRO0FBQ2pELG1CQUFLLFFBQVEsWUFBWSxNQUFNO0FBQy9CLGtCQUFJLE1BQU0sVUFBVTtBQUNoQixvQkFBSSxjQUFjLElBQUksbUJBQW1CLEtBQUssUUFBUSxlQUFlLEtBQUssT0FBTztBQUNqRix1QkFBTyxJQUFJLGtCQUFrQixNQUFNO0FBQUE7QUFFdkMsbUJBQUssT0FBTyxPQUFPLE1BQU07QUFBQTtBQUU3QixnQkFBSSxLQUFLLDJCQUEyQixLQUFLLFFBQVEsZ0JBQWdCO0FBQzdELG1CQUFLLFFBQVEsa0JBQWtCO0FBQy9CLG1CQUFLLFFBQVE7QUFBQSx1QkFFUixLQUFLLHlCQUF5QixLQUFLLFFBQVEsZ0JBQWdCO0FBQ2hFLGtCQUFJLEtBQUssUUFBUSxnQkFBZ0IsSUFBSSxLQUFLLFlBQVksV0FBVztBQUM3RCxxQkFBSyxRQUFRLGtCQUFrQjtBQUFBLHFCQUU5QjtBQUNELHFCQUFLLFFBQVEsWUFBWSxLQUFLLFlBQVk7QUFBQTtBQUU5QyxtQkFBSyxRQUFRO0FBQUE7QUFFakIsbUJBQU8sSUFBSSxrQkFBa0I7QUFBQTtBQUFBLFVBRWpDLGlCQUFpQixLQUFLO0FBQ2xCLGdCQUFJLE1BQU0sSUFBSSxLQUFLLFlBQVksV0FBVztBQUN0QyxxQkFBTztBQUFBO0FBRVgsZ0JBQUksZUFBZSxLQUFLLGdDQUFnQyxLQUFLO0FBQzdELGdCQUFJLGdCQUFnQixLQUFLLGVBQWUsSUFBSTtBQUN4QyxxQkFBTztBQUFBO0FBRVgsZ0JBQUksTUFBTSxJQUFJLEtBQUssWUFBWSxXQUFXO0FBQ3RDLHFCQUFPO0FBQUE7QUFFWCxnQkFBSSxnQkFBZ0IsS0FBSyxnQ0FBZ0MsS0FBSztBQUM5RCxnQkFBSSxpQkFBaUIsTUFBTSxnQkFBZ0IsS0FBSztBQUM1QyxxQkFBTztBQUFBO0FBRVgsZ0JBQUksTUFBTSxJQUFJLEtBQUssWUFBWSxXQUFXO0FBQ3RDLHFCQUFPO0FBQUE7QUFFWCxnQkFBSSxnQkFBZ0IsS0FBSyxnQ0FBZ0MsS0FBSztBQUM5RCxtQkFBTyxpQkFBaUIsT0FBTyxnQkFBZ0I7QUFBQTtBQUFBLFVBRW5ELGdCQUFnQixLQUFLO0FBQ2pCLGdCQUFJLGVBQWUsS0FBSyxnQ0FBZ0MsS0FBSztBQUM3RCxnQkFBSSxpQkFBaUIsSUFBSTtBQUNyQixxQkFBTyxJQUFJLFlBQVksTUFBTSxHQUFHLFlBQVk7QUFBQTtBQUVoRCxnQkFBSSxnQkFBZ0IsS0FBSyxlQUFlLElBQUk7QUFDeEMscUJBQU8sSUFBSSxZQUFZLE1BQU0sR0FBSSxNQUFPLGdCQUFlO0FBQUE7QUFFM0QsZ0JBQUksZ0JBQWdCLEtBQUssZ0NBQWdDLEtBQUs7QUFDOUQsZ0JBQUksaUJBQWlCLE1BQU0sZ0JBQWdCLElBQUk7QUFDM0MscUJBQU8sSUFBSSxZQUFZLE1BQU0sR0FBSSxLQUFNLGlCQUFnQjtBQUFBO0FBRTNELGdCQUFJLGlCQUFpQixNQUFNLGdCQUFnQixLQUFLO0FBQzVDLHFCQUFPLElBQUksWUFBWSxNQUFNLEdBQUksS0FBTSxpQkFBZ0I7QUFBQTtBQUUzRCxnQkFBSSxnQkFBZ0IsS0FBSyxnQ0FBZ0MsS0FBSztBQUM5RCxnQkFBSTtBQUNKLG9CQUFRO0FBQUEsbUJBQ0M7QUFDRCxvQkFBSTtBQUNKO0FBQUEsbUJBQ0M7QUFDRCxvQkFBSTtBQUNKO0FBQUEsbUJBQ0M7QUFDRCxvQkFBSTtBQUNKO0FBQUEsbUJBQ0M7QUFDRCxvQkFBSTtBQUNKO0FBQUEsbUJBQ0M7QUFDRCxvQkFBSTtBQUNKO0FBQUEsbUJBQ0M7QUFDRCxvQkFBSTtBQUNKO0FBQUEsbUJBQ0M7QUFDRCxvQkFBSTtBQUNKO0FBQUEsbUJBQ0M7QUFDRCxvQkFBSTtBQUNKO0FBQUEsbUJBQ0M7QUFDRCxvQkFBSTtBQUNKO0FBQUEsbUJBQ0M7QUFDRCxvQkFBSTtBQUNKO0FBQUEsbUJBQ0M7QUFDRCxvQkFBSTtBQUNKO0FBQUEsbUJBQ0M7QUFDRCxvQkFBSTtBQUNKO0FBQUEsbUJBQ0M7QUFDRCxvQkFBSTtBQUNKO0FBQUEsbUJBQ0M7QUFDRCxvQkFBSTtBQUNKO0FBQUEsbUJBQ0M7QUFDRCxvQkFBSTtBQUNKO0FBQUEsbUJBQ0M7QUFDRCxvQkFBSTtBQUNKO0FBQUEsbUJBQ0M7QUFDRCxvQkFBSTtBQUNKO0FBQUEsbUJBQ0M7QUFDRCxvQkFBSTtBQUNKO0FBQUEsbUJBQ0M7QUFDRCxvQkFBSTtBQUNKO0FBQUEsbUJBQ0M7QUFDRCxvQkFBSTtBQUNKO0FBQUEsbUJBQ0M7QUFDRCxvQkFBSTtBQUNKO0FBQUE7QUFFQSxzQkFBTSxJQUFJO0FBQUE7QUFFbEIsbUJBQU8sSUFBSSxZQUFZLE1BQU0sR0FBRztBQUFBO0FBQUEsVUFFcEMsYUFBYSxLQUFLO0FBQ2QsZ0JBQUksTUFBTSxJQUFJLEtBQUssWUFBWSxXQUFXO0FBQ3RDLHFCQUFPO0FBQUE7QUFHWCxnQkFBSSxlQUFlLEtBQUssZ0NBQWdDLEtBQUs7QUFDN0QsZ0JBQUksZ0JBQWdCLEtBQUssZUFBZSxJQUFJO0FBQ3hDLHFCQUFPO0FBQUE7QUFFWCxnQkFBSSxNQUFNLElBQUksS0FBSyxZQUFZLFdBQVc7QUFDdEMscUJBQU87QUFBQTtBQUVYLGdCQUFJLGNBQWMsS0FBSyxnQ0FBZ0MsS0FBSztBQUM1RCxtQkFBTyxlQUFlLE1BQU0sY0FBYztBQUFBO0FBQUEsVUFFOUMsbUJBQW1CLEtBQUs7QUFDcEIsZ0JBQUksZUFBZSxLQUFLLGdDQUFnQyxLQUFLO0FBQzdELGdCQUFJLGlCQUFpQixJQUFJO0FBQ3JCLHFCQUFPLElBQUksWUFBWSxNQUFNLEdBQUcsWUFBWTtBQUFBO0FBRWhELGdCQUFJLGdCQUFnQixLQUFLLGVBQWUsSUFBSTtBQUN4QyxxQkFBTyxJQUFJLFlBQVksTUFBTSxHQUFJLE1BQU8sZ0JBQWU7QUFBQTtBQUUzRCxnQkFBSSxjQUFjLEtBQUssZ0NBQWdDLEtBQUs7QUFDNUQsZ0JBQUksZUFBZSxNQUFNLGNBQWMsSUFBSTtBQUN2QyxxQkFBTyxJQUFJLFlBQVksTUFBTSxHQUFJLEtBQU0sZUFBYztBQUFBO0FBRXpELGdCQUFJO0FBQ0osb0JBQVE7QUFBQSxtQkFDQztBQUNELG9CQUFJO0FBQ0o7QUFBQSxtQkFDQztBQUNELG9CQUFJO0FBQ0o7QUFBQSxtQkFDQztBQUNELG9CQUFJO0FBQ0o7QUFBQSxtQkFDQztBQUNELG9CQUFJO0FBQ0o7QUFBQSxtQkFDQztBQUNELG9CQUFJO0FBQ0o7QUFBQTtBQUVBLHNCQUFNLElBQUksc0JBQXNCLDBDQUEwQztBQUFBO0FBRWxGLG1CQUFPLElBQUksWUFBWSxNQUFNLEdBQUc7QUFBQTtBQUFBLFVBRXBDLHlCQUF5QixLQUFLO0FBQzFCLGdCQUFJLE1BQU0sSUFBSSxLQUFLLFlBQVksV0FBVztBQUN0QyxxQkFBTztBQUFBO0FBRVgscUJBQVMsSUFBSSxHQUFHLElBQUksS0FBSyxJQUFJLE1BQU0sS0FBSyxZQUFZLFdBQVcsRUFBRSxHQUFHO0FBQ2hFLGtCQUFJLE1BQU0sR0FBRztBQUNULG9CQUFJLENBQUMsS0FBSyxZQUFZLElBQUksTUFBTSxJQUFJO0FBQ2hDLHlCQUFPO0FBQUE7QUFBQSx5QkFHTixLQUFLLFlBQVksSUFBSSxNQUFNLElBQUk7QUFDcEMsdUJBQU87QUFBQTtBQUFBO0FBR2YsbUJBQU87QUFBQTtBQUFBLFVBRVgsMkJBQTJCLEtBQUs7QUFFNUIsZ0JBQUksTUFBTSxJQUFJLEtBQUssWUFBWSxXQUFXO0FBQ3RDLHFCQUFPO0FBQUE7QUFFWCxxQkFBUyxJQUFJLEtBQUssSUFBSSxNQUFNLEdBQUcsRUFBRSxHQUFHO0FBQ2hDLGtCQUFJLEtBQUssWUFBWSxJQUFJLElBQUk7QUFDekIsdUJBQU87QUFBQTtBQUFBO0FBR2YsbUJBQU87QUFBQTtBQUFBLFVBRVgsNkJBQTZCLEtBQUs7QUFHOUIsZ0JBQUksTUFBTSxJQUFJLEtBQUssWUFBWSxXQUFXO0FBQ3RDLHFCQUFPO0FBQUE7QUFFWCxxQkFBUyxJQUFJLEdBQUcsSUFBSSxLQUFLLElBQUksTUFBTSxLQUFLLFlBQVksV0FBVyxFQUFFLEdBQUc7QUFDaEUsa0JBQUksS0FBSyxZQUFZLElBQUksTUFBTSxJQUFJO0FBQy9CLHVCQUFPO0FBQUE7QUFBQTtBQUdmLG1CQUFPO0FBQUE7QUFBQTtBQUlmLHNDQUE4QjtBQUFBLFVBQzFCLFlBQVksYUFBYTtBQUNyQixpQkFBSyxjQUFjO0FBQ25CLGlCQUFLLGlCQUFpQixJQUFJLG9CQUFvQjtBQUFBO0FBQUEsVUFFbEQsaUJBQWlCO0FBQ2IsbUJBQU8sS0FBSztBQUFBO0FBQUEsVUFFaEIsb0JBQW9CO0FBQ2hCLG1CQUFPLEtBQUs7QUFBQTtBQUFBO0FBSXBCLGtDQUEwQix3QkFBd0I7QUFBQSxVQUM5QyxZQUFZLGFBQWE7QUFDckIsa0JBQU07QUFBQTtBQUFBLFVBRVYscUJBQXFCLEtBQUssWUFBWTtBQUNsQyxnQkFBSSxPQUFPO0FBQ1gsZ0JBQUksa0JBQWtCLElBQUk7QUFDMUIsZ0JBQUksT0FBTztBQUNYLGlCQUFLLDhCQUE4QixLQUFLLFlBQVk7QUFBQTtBQUFBLFVBRXhELDhCQUE4QixLQUFLLFlBQVksdUJBQXVCO0FBQ2xFLHFCQUFTLElBQUksR0FBRyxJQUFJLEdBQUcsRUFBRSxHQUFHO0FBQ3hCLGtCQUFJLGVBQWUsS0FBSyxvQkFBb0IsZ0NBQWdDLGFBQWEsS0FBSyxHQUFHO0FBQ2pHLGtCQUFJLGVBQWUsUUFBUSxHQUFHO0FBQzFCLG9CQUFJLE9BQU87QUFBQTtBQUVmLGtCQUFJLGVBQWUsT0FBTyxHQUFHO0FBQ3pCLG9CQUFJLE9BQU87QUFBQTtBQUVmLGtCQUFJLE9BQU87QUFBQTtBQUVmLHdCQUFZLGlCQUFpQixLQUFLO0FBQUE7QUFBQSxpQkFFL0IsaUJBQWlCLEtBQUssWUFBWTtBQUNyQyxnQkFBSSxhQUFhO0FBQ2pCLHFCQUFTLElBQUksR0FBRyxJQUFJLElBQUksS0FBSztBQUd6QixrQkFBSSxRQUFRLElBQUksT0FBTyxJQUFJLFlBQVksV0FBVyxLQUFLLElBQUksV0FBVztBQUN0RSw0QkFBZSxLQUFJLE9BQVUsSUFBSSxJQUFJLFFBQVE7QUFBQTtBQUVqRCx5QkFBYSxLQUFNLGFBQWE7QUFDaEMsZ0JBQUksZUFBZSxJQUFJO0FBQ25CLDJCQUFhO0FBQUE7QUFFakIsZ0JBQUksT0FBTztBQUFBO0FBQUE7QUFHbkIsb0JBQVksWUFBWTtBQUV4QixzQ0FBOEIsWUFBWTtBQUFBLFVBRXRDLFlBQVksYUFBYTtBQUNyQixrQkFBTTtBQUFBO0FBQUEsVUFFVixtQkFBbUI7QUFDZixnQkFBSSxPQUFPLElBQUk7QUFDZixpQkFBSyxPQUFPO0FBQ1osZ0JBQUksc0JBQXNCLEtBQUs7QUFDL0IsZ0JBQUksaUJBQWlCLEtBQUssb0JBQW9CLGdDQUFnQyxnQkFBZ0IsYUFBYTtBQUMzRyxpQkFBSyxPQUFPO0FBQ1osaUJBQUssOEJBQThCLE1BQU0sZ0JBQWdCLGNBQWMsR0FBRztBQUMxRSxtQkFBTyxLQUFLLG9CQUFvQixlQUFlLE1BQU0sZ0JBQWdCLGNBQWM7QUFBQTtBQUFBO0FBRzNGLHdCQUFnQixjQUFjLElBQUksSUFBSTtBQUV0QyxtQ0FBMkIsd0JBQXdCO0FBQUEsVUFDL0MsWUFBWSxhQUFhO0FBQ3JCLGtCQUFNO0FBQUE7QUFBQSxVQUVWLG1CQUFtQjtBQUNmLGdCQUFJLE1BQU0sSUFBSTtBQUNkLG1CQUFPLEtBQUssb0JBQW9CLGVBQWUsS0FBSyxhQUFhO0FBQUE7QUFBQTtBQUd6RSxxQkFBYSxjQUFjLElBQUksSUFBSTtBQUVuQyx3Q0FBZ0MsWUFBWTtBQUFBLFVBQ3hDLFlBQVksYUFBYTtBQUNyQixrQkFBTTtBQUFBO0FBQUEsVUFFVix1QkFBdUIsS0FBSyxZQUFZLFlBQVk7QUFDaEQsZ0JBQUksd0JBQXdCLEtBQUssb0JBQW9CLGdDQUFnQyxZQUFZO0FBQ2pHLGlCQUFLLGNBQWMsS0FBSztBQUN4QixnQkFBSSxnQkFBZ0IsS0FBSyxZQUFZO0FBQ3JDLGdCQUFJLGlCQUFpQjtBQUNyQixxQkFBUyxJQUFJLEdBQUcsSUFBSSxHQUFHLEVBQUUsR0FBRztBQUN4QixrQkFBSSxnQkFBZ0IsbUJBQW1CLEdBQUc7QUFDdEMsb0JBQUksT0FBTztBQUFBO0FBRWYsZ0NBQWtCO0FBQUE7QUFFdEIsZ0JBQUksT0FBTztBQUFBO0FBQUE7QUFJbkIsc0NBQThCLGtCQUFrQjtBQUFBLFVBQzVDLFlBQVksYUFBYTtBQUNyQixrQkFBTTtBQUFBO0FBQUEsVUFFVixtQkFBbUI7QUFDZixnQkFBSSxLQUFLLGlCQUFpQixhQUFhLGdCQUFnQixjQUFjLGtCQUFrQixZQUFZLGdCQUFnQixhQUFhO0FBQzVILG9CQUFNLElBQUk7QUFBQTtBQUVkLGdCQUFJLE1BQU0sSUFBSTtBQUNkLGlCQUFLLHFCQUFxQixLQUFLLGdCQUFnQjtBQUMvQyxpQkFBSyx1QkFBdUIsS0FBSyxnQkFBZ0IsY0FBYyxrQkFBa0IsV0FBVyxnQkFBZ0I7QUFDNUcsbUJBQU8sSUFBSTtBQUFBO0FBQUE7QUFHbkIsd0JBQWdCLGNBQWMsSUFBSTtBQUNsQyx3QkFBZ0IsY0FBYztBQUU5QixzQ0FBOEIsZ0JBQWdCO0FBQUEsVUFDMUMsWUFBWSxhQUFhO0FBQ3JCLGtCQUFNO0FBQUE7QUFBQSxVQUVWLGNBQWMsS0FBSyxRQUFRO0FBQ3ZCLGdCQUFJLE9BQU87QUFBQTtBQUFBLFVBRWYsWUFBWSxRQUFRO0FBQ2hCLG1CQUFPO0FBQUE7QUFBQTtBQUlmLHNDQUE4QixnQkFBZ0I7QUFBQSxVQUMxQyxZQUFZLGFBQWE7QUFDckIsa0JBQU07QUFBQTtBQUFBLFVBRVYsY0FBYyxLQUFLLFFBQVE7QUFDdkIsZ0JBQUksU0FBUyxLQUFPO0FBQ2hCLGtCQUFJLE9BQU87QUFBQSxtQkFFVjtBQUNELGtCQUFJLE9BQU87QUFBQTtBQUFBO0FBQUEsVUFHbkIsWUFBWSxRQUFRO0FBQ2hCLGdCQUFJLFNBQVMsS0FBTztBQUNoQixxQkFBTztBQUFBO0FBRVgsbUJBQU8sU0FBUztBQUFBO0FBQUE7QUFJeEIsc0NBQThCLFlBQVk7QUFBQSxVQUN0QyxZQUFZLGFBQWE7QUFDckIsa0JBQU07QUFBQTtBQUFBLFVBRVYsbUJBQW1CO0FBQ2YsZ0JBQUksS0FBSyxpQkFBaUIsWUFBWSxnQkFBZ0IsY0FBYyxZQUFZLFdBQVc7QUFDdkYsb0JBQU0sSUFBSTtBQUFBO0FBRWQsZ0JBQUksTUFBTSxJQUFJO0FBQ2QsaUJBQUsscUJBQXFCLEtBQUssZ0JBQWdCO0FBQy9DLGdCQUFJLGNBQWMsS0FBSyxvQkFBb0IsZ0NBQWdDLGdCQUFnQixjQUFjLFlBQVksV0FBVyxnQkFBZ0I7QUFDaEosZ0JBQUksT0FBTztBQUNYLGdCQUFJLE9BQU87QUFDWCxnQkFBSSxPQUFPO0FBQ1gsZ0JBQUkscUJBQXFCLEtBQUssb0JBQW9CLDBCQUEwQixnQkFBZ0IsY0FBYyxZQUFZLFlBQVksZ0JBQWdCLGlCQUFpQjtBQUNuSyxnQkFBSSxPQUFPLG1CQUFtQjtBQUM5QixtQkFBTyxJQUFJO0FBQUE7QUFBQTtBQUduQix3QkFBZ0IsY0FBYyxJQUFJLElBQUk7QUFDdEMsd0JBQWdCLGtCQUFrQjtBQUVsQyxzQ0FBOEIsWUFBWTtBQUFBLFVBQ3RDLFlBQVksYUFBYTtBQUNyQixrQkFBTTtBQUFBO0FBQUEsVUFFVixtQkFBbUI7QUFDZixnQkFBSSxLQUFLLGlCQUFpQixZQUFZLGdCQUFnQixjQUFjLFlBQVksV0FBVztBQUN2RixvQkFBTSxJQUFJO0FBQUE7QUFFZCxnQkFBSSxNQUFNLElBQUk7QUFDZCxpQkFBSyxxQkFBcUIsS0FBSyxnQkFBZ0I7QUFDL0MsZ0JBQUksY0FBYyxLQUFLLG9CQUFvQixnQ0FBZ0MsZ0JBQWdCLGNBQWMsWUFBWSxXQUFXLGdCQUFnQjtBQUNoSixnQkFBSSxPQUFPO0FBQ1gsZ0JBQUksT0FBTztBQUNYLGdCQUFJLE9BQU87QUFDWCxnQkFBSSxtQkFBbUIsS0FBSyxvQkFBb0IsZ0NBQWdDLGdCQUFnQixjQUFjLFlBQVksWUFBWSxnQkFBZ0IsaUJBQWlCLGdCQUFnQjtBQUN2TCxnQkFBSSxtQkFBbUIsT0FBTyxHQUFHO0FBQzdCLGtCQUFJLE9BQU87QUFBQTtBQUVmLGdCQUFJLG1CQUFtQixNQUFNLEdBQUc7QUFDNUIsa0JBQUksT0FBTztBQUFBO0FBRWYsZ0JBQUksT0FBTztBQUNYLGdCQUFJLHFCQUFxQixLQUFLLG9CQUFvQiwwQkFBMEIsZ0JBQWdCLGNBQWMsWUFBWSxZQUFZLGdCQUFnQixrQkFBa0IsZ0JBQWdCLHlCQUF5QjtBQUM3TSxnQkFBSSxPQUFPLG1CQUFtQjtBQUM5QixtQkFBTyxJQUFJO0FBQUE7QUFBQTtBQUduQix3QkFBZ0IsY0FBYyxJQUFJLElBQUk7QUFDdEMsd0JBQWdCLGtCQUFrQjtBQUNsQyx3QkFBZ0IsMEJBQTBCO0FBRTFDLHdDQUFnQyxrQkFBa0I7QUFBQSxVQUM5QyxZQUFZLGFBQWEsZUFBZSxVQUFVO0FBQzlDLGtCQUFNO0FBQ04saUJBQUssV0FBVztBQUNoQixpQkFBSyxnQkFBZ0I7QUFBQTtBQUFBLFVBRXpCLG1CQUFtQjtBQUNmLGdCQUFJLEtBQUssaUJBQWlCLGFBQWEsa0JBQWtCLGNBQWMsa0JBQWtCLFlBQVksa0JBQWtCLGNBQWMsa0JBQWtCLFdBQVc7QUFDOUosb0JBQU0sSUFBSTtBQUFBO0FBRWQsZ0JBQUksTUFBTSxJQUFJO0FBQ2QsaUJBQUsscUJBQXFCLEtBQUssa0JBQWtCO0FBQ2pELGlCQUFLLHVCQUF1QixLQUFLLGtCQUFrQixjQUFjLGtCQUFrQixXQUFXLGtCQUFrQjtBQUNoSCxpQkFBSyxxQkFBcUIsS0FBSyxrQkFBa0IsY0FBYyxrQkFBa0IsWUFBWSxrQkFBa0I7QUFDL0csbUJBQU8sSUFBSTtBQUFBO0FBQUEsVUFFZixxQkFBcUIsS0FBSyxZQUFZO0FBQ2xDLGdCQUFJLGNBQWMsS0FBSyxvQkFBb0IsZ0NBQWdDLFlBQVksa0JBQWtCO0FBQ3pHLGdCQUFJLGVBQWUsT0FBTztBQUN0QjtBQUFBO0FBRUosZ0JBQUksT0FBTztBQUNYLGdCQUFJLE9BQU8sS0FBSztBQUNoQixnQkFBSSxPQUFPO0FBQ1gsZ0JBQUksTUFBTSxjQUFjO0FBQ3hCLDJCQUFlO0FBQ2YsZ0JBQUksUUFBUSxjQUFjLEtBQUs7QUFDL0IsMkJBQWU7QUFDZixnQkFBSSxPQUFPO0FBQ1gsZ0JBQUksT0FBTyxNQUFNLEdBQUc7QUFDaEIsa0JBQUksT0FBTztBQUFBO0FBRWYsZ0JBQUksT0FBTztBQUNYLGdCQUFJLFFBQVEsTUFBTSxHQUFHO0FBQ2pCLGtCQUFJLE9BQU87QUFBQTtBQUVmLGdCQUFJLE9BQU87QUFDWCxnQkFBSSxNQUFNLE1BQU0sR0FBRztBQUNmLGtCQUFJLE9BQU87QUFBQTtBQUVmLGdCQUFJLE9BQU87QUFBQTtBQUFBLFVBRWYsY0FBYyxLQUFLLFFBQVE7QUFDdkIsZ0JBQUksT0FBTztBQUNYLGdCQUFJLE9BQU8sS0FBSztBQUNoQixnQkFBSSxPQUFPLFNBQVM7QUFDcEIsZ0JBQUksT0FBTztBQUFBO0FBQUEsVUFFZixZQUFZLFFBQVE7QUFDaEIsbUJBQU8sU0FBUztBQUFBO0FBQUE7QUFHeEIsMEJBQWtCLGNBQWMsSUFBSTtBQUNwQywwQkFBa0IsY0FBYztBQUNoQywwQkFBa0IsWUFBWTtBQUU5QiwrQkFBdUIsYUFBYTtBQUNoQyxjQUFJO0FBQ0EsZ0JBQUksWUFBWSxJQUFJLElBQUk7QUFDcEIscUJBQU8sSUFBSSxnQkFBZ0I7QUFBQTtBQUUvQixnQkFBSSxDQUFDLFlBQVksSUFBSSxJQUFJO0FBQ3JCLHFCQUFPLElBQUksYUFBYTtBQUFBO0FBRTVCLGdCQUFJLDBCQUEwQixvQkFBb0IsZ0NBQWdDLGFBQWEsR0FBRztBQUNsRyxvQkFBUTtBQUFBLG1CQUNDO0FBQUcsdUJBQU8sSUFBSSxnQkFBZ0I7QUFBQSxtQkFDOUI7QUFBRyx1QkFBTyxJQUFJLGdCQUFnQjtBQUFBO0FBRXZDLGdCQUFJLDBCQUEwQixvQkFBb0IsZ0NBQWdDLGFBQWEsR0FBRztBQUNsRyxvQkFBUTtBQUFBLG1CQUNDO0FBQUksdUJBQU8sSUFBSSxnQkFBZ0I7QUFBQSxtQkFDL0I7QUFBSSx1QkFBTyxJQUFJLGdCQUFnQjtBQUFBO0FBRXhDLGdCQUFJLDJCQUEyQixvQkFBb0IsZ0NBQWdDLGFBQWEsR0FBRztBQUNuRyxvQkFBUTtBQUFBLG1CQUNDO0FBQUksdUJBQU8sSUFBSSxrQkFBa0IsYUFBYSxPQUFPO0FBQUEsbUJBQ3JEO0FBQUksdUJBQU8sSUFBSSxrQkFBa0IsYUFBYSxPQUFPO0FBQUEsbUJBQ3JEO0FBQUksdUJBQU8sSUFBSSxrQkFBa0IsYUFBYSxPQUFPO0FBQUEsbUJBQ3JEO0FBQUksdUJBQU8sSUFBSSxrQkFBa0IsYUFBYSxPQUFPO0FBQUEsbUJBQ3JEO0FBQUksdUJBQU8sSUFBSSxrQkFBa0IsYUFBYSxPQUFPO0FBQUEsbUJBQ3JEO0FBQUksdUJBQU8sSUFBSSxrQkFBa0IsYUFBYSxPQUFPO0FBQUEsbUJBQ3JEO0FBQUksdUJBQU8sSUFBSSxrQkFBa0IsYUFBYSxPQUFPO0FBQUEsbUJBQ3JEO0FBQUksdUJBQU8sSUFBSSxrQkFBa0IsYUFBYSxPQUFPO0FBQUE7QUFBQSxtQkFHM0QsR0FBUDtBQUNJLG9CQUFRLElBQUk7QUFDWixrQkFBTSxJQUFJLHNCQUFzQixzQkFBc0I7QUFBQTtBQUFBO0FBSTlELDJCQUFtQjtBQUFBLFVBQ2YsWUFBWSxVQUFVLFdBQVcsY0FBYyxXQUFXO0FBQ3RELGlCQUFLLFdBQVc7QUFDaEIsaUJBQUssWUFBWTtBQUNqQixpQkFBSyxnQkFBZ0I7QUFDckIsaUJBQUssWUFBWTtBQUFBO0FBQUEsVUFFckIsWUFBWTtBQUNSLG1CQUFPLEtBQUs7QUFBQTtBQUFBLFVBRWhCLGNBQWM7QUFDVixtQkFBTyxLQUFLO0FBQUE7QUFBQSxVQUVoQixlQUFlO0FBQ1gsbUJBQU8sS0FBSztBQUFBO0FBQUEsVUFFaEIsbUJBQW1CO0FBQ2YsbUJBQU8sS0FBSztBQUFBO0FBQUEsVUFFaEIsYUFBYTtBQUNULG1CQUFPLEtBQUssYUFBYTtBQUFBO0FBQUEsVUFFN0IsV0FBVztBQUNQLG1CQUFPLE9BQU8sS0FBSyxXQUFXLE9BQU8sS0FBSyxZQUFZLFFBQVMsTUFBSyxpQkFBaUIsT0FBTyxTQUFTLEtBQUssY0FBYyxjQUFjO0FBQUE7QUFBQSxpQkFFbkksT0FBTyxJQUFJLElBQUk7QUFDbEIsZ0JBQUksQ0FBRSxlQUFjLGVBQWU7QUFDL0IscUJBQU87QUFBQTtBQUVYLG1CQUFPLGFBQWEsYUFBYSxHQUFHLFVBQVUsR0FBRyxhQUM3QyxhQUFhLGFBQWEsR0FBRyxXQUFXLEdBQUcsY0FDM0MsYUFBYSxhQUFhLEdBQUcsZUFBZSxHQUFHO0FBQUE7QUFBQSxpQkFFaEQsYUFBYSxJQUFJLElBQUk7QUFDeEIsbUJBQU8sT0FBTyxPQUFPLE9BQU8sT0FBTyxhQUFhLE9BQU8sSUFBSTtBQUFBO0FBQUEsVUFFL0QsV0FBVztBQUVQLGdCQUFJLFFBQVEsS0FBSyxTQUFTLGFBQWEsS0FBSyxVQUFVLGFBQWEsS0FBSyxjQUFjO0FBQ3RGLG1CQUFPO0FBQUE7QUFBQTtBQUlmLDBCQUFrQjtBQUFBLFVBQ2QsWUFBWSxPQUFPLFdBQVcsYUFBYTtBQUN2QyxpQkFBSyxRQUFRO0FBQ2IsaUJBQUssWUFBWTtBQUNqQixpQkFBSyxjQUFjO0FBQUE7QUFBQSxVQUV2QixXQUFXO0FBQ1AsbUJBQU8sS0FBSztBQUFBO0FBQUEsVUFFaEIsZUFBZTtBQUNYLG1CQUFPLEtBQUs7QUFBQTtBQUFBLFVBRWhCLGFBQWE7QUFDVCxtQkFBTyxLQUFLO0FBQUE7QUFBQSxVQUdoQixhQUFhLFlBQVk7QUFDckIsbUJBQU8sS0FBSyxnQkFBZ0IsTUFBTTtBQUFBO0FBQUEsVUFHdEMsV0FBVztBQUNQLG1CQUFPLE9BQU8sS0FBSyxRQUFRO0FBQUE7QUFBQSxVQU8vQixPQUFPLElBQUksSUFBSTtBQUNYLGdCQUFJLENBQUUsZUFBYyxjQUFjO0FBQzlCLHFCQUFPO0FBQUE7QUFFWCxtQkFBTyxLQUFLLGdCQUFnQixJQUFJLE9BQU8sR0FBRyxnQkFBZ0IsR0FBRztBQUFBO0FBQUEsVUFFakUsZ0JBQWdCLE9BQU8sT0FBTztBQUMxQixnQkFBSSxDQUFDLFNBQVMsQ0FBQztBQUNYO0FBQ0osZ0JBQUk7QUFDSixrQkFBTSxRQUFRLENBQUMsSUFBSSxNQUFNO0FBQ3JCLG9CQUFNLFFBQVEsUUFBTTtBQUNoQixvQkFBSSxHQUFHLGNBQWMsZUFBZSxHQUFHLGNBQWMsY0FBYyxHQUFHLGVBQWUsZUFBZSxHQUFHLGVBQWUsY0FBYyxHQUFHLGtCQUFrQixlQUFlLEdBQUcsa0JBQWtCLFlBQVk7QUFDck0sMkJBQVM7QUFBQTtBQUFBO0FBQUE7QUFJckIsbUJBQU87QUFBQTtBQUFBO0FBU2Ysd0NBQWdDLGtCQUFrQjtBQUFBLFVBQzlDLFlBQVksU0FBUztBQUNqQixrQkFBTSxHQUFHO0FBQ1QsaUJBQUssUUFBUSxJQUFJLE1BQU0sa0JBQWtCO0FBQ3pDLGlCQUFLLE9BQU8sSUFBSTtBQUNoQixpQkFBSyxXQUFXLENBQUM7QUFDakIsaUJBQUssVUFBVyxZQUFZO0FBQUE7QUFBQSxVQUVoQyxVQUFVLFdBQVcsS0FBSyxPQUFPO0FBSTdCLGlCQUFLLE1BQU0sU0FBUztBQUNwQixpQkFBSyxnQkFBZ0I7QUFDckIsZ0JBQUk7QUFDQSxxQkFBTyxrQkFBa0IsZ0JBQWdCLEtBQUssZ0JBQWdCLFdBQVc7QUFBQSxxQkFFdEUsR0FBUDtBQUVJLGtCQUFJLEtBQUssU0FBUztBQUNkLHdCQUFRLElBQUk7QUFBQTtBQUFBO0FBR3BCLGlCQUFLLE1BQU0sU0FBUztBQUNwQixpQkFBSyxnQkFBZ0I7QUFDckIsbUJBQU8sa0JBQWtCLGdCQUFnQixLQUFLLGdCQUFnQixXQUFXO0FBQUE7QUFBQSxVQUU3RSxRQUFRO0FBQ0osaUJBQUssTUFBTSxTQUFTO0FBQ3BCLGlCQUFLLEtBQUssU0FBUztBQUFBO0FBQUEsVUFHdkIsZ0JBQWdCLFdBQVcsS0FBSztBQUM1QixnQkFBSSxPQUFPO0FBQ1gsbUJBQU8sQ0FBQyxNQUFNO0FBQ1Ysa0JBQUk7QUFDQSxxQkFBSyxNQUFNLEtBQUssS0FBSyxpQkFBaUIsS0FBSyxLQUFLLE9BQU87QUFBQSx1QkFFcEQsUUFBUDtBQUNJLG9CQUFJLGtCQUFpQixtQkFBbUI7QUFDcEMsc0JBQUksQ0FBQyxLQUFLLE1BQU0sUUFBUTtBQUNwQiwwQkFBTSxJQUFJO0FBQUE7QUFHZCx5QkFBTztBQUFBO0FBQUE7QUFBQTtBQUtuQixnQkFBSSxLQUFLLGlCQUFpQjtBQUN0QixxQkFBTyxLQUFLO0FBQUE7QUFFaEIsZ0JBQUk7QUFDSixnQkFBSSxLQUFLLEtBQUssUUFBUTtBQUNsQixpQ0FBbUI7QUFBQSxtQkFFbEI7QUFDRCxpQ0FBbUI7QUFBQTtBQUd2QixpQkFBSyxTQUFTLFdBQVc7QUFDekIsZ0JBQUksa0JBQWtCO0FBR2xCLGtCQUFJLEtBQUssS0FBSyxpQkFBaUI7QUFDL0Isa0JBQUksTUFBTSxNQUFNO0FBQ1osdUJBQU87QUFBQTtBQUVYLG1CQUFLLEtBQUssaUJBQWlCO0FBQzNCLGtCQUFJLE1BQU0sTUFBTTtBQUNaLHVCQUFPO0FBQUE7QUFBQTtBQUdmLGtCQUFNLElBQUk7QUFBQTtBQUFBLFVBR2QsaUJBQWlCLFNBQVM7QUFJdEIsZ0JBQUksS0FBSyxLQUFLLFNBQVMsSUFBSTtBQUN2QixtQkFBSyxLQUFLLFNBQVM7QUFDbkIscUJBQU87QUFBQTtBQUVYLGlCQUFLLE1BQU0sU0FBUztBQUNwQixnQkFBSSxTQUFTO0FBQ1QsbUJBQUssT0FBTyxLQUFLLEtBQUs7QUFBQTtBQUcxQixnQkFBSSxLQUFLO0FBQ1QsZ0JBQUk7QUFDQSxtQkFBSyxLQUFLLFVBQVUsSUFBSSxTQUFTO0FBQUEscUJBRTlCLEdBQVA7QUFFSSxrQkFBSSxLQUFLLFNBQVM7QUFDZCx3QkFBUSxJQUFJO0FBQUE7QUFBQTtBQUdwQixnQkFBSSxTQUFTO0FBQ1QsbUJBQUssT0FBTyxLQUFLLEtBQUs7QUFBQTtBQUcxQixtQkFBTztBQUFBO0FBQUEsVUFJWCxVQUFVLGVBQWUsWUFBWTtBQUNqQyxxQkFBUyxJQUFJLFlBQVksSUFBSSxLQUFLLEtBQUssUUFBUSxLQUFLO0FBQ2hELGtCQUFJLE1BQU0sS0FBSyxLQUFLO0FBQ3BCLG1CQUFLLE1BQU0sU0FBUztBQUNwQix1QkFBUyxnQkFBZ0IsZUFBZTtBQUNwQyxxQkFBSyxNQUFNLEtBQUssYUFBYTtBQUFBO0FBRWpDLG1CQUFLLE1BQU0sS0FBSyxJQUFJO0FBQ3BCLGtCQUFJLENBQUMsa0JBQWtCLGdCQUFnQixLQUFLLFFBQVE7QUFDaEQ7QUFBQTtBQUVKLGtCQUFJLEtBQUssaUJBQWlCO0FBQ3RCLHVCQUFPLEtBQUs7QUFBQTtBQUVoQixrQkFBSSxLQUFLLElBQUksTUFBTTtBQUNuQixpQkFBRyxLQUFLO0FBQ1Isa0JBQUk7QUFFQSx1QkFBTyxLQUFLLFVBQVUsSUFBSSxJQUFJO0FBQUEsdUJBRTNCLEdBQVA7QUFFSSxvQkFBSSxLQUFLLFNBQVM7QUFDZCwwQkFBUSxJQUFJO0FBQUE7QUFBQTtBQUFBO0FBSXhCLGtCQUFNLElBQUk7QUFBQTtBQUFBLGlCQUlQLGdCQUFnQixPQUFPO0FBQzFCLHFCQUFTLFlBQVksa0JBQWtCLDBCQUEwQjtBQUM3RCxrQkFBSSxNQUFNLFNBQVMsU0FBUyxRQUFRO0FBQ2hDO0FBQUE7QUFFSixrQkFBSSxRQUFPO0FBQ1gsdUJBQVMsSUFBSSxHQUFHLElBQUksTUFBTSxRQUFRLEtBQUs7QUFDbkMsb0JBQUksTUFBTSxHQUFHLG1CQUFtQixjQUFjLFNBQVMsSUFBSTtBQUN2RCwwQkFBTztBQUNQO0FBQUE7QUFBQTtBQUdSLGtCQUFJLE9BQU07QUFDTix1QkFBTztBQUFBO0FBQUE7QUFHZixtQkFBTztBQUFBO0FBQUEsVUFFWCxTQUFTLFdBQVcsYUFBYTtBQUU3QixnQkFBSSxZQUFZO0FBQ2hCLGdCQUFJLGFBQWE7QUFDakIsZ0JBQUksYUFBYTtBQUNqQixtQkFBTyxZQUFZLEtBQUssS0FBSyxRQUFRO0FBQ2pDLGtCQUFJLE9BQU8sS0FBSyxLQUFLO0FBQ3JCLGtCQUFJLEtBQUssaUJBQWlCLFdBQVc7QUFDakMsNkJBQWEsS0FBSyxhQUFhLEtBQUs7QUFDcEM7QUFBQTtBQUVKLDJCQUFhLEtBQUssYUFBYSxLQUFLO0FBQ3BDO0FBQUE7QUFFSixnQkFBSSxjQUFjLFlBQVk7QUFDMUI7QUFBQTtBQU1KLGdCQUFJLGtCQUFrQixhQUFhLEtBQUssT0FBTyxLQUFLLE9BQU87QUFDdkQ7QUFBQTtBQUVKLGlCQUFLLEtBQUssS0FBSyxXQUFXLElBQUksWUFBWSxLQUFLLE9BQU8sV0FBVztBQUNqRSxpQkFBSyxrQkFBa0IsS0FBSyxPQUFPLEtBQUs7QUFBQTtBQUFBLFVBRzVDLGtCQUFrQixPQUFPLE1BQU07QUF5QjNCLHFCQUFTLE9BQU8sTUFBTTtBQUNsQixrQkFBSSxJQUFJLFdBQVcsV0FBVyxNQUFNLFFBQVE7QUFDeEM7QUFBQTtBQUVKLHVCQUFTLEtBQUssSUFBSSxZQUFZO0FBQzFCLHlCQUFTLE1BQU0sT0FBTztBQUNsQixzQkFBSSxhQUFhLE9BQU8sR0FBRyxLQUFLO0FBQzVCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLGlCQU9iLGFBQWEsT0FBTyxNQUFNO0FBQzdCLHFCQUFTLEtBQUssTUFBTTtBQUNoQixrQkFBSSxXQUFXO0FBQ2YsdUJBQVMsS0FBSyxPQUFPO0FBQ2pCLG9CQUFJLFFBQVE7QUFDWix5QkFBUyxNQUFNLEVBQUUsWUFBWTtBQUN6QixzQkFBSSxFQUFFLE9BQU8sS0FBSztBQUNkLDRCQUFRO0FBQ1I7QUFBQTtBQUFBO0FBR1Isb0JBQUksQ0FBQyxPQUFPO0FBQ1IsNkJBQVc7QUFDWDtBQUFBO0FBQUE7QUFHUixrQkFBSSxVQUFVO0FBRVYsdUJBQU87QUFBQTtBQUFBO0FBR2YsbUJBQU87QUFBQTtBQUFBLFVBR1gsVUFBVTtBQUNOLG1CQUFPLEtBQUs7QUFBQTtBQUFBLGlCQUdULGdCQUFnQixPQUFPO0FBQzFCLGdCQUFJLFNBQVMsZ0JBQWdCLGNBQWM7QUFDM0MsZ0JBQUksVUFBVSxjQUFjO0FBQzVCLGdCQUFJLGtCQUFrQixRQUFRO0FBQzlCLGdCQUFJLGNBQWMsTUFBTSxHQUFHLG1CQUFtQjtBQUM5QyxnQkFBSSxhQUFhLE1BQU0sTUFBTSxTQUFTLEdBQUcsbUJBQW1CO0FBQzVELGdCQUFJLFNBQVMsQ0FBQyxZQUFZLElBQUksWUFBWSxJQUFJLFdBQVcsSUFBSSxXQUFXO0FBQ3hFLG1CQUFPLElBQUksT0FBTyxpQkFBaUIsTUFBTSxNQUFNLFFBQVEsZ0JBQWdCLGNBQWM7QUFBQTtBQUFBLFVBRXpGLGdCQUFnQjtBQUNaLGdCQUFJLFlBQVksS0FBSyxNQUFNLElBQUk7QUFDL0IsZ0JBQUksaUJBQWlCLFVBQVU7QUFDL0IsZ0JBQUksaUJBQWlCLFVBQVU7QUFDL0IsZ0JBQUksa0JBQWtCLE1BQU07QUFDeEIscUJBQU87QUFBQTtBQUVYLGdCQUFJLFdBQVcsZUFBZTtBQUM5QixnQkFBSSxJQUFJO0FBQ1IscUJBQVMsSUFBSSxHQUFHLElBQUksS0FBSyxNQUFNLFFBQVEsRUFBRSxHQUFHO0FBQ3hDLGtCQUFJLGNBQWMsS0FBSyxNQUFNLElBQUk7QUFDakMsMEJBQVksWUFBWSxjQUFjO0FBQ3RDO0FBQ0Esa0JBQUksbUJBQW1CLFlBQVk7QUFDbkMsa0JBQUksb0JBQW9CLE1BQU07QUFDMUIsNEJBQVksaUJBQWlCO0FBQzdCO0FBQUE7QUFBQTtBQUdSLHdCQUFZO0FBQ1osZ0JBQUksc0JBQXNCLE1BQU8sS0FBSSxLQUFLO0FBQzFDLG1CQUFPLHVCQUF1QixlQUFlO0FBQUE7QUFBQSxpQkFFMUMsaUJBQWlCLEtBQUssWUFBWTtBQUNyQyxnQkFBSTtBQUNKLGdCQUFJLElBQUksSUFBSSxhQUFhO0FBQ3JCLDJCQUFhLElBQUksYUFBYTtBQUM5QiwyQkFBYSxJQUFJLFdBQVc7QUFBQSxtQkFFM0I7QUFDRCwyQkFBYSxJQUFJLFdBQVc7QUFDNUIsMkJBQWEsSUFBSSxhQUFhO0FBQUE7QUFFbEMsbUJBQU87QUFBQTtBQUFBLFVBR1gsaUJBQWlCLEtBQUssZUFBZSxXQUFXO0FBQzVDLGdCQUFJLGVBQWUsY0FBYyxTQUFTLEtBQUs7QUFDL0MsZ0JBQUksS0FBSyxlQUFlO0FBQ3BCLDZCQUFlLENBQUM7QUFBQTtBQUVwQixnQkFBSTtBQUNKLGdCQUFJLGNBQWM7QUFDbEIsZ0JBQUksZUFBZTtBQUNuQixlQUFHO0FBQ0MsbUJBQUssYUFBYSxLQUFLLGVBQWU7QUFDdEMsd0JBQVUsS0FBSyx3QkFBd0IsS0FBSyxXQUFXO0FBQ3ZELGtCQUFJLFdBQVcsTUFBTTtBQUNqQiwrQkFBZSxrQkFBa0IsaUJBQWlCLEtBQUssS0FBSyxTQUFTO0FBQUEscUJBRXBFO0FBQ0QsOEJBQWM7QUFBQTtBQUFBLHFCQUViO0FBR1QsZ0JBQUksV0FBVyxLQUFLLG9CQUFvQixLQUFLLFNBQVMsY0FBYztBQUNwRSxnQkFBSSxDQUFDLEtBQUssWUFBWSxrQkFBa0IsY0FBYyxjQUFjLFNBQVMsR0FBRyxjQUFjO0FBQzFGLG9CQUFNLElBQUk7QUFBQTtBQUVkLGdCQUFJO0FBQ0osZ0JBQUk7QUFDQSwwQkFBWSxLQUFLLG9CQUFvQixLQUFLLFNBQVMsY0FBYztBQUFBLHFCQUU5RCxHQUFQO0FBQ0ksMEJBQVk7QUFDWixrQkFBSSxLQUFLLFNBQVM7QUFDZCx3QkFBUSxJQUFJO0FBQUE7QUFBQTtBQUdwQixtQkFBTyxJQUFJLGFBQWEsVUFBVSxXQUFXLFNBQVM7QUFBQTtBQUFBLFVBRTFELFlBQVksT0FBTztBQUNmLGdCQUFJLE1BQU0sV0FBVyxHQUFHO0FBQ3BCLHFCQUFPO0FBQUE7QUFFWCxtQkFBTztBQUFBO0FBQUEsVUFFWCxhQUFhLEtBQUssZUFBZSxjQUFjO0FBQzNDLGdCQUFJLFdBQVcsS0FBSztBQUNwQixxQkFBUyxLQUFLO0FBQ2QscUJBQVMsS0FBSztBQUNkLHFCQUFTLEtBQUs7QUFDZCxxQkFBUyxLQUFLO0FBQ2QsZ0JBQUksUUFBUSxJQUFJO0FBQ2hCLGdCQUFJO0FBQ0osZ0JBQUksZ0JBQWdCLEdBQUc7QUFDbkIsMEJBQVk7QUFBQSx1QkFFUCxLQUFLLFlBQVksZ0JBQWdCO0FBQ3RDLDBCQUFZO0FBQUEsbUJBRVg7QUFDRCxrQkFBSSxXQUFXLGNBQWMsY0FBYyxTQUFTO0FBQ3BELDBCQUFZLFNBQVMsbUJBQW1CLGNBQWM7QUFBQTtBQUUxRCxnQkFBSSxvQkFBb0IsY0FBYyxTQUFTLEtBQUs7QUFDcEQsZ0JBQUksS0FBSyxlQUFlO0FBQ3BCLGtDQUFvQixDQUFDO0FBQUE7QUFFekIsZ0JBQUksVUFBVTtBQUNkLG1CQUFPLFlBQVksT0FBTztBQUN0Qix3QkFBVSxDQUFDLElBQUksSUFBSTtBQUNuQixrQkFBSSxDQUFDLFNBQVM7QUFDVjtBQUFBO0FBRUo7QUFBQTtBQUVKLGdCQUFJLGtCQUFrQjtBQUN0QixnQkFBSSxlQUFlO0FBQ25CLHFCQUFTLElBQUksV0FBVyxJQUFJLE9BQU8sS0FBSztBQUNwQyxrQkFBSSxJQUFJLElBQUksTUFBTSxTQUFTO0FBQ3ZCLHlCQUFTO0FBQUEscUJBRVI7QUFDRCxvQkFBSSxtQkFBbUIsR0FBRztBQUN0QixzQkFBSSxtQkFBbUI7QUFDbkIsc0NBQWtCLGdCQUFnQjtBQUFBO0FBRXRDLHNCQUFJLGtCQUFrQixnQkFBZ0IsV0FBVztBQUM3Qyx5QkFBSyxTQUFTLEtBQUs7QUFDbkIseUJBQUssU0FBUyxLQUFLO0FBQ25CO0FBQUE7QUFFSixzQkFBSSxtQkFBbUI7QUFDbkIsc0NBQWtCLGdCQUFnQjtBQUFBO0FBRXRDLGtDQUFnQixTQUFTLEtBQUssU0FBUztBQUN2QywyQkFBUyxLQUFLLFNBQVM7QUFDdkIsMkJBQVMsS0FBSyxTQUFTO0FBQ3ZCLDJCQUFTLEtBQUs7QUFDZCwyQkFBUyxLQUFLO0FBQ2Q7QUFBQSx1QkFFQztBQUNEO0FBQUE7QUFFSix5QkFBUyxtQkFBbUI7QUFDNUIsMEJBQVUsQ0FBQztBQUFBO0FBQUE7QUFHbkIsa0JBQU0sSUFBSTtBQUFBO0FBQUEsaUJBRVAsZ0JBQWdCLFVBQVU7QUFDN0IsZ0JBQUksU0FBUyxTQUFTO0FBQ3RCLHFCQUFTLElBQUksR0FBRyxJQUFJLFNBQVMsR0FBRyxFQUFFLEdBQUc7QUFDakMsa0JBQUksTUFBTSxTQUFTO0FBQ25CLHVCQUFTLEtBQUssU0FBUyxTQUFTLElBQUk7QUFDcEMsdUJBQVMsU0FBUyxJQUFJLEtBQUs7QUFBQTtBQUFBO0FBQUEsVUFHbkMsd0JBQXdCLEtBQUssV0FBVyxZQUFZO0FBRWhELGdCQUFJO0FBQ0osZ0JBQUk7QUFDSixnQkFBSTtBQUNKLGdCQUFJLFlBQVk7QUFFWixrQkFBSSxvQkFBb0IsS0FBSyxTQUFTLEtBQUs7QUFFM0MscUJBQU8scUJBQXFCLEtBQUssQ0FBQyxJQUFJLElBQUksb0JBQW9CO0FBQzFEO0FBQUE7QUFFSjtBQUNBLDZCQUFlLEtBQUssU0FBUyxLQUFLO0FBQ2xDLHVCQUFRO0FBQ1Isb0JBQU0sS0FBSyxTQUFTO0FBQUEsbUJBRW5CO0FBRUQsdUJBQVEsS0FBSyxTQUFTO0FBQ3RCLG9CQUFNLElBQUksYUFBYSxLQUFLLFNBQVMsS0FBSztBQUMxQyw2QkFBZSxNQUFNLEtBQUssU0FBUztBQUFBO0FBR3ZDLGdCQUFJLFdBQVcsS0FBSztBQUNwQixtQkFBTyxVQUFVLFVBQVUsR0FBRyxVQUFVLEdBQUcsU0FBUyxTQUFTO0FBQzdELHFCQUFTLEtBQUs7QUFDZCxnQkFBSTtBQUNKLGdCQUFJO0FBQ0Esc0JBQVEsS0FBSyxpQkFBaUIsVUFBVSxrQkFBa0I7QUFBQSxxQkFFdkQsR0FBUDtBQUNJLHFCQUFPO0FBQUE7QUFHWCxtQkFBTyxJQUFJLGNBQWMsT0FBTyxDQUFDLFFBQU8sTUFBTSxRQUFPLEtBQUs7QUFBQTtBQUFBLFVBRTlELG9CQUFvQixLQUFLLFNBQVMsY0FBYyxVQUFVO0FBQ3RELGdCQUFJLFdBQVcsS0FBSztBQUNwQixxQkFBUyxJQUFJLEdBQUcsSUFBSSxTQUFTLFFBQVEsS0FBSztBQUN0Qyx1QkFBUyxLQUFLO0FBQUE7QUFFbEIsZ0JBQUksVUFBVTtBQUNWLGdDQUFrQix1QkFBdUIsS0FBSyxRQUFRLGNBQWMsSUFBSTtBQUFBLG1CQUV2RTtBQUNELGdDQUFrQixjQUFjLEtBQUssUUFBUSxjQUFjLElBQUk7QUFFL0QsdUJBQVMsSUFBSSxHQUFHLElBQUksU0FBUyxTQUFTLEdBQUcsSUFBSSxHQUFHLEtBQUssS0FBSztBQUN0RCxvQkFBSSxPQUFPLFNBQVM7QUFDcEIseUJBQVMsS0FBSyxTQUFTO0FBQ3ZCLHlCQUFTLEtBQUs7QUFBQTtBQUFBO0FBR3RCLGdCQUFJLGFBQWE7QUFDakIsZ0JBQUksZUFBZSxVQUFVLElBQUksSUFBSSxXQUFXLGFBQWE7QUFFN0QsZ0JBQUksdUJBQXdCLFNBQVEsY0FBYyxLQUFLLFFBQVEsY0FBYyxNQUFNO0FBQ25GLGdCQUFJLEtBQUssSUFBSSxlQUFlLHdCQUF3Qix1QkFBdUIsS0FBSztBQUM1RSxvQkFBTSxJQUFJO0FBQUE7QUFFZCxnQkFBSSxZQUFZLEtBQUs7QUFDckIsZ0JBQUksYUFBYSxLQUFLO0FBQ3RCLGdCQUFJLG9CQUFvQixLQUFLO0FBQzdCLGdCQUFJLHFCQUFxQixLQUFLO0FBQzlCLHFCQUFTLElBQUksR0FBRyxJQUFJLFNBQVMsUUFBUSxLQUFLO0FBQ3RDLGtCQUFJLFNBQVEsSUFBTSxTQUFTLEtBQUs7QUFDaEMsa0JBQUksUUFBUSxTQUFRO0FBQ3BCLGtCQUFJLFFBQVEsR0FBRztBQUNYLG9CQUFJLFNBQVEsS0FBSztBQUNiLHdCQUFNLElBQUk7QUFBQTtBQUVkLHdCQUFRO0FBQUEseUJBRUgsUUFBUSxHQUFHO0FBQ2hCLG9CQUFJLFNBQVEsS0FBSztBQUNiLHdCQUFNLElBQUk7QUFBQTtBQUVkLHdCQUFRO0FBQUE7QUFFWixrQkFBSSxTQUFTLElBQUk7QUFDakIsa0JBQUssS0FBSSxNQUFTLEdBQUc7QUFDakIsMEJBQVUsVUFBVTtBQUNwQixrQ0FBa0IsVUFBVSxTQUFRO0FBQUEscUJBRW5DO0FBQ0QsMkJBQVcsVUFBVTtBQUNyQixtQ0FBbUIsVUFBVSxTQUFRO0FBQUE7QUFBQTtBQUc3QyxpQkFBSyxvQkFBb0I7QUFDekIsZ0JBQUksa0JBQWtCLElBQUksUUFBUSxhQUFjLGdCQUFlLElBQUksS0FBTSxZQUFXLElBQUksS0FBSztBQUM3RixnQkFBSSxTQUFTO0FBQ2IsZ0JBQUkscUJBQXFCO0FBQ3pCLHFCQUFTLElBQUksVUFBVSxTQUFTLEdBQUcsS0FBSyxHQUFHLEtBQUs7QUFDNUMsa0JBQUksa0JBQWtCLFlBQVksU0FBUyxjQUFjLFdBQVc7QUFDaEUsb0JBQUksU0FBUyxrQkFBa0IsUUFBUSxpQkFBaUIsSUFBSTtBQUM1RCxzQ0FBc0IsVUFBVSxLQUFLO0FBQUE7QUFFekMsd0JBQVUsVUFBVTtBQUFBO0FBRXhCLGdCQUFJLHNCQUFzQjtBQUUxQixxQkFBUyxJQUFJLFdBQVcsU0FBUyxHQUFHLEtBQUssR0FBRyxLQUFLO0FBQzdDLGtCQUFJLGtCQUFrQixZQUFZLFNBQVMsY0FBYyxXQUFXO0FBQ2hFLG9CQUFJLFNBQVMsa0JBQWtCLFFBQVEsaUJBQWlCLElBQUksSUFBSTtBQUNoRSx1Q0FBdUIsV0FBVyxLQUFLO0FBQUE7QUFBQTtBQUkvQyxnQkFBSSxrQkFBa0IscUJBQXFCO0FBQzNDLGdCQUFLLFVBQVMsTUFBUyxLQUFLLFNBQVMsTUFBTSxTQUFTLEdBQUc7QUFDbkQsb0JBQU0sSUFBSTtBQUFBO0FBRWQsZ0JBQUksUUFBUyxNQUFLLFVBQVU7QUFDNUIsZ0JBQUksWUFBWSxrQkFBa0IsY0FBYztBQUNoRCxnQkFBSSxhQUFhLElBQUk7QUFDckIsZ0JBQUksT0FBTyxTQUFTLFlBQVksV0FBVyxXQUFXO0FBQ3RELGdCQUFJLFFBQVEsU0FBUyxZQUFZLFlBQVksWUFBWTtBQUN6RCxnQkFBSSxRQUFRLGtCQUFrQixrQkFBa0I7QUFDaEQsZ0JBQUksT0FBTyxrQkFBa0IsS0FBSztBQUNsQyxnQkFBSSxRQUFRLE9BQU8sUUFBUSxRQUFRO0FBQ25DLG1CQUFPLElBQUksY0FBYyxPQUFPO0FBQUE7QUFBQSxpQkFFN0IsWUFBWSxTQUFTLGNBQWMsVUFBVTtBQUVoRCxtQkFBTyxDQUFFLFNBQVEsY0FBYyxLQUFLLGdCQUFnQjtBQUFBO0FBQUEsVUFFeEQsb0JBQW9CLFlBQVk7QUFDNUIsZ0JBQUksU0FBUyxVQUFVLElBQUksSUFBSSxXQUFXLEtBQUs7QUFDL0MsZ0JBQUksVUFBVSxVQUFVLElBQUksSUFBSSxXQUFXLEtBQUs7QUFDaEQsZ0JBQUksZUFBZTtBQUNuQixnQkFBSSxlQUFlO0FBQ25CLGdCQUFJLFNBQVMsSUFBSTtBQUNiLDZCQUFlO0FBQUEsdUJBRVYsU0FBUyxHQUFHO0FBQ2pCLDZCQUFlO0FBQUE7QUFFbkIsZ0JBQUksZ0JBQWdCO0FBQ3BCLGdCQUFJLGdCQUFnQjtBQUNwQixnQkFBSSxVQUFVLElBQUk7QUFDZCw4QkFBZ0I7QUFBQSx1QkFFWCxVQUFVLEdBQUc7QUFDbEIsOEJBQWdCO0FBQUE7QUFFcEIsZ0JBQUksV0FBVyxTQUFTLFVBQVU7QUFDbEMsZ0JBQUksZUFBZ0IsVUFBUyxNQUFTO0FBQ3RDLGdCQUFJLGdCQUFpQixXQUFVLE1BQVM7QUFDeEMsZ0JBQUksWUFBWSxHQUFHO0FBQ2Ysa0JBQUksY0FBYztBQUNkLG9CQUFJLGVBQWU7QUFDZix3QkFBTSxJQUFJO0FBQUE7QUFFZCwrQkFBZTtBQUFBLHFCQUVkO0FBQ0Qsb0JBQUksQ0FBQyxlQUFlO0FBQ2hCLHdCQUFNLElBQUk7QUFBQTtBQUVkLGdDQUFnQjtBQUFBO0FBQUEsdUJBR2YsWUFBWSxJQUFJO0FBQ3JCLGtCQUFJLGNBQWM7QUFDZCxvQkFBSSxlQUFlO0FBQ2Ysd0JBQU0sSUFBSTtBQUFBO0FBRWQsK0JBQWU7QUFBQSxxQkFFZDtBQUNELG9CQUFJLENBQUMsZUFBZTtBQUNoQix3QkFBTSxJQUFJO0FBQUE7QUFFZCxnQ0FBZ0I7QUFBQTtBQUFBLHVCQUdmLFlBQVksR0FBRztBQUNwQixrQkFBSSxjQUFjO0FBQ2Qsb0JBQUksQ0FBQyxlQUFlO0FBQ2hCLHdCQUFNLElBQUk7QUFBQTtBQUdkLG9CQUFJLFNBQVMsU0FBUztBQUNsQixpQ0FBZTtBQUNmLGtDQUFnQjtBQUFBLHVCQUVmO0FBQ0QsaUNBQWU7QUFDZixrQ0FBZ0I7QUFBQTtBQUFBLHFCQUduQjtBQUNELG9CQUFJLGVBQWU7QUFDZix3QkFBTSxJQUFJO0FBQUE7QUFBQTtBQUFBLG1CQUtqQjtBQUNELG9CQUFNLElBQUk7QUFBQTtBQUVkLGdCQUFJLGNBQWM7QUFDZCxrQkFBSSxjQUFjO0FBQ2Qsc0JBQU0sSUFBSTtBQUFBO0FBRWQsZ0NBQWtCLFVBQVUsS0FBSyxnQkFBZ0IsS0FBSztBQUFBO0FBRTFELGdCQUFJLGNBQWM7QUFDZCxnQ0FBa0IsVUFBVSxLQUFLLGdCQUFnQixLQUFLO0FBQUE7QUFFMUQsZ0JBQUksZUFBZTtBQUNmLGtCQUFJLGVBQWU7QUFDZixzQkFBTSxJQUFJO0FBQUE7QUFFZCxnQ0FBa0IsVUFBVSxLQUFLLGlCQUFpQixLQUFLO0FBQUE7QUFFM0QsZ0JBQUksZUFBZTtBQUNmLGdDQUFrQixVQUFVLEtBQUssaUJBQWlCLEtBQUs7QUFBQTtBQUFBO0FBQUE7QUFJbkUsMEJBQWtCLGdCQUFnQixDQUFDLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFDL0MsMEJBQWtCLG9CQUFvQixDQUFDLEdBQUcsSUFBSSxJQUFJLEtBQUs7QUFDdkQsMEJBQWtCLE9BQU8sQ0FBQyxHQUFHLEtBQUssTUFBTSxNQUFNO0FBQzlDLDBCQUFrQixrQkFBa0I7QUFBQSxVQUNoQyxXQUFXLEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRztBQUFBLFVBQzFCLFdBQVcsS0FBSyxDQUFDLEdBQUcsR0FBRyxHQUFHO0FBQUEsVUFDMUIsV0FBVyxLQUFLLENBQUMsR0FBRyxHQUFHLEdBQUc7QUFBQSxVQUMxQixXQUFXLEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRztBQUFBLFVBQzFCLFdBQVcsS0FBSyxDQUFDLEdBQUcsR0FBRyxHQUFHO0FBQUEsVUFDMUIsV0FBVyxLQUFLLENBQUMsR0FBRyxHQUFHLEdBQUc7QUFBQTtBQUU5QiwwQkFBa0IsVUFBVTtBQUFBLFVBQ3hCLENBQUMsR0FBRyxHQUFHLEdBQUcsSUFBSSxJQUFJLElBQUksSUFBSTtBQUFBLFVBQzFCLENBQUMsSUFBSSxJQUFJLEtBQUssS0FBSyxLQUFLLEdBQUcsSUFBSTtBQUFBLFVBQy9CLENBQUMsS0FBSyxLQUFLLElBQUksSUFBSSxLQUFLLEtBQUssS0FBSztBQUFBLFVBQ2xDLENBQUMsS0FBSyxLQUFLLElBQUksS0FBSyxJQUFJLElBQUksS0FBSztBQUFBLFVBQ2pDLENBQUMsSUFBSSxLQUFLLEtBQUssS0FBSyxLQUFLLElBQUksSUFBSTtBQUFBLFVBQ2pDLENBQUMsS0FBSyxLQUFLLEtBQUssS0FBSyxHQUFHLElBQUksSUFBSTtBQUFBLFVBQ2hDLENBQUMsS0FBSyxLQUFLLEtBQUssSUFBSSxJQUFJLElBQUksSUFBSTtBQUFBLFVBQ2hDLENBQUMsS0FBSyxJQUFJLElBQUksSUFBSSxLQUFLLEtBQUssSUFBSTtBQUFBLFVBQ2hDLENBQUMsSUFBSSxLQUFLLEtBQUssS0FBSyxLQUFLLEtBQUssS0FBSztBQUFBLFVBQ25DLENBQUMsSUFBSSxJQUFJLElBQUksS0FBSyxJQUFJLEtBQUssS0FBSztBQUFBLFVBQ2hDLENBQUMsSUFBSSxLQUFLLEtBQUssS0FBSyxLQUFLLEtBQUssS0FBSztBQUFBLFVBQ25DLENBQUMsSUFBSSxJQUFJLEtBQUssSUFBSSxJQUFJLElBQUksSUFBSTtBQUFBLFVBQzlCLENBQUMsS0FBSyxLQUFLLEtBQUssS0FBSyxLQUFLLEtBQUssS0FBSztBQUFBLFVBQ3BDLENBQUMsSUFBSSxLQUFLLEtBQUssS0FBSyxLQUFLLEtBQUssS0FBSztBQUFBLFVBQ25DLENBQUMsS0FBSyxLQUFLLEtBQUssSUFBSSxJQUFJLElBQUksS0FBSztBQUFBLFVBQ2pDLENBQUMsS0FBSyxJQUFJLElBQUksS0FBSyxLQUFLLElBQUksSUFBSTtBQUFBLFVBQ2hDLENBQUMsR0FBRyxJQUFJLElBQUksS0FBSyxJQUFJLEtBQUssS0FBSztBQUFBLFVBQy9CLENBQUMsS0FBSyxLQUFLLElBQUksSUFBSSxJQUFJLElBQUksS0FBSztBQUFBLFVBQ2hDLENB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SUFBSSxJQUFJLElBQUksU0FBUyxJQUFJLElBQUksSUFBSSxHQUFHO0FBQUEsY0FDM0QsSUFBSSxRQUFRLEdBQUcsSUFBSSxJQUFJLElBQUksSUFBSSxJQUFJLFNBQVMsSUFBSSxJQUFJLElBQUksR0FBRztBQUFBLGNBQzNELElBQUksUUFBUSxHQUFHLElBQUksSUFBSSxJQUFJLElBQUksSUFBSSxTQUFTLElBQUksSUFBSSxJQUFJLEdBQUc7QUFBQSxjQUMzRCxJQUFJLFFBQVEsR0FBRyxJQUFJLElBQUksSUFBSSxJQUFJLElBQUksU0FBUyxJQUFJLElBQUksSUFBSSxHQUFHO0FBQUEsY0FDM0QsSUFBSSxRQUFRLElBQUksSUFBSSxJQUFJLElBQUksSUFBSSxJQUFJLFNBQVMsSUFBSSxJQUFJLElBQUksR0FBRztBQUFBLGNBQzVELElBQUksUUFBUSxJQUFJLElBQUksSUFBSSxJQUFJLElBQUksSUFBSSxTQUFTLElBQUksSUFBSSxJQUFJLEdBQUc7QUFBQSxjQUM1RCxJQUFJLFFBQVEsSUFBSSxJQUFJLElBQUksSUFBSSxJQUFJLElBQUksU0FBUyxJQUFJLElBQUksSUFBSSxHQUFHO0FBQUEsY0FDNUQsSUFBSSxRQUFRLElBQUksSUFBSSxJQUFJLElBQUksSUFBSSxJQUFJLFNBQVMsSUFBSSxJQUFJLElBQUksR0FBRztBQUFBLGNBQzVELElBQUksUUFBUSxJQUFJLElBQUksSUFBSSxJQUFJLElBQUksSUFBSSxTQUFTLElBQUksSUFBSSxJQUFJLEdBQUc7QUFBQSxjQUM1RCxJQUFJLFFBQVEsSUFBSSxJQUFJLElBQUksSUFBSSxJQUFJLElBQUksU0FBUyxJQUFJLElBQUksSUFBSSxHQUFHO0FBQUEsY0FDNUQsSUFBSSxRQUFRLElBQUksSUFBSSxJQUFJLElBQUksSUFBSSxJQUFJLFNBQVMsSUFBSSxJQUFJLElBQUksR0FBRztBQUFBLGNBQzVELElBQUksUUFBUSxJQUFJLElBQUksSUFBSSxJQUFJLElBQUksSUFBSSxTQUFTLElBQUksSUFBSSxJQUFJLEdBQUc7QUFBQSxjQUM1RCxJQUFJLFFBQVEsSUFBSSxJQUFJLElBQUksSUFBSSxJQUFJLElBQUksU0FBUyxJQUFJLElBQUksSUFBSSxHQUFHO0FBQUEsY0FDNUQsSUFBSSxRQUFRLElBQUksSUFBSSxJQUFJLElBQUksSUFBSSxJQUFJLFNBQVMsSUFBSSxJQUFJLElBQUksR0FBRztBQUFBLGNBQzVELElBQUksUUFBUSxJQUFJLElBQUksSUFBSSxJQUFJLElBQUksSUFBSSxTQUFTLElBQUksSUFBSSxJQUFJLEdBQUc7QUFBQSxjQUM1RCxJQUFJLFFBQVEsSUFBSSxLQUFLLEtBQUssSUFBSSxJQUFJLElBQUksU0FBUyxJQUFJLElBQUksSUFBSSxHQUFHO0FBQUEsY0FDOUQsSUFBSSxRQUFRLElBQUksS0FBSyxLQUFLLElBQUksSUFBSSxJQUFJLFNBQVMsSUFBSSxJQUFJLElBQUksR0FBRztBQUFBLGNBQzlELElBQUksUUFBUSxJQUFJLEtBQUssS0FBSyxJQUFJLElBQUksSUFBSSxTQUFTLElBQUksSUFBSSxJQUFJLEdBQUc7QUFBQSxjQUM5RCxJQUFJLFFBQVEsSUFBSSxLQUFLLEtBQUssSUFBSSxJQUFJLElBQUksU0FBUyxJQUFJLElBQUksSUFBSSxHQUFHLE1BQU0sSUFBSSxJQUFJLEdBQUc7QUFBQSxjQUMvRSxJQUFJLFFBQVEsSUFBSSxHQUFHLElBQUksR0FBRyxJQUFJLElBQUksU0FBUyxHQUFHLElBQUksSUFBSSxHQUFHO0FBQUEsY0FDekQsSUFBSSxRQUFRLElBQUksR0FBRyxJQUFJLEdBQUcsSUFBSSxJQUFJLFNBQVMsSUFBSSxJQUFJLElBQUksR0FBRztBQUFBLGNBQzFELElBQUksUUFBUSxJQUFJLElBQUksSUFBSSxJQUFJLElBQUksSUFBSSxTQUFTLElBQUksSUFBSSxJQUFJLEdBQUc7QUFBQSxjQUM1RCxJQUFJLFFBQVEsSUFBSSxJQUFJLElBQUksSUFBSSxJQUFJLElBQUksU0FBUyxJQUFJLElBQUksSUFBSSxHQUFHO0FBQUEsY0FDNUQsSUFBSSxRQUFRLElBQUksSUFBSSxJQUFJLElBQUksSUFBSSxJQUFJLFNBQVMsSUFBSSxJQUFJLElB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QUksSUFBSSxXQUFXLEdBQUcsSUFBSSxNQUFNLEdBQUcsTUFBTSxJQUFJLFdBQVcsSUFBSSxJQUFJLE1BQU0sR0FBRyxNQUFNLElBQUksV0FBVyxJQUFJLElBQUksTUFBTSxHQUFHLE1BQU0sSUFBSSxXQUFXLElBQUksSUFBSSxNQUFNLEdBQUc7QUFBQSxVQUNyTCxJQUFJLFVBQVUsR0FBRyxXQUFXLEtBQUssQ0FBQyxHQUFHLE1BQU0sSUFBSSxXQUFXLElBQUksSUFBSSxNQUFNLEdBQUcsTUFBTSxJQUFJLFdBQVcsSUFBSSxJQUFJLE1BQU0sR0FBRyxNQUFNLElBQUksV0FBVyxJQUFJLElBQUksTUFBTSxHQUFHLE1BQU0sSUFBSSxXQUFXLElBQUksSUFBSSxNQUFNLEdBQUc7QUFBQSxVQUM3TCxJQUFJLFVBQVUsR0FBRyxXQUFXLEtBQUssQ0FBQyxHQUFHLE1BQU0sSUFBSSxXQUFXLElBQUksSUFBSSxNQUFNLEdBQUcsTUFBTSxJQUFJLFdBQVcsSUFBSSxJQUFJLE1BQU0sR0FBRyxNQUFNLElBQUksV0FBVyxJQUFJLElBQUksTUFBTSxHQUFHLE1BQU0sSUFBSSxXQUFXLElBQUksSUFBSSxNQUFNLEdBQUc7QUFBQSxVQUM3TCxJQUFJLFVBQVUsR0FBRyxXQUFXLEtBQUssQ0FBQyxHQUFHLE1BQU0sSUFBSSxXQUFXLElBQUksSUFBSSxNQUFNLEdBQUcsTUFBTSxJQUFJLFdBQVcsSUFBSSxJQUFJLE1BQU0sR0FBRyxNQUFNLElBQUksV0FBVyxJQUFJLElBQUksTUFBTSxHQUFHLE1BQU0sSUFBSSxXQUFXLElBQUksSUFBSSxNQUFNLEdBQUc7QUFBQSxVQUM3TCxJQUFJLFVBQVUsR0FBRyxXQUFXLEtBQUssQ0FBQyxHQUFHLE1BQU0sSUFBSSxXQUFXLElBQUksSUFBSSxNQUFNLEdBQUcsT0FBTyxJQUFJLFdBQVcsSUFBSSxJQUFJLE1BQU0sR0FBRyxNQUFNLElBQUksV0FBVyxJQUFJLElBQUksTUFBTSxHQUFHLEtBQUssSUFBSSxNQUFNLEdBQUcsTUFBTSxJQUFJLFdBQVcsSUFBSSxJQUFJLE1BQU0sR0FBRyxLQUFLLElBQUksTUFBTSxHQUFHO0FBQUEsVUFDbE8sSUFBSSxVQUFVLEdBQUcsV0FBVyxLQUFLLENBQUMsR0FBRyxNQUFNLElBQUksV0FBVyxJQUFJLElBQUksTUFBTSxHQUFHLE1BQU0sSUFBSSxXQUFXLElBQUksSUFBSSxNQUFNLEdBQUcsTUFBTSxJQUFJLFdBQVcsSUFBSSxJQUFJLE1BQU0sR0FBRyxNQUFNLElBQUksV0FBVyxJQUFJLElBQUksTUFBTSxHQUFHO0FBQUEsVUFDN0wsSUFBSSxVQUFVLEdBQUcsV0FBVyxLQUFLLENBQUMsR0FBRyxJQUFJLE1BQU0sSUFBSSxXQUFXLElBQUksSUFBSSxNQUFNLEdBQUcsTUFBTSxJQUFJLFdBQVcsSUFBSSxJQUFJLE1BQU0sR0FBRyxNQUFNLElBQUksV0FBVyxJQUFJLElBQUksTUFBTSxHQUFHLEtBQUssSUFBSSxNQUFNLEdBQUcsTUFBTSxJQUFJLFdBQVcsSUFBSSxJQUFJLE1BQU0sR0FBRyxLQUFLLElBQUksTUFBTSxHQUFHO0FBQUEsVUFDck8sSUFBSSxVQUFVLEdBQUcsV0FBVyxLQUFLLENBQUMsR0FBRyxJQUFJLE1BQU0sSUFBSSxXQUFXLElBQUksSUFBSSxNQUFNLEdBQUcsTUFBTSxJQUFJLFdBQVcsSUFBSSxJQUFJLE1BQU0sR0FBRyxLQUFLLElBQUksTUFBTSxHQUFHLE1BQU0sSUFBSSxXQUFXLElBQUksSUFBSSxNQUFNLEdBQUcsS0FBSyxJQUFJLE1BQU0sR0FBRyxNQUFNLElBQUksV0FBVyxJQUFJLElBQUksTUFBTSxHQUFHLEtBQUssSUFBSSxNQUFNLEdBQUc7QUFBQSxVQUN2UCxJQUFJLFVBQVUsR0FBRyxXQUFXLEtBQUssQ0FBQyxHQUFHLElBQUksTUFBTSxJQUFJLFdBQVcsSUFBSSxJQUFJLE1BQU0sR0FBRyxPQUFPLElBQUksV0FBVyxJQUFJLElBQUksTUFBTSxHQUFHLEtBQUssSUFBSSxNQUFNLEdBQUcsTUFBTSxJQUFJLFdBQVcsSUFBSSxJQUFJLE1BQU0sR0FBRyxLQUFLLElBQUksTUFBTSxHQUFHLE1BQU0sSUFBSSxXQUFXLElBQUksSUFBSSxNQUFNLEdBQUcsS0FBSyxJQUFJLE1BQU0sR0FBRztBQUFBLFVBQ3hQLElBQUksVUFBVSxJQUFJLFdBQVcsS0FBSyxDQUFDLEdBQUcsSUFBSSxNQUFNLElBQUksV0FBVyxJQUFJLElBQUksTUFBTSxHQUFHLEtBQUssSUFBSSxNQUFNLEdBQUcsTUFBTSxJQUFJLFdBQVcsSUFBSSxJQUFJLE1BQU0sR0FBRyxLQUFLLElBQUksTUFBTSxHQUFHLE1BQU0sSUFBSSxXQUFXLElBQUksSUFBSSxNQUFNLEdBQUcsS0FBSyxJQUFJLE1BQU0sR0FBRyxNQUFNLElBQUksV0FBVyxJQUFJLElBQUksTUFBTSxHQUFHLEtBQUssSUFBSSxNQUFNLEdBQUc7QUFBQSxVQUMxUSxJQUFJLFVBQVUsSUFBSSxXQUFXLEtBQUssQ0FBQyxHQUFHLElBQUksTUFBTSxJQUFJLFdBQVcsSUFBSSxJQUFJLE1BQU0sR0FBRyxNQUFNLElBQUksV0FBVyxJQUFJLElBQUksTUFBTSxHQUFHLEtBQUssSUFBSSxNQUFNLEdBQUcsTUFBTSxJQUFJLFdBQVcsSUFBSSxJQUFJLE1BQU0sR0FBRyxLQUFLLElBQUksTUFBTSxHQUFHLE1BQU0sSUFBSSxXQUFXLElBQUksSUFBSSxNQUFNLEdBQUcsS0FBSyxJQUFJLE1BQU0sR0FBRztBQUFBLFVBQ3hQLElBQUksVUFBVSxJQUFJLFdBQVcsS0FBSyxDQUFDLEdBQUcsSUFBSSxNQUFNLElBQUksV0FBVyxJQUFJLElBQUksTUFBTSxHQUFHLEtBQUssSUFBSSxNQUFNLEdBQUcsTUFBTSxJQUFJLFdBQVcsSUFBSSxJQUFJLE1BQU0sR0FBRyxLQUFLLElBQUksTUFBTSxHQUFHLE1BQU0sSUFBSSxXQUFXLElBQUksSUFBSSxNQUFNLEdBQUcsS0FBSyxJQUFJLE1BQU0sR0FBRyxNQUFNLElBQUksV0FBVyxJQUFJLElBQUksTUFBTSxHQUFHLEtBQUssSUFBSSxNQUFNLEdBQUc7QUFBQSxVQUMxUSxJQUFJLFVBQVUsSUFBSSxXQUFXLEtBQUssQ0FBQyxHQUFHLElBQUksTUFBTSxJQUFJLFdBQVcsSUFBSSxJQUFJLE1BQU0sR0FBRyxPQUFPLElBQUksV0FBVyxJQUFJLElBQUksTUFBTSxHQUFHLEtBQUssSUFBSSxNQUFNLEdBQUcsTUFBTSxJQUFJLFdBQVcsSUFBSSxJQUFJLE1BQU0sR0FBRyxLQUFLLElBQUksTUFBTSxHQUFHLE1BQU0sSUFBSSxXQUFXLElBQUksSUFBSSxNQUFNLElBQUksS0FBSyxJQUFJLE1BQU0sR0FBRztBQUFBLFVBQzFQLElBQUksVUFBVSxJQUFJLFdBQVcsS0FBSyxDQUFDLEdBQUcsSUFBSSxJQUFJLE1BQU0sSUFBSSxXQUFXLElBQUksSUFBSSxNQUFNLEdBQUcsTUFBTSxJQUFJLE1BQU0sR0FBRyxPQUFPLElBQUksV0FBVyxJQUFJLElBQUksTUFBTSxHQUFHLEtBQUssSUFBSSxNQUFNLEdBQUcsTUFBTSxJQUFJLFdBQVcsSUFBSSxJQUFJLE1BQU0sSUFBSSxLQUFLLElBQUksTUFBTSxHQUFHLE1BQU0sSUFBSSxXQUFXLElBQUksSUFBSSxNQUFNLElBQUksS0FBSyxJQUFJLE1BQU0sR0FBRztBQUFBLFVBQ2xSLElBQUksVUFBVSxJQUFJLFdBQVcsS0FBSyxDQUFDLEdBQUcsSUFBSSxJQUFJLE1BQU0sSUFBSSxXQUFXLElBQUksSUFBSSxNQUFNLEdBQUcsS0FBSyxJQUFJLE1BQU0sR0FBRyxNQUFNLElBQUksV0FBVyxJQUFJLElBQUksTUFBTSxHQUFHLEtBQUssSUFBSSxNQUFNLEdBQUcsTUFBTSxJQUFJLFdBQVcsSUFBSSxJQUFJLE1BQU0sR0FBRyxLQUFLLElBQUksTUFBTSxHQUFHLE1BQU0sSUFBSSxXQUFXLElBQUksSUFBSSxNQUFNLElBQUksS0FBSyxJQUFJLE1BQU0sR0FBRztBQUFBLFVBQy9RLElBQUksVUFBVSxJQUFJLFdBQVcsS0FBSyxDQUFDLEdBQUcsSUFBSSxJQUFJLE1BQU0sSUFBSSxXQUFXLElBQUksSUFBSSxNQUFNLEdBQUcsS0FBSyxJQUFJLE1BQU0sR0FBRyxNQUFNLElBQUksV0FBVyxJQUFJLElBQUksTUFBTSxHQUFHLEtBQUssSUFBSSxNQUFNLEdBQUcsTUFBTSxJQUFJLFdBQVcsSUFBSSxJQUFJLE1BQU0sSUFBSSxLQUFLLElBQUksTUFBTSxHQUFHLE1BQU0sSUFBSSxXQUFXLElBQUksSUFBSSxNQUFNLEdBQUcsS0FBSyxJQUFJLE1BQU0sSUFBSTtBQUFBLFVBQ2hSLElBQUksVUFBVSxJQUFJLFdBQVcsS0FBSyxDQUFDLEdBQUcsSUFBSSxJQUFJLE1BQU0sSUFBSSxXQUFXLElBQUksSUFBSSxNQUFNLEdBQUcsTUFBTSxJQUFJLE1BQU0sR0FBRyxPQUFPLElBQUksV0FBVyxJQUFJLElBQUksTUFBTSxJQUFJLEtBQUssSUFBSSxNQUFNLEdBQUcsTUFBTSxJQUFJLFdBQVcsSUFBSSxJQUFJLE1BQU0sR0FBRyxLQUFLLElBQUksTUFBTSxJQUFJLE1BQU0sSUFBSSxXQUFXLElBQUksSUFBSSxNQUFNLEdBQUcsS0FBSyxJQUFJLE1BQU0sSUFBSTtBQUFBLFVBQ25SLElBQUksVUFBVSxJQUFJLFdBQVcsS0FBSyxDQUFDLEdBQUcsSUFBSSxJQUFJLE1BQU0sSUFBSSxXQUFXLElBQUksSUFBSSxNQUFNLEdBQUcsTUFBTSxJQUFJLE1BQU0sR0FBRyxPQUFPLElBQUksV0FBVyxJQUFJLElBQUksTUFBTSxHQUFHLEtBQUssSUFBSSxNQUFNLEdBQUcsTUFBTSxJQUFJLFdBQVcsSUFBSSxJQUFJLE1BQU0sSUFBSSxLQUFLLElBQUksTUFBTSxHQUFHLE1BQU0sSUFBSSxXQUFXLElBQUksSUFBSSxNQUFNLEdBQUcsS0FBSyxJQUFJLE1BQU0sSUFBSTtBQUFBLFVBQ2xSLElBQUksVUFBVSxJQUFJLFdBQVcsS0FBSyxDQUFDLEdBQUcsSUFBSSxJQUFJLE1BQU0sSUFBSSxXQUFXLElBQUksSUFBSSxNQUFNLEdBQUcsTUFBTSxJQUFJLE1BQU0sR0FBRyxPQUFPLElBQUksV0FBVyxJQUFJLElBQUksTUFBTSxHQUFHLEtBQUssSUFBSSxNQUFNLElBQUksTUFBTSxJQUFJLFdBQVcsSUFBSSxJQUFJLE1BQU0sSUFBSSxLQUFLLElBQUksTUFBTSxHQUFHLE1BQU0sSUFBSSxXQUFXLElBQUksSUFBSSxNQUFNLEdBQUcsS0FBSyxJQUFJLE1BQU0sSUFBSTtBQUFBLFVBQ25SLElBQUksVUFBVSxJQUFJLFdBQVcsS0FBSyxDQUFDLEdBQUcsSUFBSSxJQUFJLE1BQU0sSUFBSSxXQUFXLElBQUksSUFBSSxNQUFNLEdBQUcsTUFBTSxJQUFJLE1BQU0sR0FBRyxPQUFPLElBQUksV0FBVyxJQUFJLElBQUksTUFBTSxHQUFHLEtBQUssSUFBSSxNQUFNLElBQUksTUFBTSxJQUFJLFdBQVcsSUFBSSxJQUFJLE1BQU0sSUFBSSxLQUFLLElBQUksTUFBTSxHQUFHLE1BQU0sSUFBSSxXQUFXLElBQUksSUFBSSxNQUFNLElBQUksS0FBSyxJQUFJLE1BQU0sSUFBSTtBQUFBLFVBQ3BSLElBQUksVUFBVSxJQUFJLFdBQVcsS0FBSyxDQUFDLEdBQUcsSUFBSSxJQUFJLElBQUksTUFBTSxJQUFJLFdBQVcsSUFBSSxJQUFJLE1BQU0sR0FBRyxNQUFNLElBQUksTUFBTSxHQUFHLE9BQU8sSUFBSSxXQUFXLElBQUksSUFBSSxNQUFNLElBQUksTUFBTSxJQUFJLFdBQVcsSUFBSSxJQUFJLE1BQU0sSUFBSSxLQUFLLElBQUksTUFBTSxHQUFHLE1BQU0sSUFBSSxXQUFXLElBQUksSUFBSSxNQUFNLElBQUksS0FBSyxJQUFJLE1BQU0sR0FBRztBQUFBLFVBQ3JRLElBQUksVUFBVSxJQUFJLFdBQVcsS0FBSyxDQUFDLEdBQUcsSUFBSSxJQUFJLElBQUksTUFBTSxJQUFJLFdBQVcsSUFBSSxJQUFJLE1BQU0sR0FBRyxNQUFNLElBQUksTUFBTSxHQUFHLE9BQU8sSUFBSSxXQUFXLElBQUksSUFBSSxNQUFNLElBQUksTUFBTSxJQUFJLFdBQVcsSUFBSSxJQUFJLE1BQU0sR0FBRyxLQUFLLElBQUksTUFBTSxJQUFJLE1BQU0sSUFBSSxXQUFXLElBQUksSUFBSSxNQUFNLElBQUk7QUFBQSxVQUNuUCxJQUFJLFVBQVUsSUFBSSxXQUFXLEtBQUssQ0FBQyxHQUFHLElBQUksSUFBSSxJQUFJLE9BQU8sSUFBSSxXQUFXLElBQUksSUFBSSxNQUFNLEdBQUcsTUFBTSxJQUFJLE1BQU0sR0FBRyxPQUFPLElBQUksV0FBVyxJQUFJLElBQUksTUFBTSxHQUFHLEtBQUssSUFBSSxNQUFNLElBQUksTUFBTSxJQUFJLFdBQVcsSUFBSSxJQUFJLE1BQU0sSUFBSSxLQUFLLElBQUksTUFBTSxJQUFJLE1BQU0sSUFBSSxXQUFXLElBQUksSUFBSSxNQUFNLElBQUksS0FBSyxJQUFJLE1BQU0sSUFBSTtBQUFBLFVBQzFSLElBQUksVUFBVSxJQUFJLFdBQVcsS0FBSyxDQUFDLEdBQUcsSUFBSSxJQUFJLElBQUksT0FBTyxJQUFJLFdBQVcsSUFBSSxJQUFJLE1BQU0sR0FBRyxNQUFNLElBQUksTUFBTSxHQUFHLE9BQU8sSUFBSSxXQUFXLElBQUksSUFBSSxNQUFNLEdBQUcsS0FBSyxJQUFJLE1BQU0sSUFBSSxNQUFNLElBQUksV0FBVyxJQUFJLElBQUksTUFBTSxJQUFJLEtBQUssSUFBSSxNQUFNLElBQUksTUFBTSxJQUFJLFdBQVcsSUFBSSxJQUFJLE1BQU0sSUFBSSxLQUFLLElBQUksTUFBTSxHQUFHO0FBQUEsVUFDelIsSUFBSSxVQUFVLElBQUksV0FBVyxLQUFLLENBQUMsR0FBRyxJQUFJLElBQUksSUFBSSxPQUFPLElBQUksV0FBVyxJQUFJLElBQUksTUFBTSxHQUFHLE1BQU0sSUFBSSxNQUFNLEdBQUcsT0FBTyxJQUFJLFdBQVcsSUFBSSxJQUFJLE1BQU0sR0FBRyxLQUFLLElBQUksTUFBTSxJQUFJLE1BQU0sSUFBSSxXQUFXLElBQUksSUFBSSxNQUFNLEdBQUcsS0FBSyxJQUFJLE1BQU0sSUFBSSxNQUFNLElBQUksV0FBVyxJQUFJLElBQUksTUFBTSxJQUFJLEtBQUssSUFBSSxNQUFNLElBQUk7QUFBQSxVQUN6UixJQUFJLFVBQVUsSUFBSSxXQUFXLEtBQUssQ0FBQyxHQUFHLElBQUksSUFBSSxJQUFJLE9BQU8sSUFBSSxXQUFXLElBQUksSUFBSSxNQUFNLElBQUksTUFBTSxJQUFJLE1BQU0sR0FBRyxPQUFPLElBQUksV0FBVyxJQUFJLElBQUksTUFBTSxJQUFJLEtBQUssSUFBSSxNQUFNLEdBQUcsTUFBTSxJQUFJLFdBQVcsSUFBSSxJQUFJLE1BQU0sSUFBSSxLQUFLLElBQUksTUFBTSxHQUFHLE1BQU0sSUFBSSxXQUFXLElBQUksSUFBSSxNQUFNLElBQUksS0FBSyxJQUFJLE1BQU0sR0FBRztBQUFBLFVBQ3pSLElBQUksVUFBVSxJQUFJLFdBQVcsS0FBSyxDQUFDLEdBQUcsSUFBSSxJQUFJLElBQUksT0FBTyxJQUFJLFdBQVcsSUFBSSxJQUFJLE1BQU0sR0FBRyxNQUFNLElBQUksTUFBTSxHQUFHLE9BQU8sSUFBSSxXQUFXLElBQUksSUFBSSxNQUFNLElBQUksS0FBSyxJQUFJLE1BQU0sR0FBRyxNQUFNLElBQUksV0FBVyxJQUFJLElBQUksTUFBTSxHQUFHLEtBQUssSUFBSSxNQUFNLElBQUksTUFBTSxJQUFJLFdBQVcsSUFBSSxJQUFJLE1BQU0sSUFBSSxLQUFLLElBQUksTUFBTSxJQUFJO0FBQUEsVUFDelIsSUFBSSxVQUFVLElBQUksV0FBVyxLQUFLLENBQUMsR0FBRyxJQUFJLElBQUksSUFBSSxJQUFJLE9BQU8sSUFBSSxXQUFXLElBQUksSUFBSSxNQUFNLEdBQUcsTUFBTSxJQUFJLE1BQU0sSUFBSSxPQUFPLElBQUksV0FBVyxJQUFJLElBQUksTUFBTSxHQUFHLEtBQUssSUFBSSxNQUFNLElBQUksTUFBTSxJQUFJLFdBQVcsSUFBSSxJQUFJLE1BQU0sR0FBRyxLQUFLLElBQUksTUFBTSxJQUFJLE1BQU0sSUFBSSxXQUFXLElBQUksSUFBSSxNQUFNLElBQUksS0FBSyxJQUFJLE1BQU0sSUFBSTtBQUFBLFVBQzlSLElBQUksVUFBVSxJQUFJLFdBQVcsS0FBSyxDQUFDLEdBQUcsSUFBSSxJQUFJLElBQUksS0FBSyxPQUFPLElBQUksV0FBVyxJQUFJLElBQUksTUFBTSxHQUFHLE1BQU0sSUFBSSxNQUFNLEdBQUcsT0FBTyxJQUFJLFdBQVcsSUFBSSxJQUFJLE1BQU0sSUFBSSxLQUFLLElBQUksTUFBTSxHQUFHLE1BQU0sSUFBSSxXQUFXLElBQUksSUFBSSxNQUFNLEdBQUcsS0FBSyxJQUFJLE1BQU0sSUFBSSxNQUFNLElBQUksV0FBVyxJQUFJLElBQUksTUFBTSxJQUFJLEtBQUssSUFBSSxNQUFNLElBQUk7QUFBQSxVQUM5UixJQUFJLFVBQVUsSUFBSSxXQUFXLEtBQUssQ0FBQyxHQUFHLElBQUksSUFBSSxJQUFJLEtBQUssT0FBTyxJQUFJLFdBQVcsSUFBSSxJQUFJLE1BQU0sR0FBRyxNQUFNLElBQUksTUFBTSxJQUFJLE9BQU8sSUFBSSxXQUFXLElBQUksSUFBSSxNQUFNLElBQUksS0FBSyxJQUFJLE1BQU0sSUFBSSxNQUFNLElBQUksV0FBVyxJQUFJLElBQUksTUFBTSxJQUFJLEtBQUssSUFBSSxNQUFNLElBQUksTUFBTSxJQUFJLFdBQVcsSUFBSSxJQUFJLE1BQU0sSUFBSSxLQUFLLElBQUksTUFBTSxJQUFJO0FBQUEsVUFDalMsSUFBSSxVQUFVLElBQUksV0FBVyxLQUFLLENBQUMsR0FBRyxJQUFJLElBQUksSUFBSSxLQUFLLE9BQU8sSUFBSSxXQUFXLElBQUksSUFBSSxNQUFNLElBQUksTUFBTSxJQUFJLE1BQU0sR0FBRyxPQUFPLElBQUksV0FBVyxJQUFJLElBQUksTUFBTSxHQUFHLEtBQUssSUFBSSxNQUFNLElBQUksTUFBTSxJQUFJLFdBQVcsSUFBSSxJQUFJLE1BQU0sSUFBSSxLQUFLLElBQUksTUFBTSxHQUFHLE1BQU0sSUFBSSxXQUFXLElBQUksSUFBSSxNQUFNLElBQUksS0FBSyxJQUFJLE1BQU0sSUFBSTtBQUFBLFVBQy9SLElBQUksVUFBVSxJQUFJLFdBQVcsS0FBSyxDQUFDLEdBQUcsSUFBSSxJQUFJLElBQUksS0FBSyxPQUFPLElBQUksV0FBVyxJQUFJLElBQUksTUFBTSxJQUFJLE9BQU8sSUFBSSxXQUFXLElBQUksSUFBSSxNQUFNLElBQUksS0FBSyxJQUFJLE1BQU0sSUFBSSxNQUFNLElBQUksV0FBVyxJQUFJLElBQUksTUFBTSxJQUFJLEtBQUssSUFBSSxNQUFNLElBQUksTUFBTSxJQUFJLFdBQVcsSUFBSSxJQUFJLE1BQU0sSUFBSSxLQUFLLElBQUksTUFBTSxJQUFJO0FBQUEsVUFDOVEsSUFBSSxVQUFVLElBQUksV0FBVyxLQUFLLENBQUMsR0FBRyxJQUFJLElBQUksSUFBSSxLQUFLLE9BQU8sSUFBSSxXQUFXLElBQUksSUFBSSxNQUFNLElBQUksTUFBTSxJQUFJLE1BQU0sR0FBRyxPQUFPLElBQUksV0FBVyxJQUFJLElBQUksTUFBTSxJQUFJLEtBQUssSUFBSSxNQUFNLElBQUksTUFBTSxJQUFJLFdBQVcsSUFBSSxJQUFJLE1BQU0sSUFBSSxLQUFLLElBQUksTUFBTSxJQUFJLE1BQU0sSUFBSSxXQUFXLElBQUksSUFBSSxNQUFNLElBQUksS0FBSyxJQUFJLE1BQU0sSUFBSTtBQUFBLFVBQ2pTLElBQUksVUFBVSxJQUFJLFdBQVcsS0FBSyxDQUFDLEdBQUcsSUFBSSxJQUFJLElBQUksS0FBSyxPQUFPLElBQUksV0FBVyxJQUFJLElBQUksTUFBTSxJQUFJLE1BQU0sSUFBSSxNQUFNLEdBQUcsT0FBTyxJQUFJLFdBQVcsSUFBSSxJQUFJLE1BQU0sSUFBSSxLQUFLLElBQUksTUFBTSxJQUFJLE1BQU0sSUFBSSxXQUFXLElBQUksSUFBSSxNQUFNLElBQUksS0FBSyxJQUFJLE1BQU0sR0FBRyxNQUFNLElBQUksV0FBVyxJQUFJLElBQUksTUFBTSxJQUFJLEtBQUssSUFBSSxNQUFNLEdBQUc7QUFBQSxVQUMvUixJQUFJLFVBQVUsSUFBSSxXQUFXLEtBQUssQ0FBQyxHQUFHLElBQUksSUFBSSxJQUFJLEtBQUssS0FBSyxPQUFPLElBQUksV0FBVyxJQUFJLElBQUksTUFBTSxJQUFJLE1BQU0sSUFBSSxNQUFNLEdBQUcsT0FBTyxJQUFJLFdBQVcsSUFBSSxJQUFJLE1BQU0sSUFBSSxLQUFLLElBQUksTUFBTSxJQUFJLE1BQU0sSUFBSSxXQUFXLElBQUksSUFBSSxNQUFNLElBQUksS0FBSyxJQUFJLE1BQU0sSUFBSSxNQUFNLElBQUksV0FBVyxJQUFJLElBQUksTUFBTSxJQUFJLEtBQUssSUFBSSxNQUFNLElBQUk7QUFBQSxVQUN0UyxJQUFJLFVBQVUsSUFBSSxXQUFXLEtBQUssQ0FBQyxHQUFHLElBQUksSUFBSSxJQUFJLEtBQUssS0FBSyxPQUFPLElBQUksV0FBVyxJQUFJLElBQUksTUFBTSxHQUFHLE1BQU0sSUFBSSxNQUFNLElBQUksT0FBTyxJQUFJLFdBQVcsSUFBSSxJQUFJLE1BQU0sR0FBRyxLQUFLLElBQUksTUFBTSxJQUFJLE1BQU0sSUFBSSxXQUFXLElBQUksSUFBSSxNQUFNLElBQUksS0FBSyxJQUFJLE1BQU0sSUFBSSxNQUFNLElBQUksV0FBVyxJQUFJLElBQUksTUFBTSxHQUFHLEtBQUssSUFBSSxNQUFNLElBQUk7QUFBQSxVQUNwUyxJQUFJLFVBQVUsSUFBSSxXQUFXLEtBQUssQ0FBQyxHQUFHLElBQUksSUFBSSxJQUFJLEtBQUssS0FBSyxPQUFPLElBQUksV0FBVyxJQUFJLElBQUksTUFBTSxJQUFJLE1BQU0sSUFBSSxNQUFNLEdBQUcsT0FBTyxJQUFJLFdBQVcsSUFBSSxJQUFJLE1BQU0sSUFBSSxLQUFLLElBQUksTUFBTSxJQUFJLE1BQU0sSUFBSSxXQUFXLElBQUksSUFBSSxNQUFNLElBQUksS0FBSyxJQUFJLE1BQU0sSUFBSSxNQUFNLElBQUksV0FBVyxJQUFJLElBQUksTUFBTSxJQUFJLEtBQUssSUFBSSxNQUFNLElBQUk7QUFBQSxVQUN0UyxJQUFJLFVBQVUsSUFBSSxXQUFXLEtBQUssQ0FBQyxHQUFHLElBQUksSUFBSSxJQUFJLEtBQUssS0FBSyxPQUFPLElBQUksV0FBVyxJQUFJLElBQUksTUFBTSxHQUFHLE1BQU0sSUFBSSxNQUFNLElBQUksT0FBTyxJQUFJLFdBQVcsSUFBSSxJQUFJLE1BQU0sSUFBSSxLQUFLLElBQUksTUFBTSxJQUFJLE1BQU0sSUFBSSxXQUFXLElBQUksSUFBSSxNQUFNLElBQUksS0FBSyxJQUFJLE1BQU0sSUFBSSxNQUFNLElBQUksV0FBVyxJQUFJLElBQUksTUFBTSxJQUFJLEtBQUssSUFBSSxNQUFNLElBQUk7QUFBQSxVQUN0UyxJQUFJLFVBQVUsSUFBSSxXQUFX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QzlCLHFCQUFhLGtCQUFrQixJQUFJLFdBQVc7QUFNOUMscUJBQWEsZUFBZSxXQUFXLEtBQUs7QUFBQSxVQUN4QztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFDbkc7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQ25HO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUNuRztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFDbkc7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQ25HO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUNuRztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFDbkc7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQ25HO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUNuRztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFDbkc7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQ25HO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUNuRztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFDbkc7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQ25HO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUNuRztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFDbkc7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQ25HO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUNuRztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFDbkc7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQ25HO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUNuRztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFDbkc7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQ25HO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUNuRztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFDbkc7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQ25HO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUNuRztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFDbkc7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQ25HO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUNuRztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFDbkc7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQ25HO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUNuRztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFDbkc7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQ25HO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUNuRztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFDbkc7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQ25HO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUNuRztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFDbkc7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQ25HO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUNuRztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFDbkc7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQ25HO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUNuRztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFDbkc7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQ25HO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUNuRztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFDbkc7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQ25HO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUNuRztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFDbkc7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQ25HO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUNuRztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFDbkc7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQ25HO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUNuRztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFDbkc7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQ25HO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUNuRztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFDbkc7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQ25HO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUNuRztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFDbkc7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQ25HO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUNuRztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFDbkc7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQ25HO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUNuRztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFDbkc7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQ25HO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUNuRztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFDbkc7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQ25HO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUNuRztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFDbkc7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQ25HO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUNuRztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFDbkc7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQ25HO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUNuRztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFDbkc7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQ25HO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUNuRztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFDbkc7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQ25HO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUNuRztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFDbkc7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQ25HO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUNuRztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFDbkc7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQ25HO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUNuRztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFDbkc7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQ25HO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUNuRztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFDbkc7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQ25HO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUNuRztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFDbkc7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQ25HO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUNuRztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFDbkc7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQ25HO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUNuRztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFDbkc7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQ25HO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUNuRztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFDbkc7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQ25HO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUNuRztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFDbkc7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQ25HO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUNuRztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFDbkc7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQ25HO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUNuRztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFDbkc7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQ25HO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUNuRztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFDbkc7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQ25HO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUNuRztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFDbkc7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQ25HO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUNuRztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFDbkc7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQ25HO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUNuRztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFDbkc7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQ25HO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUNuRztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFDbkc7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQ25HO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUNuRztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFDbkc7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQ25HO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUNuRztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFDbkc7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQ25HO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUNuRztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFDbkc7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQ25HO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUNuRztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFDbkc7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQ25HO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUNuRztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFDbkc7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQ25HO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUNuRztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFDbkc7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQ25HO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUNuRztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFDbkc7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQ25HO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUNuRztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFDbkc7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQ25HO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUNuRztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFDbkc7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQ25HO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUNuRztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFDbkc7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQ25HO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUNuRztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFDbkc7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQ25HO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUNuRztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFDbkc7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQ25HO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUNuRztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFDbkc7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQ25HO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUNuRztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFDbkc7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQ25HO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUNuRztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFDbkc7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQ25HO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUNuRztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFDbkc7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQ25HO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUNuRztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFDbkc7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQ25HO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUNuRztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFDbkc7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQ25HO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUNuRztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFDbkc7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQ25HO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUNuRztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFDbkc7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQ25HO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUNuRztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFDbkc7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQ25HO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUNuRztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFDbkc7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQ25HO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUNuRztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFDbkc7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQ25HO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUNuRztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFDbkc7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQ25HO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUNuRztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFDbkc7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQ25HO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUNuRztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFDbkc7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQ25HO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUNuRztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFDbkc7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQ25HO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUNuRztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFDbkc7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQ25HO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUNuRztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFDbkc7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQ25HO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUNuRztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFDbkc7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQ25HO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUNuRztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFDbkc7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQ25HO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUNuRztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFDbkc7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQ25HO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUNuRztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBLFVBQVM7QUFBQSxVQUFTO0FBQUEsVUFDbkc7QUFBQSxVQUFTO0FBQUEsVUFBUztBQUFBO0FBS3RCLHFCQUFhLGlCQUFpQixXQUFXLEtBQUs7QUFBQSxVQUMxQztBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUMzRztBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFDNUc7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUN2RztBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUM1RztBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFDNUc7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQzdHO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQzFHO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQ3pHO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFDdkc7QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUM1RztBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFDM0c7QUFBQSxVQUFNO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFDekc7QUFBQSxVQUFNO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFDekc7QUFBQSxVQUFNO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFDekc7QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFDMUc7QUFBQSxVQUFLO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFDekc7QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFDekc7QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUMxRztBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUM1RztBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQzVHO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFDeEc7QUFBQSxVQUFLO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFDMUc7QUFBQSxVQUFLO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFDekc7QUFBQSxVQUFLO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFDMUc7QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFDM0c7QUFBQSxVQUFLO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUN2RztBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUMxRztBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUMzRztBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUM3RztBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUN6RztBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQ3pHO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFDeEc7QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFDNUc7QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUM1RztBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQzVHO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFDekc7QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUN6RztBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUN4RztBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQUk7QUFBQSxVQUFJO0FBQUEsVUFBTTtBQUFBLFVBQUk7QUFBQSxVQUFNO0FBQUEsVUFDNUc7QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFJO0FBQUEsVUFBSTtBQUFBLFVBQUk7QUFBQSxVQUFNO0FBQUEsVUFBSTtBQUFBLFVBQU07QUFBQSxVQUFJO0FBQUEsVUFBTTtBQUFBLFVBQUk7QUFBQSxVQUFJO0FBQUEsVUFBSTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQ3hHO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQUk7QUFBQSxVQUFJO0FBQUEsVUFBTTtBQUFBLFVBQUk7QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBSTtBQUFBLFVBQU07QUFBQSxVQUFJO0FBQUEsVUFBTTtBQUFBLFVBQUk7QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQUk7QUFBQSxVQUMxRztBQUFBLFVBQU07QUFBQSxVQUFJO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQUk7QUFBQSxVQUFNO0FBQUEsVUFBSTtBQUFBLFVBQU07QUFBQSxVQUFJO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBSTtBQUFBLFVBQUk7QUFBQSxVQUFNO0FBQUEsVUFDNUc7QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQUk7QUFBQSxVQUFNO0FBQUEsVUFBSTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQUk7QUFBQSxVQUFNO0FBQUEsVUFBSTtBQUFBLFVBQU07QUFBQSxVQUFJO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFJO0FBQUEsVUFBSTtBQUFBLFVBQUs7QUFBQSxVQUMzRztBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBSTtBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUN4RztBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUMxRztBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUN6RztBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUMzRztBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBTTtBQUFBLFVBQ3pHO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQzFHO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFDM0c7QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFDNUc7QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFDN0c7QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUM1RztBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUM1RztBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBTTtBQUFBLFVBQzFHO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFDeEc7QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUM1RztBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQ3hHO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFDNUc7QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUM1RztBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUM1RztBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUN4RztBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFDN0c7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQzNHO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBTTtBQUFBLFVBQ3pHO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQzNHO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQzFHO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUMzRztBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUN4RztBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUMzRztBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUN6RztBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUN6RztBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUM1RztBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUMzRztBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUN4RztBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUN4RztBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUM1RztBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFDN0c7QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUN4RztBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBTTtBQUFBLFVBQzFHO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUM1RztBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBSTtBQUFBLFVBQUk7QUFBQSxVQUFNO0FBQUEsVUFBSTtBQUFBLFVBQU07QUFBQSxVQUFJO0FBQUEsVUFBTTtBQUFBLFVBQUk7QUFBQSxVQUFJO0FBQUEsVUFBSTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFDekc7QUFBQSxVQUFNO0FBQUEsVUFBSTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQUk7QUFBQSxVQUFJO0FBQUEsVUFBTTtBQUFBLFVBQUk7QUFBQSxVQUFNO0FBQUEsVUFBSTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBSTtBQUFBLFVBQUk7QUFBQSxVQUFJO0FBQUEsVUFBTTtBQUFBLFVBQUk7QUFBQSxVQUM1RztBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFJO0FBQUEsVUFBTTtBQUFBLFVBQUk7QUFBQSxVQUFNO0FBQUEsVUFBSTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFJO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFJO0FBQUEsVUFDOUc7QUFBQSxVQUFNO0FBQUEsVUFBRztBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQUk7QUFBQSxVQUFNO0FBQUEsVUFBSTtBQUFBLFVBQU07QUFBQSxVQUFJO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFJO0FBQUEsVUFBSztBQUFBLFVBQUk7QUFBQSxVQUFJO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFDN0c7QUFBQSxVQUFJO0FBQUEsVUFBSztBQUFBLFVBQUk7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBTTtBQUFBLFVBQ3pHO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUM1RztBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUMxRztBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQ3ZHO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQ3ZHO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQzVHO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFDdkc7QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUN2RztBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQzNHO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFDMUc7QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFDNUc7QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFDM0c7QUFBQSxVQUFLO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFDNUc7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQzFHO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQzFHO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBTTtBQUFBLFVBQzFHO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFDeEc7QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFDNUc7QUFBQSxVQUFLO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFDekc7QUFBQSxVQUFNO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBSztBQUFBLFVBQzVHO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQzVHO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFJO0FBQUEsVUFBSTtBQUFBLFVBQUk7QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQUk7QUFBQSxVQUM1RztBQUFBLFVBQUk7QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFJO0FBQUEsVUFBSTtBQUFBLFVBQUk7QUFBQSxVQUFNO0FBQUEsVUFBSTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBSTtBQUFBLFVBQU07QUFBQSxVQUFJO0FBQUEsVUFDMUc7QUFBQSxVQUFJO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQUk7QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFHO0FBQUEsVUFBTTtBQUFBLFVBQUc7QUFBQSxVQUFNO0FBQUEsVUFBRztBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQ3pHO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFJO0FBQUEsVUFBSTtBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFJO0FBQUEsVUFBSztBQUFBLFVBQUk7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFDM0c7QUFBQSxVQUFLO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQzVHO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBTTtBQUFBLFVBQzFHO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUM3RztBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUN6RztBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUN6RztBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQzFHO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFDNUc7QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUMxRztBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQzNHO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFDekc7QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUN4RztBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUN6RztBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUN6RztBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQUk7QUFBQSxVQUFNO0FBQUEsVUFBSTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQ3ZHO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBSztBQUFBLFVBQUk7QUFBQSxVQUFLO0FBQUEsVUFBSTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFJO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBSztBQUFBLFVBQ3pHO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBRztBQUFBLFVBQUc7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBSTtBQUFBLFVBQUs7QUFBQSxVQUFJO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFDeEc7QUFBQSxVQUFNO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFDM0c7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFDekc7QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQzFHO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFDeEc7QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUM1RztBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQzNHO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFDMUc7QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUFJO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQUc7QUFBQSxVQUFLO0FBQUEsVUFBRztBQUFBLFVBQzFHO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBSTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFDdkc7QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUN4RztBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUMzRztBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtB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LElBQUksSUFBSSxJQUFJLElBQUk7QUFBQSxVQUN6QyxXQUFXLEtBQUssQ0FBQyxHQUFHLElBQUksSUFBSSxJQUFJLElBQUksSUFBSTtBQUFBLFVBQ3hDLFdBQVcsS0FBSyxDQUFDLEdBQUcsSUFBSSxJQUFJLElBQUksSUFBSSxJQUFJO0FBQUEsVUFDeEMsV0FBVyxLQUFLLENBQUMsR0FBRyxJQUFJLElBQUksSUFBSSxJQUFJLElBQUk7QUFBQSxVQUN4QyxXQUFXLEtBQUssQ0FBQyxHQUFHLElBQUksSUFBSSxJQUFJLElBQUksSUFBSTtBQUFBLFVBQ3hDLFdBQVcsS0FBSyxDQUFDLEdBQUcsSUFBSSxJQUFJLElBQUksSUFBSSxJQUFJO0FBQUEsVUFDeEMsV0FBVyxLQUFLLENBQUMsR0FBRyxJQUFJLElBQUksSUFBSSxJQUFJLElBQUk7QUFBQSxVQUN4QyxXQUFXLEtBQUssQ0FBQyxHQUFHLElBQUksSUFBSSxJQUFJLElBQUksSUFBSTtBQUFBLFVBQ3hDLFdBQVcsS0FBSyxDQUFDLEdBQUcsSUFBSSxJQUFJLElBQUksSUFBSSxJQUFJO0FBQUEsVUFDeEMsV0FBVyxLQUFLLENBQUMsR0FBRyxJQUFJLElBQUksSUFBSSxJQUFJLElBQUk7QUFBQSxVQUN4QyxXQUFXLEtBQUssQ0FBQyxHQUFHLElBQUksSUFBSSxJQUFJLElBQUksSUFBSTtBQUFBLFVBQ3hDLFdBQVcsS0FBSyxDQUFDLEdBQUcsSUFBSSxJQUFJLElBQUksSUFBSSxJQUFJO0FBQUEsVUFDeEMsV0FBVyxLQUFLLENBQUMsR0FBRyxJQUFJLElBQUksSUFBSSxJQUFJLElBQUk7QUFBQSxVQUN4QyxXQUFXLEtBQUssQ0FBQyxHQUFHLElBQUksSUFBSSxJQUFJLElBQUksSUFBSTtBQUFBLFVBQ3hDLFdBQVcsS0FBSyxDQUFDLEdBQUcsSUFBSSxJQUFJLElBQUksSUFBSSxJQUFJO0FBQUEsVUFDeEMsV0FBVyxLQUFLLENBQUMsR0FBRyxJQUFJLElBQUksSUFBSSxJQUFJLElBQUk7QUFBQSxVQUN4QyxXQUFXLEtBQUssQ0FBQyxHQUFHLElBQUksSUFBSSxJQUFJLElBQUksSUFBSTtBQUFBLFVBQ3hDLFdBQVcsS0FBSyxDQUFDLEdBQUcsSUFBSSxJQUFJLElBQUksSUFBSSxJQUFJO0FBQUEsVUFDeEMsV0FBVyxLQUFLLENBQUMsR0FBRyxJQUFJLElBQUksSUFBSSxJQUFJLElBQUk7QUFBQSxVQUN4QyxXQUFXLEtBQUssQ0FBQyxHQUFHLElBQUksSUFBSSxJQUFJLElBQUksSUFBSTtBQUFBLFVBQ3hDLFdBQVcsS0FBSyxDQUFDLEdBQUcsSUFBSSxJQUFJLElBQUksSUFBSSxJQUFJO0FBQUEsVUFDeEMsV0FBVyxLQUFLLENBQUMsR0FBRyxJQUFJLElBQUksSUFBSSxJQUFJLElBQUk7QUFBQSxVQUN4QyxXQUFXLEtBQUssQ0FBQyxHQUFHLElBQUksSUFBSSxJQUFJLEtBQUssSUFBSTtBQUFBLFVBQ3pDLFdBQVcsS0FBSyxDQUFDLEdBQUcsSUFBSSxJQUFJLElBQUksS0FBSyxJQUFJO0FBQUEsVUFDekMsV0FBVyxLQUFLLENBQUMsR0FBRyxJQUFJLElBQUksSUFBSSxLQUFLLElBQUk7QUFBQSxVQUN6QyxXQUFXLEtBQUssQ0FBQyxHQUFHLElBQUksSUFBSSxJQUFJLEtBQUssSUFBSTtBQUFBLFVBQ3pDLFdBQVcsS0FBSyxDQUFDLEdBQUcsSUFBSSxJQUFJLElBQUksS0FBSyxJQUFJO0FBQUEsVUFDekMsV0FBVyxLQUFLLENBQUMsR0FBRyxJQUFJLElBQUksSUFBSSxJQUFJLEtBQUs7QUFBQSxVQUN6QyxXQUFXLEtBQUssQ0FBQyxHQUFHLElBQUksSUFBSSxJQUFJLEtBQUssS0FBSztBQUFBLFVBQzFDLFdBQVcsS0FBSyxDQUFDLEdBQUcsSUFBSSxJQUFJLElBQUksS0FBSyxLQUFLO0FBQUEsVUFDMUMsV0FBVyxLQUFLLENBQUMsR0FBRyxJQUFJLElBQUksSUFBSSxLQUFLLEtBQUs7QUFBQSxVQUMxQyxXQUFXLEtBQUssQ0FBQyxHQUFHLElBQUksSUFBSSxJQUFJLEtBQUssS0FBSztBQUFBLFVBQzFDLFdBQVcsS0FBSyxDQUFDLEdBQUcsSUFBSSxJQUFJLElBQUksS0FBSyxLQUFLO0FBQUEsVUFDMUMsV0FBVyxLQUFLLENBQUMsR0FBRyxJQUFJLElBQUksSUFBSSxLQUFLLEtBQUs7QUFBQSxVQUMxQyxXQUFXLEtBQUssQ0FBQyxHQUFHLElBQUksSUFBSSxJQUFJLEtBQUssS0FBSztBQUFBLFVBQzFDLFdBQVcsS0FBSyxDQUFDLEdBQUcsSUFBSSxJQUFJLElBQUksS0FBSyxLQUFLO0FBQUEsVUFDMUMsV0FBVyxLQUFLLENBQUMsR0FBRyxJQUFJLElBQUksSUFBSSxLQUFLLEtBQUs7QUFBQSxVQUMxQyxXQUFXLEtBQUssQ0FBQyxHQUFHLElBQUksSUFBSSxJQUFJLEtBQUssS0FBSztBQUFBLFVBQzFDLFdBQVcsS0FBSyxDQUFDLEdBQUcsSUFBSSxJQUFJLElBQUksS0FBSyxLQUFLO0FBQUEsVUFDMUMsV0FBVyxLQUFLLENBQUMsR0FBRyxJQUFJLElBQUksSUFBSSxLQUFLLEtBQUs7QUFBQTtBQUc5QyxtQkFBVyx3QkFBd0IsTUFBTSxLQUFLO0FBQUEsVUFDMUMsV0FBVyxLQUFLLENBQUMsR0FBRztBQUFBLFVBQ3BCLFdBQVcsS0FBSyxDQUFDLEdBQUc7QUFBQSxVQUNwQixXQUFXLEtBQUssQ0FBQyxHQUFHO0FBQUEsVUFDcEIsV0FBVyxLQUFLLENBQUMsR0FBRztBQUFBLFVBQ3BCLFdBQVcsS0FBSyxDQUFDLEdBQUc7QUFBQSxVQUNwQixXQUFXLEtBQUssQ0FBQyxHQUFHO0FBQUEsVUFDcEIsV0FBVyxLQUFLLENBQUMsR0FBRztBQUFBLFVBQ3BCLFdBQVcsS0FBSyxDQUFDLEdBQUc7QUFBQSxVQUNwQixXQUFXLEtBQUssQ0FBQyxHQUFHO0FBQUEsVUFDcEIsV0FBVyxLQUFLLENBQUMsR0FBRztBQUFBLFVBQ3BCLFdBQVcsS0FBSyxDQUFDLEdBQUc7QUFBQSxVQUNwQixXQUFXLEtBQUssQ0FBQyxHQUFHO0FBQUEsVUFDcEIsV0FBVyxLQUFLLENBQUMsR0FBRztBQUFBLFVBQ3BCLFdBQVcsS0FBSyxDQUFDLEdBQUc7QUFBQSxVQUNwQixXQUFXLEtBQUssQ0FBQyxH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
